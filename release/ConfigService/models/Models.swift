// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccountAggregationSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
        case allAwsRegions = "AllAwsRegions"
        case awsRegions = "AwsRegions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountaggregationsourceaccountlist0 in accountIds {
                try accountIdsContainer.encode(accountaggregationsourceaccountlist0)
            }
        }
        if allAwsRegions != false {
            try encodeContainer.encode(allAwsRegions, forKey: .allAwsRegions)
        }
        if let awsRegions = awsRegions {
            var awsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsRegions)
            for aggregatorregionlist0 in awsRegions {
                try awsRegionsContainer.encode(aggregatorregionlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let allAwsRegionsDecoded = try containerValues.decode(Bool.self, forKey: .allAwsRegions)
        allAwsRegions = allAwsRegionsDecoded
        let awsRegionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .awsRegions)
        var awsRegionsDecoded0:[String]? = nil
        if let awsRegionsContainer = awsRegionsContainer {
            awsRegionsDecoded0 = [String]()
            for string0 in awsRegionsContainer {
                if let string0 = string0 {
                    awsRegionsDecoded0?.append(string0)
                }
            }
        }
        awsRegions = awsRegionsDecoded0
    }
}

extension AccountAggregationSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountAggregationSource(accountIds: \(String(describing: accountIds)), allAwsRegions: \(String(describing: allAwsRegions)), awsRegions: \(String(describing: awsRegions)))"}
}

/// <p>A collection of accounts and regions.</p>
public struct AccountAggregationSource: Equatable {
    /// <p>The 12-digit account ID of the account being aggregated.
    /// 		</p>
    public let accountIds: [String]?
    /// <p>If true, aggregate existing AWS Config regions and future
    /// 			regions.</p>
    public let allAwsRegions: Bool
    /// <p>The source regions being aggregated.</p>
    public let awsRegions: [String]?

    public init (
        accountIds: [String]? = nil,
        allAwsRegions: Bool = false,
        awsRegions: [String]? = nil
    )
    {
        self.accountIds = accountIds
        self.allAwsRegions = allAwsRegions
        self.awsRegions = awsRegions
    }
}

extension AggregateComplianceByConfigRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case awsRegion = "AwsRegion"
        case compliance = "Compliance"
        case configRuleName = "ConfigRuleName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let compliance = compliance {
            try encodeContainer.encode(compliance, forKey: .compliance)
        }
        if let configRuleName = configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let complianceDecoded = try containerValues.decodeIfPresent(Compliance.self, forKey: .compliance)
        compliance = complianceDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension AggregateComplianceByConfigRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AggregateComplianceByConfigRule(accountId: \(String(describing: accountId)), awsRegion: \(String(describing: awsRegion)), compliance: \(String(describing: compliance)), configRuleName: \(String(describing: configRuleName)))"}
}

/// <p>Indicates whether an AWS Config rule is compliant based on
/// 			account ID, region, compliance, and rule name.</p>
/// 		       <p>A rule is compliant if all of the resources that the rule
/// 			evaluated comply with it. It is noncompliant if any of these
/// 			resources do not comply.</p>
public struct AggregateComplianceByConfigRule: Equatable {
    /// <p>The 12-digit account ID of the source account.</p>
    public let accountId: String?
    /// <p>The source region from where the data is aggregated.</p>
    public let awsRegion: String?
    /// <p>Indicates whether an AWS resource or AWS Config rule is
    /// 			compliant and provides the number of contributors that affect the
    /// 			compliance.</p>
    public let compliance: Compliance?
    /// <p>The name of the AWS Config rule.</p>
    public let configRuleName: String?

    public init (
        accountId: String? = nil,
        awsRegion: String? = nil,
        compliance: Compliance? = nil,
        configRuleName: String? = nil
    )
    {
        self.accountId = accountId
        self.awsRegion = awsRegion
        self.compliance = compliance
        self.configRuleName = configRuleName
    }
}

extension AggregateComplianceByConformancePack: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case awsRegion = "AwsRegion"
        case compliance = "Compliance"
        case conformancePackName = "ConformancePackName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let compliance = compliance {
            try encodeContainer.encode(compliance, forKey: .compliance)
        }
        if let conformancePackName = conformancePackName {
            try encodeContainer.encode(conformancePackName, forKey: .conformancePackName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conformancePackName)
        conformancePackName = conformancePackNameDecoded
        let complianceDecoded = try containerValues.decodeIfPresent(AggregateConformancePackCompliance.self, forKey: .compliance)
        compliance = complianceDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension AggregateComplianceByConformancePack: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AggregateComplianceByConformancePack(accountId: \(String(describing: accountId)), awsRegion: \(String(describing: awsRegion)), compliance: \(String(describing: compliance)), conformancePackName: \(String(describing: conformancePackName)))"}
}

/// <p>Provides aggregate compliance of the conformance pack. Indicates whether a conformance pack is compliant based on the name of the conformance pack, account ID, and region.</p>
/// 		       <p>A conformance pack is compliant if all of the rules in a conformance packs are compliant. It is noncompliant if any of the rules are not compliant.
/// 			The compliance status of a conformance pack is INSUFFICIENT_DATA only if all rules within a conformance pack cannot be evaluated due to insufficient data.
/// 			If some of the rules in a conformance pack are compliant but the compliance status of other rules in that same conformance pack is INSUFFICIENT_DATA, the conformance pack shows compliant.</p>
public struct AggregateComplianceByConformancePack: Equatable {
    /// <p>The 12-digit AWS account ID of the source account.</p>
    public let accountId: String?
    /// <p>The source AWS Region from where the data is aggregated.</p>
    public let awsRegion: String?
    /// <p>The compliance status of the conformance pack.</p>
    public let compliance: AggregateConformancePackCompliance?
    /// <p>The name of the conformance pack.</p>
    public let conformancePackName: String?

    public init (
        accountId: String? = nil,
        awsRegion: String? = nil,
        compliance: AggregateConformancePackCompliance? = nil,
        conformancePackName: String? = nil
    )
    {
        self.accountId = accountId
        self.awsRegion = awsRegion
        self.compliance = compliance
        self.conformancePackName = conformancePackName
    }
}

extension AggregateComplianceCount: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceSummary = "ComplianceSummary"
        case groupName = "GroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceSummary = complianceSummary {
            try encodeContainer.encode(complianceSummary, forKey: .complianceSummary)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let complianceSummaryDecoded = try containerValues.decodeIfPresent(ComplianceSummary.self, forKey: .complianceSummary)
        complianceSummary = complianceSummaryDecoded
    }
}

extension AggregateComplianceCount: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AggregateComplianceCount(complianceSummary: \(String(describing: complianceSummary)), groupName: \(String(describing: groupName)))"}
}

/// <p>Returns the number of compliant and noncompliant rules for one
/// 			or more accounts and regions in an aggregator.</p>
public struct AggregateComplianceCount: Equatable {
    /// <p>The number of compliant and noncompliant AWS Config
    /// 			rules.</p>
    public let complianceSummary: ComplianceSummary?
    /// <p>The 12-digit account ID or region based on the GroupByKey
    /// 			value.</p>
    public let groupName: String?

    public init (
        complianceSummary: ComplianceSummary? = nil,
        groupName: String? = nil
    )
    {
        self.complianceSummary = complianceSummary
        self.groupName = groupName
    }
}

extension AggregateConformancePackCompliance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceType = "ComplianceType"
        case compliantRuleCount = "CompliantRuleCount"
        case nonCompliantRuleCount = "NonCompliantRuleCount"
        case totalRuleCount = "TotalRuleCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
        if compliantRuleCount != 0 {
            try encodeContainer.encode(compliantRuleCount, forKey: .compliantRuleCount)
        }
        if nonCompliantRuleCount != 0 {
            try encodeContainer.encode(nonCompliantRuleCount, forKey: .nonCompliantRuleCount)
        }
        if totalRuleCount != 0 {
            try encodeContainer.encode(totalRuleCount, forKey: .totalRuleCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ConformancePackComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let compliantRuleCountDecoded = try containerValues.decode(Int.self, forKey: .compliantRuleCount)
        compliantRuleCount = compliantRuleCountDecoded
        let nonCompliantRuleCountDecoded = try containerValues.decode(Int.self, forKey: .nonCompliantRuleCount)
        nonCompliantRuleCount = nonCompliantRuleCountDecoded
        let totalRuleCountDecoded = try containerValues.decode(Int.self, forKey: .totalRuleCount)
        totalRuleCount = totalRuleCountDecoded
    }
}

extension AggregateConformancePackCompliance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AggregateConformancePackCompliance(complianceType: \(String(describing: complianceType)), compliantRuleCount: \(String(describing: compliantRuleCount)), nonCompliantRuleCount: \(String(describing: nonCompliantRuleCount)), totalRuleCount: \(String(describing: totalRuleCount)))"}
}

/// <p>Provides the number of compliant and noncompliant rules within a conformance pack.
/// 			Also provides the compliance status of the conformance pack and the total rule count which includes compliant rules, noncompliant rules, and rules that cannot be evaluated due to insufficient data.</p>
/// 		
/// 		       <p>A conformance pack is compliant if all of the rules in a conformance packs are compliant. It is noncompliant if any of the rules are not compliant.
/// 			The compliance status of a conformance pack is INSUFFICIENT_DATA only if all rules within a conformance pack cannot be evaluated due to insufficient data.
/// 			If some of the rules in a conformance pack are compliant but the compliance status of other rules in that same conformance pack is INSUFFICIENT_DATA, the conformance pack shows compliant.</p>
public struct AggregateConformancePackCompliance: Equatable {
    /// <p>The compliance status of the conformance pack.</p>
    public let complianceType: ConformancePackComplianceType?
    /// <p>The number of compliant AWS Config Rules.</p>
    public let compliantRuleCount: Int
    /// <p>The number of noncompliant AWS Config Rules.</p>
    public let nonCompliantRuleCount: Int
    /// <p>Total number of compliant rules, noncompliant rules, and the rules that do not have any applicable resources to evaluate upon resulting in insufficient data.</p>
    public let totalRuleCount: Int

    public init (
        complianceType: ConformancePackComplianceType? = nil,
        compliantRuleCount: Int = 0,
        nonCompliantRuleCount: Int = 0,
        totalRuleCount: Int = 0
    )
    {
        self.complianceType = complianceType
        self.compliantRuleCount = compliantRuleCount
        self.nonCompliantRuleCount = nonCompliantRuleCount
        self.totalRuleCount = totalRuleCount
    }
}

extension AggregateConformancePackComplianceCount: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case compliantConformancePackCount = "CompliantConformancePackCount"
        case nonCompliantConformancePackCount = "NonCompliantConformancePackCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if compliantConformancePackCount != 0 {
            try encodeContainer.encode(compliantConformancePackCount, forKey: .compliantConformancePackCount)
        }
        if nonCompliantConformancePackCount != 0 {
            try encodeContainer.encode(nonCompliantConformancePackCount, forKey: .nonCompliantConformancePackCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compliantConformancePackCountDecoded = try containerValues.decode(Int.self, forKey: .compliantConformancePackCount)
        compliantConformancePackCount = compliantConformancePackCountDecoded
        let nonCompliantConformancePackCountDecoded = try containerValues.decode(Int.self, forKey: .nonCompliantConformancePackCount)
        nonCompliantConformancePackCount = nonCompliantConformancePackCountDecoded
    }
}

extension AggregateConformancePackComplianceCount: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AggregateConformancePackComplianceCount(compliantConformancePackCount: \(String(describing: compliantConformancePackCount)), nonCompliantConformancePackCount: \(String(describing: nonCompliantConformancePackCount)))"}
}

/// <p>The number of conformance packs that are compliant and noncompliant.</p>
public struct AggregateConformancePackComplianceCount: Equatable {
    /// <p>Number of compliant conformance packs.</p>
    public let compliantConformancePackCount: Int
    /// <p>Number of noncompliant conformance packs.</p>
    public let nonCompliantConformancePackCount: Int

    public init (
        compliantConformancePackCount: Int = 0,
        nonCompliantConformancePackCount: Int = 0
    )
    {
        self.compliantConformancePackCount = compliantConformancePackCount
        self.nonCompliantConformancePackCount = nonCompliantConformancePackCount
    }
}

extension AggregateConformancePackComplianceFilters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case awsRegion = "AwsRegion"
        case complianceType = "ComplianceType"
        case conformancePackName = "ConformancePackName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
        if let conformancePackName = conformancePackName {
            try encodeContainer.encode(conformancePackName, forKey: .conformancePackName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conformancePackName)
        conformancePackName = conformancePackNameDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ConformancePackComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension AggregateConformancePackComplianceFilters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AggregateConformancePackComplianceFilters(accountId: \(String(describing: accountId)), awsRegion: \(String(describing: awsRegion)), complianceType: \(String(describing: complianceType)), conformancePackName: \(String(describing: conformancePackName)))"}
}

/// <p>Filters the conformance packs based on an account ID, region, compliance type, and the name of the conformance pack.</p>
public struct AggregateConformancePackComplianceFilters: Equatable {
    /// <p>The 12-digit AWS account ID of the source account.</p>
    public let accountId: String?
    /// <p>The source AWS Region from where the data is aggregated.</p>
    public let awsRegion: String?
    /// <p>The compliance status of the conformance pack.</p>
    public let complianceType: ConformancePackComplianceType?
    /// <p>The name of the conformance pack.</p>
    public let conformancePackName: String?

    public init (
        accountId: String? = nil,
        awsRegion: String? = nil,
        complianceType: ConformancePackComplianceType? = nil,
        conformancePackName: String? = nil
    )
    {
        self.accountId = accountId
        self.awsRegion = awsRegion
        self.complianceType = complianceType
        self.conformancePackName = conformancePackName
    }
}

extension AggregateConformancePackComplianceSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceSummary = "ComplianceSummary"
        case groupName = "GroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceSummary = complianceSummary {
            try encodeContainer.encode(complianceSummary, forKey: .complianceSummary)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceSummaryDecoded = try containerValues.decodeIfPresent(AggregateConformancePackComplianceCount.self, forKey: .complianceSummary)
        complianceSummary = complianceSummaryDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
    }
}

extension AggregateConformancePackComplianceSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AggregateConformancePackComplianceSummary(complianceSummary: \(String(describing: complianceSummary)), groupName: \(String(describing: groupName)))"}
}

/// <p>Provides a summary of compliance based on either account ID or region. </p>
public struct AggregateConformancePackComplianceSummary: Equatable {
    /// <p>Returns an <code>AggregateConformancePackComplianceCount</code> object. </p>
    public let complianceSummary: AggregateConformancePackComplianceCount?
    /// <p>Groups the result based on AWS Account ID or AWS Region.</p>
    public let groupName: String?

    public init (
        complianceSummary: AggregateConformancePackComplianceCount? = nil,
        groupName: String? = nil
    )
    {
        self.complianceSummary = complianceSummary
        self.groupName = groupName
    }
}

extension AggregateConformancePackComplianceSummaryFilters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case awsRegion = "AwsRegion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension AggregateConformancePackComplianceSummaryFilters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AggregateConformancePackComplianceSummaryFilters(accountId: \(String(describing: accountId)), awsRegion: \(String(describing: awsRegion)))"}
}

/// <p>Filters the results based on account ID and region. </p>
public struct AggregateConformancePackComplianceSummaryFilters: Equatable {
    /// <p>The 12-digit AWS account ID of the source account.</p>
    public let accountId: String?
    /// <p>The source AWS Region from where the data is aggregated.</p>
    public let awsRegion: String?

    public init (
        accountId: String? = nil,
        awsRegion: String? = nil
    )
    {
        self.accountId = accountId
        self.awsRegion = awsRegion
    }
}

public enum AggregateConformancePackComplianceSummaryGroupKey {
    case accountId
    case awsRegion
    case sdkUnknown(String)
}

extension AggregateConformancePackComplianceSummaryGroupKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AggregateConformancePackComplianceSummaryGroupKey] {
        return [
            .accountId,
            .awsRegion,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accountId: return "ACCOUNT_ID"
        case .awsRegion: return "AWS_REGION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AggregateConformancePackComplianceSummaryGroupKey(rawValue: rawValue) ?? AggregateConformancePackComplianceSummaryGroupKey.sdkUnknown(rawValue)
    }
}

extension AggregateEvaluationResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case annotation = "Annotation"
        case awsRegion = "AwsRegion"
        case complianceType = "ComplianceType"
        case configRuleInvokedTime = "ConfigRuleInvokedTime"
        case evaluationResultIdentifier = "EvaluationResultIdentifier"
        case resultRecordedTime = "ResultRecordedTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let annotation = annotation {
            try encodeContainer.encode(annotation, forKey: .annotation)
        }
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
        if let configRuleInvokedTime = configRuleInvokedTime {
            try encodeContainer.encode(configRuleInvokedTime.timeIntervalSince1970, forKey: .configRuleInvokedTime)
        }
        if let evaluationResultIdentifier = evaluationResultIdentifier {
            try encodeContainer.encode(evaluationResultIdentifier, forKey: .evaluationResultIdentifier)
        }
        if let resultRecordedTime = resultRecordedTime {
            try encodeContainer.encode(resultRecordedTime.timeIntervalSince1970, forKey: .resultRecordedTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationResultIdentifierDecoded = try containerValues.decodeIfPresent(EvaluationResultIdentifier.self, forKey: .evaluationResultIdentifier)
        evaluationResultIdentifier = evaluationResultIdentifierDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let resultRecordedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .resultRecordedTime)
        resultRecordedTime = resultRecordedTimeDecoded
        let configRuleInvokedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .configRuleInvokedTime)
        configRuleInvokedTime = configRuleInvokedTimeDecoded
        let annotationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .annotation)
        annotation = annotationDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension AggregateEvaluationResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AggregateEvaluationResult(accountId: \(String(describing: accountId)), annotation: \(String(describing: annotation)), awsRegion: \(String(describing: awsRegion)), complianceType: \(String(describing: complianceType)), configRuleInvokedTime: \(String(describing: configRuleInvokedTime)), evaluationResultIdentifier: \(String(describing: evaluationResultIdentifier)), resultRecordedTime: \(String(describing: resultRecordedTime)))"}
}

/// <p>The details of an AWS Config evaluation for an account ID and
/// 			region in an aggregator. Provides the AWS resource that was
/// 			evaluated, the compliance of the resource, related time stamps, and
/// 			supplementary information. </p>
public struct AggregateEvaluationResult: Equatable {
    /// <p>The 12-digit account ID of the source account.</p>
    public let accountId: String?
    /// <p>Supplementary information about how the agrregate evaluation
    /// 			determined the compliance.</p>
    public let annotation: String?
    /// <p>The source region from where the data is aggregated.</p>
    public let awsRegion: String?
    /// <p>The resource compliance status.</p>
    /// 		       <p>For the <code>AggregationEvaluationResult</code> data type, AWS
    /// 			Config supports only the <code>COMPLIANT</code> and
    /// 				<code>NON_COMPLIANT</code>. AWS Config does not support the
    /// 				<code>NOT_APPLICABLE</code> and <code>INSUFFICIENT_DATA</code>
    /// 			value.</p>
    public let complianceType: ComplianceType?
    /// <p>The time when the AWS Config rule evaluated the AWS
    /// 			resource.</p>
    public let configRuleInvokedTime: Date?
    /// <p>Uniquely identifies the evaluation result.</p>
    public let evaluationResultIdentifier: EvaluationResultIdentifier?
    /// <p>The time when AWS Config recorded the aggregate evaluation
    /// 			result.</p>
    public let resultRecordedTime: Date?

    public init (
        accountId: String? = nil,
        annotation: String? = nil,
        awsRegion: String? = nil,
        complianceType: ComplianceType? = nil,
        configRuleInvokedTime: Date? = nil,
        evaluationResultIdentifier: EvaluationResultIdentifier? = nil,
        resultRecordedTime: Date? = nil
    )
    {
        self.accountId = accountId
        self.annotation = annotation
        self.awsRegion = awsRegion
        self.complianceType = complianceType
        self.configRuleInvokedTime = configRuleInvokedTime
        self.evaluationResultIdentifier = evaluationResultIdentifier
        self.resultRecordedTime = resultRecordedTime
    }
}

extension AggregateResourceIdentifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
        case sourceAccountId = "SourceAccountId"
        case sourceRegion = "SourceRegion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let sourceAccountId = sourceAccountId {
            try encodeContainer.encode(sourceAccountId, forKey: .sourceAccountId)
        }
        if let sourceRegion = sourceRegion {
            try encodeContainer.encode(sourceRegion, forKey: .sourceRegion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceAccountId)
        sourceAccountId = sourceAccountIdDecoded
        let sourceRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceRegion)
        sourceRegion = sourceRegionDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension AggregateResourceIdentifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AggregateResourceIdentifier(resourceId: \(String(describing: resourceId)), resourceName: \(String(describing: resourceName)), resourceType: \(String(describing: resourceType)), sourceAccountId: \(String(describing: sourceAccountId)), sourceRegion: \(String(describing: sourceRegion)))"}
}

/// <p>The details that identify a resource that is collected by AWS Config aggregator, including the resource type, ID, (if available) the custom resource name, the source account, and source region.</p>
public struct AggregateResourceIdentifier: Equatable {
    /// <p>The ID of the AWS resource.</p>
    public let resourceId: String?
    /// <p>The name of the AWS resource.</p>
    public let resourceName: String?
    /// <p>The type of the AWS resource.</p>
    public let resourceType: ResourceType?
    /// <p>The 12-digit account ID of the source account.</p>
    public let sourceAccountId: String?
    /// <p>The source region where data is aggregated.</p>
    public let sourceRegion: String?

    public init (
        resourceId: String? = nil,
        resourceName: String? = nil,
        resourceType: ResourceType? = nil,
        sourceAccountId: String? = nil,
        sourceRegion: String? = nil
    )
    {
        self.resourceId = resourceId
        self.resourceName = resourceName
        self.resourceType = resourceType
        self.sourceAccountId = sourceAccountId
        self.sourceRegion = sourceRegion
    }
}

extension AggregatedSourceStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsRegion = "AwsRegion"
        case lastErrorCode = "LastErrorCode"
        case lastErrorMessage = "LastErrorMessage"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateTime = "LastUpdateTime"
        case sourceId = "SourceId"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let lastErrorCode = lastErrorCode {
            try encodeContainer.encode(lastErrorCode, forKey: .lastErrorCode)
        }
        if let lastErrorMessage = lastErrorMessage {
            try encodeContainer.encode(lastErrorMessage, forKey: .lastErrorMessage)
        }
        if let lastUpdateStatus = lastUpdateStatus {
            try encodeContainer.encode(lastUpdateStatus.rawValue, forKey: .lastUpdateStatus)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let sourceId = sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(AggregatedSourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(AggregatedSourceStatusType.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let lastErrorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastErrorCode)
        lastErrorCode = lastErrorCodeDecoded
        let lastErrorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastErrorMessage)
        lastErrorMessage = lastErrorMessageDecoded
    }
}

extension AggregatedSourceStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AggregatedSourceStatus(awsRegion: \(String(describing: awsRegion)), lastErrorCode: \(String(describing: lastErrorCode)), lastErrorMessage: \(String(describing: lastErrorMessage)), lastUpdateStatus: \(String(describing: lastUpdateStatus)), lastUpdateTime: \(String(describing: lastUpdateTime)), sourceId: \(String(describing: sourceId)), sourceType: \(String(describing: sourceType)))"}
}

/// <p>The current sync status between the source and the aggregator
/// 			account.</p>
public struct AggregatedSourceStatus: Equatable {
    /// <p>The region authorized to collect aggregated data.</p>
    public let awsRegion: String?
    /// <p>The error code that AWS Config returned when the source account
    /// 			aggregation last failed.</p>
    public let lastErrorCode: String?
    /// <p>The message indicating that the source account aggregation
    /// 			failed due to an error.</p>
    public let lastErrorMessage: String?
    /// <p>Filters the last updated status type.</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>Valid value FAILED indicates errors while moving
    /// 					data.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Valid value SUCCEEDED indicates the data was
    /// 					successfully moved.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Valid value OUTDATED indicates the data is not the most
    /// 					recent.</p>
    /// 			         </li>
    ///          </ul>
    public let lastUpdateStatus: AggregatedSourceStatusType?
    /// <p>The time of the last update.</p>
    public let lastUpdateTime: Date?
    /// <p>The source account ID or an organization.</p>
    public let sourceId: String?
    /// <p>The source account or an organization.</p>
    public let sourceType: AggregatedSourceType?

    public init (
        awsRegion: String? = nil,
        lastErrorCode: String? = nil,
        lastErrorMessage: String? = nil,
        lastUpdateStatus: AggregatedSourceStatusType? = nil,
        lastUpdateTime: Date? = nil,
        sourceId: String? = nil,
        sourceType: AggregatedSourceType? = nil
    )
    {
        self.awsRegion = awsRegion
        self.lastErrorCode = lastErrorCode
        self.lastErrorMessage = lastErrorMessage
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateTime = lastUpdateTime
        self.sourceId = sourceId
        self.sourceType = sourceType
    }
}

public enum AggregatedSourceStatusType {
    case failed
    case outdated
    case succeeded
    case sdkUnknown(String)
}

extension AggregatedSourceStatusType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AggregatedSourceStatusType] {
        return [
            .failed,
            .outdated,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .outdated: return "OUTDATED"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AggregatedSourceStatusType(rawValue: rawValue) ?? AggregatedSourceStatusType.sdkUnknown(rawValue)
    }
}

public enum AggregatedSourceType {
    case account
    case organization
    case sdkUnknown(String)
}

extension AggregatedSourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AggregatedSourceType] {
        return [
            .account,
            .organization,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .account: return "ACCOUNT"
        case .organization: return "ORGANIZATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AggregatedSourceType(rawValue: rawValue) ?? AggregatedSourceType.sdkUnknown(rawValue)
    }
}

extension AggregationAuthorization: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aggregationAuthorizationArn = "AggregationAuthorizationArn"
        case authorizedAccountId = "AuthorizedAccountId"
        case authorizedAwsRegion = "AuthorizedAwsRegion"
        case creationTime = "CreationTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationAuthorizationArn = aggregationAuthorizationArn {
            try encodeContainer.encode(aggregationAuthorizationArn, forKey: .aggregationAuthorizationArn)
        }
        if let authorizedAccountId = authorizedAccountId {
            try encodeContainer.encode(authorizedAccountId, forKey: .authorizedAccountId)
        }
        if let authorizedAwsRegion = authorizedAwsRegion {
            try encodeContainer.encode(authorizedAwsRegion, forKey: .authorizedAwsRegion)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregationAuthorizationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aggregationAuthorizationArn)
        aggregationAuthorizationArn = aggregationAuthorizationArnDecoded
        let authorizedAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizedAccountId)
        authorizedAccountId = authorizedAccountIdDecoded
        let authorizedAwsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizedAwsRegion)
        authorizedAwsRegion = authorizedAwsRegionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension AggregationAuthorization: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AggregationAuthorization(aggregationAuthorizationArn: \(String(describing: aggregationAuthorizationArn)), authorizedAccountId: \(String(describing: authorizedAccountId)), authorizedAwsRegion: \(String(describing: authorizedAwsRegion)), creationTime: \(String(describing: creationTime)))"}
}

/// <p>An object that represents the authorizations granted to
/// 			aggregator accounts and regions.</p>
public struct AggregationAuthorization: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the aggregation
    /// 			object.</p>
    public let aggregationAuthorizationArn: String?
    /// <p>The 12-digit account ID of the account authorized to aggregate
    /// 			data.</p>
    public let authorizedAccountId: String?
    /// <p>The region authorized to collect aggregated data.</p>
    public let authorizedAwsRegion: String?
    /// <p>The time stamp when the aggregation authorization was
    /// 			created.</p>
    public let creationTime: Date?

    public init (
        aggregationAuthorizationArn: String? = nil,
        authorizedAccountId: String? = nil,
        authorizedAwsRegion: String? = nil,
        creationTime: Date? = nil
    )
    {
        self.aggregationAuthorizationArn = aggregationAuthorizationArn
        self.authorizedAccountId = authorizedAccountId
        self.authorizedAwsRegion = authorizedAwsRegion
        self.creationTime = creationTime
    }
}

extension BaseConfigurationItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId
        case arn
        case availabilityZone
        case awsRegion
        case configuration
        case configurationItemCaptureTime
        case configurationItemStatus
        case configurationStateId
        case resourceCreationTime
        case resourceId
        case resourceName
        case resourceType
        case supplementaryConfiguration
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let configurationItemCaptureTime = configurationItemCaptureTime {
            try encodeContainer.encode(configurationItemCaptureTime.timeIntervalSince1970, forKey: .configurationItemCaptureTime)
        }
        if let configurationItemStatus = configurationItemStatus {
            try encodeContainer.encode(configurationItemStatus.rawValue, forKey: .configurationItemStatus)
        }
        if let configurationStateId = configurationStateId {
            try encodeContainer.encode(configurationStateId, forKey: .configurationStateId)
        }
        if let resourceCreationTime = resourceCreationTime {
            try encodeContainer.encode(resourceCreationTime.timeIntervalSince1970, forKey: .resourceCreationTime)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let supplementaryConfiguration = supplementaryConfiguration {
            var supplementaryConfigurationContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .supplementaryConfiguration)
            for (dictKey0, supplementaryconfiguration0) in supplementaryConfiguration {
                try supplementaryConfigurationContainer.encode(supplementaryconfiguration0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let configurationItemCaptureTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .configurationItemCaptureTime)
        configurationItemCaptureTime = configurationItemCaptureTimeDecoded
        let configurationItemStatusDecoded = try containerValues.decodeIfPresent(ConfigurationItemStatus.self, forKey: .configurationItemStatus)
        configurationItemStatus = configurationItemStatusDecoded
        let configurationStateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationStateId)
        configurationStateId = configurationStateIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let resourceCreationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .resourceCreationTime)
        resourceCreationTime = resourceCreationTimeDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configuration)
        configuration = configurationDecoded
        let supplementaryConfigurationContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .supplementaryConfiguration)
        var supplementaryConfigurationDecoded0: [String:String]? = nil
        if let supplementaryConfigurationContainer = supplementaryConfigurationContainer {
            supplementaryConfigurationDecoded0 = [String:String]()
            for (key0, supplementaryconfigurationvalue0) in supplementaryConfigurationContainer {
                if let supplementaryconfigurationvalue0 = supplementaryconfigurationvalue0 {
                    supplementaryConfigurationDecoded0?[key0] = supplementaryconfigurationvalue0
                }
            }
        }
        supplementaryConfiguration = supplementaryConfigurationDecoded0
    }
}

extension BaseConfigurationItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BaseConfigurationItem(accountId: \(String(describing: accountId)), arn: \(String(describing: arn)), availabilityZone: \(String(describing: availabilityZone)), awsRegion: \(String(describing: awsRegion)), configuration: \(String(describing: configuration)), configurationItemCaptureTime: \(String(describing: configurationItemCaptureTime)), configurationItemStatus: \(String(describing: configurationItemStatus)), configurationStateId: \(String(describing: configurationStateId)), resourceCreationTime: \(String(describing: resourceCreationTime)), resourceId: \(String(describing: resourceId)), resourceName: \(String(describing: resourceName)), resourceType: \(String(describing: resourceType)), supplementaryConfiguration: \(String(describing: supplementaryConfiguration)), version: \(String(describing: version)))"}
}

/// <p>The detailed configuration of a specified resource.</p>
public struct BaseConfigurationItem: Equatable {
    /// <p>The 12-digit AWS account ID associated with the resource.</p>
    public let accountId: String?
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let arn: String?
    /// <p>The Availability Zone associated with the resource.</p>
    public let availabilityZone: String?
    /// <p>The region where the resource resides.</p>
    public let awsRegion: String?
    /// <p>The description of the resource configuration.</p>
    public let configuration: String?
    /// <p>The time when the configuration recording was initiated.</p>
    public let configurationItemCaptureTime: Date?
    /// <p>The configuration item status. The valid values are:</p>
    /// 		
    /// 		       <ul>
    ///             <li>
    ///                <p>OK – The resource configuration has been updated</p>
    ///             </li>
    ///             <li>
    ///                <p>ResourceDiscovered – The resource was newly discovered</p>
    ///             </li>
    ///             <li>
    ///                <p>ResourceNotRecorded – The resource was discovered but its configuration was not recorded since the recorder excludes the recording of resources of this type</p>
    ///             </li>
    ///             <li>
    ///                <p>ResourceDeleted – The resource was deleted</p>
    ///             </li>
    ///             <li>
    ///                <p>ResourceDeletedNotRecorded – The resource was deleted but its configuration was not recorded since the recorder excludes the recording of resources of this type</p>
    ///             </li>
    ///          </ul>
    /// 		       <note>
    ///             <p>The CIs do not incur any cost.</p>
    ///          </note>
    public let configurationItemStatus: ConfigurationItemStatus?
    /// <p>An identifier that indicates the ordering of the configuration
    /// 			items of a resource.</p>
    public let configurationStateId: String?
    /// <p>The time stamp when the resource was created.</p>
    public let resourceCreationTime: Date?
    /// <p>The ID of the resource (for example., sg-xxxxxx).</p>
    public let resourceId: String?
    /// <p>The custom name of the resource, if available.</p>
    public let resourceName: String?
    /// <p>The type of AWS resource.</p>
    public let resourceType: ResourceType?
    /// <p>Configuration attributes that AWS Config returns for certain
    /// 			resource types to supplement the information returned for the
    /// 			configuration parameter.</p>
    public let supplementaryConfiguration: [String:String]?
    /// <p>The version number of the resource configuration.</p>
    public let version: String?

    public init (
        accountId: String? = nil,
        arn: String? = nil,
        availabilityZone: String? = nil,
        awsRegion: String? = nil,
        configuration: String? = nil,
        configurationItemCaptureTime: Date? = nil,
        configurationItemStatus: ConfigurationItemStatus? = nil,
        configurationStateId: String? = nil,
        resourceCreationTime: Date? = nil,
        resourceId: String? = nil,
        resourceName: String? = nil,
        resourceType: ResourceType? = nil,
        supplementaryConfiguration: [String:String]? = nil,
        version: String? = nil
    )
    {
        self.accountId = accountId
        self.arn = arn
        self.availabilityZone = availabilityZone
        self.awsRegion = awsRegion
        self.configuration = configuration
        self.configurationItemCaptureTime = configurationItemCaptureTime
        self.configurationItemStatus = configurationItemStatus
        self.configurationStateId = configurationStateId
        self.resourceCreationTime = resourceCreationTime
        self.resourceId = resourceId
        self.resourceName = resourceName
        self.resourceType = resourceType
        self.supplementaryConfiguration = supplementaryConfiguration
        self.version = version
    }
}

public struct BatchGetAggregateResourceConfigInputBodyMiddleware: Middleware {
    public let id: String = "BatchGetAggregateResourceConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetAggregateResourceConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetAggregateResourceConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetAggregateResourceConfigInput>
    public typealias MOutput = OperationOutput<BatchGetAggregateResourceConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetAggregateResourceConfigOutputError>
}

extension BatchGetAggregateResourceConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetAggregateResourceConfigInput(configurationAggregatorName: \(String(describing: configurationAggregatorName)), resourceIdentifiers: \(String(describing: resourceIdentifiers)))"}
}

extension BatchGetAggregateResourceConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case resourceIdentifiers = "ResourceIdentifiers"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationAggregatorName = configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if let resourceIdentifiers = resourceIdentifiers {
            var resourceIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIdentifiers)
            for resourceidentifierslist0 in resourceIdentifiers {
                try resourceIdentifiersContainer.encode(resourceidentifierslist0)
            }
        }
    }
}

public struct BatchGetAggregateResourceConfigInputHeadersMiddleware: Middleware {
    public let id: String = "BatchGetAggregateResourceConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetAggregateResourceConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetAggregateResourceConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetAggregateResourceConfigInput>
    public typealias MOutput = OperationOutput<BatchGetAggregateResourceConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetAggregateResourceConfigOutputError>
}

public struct BatchGetAggregateResourceConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchGetAggregateResourceConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetAggregateResourceConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetAggregateResourceConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetAggregateResourceConfigInput>
    public typealias MOutput = OperationOutput<BatchGetAggregateResourceConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetAggregateResourceConfigOutputError>
}

public struct BatchGetAggregateResourceConfigInput: Equatable {
    /// <p>The name of the configuration aggregator.</p>
    public let configurationAggregatorName: String?
    /// <p>A list of aggregate ResourceIdentifiers objects. </p>
    public let resourceIdentifiers: [AggregateResourceIdentifier]?

    public init (
        configurationAggregatorName: String? = nil,
        resourceIdentifiers: [AggregateResourceIdentifier]? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.resourceIdentifiers = resourceIdentifiers
    }
}

struct BatchGetAggregateResourceConfigInputBody: Equatable {
    public let configurationAggregatorName: String?
    public let resourceIdentifiers: [AggregateResourceIdentifier]?
}

extension BatchGetAggregateResourceConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case resourceIdentifiers = "ResourceIdentifiers"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let resourceIdentifiersContainer = try containerValues.decodeIfPresent([AggregateResourceIdentifier?].self, forKey: .resourceIdentifiers)
        var resourceIdentifiersDecoded0:[AggregateResourceIdentifier]? = nil
        if let resourceIdentifiersContainer = resourceIdentifiersContainer {
            resourceIdentifiersDecoded0 = [AggregateResourceIdentifier]()
            for structure0 in resourceIdentifiersContainer {
                if let structure0 = structure0 {
                    resourceIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        resourceIdentifiers = resourceIdentifiersDecoded0
    }
}

extension BatchGetAggregateResourceConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetAggregateResourceConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetAggregateResourceConfigOutputError: Equatable {
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetAggregateResourceConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetAggregateResourceConfigOutputResponse(baseConfigurationItems: \(String(describing: baseConfigurationItems)), unprocessedResourceIdentifiers: \(String(describing: unprocessedResourceIdentifiers)))"}
}

extension BatchGetAggregateResourceConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchGetAggregateResourceConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.baseConfigurationItems = output.baseConfigurationItems
            self.unprocessedResourceIdentifiers = output.unprocessedResourceIdentifiers
        } else {
            self.baseConfigurationItems = nil
            self.unprocessedResourceIdentifiers = nil
        }
    }
}

public struct BatchGetAggregateResourceConfigOutputResponse: Equatable {
    /// <p>A list that contains the current configuration of one or more resources.</p>
    public let baseConfigurationItems: [BaseConfigurationItem]?
    /// <p>A list of resource identifiers that were not processed with current scope. The list is empty if all the resources are processed.</p>
    public let unprocessedResourceIdentifiers: [AggregateResourceIdentifier]?

    public init (
        baseConfigurationItems: [BaseConfigurationItem]? = nil,
        unprocessedResourceIdentifiers: [AggregateResourceIdentifier]? = nil
    )
    {
        self.baseConfigurationItems = baseConfigurationItems
        self.unprocessedResourceIdentifiers = unprocessedResourceIdentifiers
    }
}

struct BatchGetAggregateResourceConfigOutputResponseBody: Equatable {
    public let baseConfigurationItems: [BaseConfigurationItem]?
    public let unprocessedResourceIdentifiers: [AggregateResourceIdentifier]?
}

extension BatchGetAggregateResourceConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baseConfigurationItems = "BaseConfigurationItems"
        case unprocessedResourceIdentifiers = "UnprocessedResourceIdentifiers"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseConfigurationItemsContainer = try containerValues.decodeIfPresent([BaseConfigurationItem?].self, forKey: .baseConfigurationItems)
        var baseConfigurationItemsDecoded0:[BaseConfigurationItem]? = nil
        if let baseConfigurationItemsContainer = baseConfigurationItemsContainer {
            baseConfigurationItemsDecoded0 = [BaseConfigurationItem]()
            for structure0 in baseConfigurationItemsContainer {
                if let structure0 = structure0 {
                    baseConfigurationItemsDecoded0?.append(structure0)
                }
            }
        }
        baseConfigurationItems = baseConfigurationItemsDecoded0
        let unprocessedResourceIdentifiersContainer = try containerValues.decodeIfPresent([AggregateResourceIdentifier?].self, forKey: .unprocessedResourceIdentifiers)
        var unprocessedResourceIdentifiersDecoded0:[AggregateResourceIdentifier]? = nil
        if let unprocessedResourceIdentifiersContainer = unprocessedResourceIdentifiersContainer {
            unprocessedResourceIdentifiersDecoded0 = [AggregateResourceIdentifier]()
            for structure0 in unprocessedResourceIdentifiersContainer {
                if let structure0 = structure0 {
                    unprocessedResourceIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        unprocessedResourceIdentifiers = unprocessedResourceIdentifiersDecoded0
    }
}

public struct BatchGetResourceConfigInputBodyMiddleware: Middleware {
    public let id: String = "BatchGetResourceConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetResourceConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetResourceConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetResourceConfigInput>
    public typealias MOutput = OperationOutput<BatchGetResourceConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetResourceConfigOutputError>
}

extension BatchGetResourceConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetResourceConfigInput(resourceKeys: \(String(describing: resourceKeys)))"}
}

extension BatchGetResourceConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceKeys
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceKeys = resourceKeys {
            var resourceKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceKeys)
            for resourcekeys0 in resourceKeys {
                try resourceKeysContainer.encode(resourcekeys0)
            }
        }
    }
}

public struct BatchGetResourceConfigInputHeadersMiddleware: Middleware {
    public let id: String = "BatchGetResourceConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetResourceConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetResourceConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetResourceConfigInput>
    public typealias MOutput = OperationOutput<BatchGetResourceConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetResourceConfigOutputError>
}

public struct BatchGetResourceConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchGetResourceConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetResourceConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetResourceConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetResourceConfigInput>
    public typealias MOutput = OperationOutput<BatchGetResourceConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetResourceConfigOutputError>
}

public struct BatchGetResourceConfigInput: Equatable {
    /// <p>A list of resource keys to be processed with the current
    /// 			request. Each element in the list consists of the resource type and
    /// 			resource ID.</p>
    public let resourceKeys: [ResourceKey]?

    public init (
        resourceKeys: [ResourceKey]? = nil
    )
    {
        self.resourceKeys = resourceKeys
    }
}

struct BatchGetResourceConfigInputBody: Equatable {
    public let resourceKeys: [ResourceKey]?
}

extension BatchGetResourceConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceKeys
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceKeysContainer = try containerValues.decodeIfPresent([ResourceKey?].self, forKey: .resourceKeys)
        var resourceKeysDecoded0:[ResourceKey]? = nil
        if let resourceKeysContainer = resourceKeysContainer {
            resourceKeysDecoded0 = [ResourceKey]()
            for structure0 in resourceKeysContainer {
                if let structure0 = structure0 {
                    resourceKeysDecoded0?.append(structure0)
                }
            }
        }
        resourceKeys = resourceKeysDecoded0
    }
}

extension BatchGetResourceConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetResourceConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoAvailableConfigurationRecorderException" : self = .noAvailableConfigurationRecorderException(try NoAvailableConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetResourceConfigOutputError: Equatable {
    case noAvailableConfigurationRecorderException(NoAvailableConfigurationRecorderException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetResourceConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetResourceConfigOutputResponse(baseConfigurationItems: \(String(describing: baseConfigurationItems)), unprocessedResourceKeys: \(String(describing: unprocessedResourceKeys)))"}
}

extension BatchGetResourceConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchGetResourceConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.baseConfigurationItems = output.baseConfigurationItems
            self.unprocessedResourceKeys = output.unprocessedResourceKeys
        } else {
            self.baseConfigurationItems = nil
            self.unprocessedResourceKeys = nil
        }
    }
}

public struct BatchGetResourceConfigOutputResponse: Equatable {
    /// <p>A list that contains the current configuration of one or more
    /// 			resources.</p>
    public let baseConfigurationItems: [BaseConfigurationItem]?
    /// <p>A list of resource keys that were not processed with the
    /// 			current response. The unprocessesResourceKeys value is in the same
    /// 			form as ResourceKeys, so the value can be directly provided to a
    /// 			subsequent BatchGetResourceConfig operation.
    /// 			
    /// 			If there are no unprocessed resource keys, the response contains an
    /// 			empty unprocessedResourceKeys list. </p>
    public let unprocessedResourceKeys: [ResourceKey]?

    public init (
        baseConfigurationItems: [BaseConfigurationItem]? = nil,
        unprocessedResourceKeys: [ResourceKey]? = nil
    )
    {
        self.baseConfigurationItems = baseConfigurationItems
        self.unprocessedResourceKeys = unprocessedResourceKeys
    }
}

struct BatchGetResourceConfigOutputResponseBody: Equatable {
    public let baseConfigurationItems: [BaseConfigurationItem]?
    public let unprocessedResourceKeys: [ResourceKey]?
}

extension BatchGetResourceConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baseConfigurationItems
        case unprocessedResourceKeys
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseConfigurationItemsContainer = try containerValues.decodeIfPresent([BaseConfigurationItem?].self, forKey: .baseConfigurationItems)
        var baseConfigurationItemsDecoded0:[BaseConfigurationItem]? = nil
        if let baseConfigurationItemsContainer = baseConfigurationItemsContainer {
            baseConfigurationItemsDecoded0 = [BaseConfigurationItem]()
            for structure0 in baseConfigurationItemsContainer {
                if let structure0 = structure0 {
                    baseConfigurationItemsDecoded0?.append(structure0)
                }
            }
        }
        baseConfigurationItems = baseConfigurationItemsDecoded0
        let unprocessedResourceKeysContainer = try containerValues.decodeIfPresent([ResourceKey?].self, forKey: .unprocessedResourceKeys)
        var unprocessedResourceKeysDecoded0:[ResourceKey]? = nil
        if let unprocessedResourceKeysContainer = unprocessedResourceKeysContainer {
            unprocessedResourceKeysDecoded0 = [ResourceKey]()
            for structure0 in unprocessedResourceKeysContainer {
                if let structure0 = structure0 {
                    unprocessedResourceKeysDecoded0?.append(structure0)
                }
            }
        }
        unprocessedResourceKeys = unprocessedResourceKeysDecoded0
    }
}

public enum ChronologicalOrder {
    case forward
    case reverse
    case sdkUnknown(String)
}

extension ChronologicalOrder : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChronologicalOrder] {
        return [
            .forward,
            .reverse,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .forward: return "Forward"
        case .reverse: return "Reverse"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChronologicalOrder(rawValue: rawValue) ?? ChronologicalOrder.sdkUnknown(rawValue)
    }
}

extension Compliance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceContributorCount = "ComplianceContributorCount"
        case complianceType = "ComplianceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceContributorCount = complianceContributorCount {
            try encodeContainer.encode(complianceContributorCount, forKey: .complianceContributorCount)
        }
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let complianceContributorCountDecoded = try containerValues.decodeIfPresent(ComplianceContributorCount.self, forKey: .complianceContributorCount)
        complianceContributorCount = complianceContributorCountDecoded
    }
}

extension Compliance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Compliance(complianceContributorCount: \(String(describing: complianceContributorCount)), complianceType: \(String(describing: complianceType)))"}
}

/// <p>Indicates whether an AWS resource or AWS Config rule is
/// 			compliant and provides the number of contributors that affect the
/// 			compliance.</p>
public struct Compliance: Equatable {
    /// <p>The number of AWS resources or AWS Config rules that cause a
    /// 			result of <code>NON_COMPLIANT</code>, up to a maximum
    /// 			number.</p>
    public let complianceContributorCount: ComplianceContributorCount?
    /// <p>Indicates whether an AWS resource or AWS Config rule is
    /// 			compliant.</p>
    /// 		       <p>A resource is compliant if it complies with all of the AWS
    /// 			Config rules that evaluate it. A resource is noncompliant if it does
    /// 			not comply with one or more of these rules.</p>
    /// 		       <p>A rule is compliant if all of the resources that the rule
    /// 			evaluates comply with it. A rule is noncompliant if any of these
    /// 			resources do not comply.</p>
    /// 		       <p>AWS Config returns the <code>INSUFFICIENT_DATA</code> value
    /// 			when no evaluation results are available for the AWS resource or AWS
    /// 			Config rule.</p>
    /// 		       <p>For the <code>Compliance</code> data type, AWS Config supports
    /// 			only <code>COMPLIANT</code>, <code>NON_COMPLIANT</code>, and
    /// 				<code>INSUFFICIENT_DATA</code> values. AWS Config does not
    /// 			support the <code>NOT_APPLICABLE</code> value for the
    /// 				<code>Compliance</code> data type.</p>
    public let complianceType: ComplianceType?

    public init (
        complianceContributorCount: ComplianceContributorCount? = nil,
        complianceType: ComplianceType? = nil
    )
    {
        self.complianceContributorCount = complianceContributorCount
        self.complianceType = complianceType
    }
}

extension ComplianceByConfigRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case compliance = "Compliance"
        case configRuleName = "ConfigRuleName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compliance = compliance {
            try encodeContainer.encode(compliance, forKey: .compliance)
        }
        if let configRuleName = configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let complianceDecoded = try containerValues.decodeIfPresent(Compliance.self, forKey: .compliance)
        compliance = complianceDecoded
    }
}

extension ComplianceByConfigRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComplianceByConfigRule(compliance: \(String(describing: compliance)), configRuleName: \(String(describing: configRuleName)))"}
}

/// <p>Indicates whether an AWS Config rule is compliant. A rule is
/// 			compliant if all of the resources that the rule evaluated comply
/// 			with it. A rule is noncompliant if any of these resources do not
/// 			comply.</p>
public struct ComplianceByConfigRule: Equatable {
    /// <p>Indicates whether the AWS Config rule is compliant.</p>
    public let compliance: Compliance?
    /// <p>The name of the AWS Config rule.</p>
    public let configRuleName: String?

    public init (
        compliance: Compliance? = nil,
        configRuleName: String? = nil
    )
    {
        self.compliance = compliance
        self.configRuleName = configRuleName
    }
}

extension ComplianceByResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case compliance = "Compliance"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compliance = compliance {
            try encodeContainer.encode(compliance, forKey: .compliance)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let complianceDecoded = try containerValues.decodeIfPresent(Compliance.self, forKey: .compliance)
        compliance = complianceDecoded
    }
}

extension ComplianceByResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComplianceByResource(compliance: \(String(describing: compliance)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Indicates whether an AWS resource that is evaluated according
/// 			to one or more AWS Config rules is compliant. A resource is
/// 			compliant if it complies with all of the rules that evaluate it. A
/// 			resource is noncompliant if it does not comply with one or more of
/// 			these rules.</p>
public struct ComplianceByResource: Equatable {
    /// <p>Indicates whether the AWS resource complies with all of the AWS
    /// 			Config rules that evaluated it.</p>
    public let compliance: Compliance?
    /// <p>The ID of the AWS resource that was evaluated.</p>
    public let resourceId: String?
    /// <p>The type of the AWS resource that was evaluated.</p>
    public let resourceType: String?

    public init (
        compliance: Compliance? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.compliance = compliance
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

extension ComplianceContributorCount: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case capExceeded = "CapExceeded"
        case cappedCount = "CappedCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if capExceeded != false {
            try encodeContainer.encode(capExceeded, forKey: .capExceeded)
        }
        if cappedCount != 0 {
            try encodeContainer.encode(cappedCount, forKey: .cappedCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cappedCountDecoded = try containerValues.decode(Int.self, forKey: .cappedCount)
        cappedCount = cappedCountDecoded
        let capExceededDecoded = try containerValues.decode(Bool.self, forKey: .capExceeded)
        capExceeded = capExceededDecoded
    }
}

extension ComplianceContributorCount: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComplianceContributorCount(capExceeded: \(String(describing: capExceeded)), cappedCount: \(String(describing: cappedCount)))"}
}

/// <p>The number of AWS resources or AWS Config rules responsible for
/// 			the current compliance of the item, up to a maximum
/// 			number.</p>
public struct ComplianceContributorCount: Equatable {
    /// <p>Indicates whether the maximum count is reached.</p>
    public let capExceeded: Bool
    /// <p>The number of AWS resources or AWS Config rules responsible for
    /// 			the current compliance of the item.</p>
    public let cappedCount: Int

    public init (
        capExceeded: Bool = false,
        cappedCount: Int = 0
    )
    {
        self.capExceeded = capExceeded
        self.cappedCount = cappedCount
    }
}

extension ComplianceSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceSummaryTimestamp = "ComplianceSummaryTimestamp"
        case compliantResourceCount = "CompliantResourceCount"
        case nonCompliantResourceCount = "NonCompliantResourceCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceSummaryTimestamp = complianceSummaryTimestamp {
            try encodeContainer.encode(complianceSummaryTimestamp.timeIntervalSince1970, forKey: .complianceSummaryTimestamp)
        }
        if let compliantResourceCount = compliantResourceCount {
            try encodeContainer.encode(compliantResourceCount, forKey: .compliantResourceCount)
        }
        if let nonCompliantResourceCount = nonCompliantResourceCount {
            try encodeContainer.encode(nonCompliantResourceCount, forKey: .nonCompliantResourceCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compliantResourceCountDecoded = try containerValues.decodeIfPresent(ComplianceContributorCount.self, forKey: .compliantResourceCount)
        compliantResourceCount = compliantResourceCountDecoded
        let nonCompliantResourceCountDecoded = try containerValues.decodeIfPresent(ComplianceContributorCount.self, forKey: .nonCompliantResourceCount)
        nonCompliantResourceCount = nonCompliantResourceCountDecoded
        let complianceSummaryTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .complianceSummaryTimestamp)
        complianceSummaryTimestamp = complianceSummaryTimestampDecoded
    }
}

extension ComplianceSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComplianceSummary(complianceSummaryTimestamp: \(String(describing: complianceSummaryTimestamp)), compliantResourceCount: \(String(describing: compliantResourceCount)), nonCompliantResourceCount: \(String(describing: nonCompliantResourceCount)))"}
}

/// <p>The number of AWS Config rules or AWS resources that are
/// 			compliant and noncompliant.</p>
public struct ComplianceSummary: Equatable {
    /// <p>The time that AWS Config created the compliance
    /// 			summary.</p>
    public let complianceSummaryTimestamp: Date?
    /// <p>The number of AWS Config rules or AWS resources that are
    /// 			compliant, up to a maximum of 25 for rules and 100 for
    /// 			resources.</p>
    public let compliantResourceCount: ComplianceContributorCount?
    /// <p>The number of AWS Config rules or AWS resources that are
    /// 			noncompliant, up to a maximum of 25 for rules and 100 for
    /// 			resources.</p>
    public let nonCompliantResourceCount: ComplianceContributorCount?

    public init (
        complianceSummaryTimestamp: Date? = nil,
        compliantResourceCount: ComplianceContributorCount? = nil,
        nonCompliantResourceCount: ComplianceContributorCount? = nil
    )
    {
        self.complianceSummaryTimestamp = complianceSummaryTimestamp
        self.compliantResourceCount = compliantResourceCount
        self.nonCompliantResourceCount = nonCompliantResourceCount
    }
}

extension ComplianceSummaryByResourceType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceSummary = "ComplianceSummary"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceSummary = complianceSummary {
            try encodeContainer.encode(complianceSummary, forKey: .complianceSummary)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let complianceSummaryDecoded = try containerValues.decodeIfPresent(ComplianceSummary.self, forKey: .complianceSummary)
        complianceSummary = complianceSummaryDecoded
    }
}

extension ComplianceSummaryByResourceType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComplianceSummaryByResourceType(complianceSummary: \(String(describing: complianceSummary)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>The number of AWS resources of a specific type that are
/// 			compliant or noncompliant, up to a maximum of 100 for
/// 			each.</p>
public struct ComplianceSummaryByResourceType: Equatable {
    /// <p>The number of AWS resources that are compliant or noncompliant,
    /// 			up to a maximum of 100 for each.</p>
    public let complianceSummary: ComplianceSummary?
    /// <p>The type of AWS resource.</p>
    public let resourceType: String?

    public init (
        complianceSummary: ComplianceSummary? = nil,
        resourceType: String? = nil
    )
    {
        self.complianceSummary = complianceSummary
        self.resourceType = resourceType
    }
}

public enum ComplianceType {
    case compliant
    case insufficientData
    case nonCompliant
    case notApplicable
    case sdkUnknown(String)
}

extension ComplianceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ComplianceType] {
        return [
            .compliant,
            .insufficientData,
            .nonCompliant,
            .notApplicable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .compliant: return "COMPLIANT"
        case .insufficientData: return "INSUFFICIENT_DATA"
        case .nonCompliant: return "NON_COMPLIANT"
        case .notApplicable: return "NOT_APPLICABLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ComplianceType(rawValue: rawValue) ?? ComplianceType.sdkUnknown(rawValue)
    }
}

extension ConfigExportDeliveryInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastAttemptTime
        case lastErrorCode
        case lastErrorMessage
        case lastStatus
        case lastSuccessfulTime
        case nextDeliveryTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastAttemptTime = lastAttemptTime {
            try encodeContainer.encode(lastAttemptTime.timeIntervalSince1970, forKey: .lastAttemptTime)
        }
        if let lastErrorCode = lastErrorCode {
            try encodeContainer.encode(lastErrorCode, forKey: .lastErrorCode)
        }
        if let lastErrorMessage = lastErrorMessage {
            try encodeContainer.encode(lastErrorMessage, forKey: .lastErrorMessage)
        }
        if let lastStatus = lastStatus {
            try encodeContainer.encode(lastStatus.rawValue, forKey: .lastStatus)
        }
        if let lastSuccessfulTime = lastSuccessfulTime {
            try encodeContainer.encode(lastSuccessfulTime.timeIntervalSince1970, forKey: .lastSuccessfulTime)
        }
        if let nextDeliveryTime = nextDeliveryTime {
            try encodeContainer.encode(nextDeliveryTime.timeIntervalSince1970, forKey: .nextDeliveryTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastStatusDecoded = try containerValues.decodeIfPresent(DeliveryStatus.self, forKey: .lastStatus)
        lastStatus = lastStatusDecoded
        let lastErrorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastErrorCode)
        lastErrorCode = lastErrorCodeDecoded
        let lastErrorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastErrorMessage)
        lastErrorMessage = lastErrorMessageDecoded
        let lastAttemptTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastAttemptTime)
        lastAttemptTime = lastAttemptTimeDecoded
        let lastSuccessfulTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastSuccessfulTime)
        lastSuccessfulTime = lastSuccessfulTimeDecoded
        let nextDeliveryTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .nextDeliveryTime)
        nextDeliveryTime = nextDeliveryTimeDecoded
    }
}

extension ConfigExportDeliveryInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigExportDeliveryInfo(lastAttemptTime: \(String(describing: lastAttemptTime)), lastErrorCode: \(String(describing: lastErrorCode)), lastErrorMessage: \(String(describing: lastErrorMessage)), lastStatus: \(String(describing: lastStatus)), lastSuccessfulTime: \(String(describing: lastSuccessfulTime)), nextDeliveryTime: \(String(describing: nextDeliveryTime)))"}
}

/// <p>Provides status of the delivery of the snapshot or the
/// 			configuration history to the specified Amazon S3 bucket. Also
/// 			provides the status of notifications about the Amazon S3 delivery to
/// 			the specified Amazon SNS topic.</p>
public struct ConfigExportDeliveryInfo: Equatable {
    /// <p>The time of the last attempted delivery.</p>
    public let lastAttemptTime: Date?
    /// <p>The error code from the last attempted delivery.</p>
    public let lastErrorCode: String?
    /// <p>The error message from the last attempted delivery.</p>
    public let lastErrorMessage: String?
    /// <p>Status of the last attempted delivery.</p>
    public let lastStatus: DeliveryStatus?
    /// <p>The time of the last successful delivery.</p>
    public let lastSuccessfulTime: Date?
    /// <p>The time that the next delivery occurs.</p>
    public let nextDeliveryTime: Date?

    public init (
        lastAttemptTime: Date? = nil,
        lastErrorCode: String? = nil,
        lastErrorMessage: String? = nil,
        lastStatus: DeliveryStatus? = nil,
        lastSuccessfulTime: Date? = nil,
        nextDeliveryTime: Date? = nil
    )
    {
        self.lastAttemptTime = lastAttemptTime
        self.lastErrorCode = lastErrorCode
        self.lastErrorMessage = lastErrorMessage
        self.lastStatus = lastStatus
        self.lastSuccessfulTime = lastSuccessfulTime
        self.nextDeliveryTime = nextDeliveryTime
    }
}

extension ConfigRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configRuleArn = "ConfigRuleArn"
        case configRuleId = "ConfigRuleId"
        case configRuleName = "ConfigRuleName"
        case configRuleState = "ConfigRuleState"
        case createdBy = "CreatedBy"
        case description = "Description"
        case inputParameters = "InputParameters"
        case maximumExecutionFrequency = "MaximumExecutionFrequency"
        case scope = "Scope"
        case source = "Source"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleArn = configRuleArn {
            try encodeContainer.encode(configRuleArn, forKey: .configRuleArn)
        }
        if let configRuleId = configRuleId {
            try encodeContainer.encode(configRuleId, forKey: .configRuleId)
        }
        if let configRuleName = configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let configRuleState = configRuleState {
            try encodeContainer.encode(configRuleState.rawValue, forKey: .configRuleState)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let inputParameters = inputParameters {
            try encodeContainer.encode(inputParameters, forKey: .inputParameters)
        }
        if let maximumExecutionFrequency = maximumExecutionFrequency {
            try encodeContainer.encode(maximumExecutionFrequency.rawValue, forKey: .maximumExecutionFrequency)
        }
        if let scope = scope {
            try encodeContainer.encode(scope, forKey: .scope)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let configRuleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleArn)
        configRuleArn = configRuleArnDecoded
        let configRuleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleId)
        configRuleId = configRuleIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Source.self, forKey: .source)
        source = sourceDecoded
        let inputParametersDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputParameters)
        inputParameters = inputParametersDecoded
        let maximumExecutionFrequencyDecoded = try containerValues.decodeIfPresent(MaximumExecutionFrequency.self, forKey: .maximumExecutionFrequency)
        maximumExecutionFrequency = maximumExecutionFrequencyDecoded
        let configRuleStateDecoded = try containerValues.decodeIfPresent(ConfigRuleState.self, forKey: .configRuleState)
        configRuleState = configRuleStateDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

extension ConfigRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigRule(configRuleArn: \(String(describing: configRuleArn)), configRuleId: \(String(describing: configRuleId)), configRuleName: \(String(describing: configRuleName)), configRuleState: \(String(describing: configRuleState)), createdBy: \(String(describing: createdBy)), description: \(String(describing: description)), inputParameters: \(String(describing: inputParameters)), maximumExecutionFrequency: \(String(describing: maximumExecutionFrequency)), scope: \(String(describing: scope)), source: \(String(describing: source)))"}
}

/// <p>An AWS Config rule represents an AWS Lambda function that you
/// 			create for a custom rule or a predefined function for an AWS managed
/// 			rule. The function evaluates configuration items to assess whether
/// 			your AWS resources comply with your desired configurations. This
/// 			function can run when AWS Config detects a configuration change to
/// 			an AWS resource and at a periodic frequency that you choose (for
/// 			example, every 24 hours).</p>
///
/// 		       <note>
/// 			         <p>You can use the AWS CLI and AWS SDKs if you want to create
/// 				a rule that triggers evaluations for your resources when AWS
/// 				Config delivers the configuration snapshot. For more
/// 				information, see <a>ConfigSnapshotDeliveryProperties</a>.</p>
/// 		       </note>
/// 		       <p>For more information about developing and using AWS Config
/// 			rules, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config.html">Evaluating AWS Resource Configurations with AWS Config</a>
/// 			in the <i>AWS Config Developer Guide</i>.</p>
public struct ConfigRule: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the AWS Config
    /// 			rule.</p>
    public let configRuleArn: String?
    /// <p>The ID of the AWS Config rule.</p>
    public let configRuleId: String?
    /// <p>The name that you assign to the AWS Config rule. The name is
    /// 			required if you are adding a new rule.</p>
    public let configRuleName: String?
    /// <p>Indicates whether the AWS Config rule is active or is currently
    /// 			being deleted by AWS Config. It can also indicate the evaluation
    /// 			status for the AWS Config rule.</p>
    ///
    /// 		       <p>AWS Config sets the state of the rule to
    /// 				<code>EVALUATING</code> temporarily after you use the
    /// 				<code>StartConfigRulesEvaluation</code> request to evaluate your
    /// 			resources against the AWS Config rule.</p>
    ///
    /// 		       <p>AWS Config sets the state of the rule to
    /// 				<code>DELETING_RESULTS</code> temporarily after you use the
    /// 				<code>DeleteEvaluationResults</code> request to delete the
    /// 			current evaluation results for the AWS Config rule.</p>
    ///
    /// 		       <p>AWS Config temporarily sets the state of a rule to
    /// 				<code>DELETING</code> after you use the
    /// 				<code>DeleteConfigRule</code> request to delete the rule. After
    /// 			AWS Config deletes the rule, the rule and all of its evaluations are
    /// 			erased and are no longer available.</p>
    public let configRuleState: ConfigRuleState?
    /// <p>Service principal name of the service that created the
    /// 			rule.</p>
    /// 		       <note>
    /// 			         <p>The field is populated only if the service linked rule is
    /// 				created by a service. The field is empty if you create your own
    /// 				rule.</p>
    /// 		       </note>
    public let createdBy: String?
    /// <p>The description that you provide for the AWS Config
    /// 			rule.</p>
    public let description: String?
    /// <p>A string, in JSON format, that is passed to the AWS Config rule
    /// 			Lambda function.</p>
    public let inputParameters: String?
    /// <p>The maximum frequency with which AWS Config runs evaluations
    /// 			for a rule. You can specify a value for
    /// 				<code>MaximumExecutionFrequency</code> when:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>You are using an AWS managed rule that is triggered at
    /// 					a periodic frequency.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Your custom rule is triggered when AWS Config delivers
    /// 					the configuration snapshot. For more information, see <a>ConfigSnapshotDeliveryProperties</a>.</p>
    /// 			         </li>
    ///          </ul>
    ///
    ///
    ///
    /// 		       <note>
    /// 			         <p>By default, rules with a periodic trigger are evaluated
    /// 				every 24 hours. To change the frequency, specify a valid value
    /// 				for the <code>MaximumExecutionFrequency</code>
    /// 				parameter.</p>
    /// 		       </note>
    public let maximumExecutionFrequency: MaximumExecutionFrequency?
    /// <p>Defines which resources can trigger an evaluation for the rule.
    /// 			The scope can include one or more resource types, a combination of
    /// 			one resource type and one resource ID, or a combination of a tag key
    /// 			and value. Specify a scope to constrain the resources that can
    /// 			trigger an evaluation for the rule. If you do not specify a scope,
    /// 			evaluations are triggered when any resource in the recording group
    /// 			changes.</p>
    /// 		       <note>
    ///             <p>The scope can be empty. </p>
    ///          </note>
    public let scope: Scope?
    /// <p>Provides the rule owner (AWS or customer), the rule identifier,
    /// 			and the notifications that cause the function to evaluate your AWS
    /// 			resources.</p>
    public let source: Source?

    public init (
        configRuleArn: String? = nil,
        configRuleId: String? = nil,
        configRuleName: String? = nil,
        configRuleState: ConfigRuleState? = nil,
        createdBy: String? = nil,
        description: String? = nil,
        inputParameters: String? = nil,
        maximumExecutionFrequency: MaximumExecutionFrequency? = nil,
        scope: Scope? = nil,
        source: Source? = nil
    )
    {
        self.configRuleArn = configRuleArn
        self.configRuleId = configRuleId
        self.configRuleName = configRuleName
        self.configRuleState = configRuleState
        self.createdBy = createdBy
        self.description = description
        self.inputParameters = inputParameters
        self.maximumExecutionFrequency = maximumExecutionFrequency
        self.scope = scope
        self.source = source
    }
}

extension ConfigRuleComplianceFilters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case awsRegion = "AwsRegion"
        case complianceType = "ComplianceType"
        case configRuleName = "ConfigRuleName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
        if let configRuleName = configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension ConfigRuleComplianceFilters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigRuleComplianceFilters(accountId: \(String(describing: accountId)), awsRegion: \(String(describing: awsRegion)), complianceType: \(String(describing: complianceType)), configRuleName: \(String(describing: configRuleName)))"}
}

/// <p>Filters the compliance results based on account ID, region,
/// 			compliance type, and rule name.</p>
public struct ConfigRuleComplianceFilters: Equatable {
    /// <p>The 12-digit account ID of the source account.
    /// 			</p>
    public let accountId: String?
    /// <p>The source region where the data is aggregated.
    /// 			</p>
    public let awsRegion: String?
    /// <p>The rule compliance status.</p>
    /// 		       <p>For the <code>ConfigRuleComplianceFilters</code> data type, AWS
    /// 			Config supports only <code>COMPLIANT</code> and
    /// 				<code>NON_COMPLIANT</code>. AWS Config does not support the
    /// 				<code>NOT_APPLICABLE</code> and the
    /// 				<code>INSUFFICIENT_DATA</code> values.</p>
    public let complianceType: ComplianceType?
    /// <p>The name of the AWS Config rule.</p>
    public let configRuleName: String?

    public init (
        accountId: String? = nil,
        awsRegion: String? = nil,
        complianceType: ComplianceType? = nil,
        configRuleName: String? = nil
    )
    {
        self.accountId = accountId
        self.awsRegion = awsRegion
        self.complianceType = complianceType
        self.configRuleName = configRuleName
    }
}

extension ConfigRuleComplianceSummaryFilters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case awsRegion = "AwsRegion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension ConfigRuleComplianceSummaryFilters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigRuleComplianceSummaryFilters(accountId: \(String(describing: accountId)), awsRegion: \(String(describing: awsRegion)))"}
}

/// <p>Filters the results based on the account IDs and
/// 			regions.</p>
public struct ConfigRuleComplianceSummaryFilters: Equatable {
    /// <p>The 12-digit account ID of the source account.</p>
    public let accountId: String?
    /// <p>The source region where the data is aggregated.</p>
    public let awsRegion: String?

    public init (
        accountId: String? = nil,
        awsRegion: String? = nil
    )
    {
        self.accountId = accountId
        self.awsRegion = awsRegion
    }
}

public enum ConfigRuleComplianceSummaryGroupKey {
    case accountId
    case awsRegion
    case sdkUnknown(String)
}

extension ConfigRuleComplianceSummaryGroupKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConfigRuleComplianceSummaryGroupKey] {
        return [
            .accountId,
            .awsRegion,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accountId: return "ACCOUNT_ID"
        case .awsRegion: return "AWS_REGION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConfigRuleComplianceSummaryGroupKey(rawValue: rawValue) ?? ConfigRuleComplianceSummaryGroupKey.sdkUnknown(rawValue)
    }
}

extension ConfigRuleEvaluationStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configRuleArn = "ConfigRuleArn"
        case configRuleId = "ConfigRuleId"
        case configRuleName = "ConfigRuleName"
        case firstActivatedTime = "FirstActivatedTime"
        case firstEvaluationStarted = "FirstEvaluationStarted"
        case lastDeactivatedTime = "LastDeactivatedTime"
        case lastErrorCode = "LastErrorCode"
        case lastErrorMessage = "LastErrorMessage"
        case lastFailedEvaluationTime = "LastFailedEvaluationTime"
        case lastFailedInvocationTime = "LastFailedInvocationTime"
        case lastSuccessfulEvaluationTime = "LastSuccessfulEvaluationTime"
        case lastSuccessfulInvocationTime = "LastSuccessfulInvocationTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleArn = configRuleArn {
            try encodeContainer.encode(configRuleArn, forKey: .configRuleArn)
        }
        if let configRuleId = configRuleId {
            try encodeContainer.encode(configRuleId, forKey: .configRuleId)
        }
        if let configRuleName = configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let firstActivatedTime = firstActivatedTime {
            try encodeContainer.encode(firstActivatedTime.timeIntervalSince1970, forKey: .firstActivatedTime)
        }
        if firstEvaluationStarted != false {
            try encodeContainer.encode(firstEvaluationStarted, forKey: .firstEvaluationStarted)
        }
        if let lastDeactivatedTime = lastDeactivatedTime {
            try encodeContainer.encode(lastDeactivatedTime.timeIntervalSince1970, forKey: .lastDeactivatedTime)
        }
        if let lastErrorCode = lastErrorCode {
            try encodeContainer.encode(lastErrorCode, forKey: .lastErrorCode)
        }
        if let lastErrorMessage = lastErrorMessage {
            try encodeContainer.encode(lastErrorMessage, forKey: .lastErrorMessage)
        }
        if let lastFailedEvaluationTime = lastFailedEvaluationTime {
            try encodeContainer.encode(lastFailedEvaluationTime.timeIntervalSince1970, forKey: .lastFailedEvaluationTime)
        }
        if let lastFailedInvocationTime = lastFailedInvocationTime {
            try encodeContainer.encode(lastFailedInvocationTime.timeIntervalSince1970, forKey: .lastFailedInvocationTime)
        }
        if let lastSuccessfulEvaluationTime = lastSuccessfulEvaluationTime {
            try encodeContainer.encode(lastSuccessfulEvaluationTime.timeIntervalSince1970, forKey: .lastSuccessfulEvaluationTime)
        }
        if let lastSuccessfulInvocationTime = lastSuccessfulInvocationTime {
            try encodeContainer.encode(lastSuccessfulInvocationTime.timeIntervalSince1970, forKey: .lastSuccessfulInvocationTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let configRuleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleArn)
        configRuleArn = configRuleArnDecoded
        let configRuleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleId)
        configRuleId = configRuleIdDecoded
        let lastSuccessfulInvocationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastSuccessfulInvocationTime)
        lastSuccessfulInvocationTime = lastSuccessfulInvocationTimeDecoded
        let lastFailedInvocationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastFailedInvocationTime)
        lastFailedInvocationTime = lastFailedInvocationTimeDecoded
        let lastSuccessfulEvaluationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastSuccessfulEvaluationTime)
        lastSuccessfulEvaluationTime = lastSuccessfulEvaluationTimeDecoded
        let lastFailedEvaluationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastFailedEvaluationTime)
        lastFailedEvaluationTime = lastFailedEvaluationTimeDecoded
        let firstActivatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .firstActivatedTime)
        firstActivatedTime = firstActivatedTimeDecoded
        let lastDeactivatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastDeactivatedTime)
        lastDeactivatedTime = lastDeactivatedTimeDecoded
        let lastErrorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastErrorCode)
        lastErrorCode = lastErrorCodeDecoded
        let lastErrorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastErrorMessage)
        lastErrorMessage = lastErrorMessageDecoded
        let firstEvaluationStartedDecoded = try containerValues.decode(Bool.self, forKey: .firstEvaluationStarted)
        firstEvaluationStarted = firstEvaluationStartedDecoded
    }
}

extension ConfigRuleEvaluationStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigRuleEvaluationStatus(configRuleArn: \(String(describing: configRuleArn)), configRuleId: \(String(describing: configRuleId)), configRuleName: \(String(describing: configRuleName)), firstActivatedTime: \(String(describing: firstActivatedTime)), firstEvaluationStarted: \(String(describing: firstEvaluationStarted)), lastDeactivatedTime: \(String(describing: lastDeactivatedTime)), lastErrorCode: \(String(describing: lastErrorCode)), lastErrorMessage: \(String(describing: lastErrorMessage)), lastFailedEvaluationTime: \(String(describing: lastFailedEvaluationTime)), lastFailedInvocationTime: \(String(describing: lastFailedInvocationTime)), lastSuccessfulEvaluationTime: \(String(describing: lastSuccessfulEvaluationTime)), lastSuccessfulInvocationTime: \(String(describing: lastSuccessfulInvocationTime)))"}
}

/// <p>Status information for your AWS managed Config rules. The
/// 			status includes information such as the last time the rule ran, the
/// 			last time it failed, and the related error for the last
/// 			failure.</p>
/// 		       <p>This action does not return status information about custom AWS
/// 			Config rules.</p>
public struct ConfigRuleEvaluationStatus: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the AWS Config
    /// 			rule.</p>
    public let configRuleArn: String?
    /// <p>The ID of the AWS Config rule.</p>
    public let configRuleId: String?
    /// <p>The name of the AWS Config rule.</p>
    public let configRuleName: String?
    /// <p>The time that you first activated the AWS Config
    /// 			rule.</p>
    public let firstActivatedTime: Date?
    /// <p>Indicates whether AWS Config has evaluated your resources
    /// 			against the rule at least once.</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    /// 					             <code>true</code> - AWS Config has evaluated your AWS
    /// 					resources against the rule at least once.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    /// 					             <code>false</code> - AWS Config has not once finished
    /// 					evaluating your AWS resources against the rule.</p>
    /// 			         </li>
    ///          </ul>
    public let firstEvaluationStarted: Bool
    /// <p>The time that you last turned off the AWS Config rule.</p>
    public let lastDeactivatedTime: Date?
    /// <p>The error code that AWS Config returned when the rule last
    /// 			failed.</p>
    public let lastErrorCode: String?
    /// <p>The error message that AWS Config returned when the rule last
    /// 			failed.</p>
    public let lastErrorMessage: String?
    /// <p>The time that AWS Config last failed to evaluate your AWS
    /// 			resources against the rule.</p>
    public let lastFailedEvaluationTime: Date?
    /// <p>The time that AWS Config last failed to invoke the AWS Config
    /// 			rule to evaluate your AWS resources.</p>
    public let lastFailedInvocationTime: Date?
    /// <p>The time that AWS Config last successfully evaluated your AWS
    /// 			resources against the rule.</p>
    public let lastSuccessfulEvaluationTime: Date?
    /// <p>The time that AWS Config last successfully invoked the AWS
    /// 			Config rule to evaluate your AWS resources.</p>
    public let lastSuccessfulInvocationTime: Date?

    public init (
        configRuleArn: String? = nil,
        configRuleId: String? = nil,
        configRuleName: String? = nil,
        firstActivatedTime: Date? = nil,
        firstEvaluationStarted: Bool = false,
        lastDeactivatedTime: Date? = nil,
        lastErrorCode: String? = nil,
        lastErrorMessage: String? = nil,
        lastFailedEvaluationTime: Date? = nil,
        lastFailedInvocationTime: Date? = nil,
        lastSuccessfulEvaluationTime: Date? = nil,
        lastSuccessfulInvocationTime: Date? = nil
    )
    {
        self.configRuleArn = configRuleArn
        self.configRuleId = configRuleId
        self.configRuleName = configRuleName
        self.firstActivatedTime = firstActivatedTime
        self.firstEvaluationStarted = firstEvaluationStarted
        self.lastDeactivatedTime = lastDeactivatedTime
        self.lastErrorCode = lastErrorCode
        self.lastErrorMessage = lastErrorMessage
        self.lastFailedEvaluationTime = lastFailedEvaluationTime
        self.lastFailedInvocationTime = lastFailedInvocationTime
        self.lastSuccessfulEvaluationTime = lastSuccessfulEvaluationTime
        self.lastSuccessfulInvocationTime = lastSuccessfulInvocationTime
    }
}

public enum ConfigRuleState {
    case active
    case deleting
    case deletingResults
    case evaluating
    case sdkUnknown(String)
}

extension ConfigRuleState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConfigRuleState] {
        return [
            .active,
            .deleting,
            .deletingResults,
            .evaluating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .deleting: return "DELETING"
        case .deletingResults: return "DELETING_RESULTS"
        case .evaluating: return "EVALUATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConfigRuleState(rawValue: rawValue) ?? ConfigRuleState.sdkUnknown(rawValue)
    }
}

extension ConfigSnapshotDeliveryProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deliveryFrequency
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryFrequency = deliveryFrequency {
            try encodeContainer.encode(deliveryFrequency.rawValue, forKey: .deliveryFrequency)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryFrequencyDecoded = try containerValues.decodeIfPresent(MaximumExecutionFrequency.self, forKey: .deliveryFrequency)
        deliveryFrequency = deliveryFrequencyDecoded
    }
}

extension ConfigSnapshotDeliveryProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigSnapshotDeliveryProperties(deliveryFrequency: \(String(describing: deliveryFrequency)))"}
}

/// <p>Provides options for how often AWS Config delivers
/// 			configuration snapshots to the Amazon S3 bucket in your delivery
/// 			channel.</p>
///
/// 		
/// 		
///
/// 		       <p>The frequency for a rule that triggers evaluations for your
/// 			resources when AWS Config delivers the configuration snapshot is set
/// 			by one of two values, depending on which is less frequent:</p>
///
/// 		       <ul>
///             <li>
/// 				           <p>The value for the <code>deliveryFrequency</code>
/// 					parameter within the delivery channel configuration, which
/// 					sets how often AWS Config delivers configuration snapshots.
/// 					This value also sets how often AWS Config invokes
/// 					evaluations for AWS Config rules.</p>
/// 			         </li>
///             <li>
/// 				           <p>The value for the
/// 						<code>MaximumExecutionFrequency</code> parameter, which
/// 					sets the maximum frequency with which AWS Config invokes
/// 					evaluations for the rule. For more information, see <a>ConfigRule</a>.</p>
/// 			         </li>
///          </ul>
///
/// 		       <p>If the <code>deliveryFrequency</code> value is less frequent
/// 			than the <code>MaximumExecutionFrequency</code> value for a rule,
/// 			AWS Config invokes the rule only as often as the
/// 				<code>deliveryFrequency</code> value.</p>
///
/// 		       <ol>
///             <li>
/// 				           <p>For example, you want your rule to run evaluations when
/// 					AWS Config delivers the configuration snapshot.</p>
/// 			         </li>
///             <li>
/// 				           <p>You specify the <code>MaximumExecutionFrequency</code>
/// 					value for <code>Six_Hours</code>. </p>
/// 			         </li>
///             <li>
/// 				           <p>You then specify the delivery channel
/// 						<code>deliveryFrequency</code> value for
/// 						<code>TwentyFour_Hours</code>.</p>
/// 			         </li>
///             <li>
/// 				           <p>Because the value for <code>deliveryFrequency</code> is
/// 					less frequent than <code>MaximumExecutionFrequency</code>,
/// 					AWS Config invokes evaluations for the rule every 24 hours.
/// 				</p>
/// 			         </li>
///          </ol>
///
///
/// 		       <p>You should set the <code>MaximumExecutionFrequency</code> value
/// 			to be at least as frequent as the <code>deliveryFrequency</code>
/// 			value. You can view the <code>deliveryFrequency</code> value by
/// 			using the <code>DescribeDeliveryChannnels</code> action.</p>
///
/// 		       <p>To update the <code>deliveryFrequency</code> with which AWS
/// 			Config delivers your configuration snapshots, use the
/// 				<code>PutDeliveryChannel</code> action.</p>
public struct ConfigSnapshotDeliveryProperties: Equatable {
    /// <p>The frequency with which AWS Config delivers configuration
    /// 			snapshots.</p>
    public let deliveryFrequency: MaximumExecutionFrequency?

    public init (
        deliveryFrequency: MaximumExecutionFrequency? = nil
    )
    {
        self.deliveryFrequency = deliveryFrequency
    }
}

extension ConfigStreamDeliveryInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastErrorCode
        case lastErrorMessage
        case lastStatus
        case lastStatusChangeTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastErrorCode = lastErrorCode {
            try encodeContainer.encode(lastErrorCode, forKey: .lastErrorCode)
        }
        if let lastErrorMessage = lastErrorMessage {
            try encodeContainer.encode(lastErrorMessage, forKey: .lastErrorMessage)
        }
        if let lastStatus = lastStatus {
            try encodeContainer.encode(lastStatus.rawValue, forKey: .lastStatus)
        }
        if let lastStatusChangeTime = lastStatusChangeTime {
            try encodeContainer.encode(lastStatusChangeTime.timeIntervalSince1970, forKey: .lastStatusChangeTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastStatusDecoded = try containerValues.decodeIfPresent(DeliveryStatus.self, forKey: .lastStatus)
        lastStatus = lastStatusDecoded
        let lastErrorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastErrorCode)
        lastErrorCode = lastErrorCodeDecoded
        let lastErrorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastErrorMessage)
        lastErrorMessage = lastErrorMessageDecoded
        let lastStatusChangeTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastStatusChangeTime)
        lastStatusChangeTime = lastStatusChangeTimeDecoded
    }
}

extension ConfigStreamDeliveryInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigStreamDeliveryInfo(lastErrorCode: \(String(describing: lastErrorCode)), lastErrorMessage: \(String(describing: lastErrorMessage)), lastStatus: \(String(describing: lastStatus)), lastStatusChangeTime: \(String(describing: lastStatusChangeTime)))"}
}

/// <p>A list that contains the status of the delivery of the
/// 			configuration stream notification to the Amazon SNS topic.</p>
public struct ConfigStreamDeliveryInfo: Equatable {
    /// <p>The error code from the last attempted delivery.</p>
    public let lastErrorCode: String?
    /// <p>The error message from the last attempted delivery.</p>
    public let lastErrorMessage: String?
    /// <p>Status of the last attempted delivery.</p>
    /// 		       <p>
    /// 			         <b>Note</b> Providing an SNS topic on a
    /// 				<a href="https://docs.aws.amazon.com/config/latest/APIReference/API_DeliveryChannel.html">DeliveryChannel</a> for AWS Config is optional. If the SNS
    /// 			delivery is turned off, the last status will be <b>Not_Applicable</b>.</p>
    public let lastStatus: DeliveryStatus?
    /// <p>The time from the last status change.</p>
    public let lastStatusChangeTime: Date?

    public init (
        lastErrorCode: String? = nil,
        lastErrorMessage: String? = nil,
        lastStatus: DeliveryStatus? = nil,
        lastStatusChangeTime: Date? = nil
    )
    {
        self.lastErrorCode = lastErrorCode
        self.lastErrorMessage = lastErrorMessage
        self.lastStatus = lastStatus
        self.lastStatusChangeTime = lastStatusChangeTime
    }
}

extension ConfigurationAggregator: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountAggregationSources = "AccountAggregationSources"
        case configurationAggregatorArn = "ConfigurationAggregatorArn"
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case createdBy = "CreatedBy"
        case creationTime = "CreationTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case organizationAggregationSource = "OrganizationAggregationSource"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountAggregationSources = accountAggregationSources {
            var accountAggregationSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountAggregationSources)
            for accountaggregationsourcelist0 in accountAggregationSources {
                try accountAggregationSourcesContainer.encode(accountaggregationsourcelist0)
            }
        }
        if let configurationAggregatorArn = configurationAggregatorArn {
            try encodeContainer.encode(configurationAggregatorArn, forKey: .configurationAggregatorArn)
        }
        if let configurationAggregatorName = configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let organizationAggregationSource = organizationAggregationSource {
            try encodeContainer.encode(organizationAggregationSource, forKey: .organizationAggregationSource)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let configurationAggregatorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationAggregatorArn)
        configurationAggregatorArn = configurationAggregatorArnDecoded
        let accountAggregationSourcesContainer = try containerValues.decodeIfPresent([AccountAggregationSource?].self, forKey: .accountAggregationSources)
        var accountAggregationSourcesDecoded0:[AccountAggregationSource]? = nil
        if let accountAggregationSourcesContainer = accountAggregationSourcesContainer {
            accountAggregationSourcesDecoded0 = [AccountAggregationSource]()
            for structure0 in accountAggregationSourcesContainer {
                if let structure0 = structure0 {
                    accountAggregationSourcesDecoded0?.append(structure0)
                }
            }
        }
        accountAggregationSources = accountAggregationSourcesDecoded0
        let organizationAggregationSourceDecoded = try containerValues.decodeIfPresent(OrganizationAggregationSource.self, forKey: .organizationAggregationSource)
        organizationAggregationSource = organizationAggregationSourceDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

extension ConfigurationAggregator: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigurationAggregator(accountAggregationSources: \(String(describing: accountAggregationSources)), configurationAggregatorArn: \(String(describing: configurationAggregatorArn)), configurationAggregatorName: \(String(describing: configurationAggregatorName)), createdBy: \(String(describing: createdBy)), creationTime: \(String(describing: creationTime)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), organizationAggregationSource: \(String(describing: organizationAggregationSource)))"}
}

/// <p>The details about the configuration aggregator, including
/// 			information about source accounts, regions, and metadata of the
/// 			aggregator. </p>
public struct ConfigurationAggregator: Equatable {
    /// <p>Provides a list of source accounts and regions to be
    /// 			aggregated.</p>
    public let accountAggregationSources: [AccountAggregationSource]?
    /// <p>The Amazon Resource Name (ARN) of the aggregator.</p>
    public let configurationAggregatorArn: String?
    /// <p>The name of the aggregator.</p>
    public let configurationAggregatorName: String?
    /// <p>AWS service that created the configuration aggregator.</p>
    public let createdBy: String?
    /// <p>The time stamp when the configuration aggregator was
    /// 			created.</p>
    public let creationTime: Date?
    /// <p>The time of the last update.</p>
    public let lastUpdatedTime: Date?
    /// <p>Provides an organization and list of regions to be
    /// 			aggregated.</p>
    public let organizationAggregationSource: OrganizationAggregationSource?

    public init (
        accountAggregationSources: [AccountAggregationSource]? = nil,
        configurationAggregatorArn: String? = nil,
        configurationAggregatorName: String? = nil,
        createdBy: String? = nil,
        creationTime: Date? = nil,
        lastUpdatedTime: Date? = nil,
        organizationAggregationSource: OrganizationAggregationSource? = nil
    )
    {
        self.accountAggregationSources = accountAggregationSources
        self.configurationAggregatorArn = configurationAggregatorArn
        self.configurationAggregatorName = configurationAggregatorName
        self.createdBy = createdBy
        self.creationTime = creationTime
        self.lastUpdatedTime = lastUpdatedTime
        self.organizationAggregationSource = organizationAggregationSource
    }
}

extension ConfigurationItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId
        case arn
        case availabilityZone
        case awsRegion
        case configuration
        case configurationItemCaptureTime
        case configurationItemMD5Hash
        case configurationItemStatus
        case configurationStateId
        case relatedEvents
        case relationships
        case resourceCreationTime
        case resourceId
        case resourceName
        case resourceType
        case supplementaryConfiguration
        case tags
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let configurationItemCaptureTime = configurationItemCaptureTime {
            try encodeContainer.encode(configurationItemCaptureTime.timeIntervalSince1970, forKey: .configurationItemCaptureTime)
        }
        if let configurationItemMD5Hash = configurationItemMD5Hash {
            try encodeContainer.encode(configurationItemMD5Hash, forKey: .configurationItemMD5Hash)
        }
        if let configurationItemStatus = configurationItemStatus {
            try encodeContainer.encode(configurationItemStatus.rawValue, forKey: .configurationItemStatus)
        }
        if let configurationStateId = configurationStateId {
            try encodeContainer.encode(configurationStateId, forKey: .configurationStateId)
        }
        if let relatedEvents = relatedEvents {
            var relatedEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedEvents)
            for relatedeventlist0 in relatedEvents {
                try relatedEventsContainer.encode(relatedeventlist0)
            }
        }
        if let relationships = relationships {
            var relationshipsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relationships)
            for relationshiplist0 in relationships {
                try relationshipsContainer.encode(relationshiplist0)
            }
        }
        if let resourceCreationTime = resourceCreationTime {
            try encodeContainer.encode(resourceCreationTime.timeIntervalSince1970, forKey: .resourceCreationTime)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let supplementaryConfiguration = supplementaryConfiguration {
            var supplementaryConfigurationContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .supplementaryConfiguration)
            for (dictKey0, supplementaryconfiguration0) in supplementaryConfiguration {
                try supplementaryConfigurationContainer.encode(supplementaryconfiguration0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let configurationItemCaptureTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .configurationItemCaptureTime)
        configurationItemCaptureTime = configurationItemCaptureTimeDecoded
        let configurationItemStatusDecoded = try containerValues.decodeIfPresent(ConfigurationItemStatus.self, forKey: .configurationItemStatus)
        configurationItemStatus = configurationItemStatusDecoded
        let configurationStateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationStateId)
        configurationStateId = configurationStateIdDecoded
        let configurationItemMD5HashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationItemMD5Hash)
        configurationItemMD5Hash = configurationItemMD5HashDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let resourceCreationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .resourceCreationTime)
        resourceCreationTime = resourceCreationTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, value0) in tagsContainer {
                if let value0 = value0 {
                    tagsDecoded0?[key0] = value0
                }
            }
        }
        tags = tagsDecoded0
        let relatedEventsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .relatedEvents)
        var relatedEventsDecoded0:[String]? = nil
        if let relatedEventsContainer = relatedEventsContainer {
            relatedEventsDecoded0 = [String]()
            for string0 in relatedEventsContainer {
                if let string0 = string0 {
                    relatedEventsDecoded0?.append(string0)
                }
            }
        }
        relatedEvents = relatedEventsDecoded0
        let relationshipsContainer = try containerValues.decodeIfPresent([Relationship?].self, forKey: .relationships)
        var relationshipsDecoded0:[Relationship]? = nil
        if let relationshipsContainer = relationshipsContainer {
            relationshipsDecoded0 = [Relationship]()
            for structure0 in relationshipsContainer {
                if let structure0 = structure0 {
                    relationshipsDecoded0?.append(structure0)
                }
            }
        }
        relationships = relationshipsDecoded0
        let configurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configuration)
        configuration = configurationDecoded
        let supplementaryConfigurationContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .supplementaryConfiguration)
        var supplementaryConfigurationDecoded0: [String:String]? = nil
        if let supplementaryConfigurationContainer = supplementaryConfigurationContainer {
            supplementaryConfigurationDecoded0 = [String:String]()
            for (key0, supplementaryconfigurationvalue0) in supplementaryConfigurationContainer {
                if let supplementaryconfigurationvalue0 = supplementaryconfigurationvalue0 {
                    supplementaryConfigurationDecoded0?[key0] = supplementaryconfigurationvalue0
                }
            }
        }
        supplementaryConfiguration = supplementaryConfigurationDecoded0
    }
}

extension ConfigurationItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigurationItem(accountId: \(String(describing: accountId)), arn: \(String(describing: arn)), availabilityZone: \(String(describing: availabilityZone)), awsRegion: \(String(describing: awsRegion)), configuration: \(String(describing: configuration)), configurationItemCaptureTime: \(String(describing: configurationItemCaptureTime)), configurationItemMD5Hash: \(String(describing: configurationItemMD5Hash)), configurationItemStatus: \(String(describing: configurationItemStatus)), configurationStateId: \(String(describing: configurationStateId)), relatedEvents: \(String(describing: relatedEvents)), relationships: \(String(describing: relationships)), resourceCreationTime: \(String(describing: resourceCreationTime)), resourceId: \(String(describing: resourceId)), resourceName: \(String(describing: resourceName)), resourceType: \(String(describing: resourceType)), supplementaryConfiguration: \(String(describing: supplementaryConfiguration)), tags: \(String(describing: tags)), version: \(String(describing: version)))"}
}

/// <p>A list that contains detailed configurations of a specified
/// 			resource.</p>
public struct ConfigurationItem: Equatable {
    /// <p>The 12-digit AWS account ID associated with the
    /// 			resource.</p>
    public let accountId: String?
    /// <p>Amazon Resource Name (ARN) associated with the resource.</p>
    public let arn: String?
    /// <p>The Availability Zone associated with the resource.</p>
    public let availabilityZone: String?
    /// <p>The region where the resource resides.</p>
    public let awsRegion: String?
    /// <p>The description of the resource configuration.</p>
    public let configuration: String?
    /// <p>The time when the configuration recording was
    /// 			initiated.</p>
    public let configurationItemCaptureTime: Date?
    /// <p>Unique MD5 hash that represents the configuration item's
    /// 			state.</p>
    /// 		       <p>You can use MD5 hash to compare the states of two or more
    /// 			configuration items that are associated with the same
    /// 			resource.</p>
    public let configurationItemMD5Hash: String?
    /// <p>The configuration item status. The valid values are:</p>
    /// 		
    /// 		       <ul>
    ///             <li>
    ///                <p>OK – The resource configuration has been updated</p>
    ///             </li>
    ///             <li>
    ///                <p>ResourceDiscovered – The resource was newly discovered</p>
    ///             </li>
    ///             <li>
    ///                <p>ResourceNotRecorded – The resource was discovered but its configuration was not recorded since the recorder excludes the recording of resources of this type</p>
    ///             </li>
    ///             <li>
    ///                <p>ResourceDeleted – The resource was deleted</p>
    ///             </li>
    ///             <li>
    ///                <p>ResourceDeletedNotRecorded – The resource was deleted but its configuration was not recorded since the recorder excludes the recording of resources of this type</p>
    ///             </li>
    ///          </ul>
    /// 		       <note>
    ///             <p>The CIs do not incur any cost.</p>
    ///          </note>
    public let configurationItemStatus: ConfigurationItemStatus?
    /// <p>An identifier that indicates the ordering of the configuration
    /// 			items of a resource.</p>
    public let configurationStateId: String?
    /// <p>A list of CloudTrail event IDs.</p>
    /// 		       <p>A populated field indicates that the current configuration was
    /// 			initiated by the events recorded in the CloudTrail log. For more
    /// 			information about CloudTrail, see <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/what_is_cloud_trail_top_level.html">What Is AWS CloudTrail</a>.</p>
    /// 		       <p>An empty field indicates that the current configuration was not
    /// 			initiated by any event. As of Version 1.3, the relatedEvents field is empty.
    /// 			You can access the <a href="https://docs.aws.amazon.com/awscloudtrail/latest/APIReference/API_LookupEvents.html">LookupEvents API</a> in the <i>AWS CloudTrail API Reference</i> to retrieve the events for the resource.</p>
    public let relatedEvents: [String]?
    /// <p>A list of related AWS resources.</p>
    public let relationships: [Relationship]?
    /// <p>The time stamp when the resource was created.</p>
    public let resourceCreationTime: Date?
    /// <p>The ID of the resource (for example,
    /// 			<code>sg-xxxxxx</code>).</p>
    public let resourceId: String?
    /// <p>The custom name of the resource, if available.</p>
    public let resourceName: String?
    /// <p>The type of AWS resource.</p>
    public let resourceType: ResourceType?
    /// <p>Configuration attributes that AWS Config returns for certain
    /// 			resource types to supplement the information returned for the
    /// 				<code>configuration</code> parameter.</p>
    public let supplementaryConfiguration: [String:String]?
    /// <p>A mapping of key value tags associated with the
    /// 			resource.</p>
    public let tags: [String:String]?
    /// <p>The version number of the resource configuration.</p>
    public let version: String?

    public init (
        accountId: String? = nil,
        arn: String? = nil,
        availabilityZone: String? = nil,
        awsRegion: String? = nil,
        configuration: String? = nil,
        configurationItemCaptureTime: Date? = nil,
        configurationItemMD5Hash: String? = nil,
        configurationItemStatus: ConfigurationItemStatus? = nil,
        configurationStateId: String? = nil,
        relatedEvents: [String]? = nil,
        relationships: [Relationship]? = nil,
        resourceCreationTime: Date? = nil,
        resourceId: String? = nil,
        resourceName: String? = nil,
        resourceType: ResourceType? = nil,
        supplementaryConfiguration: [String:String]? = nil,
        tags: [String:String]? = nil,
        version: String? = nil
    )
    {
        self.accountId = accountId
        self.arn = arn
        self.availabilityZone = availabilityZone
        self.awsRegion = awsRegion
        self.configuration = configuration
        self.configurationItemCaptureTime = configurationItemCaptureTime
        self.configurationItemMD5Hash = configurationItemMD5Hash
        self.configurationItemStatus = configurationItemStatus
        self.configurationStateId = configurationStateId
        self.relatedEvents = relatedEvents
        self.relationships = relationships
        self.resourceCreationTime = resourceCreationTime
        self.resourceId = resourceId
        self.resourceName = resourceName
        self.resourceType = resourceType
        self.supplementaryConfiguration = supplementaryConfiguration
        self.tags = tags
        self.version = version
    }
}

public enum ConfigurationItemStatus {
    case ok
    case resourcedeleted
    case resourcedeletednotrecorded
    case resourcediscovered
    case resourcenotrecorded
    case sdkUnknown(String)
}

extension ConfigurationItemStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConfigurationItemStatus] {
        return [
            .ok,
            .resourcedeleted,
            .resourcedeletednotrecorded,
            .resourcediscovered,
            .resourcenotrecorded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ok: return "OK"
        case .resourcedeleted: return "ResourceDeleted"
        case .resourcedeletednotrecorded: return "ResourceDeletedNotRecorded"
        case .resourcediscovered: return "ResourceDiscovered"
        case .resourcenotrecorded: return "ResourceNotRecorded"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConfigurationItemStatus(rawValue: rawValue) ?? ConfigurationItemStatus.sdkUnknown(rawValue)
    }
}

extension ConfigurationRecorder: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case recordingGroup
        case roleARN
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recordingGroup = recordingGroup {
            try encodeContainer.encode(recordingGroup, forKey: .recordingGroup)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let recordingGroupDecoded = try containerValues.decodeIfPresent(RecordingGroup.self, forKey: .recordingGroup)
        recordingGroup = recordingGroupDecoded
    }
}

extension ConfigurationRecorder: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigurationRecorder(name: \(String(describing: name)), recordingGroup: \(String(describing: recordingGroup)), roleARN: \(String(describing: roleARN)))"}
}

/// <p>An object that represents the recording of configuration
/// 			changes of an AWS resource.</p>
public struct ConfigurationRecorder: Equatable {
    /// <p>The name of the recorder. By default, AWS Config automatically
    /// 			assigns the name "default" when creating the configuration recorder.
    /// 			You cannot change the assigned name.</p>
    public let name: String?
    /// <p>Specifies the types of AWS resources for which AWS Config
    /// 			records configuration changes.</p>
    public let recordingGroup: RecordingGroup?
    /// <p>Amazon Resource Name (ARN) of the IAM role used to describe the
    /// 			AWS resources associated with the account.</p>
    public let roleARN: String?

    public init (
        name: String? = nil,
        recordingGroup: RecordingGroup? = nil,
        roleARN: String? = nil
    )
    {
        self.name = name
        self.recordingGroup = recordingGroup
        self.roleARN = roleARN
    }
}

extension ConfigurationRecorderStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastErrorCode
        case lastErrorMessage
        case lastStartTime
        case lastStatus
        case lastStatusChangeTime
        case lastStopTime
        case name
        case recording
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastErrorCode = lastErrorCode {
            try encodeContainer.encode(lastErrorCode, forKey: .lastErrorCode)
        }
        if let lastErrorMessage = lastErrorMessage {
            try encodeContainer.encode(lastErrorMessage, forKey: .lastErrorMessage)
        }
        if let lastStartTime = lastStartTime {
            try encodeContainer.encode(lastStartTime.timeIntervalSince1970, forKey: .lastStartTime)
        }
        if let lastStatus = lastStatus {
            try encodeContainer.encode(lastStatus.rawValue, forKey: .lastStatus)
        }
        if let lastStatusChangeTime = lastStatusChangeTime {
            try encodeContainer.encode(lastStatusChangeTime.timeIntervalSince1970, forKey: .lastStatusChangeTime)
        }
        if let lastStopTime = lastStopTime {
            try encodeContainer.encode(lastStopTime.timeIntervalSince1970, forKey: .lastStopTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if recording != false {
            try encodeContainer.encode(recording, forKey: .recording)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let lastStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastStartTime)
        lastStartTime = lastStartTimeDecoded
        let lastStopTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastStopTime)
        lastStopTime = lastStopTimeDecoded
        let recordingDecoded = try containerValues.decode(Bool.self, forKey: .recording)
        recording = recordingDecoded
        let lastStatusDecoded = try containerValues.decodeIfPresent(RecorderStatus.self, forKey: .lastStatus)
        lastStatus = lastStatusDecoded
        let lastErrorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastErrorCode)
        lastErrorCode = lastErrorCodeDecoded
        let lastErrorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastErrorMessage)
        lastErrorMessage = lastErrorMessageDecoded
        let lastStatusChangeTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastStatusChangeTime)
        lastStatusChangeTime = lastStatusChangeTimeDecoded
    }
}

extension ConfigurationRecorderStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigurationRecorderStatus(lastErrorCode: \(String(describing: lastErrorCode)), lastErrorMessage: \(String(describing: lastErrorMessage)), lastStartTime: \(String(describing: lastStartTime)), lastStatus: \(String(describing: lastStatus)), lastStatusChangeTime: \(String(describing: lastStatusChangeTime)), lastStopTime: \(String(describing: lastStopTime)), name: \(String(describing: name)), recording: \(String(describing: recording)))"}
}

/// <p>The current status of the configuration recorder.</p>
public struct ConfigurationRecorderStatus: Equatable {
    /// <p>The error code indicating that the recording failed.</p>
    public let lastErrorCode: String?
    /// <p>The message indicating that the recording failed due to an
    /// 			error.</p>
    public let lastErrorMessage: String?
    /// <p>The time the recorder was last started.</p>
    public let lastStartTime: Date?
    /// <p>The last (previous) status of the recorder.</p>
    public let lastStatus: RecorderStatus?
    /// <p>The time when the status was last changed.</p>
    public let lastStatusChangeTime: Date?
    /// <p>The time the recorder was last stopped.</p>
    public let lastStopTime: Date?
    /// <p>The name of the configuration recorder.</p>
    public let name: String?
    /// <p>Specifies whether or not the recorder is currently
    /// 			recording.</p>
    public let recording: Bool

    public init (
        lastErrorCode: String? = nil,
        lastErrorMessage: String? = nil,
        lastStartTime: Date? = nil,
        lastStatus: RecorderStatus? = nil,
        lastStatusChangeTime: Date? = nil,
        lastStopTime: Date? = nil,
        name: String? = nil,
        recording: Bool = false
    )
    {
        self.lastErrorCode = lastErrorCode
        self.lastErrorMessage = lastErrorMessage
        self.lastStartTime = lastStartTime
        self.lastStatus = lastStatus
        self.lastStatusChangeTime = lastStatusChangeTime
        self.lastStopTime = lastStopTime
        self.name = name
        self.recording = recording
    }
}

extension ConformancePackComplianceFilters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceType = "ComplianceType"
        case configRuleNames = "ConfigRuleNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
        if let configRuleNames = configRuleNames {
            var configRuleNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configRuleNames)
            for conformancepackconfigrulenames0 in configRuleNames {
                try configRuleNamesContainer.encode(conformancepackconfigrulenames0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .configRuleNames)
        var configRuleNamesDecoded0:[String]? = nil
        if let configRuleNamesContainer = configRuleNamesContainer {
            configRuleNamesDecoded0 = [String]()
            for string0 in configRuleNamesContainer {
                if let string0 = string0 {
                    configRuleNamesDecoded0?.append(string0)
                }
            }
        }
        configRuleNames = configRuleNamesDecoded0
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ConformancePackComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
    }
}

extension ConformancePackComplianceFilters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConformancePackComplianceFilters(complianceType: \(String(describing: complianceType)), configRuleNames: \(String(describing: configRuleNames)))"}
}

/// <p>Filters the conformance pack by compliance types and AWS Config rule names.</p>
public struct ConformancePackComplianceFilters: Equatable {
    /// <p>Filters the results by compliance.</p>
    /// 		       <p>The allowed values are <code>COMPLIANT</code> and <code>NON_COMPLIANT</code>. <code>INSUFFICIENT_DATA</code> is not supported.</p>
    public let complianceType: ConformancePackComplianceType?
    /// <p>Filters the results by AWS Config rule names.</p>
    public let configRuleNames: [String]?

    public init (
        complianceType: ConformancePackComplianceType? = nil,
        configRuleNames: [String]? = nil
    )
    {
        self.complianceType = complianceType
        self.configRuleNames = configRuleNames
    }
}

extension ConformancePackComplianceSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conformancePackComplianceStatus = "ConformancePackComplianceStatus"
        case conformancePackName = "ConformancePackName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackComplianceStatus = conformancePackComplianceStatus {
            try encodeContainer.encode(conformancePackComplianceStatus.rawValue, forKey: .conformancePackComplianceStatus)
        }
        if let conformancePackName = conformancePackName {
            try encodeContainer.encode(conformancePackName, forKey: .conformancePackName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conformancePackName)
        conformancePackName = conformancePackNameDecoded
        let conformancePackComplianceStatusDecoded = try containerValues.decodeIfPresent(ConformancePackComplianceType.self, forKey: .conformancePackComplianceStatus)
        conformancePackComplianceStatus = conformancePackComplianceStatusDecoded
    }
}

extension ConformancePackComplianceSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConformancePackComplianceSummary(conformancePackComplianceStatus: \(String(describing: conformancePackComplianceStatus)), conformancePackName: \(String(describing: conformancePackName)))"}
}

/// <p>Summary includes the name and status of the conformance pack.</p>
public struct ConformancePackComplianceSummary: Equatable {
    /// <p>The status of the conformance pack. The allowed values are <code>COMPLIANT</code>, <code>NON_COMPLIANT</code> and <code>INSUFFICIENT_DATA</code>.</p>
    public let conformancePackComplianceStatus: ConformancePackComplianceType?
    /// <p>The name of the conformance pack name.</p>
    public let conformancePackName: String?

    public init (
        conformancePackComplianceStatus: ConformancePackComplianceType? = nil,
        conformancePackName: String? = nil
    )
    {
        self.conformancePackComplianceStatus = conformancePackComplianceStatus
        self.conformancePackName = conformancePackName
    }
}

public enum ConformancePackComplianceType {
    case compliant
    case insufficientData
    case nonCompliant
    case sdkUnknown(String)
}

extension ConformancePackComplianceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConformancePackComplianceType] {
        return [
            .compliant,
            .insufficientData,
            .nonCompliant,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .compliant: return "COMPLIANT"
        case .insufficientData: return "INSUFFICIENT_DATA"
        case .nonCompliant: return "NON_COMPLIANT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConformancePackComplianceType(rawValue: rawValue) ?? ConformancePackComplianceType.sdkUnknown(rawValue)
    }
}

extension ConformancePackDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conformancePackArn = "ConformancePackArn"
        case conformancePackId = "ConformancePackId"
        case conformancePackInputParameters = "ConformancePackInputParameters"
        case conformancePackName = "ConformancePackName"
        case createdBy = "CreatedBy"
        case deliveryS3Bucket = "DeliveryS3Bucket"
        case deliveryS3KeyPrefix = "DeliveryS3KeyPrefix"
        case lastUpdateRequestedTime = "LastUpdateRequestedTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackArn = conformancePackArn {
            try encodeContainer.encode(conformancePackArn, forKey: .conformancePackArn)
        }
        if let conformancePackId = conformancePackId {
            try encodeContainer.encode(conformancePackId, forKey: .conformancePackId)
        }
        if let conformancePackInputParameters = conformancePackInputParameters {
            var conformancePackInputParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conformancePackInputParameters)
            for conformancepackinputparameters0 in conformancePackInputParameters {
                try conformancePackInputParametersContainer.encode(conformancepackinputparameters0)
            }
        }
        if let conformancePackName = conformancePackName {
            try encodeContainer.encode(conformancePackName, forKey: .conformancePackName)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let deliveryS3Bucket = deliveryS3Bucket {
            try encodeContainer.encode(deliveryS3Bucket, forKey: .deliveryS3Bucket)
        }
        if let deliveryS3KeyPrefix = deliveryS3KeyPrefix {
            try encodeContainer.encode(deliveryS3KeyPrefix, forKey: .deliveryS3KeyPrefix)
        }
        if let lastUpdateRequestedTime = lastUpdateRequestedTime {
            try encodeContainer.encode(lastUpdateRequestedTime.timeIntervalSince1970, forKey: .lastUpdateRequestedTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conformancePackName)
        conformancePackName = conformancePackNameDecoded
        let conformancePackArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conformancePackArn)
        conformancePackArn = conformancePackArnDecoded
        let conformancePackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conformancePackId)
        conformancePackId = conformancePackIdDecoded
        let deliveryS3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deliveryS3Bucket)
        deliveryS3Bucket = deliveryS3BucketDecoded
        let deliveryS3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deliveryS3KeyPrefix)
        deliveryS3KeyPrefix = deliveryS3KeyPrefixDecoded
        let conformancePackInputParametersContainer = try containerValues.decodeIfPresent([ConformancePackInputParameter?].self, forKey: .conformancePackInputParameters)
        var conformancePackInputParametersDecoded0:[ConformancePackInputParameter]? = nil
        if let conformancePackInputParametersContainer = conformancePackInputParametersContainer {
            conformancePackInputParametersDecoded0 = [ConformancePackInputParameter]()
            for structure0 in conformancePackInputParametersContainer {
                if let structure0 = structure0 {
                    conformancePackInputParametersDecoded0?.append(structure0)
                }
            }
        }
        conformancePackInputParameters = conformancePackInputParametersDecoded0
        let lastUpdateRequestedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateRequestedTime)
        lastUpdateRequestedTime = lastUpdateRequestedTimeDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

extension ConformancePackDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConformancePackDetail(conformancePackArn: \(String(describing: conformancePackArn)), conformancePackId: \(String(describing: conformancePackId)), conformancePackInputParameters: \(String(describing: conformancePackInputParameters)), conformancePackName: \(String(describing: conformancePackName)), createdBy: \(String(describing: createdBy)), deliveryS3Bucket: \(String(describing: deliveryS3Bucket)), deliveryS3KeyPrefix: \(String(describing: deliveryS3KeyPrefix)), lastUpdateRequestedTime: \(String(describing: lastUpdateRequestedTime)))"}
}

/// <p>Returns details of a conformance pack. A conformance pack is a collection of AWS Config rules and remediation actions that can be easily deployed in an account and a region.</p>
public struct ConformancePackDetail: Equatable {
    /// <p>Amazon Resource Name (ARN) of the conformance pack.</p>
    public let conformancePackArn: String?
    /// <p>ID of the conformance pack.</p>
    public let conformancePackId: String?
    /// <p>A list of <code>ConformancePackInputParameter</code> objects.</p>
    public let conformancePackInputParameters: [ConformancePackInputParameter]?
    /// <p>Name of the conformance pack.</p>
    public let conformancePackName: String?
    /// <p>AWS service that created the conformance pack.</p>
    public let createdBy: String?
    /// <p>Amazon S3 bucket where AWS Config stores conformance pack templates. </p>
    /// 	        <note>
    ///             <p>This field is optional.</p>
    ///          </note>
    public let deliveryS3Bucket: String?
    /// <p>The prefix for the Amazon S3 bucket.</p>
    /// 		       <note>
    ///             <p>This field is optional.</p>
    ///          </note>
    public let deliveryS3KeyPrefix: String?
    /// <p>Last time when conformation pack update was requested. </p>
    public let lastUpdateRequestedTime: Date?

    public init (
        conformancePackArn: String? = nil,
        conformancePackId: String? = nil,
        conformancePackInputParameters: [ConformancePackInputParameter]? = nil,
        conformancePackName: String? = nil,
        createdBy: String? = nil,
        deliveryS3Bucket: String? = nil,
        deliveryS3KeyPrefix: String? = nil,
        lastUpdateRequestedTime: Date? = nil
    )
    {
        self.conformancePackArn = conformancePackArn
        self.conformancePackId = conformancePackId
        self.conformancePackInputParameters = conformancePackInputParameters
        self.conformancePackName = conformancePackName
        self.createdBy = createdBy
        self.deliveryS3Bucket = deliveryS3Bucket
        self.deliveryS3KeyPrefix = deliveryS3KeyPrefix
        self.lastUpdateRequestedTime = lastUpdateRequestedTime
    }
}

extension ConformancePackEvaluationFilters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceType = "ComplianceType"
        case configRuleNames = "ConfigRuleNames"
        case resourceIds = "ResourceIds"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
        if let configRuleNames = configRuleNames {
            var configRuleNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configRuleNames)
            for conformancepackconfigrulenames0 in configRuleNames {
                try configRuleNamesContainer.encode(conformancepackconfigrulenames0)
            }
        }
        if let resourceIds = resourceIds {
            var resourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIds)
            for conformancepackcomplianceresourceids0 in resourceIds {
                try resourceIdsContainer.encode(conformancepackcomplianceresourceids0)
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .configRuleNames)
        var configRuleNamesDecoded0:[String]? = nil
        if let configRuleNamesContainer = configRuleNamesContainer {
            configRuleNamesDecoded0 = [String]()
            for string0 in configRuleNamesContainer {
                if let string0 = string0 {
                    configRuleNamesDecoded0?.append(string0)
                }
            }
        }
        configRuleNames = configRuleNamesDecoded0
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ConformancePackComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceIds)
        var resourceIdsDecoded0:[String]? = nil
        if let resourceIdsContainer = resourceIdsContainer {
            resourceIdsDecoded0 = [String]()
            for string0 in resourceIdsContainer {
                if let string0 = string0 {
                    resourceIdsDecoded0?.append(string0)
                }
            }
        }
        resourceIds = resourceIdsDecoded0
    }
}

extension ConformancePackEvaluationFilters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConformancePackEvaluationFilters(complianceType: \(String(describing: complianceType)), configRuleNames: \(String(describing: configRuleNames)), resourceIds: \(String(describing: resourceIds)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Filters a conformance pack by AWS Config rule names, compliance types, AWS resource types, and resource IDs.</p>
public struct ConformancePackEvaluationFilters: Equatable {
    /// <p>Filters the results by compliance.</p>
    /// 		       <p>The allowed values are <code>COMPLIANT</code> and <code>NON_COMPLIANT</code>. <code>INSUFFICIENT_DATA</code> is not supported.</p>
    public let complianceType: ConformancePackComplianceType?
    /// <p>Filters the results by AWS Config rule names.</p>
    public let configRuleNames: [String]?
    /// <p>Filters the results by resource IDs.</p>
    /// 		       <note>
    ///             <p>This is valid only when you provide resource type. If there is no resource type, you will see an error.</p>
    ///          </note>
    public let resourceIds: [String]?
    /// <p>Filters the results by the resource type (for example, <code>"AWS::EC2::Instance"</code>). </p>
    public let resourceType: String?

    public init (
        complianceType: ConformancePackComplianceType? = nil,
        configRuleNames: [String]? = nil,
        resourceIds: [String]? = nil,
        resourceType: String? = nil
    )
    {
        self.complianceType = complianceType
        self.configRuleNames = configRuleNames
        self.resourceIds = resourceIds
        self.resourceType = resourceType
    }
}

extension ConformancePackEvaluationResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case annotation = "Annotation"
        case complianceType = "ComplianceType"
        case configRuleInvokedTime = "ConfigRuleInvokedTime"
        case evaluationResultIdentifier = "EvaluationResultIdentifier"
        case resultRecordedTime = "ResultRecordedTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let annotation = annotation {
            try encodeContainer.encode(annotation, forKey: .annotation)
        }
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
        if let configRuleInvokedTime = configRuleInvokedTime {
            try encodeContainer.encode(configRuleInvokedTime.timeIntervalSince1970, forKey: .configRuleInvokedTime)
        }
        if let evaluationResultIdentifier = evaluationResultIdentifier {
            try encodeContainer.encode(evaluationResultIdentifier, forKey: .evaluationResultIdentifier)
        }
        if let resultRecordedTime = resultRecordedTime {
            try encodeContainer.encode(resultRecordedTime.timeIntervalSince1970, forKey: .resultRecordedTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ConformancePackComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let evaluationResultIdentifierDecoded = try containerValues.decodeIfPresent(EvaluationResultIdentifier.self, forKey: .evaluationResultIdentifier)
        evaluationResultIdentifier = evaluationResultIdentifierDecoded
        let configRuleInvokedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .configRuleInvokedTime)
        configRuleInvokedTime = configRuleInvokedTimeDecoded
        let resultRecordedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .resultRecordedTime)
        resultRecordedTime = resultRecordedTimeDecoded
        let annotationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .annotation)
        annotation = annotationDecoded
    }
}

extension ConformancePackEvaluationResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConformancePackEvaluationResult(annotation: \(String(describing: annotation)), complianceType: \(String(describing: complianceType)), configRuleInvokedTime: \(String(describing: configRuleInvokedTime)), evaluationResultIdentifier: \(String(describing: evaluationResultIdentifier)), resultRecordedTime: \(String(describing: resultRecordedTime)))"}
}

/// <p>The details of a conformance pack evaluation. Provides AWS Config rule and AWS resource type that was evaluated, the compliance of the conformance pack, related time stamps, and supplementary information. </p>
public struct ConformancePackEvaluationResult: Equatable {
    /// <p>Supplementary information about how the evaluation determined the compliance. </p>
    public let annotation: String?
    /// <p>The compliance type. The allowed values are <code>COMPLIANT</code> and <code>NON_COMPLIANT</code>. <code>INSUFFICIENT_DATA</code> is not supported.</p>
    public let complianceType: ConformancePackComplianceType?
    /// <p>The time when AWS Config rule evaluated AWS resource.</p>
    public let configRuleInvokedTime: Date?
    /// <p>Uniquely identifies an evaluation result.</p>
    public let evaluationResultIdentifier: EvaluationResultIdentifier?
    /// <p>The time when AWS Config recorded the evaluation result. </p>
    public let resultRecordedTime: Date?

    public init (
        annotation: String? = nil,
        complianceType: ConformancePackComplianceType? = nil,
        configRuleInvokedTime: Date? = nil,
        evaluationResultIdentifier: EvaluationResultIdentifier? = nil,
        resultRecordedTime: Date? = nil
    )
    {
        self.annotation = annotation
        self.complianceType = complianceType
        self.configRuleInvokedTime = configRuleInvokedTime
        self.evaluationResultIdentifier = evaluationResultIdentifier
        self.resultRecordedTime = resultRecordedTime
    }
}

extension ConformancePackInputParameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case parameterName = "ParameterName"
        case parameterValue = "ParameterValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterName = parameterName {
            try encodeContainer.encode(parameterName, forKey: .parameterName)
        }
        if let parameterValue = parameterValue {
            try encodeContainer.encode(parameterValue, forKey: .parameterValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
    }
}

extension ConformancePackInputParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConformancePackInputParameter(parameterName: \(String(describing: parameterName)), parameterValue: \(String(describing: parameterValue)))"}
}

/// <p>Input parameters in the form of key-value pairs for the conformance pack, both of which you define.
/// 			Keys can have a maximum character length of 255 characters, and values can have a maximum length of 4096 characters.</p>
public struct ConformancePackInputParameter: Equatable {
    /// <p>One part of a key-value pair.</p>
    public let parameterName: String?
    /// <p>Another part of the key-value pair. </p>
    public let parameterValue: String?

    public init (
        parameterName: String? = nil,
        parameterValue: String? = nil
    )
    {
        self.parameterName = parameterName
        self.parameterValue = parameterValue
    }
}

extension ConformancePackRuleCompliance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceType = "ComplianceType"
        case configRuleName = "ConfigRuleName"
        case controls = "Controls"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
        if let configRuleName = configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let controls = controls {
            var controlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controls)
            for controlslist0 in controls {
                try controlsContainer.encode(controlslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ConformancePackComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let controlsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .controls)
        var controlsDecoded0:[String]? = nil
        if let controlsContainer = controlsContainer {
            controlsDecoded0 = [String]()
            for string0 in controlsContainer {
                if let string0 = string0 {
                    controlsDecoded0?.append(string0)
                }
            }
        }
        controls = controlsDecoded0
    }
}

extension ConformancePackRuleCompliance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConformancePackRuleCompliance(complianceType: \(String(describing: complianceType)), configRuleName: \(String(describing: configRuleName)), controls: \(String(describing: controls)))"}
}

/// <p>Compliance information of one or more AWS Config rules within a conformance pack. You can filter using AWS Config rule names and compliance types.</p>
public struct ConformancePackRuleCompliance: Equatable {
    /// <p>Compliance of the AWS Config rule.</p>
    /// 		       <p>The allowed values are <code>COMPLIANT</code>, <code>NON_COMPLIANT</code>, and <code>INSUFFICIENT_DATA</code>.</p>
    public let complianceType: ConformancePackComplianceType?
    /// <p>Name of the config rule.</p>
    public let configRuleName: String?
    /// <p>Controls for the conformance pack. A control is a process to prevent or detect problems while meeting objectives.
    /// 			A control can align with a specific compliance regime or map to internal controls defined by an organization.</p>
    public let controls: [String]?

    public init (
        complianceType: ConformancePackComplianceType? = nil,
        configRuleName: String? = nil,
        controls: [String]? = nil
    )
    {
        self.complianceType = complianceType
        self.configRuleName = configRuleName
        self.controls = controls
    }
}

public enum ConformancePackState {
    case createComplete
    case createFailed
    case createInProgress
    case deleteFailed
    case deleteInProgress
    case sdkUnknown(String)
}

extension ConformancePackState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConformancePackState] {
        return [
            .createComplete,
            .createFailed,
            .createInProgress,
            .deleteFailed,
            .deleteInProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createComplete: return "CREATE_COMPLETE"
        case .createFailed: return "CREATE_FAILED"
        case .createInProgress: return "CREATE_IN_PROGRESS"
        case .deleteFailed: return "DELETE_FAILED"
        case .deleteInProgress: return "DELETE_IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConformancePackState(rawValue: rawValue) ?? ConformancePackState.sdkUnknown(rawValue)
    }
}

extension ConformancePackStatusDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conformancePackArn = "ConformancePackArn"
        case conformancePackId = "ConformancePackId"
        case conformancePackName = "ConformancePackName"
        case conformancePackState = "ConformancePackState"
        case conformancePackStatusReason = "ConformancePackStatusReason"
        case lastUpdateCompletedTime = "LastUpdateCompletedTime"
        case lastUpdateRequestedTime = "LastUpdateRequestedTime"
        case stackArn = "StackArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackArn = conformancePackArn {
            try encodeContainer.encode(conformancePackArn, forKey: .conformancePackArn)
        }
        if let conformancePackId = conformancePackId {
            try encodeContainer.encode(conformancePackId, forKey: .conformancePackId)
        }
        if let conformancePackName = conformancePackName {
            try encodeContainer.encode(conformancePackName, forKey: .conformancePackName)
        }
        if let conformancePackState = conformancePackState {
            try encodeContainer.encode(conformancePackState.rawValue, forKey: .conformancePackState)
        }
        if let conformancePackStatusReason = conformancePackStatusReason {
            try encodeContainer.encode(conformancePackStatusReason, forKey: .conformancePackStatusReason)
        }
        if let lastUpdateCompletedTime = lastUpdateCompletedTime {
            try encodeContainer.encode(lastUpdateCompletedTime.timeIntervalSince1970, forKey: .lastUpdateCompletedTime)
        }
        if let lastUpdateRequestedTime = lastUpdateRequestedTime {
            try encodeContainer.encode(lastUpdateRequestedTime.timeIntervalSince1970, forKey: .lastUpdateRequestedTime)
        }
        if let stackArn = stackArn {
            try encodeContainer.encode(stackArn, forKey: .stackArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conformancePackName)
        conformancePackName = conformancePackNameDecoded
        let conformancePackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conformancePackId)
        conformancePackId = conformancePackIdDecoded
        let conformancePackArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conformancePackArn)
        conformancePackArn = conformancePackArnDecoded
        let conformancePackStateDecoded = try containerValues.decodeIfPresent(ConformancePackState.self, forKey: .conformancePackState)
        conformancePackState = conformancePackStateDecoded
        let stackArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackArn)
        stackArn = stackArnDecoded
        let conformancePackStatusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conformancePackStatusReason)
        conformancePackStatusReason = conformancePackStatusReasonDecoded
        let lastUpdateRequestedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateRequestedTime)
        lastUpdateRequestedTime = lastUpdateRequestedTimeDecoded
        let lastUpdateCompletedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateCompletedTime)
        lastUpdateCompletedTime = lastUpdateCompletedTimeDecoded
    }
}

extension ConformancePackStatusDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConformancePackStatusDetail(conformancePackArn: \(String(describing: conformancePackArn)), conformancePackId: \(String(describing: conformancePackId)), conformancePackName: \(String(describing: conformancePackName)), conformancePackState: \(String(describing: conformancePackState)), conformancePackStatusReason: \(String(describing: conformancePackStatusReason)), lastUpdateCompletedTime: \(String(describing: lastUpdateCompletedTime)), lastUpdateRequestedTime: \(String(describing: lastUpdateRequestedTime)), stackArn: \(String(describing: stackArn)))"}
}

/// <p>Status details of a conformance pack.</p>
public struct ConformancePackStatusDetail: Equatable {
    /// <p>Amazon Resource Name (ARN) of comformance pack.</p>
    public let conformancePackArn: String?
    /// <p>ID of the conformance pack.</p>
    public let conformancePackId: String?
    /// <p>Name of the conformance pack.</p>
    public let conformancePackName: String?
    /// <p>Indicates deployment status of conformance pack.</p>
    /// 		       <p>AWS Config sets the state of the conformance pack to:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>CREATE_IN_PROGRESS when a conformance pack creation is in progress for an account.</p>
    ///             </li>
    ///             <li>
    ///                <p>CREATE_COMPLETE when a conformance pack has been successfully created in your account.</p>
    ///             </li>
    ///             <li>
    ///                <p>CREATE_FAILED when a conformance pack creation failed in your account.</p>
    ///             </li>
    ///             <li>
    ///                <p>DELETE_IN_PROGRESS when a conformance pack deletion is in progress. </p>
    ///             </li>
    ///             <li>
    ///                <p>DELETE_FAILED when a conformance pack deletion failed in your account.</p>
    ///             </li>
    ///          </ul>
    public let conformancePackState: ConformancePackState?
    /// <p>The reason of conformance pack creation failure.</p>
    public let conformancePackStatusReason: String?
    /// <p>Last time when conformation pack creation and update was successful.</p>
    public let lastUpdateCompletedTime: Date?
    /// <p>Last time when conformation pack creation and update was requested.</p>
    public let lastUpdateRequestedTime: Date?
    /// <p>Amazon Resource Name (ARN) of AWS CloudFormation stack. </p>
    public let stackArn: String?

    public init (
        conformancePackArn: String? = nil,
        conformancePackId: String? = nil,
        conformancePackName: String? = nil,
        conformancePackState: ConformancePackState? = nil,
        conformancePackStatusReason: String? = nil,
        lastUpdateCompletedTime: Date? = nil,
        lastUpdateRequestedTime: Date? = nil,
        stackArn: String? = nil
    )
    {
        self.conformancePackArn = conformancePackArn
        self.conformancePackId = conformancePackId
        self.conformancePackName = conformancePackName
        self.conformancePackState = conformancePackState
        self.conformancePackStatusReason = conformancePackStatusReason
        self.lastUpdateCompletedTime = lastUpdateCompletedTime
        self.lastUpdateRequestedTime = lastUpdateRequestedTime
        self.stackArn = stackArn
    }
}

extension ConformancePackTemplateValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConformancePackTemplateValidationException(message: \(String(describing: message)))"}
}

extension ConformancePackTemplateValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConformancePackTemplateValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have specified a template that is not valid or supported.</p>
public struct ConformancePackTemplateValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConformancePackTemplateValidationExceptionBody: Equatable {
    public let message: String?
}

extension ConformancePackTemplateValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DeleteAggregationAuthorizationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAggregationAuthorizationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAggregationAuthorizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAggregationAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAggregationAuthorizationInput>
    public typealias MOutput = OperationOutput<DeleteAggregationAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAggregationAuthorizationOutputError>
}

extension DeleteAggregationAuthorizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAggregationAuthorizationInput(authorizedAccountId: \(String(describing: authorizedAccountId)), authorizedAwsRegion: \(String(describing: authorizedAwsRegion)))"}
}

extension DeleteAggregationAuthorizationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorizedAccountId = "AuthorizedAccountId"
        case authorizedAwsRegion = "AuthorizedAwsRegion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizedAccountId = authorizedAccountId {
            try encodeContainer.encode(authorizedAccountId, forKey: .authorizedAccountId)
        }
        if let authorizedAwsRegion = authorizedAwsRegion {
            try encodeContainer.encode(authorizedAwsRegion, forKey: .authorizedAwsRegion)
        }
    }
}

public struct DeleteAggregationAuthorizationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAggregationAuthorizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAggregationAuthorizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAggregationAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAggregationAuthorizationInput>
    public typealias MOutput = OperationOutput<DeleteAggregationAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAggregationAuthorizationOutputError>
}

public struct DeleteAggregationAuthorizationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAggregationAuthorizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAggregationAuthorizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAggregationAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAggregationAuthorizationInput>
    public typealias MOutput = OperationOutput<DeleteAggregationAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAggregationAuthorizationOutputError>
}

public struct DeleteAggregationAuthorizationInput: Equatable {
    /// <p>The 12-digit account ID of the account authorized to aggregate
    /// 			data.</p>
    public let authorizedAccountId: String?
    /// <p>The region authorized to collect aggregated data.</p>
    public let authorizedAwsRegion: String?

    public init (
        authorizedAccountId: String? = nil,
        authorizedAwsRegion: String? = nil
    )
    {
        self.authorizedAccountId = authorizedAccountId
        self.authorizedAwsRegion = authorizedAwsRegion
    }
}

struct DeleteAggregationAuthorizationInputBody: Equatable {
    public let authorizedAccountId: String?
    public let authorizedAwsRegion: String?
}

extension DeleteAggregationAuthorizationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizedAccountId = "AuthorizedAccountId"
        case authorizedAwsRegion = "AuthorizedAwsRegion"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizedAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizedAccountId)
        authorizedAccountId = authorizedAccountIdDecoded
        let authorizedAwsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizedAwsRegion)
        authorizedAwsRegion = authorizedAwsRegionDecoded
    }
}

extension DeleteAggregationAuthorizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAggregationAuthorizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAggregationAuthorizationOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAggregationAuthorizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAggregationAuthorizationOutputResponse()"}
}

extension DeleteAggregationAuthorizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAggregationAuthorizationOutputResponse: Equatable {

    public init() {}
}

struct DeleteAggregationAuthorizationOutputResponseBody: Equatable {
}

extension DeleteAggregationAuthorizationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteConfigRuleInputBodyMiddleware: Middleware {
    public let id: String = "DeleteConfigRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigRuleInput>
    public typealias MOutput = OperationOutput<DeleteConfigRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigRuleOutputError>
}

extension DeleteConfigRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigRuleInput(configRuleName: \(String(describing: configRuleName)))"}
}

extension DeleteConfigRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configRuleName = "ConfigRuleName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleName = configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
    }
}

public struct DeleteConfigRuleInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConfigRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigRuleInput>
    public typealias MOutput = OperationOutput<DeleteConfigRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigRuleOutputError>
}

public struct DeleteConfigRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConfigRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigRuleInput>
    public typealias MOutput = OperationOutput<DeleteConfigRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigRuleOutputError>
}

/// <p></p>
public struct DeleteConfigRuleInput: Equatable {
    /// <p>The name of the AWS Config rule that you want to
    /// 			delete.</p>
    public let configRuleName: String?

    public init (
        configRuleName: String? = nil
    )
    {
        self.configRuleName = configRuleName
    }
}

struct DeleteConfigRuleInputBody: Equatable {
    public let configRuleName: String?
}

extension DeleteConfigRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configRuleName = "ConfigRuleName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
    }
}

extension DeleteConfigRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConfigRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchConfigRuleException" : self = .noSuchConfigRuleException(try NoSuchConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConfigRuleOutputError: Equatable {
    case noSuchConfigRuleException(NoSuchConfigRuleException)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigRuleOutputResponse()"}
}

extension DeleteConfigRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConfigRuleOutputResponse: Equatable {

    public init() {}
}

struct DeleteConfigRuleOutputResponseBody: Equatable {
}

extension DeleteConfigRuleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteConfigurationAggregatorInputBodyMiddleware: Middleware {
    public let id: String = "DeleteConfigurationAggregatorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationAggregatorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationAggregatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationAggregatorInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationAggregatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationAggregatorOutputError>
}

extension DeleteConfigurationAggregatorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationAggregatorInput(configurationAggregatorName: \(String(describing: configurationAggregatorName)))"}
}

extension DeleteConfigurationAggregatorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationAggregatorName = configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
    }
}

public struct DeleteConfigurationAggregatorInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConfigurationAggregatorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationAggregatorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationAggregatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationAggregatorInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationAggregatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationAggregatorOutputError>
}

public struct DeleteConfigurationAggregatorInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConfigurationAggregatorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationAggregatorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationAggregatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationAggregatorInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationAggregatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationAggregatorOutputError>
}

public struct DeleteConfigurationAggregatorInput: Equatable {
    /// <p>The name of the configuration aggregator.</p>
    public let configurationAggregatorName: String?

    public init (
        configurationAggregatorName: String? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
    }
}

struct DeleteConfigurationAggregatorInputBody: Equatable {
    public let configurationAggregatorName: String?
}

extension DeleteConfigurationAggregatorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
    }
}

extension DeleteConfigurationAggregatorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConfigurationAggregatorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConfigurationAggregatorOutputError: Equatable {
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigurationAggregatorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationAggregatorOutputResponse()"}
}

extension DeleteConfigurationAggregatorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConfigurationAggregatorOutputResponse: Equatable {

    public init() {}
}

struct DeleteConfigurationAggregatorOutputResponseBody: Equatable {
}

extension DeleteConfigurationAggregatorOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteConfigurationRecorderInputBodyMiddleware: Middleware {
    public let id: String = "DeleteConfigurationRecorderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationRecorderInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationRecorderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationRecorderInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationRecorderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationRecorderOutputError>
}

extension DeleteConfigurationRecorderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationRecorderInput(configurationRecorderName: \(String(describing: configurationRecorderName)))"}
}

extension DeleteConfigurationRecorderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationRecorderName = "ConfigurationRecorderName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationRecorderName = configurationRecorderName {
            try encodeContainer.encode(configurationRecorderName, forKey: .configurationRecorderName)
        }
    }
}

public struct DeleteConfigurationRecorderInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConfigurationRecorderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationRecorderInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationRecorderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationRecorderInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationRecorderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationRecorderOutputError>
}

public struct DeleteConfigurationRecorderInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConfigurationRecorderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationRecorderInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationRecorderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationRecorderInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationRecorderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationRecorderOutputError>
}

/// <p>The request object for the
/// 				<code>DeleteConfigurationRecorder</code> action.</p>
public struct DeleteConfigurationRecorderInput: Equatable {
    /// <p>The name of the configuration recorder to be deleted. You can
    /// 			retrieve the name of your configuration recorder by using the
    /// 				<code>DescribeConfigurationRecorders</code> action.</p>
    public let configurationRecorderName: String?

    public init (
        configurationRecorderName: String? = nil
    )
    {
        self.configurationRecorderName = configurationRecorderName
    }
}

struct DeleteConfigurationRecorderInputBody: Equatable {
    public let configurationRecorderName: String?
}

extension DeleteConfigurationRecorderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationRecorderName = "ConfigurationRecorderName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationRecorderNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationRecorderName)
        configurationRecorderName = configurationRecorderNameDecoded
    }
}

extension DeleteConfigurationRecorderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConfigurationRecorderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchConfigurationRecorderException" : self = .noSuchConfigurationRecorderException(try NoSuchConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConfigurationRecorderOutputError: Equatable {
    case noSuchConfigurationRecorderException(NoSuchConfigurationRecorderException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigurationRecorderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationRecorderOutputResponse()"}
}

extension DeleteConfigurationRecorderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConfigurationRecorderOutputResponse: Equatable {

    public init() {}
}

struct DeleteConfigurationRecorderOutputResponseBody: Equatable {
}

extension DeleteConfigurationRecorderOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteConformancePackInputBodyMiddleware: Middleware {
    public let id: String = "DeleteConformancePackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConformancePackInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConformancePackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConformancePackInput>
    public typealias MOutput = OperationOutput<DeleteConformancePackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConformancePackOutputError>
}

extension DeleteConformancePackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConformancePackInput(conformancePackName: \(String(describing: conformancePackName)))"}
}

extension DeleteConformancePackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conformancePackName = "ConformancePackName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackName = conformancePackName {
            try encodeContainer.encode(conformancePackName, forKey: .conformancePackName)
        }
    }
}

public struct DeleteConformancePackInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConformancePackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConformancePackInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConformancePackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConformancePackInput>
    public typealias MOutput = OperationOutput<DeleteConformancePackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConformancePackOutputError>
}

public struct DeleteConformancePackInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConformancePackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConformancePackInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConformancePackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConformancePackInput>
    public typealias MOutput = OperationOutput<DeleteConformancePackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConformancePackOutputError>
}

public struct DeleteConformancePackInput: Equatable {
    /// <p>Name of the conformance pack you want to delete.</p>
    public let conformancePackName: String?

    public init (
        conformancePackName: String? = nil
    )
    {
        self.conformancePackName = conformancePackName
    }
}

struct DeleteConformancePackInputBody: Equatable {
    public let conformancePackName: String?
}

extension DeleteConformancePackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conformancePackName = "ConformancePackName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conformancePackName)
        conformancePackName = conformancePackNameDecoded
    }
}

extension DeleteConformancePackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConformancePackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchConformancePackException" : self = .noSuchConformancePackException(try NoSuchConformancePackException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConformancePackOutputError: Equatable {
    case noSuchConformancePackException(NoSuchConformancePackException)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConformancePackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConformancePackOutputResponse()"}
}

extension DeleteConformancePackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConformancePackOutputResponse: Equatable {

    public init() {}
}

struct DeleteConformancePackOutputResponseBody: Equatable {
}

extension DeleteConformancePackOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteDeliveryChannelInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDeliveryChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDeliveryChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDeliveryChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDeliveryChannelInput>
    public typealias MOutput = OperationOutput<DeleteDeliveryChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDeliveryChannelOutputError>
}

extension DeleteDeliveryChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDeliveryChannelInput(deliveryChannelName: \(String(describing: deliveryChannelName)))"}
}

extension DeleteDeliveryChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deliveryChannelName = "DeliveryChannelName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryChannelName = deliveryChannelName {
            try encodeContainer.encode(deliveryChannelName, forKey: .deliveryChannelName)
        }
    }
}

public struct DeleteDeliveryChannelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDeliveryChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDeliveryChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDeliveryChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDeliveryChannelInput>
    public typealias MOutput = OperationOutput<DeleteDeliveryChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDeliveryChannelOutputError>
}

public struct DeleteDeliveryChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDeliveryChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDeliveryChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDeliveryChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDeliveryChannelInput>
    public typealias MOutput = OperationOutput<DeleteDeliveryChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDeliveryChannelOutputError>
}

/// <p>The input for the <a>DeleteDeliveryChannel</a>
/// 			action. The action accepts the following data, in JSON format.
/// 		</p>
public struct DeleteDeliveryChannelInput: Equatable {
    /// <p>The name of the delivery channel to delete.</p>
    public let deliveryChannelName: String?

    public init (
        deliveryChannelName: String? = nil
    )
    {
        self.deliveryChannelName = deliveryChannelName
    }
}

struct DeleteDeliveryChannelInputBody: Equatable {
    public let deliveryChannelName: String?
}

extension DeleteDeliveryChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deliveryChannelName = "DeliveryChannelName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryChannelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deliveryChannelName)
        deliveryChannelName = deliveryChannelNameDecoded
    }
}

extension DeleteDeliveryChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDeliveryChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LastDeliveryChannelDeleteFailedException" : self = .lastDeliveryChannelDeleteFailedException(try LastDeliveryChannelDeleteFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDeliveryChannelException" : self = .noSuchDeliveryChannelException(try NoSuchDeliveryChannelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDeliveryChannelOutputError: Equatable {
    case lastDeliveryChannelDeleteFailedException(LastDeliveryChannelDeleteFailedException)
    case noSuchDeliveryChannelException(NoSuchDeliveryChannelException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDeliveryChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDeliveryChannelOutputResponse()"}
}

extension DeleteDeliveryChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDeliveryChannelOutputResponse: Equatable {

    public init() {}
}

struct DeleteDeliveryChannelOutputResponseBody: Equatable {
}

extension DeleteDeliveryChannelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteEvaluationResultsInputBodyMiddleware: Middleware {
    public let id: String = "DeleteEvaluationResultsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEvaluationResultsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEvaluationResultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEvaluationResultsInput>
    public typealias MOutput = OperationOutput<DeleteEvaluationResultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEvaluationResultsOutputError>
}

extension DeleteEvaluationResultsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEvaluationResultsInput(configRuleName: \(String(describing: configRuleName)))"}
}

extension DeleteEvaluationResultsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configRuleName = "ConfigRuleName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleName = configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
    }
}

public struct DeleteEvaluationResultsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEvaluationResultsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEvaluationResultsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEvaluationResultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEvaluationResultsInput>
    public typealias MOutput = OperationOutput<DeleteEvaluationResultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEvaluationResultsOutputError>
}

public struct DeleteEvaluationResultsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEvaluationResultsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEvaluationResultsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEvaluationResultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEvaluationResultsInput>
    public typealias MOutput = OperationOutput<DeleteEvaluationResultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEvaluationResultsOutputError>
}

/// <p></p>
public struct DeleteEvaluationResultsInput: Equatable {
    /// <p>The name of the AWS Config rule for which you want to delete
    /// 			the evaluation results.</p>
    public let configRuleName: String?

    public init (
        configRuleName: String? = nil
    )
    {
        self.configRuleName = configRuleName
    }
}

struct DeleteEvaluationResultsInputBody: Equatable {
    public let configRuleName: String?
}

extension DeleteEvaluationResultsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configRuleName = "ConfigRuleName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
    }
}

extension DeleteEvaluationResultsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEvaluationResultsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchConfigRuleException" : self = .noSuchConfigRuleException(try NoSuchConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEvaluationResultsOutputError: Equatable {
    case noSuchConfigRuleException(NoSuchConfigRuleException)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEvaluationResultsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEvaluationResultsOutputResponse()"}
}

extension DeleteEvaluationResultsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The output when you delete the evaluation results for the
/// 			specified AWS Config rule.</p>
public struct DeleteEvaluationResultsOutputResponse: Equatable {

    public init() {}
}

struct DeleteEvaluationResultsOutputResponseBody: Equatable {
}

extension DeleteEvaluationResultsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteOrganizationConfigRuleInputBodyMiddleware: Middleware {
    public let id: String = "DeleteOrganizationConfigRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOrganizationConfigRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOrganizationConfigRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOrganizationConfigRuleInput>
    public typealias MOutput = OperationOutput<DeleteOrganizationConfigRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOrganizationConfigRuleOutputError>
}

extension DeleteOrganizationConfigRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteOrganizationConfigRuleInput(organizationConfigRuleName: \(String(describing: organizationConfigRuleName)))"}
}

extension DeleteOrganizationConfigRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case organizationConfigRuleName = "OrganizationConfigRuleName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationConfigRuleName = organizationConfigRuleName {
            try encodeContainer.encode(organizationConfigRuleName, forKey: .organizationConfigRuleName)
        }
    }
}

public struct DeleteOrganizationConfigRuleInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteOrganizationConfigRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOrganizationConfigRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOrganizationConfigRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOrganizationConfigRuleInput>
    public typealias MOutput = OperationOutput<DeleteOrganizationConfigRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOrganizationConfigRuleOutputError>
}

public struct DeleteOrganizationConfigRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteOrganizationConfigRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOrganizationConfigRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOrganizationConfigRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOrganizationConfigRuleInput>
    public typealias MOutput = OperationOutput<DeleteOrganizationConfigRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOrganizationConfigRuleOutputError>
}

public struct DeleteOrganizationConfigRuleInput: Equatable {
    /// <p>The name of organization config rule that you want to delete.</p>
    public let organizationConfigRuleName: String?

    public init (
        organizationConfigRuleName: String? = nil
    )
    {
        self.organizationConfigRuleName = organizationConfigRuleName
    }
}

struct DeleteOrganizationConfigRuleInputBody: Equatable {
    public let organizationConfigRuleName: String?
}

extension DeleteOrganizationConfigRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case organizationConfigRuleName = "OrganizationConfigRuleName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConfigRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationConfigRuleName)
        organizationConfigRuleName = organizationConfigRuleNameDecoded
    }
}

extension DeleteOrganizationConfigRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteOrganizationConfigRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchOrganizationConfigRuleException" : self = .noSuchOrganizationConfigRuleException(try NoSuchOrganizationConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAccessDeniedException" : self = .organizationAccessDeniedException(try OrganizationAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteOrganizationConfigRuleOutputError: Equatable {
    case noSuchOrganizationConfigRuleException(NoSuchOrganizationConfigRuleException)
    case organizationAccessDeniedException(OrganizationAccessDeniedException)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOrganizationConfigRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteOrganizationConfigRuleOutputResponse()"}
}

extension DeleteOrganizationConfigRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteOrganizationConfigRuleOutputResponse: Equatable {

    public init() {}
}

struct DeleteOrganizationConfigRuleOutputResponseBody: Equatable {
}

extension DeleteOrganizationConfigRuleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteOrganizationConformancePackInputBodyMiddleware: Middleware {
    public let id: String = "DeleteOrganizationConformancePackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOrganizationConformancePackInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOrganizationConformancePackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOrganizationConformancePackInput>
    public typealias MOutput = OperationOutput<DeleteOrganizationConformancePackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOrganizationConformancePackOutputError>
}

extension DeleteOrganizationConformancePackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteOrganizationConformancePackInput(organizationConformancePackName: \(String(describing: organizationConformancePackName)))"}
}

extension DeleteOrganizationConformancePackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case organizationConformancePackName = "OrganizationConformancePackName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationConformancePackName = organizationConformancePackName {
            try encodeContainer.encode(organizationConformancePackName, forKey: .organizationConformancePackName)
        }
    }
}

public struct DeleteOrganizationConformancePackInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteOrganizationConformancePackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOrganizationConformancePackInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOrganizationConformancePackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOrganizationConformancePackInput>
    public typealias MOutput = OperationOutput<DeleteOrganizationConformancePackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOrganizationConformancePackOutputError>
}

public struct DeleteOrganizationConformancePackInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteOrganizationConformancePackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOrganizationConformancePackInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOrganizationConformancePackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOrganizationConformancePackInput>
    public typealias MOutput = OperationOutput<DeleteOrganizationConformancePackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOrganizationConformancePackOutputError>
}

public struct DeleteOrganizationConformancePackInput: Equatable {
    /// <p>The name of organization conformance pack that you want to delete.</p>
    public let organizationConformancePackName: String?

    public init (
        organizationConformancePackName: String? = nil
    )
    {
        self.organizationConformancePackName = organizationConformancePackName
    }
}

struct DeleteOrganizationConformancePackInputBody: Equatable {
    public let organizationConformancePackName: String?
}

extension DeleteOrganizationConformancePackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case organizationConformancePackName = "OrganizationConformancePackName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConformancePackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationConformancePackName)
        organizationConformancePackName = organizationConformancePackNameDecoded
    }
}

extension DeleteOrganizationConformancePackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteOrganizationConformancePackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchOrganizationConformancePackException" : self = .noSuchOrganizationConformancePackException(try NoSuchOrganizationConformancePackException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAccessDeniedException" : self = .organizationAccessDeniedException(try OrganizationAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteOrganizationConformancePackOutputError: Equatable {
    case noSuchOrganizationConformancePackException(NoSuchOrganizationConformancePackException)
    case organizationAccessDeniedException(OrganizationAccessDeniedException)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOrganizationConformancePackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteOrganizationConformancePackOutputResponse()"}
}

extension DeleteOrganizationConformancePackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteOrganizationConformancePackOutputResponse: Equatable {

    public init() {}
}

struct DeleteOrganizationConformancePackOutputResponseBody: Equatable {
}

extension DeleteOrganizationConformancePackOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeletePendingAggregationRequestInputBodyMiddleware: Middleware {
    public let id: String = "DeletePendingAggregationRequestInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePendingAggregationRequestInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePendingAggregationRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePendingAggregationRequestInput>
    public typealias MOutput = OperationOutput<DeletePendingAggregationRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePendingAggregationRequestOutputError>
}

extension DeletePendingAggregationRequestInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePendingAggregationRequestInput(requesterAccountId: \(String(describing: requesterAccountId)), requesterAwsRegion: \(String(describing: requesterAwsRegion)))"}
}

extension DeletePendingAggregationRequestInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case requesterAccountId = "RequesterAccountId"
        case requesterAwsRegion = "RequesterAwsRegion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let requesterAccountId = requesterAccountId {
            try encodeContainer.encode(requesterAccountId, forKey: .requesterAccountId)
        }
        if let requesterAwsRegion = requesterAwsRegion {
            try encodeContainer.encode(requesterAwsRegion, forKey: .requesterAwsRegion)
        }
    }
}

public struct DeletePendingAggregationRequestInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePendingAggregationRequestInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePendingAggregationRequestInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePendingAggregationRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePendingAggregationRequestInput>
    public typealias MOutput = OperationOutput<DeletePendingAggregationRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePendingAggregationRequestOutputError>
}

public struct DeletePendingAggregationRequestInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePendingAggregationRequestInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePendingAggregationRequestInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePendingAggregationRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePendingAggregationRequestInput>
    public typealias MOutput = OperationOutput<DeletePendingAggregationRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePendingAggregationRequestOutputError>
}

public struct DeletePendingAggregationRequestInput: Equatable {
    /// <p>The 12-digit account ID of the account requesting to aggregate
    /// 			data.</p>
    public let requesterAccountId: String?
    /// <p>The region requesting to aggregate data.</p>
    public let requesterAwsRegion: String?

    public init (
        requesterAccountId: String? = nil,
        requesterAwsRegion: String? = nil
    )
    {
        self.requesterAccountId = requesterAccountId
        self.requesterAwsRegion = requesterAwsRegion
    }
}

struct DeletePendingAggregationRequestInputBody: Equatable {
    public let requesterAccountId: String?
    public let requesterAwsRegion: String?
}

extension DeletePendingAggregationRequestInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requesterAccountId = "RequesterAccountId"
        case requesterAwsRegion = "RequesterAwsRegion"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requesterAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requesterAccountId)
        requesterAccountId = requesterAccountIdDecoded
        let requesterAwsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requesterAwsRegion)
        requesterAwsRegion = requesterAwsRegionDecoded
    }
}

extension DeletePendingAggregationRequestOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePendingAggregationRequestOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePendingAggregationRequestOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePendingAggregationRequestOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePendingAggregationRequestOutputResponse()"}
}

extension DeletePendingAggregationRequestOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePendingAggregationRequestOutputResponse: Equatable {

    public init() {}
}

struct DeletePendingAggregationRequestOutputResponseBody: Equatable {
}

extension DeletePendingAggregationRequestOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteRemediationConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRemediationConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRemediationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRemediationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRemediationConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteRemediationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRemediationConfigurationOutputError>
}

extension DeleteRemediationConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRemediationConfigurationInput(configRuleName: \(String(describing: configRuleName)), resourceType: \(String(describing: resourceType)))"}
}

extension DeleteRemediationConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configRuleName = "ConfigRuleName"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleName = configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

public struct DeleteRemediationConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRemediationConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRemediationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRemediationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRemediationConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteRemediationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRemediationConfigurationOutputError>
}

public struct DeleteRemediationConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRemediationConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRemediationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRemediationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRemediationConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteRemediationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRemediationConfigurationOutputError>
}

public struct DeleteRemediationConfigurationInput: Equatable {
    /// <p>The name of the AWS Config rule for which you want to delete remediation configuration.</p>
    public let configRuleName: String?
    /// <p>The type of a resource.</p>
    public let resourceType: String?

    public init (
        configRuleName: String? = nil,
        resourceType: String? = nil
    )
    {
        self.configRuleName = configRuleName
        self.resourceType = resourceType
    }
}

struct DeleteRemediationConfigurationInputBody: Equatable {
    public let configRuleName: String?
    public let resourceType: String?
}

extension DeleteRemediationConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configRuleName = "ConfigRuleName"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension DeleteRemediationConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRemediationConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPermissionsException" : self = .insufficientPermissionsException(try InsufficientPermissionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRemediationConfigurationException" : self = .noSuchRemediationConfigurationException(try NoSuchRemediationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RemediationInProgressException" : self = .remediationInProgressException(try RemediationInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRemediationConfigurationOutputError: Equatable {
    case insufficientPermissionsException(InsufficientPermissionsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchRemediationConfigurationException(NoSuchRemediationConfigurationException)
    case remediationInProgressException(RemediationInProgressException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRemediationConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRemediationConfigurationOutputResponse()"}
}

extension DeleteRemediationConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRemediationConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeleteRemediationConfigurationOutputResponseBody: Equatable {
}

extension DeleteRemediationConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteRemediationExceptionsInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRemediationExceptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRemediationExceptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRemediationExceptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRemediationExceptionsInput>
    public typealias MOutput = OperationOutput<DeleteRemediationExceptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRemediationExceptionsOutputError>
}

extension DeleteRemediationExceptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRemediationExceptionsInput(configRuleName: \(String(describing: configRuleName)), resourceKeys: \(String(describing: resourceKeys)))"}
}

extension DeleteRemediationExceptionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configRuleName = "ConfigRuleName"
        case resourceKeys = "ResourceKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleName = configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let resourceKeys = resourceKeys {
            var resourceKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceKeys)
            for remediationexceptionresourcekeys0 in resourceKeys {
                try resourceKeysContainer.encode(remediationexceptionresourcekeys0)
            }
        }
    }
}

public struct DeleteRemediationExceptionsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRemediationExceptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRemediationExceptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRemediationExceptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRemediationExceptionsInput>
    public typealias MOutput = OperationOutput<DeleteRemediationExceptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRemediationExceptionsOutputError>
}

public struct DeleteRemediationExceptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRemediationExceptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRemediationExceptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRemediationExceptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRemediationExceptionsInput>
    public typealias MOutput = OperationOutput<DeleteRemediationExceptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRemediationExceptionsOutputError>
}

public struct DeleteRemediationExceptionsInput: Equatable {
    /// <p>The name of the AWS Config rule for which you want to delete remediation exception configuration.</p>
    public let configRuleName: String?
    /// <p>An exception list of resource exception keys to be processed with the current request. AWS Config adds exception for each resource key. For example, AWS Config adds 3 exceptions for 3 resource keys. </p>
    public let resourceKeys: [RemediationExceptionResourceKey]?

    public init (
        configRuleName: String? = nil,
        resourceKeys: [RemediationExceptionResourceKey]? = nil
    )
    {
        self.configRuleName = configRuleName
        self.resourceKeys = resourceKeys
    }
}

struct DeleteRemediationExceptionsInputBody: Equatable {
    public let configRuleName: String?
    public let resourceKeys: [RemediationExceptionResourceKey]?
}

extension DeleteRemediationExceptionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configRuleName = "ConfigRuleName"
        case resourceKeys = "ResourceKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let resourceKeysContainer = try containerValues.decodeIfPresent([RemediationExceptionResourceKey?].self, forKey: .resourceKeys)
        var resourceKeysDecoded0:[RemediationExceptionResourceKey]? = nil
        if let resourceKeysContainer = resourceKeysContainer {
            resourceKeysDecoded0 = [RemediationExceptionResourceKey]()
            for structure0 in resourceKeysContainer {
                if let structure0 = structure0 {
                    resourceKeysDecoded0?.append(structure0)
                }
            }
        }
        resourceKeys = resourceKeysDecoded0
    }
}

extension DeleteRemediationExceptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRemediationExceptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchRemediationExceptionException" : self = .noSuchRemediationExceptionException(try NoSuchRemediationExceptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRemediationExceptionsOutputError: Equatable {
    case noSuchRemediationExceptionException(NoSuchRemediationExceptionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRemediationExceptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRemediationExceptionsOutputResponse(failedBatches: \(String(describing: failedBatches)))"}
}

extension DeleteRemediationExceptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteRemediationExceptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedBatches = output.failedBatches
        } else {
            self.failedBatches = nil
        }
    }
}

public struct DeleteRemediationExceptionsOutputResponse: Equatable {
    /// <p>Returns a list of failed delete remediation exceptions batch objects. Each object in the batch consists of a list of failed items and failure messages.</p>
    public let failedBatches: [FailedDeleteRemediationExceptionsBatch]?

    public init (
        failedBatches: [FailedDeleteRemediationExceptionsBatch]? = nil
    )
    {
        self.failedBatches = failedBatches
    }
}

struct DeleteRemediationExceptionsOutputResponseBody: Equatable {
    public let failedBatches: [FailedDeleteRemediationExceptionsBatch]?
}

extension DeleteRemediationExceptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedBatches = "FailedBatches"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedBatchesContainer = try containerValues.decodeIfPresent([FailedDeleteRemediationExceptionsBatch?].self, forKey: .failedBatches)
        var failedBatchesDecoded0:[FailedDeleteRemediationExceptionsBatch]? = nil
        if let failedBatchesContainer = failedBatchesContainer {
            failedBatchesDecoded0 = [FailedDeleteRemediationExceptionsBatch]()
            for structure0 in failedBatchesContainer {
                if let structure0 = structure0 {
                    failedBatchesDecoded0?.append(structure0)
                }
            }
        }
        failedBatches = failedBatchesDecoded0
    }
}

public struct DeleteResourceConfigInputBodyMiddleware: Middleware {
    public let id: String = "DeleteResourceConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourceConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourceConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourceConfigInput>
    public typealias MOutput = OperationOutput<DeleteResourceConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourceConfigOutputError>
}

extension DeleteResourceConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourceConfigInput(resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension DeleteResourceConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

public struct DeleteResourceConfigInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteResourceConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourceConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourceConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourceConfigInput>
    public typealias MOutput = OperationOutput<DeleteResourceConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourceConfigOutputError>
}

public struct DeleteResourceConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteResourceConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourceConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourceConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourceConfigInput>
    public typealias MOutput = OperationOutput<DeleteResourceConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourceConfigOutputError>
}

public struct DeleteResourceConfigInput: Equatable {
    /// <p>Unique identifier of the resource.</p>
    public let resourceId: String?
    /// <p>The type of the resource.</p>
    public let resourceType: String?

    public init (
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct DeleteResourceConfigInputBody: Equatable {
    public let resourceType: String?
    public let resourceId: String?
}

extension DeleteResourceConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension DeleteResourceConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourceConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoRunningConfigurationRecorderException" : self = .noRunningConfigurationRecorderException(try NoRunningConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourceConfigOutputError: Equatable {
    case noRunningConfigurationRecorderException(NoRunningConfigurationRecorderException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourceConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourceConfigOutputResponse()"}
}

extension DeleteResourceConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourceConfigOutputResponse: Equatable {

    public init() {}
}

struct DeleteResourceConfigOutputResponseBody: Equatable {
}

extension DeleteResourceConfigOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteRetentionConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRetentionConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRetentionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRetentionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRetentionConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteRetentionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRetentionConfigurationOutputError>
}

extension DeleteRetentionConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRetentionConfigurationInput(retentionConfigurationName: \(String(describing: retentionConfigurationName)))"}
}

extension DeleteRetentionConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case retentionConfigurationName = "RetentionConfigurationName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retentionConfigurationName = retentionConfigurationName {
            try encodeContainer.encode(retentionConfigurationName, forKey: .retentionConfigurationName)
        }
    }
}

public struct DeleteRetentionConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRetentionConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRetentionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRetentionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRetentionConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteRetentionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRetentionConfigurationOutputError>
}

public struct DeleteRetentionConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRetentionConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRetentionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRetentionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRetentionConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteRetentionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRetentionConfigurationOutputError>
}

public struct DeleteRetentionConfigurationInput: Equatable {
    /// <p>The name of the retention configuration to delete.</p>
    public let retentionConfigurationName: String?

    public init (
        retentionConfigurationName: String? = nil
    )
    {
        self.retentionConfigurationName = retentionConfigurationName
    }
}

struct DeleteRetentionConfigurationInputBody: Equatable {
    public let retentionConfigurationName: String?
}

extension DeleteRetentionConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case retentionConfigurationName = "RetentionConfigurationName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionConfigurationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .retentionConfigurationName)
        retentionConfigurationName = retentionConfigurationNameDecoded
    }
}

extension DeleteRetentionConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRetentionConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRetentionConfigurationException" : self = .noSuchRetentionConfigurationException(try NoSuchRetentionConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRetentionConfigurationOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchRetentionConfigurationException(NoSuchRetentionConfigurationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRetentionConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRetentionConfigurationOutputResponse()"}
}

extension DeleteRetentionConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRetentionConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeleteRetentionConfigurationOutputResponseBody: Equatable {
}

extension DeleteRetentionConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteStoredQueryInputBodyMiddleware: Middleware {
    public let id: String = "DeleteStoredQueryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStoredQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStoredQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStoredQueryInput>
    public typealias MOutput = OperationOutput<DeleteStoredQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStoredQueryOutputError>
}

extension DeleteStoredQueryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStoredQueryInput(queryName: \(String(describing: queryName)))"}
}

extension DeleteStoredQueryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case queryName = "QueryName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryName = queryName {
            try encodeContainer.encode(queryName, forKey: .queryName)
        }
    }
}

public struct DeleteStoredQueryInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteStoredQueryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStoredQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStoredQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStoredQueryInput>
    public typealias MOutput = OperationOutput<DeleteStoredQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStoredQueryOutputError>
}

public struct DeleteStoredQueryInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteStoredQueryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStoredQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStoredQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStoredQueryInput>
    public typealias MOutput = OperationOutput<DeleteStoredQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStoredQueryOutputError>
}

public struct DeleteStoredQueryInput: Equatable {
    /// <p>The name of the query that you want to delete.</p>
    public let queryName: String?

    public init (
        queryName: String? = nil
    )
    {
        self.queryName = queryName
    }
}

struct DeleteStoredQueryInputBody: Equatable {
    public let queryName: String?
}

extension DeleteStoredQueryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case queryName = "QueryName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryName)
        queryName = queryNameDecoded
    }
}

extension DeleteStoredQueryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStoredQueryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStoredQueryOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStoredQueryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStoredQueryOutputResponse()"}
}

extension DeleteStoredQueryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStoredQueryOutputResponse: Equatable {

    public init() {}
}

struct DeleteStoredQueryOutputResponseBody: Equatable {
}

extension DeleteStoredQueryOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeliverConfigSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "DeliverConfigSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeliverConfigSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeliverConfigSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeliverConfigSnapshotInput>
    public typealias MOutput = OperationOutput<DeliverConfigSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeliverConfigSnapshotOutputError>
}

extension DeliverConfigSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeliverConfigSnapshotInput(deliveryChannelName: \(String(describing: deliveryChannelName)))"}
}

extension DeliverConfigSnapshotInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deliveryChannelName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryChannelName = deliveryChannelName {
            try encodeContainer.encode(deliveryChannelName, forKey: .deliveryChannelName)
        }
    }
}

public struct DeliverConfigSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "DeliverConfigSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeliverConfigSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeliverConfigSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeliverConfigSnapshotInput>
    public typealias MOutput = OperationOutput<DeliverConfigSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeliverConfigSnapshotOutputError>
}

public struct DeliverConfigSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "DeliverConfigSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeliverConfigSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<DeliverConfigSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeliverConfigSnapshotInput>
    public typealias MOutput = OperationOutput<DeliverConfigSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeliverConfigSnapshotOutputError>
}

/// <p>The input for the <a>DeliverConfigSnapshot</a>
/// 			action.</p>
public struct DeliverConfigSnapshotInput: Equatable {
    /// <p>The name of the delivery channel through which the snapshot is
    /// 			delivered.</p>
    public let deliveryChannelName: String?

    public init (
        deliveryChannelName: String? = nil
    )
    {
        self.deliveryChannelName = deliveryChannelName
    }
}

struct DeliverConfigSnapshotInputBody: Equatable {
    public let deliveryChannelName: String?
}

extension DeliverConfigSnapshotInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deliveryChannelName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryChannelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deliveryChannelName)
        deliveryChannelName = deliveryChannelNameDecoded
    }
}

extension DeliverConfigSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeliverConfigSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoAvailableConfigurationRecorderException" : self = .noAvailableConfigurationRecorderException(try NoAvailableConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoRunningConfigurationRecorderException" : self = .noRunningConfigurationRecorderException(try NoRunningConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDeliveryChannelException" : self = .noSuchDeliveryChannelException(try NoSuchDeliveryChannelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeliverConfigSnapshotOutputError: Equatable {
    case noAvailableConfigurationRecorderException(NoAvailableConfigurationRecorderException)
    case noRunningConfigurationRecorderException(NoRunningConfigurationRecorderException)
    case noSuchDeliveryChannelException(NoSuchDeliveryChannelException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeliverConfigSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeliverConfigSnapshotOutputResponse(configSnapshotId: \(String(describing: configSnapshotId)))"}
}

extension DeliverConfigSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeliverConfigSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configSnapshotId = output.configSnapshotId
        } else {
            self.configSnapshotId = nil
        }
    }
}

/// <p>The output for the <a>DeliverConfigSnapshot</a>
/// 			action, in JSON format.</p>
public struct DeliverConfigSnapshotOutputResponse: Equatable {
    /// <p>The ID of the snapshot that is being created.</p>
    public let configSnapshotId: String?

    public init (
        configSnapshotId: String? = nil
    )
    {
        self.configSnapshotId = configSnapshotId
    }
}

struct DeliverConfigSnapshotOutputResponseBody: Equatable {
    public let configSnapshotId: String?
}

extension DeliverConfigSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configSnapshotId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configSnapshotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configSnapshotId)
        configSnapshotId = configSnapshotIdDecoded
    }
}

extension DeliveryChannel: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configSnapshotDeliveryProperties
        case name
        case s3BucketName
        case s3KeyPrefix
        case s3KmsKeyArn
        case snsTopicARN
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configSnapshotDeliveryProperties = configSnapshotDeliveryProperties {
            try encodeContainer.encode(configSnapshotDeliveryProperties, forKey: .configSnapshotDeliveryProperties)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let s3KmsKeyArn = s3KmsKeyArn {
            try encodeContainer.encode(s3KmsKeyArn, forKey: .s3KmsKeyArn)
        }
        if let snsTopicARN = snsTopicARN {
            try encodeContainer.encode(snsTopicARN, forKey: .snsTopicARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let s3KmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3KmsKeyArn)
        s3KmsKeyArn = s3KmsKeyArnDecoded
        let snsTopicARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicARN)
        snsTopicARN = snsTopicARNDecoded
        let configSnapshotDeliveryPropertiesDecoded = try containerValues.decodeIfPresent(ConfigSnapshotDeliveryProperties.self, forKey: .configSnapshotDeliveryProperties)
        configSnapshotDeliveryProperties = configSnapshotDeliveryPropertiesDecoded
    }
}

extension DeliveryChannel: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeliveryChannel(configSnapshotDeliveryProperties: \(String(describing: configSnapshotDeliveryProperties)), name: \(String(describing: name)), s3BucketName: \(String(describing: s3BucketName)), s3KeyPrefix: \(String(describing: s3KeyPrefix)), s3KmsKeyArn: \(String(describing: s3KmsKeyArn)), snsTopicARN: \(String(describing: snsTopicARN)))"}
}

/// <p>The channel through which AWS Config delivers notifications and
/// 			updated configuration states.</p>
public struct DeliveryChannel: Equatable {
    /// <p>The options for how often AWS Config delivers configuration
    /// 			snapshots to the Amazon S3 bucket.</p>
    public let configSnapshotDeliveryProperties: ConfigSnapshotDeliveryProperties?
    /// <p>The name of the delivery channel. By default, AWS Config
    /// 			assigns the name "default" when creating the delivery channel. To
    /// 			change the delivery channel name, you must use the
    /// 			DeleteDeliveryChannel action to delete your current delivery
    /// 			channel, and then you must use the PutDeliveryChannel command to
    /// 			create a delivery channel that has the desired name.</p>
    public let name: String?
    /// <p>The name of the Amazon S3 bucket to which AWS Config delivers
    /// 			configuration snapshots and configuration history files.</p>
    /// 		       <p>If you specify a bucket that belongs to another AWS account,
    /// 			that bucket must have policies that grant access permissions to AWS
    /// 			Config. For more information, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/s3-bucket-policy.html">Permissions for the Amazon S3 Bucket</a> in the AWS Config
    /// 			Developer Guide.</p>
    public let s3BucketName: String?
    /// <p>The prefix for the specified Amazon S3 bucket.</p>
    public let s3KeyPrefix: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Key Management Service (KMS) customer managed key (CMK) used to encrypt objects delivered by AWS Config.
    /// 			Must belong to the same Region as the destination S3 bucket.</p>
    public let s3KmsKeyArn: String?
    /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic to which
    /// 			AWS Config sends notifications about configuration
    /// 			changes.</p>
    /// 		       <p>If you choose a topic from another account, the topic must have
    /// 			policies that grant access permissions to AWS Config. For more
    /// 			information, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/sns-topic-policy.html">Permissions for the Amazon SNS Topic</a> in the AWS Config
    /// 			Developer Guide.</p>
    public let snsTopicARN: String?

    public init (
        configSnapshotDeliveryProperties: ConfigSnapshotDeliveryProperties? = nil,
        name: String? = nil,
        s3BucketName: String? = nil,
        s3KeyPrefix: String? = nil,
        s3KmsKeyArn: String? = nil,
        snsTopicARN: String? = nil
    )
    {
        self.configSnapshotDeliveryProperties = configSnapshotDeliveryProperties
        self.name = name
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.s3KmsKeyArn = s3KmsKeyArn
        self.snsTopicARN = snsTopicARN
    }
}

extension DeliveryChannelStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configHistoryDeliveryInfo
        case configSnapshotDeliveryInfo
        case configStreamDeliveryInfo
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configHistoryDeliveryInfo = configHistoryDeliveryInfo {
            try encodeContainer.encode(configHistoryDeliveryInfo, forKey: .configHistoryDeliveryInfo)
        }
        if let configSnapshotDeliveryInfo = configSnapshotDeliveryInfo {
            try encodeContainer.encode(configSnapshotDeliveryInfo, forKey: .configSnapshotDeliveryInfo)
        }
        if let configStreamDeliveryInfo = configStreamDeliveryInfo {
            try encodeContainer.encode(configStreamDeliveryInfo, forKey: .configStreamDeliveryInfo)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let configSnapshotDeliveryInfoDecoded = try containerValues.decodeIfPresent(ConfigExportDeliveryInfo.self, forKey: .configSnapshotDeliveryInfo)
        configSnapshotDeliveryInfo = configSnapshotDeliveryInfoDecoded
        let configHistoryDeliveryInfoDecoded = try containerValues.decodeIfPresent(ConfigExportDeliveryInfo.self, forKey: .configHistoryDeliveryInfo)
        configHistoryDeliveryInfo = configHistoryDeliveryInfoDecoded
        let configStreamDeliveryInfoDecoded = try containerValues.decodeIfPresent(ConfigStreamDeliveryInfo.self, forKey: .configStreamDeliveryInfo)
        configStreamDeliveryInfo = configStreamDeliveryInfoDecoded
    }
}

extension DeliveryChannelStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeliveryChannelStatus(configHistoryDeliveryInfo: \(String(describing: configHistoryDeliveryInfo)), configSnapshotDeliveryInfo: \(String(describing: configSnapshotDeliveryInfo)), configStreamDeliveryInfo: \(String(describing: configStreamDeliveryInfo)), name: \(String(describing: name)))"}
}

/// <p>The status of a specified delivery channel.</p>
/// 		       <p>Valid values: <code>Success</code> | <code>Failure</code>
/// 		       </p>
public struct DeliveryChannelStatus: Equatable {
    /// <p>A list that contains the status of the delivery of the
    /// 			configuration history to the specified Amazon S3 bucket.</p>
    public let configHistoryDeliveryInfo: ConfigExportDeliveryInfo?
    /// <p>A list containing the status of the delivery of the snapshot to
    /// 			the specified Amazon S3 bucket.</p>
    public let configSnapshotDeliveryInfo: ConfigExportDeliveryInfo?
    /// <p>A list containing the status of the delivery of the
    /// 			configuration stream notification to the specified Amazon SNS
    /// 			topic.</p>
    public let configStreamDeliveryInfo: ConfigStreamDeliveryInfo?
    /// <p>The name of the delivery channel.</p>
    public let name: String?

    public init (
        configHistoryDeliveryInfo: ConfigExportDeliveryInfo? = nil,
        configSnapshotDeliveryInfo: ConfigExportDeliveryInfo? = nil,
        configStreamDeliveryInfo: ConfigStreamDeliveryInfo? = nil,
        name: String? = nil
    )
    {
        self.configHistoryDeliveryInfo = configHistoryDeliveryInfo
        self.configSnapshotDeliveryInfo = configSnapshotDeliveryInfo
        self.configStreamDeliveryInfo = configStreamDeliveryInfo
        self.name = name
    }
}

public enum DeliveryStatus {
    case failure
    case notApplicable
    case success
    case sdkUnknown(String)
}

extension DeliveryStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeliveryStatus] {
        return [
            .failure,
            .notApplicable,
            .success,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failure: return "Failure"
        case .notApplicable: return "Not_Applicable"
        case .success: return "Success"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeliveryStatus(rawValue: rawValue) ?? DeliveryStatus.sdkUnknown(rawValue)
    }
}

public struct DescribeAggregateComplianceByConfigRulesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAggregateComplianceByConfigRulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAggregateComplianceByConfigRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAggregateComplianceByConfigRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAggregateComplianceByConfigRulesInput>
    public typealias MOutput = OperationOutput<DescribeAggregateComplianceByConfigRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAggregateComplianceByConfigRulesOutputError>
}

extension DescribeAggregateComplianceByConfigRulesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAggregateComplianceByConfigRulesInput(configurationAggregatorName: \(String(describing: configurationAggregatorName)), filters: \(String(describing: filters)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAggregateComplianceByConfigRulesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationAggregatorName = configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeAggregateComplianceByConfigRulesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAggregateComplianceByConfigRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAggregateComplianceByConfigRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAggregateComplianceByConfigRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAggregateComplianceByConfigRulesInput>
    public typealias MOutput = OperationOutput<DescribeAggregateComplianceByConfigRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAggregateComplianceByConfigRulesOutputError>
}

public struct DescribeAggregateComplianceByConfigRulesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAggregateComplianceByConfigRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAggregateComplianceByConfigRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAggregateComplianceByConfigRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAggregateComplianceByConfigRulesInput>
    public typealias MOutput = OperationOutput<DescribeAggregateComplianceByConfigRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAggregateComplianceByConfigRulesOutputError>
}

public struct DescribeAggregateComplianceByConfigRulesInput: Equatable {
    /// <p>The name of the configuration aggregator.</p>
    public let configurationAggregatorName: String?
    /// <p>Filters the results by ConfigRuleComplianceFilters object.
    /// 		</p>
    public let filters: ConfigRuleComplianceFilters?
    /// <p>The maximum number of evaluation results returned on each page.
    /// 			The default is
    /// 			maximum.
    /// 			If you specify 0, AWS Config uses the default.</p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned on a previous page that you use
    /// 			to get the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        configurationAggregatorName: String? = nil,
        filters: ConfigRuleComplianceFilters? = nil,
        limit: Int = 0,
        nextToken: String? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribeAggregateComplianceByConfigRulesInputBody: Equatable {
    public let configurationAggregatorName: String?
    public let filters: ConfigRuleComplianceFilters?
    public let limit: Int
    public let nextToken: String?
}

extension DescribeAggregateComplianceByConfigRulesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(ConfigRuleComplianceFilters.self, forKey: .filters)
        filters = filtersDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAggregateComplianceByConfigRulesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAggregateComplianceByConfigRulesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAggregateComplianceByConfigRulesOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAggregateComplianceByConfigRulesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAggregateComplianceByConfigRulesOutputResponse(aggregateComplianceByConfigRules: \(String(describing: aggregateComplianceByConfigRules)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAggregateComplianceByConfigRulesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAggregateComplianceByConfigRulesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.aggregateComplianceByConfigRules = output.aggregateComplianceByConfigRules
            self.nextToken = output.nextToken
        } else {
            self.aggregateComplianceByConfigRules = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAggregateComplianceByConfigRulesOutputResponse: Equatable {
    /// <p>Returns a list of AggregateComplianceByConfigRule
    /// 			object.</p>
    public let aggregateComplianceByConfigRules: [AggregateComplianceByConfigRule]?
    /// <p>The <code>nextToken</code> string returned on a previous page that you use
    /// 			to get the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        aggregateComplianceByConfigRules: [AggregateComplianceByConfigRule]? = nil,
        nextToken: String? = nil
    )
    {
        self.aggregateComplianceByConfigRules = aggregateComplianceByConfigRules
        self.nextToken = nextToken
    }
}

struct DescribeAggregateComplianceByConfigRulesOutputResponseBody: Equatable {
    public let aggregateComplianceByConfigRules: [AggregateComplianceByConfigRule]?
    public let nextToken: String?
}

extension DescribeAggregateComplianceByConfigRulesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aggregateComplianceByConfigRules = "AggregateComplianceByConfigRules"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregateComplianceByConfigRulesContainer = try containerValues.decodeIfPresent([AggregateComplianceByConfigRule?].self, forKey: .aggregateComplianceByConfigRules)
        var aggregateComplianceByConfigRulesDecoded0:[AggregateComplianceByConfigRule]? = nil
        if let aggregateComplianceByConfigRulesContainer = aggregateComplianceByConfigRulesContainer {
            aggregateComplianceByConfigRulesDecoded0 = [AggregateComplianceByConfigRule]()
            for structure0 in aggregateComplianceByConfigRulesContainer {
                if let structure0 = structure0 {
                    aggregateComplianceByConfigRulesDecoded0?.append(structure0)
                }
            }
        }
        aggregateComplianceByConfigRules = aggregateComplianceByConfigRulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeAggregateComplianceByConformancePacksInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAggregateComplianceByConformancePacksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAggregateComplianceByConformancePacksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAggregateComplianceByConformancePacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAggregateComplianceByConformancePacksInput>
    public typealias MOutput = OperationOutput<DescribeAggregateComplianceByConformancePacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAggregateComplianceByConformancePacksOutputError>
}

extension DescribeAggregateComplianceByConformancePacksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAggregateComplianceByConformancePacksInput(configurationAggregatorName: \(String(describing: configurationAggregatorName)), filters: \(String(describing: filters)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAggregateComplianceByConformancePacksInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationAggregatorName = configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeAggregateComplianceByConformancePacksInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAggregateComplianceByConformancePacksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAggregateComplianceByConformancePacksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAggregateComplianceByConformancePacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAggregateComplianceByConformancePacksInput>
    public typealias MOutput = OperationOutput<DescribeAggregateComplianceByConformancePacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAggregateComplianceByConformancePacksOutputError>
}

public struct DescribeAggregateComplianceByConformancePacksInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAggregateComplianceByConformancePacksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAggregateComplianceByConformancePacksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAggregateComplianceByConformancePacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAggregateComplianceByConformancePacksInput>
    public typealias MOutput = OperationOutput<DescribeAggregateComplianceByConformancePacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAggregateComplianceByConformancePacksOutputError>
}

public struct DescribeAggregateComplianceByConformancePacksInput: Equatable {
    /// <p>The name of the configuration aggregator.</p>
    public let configurationAggregatorName: String?
    /// <p>Filters the result by <code>AggregateConformancePackComplianceFilters</code> object.</p>
    public let filters: AggregateConformancePackComplianceFilters?
    /// <p>The maximum number of conformance packs compliance details returned on each page. The default is maximum. If you specify 0, AWS Config uses the default. </p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned on a previous page that you use to get the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        configurationAggregatorName: String? = nil,
        filters: AggregateConformancePackComplianceFilters? = nil,
        limit: Int = 0,
        nextToken: String? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribeAggregateComplianceByConformancePacksInputBody: Equatable {
    public let configurationAggregatorName: String?
    public let filters: AggregateConformancePackComplianceFilters?
    public let limit: Int
    public let nextToken: String?
}

extension DescribeAggregateComplianceByConformancePacksInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(AggregateConformancePackComplianceFilters.self, forKey: .filters)
        filters = filtersDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAggregateComplianceByConformancePacksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAggregateComplianceByConformancePacksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAggregateComplianceByConformancePacksOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAggregateComplianceByConformancePacksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAggregateComplianceByConformancePacksOutputResponse(aggregateComplianceByConformancePacks: \(String(describing: aggregateComplianceByConformancePacks)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAggregateComplianceByConformancePacksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAggregateComplianceByConformancePacksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.aggregateComplianceByConformancePacks = output.aggregateComplianceByConformancePacks
            self.nextToken = output.nextToken
        } else {
            self.aggregateComplianceByConformancePacks = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAggregateComplianceByConformancePacksOutputResponse: Equatable {
    /// <p>Returns the <code>AggregateComplianceByConformancePack</code> object.</p>
    public let aggregateComplianceByConformancePacks: [AggregateComplianceByConformancePack]?
    /// <p>The <code>nextToken</code> string returned on a previous page that you use to get the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        aggregateComplianceByConformancePacks: [AggregateComplianceByConformancePack]? = nil,
        nextToken: String? = nil
    )
    {
        self.aggregateComplianceByConformancePacks = aggregateComplianceByConformancePacks
        self.nextToken = nextToken
    }
}

struct DescribeAggregateComplianceByConformancePacksOutputResponseBody: Equatable {
    public let aggregateComplianceByConformancePacks: [AggregateComplianceByConformancePack]?
    public let nextToken: String?
}

extension DescribeAggregateComplianceByConformancePacksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aggregateComplianceByConformancePacks = "AggregateComplianceByConformancePacks"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregateComplianceByConformancePacksContainer = try containerValues.decodeIfPresent([AggregateComplianceByConformancePack?].self, forKey: .aggregateComplianceByConformancePacks)
        var aggregateComplianceByConformancePacksDecoded0:[AggregateComplianceByConformancePack]? = nil
        if let aggregateComplianceByConformancePacksContainer = aggregateComplianceByConformancePacksContainer {
            aggregateComplianceByConformancePacksDecoded0 = [AggregateComplianceByConformancePack]()
            for structure0 in aggregateComplianceByConformancePacksContainer {
                if let structure0 = structure0 {
                    aggregateComplianceByConformancePacksDecoded0?.append(structure0)
                }
            }
        }
        aggregateComplianceByConformancePacks = aggregateComplianceByConformancePacksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeAggregationAuthorizationsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAggregationAuthorizationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAggregationAuthorizationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAggregationAuthorizationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAggregationAuthorizationsInput>
    public typealias MOutput = OperationOutput<DescribeAggregationAuthorizationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAggregationAuthorizationsOutputError>
}

extension DescribeAggregationAuthorizationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAggregationAuthorizationsInput(limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAggregationAuthorizationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeAggregationAuthorizationsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAggregationAuthorizationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAggregationAuthorizationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAggregationAuthorizationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAggregationAuthorizationsInput>
    public typealias MOutput = OperationOutput<DescribeAggregationAuthorizationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAggregationAuthorizationsOutputError>
}

public struct DescribeAggregationAuthorizationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAggregationAuthorizationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAggregationAuthorizationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAggregationAuthorizationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAggregationAuthorizationsInput>
    public typealias MOutput = OperationOutput<DescribeAggregationAuthorizationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAggregationAuthorizationsOutputError>
}

public struct DescribeAggregationAuthorizationsInput: Equatable {
    /// <p>The maximum number of AggregationAuthorizations returned on
    /// 			each page. The default is maximum. If you specify 0, AWS Config uses
    /// 			the default.</p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned on a previous page that you use
    /// 			to get the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        limit: Int = 0,
        nextToken: String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribeAggregationAuthorizationsInputBody: Equatable {
    public let limit: Int
    public let nextToken: String?
}

extension DescribeAggregationAuthorizationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAggregationAuthorizationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAggregationAuthorizationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAggregationAuthorizationsOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAggregationAuthorizationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAggregationAuthorizationsOutputResponse(aggregationAuthorizations: \(String(describing: aggregationAuthorizations)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAggregationAuthorizationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAggregationAuthorizationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.aggregationAuthorizations = output.aggregationAuthorizations
            self.nextToken = output.nextToken
        } else {
            self.aggregationAuthorizations = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAggregationAuthorizationsOutputResponse: Equatable {
    /// <p>Returns a list of authorizations granted to various aggregator
    /// 			accounts and regions.</p>
    public let aggregationAuthorizations: [AggregationAuthorization]?
    /// <p>The <code>nextToken</code> string returned on a previous page that you use
    /// 			to get the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        aggregationAuthorizations: [AggregationAuthorization]? = nil,
        nextToken: String? = nil
    )
    {
        self.aggregationAuthorizations = aggregationAuthorizations
        self.nextToken = nextToken
    }
}

struct DescribeAggregationAuthorizationsOutputResponseBody: Equatable {
    public let aggregationAuthorizations: [AggregationAuthorization]?
    public let nextToken: String?
}

extension DescribeAggregationAuthorizationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aggregationAuthorizations = "AggregationAuthorizations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregationAuthorizationsContainer = try containerValues.decodeIfPresent([AggregationAuthorization?].self, forKey: .aggregationAuthorizations)
        var aggregationAuthorizationsDecoded0:[AggregationAuthorization]? = nil
        if let aggregationAuthorizationsContainer = aggregationAuthorizationsContainer {
            aggregationAuthorizationsDecoded0 = [AggregationAuthorization]()
            for structure0 in aggregationAuthorizationsContainer {
                if let structure0 = structure0 {
                    aggregationAuthorizationsDecoded0?.append(structure0)
                }
            }
        }
        aggregationAuthorizations = aggregationAuthorizationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeComplianceByConfigRuleInputBodyMiddleware: Middleware {
    public let id: String = "DescribeComplianceByConfigRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeComplianceByConfigRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeComplianceByConfigRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeComplianceByConfigRuleInput>
    public typealias MOutput = OperationOutput<DescribeComplianceByConfigRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeComplianceByConfigRuleOutputError>
}

extension DescribeComplianceByConfigRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeComplianceByConfigRuleInput(complianceTypes: \(String(describing: complianceTypes)), configRuleNames: \(String(describing: configRuleNames)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeComplianceByConfigRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceTypes = "ComplianceTypes"
        case configRuleNames = "ConfigRuleNames"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceTypes = complianceTypes {
            var complianceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .complianceTypes)
            for compliancetypes0 in complianceTypes {
                try complianceTypesContainer.encode(compliancetypes0.rawValue)
            }
        }
        if let configRuleNames = configRuleNames {
            var configRuleNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configRuleNames)
            for configrulenames0 in configRuleNames {
                try configRuleNamesContainer.encode(configrulenames0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeComplianceByConfigRuleInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeComplianceByConfigRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeComplianceByConfigRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeComplianceByConfigRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeComplianceByConfigRuleInput>
    public typealias MOutput = OperationOutput<DescribeComplianceByConfigRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeComplianceByConfigRuleOutputError>
}

public struct DescribeComplianceByConfigRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeComplianceByConfigRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeComplianceByConfigRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeComplianceByConfigRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeComplianceByConfigRuleInput>
    public typealias MOutput = OperationOutput<DescribeComplianceByConfigRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeComplianceByConfigRuleOutputError>
}

/// <p></p>
public struct DescribeComplianceByConfigRuleInput: Equatable {
    /// <p>Filters the results by compliance.</p>
    /// 		       <p>The allowed values are <code>COMPLIANT</code> and <code>NON_COMPLIANT</code>.</p>
    public let complianceTypes: [ComplianceType]?
    /// <p>Specify one or more AWS Config rule names to filter the results
    /// 			by rule.</p>
    public let configRuleNames: [String]?
    /// <p>The <code>nextToken</code> string returned on a previous page
    /// 			that you use to get the next page of results in a paginated
    /// 			response.</p>
    public let nextToken: String?

    public init (
        complianceTypes: [ComplianceType]? = nil,
        configRuleNames: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.complianceTypes = complianceTypes
        self.configRuleNames = configRuleNames
        self.nextToken = nextToken
    }
}

struct DescribeComplianceByConfigRuleInputBody: Equatable {
    public let configRuleNames: [String]?
    public let complianceTypes: [ComplianceType]?
    public let nextToken: String?
}

extension DescribeComplianceByConfigRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case complianceTypes = "ComplianceTypes"
        case configRuleNames = "ConfigRuleNames"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .configRuleNames)
        var configRuleNamesDecoded0:[String]? = nil
        if let configRuleNamesContainer = configRuleNamesContainer {
            configRuleNamesDecoded0 = [String]()
            for string0 in configRuleNamesContainer {
                if let string0 = string0 {
                    configRuleNamesDecoded0?.append(string0)
                }
            }
        }
        configRuleNames = configRuleNamesDecoded0
        let complianceTypesContainer = try containerValues.decodeIfPresent([ComplianceType?].self, forKey: .complianceTypes)
        var complianceTypesDecoded0:[ComplianceType]? = nil
        if let complianceTypesContainer = complianceTypesContainer {
            complianceTypesDecoded0 = [ComplianceType]()
            for string0 in complianceTypesContainer {
                if let string0 = string0 {
                    complianceTypesDecoded0?.append(string0)
                }
            }
        }
        complianceTypes = complianceTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeComplianceByConfigRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeComplianceByConfigRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigRuleException" : self = .noSuchConfigRuleException(try NoSuchConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeComplianceByConfigRuleOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchConfigRuleException(NoSuchConfigRuleException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeComplianceByConfigRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeComplianceByConfigRuleOutputResponse(complianceByConfigRules: \(String(describing: complianceByConfigRules)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeComplianceByConfigRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeComplianceByConfigRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.complianceByConfigRules = output.complianceByConfigRules
            self.nextToken = output.nextToken
        } else {
            self.complianceByConfigRules = nil
            self.nextToken = nil
        }
    }
}

/// <p></p>
public struct DescribeComplianceByConfigRuleOutputResponse: Equatable {
    /// <p>Indicates whether each of the specified AWS Config rules is
    /// 			compliant.</p>
    public let complianceByConfigRules: [ComplianceByConfigRule]?
    /// <p>The string that you use in a subsequent request to get the next
    /// 			page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        complianceByConfigRules: [ComplianceByConfigRule]? = nil,
        nextToken: String? = nil
    )
    {
        self.complianceByConfigRules = complianceByConfigRules
        self.nextToken = nextToken
    }
}

struct DescribeComplianceByConfigRuleOutputResponseBody: Equatable {
    public let complianceByConfigRules: [ComplianceByConfigRule]?
    public let nextToken: String?
}

extension DescribeComplianceByConfigRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case complianceByConfigRules = "ComplianceByConfigRules"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceByConfigRulesContainer = try containerValues.decodeIfPresent([ComplianceByConfigRule?].self, forKey: .complianceByConfigRules)
        var complianceByConfigRulesDecoded0:[ComplianceByConfigRule]? = nil
        if let complianceByConfigRulesContainer = complianceByConfigRulesContainer {
            complianceByConfigRulesDecoded0 = [ComplianceByConfigRule]()
            for structure0 in complianceByConfigRulesContainer {
                if let structure0 = structure0 {
                    complianceByConfigRulesDecoded0?.append(structure0)
                }
            }
        }
        complianceByConfigRules = complianceByConfigRulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeComplianceByResourceInputBodyMiddleware: Middleware {
    public let id: String = "DescribeComplianceByResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeComplianceByResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeComplianceByResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeComplianceByResourceInput>
    public typealias MOutput = OperationOutput<DescribeComplianceByResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeComplianceByResourceOutputError>
}

extension DescribeComplianceByResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeComplianceByResourceInput(complianceTypes: \(String(describing: complianceTypes)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension DescribeComplianceByResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceTypes = "ComplianceTypes"
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceTypes = complianceTypes {
            var complianceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .complianceTypes)
            for compliancetypes0 in complianceTypes {
                try complianceTypesContainer.encode(compliancetypes0.rawValue)
            }
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

public struct DescribeComplianceByResourceInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeComplianceByResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeComplianceByResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeComplianceByResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeComplianceByResourceInput>
    public typealias MOutput = OperationOutput<DescribeComplianceByResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeComplianceByResourceOutputError>
}

public struct DescribeComplianceByResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeComplianceByResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeComplianceByResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeComplianceByResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeComplianceByResourceInput>
    public typealias MOutput = OperationOutput<DescribeComplianceByResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeComplianceByResourceOutputError>
}

/// <p></p>
public struct DescribeComplianceByResourceInput: Equatable {
    /// <p>Filters the results by compliance.</p>
    /// 		       <p>The allowed values are <code>COMPLIANT</code>, <code>NON_COMPLIANT</code>, and <code>INSUFFICIENT_DATA</code>.</p>
    public let complianceTypes: [ComplianceType]?
    /// <p>The maximum number of evaluation results returned on each page.
    /// 			The default is 10. You cannot specify a number greater than 100. If
    /// 			you specify 0, AWS Config uses the default.</p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned on a previous page
    /// 			that you use to get the next page of results in a paginated
    /// 			response.</p>
    public let nextToken: String?
    /// <p>The ID of the AWS resource for which you want compliance
    /// 			information. You can specify only one resource ID. If you specify a
    /// 			resource ID, you must also specify a type for
    /// 				<code>ResourceType</code>.</p>
    public let resourceId: String?
    /// <p>The types of AWS resources for which you want compliance
    /// 			information (for example, <code>AWS::EC2::Instance</code>). For this
    /// 			action, you can specify that the resource type is an AWS account by
    /// 			specifying <code>AWS::::Account</code>.</p>
    public let resourceType: String?

    public init (
        complianceTypes: [ComplianceType]? = nil,
        limit: Int = 0,
        nextToken: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.complianceTypes = complianceTypes
        self.limit = limit
        self.nextToken = nextToken
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct DescribeComplianceByResourceInputBody: Equatable {
    public let resourceType: String?
    public let resourceId: String?
    public let complianceTypes: [ComplianceType]?
    public let limit: Int
    public let nextToken: String?
}

extension DescribeComplianceByResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case complianceTypes = "ComplianceTypes"
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let complianceTypesContainer = try containerValues.decodeIfPresent([ComplianceType?].self, forKey: .complianceTypes)
        var complianceTypesDecoded0:[ComplianceType]? = nil
        if let complianceTypesContainer = complianceTypesContainer {
            complianceTypesDecoded0 = [ComplianceType]()
            for string0 in complianceTypesContainer {
                if let string0 = string0 {
                    complianceTypesDecoded0?.append(string0)
                }
            }
        }
        complianceTypes = complianceTypesDecoded0
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeComplianceByResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeComplianceByResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeComplianceByResourceOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeComplianceByResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeComplianceByResourceOutputResponse(complianceByResources: \(String(describing: complianceByResources)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeComplianceByResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeComplianceByResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.complianceByResources = output.complianceByResources
            self.nextToken = output.nextToken
        } else {
            self.complianceByResources = nil
            self.nextToken = nil
        }
    }
}

/// <p></p>
public struct DescribeComplianceByResourceOutputResponse: Equatable {
    /// <p>Indicates whether the specified AWS resource complies with all
    /// 			of the AWS Config rules that evaluate it.</p>
    public let complianceByResources: [ComplianceByResource]?
    /// <p>The string that you use in a subsequent request to get the next
    /// 			page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        complianceByResources: [ComplianceByResource]? = nil,
        nextToken: String? = nil
    )
    {
        self.complianceByResources = complianceByResources
        self.nextToken = nextToken
    }
}

struct DescribeComplianceByResourceOutputResponseBody: Equatable {
    public let complianceByResources: [ComplianceByResource]?
    public let nextToken: String?
}

extension DescribeComplianceByResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case complianceByResources = "ComplianceByResources"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceByResourcesContainer = try containerValues.decodeIfPresent([ComplianceByResource?].self, forKey: .complianceByResources)
        var complianceByResourcesDecoded0:[ComplianceByResource]? = nil
        if let complianceByResourcesContainer = complianceByResourcesContainer {
            complianceByResourcesDecoded0 = [ComplianceByResource]()
            for structure0 in complianceByResourcesContainer {
                if let structure0 = structure0 {
                    complianceByResourcesDecoded0?.append(structure0)
                }
            }
        }
        complianceByResources = complianceByResourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeConfigRuleEvaluationStatusInputBodyMiddleware: Middleware {
    public let id: String = "DescribeConfigRuleEvaluationStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigRuleEvaluationStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigRuleEvaluationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigRuleEvaluationStatusInput>
    public typealias MOutput = OperationOutput<DescribeConfigRuleEvaluationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigRuleEvaluationStatusOutputError>
}

extension DescribeConfigRuleEvaluationStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigRuleEvaluationStatusInput(configRuleNames: \(String(describing: configRuleNames)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeConfigRuleEvaluationStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configRuleNames = "ConfigRuleNames"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleNames = configRuleNames {
            var configRuleNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configRuleNames)
            for configrulenames0 in configRuleNames {
                try configRuleNamesContainer.encode(configrulenames0)
            }
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeConfigRuleEvaluationStatusInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConfigRuleEvaluationStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigRuleEvaluationStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigRuleEvaluationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigRuleEvaluationStatusInput>
    public typealias MOutput = OperationOutput<DescribeConfigRuleEvaluationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigRuleEvaluationStatusOutputError>
}

public struct DescribeConfigRuleEvaluationStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConfigRuleEvaluationStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigRuleEvaluationStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigRuleEvaluationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigRuleEvaluationStatusInput>
    public typealias MOutput = OperationOutput<DescribeConfigRuleEvaluationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigRuleEvaluationStatusOutputError>
}

/// <p></p>
public struct DescribeConfigRuleEvaluationStatusInput: Equatable {
    /// <p>The name of the AWS managed Config rules for which you want
    /// 			status information. If you do not specify any names, AWS Config
    /// 			returns status information for all AWS managed Config rules that you
    /// 			use.</p>
    public let configRuleNames: [String]?
    /// <p>The number of rule evaluation results that you want
    /// 			returned.</p>
    /// 		
    /// 		       <p>This parameter is required if the rule limit for your account
    /// 			is more than the default of 150 rules.</p>
    /// 		       <p>For information about requesting a rule limit increase, see
    /// 				<a href="http://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_config">AWS Config Limits</a> in the <i>AWS General
    /// 				Reference Guide</i>.</p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned on a previous page
    /// 			that you use to get the next page of results in a paginated
    /// 			response.</p>
    public let nextToken: String?

    public init (
        configRuleNames: [String]? = nil,
        limit: Int = 0,
        nextToken: String? = nil
    )
    {
        self.configRuleNames = configRuleNames
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribeConfigRuleEvaluationStatusInputBody: Equatable {
    public let configRuleNames: [String]?
    public let nextToken: String?
    public let limit: Int
}

extension DescribeConfigRuleEvaluationStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configRuleNames = "ConfigRuleNames"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .configRuleNames)
        var configRuleNamesDecoded0:[String]? = nil
        if let configRuleNamesContainer = configRuleNamesContainer {
            configRuleNamesDecoded0 = [String]()
            for string0 in configRuleNamesContainer {
                if let string0 = string0 {
                    configRuleNamesDecoded0?.append(string0)
                }
            }
        }
        configRuleNames = configRuleNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeConfigRuleEvaluationStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConfigRuleEvaluationStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigRuleException" : self = .noSuchConfigRuleException(try NoSuchConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConfigRuleEvaluationStatusOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchConfigRuleException(NoSuchConfigRuleException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigRuleEvaluationStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigRuleEvaluationStatusOutputResponse(configRulesEvaluationStatus: \(String(describing: configRulesEvaluationStatus)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeConfigRuleEvaluationStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeConfigRuleEvaluationStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configRulesEvaluationStatus = output.configRulesEvaluationStatus
            self.nextToken = output.nextToken
        } else {
            self.configRulesEvaluationStatus = nil
            self.nextToken = nil
        }
    }
}

/// <p></p>
public struct DescribeConfigRuleEvaluationStatusOutputResponse: Equatable {
    /// <p>Status information about your AWS managed Config
    /// 			rules.</p>
    public let configRulesEvaluationStatus: [ConfigRuleEvaluationStatus]?
    /// <p>The string that you use in a subsequent request to get the next
    /// 			page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        configRulesEvaluationStatus: [ConfigRuleEvaluationStatus]? = nil,
        nextToken: String? = nil
    )
    {
        self.configRulesEvaluationStatus = configRulesEvaluationStatus
        self.nextToken = nextToken
    }
}

struct DescribeConfigRuleEvaluationStatusOutputResponseBody: Equatable {
    public let configRulesEvaluationStatus: [ConfigRuleEvaluationStatus]?
    public let nextToken: String?
}

extension DescribeConfigRuleEvaluationStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configRulesEvaluationStatus = "ConfigRulesEvaluationStatus"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRulesEvaluationStatusContainer = try containerValues.decodeIfPresent([ConfigRuleEvaluationStatus?].self, forKey: .configRulesEvaluationStatus)
        var configRulesEvaluationStatusDecoded0:[ConfigRuleEvaluationStatus]? = nil
        if let configRulesEvaluationStatusContainer = configRulesEvaluationStatusContainer {
            configRulesEvaluationStatusDecoded0 = [ConfigRuleEvaluationStatus]()
            for structure0 in configRulesEvaluationStatusContainer {
                if let structure0 = structure0 {
                    configRulesEvaluationStatusDecoded0?.append(structure0)
                }
            }
        }
        configRulesEvaluationStatus = configRulesEvaluationStatusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeConfigRulesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeConfigRulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigRulesInput>
    public typealias MOutput = OperationOutput<DescribeConfigRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigRulesOutputError>
}

extension DescribeConfigRulesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigRulesInput(configRuleNames: \(String(describing: configRuleNames)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeConfigRulesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configRuleNames = "ConfigRuleNames"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleNames = configRuleNames {
            var configRuleNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configRuleNames)
            for configrulenames0 in configRuleNames {
                try configRuleNamesContainer.encode(configrulenames0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeConfigRulesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConfigRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigRulesInput>
    public typealias MOutput = OperationOutput<DescribeConfigRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigRulesOutputError>
}

public struct DescribeConfigRulesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConfigRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigRulesInput>
    public typealias MOutput = OperationOutput<DescribeConfigRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigRulesOutputError>
}

/// <p></p>
public struct DescribeConfigRulesInput: Equatable {
    /// <p>The names of the AWS Config rules for which you want details.
    /// 			If you do not specify any names, AWS Config returns details for all
    /// 			your rules.</p>
    public let configRuleNames: [String]?
    /// <p>The <code>nextToken</code> string returned on a previous page
    /// 			that you use to get the next page of results in a paginated
    /// 			response.</p>
    public let nextToken: String?

    public init (
        configRuleNames: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.configRuleNames = configRuleNames
        self.nextToken = nextToken
    }
}

struct DescribeConfigRulesInputBody: Equatable {
    public let configRuleNames: [String]?
    public let nextToken: String?
}

extension DescribeConfigRulesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configRuleNames = "ConfigRuleNames"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .configRuleNames)
        var configRuleNamesDecoded0:[String]? = nil
        if let configRuleNamesContainer = configRuleNamesContainer {
            configRuleNamesDecoded0 = [String]()
            for string0 in configRuleNamesContainer {
                if let string0 = string0 {
                    configRuleNamesDecoded0?.append(string0)
                }
            }
        }
        configRuleNames = configRuleNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConfigRulesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConfigRulesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigRuleException" : self = .noSuchConfigRuleException(try NoSuchConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConfigRulesOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchConfigRuleException(NoSuchConfigRuleException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigRulesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigRulesOutputResponse(configRules: \(String(describing: configRules)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeConfigRulesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeConfigRulesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configRules = output.configRules
            self.nextToken = output.nextToken
        } else {
            self.configRules = nil
            self.nextToken = nil
        }
    }
}

/// <p></p>
public struct DescribeConfigRulesOutputResponse: Equatable {
    /// <p>The details about your AWS Config rules.</p>
    public let configRules: [ConfigRule]?
    /// <p>The string that you use in a subsequent request to get the next
    /// 			page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        configRules: [ConfigRule]? = nil,
        nextToken: String? = nil
    )
    {
        self.configRules = configRules
        self.nextToken = nextToken
    }
}

struct DescribeConfigRulesOutputResponseBody: Equatable {
    public let configRules: [ConfigRule]?
    public let nextToken: String?
}

extension DescribeConfigRulesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configRules = "ConfigRules"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRulesContainer = try containerValues.decodeIfPresent([ConfigRule?].self, forKey: .configRules)
        var configRulesDecoded0:[ConfigRule]? = nil
        if let configRulesContainer = configRulesContainer {
            configRulesDecoded0 = [ConfigRule]()
            for structure0 in configRulesContainer {
                if let structure0 = structure0 {
                    configRulesDecoded0?.append(structure0)
                }
            }
        }
        configRules = configRulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeConfigurationAggregatorSourcesStatusInputBodyMiddleware: Middleware {
    public let id: String = "DescribeConfigurationAggregatorSourcesStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationAggregatorSourcesStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationAggregatorSourcesStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationAggregatorSourcesStatusInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationAggregatorSourcesStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationAggregatorSourcesStatusOutputError>
}

extension DescribeConfigurationAggregatorSourcesStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigurationAggregatorSourcesStatusInput(configurationAggregatorName: \(String(describing: configurationAggregatorName)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), updateStatus: \(String(describing: updateStatus)))"}
}

extension DescribeConfigurationAggregatorSourcesStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case updateStatus = "UpdateStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationAggregatorName = configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let updateStatus = updateStatus {
            var updateStatusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updateStatus)
            for aggregatedsourcestatustypelist0 in updateStatus {
                try updateStatusContainer.encode(aggregatedsourcestatustypelist0.rawValue)
            }
        }
    }
}

public struct DescribeConfigurationAggregatorSourcesStatusInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConfigurationAggregatorSourcesStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationAggregatorSourcesStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationAggregatorSourcesStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationAggregatorSourcesStatusInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationAggregatorSourcesStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationAggregatorSourcesStatusOutputError>
}

public struct DescribeConfigurationAggregatorSourcesStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConfigurationAggregatorSourcesStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationAggregatorSourcesStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationAggregatorSourcesStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationAggregatorSourcesStatusInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationAggregatorSourcesStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationAggregatorSourcesStatusOutputError>
}

public struct DescribeConfigurationAggregatorSourcesStatusInput: Equatable {
    /// <p>The name of the configuration aggregator.</p>
    public let configurationAggregatorName: String?
    /// <p>The maximum number of AggregatorSourceStatus returned on each
    /// 			page. The default is maximum. If you specify 0, AWS Config uses the
    /// 			default.</p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned on a previous page that you use
    /// 			to get the next page of results in a paginated response.</p>
    public let nextToken: String?
    /// <p>Filters the status type.</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>Valid value FAILED indicates errors while moving
    /// 					data.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Valid value SUCCEEDED indicates the data was
    /// 					successfully moved.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Valid value OUTDATED indicates the data is not the most
    /// 					recent.</p>
    /// 			         </li>
    ///          </ul>
    public let updateStatus: [AggregatedSourceStatusType]?

    public init (
        configurationAggregatorName: String? = nil,
        limit: Int = 0,
        nextToken: String? = nil,
        updateStatus: [AggregatedSourceStatusType]? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.limit = limit
        self.nextToken = nextToken
        self.updateStatus = updateStatus
    }
}

struct DescribeConfigurationAggregatorSourcesStatusInputBody: Equatable {
    public let configurationAggregatorName: String?
    public let updateStatus: [AggregatedSourceStatusType]?
    public let nextToken: String?
    public let limit: Int
}

extension DescribeConfigurationAggregatorSourcesStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case updateStatus = "UpdateStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let updateStatusContainer = try containerValues.decodeIfPresent([AggregatedSourceStatusType?].self, forKey: .updateStatus)
        var updateStatusDecoded0:[AggregatedSourceStatusType]? = nil
        if let updateStatusContainer = updateStatusContainer {
            updateStatusDecoded0 = [AggregatedSourceStatusType]()
            for string0 in updateStatusContainer {
                if let string0 = string0 {
                    updateStatusDecoded0?.append(string0)
                }
            }
        }
        updateStatus = updateStatusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeConfigurationAggregatorSourcesStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConfigurationAggregatorSourcesStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConfigurationAggregatorSourcesStatusOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigurationAggregatorSourcesStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigurationAggregatorSourcesStatusOutputResponse(aggregatedSourceStatusList: \(String(describing: aggregatedSourceStatusList)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeConfigurationAggregatorSourcesStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeConfigurationAggregatorSourcesStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.aggregatedSourceStatusList = output.aggregatedSourceStatusList
            self.nextToken = output.nextToken
        } else {
            self.aggregatedSourceStatusList = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConfigurationAggregatorSourcesStatusOutputResponse: Equatable {
    /// <p>Returns an AggregatedSourceStatus object.
    /// 			</p>
    public let aggregatedSourceStatusList: [AggregatedSourceStatus]?
    /// <p>The <code>nextToken</code> string returned on a previous page that you use
    /// 			to get the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        aggregatedSourceStatusList: [AggregatedSourceStatus]? = nil,
        nextToken: String? = nil
    )
    {
        self.aggregatedSourceStatusList = aggregatedSourceStatusList
        self.nextToken = nextToken
    }
}

struct DescribeConfigurationAggregatorSourcesStatusOutputResponseBody: Equatable {
    public let aggregatedSourceStatusList: [AggregatedSourceStatus]?
    public let nextToken: String?
}

extension DescribeConfigurationAggregatorSourcesStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aggregatedSourceStatusList = "AggregatedSourceStatusList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregatedSourceStatusListContainer = try containerValues.decodeIfPresent([AggregatedSourceStatus?].self, forKey: .aggregatedSourceStatusList)
        var aggregatedSourceStatusListDecoded0:[AggregatedSourceStatus]? = nil
        if let aggregatedSourceStatusListContainer = aggregatedSourceStatusListContainer {
            aggregatedSourceStatusListDecoded0 = [AggregatedSourceStatus]()
            for structure0 in aggregatedSourceStatusListContainer {
                if let structure0 = structure0 {
                    aggregatedSourceStatusListDecoded0?.append(structure0)
                }
            }
        }
        aggregatedSourceStatusList = aggregatedSourceStatusListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeConfigurationAggregatorsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeConfigurationAggregatorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationAggregatorsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationAggregatorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationAggregatorsInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationAggregatorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationAggregatorsOutputError>
}

extension DescribeConfigurationAggregatorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigurationAggregatorsInput(configurationAggregatorNames: \(String(describing: configurationAggregatorNames)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeConfigurationAggregatorsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationAggregatorNames = "ConfigurationAggregatorNames"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationAggregatorNames = configurationAggregatorNames {
            var configurationAggregatorNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationAggregatorNames)
            for configurationaggregatornamelist0 in configurationAggregatorNames {
                try configurationAggregatorNamesContainer.encode(configurationaggregatornamelist0)
            }
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeConfigurationAggregatorsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConfigurationAggregatorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationAggregatorsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationAggregatorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationAggregatorsInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationAggregatorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationAggregatorsOutputError>
}

public struct DescribeConfigurationAggregatorsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConfigurationAggregatorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationAggregatorsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationAggregatorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationAggregatorsInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationAggregatorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationAggregatorsOutputError>
}

public struct DescribeConfigurationAggregatorsInput: Equatable {
    /// <p>The name of the configuration aggregators.</p>
    public let configurationAggregatorNames: [String]?
    /// <p>The maximum number of configuration aggregators returned on
    /// 			each page. The default is maximum. If you specify 0, AWS Config uses
    /// 			the default.</p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned on a previous page that you use
    /// 			to get the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        configurationAggregatorNames: [String]? = nil,
        limit: Int = 0,
        nextToken: String? = nil
    )
    {
        self.configurationAggregatorNames = configurationAggregatorNames
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribeConfigurationAggregatorsInputBody: Equatable {
    public let configurationAggregatorNames: [String]?
    public let nextToken: String?
    public let limit: Int
}

extension DescribeConfigurationAggregatorsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationAggregatorNames = "ConfigurationAggregatorNames"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .configurationAggregatorNames)
        var configurationAggregatorNamesDecoded0:[String]? = nil
        if let configurationAggregatorNamesContainer = configurationAggregatorNamesContainer {
            configurationAggregatorNamesDecoded0 = [String]()
            for string0 in configurationAggregatorNamesContainer {
                if let string0 = string0 {
                    configurationAggregatorNamesDecoded0?.append(string0)
                }
            }
        }
        configurationAggregatorNames = configurationAggregatorNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DescribeConfigurationAggregatorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConfigurationAggregatorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConfigurationAggregatorsOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigurationAggregatorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigurationAggregatorsOutputResponse(configurationAggregators: \(String(describing: configurationAggregators)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeConfigurationAggregatorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeConfigurationAggregatorsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationAggregators = output.configurationAggregators
            self.nextToken = output.nextToken
        } else {
            self.configurationAggregators = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConfigurationAggregatorsOutputResponse: Equatable {
    /// <p>Returns a ConfigurationAggregators object.</p>
    public let configurationAggregators: [ConfigurationAggregator]?
    /// <p>The <code>nextToken</code> string returned on a previous page that you use
    /// 			to get the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        configurationAggregators: [ConfigurationAggregator]? = nil,
        nextToken: String? = nil
    )
    {
        self.configurationAggregators = configurationAggregators
        self.nextToken = nextToken
    }
}

struct DescribeConfigurationAggregatorsOutputResponseBody: Equatable {
    public let configurationAggregators: [ConfigurationAggregator]?
    public let nextToken: String?
}

extension DescribeConfigurationAggregatorsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationAggregators = "ConfigurationAggregators"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorsContainer = try containerValues.decodeIfPresent([ConfigurationAggregator?].self, forKey: .configurationAggregators)
        var configurationAggregatorsDecoded0:[ConfigurationAggregator]? = nil
        if let configurationAggregatorsContainer = configurationAggregatorsContainer {
            configurationAggregatorsDecoded0 = [ConfigurationAggregator]()
            for structure0 in configurationAggregatorsContainer {
                if let structure0 = structure0 {
                    configurationAggregatorsDecoded0?.append(structure0)
                }
            }
        }
        configurationAggregators = configurationAggregatorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeConfigurationRecorderStatusInputBodyMiddleware: Middleware {
    public let id: String = "DescribeConfigurationRecorderStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationRecorderStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationRecorderStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationRecorderStatusInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationRecorderStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationRecorderStatusOutputError>
}

extension DescribeConfigurationRecorderStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigurationRecorderStatusInput(configurationRecorderNames: \(String(describing: configurationRecorderNames)))"}
}

extension DescribeConfigurationRecorderStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationRecorderNames = "ConfigurationRecorderNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationRecorderNames = configurationRecorderNames {
            var configurationRecorderNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationRecorderNames)
            for configurationrecordernamelist0 in configurationRecorderNames {
                try configurationRecorderNamesContainer.encode(configurationrecordernamelist0)
            }
        }
    }
}

public struct DescribeConfigurationRecorderStatusInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConfigurationRecorderStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationRecorderStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationRecorderStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationRecorderStatusInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationRecorderStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationRecorderStatusOutputError>
}

public struct DescribeConfigurationRecorderStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConfigurationRecorderStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationRecorderStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationRecorderStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationRecorderStatusInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationRecorderStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationRecorderStatusOutputError>
}

/// <p>The input for the <a>DescribeConfigurationRecorderStatus</a>
/// 			action.</p>
public struct DescribeConfigurationRecorderStatusInput: Equatable {
    /// <p>The name(s) of the configuration recorder. If the name is not
    /// 			specified, the action returns the current status of all the
    /// 			configuration recorders associated with the account.</p>
    public let configurationRecorderNames: [String]?

    public init (
        configurationRecorderNames: [String]? = nil
    )
    {
        self.configurationRecorderNames = configurationRecorderNames
    }
}

struct DescribeConfigurationRecorderStatusInputBody: Equatable {
    public let configurationRecorderNames: [String]?
}

extension DescribeConfigurationRecorderStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationRecorderNames = "ConfigurationRecorderNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationRecorderNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .configurationRecorderNames)
        var configurationRecorderNamesDecoded0:[String]? = nil
        if let configurationRecorderNamesContainer = configurationRecorderNamesContainer {
            configurationRecorderNamesDecoded0 = [String]()
            for string0 in configurationRecorderNamesContainer {
                if let string0 = string0 {
                    configurationRecorderNamesDecoded0?.append(string0)
                }
            }
        }
        configurationRecorderNames = configurationRecorderNamesDecoded0
    }
}

extension DescribeConfigurationRecorderStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConfigurationRecorderStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchConfigurationRecorderException" : self = .noSuchConfigurationRecorderException(try NoSuchConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConfigurationRecorderStatusOutputError: Equatable {
    case noSuchConfigurationRecorderException(NoSuchConfigurationRecorderException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigurationRecorderStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigurationRecorderStatusOutputResponse(configurationRecordersStatus: \(String(describing: configurationRecordersStatus)))"}
}

extension DescribeConfigurationRecorderStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeConfigurationRecorderStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationRecordersStatus = output.configurationRecordersStatus
        } else {
            self.configurationRecordersStatus = nil
        }
    }
}

/// <p>The output for the <a>DescribeConfigurationRecorderStatus</a> action, in JSON
/// 			format.</p>
public struct DescribeConfigurationRecorderStatusOutputResponse: Equatable {
    /// <p>A list that contains status of the specified
    /// 			recorders.</p>
    public let configurationRecordersStatus: [ConfigurationRecorderStatus]?

    public init (
        configurationRecordersStatus: [ConfigurationRecorderStatus]? = nil
    )
    {
        self.configurationRecordersStatus = configurationRecordersStatus
    }
}

struct DescribeConfigurationRecorderStatusOutputResponseBody: Equatable {
    public let configurationRecordersStatus: [ConfigurationRecorderStatus]?
}

extension DescribeConfigurationRecorderStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationRecordersStatus = "ConfigurationRecordersStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationRecordersStatusContainer = try containerValues.decodeIfPresent([ConfigurationRecorderStatus?].self, forKey: .configurationRecordersStatus)
        var configurationRecordersStatusDecoded0:[ConfigurationRecorderStatus]? = nil
        if let configurationRecordersStatusContainer = configurationRecordersStatusContainer {
            configurationRecordersStatusDecoded0 = [ConfigurationRecorderStatus]()
            for structure0 in configurationRecordersStatusContainer {
                if let structure0 = structure0 {
                    configurationRecordersStatusDecoded0?.append(structure0)
                }
            }
        }
        configurationRecordersStatus = configurationRecordersStatusDecoded0
    }
}

public struct DescribeConfigurationRecordersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeConfigurationRecordersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationRecordersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationRecordersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationRecordersInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationRecordersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationRecordersOutputError>
}

extension DescribeConfigurationRecordersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigurationRecordersInput(configurationRecorderNames: \(String(describing: configurationRecorderNames)))"}
}

extension DescribeConfigurationRecordersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationRecorderNames = "ConfigurationRecorderNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationRecorderNames = configurationRecorderNames {
            var configurationRecorderNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationRecorderNames)
            for configurationrecordernamelist0 in configurationRecorderNames {
                try configurationRecorderNamesContainer.encode(configurationrecordernamelist0)
            }
        }
    }
}

public struct DescribeConfigurationRecordersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConfigurationRecordersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationRecordersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationRecordersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationRecordersInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationRecordersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationRecordersOutputError>
}

public struct DescribeConfigurationRecordersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConfigurationRecordersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationRecordersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationRecordersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationRecordersInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationRecordersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationRecordersOutputError>
}

/// <p>The input for the <a>DescribeConfigurationRecorders</a> action.</p>
public struct DescribeConfigurationRecordersInput: Equatable {
    /// <p>A list of configuration recorder names.</p>
    public let configurationRecorderNames: [String]?

    public init (
        configurationRecorderNames: [String]? = nil
    )
    {
        self.configurationRecorderNames = configurationRecorderNames
    }
}

struct DescribeConfigurationRecordersInputBody: Equatable {
    public let configurationRecorderNames: [String]?
}

extension DescribeConfigurationRecordersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationRecorderNames = "ConfigurationRecorderNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationRecorderNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .configurationRecorderNames)
        var configurationRecorderNamesDecoded0:[String]? = nil
        if let configurationRecorderNamesContainer = configurationRecorderNamesContainer {
            configurationRecorderNamesDecoded0 = [String]()
            for string0 in configurationRecorderNamesContainer {
                if let string0 = string0 {
                    configurationRecorderNamesDecoded0?.append(string0)
                }
            }
        }
        configurationRecorderNames = configurationRecorderNamesDecoded0
    }
}

extension DescribeConfigurationRecordersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConfigurationRecordersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchConfigurationRecorderException" : self = .noSuchConfigurationRecorderException(try NoSuchConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConfigurationRecordersOutputError: Equatable {
    case noSuchConfigurationRecorderException(NoSuchConfigurationRecorderException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigurationRecordersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigurationRecordersOutputResponse(configurationRecorders: \(String(describing: configurationRecorders)))"}
}

extension DescribeConfigurationRecordersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeConfigurationRecordersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationRecorders = output.configurationRecorders
        } else {
            self.configurationRecorders = nil
        }
    }
}

/// <p>The output for the <a>DescribeConfigurationRecorders</a> action.</p>
public struct DescribeConfigurationRecordersOutputResponse: Equatable {
    /// <p>A list that contains the descriptions of the specified
    /// 			configuration recorders.</p>
    public let configurationRecorders: [ConfigurationRecorder]?

    public init (
        configurationRecorders: [ConfigurationRecorder]? = nil
    )
    {
        self.configurationRecorders = configurationRecorders
    }
}

struct DescribeConfigurationRecordersOutputResponseBody: Equatable {
    public let configurationRecorders: [ConfigurationRecorder]?
}

extension DescribeConfigurationRecordersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationRecorders = "ConfigurationRecorders"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationRecordersContainer = try containerValues.decodeIfPresent([ConfigurationRecorder?].self, forKey: .configurationRecorders)
        var configurationRecordersDecoded0:[ConfigurationRecorder]? = nil
        if let configurationRecordersContainer = configurationRecordersContainer {
            configurationRecordersDecoded0 = [ConfigurationRecorder]()
            for structure0 in configurationRecordersContainer {
                if let structure0 = structure0 {
                    configurationRecordersDecoded0?.append(structure0)
                }
            }
        }
        configurationRecorders = configurationRecordersDecoded0
    }
}

public struct DescribeConformancePackComplianceInputBodyMiddleware: Middleware {
    public let id: String = "DescribeConformancePackComplianceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConformancePackComplianceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConformancePackComplianceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConformancePackComplianceInput>
    public typealias MOutput = OperationOutput<DescribeConformancePackComplianceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConformancePackComplianceOutputError>
}

extension DescribeConformancePackComplianceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConformancePackComplianceInput(conformancePackName: \(String(describing: conformancePackName)), filters: \(String(describing: filters)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeConformancePackComplianceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conformancePackName = "ConformancePackName"
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackName = conformancePackName {
            try encodeContainer.encode(conformancePackName, forKey: .conformancePackName)
        }
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeConformancePackComplianceInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConformancePackComplianceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConformancePackComplianceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConformancePackComplianceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConformancePackComplianceInput>
    public typealias MOutput = OperationOutput<DescribeConformancePackComplianceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConformancePackComplianceOutputError>
}

public struct DescribeConformancePackComplianceInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConformancePackComplianceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConformancePackComplianceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConformancePackComplianceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConformancePackComplianceInput>
    public typealias MOutput = OperationOutput<DescribeConformancePackComplianceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConformancePackComplianceOutputError>
}

public struct DescribeConformancePackComplianceInput: Equatable {
    /// <p>Name of the conformance pack.</p>
    public let conformancePackName: String?
    /// <p>A <code>ConformancePackComplianceFilters</code> object.</p>
    public let filters: ConformancePackComplianceFilters?
    /// <p>The maximum number of AWS Config rules within a conformance pack are returned on each page.</p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned in a previous request that you use to request the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        conformancePackName: String? = nil,
        filters: ConformancePackComplianceFilters? = nil,
        limit: Int = 0,
        nextToken: String? = nil
    )
    {
        self.conformancePackName = conformancePackName
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribeConformancePackComplianceInputBody: Equatable {
    public let conformancePackName: String?
    public let filters: ConformancePackComplianceFilters?
    public let limit: Int
    public let nextToken: String?
}

extension DescribeConformancePackComplianceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conformancePackName = "ConformancePackName"
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conformancePackName)
        conformancePackName = conformancePackNameDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(ConformancePackComplianceFilters.self, forKey: .filters)
        filters = filtersDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConformancePackComplianceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConformancePackComplianceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigRuleInConformancePackException" : self = .noSuchConfigRuleInConformancePackException(try NoSuchConfigRuleInConformancePackException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConformancePackException" : self = .noSuchConformancePackException(try NoSuchConformancePackException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConformancePackComplianceOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchConfigRuleInConformancePackException(NoSuchConfigRuleInConformancePackException)
    case noSuchConformancePackException(NoSuchConformancePackException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConformancePackComplianceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConformancePackComplianceOutputResponse(conformancePackName: \(String(describing: conformancePackName)), conformancePackRuleComplianceList: \(String(describing: conformancePackRuleComplianceList)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeConformancePackComplianceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeConformancePackComplianceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.conformancePackName = output.conformancePackName
            self.conformancePackRuleComplianceList = output.conformancePackRuleComplianceList
            self.nextToken = output.nextToken
        } else {
            self.conformancePackName = nil
            self.conformancePackRuleComplianceList = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConformancePackComplianceOutputResponse: Equatable {
    /// <p>Name of the conformance pack.</p>
    public let conformancePackName: String?
    /// <p>Returns a list of <code>ConformancePackRuleCompliance</code> objects.</p>
    public let conformancePackRuleComplianceList: [ConformancePackRuleCompliance]?
    /// <p>The <code>nextToken</code> string returned in a previous request that you use to request the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        conformancePackName: String? = nil,
        conformancePackRuleComplianceList: [ConformancePackRuleCompliance]? = nil,
        nextToken: String? = nil
    )
    {
        self.conformancePackName = conformancePackName
        self.conformancePackRuleComplianceList = conformancePackRuleComplianceList
        self.nextToken = nextToken
    }
}

struct DescribeConformancePackComplianceOutputResponseBody: Equatable {
    public let conformancePackName: String?
    public let conformancePackRuleComplianceList: [ConformancePackRuleCompliance]?
    public let nextToken: String?
}

extension DescribeConformancePackComplianceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conformancePackName = "ConformancePackName"
        case conformancePackRuleComplianceList = "ConformancePackRuleComplianceList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conformancePackName)
        conformancePackName = conformancePackNameDecoded
        let conformancePackRuleComplianceListContainer = try containerValues.decodeIfPresent([ConformancePackRuleCompliance?].self, forKey: .conformancePackRuleComplianceList)
        var conformancePackRuleComplianceListDecoded0:[ConformancePackRuleCompliance]? = nil
        if let conformancePackRuleComplianceListContainer = conformancePackRuleComplianceListContainer {
            conformancePackRuleComplianceListDecoded0 = [ConformancePackRuleCompliance]()
            for structure0 in conformancePackRuleComplianceListContainer {
                if let structure0 = structure0 {
                    conformancePackRuleComplianceListDecoded0?.append(structure0)
                }
            }
        }
        conformancePackRuleComplianceList = conformancePackRuleComplianceListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeConformancePackStatusInputBodyMiddleware: Middleware {
    public let id: String = "DescribeConformancePackStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConformancePackStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConformancePackStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConformancePackStatusInput>
    public typealias MOutput = OperationOutput<DescribeConformancePackStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConformancePackStatusOutputError>
}

extension DescribeConformancePackStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConformancePackStatusInput(conformancePackNames: \(String(describing: conformancePackNames)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeConformancePackStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conformancePackNames = "ConformancePackNames"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackNames = conformancePackNames {
            var conformancePackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conformancePackNames)
            for conformancepacknameslist0 in conformancePackNames {
                try conformancePackNamesContainer.encode(conformancepacknameslist0)
            }
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeConformancePackStatusInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConformancePackStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConformancePackStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConformancePackStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConformancePackStatusInput>
    public typealias MOutput = OperationOutput<DescribeConformancePackStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConformancePackStatusOutputError>
}

public struct DescribeConformancePackStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConformancePackStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConformancePackStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConformancePackStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConformancePackStatusInput>
    public typealias MOutput = OperationOutput<DescribeConformancePackStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConformancePackStatusOutputError>
}

public struct DescribeConformancePackStatusInput: Equatable {
    /// <p>Comma-separated list of conformance pack names.</p>
    public let conformancePackNames: [String]?
    /// <p>The maximum number of conformance packs status returned on each page.</p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned in a previous request that you use to request the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        conformancePackNames: [String]? = nil,
        limit: Int = 0,
        nextToken: String? = nil
    )
    {
        self.conformancePackNames = conformancePackNames
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribeConformancePackStatusInputBody: Equatable {
    public let conformancePackNames: [String]?
    public let limit: Int
    public let nextToken: String?
}

extension DescribeConformancePackStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conformancePackNames = "ConformancePackNames"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .conformancePackNames)
        var conformancePackNamesDecoded0:[String]? = nil
        if let conformancePackNamesContainer = conformancePackNamesContainer {
            conformancePackNamesDecoded0 = [String]()
            for string0 in conformancePackNamesContainer {
                if let string0 = string0 {
                    conformancePackNamesDecoded0?.append(string0)
                }
            }
        }
        conformancePackNames = conformancePackNamesDecoded0
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConformancePackStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConformancePackStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConformancePackStatusOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConformancePackStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConformancePackStatusOutputResponse(conformancePackStatusDetails: \(String(describing: conformancePackStatusDetails)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeConformancePackStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeConformancePackStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.conformancePackStatusDetails = output.conformancePackStatusDetails
            self.nextToken = output.nextToken
        } else {
            self.conformancePackStatusDetails = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConformancePackStatusOutputResponse: Equatable {
    /// <p>A list of <code>ConformancePackStatusDetail</code> objects.</p>
    public let conformancePackStatusDetails: [ConformancePackStatusDetail]?
    /// <p>The <code>nextToken</code> string returned in a previous request that you use to request the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        conformancePackStatusDetails: [ConformancePackStatusDetail]? = nil,
        nextToken: String? = nil
    )
    {
        self.conformancePackStatusDetails = conformancePackStatusDetails
        self.nextToken = nextToken
    }
}

struct DescribeConformancePackStatusOutputResponseBody: Equatable {
    public let conformancePackStatusDetails: [ConformancePackStatusDetail]?
    public let nextToken: String?
}

extension DescribeConformancePackStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conformancePackStatusDetails = "ConformancePackStatusDetails"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackStatusDetailsContainer = try containerValues.decodeIfPresent([ConformancePackStatusDetail?].self, forKey: .conformancePackStatusDetails)
        var conformancePackStatusDetailsDecoded0:[ConformancePackStatusDetail]? = nil
        if let conformancePackStatusDetailsContainer = conformancePackStatusDetailsContainer {
            conformancePackStatusDetailsDecoded0 = [ConformancePackStatusDetail]()
            for structure0 in conformancePackStatusDetailsContainer {
                if let structure0 = structure0 {
                    conformancePackStatusDetailsDecoded0?.append(structure0)
                }
            }
        }
        conformancePackStatusDetails = conformancePackStatusDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeConformancePacksInputBodyMiddleware: Middleware {
    public let id: String = "DescribeConformancePacksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConformancePacksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConformancePacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConformancePacksInput>
    public typealias MOutput = OperationOutput<DescribeConformancePacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConformancePacksOutputError>
}

extension DescribeConformancePacksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConformancePacksInput(conformancePackNames: \(String(describing: conformancePackNames)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeConformancePacksInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conformancePackNames = "ConformancePackNames"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackNames = conformancePackNames {
            var conformancePackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conformancePackNames)
            for conformancepacknameslist0 in conformancePackNames {
                try conformancePackNamesContainer.encode(conformancepacknameslist0)
            }
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeConformancePacksInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConformancePacksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConformancePacksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConformancePacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConformancePacksInput>
    public typealias MOutput = OperationOutput<DescribeConformancePacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConformancePacksOutputError>
}

public struct DescribeConformancePacksInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConformancePacksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConformancePacksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConformancePacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConformancePacksInput>
    public typealias MOutput = OperationOutput<DescribeConformancePacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConformancePacksOutputError>
}

public struct DescribeConformancePacksInput: Equatable {
    /// <p>Comma-separated list of conformance pack names for which you want details. If you do not specify any names, AWS Config returns details for all your conformance packs. </p>
    public let conformancePackNames: [String]?
    /// <p>The maximum number of conformance packs returned on each page.</p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned in a previous request that you use to request the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        conformancePackNames: [String]? = nil,
        limit: Int = 0,
        nextToken: String? = nil
    )
    {
        self.conformancePackNames = conformancePackNames
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribeConformancePacksInputBody: Equatable {
    public let conformancePackNames: [String]?
    public let limit: Int
    public let nextToken: String?
}

extension DescribeConformancePacksInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conformancePackNames = "ConformancePackNames"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .conformancePackNames)
        var conformancePackNamesDecoded0:[String]? = nil
        if let conformancePackNamesContainer = conformancePackNamesContainer {
            conformancePackNamesDecoded0 = [String]()
            for string0 in conformancePackNamesContainer {
                if let string0 = string0 {
                    conformancePackNamesDecoded0?.append(string0)
                }
            }
        }
        conformancePackNames = conformancePackNamesDecoded0
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConformancePacksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConformancePacksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConformancePackException" : self = .noSuchConformancePackException(try NoSuchConformancePackException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConformancePacksOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchConformancePackException(NoSuchConformancePackException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConformancePacksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConformancePacksOutputResponse(conformancePackDetails: \(String(describing: conformancePackDetails)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeConformancePacksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeConformancePacksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.conformancePackDetails = output.conformancePackDetails
            self.nextToken = output.nextToken
        } else {
            self.conformancePackDetails = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConformancePacksOutputResponse: Equatable {
    /// <p>Returns a list of <code>ConformancePackDetail</code> objects.</p>
    public let conformancePackDetails: [ConformancePackDetail]?
    /// <p>The <code>nextToken</code> string returned in a previous request that you use to request the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        conformancePackDetails: [ConformancePackDetail]? = nil,
        nextToken: String? = nil
    )
    {
        self.conformancePackDetails = conformancePackDetails
        self.nextToken = nextToken
    }
}

struct DescribeConformancePacksOutputResponseBody: Equatable {
    public let conformancePackDetails: [ConformancePackDetail]?
    public let nextToken: String?
}

extension DescribeConformancePacksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conformancePackDetails = "ConformancePackDetails"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackDetailsContainer = try containerValues.decodeIfPresent([ConformancePackDetail?].self, forKey: .conformancePackDetails)
        var conformancePackDetailsDecoded0:[ConformancePackDetail]? = nil
        if let conformancePackDetailsContainer = conformancePackDetailsContainer {
            conformancePackDetailsDecoded0 = [ConformancePackDetail]()
            for structure0 in conformancePackDetailsContainer {
                if let structure0 = structure0 {
                    conformancePackDetailsDecoded0?.append(structure0)
                }
            }
        }
        conformancePackDetails = conformancePackDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeDeliveryChannelStatusInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDeliveryChannelStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDeliveryChannelStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDeliveryChannelStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDeliveryChannelStatusInput>
    public typealias MOutput = OperationOutput<DescribeDeliveryChannelStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDeliveryChannelStatusOutputError>
}

extension DescribeDeliveryChannelStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDeliveryChannelStatusInput(deliveryChannelNames: \(String(describing: deliveryChannelNames)))"}
}

extension DescribeDeliveryChannelStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deliveryChannelNames = "DeliveryChannelNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryChannelNames = deliveryChannelNames {
            var deliveryChannelNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deliveryChannelNames)
            for deliverychannelnamelist0 in deliveryChannelNames {
                try deliveryChannelNamesContainer.encode(deliverychannelnamelist0)
            }
        }
    }
}

public struct DescribeDeliveryChannelStatusInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDeliveryChannelStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDeliveryChannelStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDeliveryChannelStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDeliveryChannelStatusInput>
    public typealias MOutput = OperationOutput<DescribeDeliveryChannelStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDeliveryChannelStatusOutputError>
}

public struct DescribeDeliveryChannelStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDeliveryChannelStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDeliveryChannelStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDeliveryChannelStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDeliveryChannelStatusInput>
    public typealias MOutput = OperationOutput<DescribeDeliveryChannelStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDeliveryChannelStatusOutputError>
}

/// <p>The input for the <a>DeliveryChannelStatus</a>
/// 			action.</p>
public struct DescribeDeliveryChannelStatusInput: Equatable {
    /// <p>A list of delivery channel names.</p>
    public let deliveryChannelNames: [String]?

    public init (
        deliveryChannelNames: [String]? = nil
    )
    {
        self.deliveryChannelNames = deliveryChannelNames
    }
}

struct DescribeDeliveryChannelStatusInputBody: Equatable {
    public let deliveryChannelNames: [String]?
}

extension DescribeDeliveryChannelStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deliveryChannelNames = "DeliveryChannelNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryChannelNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .deliveryChannelNames)
        var deliveryChannelNamesDecoded0:[String]? = nil
        if let deliveryChannelNamesContainer = deliveryChannelNamesContainer {
            deliveryChannelNamesDecoded0 = [String]()
            for string0 in deliveryChannelNamesContainer {
                if let string0 = string0 {
                    deliveryChannelNamesDecoded0?.append(string0)
                }
            }
        }
        deliveryChannelNames = deliveryChannelNamesDecoded0
    }
}

extension DescribeDeliveryChannelStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDeliveryChannelStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchDeliveryChannelException" : self = .noSuchDeliveryChannelException(try NoSuchDeliveryChannelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDeliveryChannelStatusOutputError: Equatable {
    case noSuchDeliveryChannelException(NoSuchDeliveryChannelException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDeliveryChannelStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDeliveryChannelStatusOutputResponse(deliveryChannelsStatus: \(String(describing: deliveryChannelsStatus)))"}
}

extension DescribeDeliveryChannelStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDeliveryChannelStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deliveryChannelsStatus = output.deliveryChannelsStatus
        } else {
            self.deliveryChannelsStatus = nil
        }
    }
}

/// <p>The output for the <a>DescribeDeliveryChannelStatus</a> action.</p>
public struct DescribeDeliveryChannelStatusOutputResponse: Equatable {
    /// <p>A list that contains the status of a specified delivery
    /// 			channel.</p>
    public let deliveryChannelsStatus: [DeliveryChannelStatus]?

    public init (
        deliveryChannelsStatus: [DeliveryChannelStatus]? = nil
    )
    {
        self.deliveryChannelsStatus = deliveryChannelsStatus
    }
}

struct DescribeDeliveryChannelStatusOutputResponseBody: Equatable {
    public let deliveryChannelsStatus: [DeliveryChannelStatus]?
}

extension DescribeDeliveryChannelStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deliveryChannelsStatus = "DeliveryChannelsStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryChannelsStatusContainer = try containerValues.decodeIfPresent([DeliveryChannelStatus?].self, forKey: .deliveryChannelsStatus)
        var deliveryChannelsStatusDecoded0:[DeliveryChannelStatus]? = nil
        if let deliveryChannelsStatusContainer = deliveryChannelsStatusContainer {
            deliveryChannelsStatusDecoded0 = [DeliveryChannelStatus]()
            for structure0 in deliveryChannelsStatusContainer {
                if let structure0 = structure0 {
                    deliveryChannelsStatusDecoded0?.append(structure0)
                }
            }
        }
        deliveryChannelsStatus = deliveryChannelsStatusDecoded0
    }
}

public struct DescribeDeliveryChannelsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDeliveryChannelsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDeliveryChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDeliveryChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDeliveryChannelsInput>
    public typealias MOutput = OperationOutput<DescribeDeliveryChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDeliveryChannelsOutputError>
}

extension DescribeDeliveryChannelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDeliveryChannelsInput(deliveryChannelNames: \(String(describing: deliveryChannelNames)))"}
}

extension DescribeDeliveryChannelsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deliveryChannelNames = "DeliveryChannelNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryChannelNames = deliveryChannelNames {
            var deliveryChannelNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deliveryChannelNames)
            for deliverychannelnamelist0 in deliveryChannelNames {
                try deliveryChannelNamesContainer.encode(deliverychannelnamelist0)
            }
        }
    }
}

public struct DescribeDeliveryChannelsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDeliveryChannelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDeliveryChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDeliveryChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDeliveryChannelsInput>
    public typealias MOutput = OperationOutput<DescribeDeliveryChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDeliveryChannelsOutputError>
}

public struct DescribeDeliveryChannelsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDeliveryChannelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDeliveryChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDeliveryChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDeliveryChannelsInput>
    public typealias MOutput = OperationOutput<DescribeDeliveryChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDeliveryChannelsOutputError>
}

/// <p>The input for the <a>DescribeDeliveryChannels</a>
/// 			action.</p>
public struct DescribeDeliveryChannelsInput: Equatable {
    /// <p>A list of delivery channel names.</p>
    public let deliveryChannelNames: [String]?

    public init (
        deliveryChannelNames: [String]? = nil
    )
    {
        self.deliveryChannelNames = deliveryChannelNames
    }
}

struct DescribeDeliveryChannelsInputBody: Equatable {
    public let deliveryChannelNames: [String]?
}

extension DescribeDeliveryChannelsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deliveryChannelNames = "DeliveryChannelNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryChannelNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .deliveryChannelNames)
        var deliveryChannelNamesDecoded0:[String]? = nil
        if let deliveryChannelNamesContainer = deliveryChannelNamesContainer {
            deliveryChannelNamesDecoded0 = [String]()
            for string0 in deliveryChannelNamesContainer {
                if let string0 = string0 {
                    deliveryChannelNamesDecoded0?.append(string0)
                }
            }
        }
        deliveryChannelNames = deliveryChannelNamesDecoded0
    }
}

extension DescribeDeliveryChannelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDeliveryChannelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchDeliveryChannelException" : self = .noSuchDeliveryChannelException(try NoSuchDeliveryChannelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDeliveryChannelsOutputError: Equatable {
    case noSuchDeliveryChannelException(NoSuchDeliveryChannelException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDeliveryChannelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDeliveryChannelsOutputResponse(deliveryChannels: \(String(describing: deliveryChannels)))"}
}

extension DescribeDeliveryChannelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDeliveryChannelsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deliveryChannels = output.deliveryChannels
        } else {
            self.deliveryChannels = nil
        }
    }
}

/// <p>The output for the <a>DescribeDeliveryChannels</a>
/// 			action.</p>
public struct DescribeDeliveryChannelsOutputResponse: Equatable {
    /// <p>A list that contains the descriptions of the specified delivery
    /// 			channel.</p>
    public let deliveryChannels: [DeliveryChannel]?

    public init (
        deliveryChannels: [DeliveryChannel]? = nil
    )
    {
        self.deliveryChannels = deliveryChannels
    }
}

struct DescribeDeliveryChannelsOutputResponseBody: Equatable {
    public let deliveryChannels: [DeliveryChannel]?
}

extension DescribeDeliveryChannelsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deliveryChannels = "DeliveryChannels"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryChannelsContainer = try containerValues.decodeIfPresent([DeliveryChannel?].self, forKey: .deliveryChannels)
        var deliveryChannelsDecoded0:[DeliveryChannel]? = nil
        if let deliveryChannelsContainer = deliveryChannelsContainer {
            deliveryChannelsDecoded0 = [DeliveryChannel]()
            for structure0 in deliveryChannelsContainer {
                if let structure0 = structure0 {
                    deliveryChannelsDecoded0?.append(structure0)
                }
            }
        }
        deliveryChannels = deliveryChannelsDecoded0
    }
}

public struct DescribeOrganizationConfigRuleStatusesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeOrganizationConfigRuleStatusesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrganizationConfigRuleStatusesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrganizationConfigRuleStatusesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrganizationConfigRuleStatusesInput>
    public typealias MOutput = OperationOutput<DescribeOrganizationConfigRuleStatusesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrganizationConfigRuleStatusesOutputError>
}

extension DescribeOrganizationConfigRuleStatusesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOrganizationConfigRuleStatusesInput(limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), organizationConfigRuleNames: \(String(describing: organizationConfigRuleNames)))"}
}

extension DescribeOrganizationConfigRuleStatusesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case organizationConfigRuleNames = "OrganizationConfigRuleNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationConfigRuleNames = organizationConfigRuleNames {
            var organizationConfigRuleNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationConfigRuleNames)
            for organizationconfigrulenames0 in organizationConfigRuleNames {
                try organizationConfigRuleNamesContainer.encode(organizationconfigrulenames0)
            }
        }
    }
}

public struct DescribeOrganizationConfigRuleStatusesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeOrganizationConfigRuleStatusesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrganizationConfigRuleStatusesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrganizationConfigRuleStatusesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrganizationConfigRuleStatusesInput>
    public typealias MOutput = OperationOutput<DescribeOrganizationConfigRuleStatusesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrganizationConfigRuleStatusesOutputError>
}

public struct DescribeOrganizationConfigRuleStatusesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeOrganizationConfigRuleStatusesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrganizationConfigRuleStatusesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrganizationConfigRuleStatusesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrganizationConfigRuleStatusesInput>
    public typealias MOutput = OperationOutput<DescribeOrganizationConfigRuleStatusesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrganizationConfigRuleStatusesOutputError>
}

public struct DescribeOrganizationConfigRuleStatusesInput: Equatable {
    /// <p>The maximum number of <code>OrganizationConfigRuleStatuses</code> returned on each page. If you do no specify a number, AWS Config uses the default. The default is 100.</p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned on a previous page that you use to get the next page of results in a paginated response. </p>
    public let nextToken: String?
    /// <p>The names of organization config rules for which you want status details. If you do not specify any names, AWS Config returns details for all your organization AWS Confg rules.</p>
    public let organizationConfigRuleNames: [String]?

    public init (
        limit: Int = 0,
        nextToken: String? = nil,
        organizationConfigRuleNames: [String]? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.organizationConfigRuleNames = organizationConfigRuleNames
    }
}

struct DescribeOrganizationConfigRuleStatusesInputBody: Equatable {
    public let organizationConfigRuleNames: [String]?
    public let limit: Int
    public let nextToken: String?
}

extension DescribeOrganizationConfigRuleStatusesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case organizationConfigRuleNames = "OrganizationConfigRuleNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConfigRuleNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .organizationConfigRuleNames)
        var organizationConfigRuleNamesDecoded0:[String]? = nil
        if let organizationConfigRuleNamesContainer = organizationConfigRuleNamesContainer {
            organizationConfigRuleNamesDecoded0 = [String]()
            for string0 in organizationConfigRuleNamesContainer {
                if let string0 = string0 {
                    organizationConfigRuleNamesDecoded0?.append(string0)
                }
            }
        }
        organizationConfigRuleNames = organizationConfigRuleNamesDecoded0
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeOrganizationConfigRuleStatusesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOrganizationConfigRuleStatusesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOrganizationConfigRuleException" : self = .noSuchOrganizationConfigRuleException(try NoSuchOrganizationConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAccessDeniedException" : self = .organizationAccessDeniedException(try OrganizationAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOrganizationConfigRuleStatusesOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchOrganizationConfigRuleException(NoSuchOrganizationConfigRuleException)
    case organizationAccessDeniedException(OrganizationAccessDeniedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrganizationConfigRuleStatusesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOrganizationConfigRuleStatusesOutputResponse(nextToken: \(String(describing: nextToken)), organizationConfigRuleStatuses: \(String(describing: organizationConfigRuleStatuses)))"}
}

extension DescribeOrganizationConfigRuleStatusesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeOrganizationConfigRuleStatusesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.organizationConfigRuleStatuses = output.organizationConfigRuleStatuses
        } else {
            self.nextToken = nil
            self.organizationConfigRuleStatuses = nil
        }
    }
}

public struct DescribeOrganizationConfigRuleStatusesOutputResponse: Equatable {
    /// <p>The <code>nextToken</code> string returned on a previous page that you use to get the next page of results in a paginated response. </p>
    public let nextToken: String?
    /// <p>A list of <code>OrganizationConfigRuleStatus</code> objects.</p>
    public let organizationConfigRuleStatuses: [OrganizationConfigRuleStatus]?

    public init (
        nextToken: String? = nil,
        organizationConfigRuleStatuses: [OrganizationConfigRuleStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationConfigRuleStatuses = organizationConfigRuleStatuses
    }
}

struct DescribeOrganizationConfigRuleStatusesOutputResponseBody: Equatable {
    public let organizationConfigRuleStatuses: [OrganizationConfigRuleStatus]?
    public let nextToken: String?
}

extension DescribeOrganizationConfigRuleStatusesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case organizationConfigRuleStatuses = "OrganizationConfigRuleStatuses"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConfigRuleStatusesContainer = try containerValues.decodeIfPresent([OrganizationConfigRuleStatus?].self, forKey: .organizationConfigRuleStatuses)
        var organizationConfigRuleStatusesDecoded0:[OrganizationConfigRuleStatus]? = nil
        if let organizationConfigRuleStatusesContainer = organizationConfigRuleStatusesContainer {
            organizationConfigRuleStatusesDecoded0 = [OrganizationConfigRuleStatus]()
            for structure0 in organizationConfigRuleStatusesContainer {
                if let structure0 = structure0 {
                    organizationConfigRuleStatusesDecoded0?.append(structure0)
                }
            }
        }
        organizationConfigRuleStatuses = organizationConfigRuleStatusesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeOrganizationConfigRulesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeOrganizationConfigRulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrganizationConfigRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrganizationConfigRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrganizationConfigRulesInput>
    public typealias MOutput = OperationOutput<DescribeOrganizationConfigRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrganizationConfigRulesOutputError>
}

extension DescribeOrganizationConfigRulesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOrganizationConfigRulesInput(limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), organizationConfigRuleNames: \(String(describing: organizationConfigRuleNames)))"}
}

extension DescribeOrganizationConfigRulesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case organizationConfigRuleNames = "OrganizationConfigRuleNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationConfigRuleNames = organizationConfigRuleNames {
            var organizationConfigRuleNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationConfigRuleNames)
            for organizationconfigrulenames0 in organizationConfigRuleNames {
                try organizationConfigRuleNamesContainer.encode(organizationconfigrulenames0)
            }
        }
    }
}

public struct DescribeOrganizationConfigRulesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeOrganizationConfigRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrganizationConfigRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrganizationConfigRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrganizationConfigRulesInput>
    public typealias MOutput = OperationOutput<DescribeOrganizationConfigRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrganizationConfigRulesOutputError>
}

public struct DescribeOrganizationConfigRulesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeOrganizationConfigRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrganizationConfigRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrganizationConfigRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrganizationConfigRulesInput>
    public typealias MOutput = OperationOutput<DescribeOrganizationConfigRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrganizationConfigRulesOutputError>
}

public struct DescribeOrganizationConfigRulesInput: Equatable {
    /// <p>The maximum number of organization config rules returned on each page. If you do no specify a number, AWS Config uses the default. The default is 100.</p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned on a previous page that you use to get the next page of results in a paginated response. </p>
    public let nextToken: String?
    /// <p>The names of organization config rules for which you want details. If you do not specify any names, AWS Config returns details for all your organization config rules.</p>
    public let organizationConfigRuleNames: [String]?

    public init (
        limit: Int = 0,
        nextToken: String? = nil,
        organizationConfigRuleNames: [String]? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.organizationConfigRuleNames = organizationConfigRuleNames
    }
}

struct DescribeOrganizationConfigRulesInputBody: Equatable {
    public let organizationConfigRuleNames: [String]?
    public let limit: Int
    public let nextToken: String?
}

extension DescribeOrganizationConfigRulesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case organizationConfigRuleNames = "OrganizationConfigRuleNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConfigRuleNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .organizationConfigRuleNames)
        var organizationConfigRuleNamesDecoded0:[String]? = nil
        if let organizationConfigRuleNamesContainer = organizationConfigRuleNamesContainer {
            organizationConfigRuleNamesDecoded0 = [String]()
            for string0 in organizationConfigRuleNamesContainer {
                if let string0 = string0 {
                    organizationConfigRuleNamesDecoded0?.append(string0)
                }
            }
        }
        organizationConfigRuleNames = organizationConfigRuleNamesDecoded0
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeOrganizationConfigRulesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOrganizationConfigRulesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOrganizationConfigRuleException" : self = .noSuchOrganizationConfigRuleException(try NoSuchOrganizationConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAccessDeniedException" : self = .organizationAccessDeniedException(try OrganizationAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOrganizationConfigRulesOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchOrganizationConfigRuleException(NoSuchOrganizationConfigRuleException)
    case organizationAccessDeniedException(OrganizationAccessDeniedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrganizationConfigRulesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOrganizationConfigRulesOutputResponse(nextToken: \(String(describing: nextToken)), organizationConfigRules: \(String(describing: organizationConfigRules)))"}
}

extension DescribeOrganizationConfigRulesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeOrganizationConfigRulesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.organizationConfigRules = output.organizationConfigRules
        } else {
            self.nextToken = nil
            self.organizationConfigRules = nil
        }
    }
}

public struct DescribeOrganizationConfigRulesOutputResponse: Equatable {
    /// <p>The <code>nextToken</code> string returned on a previous page that you use to get the next page of results in a paginated response. </p>
    public let nextToken: String?
    /// <p>Returns a list of <code>OrganizationConfigRule</code> objects.</p>
    public let organizationConfigRules: [OrganizationConfigRule]?

    public init (
        nextToken: String? = nil,
        organizationConfigRules: [OrganizationConfigRule]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationConfigRules = organizationConfigRules
    }
}

struct DescribeOrganizationConfigRulesOutputResponseBody: Equatable {
    public let organizationConfigRules: [OrganizationConfigRule]?
    public let nextToken: String?
}

extension DescribeOrganizationConfigRulesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case organizationConfigRules = "OrganizationConfigRules"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConfigRulesContainer = try containerValues.decodeIfPresent([OrganizationConfigRule?].self, forKey: .organizationConfigRules)
        var organizationConfigRulesDecoded0:[OrganizationConfigRule]? = nil
        if let organizationConfigRulesContainer = organizationConfigRulesContainer {
            organizationConfigRulesDecoded0 = [OrganizationConfigRule]()
            for structure0 in organizationConfigRulesContainer {
                if let structure0 = structure0 {
                    organizationConfigRulesDecoded0?.append(structure0)
                }
            }
        }
        organizationConfigRules = organizationConfigRulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeOrganizationConformancePackStatusesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeOrganizationConformancePackStatusesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrganizationConformancePackStatusesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrganizationConformancePackStatusesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrganizationConformancePackStatusesInput>
    public typealias MOutput = OperationOutput<DescribeOrganizationConformancePackStatusesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrganizationConformancePackStatusesOutputError>
}

extension DescribeOrganizationConformancePackStatusesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOrganizationConformancePackStatusesInput(limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), organizationConformancePackNames: \(String(describing: organizationConformancePackNames)))"}
}

extension DescribeOrganizationConformancePackStatusesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case organizationConformancePackNames = "OrganizationConformancePackNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationConformancePackNames = organizationConformancePackNames {
            var organizationConformancePackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationConformancePackNames)
            for organizationconformancepacknames0 in organizationConformancePackNames {
                try organizationConformancePackNamesContainer.encode(organizationconformancepacknames0)
            }
        }
    }
}

public struct DescribeOrganizationConformancePackStatusesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeOrganizationConformancePackStatusesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrganizationConformancePackStatusesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrganizationConformancePackStatusesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrganizationConformancePackStatusesInput>
    public typealias MOutput = OperationOutput<DescribeOrganizationConformancePackStatusesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrganizationConformancePackStatusesOutputError>
}

public struct DescribeOrganizationConformancePackStatusesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeOrganizationConformancePackStatusesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrganizationConformancePackStatusesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrganizationConformancePackStatusesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrganizationConformancePackStatusesInput>
    public typealias MOutput = OperationOutput<DescribeOrganizationConformancePackStatusesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrganizationConformancePackStatusesOutputError>
}

public struct DescribeOrganizationConformancePackStatusesInput: Equatable {
    /// <p>The maximum number of OrganizationConformancePackStatuses returned on each page.
    /// 			If you do no specify a number, AWS Config uses the default. The default is 100. </p>
    public let limit: Int
    /// <p>The nextToken string returned on a previous page that you use to get the next page of results in a paginated response. </p>
    public let nextToken: String?
    /// <p>The names of organization conformance packs for which you want status details.
    /// 			If you do not specify any names, AWS Config returns details for all your organization conformance packs. </p>
    public let organizationConformancePackNames: [String]?

    public init (
        limit: Int = 0,
        nextToken: String? = nil,
        organizationConformancePackNames: [String]? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.organizationConformancePackNames = organizationConformancePackNames
    }
}

struct DescribeOrganizationConformancePackStatusesInputBody: Equatable {
    public let organizationConformancePackNames: [String]?
    public let limit: Int
    public let nextToken: String?
}

extension DescribeOrganizationConformancePackStatusesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case organizationConformancePackNames = "OrganizationConformancePackNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConformancePackNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .organizationConformancePackNames)
        var organizationConformancePackNamesDecoded0:[String]? = nil
        if let organizationConformancePackNamesContainer = organizationConformancePackNamesContainer {
            organizationConformancePackNamesDecoded0 = [String]()
            for string0 in organizationConformancePackNamesContainer {
                if let string0 = string0 {
                    organizationConformancePackNamesDecoded0?.append(string0)
                }
            }
        }
        organizationConformancePackNames = organizationConformancePackNamesDecoded0
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeOrganizationConformancePackStatusesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOrganizationConformancePackStatusesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOrganizationConformancePackException" : self = .noSuchOrganizationConformancePackException(try NoSuchOrganizationConformancePackException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAccessDeniedException" : self = .organizationAccessDeniedException(try OrganizationAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOrganizationConformancePackStatusesOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchOrganizationConformancePackException(NoSuchOrganizationConformancePackException)
    case organizationAccessDeniedException(OrganizationAccessDeniedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrganizationConformancePackStatusesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOrganizationConformancePackStatusesOutputResponse(nextToken: \(String(describing: nextToken)), organizationConformancePackStatuses: \(String(describing: organizationConformancePackStatuses)))"}
}

extension DescribeOrganizationConformancePackStatusesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeOrganizationConformancePackStatusesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.organizationConformancePackStatuses = output.organizationConformancePackStatuses
        } else {
            self.nextToken = nil
            self.organizationConformancePackStatuses = nil
        }
    }
}

public struct DescribeOrganizationConformancePackStatusesOutputResponse: Equatable {
    /// <p>The nextToken string returned on a previous page that you use to get the next page of results in a paginated response. </p>
    public let nextToken: String?
    /// <p>A list of <code>OrganizationConformancePackStatus</code> objects. </p>
    public let organizationConformancePackStatuses: [OrganizationConformancePackStatus]?

    public init (
        nextToken: String? = nil,
        organizationConformancePackStatuses: [OrganizationConformancePackStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationConformancePackStatuses = organizationConformancePackStatuses
    }
}

struct DescribeOrganizationConformancePackStatusesOutputResponseBody: Equatable {
    public let organizationConformancePackStatuses: [OrganizationConformancePackStatus]?
    public let nextToken: String?
}

extension DescribeOrganizationConformancePackStatusesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case organizationConformancePackStatuses = "OrganizationConformancePackStatuses"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConformancePackStatusesContainer = try containerValues.decodeIfPresent([OrganizationConformancePackStatus?].self, forKey: .organizationConformancePackStatuses)
        var organizationConformancePackStatusesDecoded0:[OrganizationConformancePackStatus]? = nil
        if let organizationConformancePackStatusesContainer = organizationConformancePackStatusesContainer {
            organizationConformancePackStatusesDecoded0 = [OrganizationConformancePackStatus]()
            for structure0 in organizationConformancePackStatusesContainer {
                if let structure0 = structure0 {
                    organizationConformancePackStatusesDecoded0?.append(structure0)
                }
            }
        }
        organizationConformancePackStatuses = organizationConformancePackStatusesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeOrganizationConformancePacksInputBodyMiddleware: Middleware {
    public let id: String = "DescribeOrganizationConformancePacksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrganizationConformancePacksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrganizationConformancePacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrganizationConformancePacksInput>
    public typealias MOutput = OperationOutput<DescribeOrganizationConformancePacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrganizationConformancePacksOutputError>
}

extension DescribeOrganizationConformancePacksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOrganizationConformancePacksInput(limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), organizationConformancePackNames: \(String(describing: organizationConformancePackNames)))"}
}

extension DescribeOrganizationConformancePacksInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case organizationConformancePackNames = "OrganizationConformancePackNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationConformancePackNames = organizationConformancePackNames {
            var organizationConformancePackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationConformancePackNames)
            for organizationconformancepacknames0 in organizationConformancePackNames {
                try organizationConformancePackNamesContainer.encode(organizationconformancepacknames0)
            }
        }
    }
}

public struct DescribeOrganizationConformancePacksInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeOrganizationConformancePacksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrganizationConformancePacksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrganizationConformancePacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrganizationConformancePacksInput>
    public typealias MOutput = OperationOutput<DescribeOrganizationConformancePacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrganizationConformancePacksOutputError>
}

public struct DescribeOrganizationConformancePacksInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeOrganizationConformancePacksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrganizationConformancePacksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrganizationConformancePacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrganizationConformancePacksInput>
    public typealias MOutput = OperationOutput<DescribeOrganizationConformancePacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrganizationConformancePacksOutputError>
}

public struct DescribeOrganizationConformancePacksInput: Equatable {
    /// <p>The maximum number of organization config packs returned on each page. If you do no specify a
    /// 			number, AWS Config uses the default. The default is 100.</p>
    public let limit: Int
    /// <p>The nextToken string returned on a previous page that you use to get the next page of results in a
    /// 			paginated response.</p>
    public let nextToken: String?
    /// <p>The name that you assign to an organization conformance pack.</p>
    public let organizationConformancePackNames: [String]?

    public init (
        limit: Int = 0,
        nextToken: String? = nil,
        organizationConformancePackNames: [String]? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.organizationConformancePackNames = organizationConformancePackNames
    }
}

struct DescribeOrganizationConformancePacksInputBody: Equatable {
    public let organizationConformancePackNames: [String]?
    public let limit: Int
    public let nextToken: String?
}

extension DescribeOrganizationConformancePacksInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case organizationConformancePackNames = "OrganizationConformancePackNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConformancePackNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .organizationConformancePackNames)
        var organizationConformancePackNamesDecoded0:[String]? = nil
        if let organizationConformancePackNamesContainer = organizationConformancePackNamesContainer {
            organizationConformancePackNamesDecoded0 = [String]()
            for string0 in organizationConformancePackNamesContainer {
                if let string0 = string0 {
                    organizationConformancePackNamesDecoded0?.append(string0)
                }
            }
        }
        organizationConformancePackNames = organizationConformancePackNamesDecoded0
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeOrganizationConformancePacksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOrganizationConformancePacksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOrganizationConformancePackException" : self = .noSuchOrganizationConformancePackException(try NoSuchOrganizationConformancePackException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAccessDeniedException" : self = .organizationAccessDeniedException(try OrganizationAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOrganizationConformancePacksOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchOrganizationConformancePackException(NoSuchOrganizationConformancePackException)
    case organizationAccessDeniedException(OrganizationAccessDeniedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrganizationConformancePacksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOrganizationConformancePacksOutputResponse(nextToken: \(String(describing: nextToken)), organizationConformancePacks: \(String(describing: organizationConformancePacks)))"}
}

extension DescribeOrganizationConformancePacksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeOrganizationConformancePacksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.organizationConformancePacks = output.organizationConformancePacks
        } else {
            self.nextToken = nil
            self.organizationConformancePacks = nil
        }
    }
}

public struct DescribeOrganizationConformancePacksOutputResponse: Equatable {
    /// <p>The nextToken string returned on a previous page that you use to get the next page of results in a
    /// 			paginated response.</p>
    public let nextToken: String?
    /// <p>Returns a list of OrganizationConformancePacks objects.</p>
    public let organizationConformancePacks: [OrganizationConformancePack]?

    public init (
        nextToken: String? = nil,
        organizationConformancePacks: [OrganizationConformancePack]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationConformancePacks = organizationConformancePacks
    }
}

struct DescribeOrganizationConformancePacksOutputResponseBody: Equatable {
    public let organizationConformancePacks: [OrganizationConformancePack]?
    public let nextToken: String?
}

extension DescribeOrganizationConformancePacksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case organizationConformancePacks = "OrganizationConformancePacks"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConformancePacksContainer = try containerValues.decodeIfPresent([OrganizationConformancePack?].self, forKey: .organizationConformancePacks)
        var organizationConformancePacksDecoded0:[OrganizationConformancePack]? = nil
        if let organizationConformancePacksContainer = organizationConformancePacksContainer {
            organizationConformancePacksDecoded0 = [OrganizationConformancePack]()
            for structure0 in organizationConformancePacksContainer {
                if let structure0 = structure0 {
                    organizationConformancePacksDecoded0?.append(structure0)
                }
            }
        }
        organizationConformancePacks = organizationConformancePacksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribePendingAggregationRequestsInputBodyMiddleware: Middleware {
    public let id: String = "DescribePendingAggregationRequestsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePendingAggregationRequestsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePendingAggregationRequestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePendingAggregationRequestsInput>
    public typealias MOutput = OperationOutput<DescribePendingAggregationRequestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePendingAggregationRequestsOutputError>
}

extension DescribePendingAggregationRequestsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePendingAggregationRequestsInput(limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribePendingAggregationRequestsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribePendingAggregationRequestsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePendingAggregationRequestsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePendingAggregationRequestsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePendingAggregationRequestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePendingAggregationRequestsInput>
    public typealias MOutput = OperationOutput<DescribePendingAggregationRequestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePendingAggregationRequestsOutputError>
}

public struct DescribePendingAggregationRequestsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePendingAggregationRequestsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePendingAggregationRequestsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePendingAggregationRequestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePendingAggregationRequestsInput>
    public typealias MOutput = OperationOutput<DescribePendingAggregationRequestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePendingAggregationRequestsOutputError>
}

public struct DescribePendingAggregationRequestsInput: Equatable {
    /// <p>The maximum number of evaluation results returned on each page.
    /// 			The default is maximum. If you specify 0, AWS Config uses the
    /// 			default.</p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned on a previous page that you use
    /// 			to get the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        limit: Int = 0,
        nextToken: String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribePendingAggregationRequestsInputBody: Equatable {
    public let limit: Int
    public let nextToken: String?
}

extension DescribePendingAggregationRequestsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribePendingAggregationRequestsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePendingAggregationRequestsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePendingAggregationRequestsOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePendingAggregationRequestsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePendingAggregationRequestsOutputResponse(nextToken: \(String(describing: nextToken)), pendingAggregationRequests: \(String(describing: pendingAggregationRequests)))"}
}

extension DescribePendingAggregationRequestsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePendingAggregationRequestsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.pendingAggregationRequests = output.pendingAggregationRequests
        } else {
            self.nextToken = nil
            self.pendingAggregationRequests = nil
        }
    }
}

public struct DescribePendingAggregationRequestsOutputResponse: Equatable {
    /// <p>The <code>nextToken</code> string returned on a previous page that you use
    /// 			to get the next page of results in a paginated response.</p>
    public let nextToken: String?
    /// <p>Returns a PendingAggregationRequests object.</p>
    public let pendingAggregationRequests: [PendingAggregationRequest]?

    public init (
        nextToken: String? = nil,
        pendingAggregationRequests: [PendingAggregationRequest]? = nil
    )
    {
        self.nextToken = nextToken
        self.pendingAggregationRequests = pendingAggregationRequests
    }
}

struct DescribePendingAggregationRequestsOutputResponseBody: Equatable {
    public let pendingAggregationRequests: [PendingAggregationRequest]?
    public let nextToken: String?
}

extension DescribePendingAggregationRequestsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case pendingAggregationRequests = "PendingAggregationRequests"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pendingAggregationRequestsContainer = try containerValues.decodeIfPresent([PendingAggregationRequest?].self, forKey: .pendingAggregationRequests)
        var pendingAggregationRequestsDecoded0:[PendingAggregationRequest]? = nil
        if let pendingAggregationRequestsContainer = pendingAggregationRequestsContainer {
            pendingAggregationRequestsDecoded0 = [PendingAggregationRequest]()
            for structure0 in pendingAggregationRequestsContainer {
                if let structure0 = structure0 {
                    pendingAggregationRequestsDecoded0?.append(structure0)
                }
            }
        }
        pendingAggregationRequests = pendingAggregationRequestsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeRemediationConfigurationsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeRemediationConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRemediationConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRemediationConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRemediationConfigurationsInput>
    public typealias MOutput = OperationOutput<DescribeRemediationConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRemediationConfigurationsOutputError>
}

extension DescribeRemediationConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRemediationConfigurationsInput(configRuleNames: \(String(describing: configRuleNames)))"}
}

extension DescribeRemediationConfigurationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configRuleNames = "ConfigRuleNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleNames = configRuleNames {
            var configRuleNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configRuleNames)
            for configrulenames0 in configRuleNames {
                try configRuleNamesContainer.encode(configrulenames0)
            }
        }
    }
}

public struct DescribeRemediationConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRemediationConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRemediationConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRemediationConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRemediationConfigurationsInput>
    public typealias MOutput = OperationOutput<DescribeRemediationConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRemediationConfigurationsOutputError>
}

public struct DescribeRemediationConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRemediationConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRemediationConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRemediationConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRemediationConfigurationsInput>
    public typealias MOutput = OperationOutput<DescribeRemediationConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRemediationConfigurationsOutputError>
}

public struct DescribeRemediationConfigurationsInput: Equatable {
    /// <p>A list of AWS Config rule names of remediation configurations for which you want details. </p>
    public let configRuleNames: [String]?

    public init (
        configRuleNames: [String]? = nil
    )
    {
        self.configRuleNames = configRuleNames
    }
}

struct DescribeRemediationConfigurationsInputBody: Equatable {
    public let configRuleNames: [String]?
}

extension DescribeRemediationConfigurationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configRuleNames = "ConfigRuleNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .configRuleNames)
        var configRuleNamesDecoded0:[String]? = nil
        if let configRuleNamesContainer = configRuleNamesContainer {
            configRuleNamesDecoded0 = [String]()
            for string0 in configRuleNamesContainer {
                if let string0 = string0 {
                    configRuleNamesDecoded0?.append(string0)
                }
            }
        }
        configRuleNames = configRuleNamesDecoded0
    }
}

extension DescribeRemediationConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRemediationConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRemediationConfigurationsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRemediationConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRemediationConfigurationsOutputResponse(remediationConfigurations: \(String(describing: remediationConfigurations)))"}
}

extension DescribeRemediationConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRemediationConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.remediationConfigurations = output.remediationConfigurations
        } else {
            self.remediationConfigurations = nil
        }
    }
}

public struct DescribeRemediationConfigurationsOutputResponse: Equatable {
    /// <p>Returns a remediation configuration object.</p>
    public let remediationConfigurations: [RemediationConfiguration]?

    public init (
        remediationConfigurations: [RemediationConfiguration]? = nil
    )
    {
        self.remediationConfigurations = remediationConfigurations
    }
}

struct DescribeRemediationConfigurationsOutputResponseBody: Equatable {
    public let remediationConfigurations: [RemediationConfiguration]?
}

extension DescribeRemediationConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case remediationConfigurations = "RemediationConfigurations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remediationConfigurationsContainer = try containerValues.decodeIfPresent([RemediationConfiguration?].self, forKey: .remediationConfigurations)
        var remediationConfigurationsDecoded0:[RemediationConfiguration]? = nil
        if let remediationConfigurationsContainer = remediationConfigurationsContainer {
            remediationConfigurationsDecoded0 = [RemediationConfiguration]()
            for structure0 in remediationConfigurationsContainer {
                if let structure0 = structure0 {
                    remediationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        remediationConfigurations = remediationConfigurationsDecoded0
    }
}

public struct DescribeRemediationExceptionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeRemediationExceptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRemediationExceptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRemediationExceptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRemediationExceptionsInput>
    public typealias MOutput = OperationOutput<DescribeRemediationExceptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRemediationExceptionsOutputError>
}

extension DescribeRemediationExceptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRemediationExceptionsInput(configRuleName: \(String(describing: configRuleName)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), resourceKeys: \(String(describing: resourceKeys)))"}
}

extension DescribeRemediationExceptionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configRuleName = "ConfigRuleName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceKeys = "ResourceKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleName = configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceKeys = resourceKeys {
            var resourceKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceKeys)
            for remediationexceptionresourcekeys0 in resourceKeys {
                try resourceKeysContainer.encode(remediationexceptionresourcekeys0)
            }
        }
    }
}

public struct DescribeRemediationExceptionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRemediationExceptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRemediationExceptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRemediationExceptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRemediationExceptionsInput>
    public typealias MOutput = OperationOutput<DescribeRemediationExceptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRemediationExceptionsOutputError>
}

public struct DescribeRemediationExceptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRemediationExceptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRemediationExceptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRemediationExceptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRemediationExceptionsInput>
    public typealias MOutput = OperationOutput<DescribeRemediationExceptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRemediationExceptionsOutputError>
}

public struct DescribeRemediationExceptionsInput: Equatable {
    /// <p>The name of the AWS Config rule.</p>
    public let configRuleName: String?
    /// <p>The maximum number of RemediationExceptionResourceKey returned on each page. The default is 25. If you specify 0, AWS Config uses the default.</p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned in a previous request that you use to request the next page of results in a paginated response.</p>
    public let nextToken: String?
    /// <p>An exception list of resource exception keys to be processed with the current request. AWS Config adds exception for each resource key. For example, AWS Config adds 3 exceptions for 3 resource keys. </p>
    public let resourceKeys: [RemediationExceptionResourceKey]?

    public init (
        configRuleName: String? = nil,
        limit: Int = 0,
        nextToken: String? = nil,
        resourceKeys: [RemediationExceptionResourceKey]? = nil
    )
    {
        self.configRuleName = configRuleName
        self.limit = limit
        self.nextToken = nextToken
        self.resourceKeys = resourceKeys
    }
}

struct DescribeRemediationExceptionsInputBody: Equatable {
    public let configRuleName: String?
    public let resourceKeys: [RemediationExceptionResourceKey]?
    public let limit: Int
    public let nextToken: String?
}

extension DescribeRemediationExceptionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configRuleName = "ConfigRuleName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceKeys = "ResourceKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let resourceKeysContainer = try containerValues.decodeIfPresent([RemediationExceptionResourceKey?].self, forKey: .resourceKeys)
        var resourceKeysDecoded0:[RemediationExceptionResourceKey]? = nil
        if let resourceKeysContainer = resourceKeysContainer {
            resourceKeysDecoded0 = [RemediationExceptionResourceKey]()
            for structure0 in resourceKeysContainer {
                if let structure0 = structure0 {
                    resourceKeysDecoded0?.append(structure0)
                }
            }
        }
        resourceKeys = resourceKeysDecoded0
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeRemediationExceptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRemediationExceptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRemediationExceptionsOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRemediationExceptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRemediationExceptionsOutputResponse(nextToken: \(String(describing: nextToken)), remediationExceptions: \(String(describing: remediationExceptions)))"}
}

extension DescribeRemediationExceptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRemediationExceptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.remediationExceptions = output.remediationExceptions
        } else {
            self.nextToken = nil
            self.remediationExceptions = nil
        }
    }
}

public struct DescribeRemediationExceptionsOutputResponse: Equatable {
    /// <p>The <code>nextToken</code> string returned in a previous request that you use to request the next page of results in a paginated response.</p>
    public let nextToken: String?
    /// <p>Returns a list of remediation exception objects.</p>
    public let remediationExceptions: [RemediationException]?

    public init (
        nextToken: String? = nil,
        remediationExceptions: [RemediationException]? = nil
    )
    {
        self.nextToken = nextToken
        self.remediationExceptions = remediationExceptions
    }
}

struct DescribeRemediationExceptionsOutputResponseBody: Equatable {
    public let remediationExceptions: [RemediationException]?
    public let nextToken: String?
}

extension DescribeRemediationExceptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case remediationExceptions = "RemediationExceptions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remediationExceptionsContainer = try containerValues.decodeIfPresent([RemediationException?].self, forKey: .remediationExceptions)
        var remediationExceptionsDecoded0:[RemediationException]? = nil
        if let remediationExceptionsContainer = remediationExceptionsContainer {
            remediationExceptionsDecoded0 = [RemediationException]()
            for structure0 in remediationExceptionsContainer {
                if let structure0 = structure0 {
                    remediationExceptionsDecoded0?.append(structure0)
                }
            }
        }
        remediationExceptions = remediationExceptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeRemediationExecutionStatusInputBodyMiddleware: Middleware {
    public let id: String = "DescribeRemediationExecutionStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRemediationExecutionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRemediationExecutionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRemediationExecutionStatusInput>
    public typealias MOutput = OperationOutput<DescribeRemediationExecutionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRemediationExecutionStatusOutputError>
}

extension DescribeRemediationExecutionStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRemediationExecutionStatusInput(configRuleName: \(String(describing: configRuleName)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), resourceKeys: \(String(describing: resourceKeys)))"}
}

extension DescribeRemediationExecutionStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configRuleName = "ConfigRuleName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceKeys = "ResourceKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleName = configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceKeys = resourceKeys {
            var resourceKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceKeys)
            for resourcekeys0 in resourceKeys {
                try resourceKeysContainer.encode(resourcekeys0)
            }
        }
    }
}

public struct DescribeRemediationExecutionStatusInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRemediationExecutionStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRemediationExecutionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRemediationExecutionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRemediationExecutionStatusInput>
    public typealias MOutput = OperationOutput<DescribeRemediationExecutionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRemediationExecutionStatusOutputError>
}

public struct DescribeRemediationExecutionStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRemediationExecutionStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRemediationExecutionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRemediationExecutionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRemediationExecutionStatusInput>
    public typealias MOutput = OperationOutput<DescribeRemediationExecutionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRemediationExecutionStatusOutputError>
}

public struct DescribeRemediationExecutionStatusInput: Equatable {
    /// <p>A list of AWS Config rule names.</p>
    public let configRuleName: String?
    /// <p>The maximum number of RemediationExecutionStatuses returned on each page. The default is maximum. If you specify 0, AWS Config uses the default. </p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned on a previous page that you use to get the next page of results in a paginated response.</p>
    public let nextToken: String?
    /// <p>A list of resource keys to be processed with the current request. Each element in the list consists of the resource type and resource ID. </p>
    public let resourceKeys: [ResourceKey]?

    public init (
        configRuleName: String? = nil,
        limit: Int = 0,
        nextToken: String? = nil,
        resourceKeys: [ResourceKey]? = nil
    )
    {
        self.configRuleName = configRuleName
        self.limit = limit
        self.nextToken = nextToken
        self.resourceKeys = resourceKeys
    }
}

struct DescribeRemediationExecutionStatusInputBody: Equatable {
    public let configRuleName: String?
    public let resourceKeys: [ResourceKey]?
    public let limit: Int
    public let nextToken: String?
}

extension DescribeRemediationExecutionStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configRuleName = "ConfigRuleName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceKeys = "ResourceKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let resourceKeysContainer = try containerValues.decodeIfPresent([ResourceKey?].self, forKey: .resourceKeys)
        var resourceKeysDecoded0:[ResourceKey]? = nil
        if let resourceKeysContainer = resourceKeysContainer {
            resourceKeysDecoded0 = [ResourceKey]()
            for structure0 in resourceKeysContainer {
                if let structure0 = structure0 {
                    resourceKeysDecoded0?.append(structure0)
                }
            }
        }
        resourceKeys = resourceKeysDecoded0
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeRemediationExecutionStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRemediationExecutionStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRemediationConfigurationException" : self = .noSuchRemediationConfigurationException(try NoSuchRemediationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRemediationExecutionStatusOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchRemediationConfigurationException(NoSuchRemediationConfigurationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRemediationExecutionStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRemediationExecutionStatusOutputResponse(nextToken: \(String(describing: nextToken)), remediationExecutionStatuses: \(String(describing: remediationExecutionStatuses)))"}
}

extension DescribeRemediationExecutionStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRemediationExecutionStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.remediationExecutionStatuses = output.remediationExecutionStatuses
        } else {
            self.nextToken = nil
            self.remediationExecutionStatuses = nil
        }
    }
}

public struct DescribeRemediationExecutionStatusOutputResponse: Equatable {
    /// <p>The <code>nextToken</code> string returned on a previous page that you use to get the next page of results in a paginated response.</p>
    public let nextToken: String?
    /// <p>Returns a list of remediation execution statuses objects.</p>
    public let remediationExecutionStatuses: [RemediationExecutionStatus]?

    public init (
        nextToken: String? = nil,
        remediationExecutionStatuses: [RemediationExecutionStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.remediationExecutionStatuses = remediationExecutionStatuses
    }
}

struct DescribeRemediationExecutionStatusOutputResponseBody: Equatable {
    public let remediationExecutionStatuses: [RemediationExecutionStatus]?
    public let nextToken: String?
}

extension DescribeRemediationExecutionStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case remediationExecutionStatuses = "RemediationExecutionStatuses"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remediationExecutionStatusesContainer = try containerValues.decodeIfPresent([RemediationExecutionStatus?].self, forKey: .remediationExecutionStatuses)
        var remediationExecutionStatusesDecoded0:[RemediationExecutionStatus]? = nil
        if let remediationExecutionStatusesContainer = remediationExecutionStatusesContainer {
            remediationExecutionStatusesDecoded0 = [RemediationExecutionStatus]()
            for structure0 in remediationExecutionStatusesContainer {
                if let structure0 = structure0 {
                    remediationExecutionStatusesDecoded0?.append(structure0)
                }
            }
        }
        remediationExecutionStatuses = remediationExecutionStatusesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeRetentionConfigurationsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeRetentionConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRetentionConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRetentionConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRetentionConfigurationsInput>
    public typealias MOutput = OperationOutput<DescribeRetentionConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRetentionConfigurationsOutputError>
}

extension DescribeRetentionConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRetentionConfigurationsInput(nextToken: \(String(describing: nextToken)), retentionConfigurationNames: \(String(describing: retentionConfigurationNames)))"}
}

extension DescribeRetentionConfigurationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case retentionConfigurationNames = "RetentionConfigurationNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let retentionConfigurationNames = retentionConfigurationNames {
            var retentionConfigurationNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .retentionConfigurationNames)
            for retentionconfigurationnamelist0 in retentionConfigurationNames {
                try retentionConfigurationNamesContainer.encode(retentionconfigurationnamelist0)
            }
        }
    }
}

public struct DescribeRetentionConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRetentionConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRetentionConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRetentionConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRetentionConfigurationsInput>
    public typealias MOutput = OperationOutput<DescribeRetentionConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRetentionConfigurationsOutputError>
}

public struct DescribeRetentionConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRetentionConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRetentionConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRetentionConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRetentionConfigurationsInput>
    public typealias MOutput = OperationOutput<DescribeRetentionConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRetentionConfigurationsOutputError>
}

public struct DescribeRetentionConfigurationsInput: Equatable {
    /// <p>The <code>nextToken</code> string returned on a previous page
    /// 			that you use to get the next page of results in a paginated
    /// 			response. </p>
    public let nextToken: String?
    /// <p>A list of names of retention configurations for which you want
    /// 			details. If you do not specify a name, AWS Config returns details
    /// 			for all the retention configurations for that account.</p>
    /// 		       <note>
    /// 			         <p>Currently, AWS Config supports only one retention
    /// 				configuration per region in your account.</p>
    /// 		       </note>
    public let retentionConfigurationNames: [String]?

    public init (
        nextToken: String? = nil,
        retentionConfigurationNames: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.retentionConfigurationNames = retentionConfigurationNames
    }
}

struct DescribeRetentionConfigurationsInputBody: Equatable {
    public let retentionConfigurationNames: [String]?
    public let nextToken: String?
}

extension DescribeRetentionConfigurationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case retentionConfigurationNames = "RetentionConfigurationNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionConfigurationNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .retentionConfigurationNames)
        var retentionConfigurationNamesDecoded0:[String]? = nil
        if let retentionConfigurationNamesContainer = retentionConfigurationNamesContainer {
            retentionConfigurationNamesDecoded0 = [String]()
            for string0 in retentionConfigurationNamesContainer {
                if let string0 = string0 {
                    retentionConfigurationNamesDecoded0?.append(string0)
                }
            }
        }
        retentionConfigurationNames = retentionConfigurationNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeRetentionConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRetentionConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRetentionConfigurationException" : self = .noSuchRetentionConfigurationException(try NoSuchRetentionConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRetentionConfigurationsOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchRetentionConfigurationException(NoSuchRetentionConfigurationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRetentionConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRetentionConfigurationsOutputResponse(nextToken: \(String(describing: nextToken)), retentionConfigurations: \(String(describing: retentionConfigurations)))"}
}

extension DescribeRetentionConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRetentionConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.retentionConfigurations = output.retentionConfigurations
        } else {
            self.nextToken = nil
            self.retentionConfigurations = nil
        }
    }
}

public struct DescribeRetentionConfigurationsOutputResponse: Equatable {
    /// <p>The <code>nextToken</code> string returned on a previous page
    /// 			that you use to get the next page of results in a paginated
    /// 			response. </p>
    public let nextToken: String?
    /// <p>Returns a retention configuration object.</p>
    public let retentionConfigurations: [RetentionConfiguration]?

    public init (
        nextToken: String? = nil,
        retentionConfigurations: [RetentionConfiguration]? = nil
    )
    {
        self.nextToken = nextToken
        self.retentionConfigurations = retentionConfigurations
    }
}

struct DescribeRetentionConfigurationsOutputResponseBody: Equatable {
    public let retentionConfigurations: [RetentionConfiguration]?
    public let nextToken: String?
}

extension DescribeRetentionConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case retentionConfigurations = "RetentionConfigurations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionConfigurationsContainer = try containerValues.decodeIfPresent([RetentionConfiguration?].self, forKey: .retentionConfigurations)
        var retentionConfigurationsDecoded0:[RetentionConfiguration]? = nil
        if let retentionConfigurationsContainer = retentionConfigurationsContainer {
            retentionConfigurationsDecoded0 = [RetentionConfiguration]()
            for structure0 in retentionConfigurationsContainer {
                if let structure0 = structure0 {
                    retentionConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        retentionConfigurations = retentionConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension Evaluation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case annotation = "Annotation"
        case complianceResourceId = "ComplianceResourceId"
        case complianceResourceType = "ComplianceResourceType"
        case complianceType = "ComplianceType"
        case orderingTimestamp = "OrderingTimestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let annotation = annotation {
            try encodeContainer.encode(annotation, forKey: .annotation)
        }
        if let complianceResourceId = complianceResourceId {
            try encodeContainer.encode(complianceResourceId, forKey: .complianceResourceId)
        }
        if let complianceResourceType = complianceResourceType {
            try encodeContainer.encode(complianceResourceType, forKey: .complianceResourceType)
        }
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
        if let orderingTimestamp = orderingTimestamp {
            try encodeContainer.encode(orderingTimestamp.timeIntervalSince1970, forKey: .orderingTimestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceResourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .complianceResourceType)
        complianceResourceType = complianceResourceTypeDecoded
        let complianceResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .complianceResourceId)
        complianceResourceId = complianceResourceIdDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let annotationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .annotation)
        annotation = annotationDecoded
        let orderingTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .orderingTimestamp)
        orderingTimestamp = orderingTimestampDecoded
    }
}

extension Evaluation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Evaluation(annotation: \(String(describing: annotation)), complianceResourceId: \(String(describing: complianceResourceId)), complianceResourceType: \(String(describing: complianceResourceType)), complianceType: \(String(describing: complianceType)), orderingTimestamp: \(String(describing: orderingTimestamp)))"}
}

/// <p>Identifies an AWS resource and indicates whether it complies
/// 			with the AWS Config rule that it was evaluated against.</p>
public struct Evaluation: Equatable {
    /// <p>Supplementary information about how the evaluation determined
    /// 			the compliance.</p>
    public let annotation: String?
    /// <p>The ID of the AWS resource that was evaluated.</p>
    public let complianceResourceId: String?
    /// <p>The type of AWS resource that was evaluated.</p>
    public let complianceResourceType: String?
    /// <p>Indicates whether the AWS resource complies with the AWS Config
    /// 			rule that it was evaluated against.</p>
    /// 		       <p>For the <code>Evaluation</code> data type, AWS Config supports
    /// 			only the <code>COMPLIANT</code>, <code>NON_COMPLIANT</code>, and
    /// 				<code>NOT_APPLICABLE</code> values. AWS Config does not support
    /// 			the <code>INSUFFICIENT_DATA</code> value for this data
    /// 			type.</p>
    /// 		       <p>Similarly, AWS Config does not accept
    /// 				<code>INSUFFICIENT_DATA</code> as the value for
    /// 				<code>ComplianceType</code> from a <code>PutEvaluations</code>
    /// 			request. For example, an AWS Lambda function for a custom AWS Config
    /// 			rule cannot pass an <code>INSUFFICIENT_DATA</code> value to AWS
    /// 			Config.</p>
    public let complianceType: ComplianceType?
    /// <p>The time of the event in AWS Config that triggered the
    /// 			evaluation. For event-based evaluations, the time indicates when AWS
    /// 			Config created the configuration item that triggered the evaluation.
    /// 			For periodic evaluations, the time indicates when AWS Config
    /// 			triggered the evaluation at the frequency that you specified (for
    /// 			example, every 24 hours).</p>
    public let orderingTimestamp: Date?

    public init (
        annotation: String? = nil,
        complianceResourceId: String? = nil,
        complianceResourceType: String? = nil,
        complianceType: ComplianceType? = nil,
        orderingTimestamp: Date? = nil
    )
    {
        self.annotation = annotation
        self.complianceResourceId = complianceResourceId
        self.complianceResourceType = complianceResourceType
        self.complianceType = complianceType
        self.orderingTimestamp = orderingTimestamp
    }
}

extension EvaluationResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case annotation = "Annotation"
        case complianceType = "ComplianceType"
        case configRuleInvokedTime = "ConfigRuleInvokedTime"
        case evaluationResultIdentifier = "EvaluationResultIdentifier"
        case resultRecordedTime = "ResultRecordedTime"
        case resultToken = "ResultToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let annotation = annotation {
            try encodeContainer.encode(annotation, forKey: .annotation)
        }
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
        if let configRuleInvokedTime = configRuleInvokedTime {
            try encodeContainer.encode(configRuleInvokedTime.timeIntervalSince1970, forKey: .configRuleInvokedTime)
        }
        if let evaluationResultIdentifier = evaluationResultIdentifier {
            try encodeContainer.encode(evaluationResultIdentifier, forKey: .evaluationResultIdentifier)
        }
        if let resultRecordedTime = resultRecordedTime {
            try encodeContainer.encode(resultRecordedTime.timeIntervalSince1970, forKey: .resultRecordedTime)
        }
        if let resultToken = resultToken {
            try encodeContainer.encode(resultToken, forKey: .resultToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationResultIdentifierDecoded = try containerValues.decodeIfPresent(EvaluationResultIdentifier.self, forKey: .evaluationResultIdentifier)
        evaluationResultIdentifier = evaluationResultIdentifierDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let resultRecordedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .resultRecordedTime)
        resultRecordedTime = resultRecordedTimeDecoded
        let configRuleInvokedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .configRuleInvokedTime)
        configRuleInvokedTime = configRuleInvokedTimeDecoded
        let annotationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .annotation)
        annotation = annotationDecoded
        let resultTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resultToken)
        resultToken = resultTokenDecoded
    }
}

extension EvaluationResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EvaluationResult(annotation: \(String(describing: annotation)), complianceType: \(String(describing: complianceType)), configRuleInvokedTime: \(String(describing: configRuleInvokedTime)), evaluationResultIdentifier: \(String(describing: evaluationResultIdentifier)), resultRecordedTime: \(String(describing: resultRecordedTime)), resultToken: \(String(describing: resultToken)))"}
}

/// <p>The details of an AWS Config evaluation. Provides the AWS
/// 			resource that was evaluated, the compliance of the resource, related
/// 			time stamps, and supplementary information.</p>
public struct EvaluationResult: Equatable {
    /// <p>Supplementary information about how the evaluation determined
    /// 			the compliance.</p>
    public let annotation: String?
    /// <p>Indicates whether the AWS resource complies with the AWS Config
    /// 			rule that evaluated it.</p>
    /// 		       <p>For the <code>EvaluationResult</code> data type, AWS Config
    /// 			supports only the <code>COMPLIANT</code>,
    /// 			<code>NON_COMPLIANT</code>, and <code>NOT_APPLICABLE</code> values.
    /// 			AWS Config does not support the <code>INSUFFICIENT_DATA</code> value
    /// 			for the <code>EvaluationResult</code> data type.</p>
    public let complianceType: ComplianceType?
    /// <p>The time when the AWS Config rule evaluated the AWS
    /// 			resource.</p>
    public let configRuleInvokedTime: Date?
    /// <p>Uniquely identifies the evaluation result.</p>
    public let evaluationResultIdentifier: EvaluationResultIdentifier?
    /// <p>The time when AWS Config recorded the evaluation
    /// 			result.</p>
    public let resultRecordedTime: Date?
    /// <p>An encrypted token that associates an evaluation with an AWS
    /// 			Config rule. The token identifies the rule, the AWS resource being
    /// 			evaluated, and the event that triggered the evaluation.</p>
    public let resultToken: String?

    public init (
        annotation: String? = nil,
        complianceType: ComplianceType? = nil,
        configRuleInvokedTime: Date? = nil,
        evaluationResultIdentifier: EvaluationResultIdentifier? = nil,
        resultRecordedTime: Date? = nil,
        resultToken: String? = nil
    )
    {
        self.annotation = annotation
        self.complianceType = complianceType
        self.configRuleInvokedTime = configRuleInvokedTime
        self.evaluationResultIdentifier = evaluationResultIdentifier
        self.resultRecordedTime = resultRecordedTime
        self.resultToken = resultToken
    }
}

extension EvaluationResultIdentifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case evaluationResultQualifier = "EvaluationResultQualifier"
        case orderingTimestamp = "OrderingTimestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationResultQualifier = evaluationResultQualifier {
            try encodeContainer.encode(evaluationResultQualifier, forKey: .evaluationResultQualifier)
        }
        if let orderingTimestamp = orderingTimestamp {
            try encodeContainer.encode(orderingTimestamp.timeIntervalSince1970, forKey: .orderingTimestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationResultQualifierDecoded = try containerValues.decodeIfPresent(EvaluationResultQualifier.self, forKey: .evaluationResultQualifier)
        evaluationResultQualifier = evaluationResultQualifierDecoded
        let orderingTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .orderingTimestamp)
        orderingTimestamp = orderingTimestampDecoded
    }
}

extension EvaluationResultIdentifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EvaluationResultIdentifier(evaluationResultQualifier: \(String(describing: evaluationResultQualifier)), orderingTimestamp: \(String(describing: orderingTimestamp)))"}
}

/// <p>Uniquely identifies an evaluation result.</p>
public struct EvaluationResultIdentifier: Equatable {
    /// <p>Identifies an AWS Config rule used to evaluate an AWS resource,
    /// 			and provides the type and ID of the evaluated resource.</p>
    public let evaluationResultQualifier: EvaluationResultQualifier?
    /// <p>The time of the event that triggered the evaluation of your AWS
    /// 			resources. The time can indicate when AWS Config delivered a
    /// 			configuration item change notification, or it can indicate when AWS
    /// 			Config delivered the configuration snapshot, depending on which
    /// 			event triggered the evaluation.</p>
    public let orderingTimestamp: Date?

    public init (
        evaluationResultQualifier: EvaluationResultQualifier? = nil,
        orderingTimestamp: Date? = nil
    )
    {
        self.evaluationResultQualifier = evaluationResultQualifier
        self.orderingTimestamp = orderingTimestamp
    }
}

extension EvaluationResultQualifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configRuleName = "ConfigRuleName"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleName = configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension EvaluationResultQualifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EvaluationResultQualifier(configRuleName: \(String(describing: configRuleName)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Identifies an AWS Config rule that evaluated an AWS resource,
/// 			and provides the type and ID of the resource that the rule
/// 			evaluated.</p>
public struct EvaluationResultQualifier: Equatable {
    /// <p>The name of the AWS Config rule that was used in the
    /// 			evaluation.</p>
    public let configRuleName: String?
    /// <p>The ID of the evaluated AWS resource.</p>
    public let resourceId: String?
    /// <p>The type of AWS resource that was evaluated.</p>
    public let resourceType: String?

    public init (
        configRuleName: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.configRuleName = configRuleName
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

public enum EventSource {
    case awsConfig
    case sdkUnknown(String)
}

extension EventSource : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventSource] {
        return [
            .awsConfig,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awsConfig: return "aws.config"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventSource(rawValue: rawValue) ?? EventSource.sdkUnknown(rawValue)
    }
}

extension ExecutionControls: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ssmControls = "SsmControls"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ssmControls = ssmControls {
            try encodeContainer.encode(ssmControls, forKey: .ssmControls)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ssmControlsDecoded = try containerValues.decodeIfPresent(SsmControls.self, forKey: .ssmControls)
        ssmControls = ssmControlsDecoded
    }
}

extension ExecutionControls: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecutionControls(ssmControls: \(String(describing: ssmControls)))"}
}

/// <p>The controls that AWS Config uses for executing remediations.</p>
public struct ExecutionControls: Equatable {
    /// <p>A SsmControls object.</p>
    public let ssmControls: SsmControls?

    public init (
        ssmControls: SsmControls? = nil
    )
    {
        self.ssmControls = ssmControls
    }
}

extension ExternalEvaluation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case annotation = "Annotation"
        case complianceResourceId = "ComplianceResourceId"
        case complianceResourceType = "ComplianceResourceType"
        case complianceType = "ComplianceType"
        case orderingTimestamp = "OrderingTimestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let annotation = annotation {
            try encodeContainer.encode(annotation, forKey: .annotation)
        }
        if let complianceResourceId = complianceResourceId {
            try encodeContainer.encode(complianceResourceId, forKey: .complianceResourceId)
        }
        if let complianceResourceType = complianceResourceType {
            try encodeContainer.encode(complianceResourceType, forKey: .complianceResourceType)
        }
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
        if let orderingTimestamp = orderingTimestamp {
            try encodeContainer.encode(orderingTimestamp.timeIntervalSince1970, forKey: .orderingTimestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceResourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .complianceResourceType)
        complianceResourceType = complianceResourceTypeDecoded
        let complianceResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .complianceResourceId)
        complianceResourceId = complianceResourceIdDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let annotationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .annotation)
        annotation = annotationDecoded
        let orderingTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .orderingTimestamp)
        orderingTimestamp = orderingTimestampDecoded
    }
}

extension ExternalEvaluation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExternalEvaluation(annotation: \(String(describing: annotation)), complianceResourceId: \(String(describing: complianceResourceId)), complianceResourceType: \(String(describing: complianceResourceType)), complianceType: \(String(describing: complianceType)), orderingTimestamp: \(String(describing: orderingTimestamp)))"}
}

/// <p>Identifies an AWS resource and indicates whether it complies with the AWS Config rule that it was evaluated against.</p>
public struct ExternalEvaluation: Equatable {
    /// <p>Supplementary information about the reason of compliance. For example, this task was completed on a specific date.</p>
    public let annotation: String?
    /// <p>The evaluated compliance resource ID. AWS Config accepts only AWS account ID.</p>
    public let complianceResourceId: String?
    /// <p>The evaluated compliance resource type. AWS Config accepts <code>AWS::::Account</code> resource type.</p>
    public let complianceResourceType: String?
    /// <p>The compliance of the AWS resource. The valid values are <code>COMPLIANT, NON_COMPLIANT, </code> and <code>NOT_APPLICABLE</code>.</p>
    public let complianceType: ComplianceType?
    /// <p>The time when the compliance was recorded. </p>
    public let orderingTimestamp: Date?

    public init (
        annotation: String? = nil,
        complianceResourceId: String? = nil,
        complianceResourceType: String? = nil,
        complianceType: ComplianceType? = nil,
        orderingTimestamp: Date? = nil
    )
    {
        self.annotation = annotation
        self.complianceResourceId = complianceResourceId
        self.complianceResourceType = complianceResourceType
        self.complianceType = complianceType
        self.orderingTimestamp = orderingTimestamp
    }
}

extension FailedDeleteRemediationExceptionsBatch: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failedItems = "FailedItems"
        case failureMessage = "FailureMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failedItems = failedItems {
            var failedItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .failedItems)
            for remediationexceptionresourcekeys0 in failedItems {
                try failedItemsContainer.encode(remediationexceptionresourcekeys0)
            }
        }
        if let failureMessage = failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let failedItemsContainer = try containerValues.decodeIfPresent([RemediationExceptionResourceKey?].self, forKey: .failedItems)
        var failedItemsDecoded0:[RemediationExceptionResourceKey]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [RemediationExceptionResourceKey]()
            for structure0 in failedItemsContainer {
                if let structure0 = structure0 {
                    failedItemsDecoded0?.append(structure0)
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

extension FailedDeleteRemediationExceptionsBatch: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailedDeleteRemediationExceptionsBatch(failedItems: \(String(describing: failedItems)), failureMessage: \(String(describing: failureMessage)))"}
}

/// <p>List of each of the failed delete remediation exceptions with specific reasons.</p>
public struct FailedDeleteRemediationExceptionsBatch: Equatable {
    /// <p>Returns remediation exception resource key object of the failed items.</p>
    public let failedItems: [RemediationExceptionResourceKey]?
    /// <p>Returns a failure message for delete remediation exception. For example, AWS Config creates an exception due to an internal error.</p>
    public let failureMessage: String?

    public init (
        failedItems: [RemediationExceptionResourceKey]? = nil,
        failureMessage: String? = nil
    )
    {
        self.failedItems = failedItems
        self.failureMessage = failureMessage
    }
}

extension FailedRemediationBatch: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failedItems = "FailedItems"
        case failureMessage = "FailureMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failedItems = failedItems {
            var failedItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .failedItems)
            for remediationconfigurations0 in failedItems {
                try failedItemsContainer.encode(remediationconfigurations0)
            }
        }
        if let failureMessage = failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let failedItemsContainer = try containerValues.decodeIfPresent([RemediationConfiguration?].self, forKey: .failedItems)
        var failedItemsDecoded0:[RemediationConfiguration]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [RemediationConfiguration]()
            for structure0 in failedItemsContainer {
                if let structure0 = structure0 {
                    failedItemsDecoded0?.append(structure0)
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

extension FailedRemediationBatch: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailedRemediationBatch(failedItems: \(String(describing: failedItems)), failureMessage: \(String(describing: failureMessage)))"}
}

/// <p>List of each of the failed remediations with specific reasons.</p>
public struct FailedRemediationBatch: Equatable {
    /// <p>Returns remediation configurations of the failed items.</p>
    public let failedItems: [RemediationConfiguration]?
    /// <p>Returns a failure message. For example, the resource is already compliant.</p>
    public let failureMessage: String?

    public init (
        failedItems: [RemediationConfiguration]? = nil,
        failureMessage: String? = nil
    )
    {
        self.failedItems = failedItems
        self.failureMessage = failureMessage
    }
}

extension FailedRemediationExceptionBatch: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failedItems = "FailedItems"
        case failureMessage = "FailureMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failedItems = failedItems {
            var failedItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .failedItems)
            for remediationexceptions0 in failedItems {
                try failedItemsContainer.encode(remediationexceptions0)
            }
        }
        if let failureMessage = failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let failedItemsContainer = try containerValues.decodeIfPresent([RemediationException?].self, forKey: .failedItems)
        var failedItemsDecoded0:[RemediationException]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [RemediationException]()
            for structure0 in failedItemsContainer {
                if let structure0 = structure0 {
                    failedItemsDecoded0?.append(structure0)
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

extension FailedRemediationExceptionBatch: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailedRemediationExceptionBatch(failedItems: \(String(describing: failedItems)), failureMessage: \(String(describing: failureMessage)))"}
}

/// <p>List of each of the failed remediation exceptions with specific reasons.</p>
public struct FailedRemediationExceptionBatch: Equatable {
    /// <p>Returns remediation exception resource key object of the failed items.</p>
    public let failedItems: [RemediationException]?
    /// <p>Returns a failure message. For example, the auto-remediation has failed.</p>
    public let failureMessage: String?

    public init (
        failedItems: [RemediationException]? = nil,
        failureMessage: String? = nil
    )
    {
        self.failedItems = failedItems
        self.failureMessage = failureMessage
    }
}

extension FieldInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension FieldInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FieldInfo(name: \(String(describing: name)))"}
}

/// <p>Details about the fields such as name of the field.</p>
public struct FieldInfo: Equatable {
    /// <p>Name of the field.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

public struct GetAggregateComplianceDetailsByConfigRuleInputBodyMiddleware: Middleware {
    public let id: String = "GetAggregateComplianceDetailsByConfigRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAggregateComplianceDetailsByConfigRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAggregateComplianceDetailsByConfigRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAggregateComplianceDetailsByConfigRuleInput>
    public typealias MOutput = OperationOutput<GetAggregateComplianceDetailsByConfigRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAggregateComplianceDetailsByConfigRuleOutputError>
}

extension GetAggregateComplianceDetailsByConfigRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAggregateComplianceDetailsByConfigRuleInput(accountId: \(String(describing: accountId)), awsRegion: \(String(describing: awsRegion)), complianceType: \(String(describing: complianceType)), configRuleName: \(String(describing: configRuleName)), configurationAggregatorName: \(String(describing: configurationAggregatorName)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension GetAggregateComplianceDetailsByConfigRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case awsRegion = "AwsRegion"
        case complianceType = "ComplianceType"
        case configRuleName = "ConfigRuleName"
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType.rawValue, forKey: .complianceType)
        }
        if let configRuleName = configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let configurationAggregatorName = configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetAggregateComplianceDetailsByConfigRuleInputHeadersMiddleware: Middleware {
    public let id: String = "GetAggregateComplianceDetailsByConfigRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAggregateComplianceDetailsByConfigRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAggregateComplianceDetailsByConfigRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAggregateComplianceDetailsByConfigRuleInput>
    public typealias MOutput = OperationOutput<GetAggregateComplianceDetailsByConfigRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAggregateComplianceDetailsByConfigRuleOutputError>
}

public struct GetAggregateComplianceDetailsByConfigRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAggregateComplianceDetailsByConfigRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAggregateComplianceDetailsByConfigRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAggregateComplianceDetailsByConfigRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAggregateComplianceDetailsByConfigRuleInput>
    public typealias MOutput = OperationOutput<GetAggregateComplianceDetailsByConfigRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAggregateComplianceDetailsByConfigRuleOutputError>
}

public struct GetAggregateComplianceDetailsByConfigRuleInput: Equatable {
    /// <p>The 12-digit account ID of the source account.</p>
    public let accountId: String?
    /// <p>The source region from where the data is aggregated.</p>
    public let awsRegion: String?
    /// <p>The resource compliance status.</p>
    /// 		       <note>
    /// 			         <p>For the
    /// 					<code>GetAggregateComplianceDetailsByConfigRuleRequest</code>
    /// 				data type, AWS Config supports only the <code>COMPLIANT</code>
    /// 				and <code>NON_COMPLIANT</code>. AWS Config does not support the
    /// 					<code>NOT_APPLICABLE</code> and
    /// 					<code>INSUFFICIENT_DATA</code> values.</p>
    /// 		       </note>
    public let complianceType: ComplianceType?
    /// <p>The name of the AWS Config rule for which you want compliance
    /// 			information.</p>
    public let configRuleName: String?
    /// <p>The name of the configuration aggregator.</p>
    public let configurationAggregatorName: String?
    /// <p>The maximum number of evaluation results returned on each page.
    /// 			The default is 50. You cannot specify a number greater than 100. If
    /// 			you specify 0, AWS Config uses the default.</p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned on a previous page that you use
    /// 			to get the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        accountId: String? = nil,
        awsRegion: String? = nil,
        complianceType: ComplianceType? = nil,
        configRuleName: String? = nil,
        configurationAggregatorName: String? = nil,
        limit: Int = 0,
        nextToken: String? = nil
    )
    {
        self.accountId = accountId
        self.awsRegion = awsRegion
        self.complianceType = complianceType
        self.configRuleName = configRuleName
        self.configurationAggregatorName = configurationAggregatorName
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct GetAggregateComplianceDetailsByConfigRuleInputBody: Equatable {
    public let configurationAggregatorName: String?
    public let configRuleName: String?
    public let accountId: String?
    public let awsRegion: String?
    public let complianceType: ComplianceType?
    public let limit: Int
    public let nextToken: String?
}

extension GetAggregateComplianceDetailsByConfigRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case awsRegion = "AwsRegion"
        case complianceType = "ComplianceType"
        case configRuleName = "ConfigRuleName"
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let configRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(ComplianceType.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetAggregateComplianceDetailsByConfigRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAggregateComplianceDetailsByConfigRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAggregateComplianceDetailsByConfigRuleOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAggregateComplianceDetailsByConfigRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAggregateComplianceDetailsByConfigRuleOutputResponse(aggregateEvaluationResults: \(String(describing: aggregateEvaluationResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetAggregateComplianceDetailsByConfigRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAggregateComplianceDetailsByConfigRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.aggregateEvaluationResults = output.aggregateEvaluationResults
            self.nextToken = output.nextToken
        } else {
            self.aggregateEvaluationResults = nil
            self.nextToken = nil
        }
    }
}

public struct GetAggregateComplianceDetailsByConfigRuleOutputResponse: Equatable {
    /// <p>Returns an AggregateEvaluationResults object.</p>
    public let aggregateEvaluationResults: [AggregateEvaluationResult]?
    /// <p>The <code>nextToken</code> string returned on a previous page that you use
    /// 			to get the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        aggregateEvaluationResults: [AggregateEvaluationResult]? = nil,
        nextToken: String? = nil
    )
    {
        self.aggregateEvaluationResults = aggregateEvaluationResults
        self.nextToken = nextToken
    }
}

struct GetAggregateComplianceDetailsByConfigRuleOutputResponseBody: Equatable {
    public let aggregateEvaluationResults: [AggregateEvaluationResult]?
    public let nextToken: String?
}

extension GetAggregateComplianceDetailsByConfigRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aggregateEvaluationResults = "AggregateEvaluationResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregateEvaluationResultsContainer = try containerValues.decodeIfPresent([AggregateEvaluationResult?].self, forKey: .aggregateEvaluationResults)
        var aggregateEvaluationResultsDecoded0:[AggregateEvaluationResult]? = nil
        if let aggregateEvaluationResultsContainer = aggregateEvaluationResultsContainer {
            aggregateEvaluationResultsDecoded0 = [AggregateEvaluationResult]()
            for structure0 in aggregateEvaluationResultsContainer {
                if let structure0 = structure0 {
                    aggregateEvaluationResultsDecoded0?.append(structure0)
                }
            }
        }
        aggregateEvaluationResults = aggregateEvaluationResultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetAggregateConfigRuleComplianceSummaryInputBodyMiddleware: Middleware {
    public let id: String = "GetAggregateConfigRuleComplianceSummaryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAggregateConfigRuleComplianceSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAggregateConfigRuleComplianceSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAggregateConfigRuleComplianceSummaryInput>
    public typealias MOutput = OperationOutput<GetAggregateConfigRuleComplianceSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAggregateConfigRuleComplianceSummaryOutputError>
}

extension GetAggregateConfigRuleComplianceSummaryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAggregateConfigRuleComplianceSummaryInput(configurationAggregatorName: \(String(describing: configurationAggregatorName)), filters: \(String(describing: filters)), groupByKey: \(String(describing: groupByKey)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension GetAggregateConfigRuleComplianceSummaryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case filters = "Filters"
        case groupByKey = "GroupByKey"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationAggregatorName = configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let groupByKey = groupByKey {
            try encodeContainer.encode(groupByKey.rawValue, forKey: .groupByKey)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetAggregateConfigRuleComplianceSummaryInputHeadersMiddleware: Middleware {
    public let id: String = "GetAggregateConfigRuleComplianceSummaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAggregateConfigRuleComplianceSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAggregateConfigRuleComplianceSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAggregateConfigRuleComplianceSummaryInput>
    public typealias MOutput = OperationOutput<GetAggregateConfigRuleComplianceSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAggregateConfigRuleComplianceSummaryOutputError>
}

public struct GetAggregateConfigRuleComplianceSummaryInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAggregateConfigRuleComplianceSummaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAggregateConfigRuleComplianceSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAggregateConfigRuleComplianceSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAggregateConfigRuleComplianceSummaryInput>
    public typealias MOutput = OperationOutput<GetAggregateConfigRuleComplianceSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAggregateConfigRuleComplianceSummaryOutputError>
}

public struct GetAggregateConfigRuleComplianceSummaryInput: Equatable {
    /// <p>The name of the configuration aggregator.</p>
    public let configurationAggregatorName: String?
    /// <p>Filters the results based on the
    /// 			ConfigRuleComplianceSummaryFilters object.</p>
    public let filters: ConfigRuleComplianceSummaryFilters?
    /// <p>Groups the result based on ACCOUNT_ID or AWS_REGION.</p>
    public let groupByKey: ConfigRuleComplianceSummaryGroupKey?
    /// <p>The maximum number of evaluation results returned on each page.
    /// 			The default is 1000. You cannot specify a number greater than 1000.
    /// 			If you specify 0, AWS Config uses the default.</p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned on a previous page that you use
    /// 			to get the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        configurationAggregatorName: String? = nil,
        filters: ConfigRuleComplianceSummaryFilters? = nil,
        groupByKey: ConfigRuleComplianceSummaryGroupKey? = nil,
        limit: Int = 0,
        nextToken: String? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.filters = filters
        self.groupByKey = groupByKey
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct GetAggregateConfigRuleComplianceSummaryInputBody: Equatable {
    public let configurationAggregatorName: String?
    public let filters: ConfigRuleComplianceSummaryFilters?
    public let groupByKey: ConfigRuleComplianceSummaryGroupKey?
    public let limit: Int
    public let nextToken: String?
}

extension GetAggregateConfigRuleComplianceSummaryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case filters = "Filters"
        case groupByKey = "GroupByKey"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(ConfigRuleComplianceSummaryFilters.self, forKey: .filters)
        filters = filtersDecoded
        let groupByKeyDecoded = try containerValues.decodeIfPresent(ConfigRuleComplianceSummaryGroupKey.self, forKey: .groupByKey)
        groupByKey = groupByKeyDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetAggregateConfigRuleComplianceSummaryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAggregateConfigRuleComplianceSummaryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAggregateConfigRuleComplianceSummaryOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAggregateConfigRuleComplianceSummaryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAggregateConfigRuleComplianceSummaryOutputResponse(aggregateComplianceCounts: \(String(describing: aggregateComplianceCounts)), groupByKey: \(String(describing: groupByKey)), nextToken: \(String(describing: nextToken)))"}
}

extension GetAggregateConfigRuleComplianceSummaryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAggregateConfigRuleComplianceSummaryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.aggregateComplianceCounts = output.aggregateComplianceCounts
            self.groupByKey = output.groupByKey
            self.nextToken = output.nextToken
        } else {
            self.aggregateComplianceCounts = nil
            self.groupByKey = nil
            self.nextToken = nil
        }
    }
}

public struct GetAggregateConfigRuleComplianceSummaryOutputResponse: Equatable {
    /// <p>Returns a list of AggregateComplianceCounts object.</p>
    public let aggregateComplianceCounts: [AggregateComplianceCount]?
    /// <p>Groups the result based on ACCOUNT_ID or AWS_REGION.</p>
    public let groupByKey: String?
    /// <p>The <code>nextToken</code> string returned on a previous page that you use
    /// 			to get the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        aggregateComplianceCounts: [AggregateComplianceCount]? = nil,
        groupByKey: String? = nil,
        nextToken: String? = nil
    )
    {
        self.aggregateComplianceCounts = aggregateComplianceCounts
        self.groupByKey = groupByKey
        self.nextToken = nextToken
    }
}

struct GetAggregateConfigRuleComplianceSummaryOutputResponseBody: Equatable {
    public let groupByKey: String?
    public let aggregateComplianceCounts: [AggregateComplianceCount]?
    public let nextToken: String?
}

extension GetAggregateConfigRuleComplianceSummaryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aggregateComplianceCounts = "AggregateComplianceCounts"
        case groupByKey = "GroupByKey"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupByKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupByKey)
        groupByKey = groupByKeyDecoded
        let aggregateComplianceCountsContainer = try containerValues.decodeIfPresent([AggregateComplianceCount?].self, forKey: .aggregateComplianceCounts)
        var aggregateComplianceCountsDecoded0:[AggregateComplianceCount]? = nil
        if let aggregateComplianceCountsContainer = aggregateComplianceCountsContainer {
            aggregateComplianceCountsDecoded0 = [AggregateComplianceCount]()
            for structure0 in aggregateComplianceCountsContainer {
                if let structure0 = structure0 {
                    aggregateComplianceCountsDecoded0?.append(structure0)
                }
            }
        }
        aggregateComplianceCounts = aggregateComplianceCountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetAggregateConformancePackComplianceSummaryInputBodyMiddleware: Middleware {
    public let id: String = "GetAggregateConformancePackComplianceSummaryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAggregateConformancePackComplianceSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAggregateConformancePackComplianceSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAggregateConformancePackComplianceSummaryInput>
    public typealias MOutput = OperationOutput<GetAggregateConformancePackComplianceSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAggregateConformancePackComplianceSummaryOutputError>
}

extension GetAggregateConformancePackComplianceSummaryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAggregateConformancePackComplianceSummaryInput(configurationAggregatorName: \(String(describing: configurationAggregatorName)), filters: \(String(describing: filters)), groupByKey: \(String(describing: groupByKey)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension GetAggregateConformancePackComplianceSummaryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case filters = "Filters"
        case groupByKey = "GroupByKey"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationAggregatorName = configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let groupByKey = groupByKey {
            try encodeContainer.encode(groupByKey.rawValue, forKey: .groupByKey)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetAggregateConformancePackComplianceSummaryInputHeadersMiddleware: Middleware {
    public let id: String = "GetAggregateConformancePackComplianceSummaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAggregateConformancePackComplianceSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAggregateConformancePackComplianceSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAggregateConformancePackComplianceSummaryInput>
    public typealias MOutput = OperationOutput<GetAggregateConformancePackComplianceSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAggregateConformancePackComplianceSummaryOutputError>
}

public struct GetAggregateConformancePackComplianceSummaryInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAggregateConformancePackComplianceSummaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAggregateConformancePackComplianceSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAggregateConformancePackComplianceSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAggregateConformancePackComplianceSummaryInput>
    public typealias MOutput = OperationOutput<GetAggregateConformancePackComplianceSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAggregateConformancePackComplianceSummaryOutputError>
}

public struct GetAggregateConformancePackComplianceSummaryInput: Equatable {
    /// <p>The name of the configuration aggregator.</p>
    public let configurationAggregatorName: String?
    /// <p>Filters the results based on the <code>AggregateConformancePackComplianceSummaryFilters</code> object.</p>
    public let filters: AggregateConformancePackComplianceSummaryFilters?
    /// <p>Groups the result based on AWS Account ID or AWS Region.</p>
    public let groupByKey: AggregateConformancePackComplianceSummaryGroupKey?
    /// <p>The maximum number of results returned on each page. The default is maximum. If you specify 0, AWS Config uses the default.</p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned on a previous page that you use to get the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        configurationAggregatorName: String? = nil,
        filters: AggregateConformancePackComplianceSummaryFilters? = nil,
        groupByKey: AggregateConformancePackComplianceSummaryGroupKey? = nil,
        limit: Int = 0,
        nextToken: String? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.filters = filters
        self.groupByKey = groupByKey
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct GetAggregateConformancePackComplianceSummaryInputBody: Equatable {
    public let configurationAggregatorName: String?
    public let filters: AggregateConformancePackComplianceSummaryFilters?
    public let groupByKey: AggregateConformancePackComplianceSummaryGroupKey?
    public let limit: Int
    public let nextToken: String?
}

extension GetAggregateConformancePackComplianceSummaryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case filters = "Filters"
        case groupByKey = "GroupByKey"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(AggregateConformancePackComplianceSummaryFilters.self, forKey: .filters)
        filters = filtersDecoded
        let groupByKeyDecoded = try containerValues.decodeIfPresent(AggregateConformancePackComplianceSummaryGroupKey.self, forKey: .groupByKey)
        groupByKey = groupByKeyDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetAggregateConformancePackComplianceSummaryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAggregateConformancePackComplianceSummaryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAggregateConformancePackComplianceSummaryOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAggregateConformancePackComplianceSummaryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAggregateConformancePackComplianceSummaryOutputResponse(aggregateConformancePackComplianceSummaries: \(String(describing: aggregateConformancePackComplianceSummaries)), groupByKey: \(String(describing: groupByKey)), nextToken: \(String(describing: nextToken)))"}
}

extension GetAggregateConformancePackComplianceSummaryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAggregateConformancePackComplianceSummaryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.aggregateConformancePackComplianceSummaries = output.aggregateConformancePackComplianceSummaries
            self.groupByKey = output.groupByKey
            self.nextToken = output.nextToken
        } else {
            self.aggregateConformancePackComplianceSummaries = nil
            self.groupByKey = nil
            self.nextToken = nil
        }
    }
}

public struct GetAggregateConformancePackComplianceSummaryOutputResponse: Equatable {
    /// <p>Returns a list of <code>AggregateConformancePackComplianceSummary</code> object.</p>
    public let aggregateConformancePackComplianceSummaries: [AggregateConformancePackComplianceSummary]?
    /// <p>Groups the result based on AWS Account ID or AWS Region.</p>
    public let groupByKey: String?
    /// <p>The <code>nextToken</code> string returned on a previous page that you use to get the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        aggregateConformancePackComplianceSummaries: [AggregateConformancePackComplianceSummary]? = nil,
        groupByKey: String? = nil,
        nextToken: String? = nil
    )
    {
        self.aggregateConformancePackComplianceSummaries = aggregateConformancePackComplianceSummaries
        self.groupByKey = groupByKey
        self.nextToken = nextToken
    }
}

struct GetAggregateConformancePackComplianceSummaryOutputResponseBody: Equatable {
    public let aggregateConformancePackComplianceSummaries: [AggregateConformancePackComplianceSummary]?
    public let groupByKey: String?
    public let nextToken: String?
}

extension GetAggregateConformancePackComplianceSummaryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aggregateConformancePackComplianceSummaries = "AggregateConformancePackComplianceSummaries"
        case groupByKey = "GroupByKey"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregateConformancePackComplianceSummariesContainer = try containerValues.decodeIfPresent([AggregateConformancePackComplianceSummary?].self, forKey: .aggregateConformancePackComplianceSummaries)
        var aggregateConformancePackComplianceSummariesDecoded0:[AggregateConformancePackComplianceSummary]? = nil
        if let aggregateConformancePackComplianceSummariesContainer = aggregateConformancePackComplianceSummariesContainer {
            aggregateConformancePackComplianceSummariesDecoded0 = [AggregateConformancePackComplianceSummary]()
            for structure0 in aggregateConformancePackComplianceSummariesContainer {
                if let structure0 = structure0 {
                    aggregateConformancePackComplianceSummariesDecoded0?.append(structure0)
                }
            }
        }
        aggregateConformancePackComplianceSummaries = aggregateConformancePackComplianceSummariesDecoded0
        let groupByKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupByKey)
        groupByKey = groupByKeyDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetAggregateDiscoveredResourceCountsInputBodyMiddleware: Middleware {
    public let id: String = "GetAggregateDiscoveredResourceCountsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAggregateDiscoveredResourceCountsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAggregateDiscoveredResourceCountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAggregateDiscoveredResourceCountsInput>
    public typealias MOutput = OperationOutput<GetAggregateDiscoveredResourceCountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAggregateDiscoveredResourceCountsOutputError>
}

extension GetAggregateDiscoveredResourceCountsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAggregateDiscoveredResourceCountsInput(configurationAggregatorName: \(String(describing: configurationAggregatorName)), filters: \(String(describing: filters)), groupByKey: \(String(describing: groupByKey)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension GetAggregateDiscoveredResourceCountsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case filters = "Filters"
        case groupByKey = "GroupByKey"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationAggregatorName = configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let groupByKey = groupByKey {
            try encodeContainer.encode(groupByKey.rawValue, forKey: .groupByKey)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetAggregateDiscoveredResourceCountsInputHeadersMiddleware: Middleware {
    public let id: String = "GetAggregateDiscoveredResourceCountsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAggregateDiscoveredResourceCountsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAggregateDiscoveredResourceCountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAggregateDiscoveredResourceCountsInput>
    public typealias MOutput = OperationOutput<GetAggregateDiscoveredResourceCountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAggregateDiscoveredResourceCountsOutputError>
}

public struct GetAggregateDiscoveredResourceCountsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAggregateDiscoveredResourceCountsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAggregateDiscoveredResourceCountsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAggregateDiscoveredResourceCountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAggregateDiscoveredResourceCountsInput>
    public typealias MOutput = OperationOutput<GetAggregateDiscoveredResourceCountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAggregateDiscoveredResourceCountsOutputError>
}

public struct GetAggregateDiscoveredResourceCountsInput: Equatable {
    /// <p>The name of the configuration aggregator.</p>
    public let configurationAggregatorName: String?
    /// <p>Filters the results based on the <code>ResourceCountFilters</code> object.</p>
    public let filters: ResourceCountFilters?
    /// <p>The key to group the resource counts.</p>
    public let groupByKey: ResourceCountGroupKey?
    /// <p>The maximum number of <a>GroupedResourceCount</a> objects returned on each page. The default is 1000. You cannot specify a number greater than 1000. If you specify 0, AWS Config uses the default.</p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned on a previous page that you use to get the next page of results in a paginated response. </p>
    public let nextToken: String?

    public init (
        configurationAggregatorName: String? = nil,
        filters: ResourceCountFilters? = nil,
        groupByKey: ResourceCountGroupKey? = nil,
        limit: Int = 0,
        nextToken: String? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.filters = filters
        self.groupByKey = groupByKey
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct GetAggregateDiscoveredResourceCountsInputBody: Equatable {
    public let configurationAggregatorName: String?
    public let filters: ResourceCountFilters?
    public let groupByKey: ResourceCountGroupKey?
    public let limit: Int
    public let nextToken: String?
}

extension GetAggregateDiscoveredResourceCountsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case filters = "Filters"
        case groupByKey = "GroupByKey"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(ResourceCountFilters.self, forKey: .filters)
        filters = filtersDecoded
        let groupByKeyDecoded = try containerValues.decodeIfPresent(ResourceCountGroupKey.self, forKey: .groupByKey)
        groupByKey = groupByKeyDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetAggregateDiscoveredResourceCountsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAggregateDiscoveredResourceCountsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAggregateDiscoveredResourceCountsOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAggregateDiscoveredResourceCountsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAggregateDiscoveredResourceCountsOutputResponse(groupByKey: \(String(describing: groupByKey)), groupedResourceCounts: \(String(describing: groupedResourceCounts)), nextToken: \(String(describing: nextToken)), totalDiscoveredResources: \(String(describing: totalDiscoveredResources)))"}
}

extension GetAggregateDiscoveredResourceCountsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAggregateDiscoveredResourceCountsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groupByKey = output.groupByKey
            self.groupedResourceCounts = output.groupedResourceCounts
            self.nextToken = output.nextToken
            self.totalDiscoveredResources = output.totalDiscoveredResources
        } else {
            self.groupByKey = nil
            self.groupedResourceCounts = nil
            self.nextToken = nil
            self.totalDiscoveredResources = 0
        }
    }
}

public struct GetAggregateDiscoveredResourceCountsOutputResponse: Equatable {
    /// <p>The key passed into the request object. If <code>GroupByKey</code> is not provided, the result will be empty.</p>
    public let groupByKey: String?
    /// <p>Returns a list of GroupedResourceCount objects.</p>
    public let groupedResourceCounts: [GroupedResourceCount]?
    /// <p>The <code>nextToken</code> string returned on a previous page that you use to get the next page of results in a paginated response.</p>
    public let nextToken: String?
    /// <p>The total number of resources that are present in an aggregator with the filters that you provide.</p>
    public let totalDiscoveredResources: Int

    public init (
        groupByKey: String? = nil,
        groupedResourceCounts: [GroupedResourceCount]? = nil,
        nextToken: String? = nil,
        totalDiscoveredResources: Int = 0
    )
    {
        self.groupByKey = groupByKey
        self.groupedResourceCounts = groupedResourceCounts
        self.nextToken = nextToken
        self.totalDiscoveredResources = totalDiscoveredResources
    }
}

struct GetAggregateDiscoveredResourceCountsOutputResponseBody: Equatable {
    public let totalDiscoveredResources: Int
    public let groupByKey: String?
    public let groupedResourceCounts: [GroupedResourceCount]?
    public let nextToken: String?
}

extension GetAggregateDiscoveredResourceCountsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupByKey = "GroupByKey"
        case groupedResourceCounts = "GroupedResourceCounts"
        case nextToken = "NextToken"
        case totalDiscoveredResources = "TotalDiscoveredResources"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDiscoveredResourcesDecoded = try containerValues.decode(Int.self, forKey: .totalDiscoveredResources)
        totalDiscoveredResources = totalDiscoveredResourcesDecoded
        let groupByKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupByKey)
        groupByKey = groupByKeyDecoded
        let groupedResourceCountsContainer = try containerValues.decodeIfPresent([GroupedResourceCount?].self, forKey: .groupedResourceCounts)
        var groupedResourceCountsDecoded0:[GroupedResourceCount]? = nil
        if let groupedResourceCountsContainer = groupedResourceCountsContainer {
            groupedResourceCountsDecoded0 = [GroupedResourceCount]()
            for structure0 in groupedResourceCountsContainer {
                if let structure0 = structure0 {
                    groupedResourceCountsDecoded0?.append(structure0)
                }
            }
        }
        groupedResourceCounts = groupedResourceCountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetAggregateResourceConfigInputBodyMiddleware: Middleware {
    public let id: String = "GetAggregateResourceConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAggregateResourceConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAggregateResourceConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAggregateResourceConfigInput>
    public typealias MOutput = OperationOutput<GetAggregateResourceConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAggregateResourceConfigOutputError>
}

extension GetAggregateResourceConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAggregateResourceConfigInput(configurationAggregatorName: \(String(describing: configurationAggregatorName)), resourceIdentifier: \(String(describing: resourceIdentifier)))"}
}

extension GetAggregateResourceConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case resourceIdentifier = "ResourceIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationAggregatorName = configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if let resourceIdentifier = resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
    }
}

public struct GetAggregateResourceConfigInputHeadersMiddleware: Middleware {
    public let id: String = "GetAggregateResourceConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAggregateResourceConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAggregateResourceConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAggregateResourceConfigInput>
    public typealias MOutput = OperationOutput<GetAggregateResourceConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAggregateResourceConfigOutputError>
}

public struct GetAggregateResourceConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAggregateResourceConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAggregateResourceConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAggregateResourceConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAggregateResourceConfigInput>
    public typealias MOutput = OperationOutput<GetAggregateResourceConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAggregateResourceConfigOutputError>
}

public struct GetAggregateResourceConfigInput: Equatable {
    /// <p>The name of the configuration aggregator.</p>
    public let configurationAggregatorName: String?
    /// <p>An object that identifies aggregate resource.</p>
    public let resourceIdentifier: AggregateResourceIdentifier?

    public init (
        configurationAggregatorName: String? = nil,
        resourceIdentifier: AggregateResourceIdentifier? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.resourceIdentifier = resourceIdentifier
    }
}

struct GetAggregateResourceConfigInputBody: Equatable {
    public let configurationAggregatorName: String?
    public let resourceIdentifier: AggregateResourceIdentifier?
}

extension GetAggregateResourceConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case resourceIdentifier = "ResourceIdentifier"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(AggregateResourceIdentifier.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
    }
}

extension GetAggregateResourceConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAggregateResourceConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OversizedConfigurationItemException" : self = .oversizedConfigurationItemException(try OversizedConfigurationItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotDiscoveredException" : self = .resourceNotDiscoveredException(try ResourceNotDiscoveredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAggregateResourceConfigOutputError: Equatable {
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case oversizedConfigurationItemException(OversizedConfigurationItemException)
    case resourceNotDiscoveredException(ResourceNotDiscoveredException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAggregateResourceConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAggregateResourceConfigOutputResponse(configurationItem: \(String(describing: configurationItem)))"}
}

extension GetAggregateResourceConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAggregateResourceConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationItem = output.configurationItem
        } else {
            self.configurationItem = nil
        }
    }
}

public struct GetAggregateResourceConfigOutputResponse: Equatable {
    /// <p>Returns a <code>ConfigurationItem</code> object.</p>
    public let configurationItem: ConfigurationItem?

    public init (
        configurationItem: ConfigurationItem? = nil
    )
    {
        self.configurationItem = configurationItem
    }
}

struct GetAggregateResourceConfigOutputResponseBody: Equatable {
    public let configurationItem: ConfigurationItem?
}

extension GetAggregateResourceConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationItem = "ConfigurationItem"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationItemDecoded = try containerValues.decodeIfPresent(ConfigurationItem.self, forKey: .configurationItem)
        configurationItem = configurationItemDecoded
    }
}

public struct GetComplianceDetailsByConfigRuleInputBodyMiddleware: Middleware {
    public let id: String = "GetComplianceDetailsByConfigRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetComplianceDetailsByConfigRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetComplianceDetailsByConfigRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetComplianceDetailsByConfigRuleInput>
    public typealias MOutput = OperationOutput<GetComplianceDetailsByConfigRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetComplianceDetailsByConfigRuleOutputError>
}

extension GetComplianceDetailsByConfigRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetComplianceDetailsByConfigRuleInput(complianceTypes: \(String(describing: complianceTypes)), configRuleName: \(String(describing: configRuleName)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension GetComplianceDetailsByConfigRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceTypes = "ComplianceTypes"
        case configRuleName = "ConfigRuleName"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceTypes = complianceTypes {
            var complianceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .complianceTypes)
            for compliancetypes0 in complianceTypes {
                try complianceTypesContainer.encode(compliancetypes0.rawValue)
            }
        }
        if let configRuleName = configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetComplianceDetailsByConfigRuleInputHeadersMiddleware: Middleware {
    public let id: String = "GetComplianceDetailsByConfigRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetComplianceDetailsByConfigRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetComplianceDetailsByConfigRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetComplianceDetailsByConfigRuleInput>
    public typealias MOutput = OperationOutput<GetComplianceDetailsByConfigRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetComplianceDetailsByConfigRuleOutputError>
}

public struct GetComplianceDetailsByConfigRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "GetComplianceDetailsByConfigRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetComplianceDetailsByConfigRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetComplianceDetailsByConfigRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetComplianceDetailsByConfigRuleInput>
    public typealias MOutput = OperationOutput<GetComplianceDetailsByConfigRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetComplianceDetailsByConfigRuleOutputError>
}

/// <p></p>
public struct GetComplianceDetailsByConfigRuleInput: Equatable {
    /// <p>Filters the results by compliance.</p>
    /// 		       <p>The allowed values are <code>COMPLIANT</code>,
    /// 				<code>NON_COMPLIANT</code>, and
    /// 			<code>NOT_APPLICABLE</code>.</p>
    public let complianceTypes: [ComplianceType]?
    /// <p>The name of the AWS Config rule for which you want compliance
    /// 			information.</p>
    public let configRuleName: String?
    /// <p>The maximum number of evaluation results returned on each page.
    /// 			The default is 10. You cannot specify a number greater than 100. If
    /// 			you specify 0, AWS Config uses the default.</p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned on a previous page
    /// 			that you use to get the next page of results in a paginated
    /// 			response.</p>
    public let nextToken: String?

    public init (
        complianceTypes: [ComplianceType]? = nil,
        configRuleName: String? = nil,
        limit: Int = 0,
        nextToken: String? = nil
    )
    {
        self.complianceTypes = complianceTypes
        self.configRuleName = configRuleName
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct GetComplianceDetailsByConfigRuleInputBody: Equatable {
    public let configRuleName: String?
    public let complianceTypes: [ComplianceType]?
    public let limit: Int
    public let nextToken: String?
}

extension GetComplianceDetailsByConfigRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case complianceTypes = "ComplianceTypes"
        case configRuleName = "ConfigRuleName"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let complianceTypesContainer = try containerValues.decodeIfPresent([ComplianceType?].self, forKey: .complianceTypes)
        var complianceTypesDecoded0:[ComplianceType]? = nil
        if let complianceTypesContainer = complianceTypesContainer {
            complianceTypesDecoded0 = [ComplianceType]()
            for string0 in complianceTypesContainer {
                if let string0 = string0 {
                    complianceTypesDecoded0?.append(string0)
                }
            }
        }
        complianceTypes = complianceTypesDecoded0
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetComplianceDetailsByConfigRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComplianceDetailsByConfigRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigRuleException" : self = .noSuchConfigRuleException(try NoSuchConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetComplianceDetailsByConfigRuleOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchConfigRuleException(NoSuchConfigRuleException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComplianceDetailsByConfigRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetComplianceDetailsByConfigRuleOutputResponse(evaluationResults: \(String(describing: evaluationResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetComplianceDetailsByConfigRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetComplianceDetailsByConfigRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.evaluationResults = output.evaluationResults
            self.nextToken = output.nextToken
        } else {
            self.evaluationResults = nil
            self.nextToken = nil
        }
    }
}

/// <p></p>
public struct GetComplianceDetailsByConfigRuleOutputResponse: Equatable {
    /// <p>Indicates whether the AWS resource complies with the specified
    /// 			AWS Config rule.</p>
    public let evaluationResults: [EvaluationResult]?
    /// <p>The string that you use in a subsequent request to get the next
    /// 			page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        evaluationResults: [EvaluationResult]? = nil,
        nextToken: String? = nil
    )
    {
        self.evaluationResults = evaluationResults
        self.nextToken = nextToken
    }
}

struct GetComplianceDetailsByConfigRuleOutputResponseBody: Equatable {
    public let evaluationResults: [EvaluationResult]?
    public let nextToken: String?
}

extension GetComplianceDetailsByConfigRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case evaluationResults = "EvaluationResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationResultsContainer = try containerValues.decodeIfPresent([EvaluationResult?].self, forKey: .evaluationResults)
        var evaluationResultsDecoded0:[EvaluationResult]? = nil
        if let evaluationResultsContainer = evaluationResultsContainer {
            evaluationResultsDecoded0 = [EvaluationResult]()
            for structure0 in evaluationResultsContainer {
                if let structure0 = structure0 {
                    evaluationResultsDecoded0?.append(structure0)
                }
            }
        }
        evaluationResults = evaluationResultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetComplianceDetailsByResourceInputBodyMiddleware: Middleware {
    public let id: String = "GetComplianceDetailsByResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetComplianceDetailsByResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetComplianceDetailsByResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetComplianceDetailsByResourceInput>
    public typealias MOutput = OperationOutput<GetComplianceDetailsByResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetComplianceDetailsByResourceOutputError>
}

extension GetComplianceDetailsByResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetComplianceDetailsByResourceInput(complianceTypes: \(String(describing: complianceTypes)), nextToken: \(String(describing: nextToken)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension GetComplianceDetailsByResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceTypes = "ComplianceTypes"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceTypes = complianceTypes {
            var complianceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .complianceTypes)
            for compliancetypes0 in complianceTypes {
                try complianceTypesContainer.encode(compliancetypes0.rawValue)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

public struct GetComplianceDetailsByResourceInputHeadersMiddleware: Middleware {
    public let id: String = "GetComplianceDetailsByResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetComplianceDetailsByResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetComplianceDetailsByResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetComplianceDetailsByResourceInput>
    public typealias MOutput = OperationOutput<GetComplianceDetailsByResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetComplianceDetailsByResourceOutputError>
}

public struct GetComplianceDetailsByResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "GetComplianceDetailsByResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetComplianceDetailsByResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetComplianceDetailsByResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetComplianceDetailsByResourceInput>
    public typealias MOutput = OperationOutput<GetComplianceDetailsByResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetComplianceDetailsByResourceOutputError>
}

/// <p></p>
public struct GetComplianceDetailsByResourceInput: Equatable {
    /// <p>Filters the results by compliance.</p>
    /// 		       <p>The allowed values are <code>COMPLIANT</code>,
    /// 				<code>NON_COMPLIANT</code>, and
    /// 			<code>NOT_APPLICABLE</code>.</p>
    public let complianceTypes: [ComplianceType]?
    /// <p>The <code>nextToken</code> string returned on a previous page
    /// 			that you use to get the next page of results in a paginated
    /// 			response.</p>
    public let nextToken: String?
    /// <p>The ID of the AWS resource for which you want compliance
    /// 			information.</p>
    public let resourceId: String?
    /// <p>The type of the AWS resource for which you want compliance
    /// 			information.</p>
    public let resourceType: String?

    public init (
        complianceTypes: [ComplianceType]? = nil,
        nextToken: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.complianceTypes = complianceTypes
        self.nextToken = nextToken
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct GetComplianceDetailsByResourceInputBody: Equatable {
    public let resourceType: String?
    public let resourceId: String?
    public let complianceTypes: [ComplianceType]?
    public let nextToken: String?
}

extension GetComplianceDetailsByResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case complianceTypes = "ComplianceTypes"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let complianceTypesContainer = try containerValues.decodeIfPresent([ComplianceType?].self, forKey: .complianceTypes)
        var complianceTypesDecoded0:[ComplianceType]? = nil
        if let complianceTypesContainer = complianceTypesContainer {
            complianceTypesDecoded0 = [ComplianceType]()
            for string0 in complianceTypesContainer {
                if let string0 = string0 {
                    complianceTypesDecoded0?.append(string0)
                }
            }
        }
        complianceTypes = complianceTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetComplianceDetailsByResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComplianceDetailsByResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetComplianceDetailsByResourceOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComplianceDetailsByResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetComplianceDetailsByResourceOutputResponse(evaluationResults: \(String(describing: evaluationResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetComplianceDetailsByResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetComplianceDetailsByResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.evaluationResults = output.evaluationResults
            self.nextToken = output.nextToken
        } else {
            self.evaluationResults = nil
            self.nextToken = nil
        }
    }
}

/// <p></p>
public struct GetComplianceDetailsByResourceOutputResponse: Equatable {
    /// <p>Indicates whether the specified AWS resource complies each AWS
    /// 			Config rule.</p>
    public let evaluationResults: [EvaluationResult]?
    /// <p>The string that you use in a subsequent request to get the next
    /// 			page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        evaluationResults: [EvaluationResult]? = nil,
        nextToken: String? = nil
    )
    {
        self.evaluationResults = evaluationResults
        self.nextToken = nextToken
    }
}

struct GetComplianceDetailsByResourceOutputResponseBody: Equatable {
    public let evaluationResults: [EvaluationResult]?
    public let nextToken: String?
}

extension GetComplianceDetailsByResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case evaluationResults = "EvaluationResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationResultsContainer = try containerValues.decodeIfPresent([EvaluationResult?].self, forKey: .evaluationResults)
        var evaluationResultsDecoded0:[EvaluationResult]? = nil
        if let evaluationResultsContainer = evaluationResultsContainer {
            evaluationResultsDecoded0 = [EvaluationResult]()
            for structure0 in evaluationResultsContainer {
                if let structure0 = structure0 {
                    evaluationResultsDecoded0?.append(structure0)
                }
            }
        }
        evaluationResults = evaluationResultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetComplianceSummaryByConfigRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetComplianceSummaryByConfigRuleInput()"}
}

extension GetComplianceSummaryByConfigRuleInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetComplianceSummaryByConfigRuleInputHeadersMiddleware: Middleware {
    public let id: String = "GetComplianceSummaryByConfigRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetComplianceSummaryByConfigRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetComplianceSummaryByConfigRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetComplianceSummaryByConfigRuleInput>
    public typealias MOutput = OperationOutput<GetComplianceSummaryByConfigRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetComplianceSummaryByConfigRuleOutputError>
}

public struct GetComplianceSummaryByConfigRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "GetComplianceSummaryByConfigRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetComplianceSummaryByConfigRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetComplianceSummaryByConfigRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetComplianceSummaryByConfigRuleInput>
    public typealias MOutput = OperationOutput<GetComplianceSummaryByConfigRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetComplianceSummaryByConfigRuleOutputError>
}

public struct GetComplianceSummaryByConfigRuleInput: Equatable {

    public init() {}
}

struct GetComplianceSummaryByConfigRuleInputBody: Equatable {
}

extension GetComplianceSummaryByConfigRuleInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetComplianceSummaryByConfigRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComplianceSummaryByConfigRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetComplianceSummaryByConfigRuleOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComplianceSummaryByConfigRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetComplianceSummaryByConfigRuleOutputResponse(complianceSummary: \(String(describing: complianceSummary)))"}
}

extension GetComplianceSummaryByConfigRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetComplianceSummaryByConfigRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.complianceSummary = output.complianceSummary
        } else {
            self.complianceSummary = nil
        }
    }
}

/// <p></p>
public struct GetComplianceSummaryByConfigRuleOutputResponse: Equatable {
    /// <p>The number of AWS Config rules that are compliant and the
    /// 			number that are noncompliant, up to a maximum of 25 for
    /// 			each.</p>
    public let complianceSummary: ComplianceSummary?

    public init (
        complianceSummary: ComplianceSummary? = nil
    )
    {
        self.complianceSummary = complianceSummary
    }
}

struct GetComplianceSummaryByConfigRuleOutputResponseBody: Equatable {
    public let complianceSummary: ComplianceSummary?
}

extension GetComplianceSummaryByConfigRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case complianceSummary = "ComplianceSummary"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceSummaryDecoded = try containerValues.decodeIfPresent(ComplianceSummary.self, forKey: .complianceSummary)
        complianceSummary = complianceSummaryDecoded
    }
}

public struct GetComplianceSummaryByResourceTypeInputBodyMiddleware: Middleware {
    public let id: String = "GetComplianceSummaryByResourceTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetComplianceSummaryByResourceTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetComplianceSummaryByResourceTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetComplianceSummaryByResourceTypeInput>
    public typealias MOutput = OperationOutput<GetComplianceSummaryByResourceTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetComplianceSummaryByResourceTypeOutputError>
}

extension GetComplianceSummaryByResourceTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetComplianceSummaryByResourceTypeInput(resourceTypes: \(String(describing: resourceTypes)))"}
}

extension GetComplianceSummaryByResourceTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceTypes = "ResourceTypes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for resourcetypes0 in resourceTypes {
                try resourceTypesContainer.encode(resourcetypes0)
            }
        }
    }
}

public struct GetComplianceSummaryByResourceTypeInputHeadersMiddleware: Middleware {
    public let id: String = "GetComplianceSummaryByResourceTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetComplianceSummaryByResourceTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetComplianceSummaryByResourceTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetComplianceSummaryByResourceTypeInput>
    public typealias MOutput = OperationOutput<GetComplianceSummaryByResourceTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetComplianceSummaryByResourceTypeOutputError>
}

public struct GetComplianceSummaryByResourceTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "GetComplianceSummaryByResourceTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetComplianceSummaryByResourceTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetComplianceSummaryByResourceTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetComplianceSummaryByResourceTypeInput>
    public typealias MOutput = OperationOutput<GetComplianceSummaryByResourceTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetComplianceSummaryByResourceTypeOutputError>
}

/// <p></p>
public struct GetComplianceSummaryByResourceTypeInput: Equatable {
    /// <p>Specify one or more resource types to get the number of
    /// 			resources that are compliant and the number that are noncompliant
    /// 			for each resource type.</p>
    /// 		       <p>For this request, you can specify an AWS resource type such as
    /// 				<code>AWS::EC2::Instance</code>. You can specify that the
    /// 			resource type is an AWS account by specifying
    /// 				<code>AWS::::Account</code>.</p>
    public let resourceTypes: [String]?

    public init (
        resourceTypes: [String]? = nil
    )
    {
        self.resourceTypes = resourceTypes
    }
}

struct GetComplianceSummaryByResourceTypeInputBody: Equatable {
    public let resourceTypes: [String]?
}

extension GetComplianceSummaryByResourceTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceTypes = "ResourceTypes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[String]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [String]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
    }
}

extension GetComplianceSummaryByResourceTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComplianceSummaryByResourceTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetComplianceSummaryByResourceTypeOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComplianceSummaryByResourceTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetComplianceSummaryByResourceTypeOutputResponse(complianceSummariesByResourceType: \(String(describing: complianceSummariesByResourceType)))"}
}

extension GetComplianceSummaryByResourceTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetComplianceSummaryByResourceTypeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.complianceSummariesByResourceType = output.complianceSummariesByResourceType
        } else {
            self.complianceSummariesByResourceType = nil
        }
    }
}

/// <p></p>
public struct GetComplianceSummaryByResourceTypeOutputResponse: Equatable {
    /// <p>The number of resources that are compliant and the number that
    /// 			are noncompliant. If one or more resource types were provided with
    /// 			the request, the numbers are returned for each resource type. The
    /// 			maximum number returned is 100.</p>
    public let complianceSummariesByResourceType: [ComplianceSummaryByResourceType]?

    public init (
        complianceSummariesByResourceType: [ComplianceSummaryByResourceType]? = nil
    )
    {
        self.complianceSummariesByResourceType = complianceSummariesByResourceType
    }
}

struct GetComplianceSummaryByResourceTypeOutputResponseBody: Equatable {
    public let complianceSummariesByResourceType: [ComplianceSummaryByResourceType]?
}

extension GetComplianceSummaryByResourceTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case complianceSummariesByResourceType = "ComplianceSummariesByResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceSummariesByResourceTypeContainer = try containerValues.decodeIfPresent([ComplianceSummaryByResourceType?].self, forKey: .complianceSummariesByResourceType)
        var complianceSummariesByResourceTypeDecoded0:[ComplianceSummaryByResourceType]? = nil
        if let complianceSummariesByResourceTypeContainer = complianceSummariesByResourceTypeContainer {
            complianceSummariesByResourceTypeDecoded0 = [ComplianceSummaryByResourceType]()
            for structure0 in complianceSummariesByResourceTypeContainer {
                if let structure0 = structure0 {
                    complianceSummariesByResourceTypeDecoded0?.append(structure0)
                }
            }
        }
        complianceSummariesByResourceType = complianceSummariesByResourceTypeDecoded0
    }
}

public struct GetConformancePackComplianceDetailsInputBodyMiddleware: Middleware {
    public let id: String = "GetConformancePackComplianceDetailsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConformancePackComplianceDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConformancePackComplianceDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConformancePackComplianceDetailsInput>
    public typealias MOutput = OperationOutput<GetConformancePackComplianceDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConformancePackComplianceDetailsOutputError>
}

extension GetConformancePackComplianceDetailsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConformancePackComplianceDetailsInput(conformancePackName: \(String(describing: conformancePackName)), filters: \(String(describing: filters)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension GetConformancePackComplianceDetailsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conformancePackName = "ConformancePackName"
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackName = conformancePackName {
            try encodeContainer.encode(conformancePackName, forKey: .conformancePackName)
        }
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetConformancePackComplianceDetailsInputHeadersMiddleware: Middleware {
    public let id: String = "GetConformancePackComplianceDetailsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConformancePackComplianceDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConformancePackComplianceDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConformancePackComplianceDetailsInput>
    public typealias MOutput = OperationOutput<GetConformancePackComplianceDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConformancePackComplianceDetailsOutputError>
}

public struct GetConformancePackComplianceDetailsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetConformancePackComplianceDetailsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConformancePackComplianceDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConformancePackComplianceDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConformancePackComplianceDetailsInput>
    public typealias MOutput = OperationOutput<GetConformancePackComplianceDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConformancePackComplianceDetailsOutputError>
}

public struct GetConformancePackComplianceDetailsInput: Equatable {
    /// <p>Name of the conformance pack.</p>
    public let conformancePackName: String?
    /// <p>A <code>ConformancePackEvaluationFilters</code> object.</p>
    public let filters: ConformancePackEvaluationFilters?
    /// <p>The maximum number of evaluation results returned on each page. If you do no specify a number, AWS Config uses the default. The default is 100.</p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned in a previous request that you use to request the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        conformancePackName: String? = nil,
        filters: ConformancePackEvaluationFilters? = nil,
        limit: Int = 0,
        nextToken: String? = nil
    )
    {
        self.conformancePackName = conformancePackName
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct GetConformancePackComplianceDetailsInputBody: Equatable {
    public let conformancePackName: String?
    public let filters: ConformancePackEvaluationFilters?
    public let limit: Int
    public let nextToken: String?
}

extension GetConformancePackComplianceDetailsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conformancePackName = "ConformancePackName"
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conformancePackName)
        conformancePackName = conformancePackNameDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(ConformancePackEvaluationFilters.self, forKey: .filters)
        filters = filtersDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetConformancePackComplianceDetailsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConformancePackComplianceDetailsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigRuleInConformancePackException" : self = .noSuchConfigRuleInConformancePackException(try NoSuchConfigRuleInConformancePackException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConformancePackException" : self = .noSuchConformancePackException(try NoSuchConformancePackException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConformancePackComplianceDetailsOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchConfigRuleInConformancePackException(NoSuchConfigRuleInConformancePackException)
    case noSuchConformancePackException(NoSuchConformancePackException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConformancePackComplianceDetailsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConformancePackComplianceDetailsOutputResponse(conformancePackName: \(String(describing: conformancePackName)), conformancePackRuleEvaluationResults: \(String(describing: conformancePackRuleEvaluationResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetConformancePackComplianceDetailsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetConformancePackComplianceDetailsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.conformancePackName = output.conformancePackName
            self.conformancePackRuleEvaluationResults = output.conformancePackRuleEvaluationResults
            self.nextToken = output.nextToken
        } else {
            self.conformancePackName = nil
            self.conformancePackRuleEvaluationResults = nil
            self.nextToken = nil
        }
    }
}

public struct GetConformancePackComplianceDetailsOutputResponse: Equatable {
    /// <p>Name of the conformance pack.</p>
    public let conformancePackName: String?
    /// <p>Returns a list of <code>ConformancePackEvaluationResult</code> objects.</p>
    public let conformancePackRuleEvaluationResults: [ConformancePackEvaluationResult]?
    /// <p>The <code>nextToken</code> string returned in a previous request that you use to request the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        conformancePackName: String? = nil,
        conformancePackRuleEvaluationResults: [ConformancePackEvaluationResult]? = nil,
        nextToken: String? = nil
    )
    {
        self.conformancePackName = conformancePackName
        self.conformancePackRuleEvaluationResults = conformancePackRuleEvaluationResults
        self.nextToken = nextToken
    }
}

struct GetConformancePackComplianceDetailsOutputResponseBody: Equatable {
    public let conformancePackName: String?
    public let conformancePackRuleEvaluationResults: [ConformancePackEvaluationResult]?
    public let nextToken: String?
}

extension GetConformancePackComplianceDetailsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conformancePackName = "ConformancePackName"
        case conformancePackRuleEvaluationResults = "ConformancePackRuleEvaluationResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conformancePackName)
        conformancePackName = conformancePackNameDecoded
        let conformancePackRuleEvaluationResultsContainer = try containerValues.decodeIfPresent([ConformancePackEvaluationResult?].self, forKey: .conformancePackRuleEvaluationResults)
        var conformancePackRuleEvaluationResultsDecoded0:[ConformancePackEvaluationResult]? = nil
        if let conformancePackRuleEvaluationResultsContainer = conformancePackRuleEvaluationResultsContainer {
            conformancePackRuleEvaluationResultsDecoded0 = [ConformancePackEvaluationResult]()
            for structure0 in conformancePackRuleEvaluationResultsContainer {
                if let structure0 = structure0 {
                    conformancePackRuleEvaluationResultsDecoded0?.append(structure0)
                }
            }
        }
        conformancePackRuleEvaluationResults = conformancePackRuleEvaluationResultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetConformancePackComplianceSummaryInputBodyMiddleware: Middleware {
    public let id: String = "GetConformancePackComplianceSummaryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConformancePackComplianceSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConformancePackComplianceSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConformancePackComplianceSummaryInput>
    public typealias MOutput = OperationOutput<GetConformancePackComplianceSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConformancePackComplianceSummaryOutputError>
}

extension GetConformancePackComplianceSummaryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConformancePackComplianceSummaryInput(conformancePackNames: \(String(describing: conformancePackNames)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension GetConformancePackComplianceSummaryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conformancePackNames = "ConformancePackNames"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackNames = conformancePackNames {
            var conformancePackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conformancePackNames)
            for conformancepacknamestosummarizelist0 in conformancePackNames {
                try conformancePackNamesContainer.encode(conformancepacknamestosummarizelist0)
            }
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetConformancePackComplianceSummaryInputHeadersMiddleware: Middleware {
    public let id: String = "GetConformancePackComplianceSummaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConformancePackComplianceSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConformancePackComplianceSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConformancePackComplianceSummaryInput>
    public typealias MOutput = OperationOutput<GetConformancePackComplianceSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConformancePackComplianceSummaryOutputError>
}

public struct GetConformancePackComplianceSummaryInputQueryItemMiddleware: Middleware {
    public let id: String = "GetConformancePackComplianceSummaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConformancePackComplianceSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConformancePackComplianceSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConformancePackComplianceSummaryInput>
    public typealias MOutput = OperationOutput<GetConformancePackComplianceSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConformancePackComplianceSummaryOutputError>
}

public struct GetConformancePackComplianceSummaryInput: Equatable {
    /// <p>Names of conformance packs.</p>
    public let conformancePackNames: [String]?
    /// <p>The maximum number of conformance packs returned on each page.</p>
    public let limit: Int
    /// <p>The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        conformancePackNames: [String]? = nil,
        limit: Int = 0,
        nextToken: String? = nil
    )
    {
        self.conformancePackNames = conformancePackNames
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct GetConformancePackComplianceSummaryInputBody: Equatable {
    public let conformancePackNames: [String]?
    public let limit: Int
    public let nextToken: String?
}

extension GetConformancePackComplianceSummaryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conformancePackNames = "ConformancePackNames"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .conformancePackNames)
        var conformancePackNamesDecoded0:[String]? = nil
        if let conformancePackNamesContainer = conformancePackNamesContainer {
            conformancePackNamesDecoded0 = [String]()
            for string0 in conformancePackNamesContainer {
                if let string0 = string0 {
                    conformancePackNamesDecoded0?.append(string0)
                }
            }
        }
        conformancePackNames = conformancePackNamesDecoded0
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetConformancePackComplianceSummaryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConformancePackComplianceSummaryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConformancePackException" : self = .noSuchConformancePackException(try NoSuchConformancePackException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConformancePackComplianceSummaryOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchConformancePackException(NoSuchConformancePackException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConformancePackComplianceSummaryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConformancePackComplianceSummaryOutputResponse(conformancePackComplianceSummaryList: \(String(describing: conformancePackComplianceSummaryList)), nextToken: \(String(describing: nextToken)))"}
}

extension GetConformancePackComplianceSummaryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetConformancePackComplianceSummaryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.conformancePackComplianceSummaryList = output.conformancePackComplianceSummaryList
            self.nextToken = output.nextToken
        } else {
            self.conformancePackComplianceSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct GetConformancePackComplianceSummaryOutputResponse: Equatable {
    /// <p>A list of <code>ConformancePackComplianceSummary</code> objects. </p>
    public let conformancePackComplianceSummaryList: [ConformancePackComplianceSummary]?
    /// <p>The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        conformancePackComplianceSummaryList: [ConformancePackComplianceSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.conformancePackComplianceSummaryList = conformancePackComplianceSummaryList
        self.nextToken = nextToken
    }
}

struct GetConformancePackComplianceSummaryOutputResponseBody: Equatable {
    public let conformancePackComplianceSummaryList: [ConformancePackComplianceSummary]?
    public let nextToken: String?
}

extension GetConformancePackComplianceSummaryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conformancePackComplianceSummaryList = "ConformancePackComplianceSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackComplianceSummaryListContainer = try containerValues.decodeIfPresent([ConformancePackComplianceSummary?].self, forKey: .conformancePackComplianceSummaryList)
        var conformancePackComplianceSummaryListDecoded0:[ConformancePackComplianceSummary]? = nil
        if let conformancePackComplianceSummaryListContainer = conformancePackComplianceSummaryListContainer {
            conformancePackComplianceSummaryListDecoded0 = [ConformancePackComplianceSummary]()
            for structure0 in conformancePackComplianceSummaryListContainer {
                if let structure0 = structure0 {
                    conformancePackComplianceSummaryListDecoded0?.append(structure0)
                }
            }
        }
        conformancePackComplianceSummaryList = conformancePackComplianceSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetDiscoveredResourceCountsInputBodyMiddleware: Middleware {
    public let id: String = "GetDiscoveredResourceCountsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDiscoveredResourceCountsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDiscoveredResourceCountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDiscoveredResourceCountsInput>
    public typealias MOutput = OperationOutput<GetDiscoveredResourceCountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDiscoveredResourceCountsOutputError>
}

extension GetDiscoveredResourceCountsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDiscoveredResourceCountsInput(limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), resourceTypes: \(String(describing: resourceTypes)))"}
}

extension GetDiscoveredResourceCountsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit
        case nextToken
        case resourceTypes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for resourcetypes0 in resourceTypes {
                try resourceTypesContainer.encode(resourcetypes0)
            }
        }
    }
}

public struct GetDiscoveredResourceCountsInputHeadersMiddleware: Middleware {
    public let id: String = "GetDiscoveredResourceCountsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDiscoveredResourceCountsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDiscoveredResourceCountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDiscoveredResourceCountsInput>
    public typealias MOutput = OperationOutput<GetDiscoveredResourceCountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDiscoveredResourceCountsOutputError>
}

public struct GetDiscoveredResourceCountsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDiscoveredResourceCountsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDiscoveredResourceCountsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDiscoveredResourceCountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDiscoveredResourceCountsInput>
    public typealias MOutput = OperationOutput<GetDiscoveredResourceCountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDiscoveredResourceCountsOutputError>
}

public struct GetDiscoveredResourceCountsInput: Equatable {
    /// <p>The maximum number of <a>ResourceCount</a> objects
    /// 			returned on each page. The default is 100. You cannot specify a
    /// 			number greater than 100. If you specify 0, AWS Config uses the
    /// 			default.</p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned on a previous page
    /// 			that you use to get the next page of results in a paginated
    /// 			response.</p>
    public let nextToken: String?
    /// <p>The comma-separated list that specifies the resource types that
    /// 			you want AWS Config to return (for example,
    /// 				<code>"AWS::EC2::Instance"</code>,
    /// 			<code>"AWS::IAM::User"</code>).</p>
    ///
    /// 		       <p>If a value for <code>resourceTypes</code> is not specified, AWS
    /// 			Config returns all resource types that AWS Config is recording in
    /// 			the region for your account.</p>
    /// 		       <note>
    /// 			         <p>If the configuration recorder is turned off, AWS Config
    /// 				returns an empty list of <a>ResourceCount</a>
    /// 				objects. If the configuration recorder is not recording a
    /// 				specific resource type (for example, S3 buckets), that resource
    /// 				type is not returned in the list of <a>ResourceCount</a> objects.</p>
    /// 		       </note>
    public let resourceTypes: [String]?

    public init (
        limit: Int = 0,
        nextToken: String? = nil,
        resourceTypes: [String]? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.resourceTypes = resourceTypes
    }
}

struct GetDiscoveredResourceCountsInputBody: Equatable {
    public let resourceTypes: [String]?
    public let limit: Int
    public let nextToken: String?
}

extension GetDiscoveredResourceCountsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit
        case nextToken
        case resourceTypes
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[String]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [String]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetDiscoveredResourceCountsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDiscoveredResourceCountsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDiscoveredResourceCountsOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDiscoveredResourceCountsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDiscoveredResourceCountsOutputResponse(nextToken: \(String(describing: nextToken)), resourceCounts: \(String(describing: resourceCounts)), totalDiscoveredResources: \(String(describing: totalDiscoveredResources)))"}
}

extension GetDiscoveredResourceCountsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDiscoveredResourceCountsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resourceCounts = output.resourceCounts
            self.totalDiscoveredResources = output.totalDiscoveredResources
        } else {
            self.nextToken = nil
            self.resourceCounts = nil
            self.totalDiscoveredResources = 0
        }
    }
}

public struct GetDiscoveredResourceCountsOutputResponse: Equatable {
    /// <p>The string that you use in a subsequent request to get the next
    /// 			page of results in a paginated response.</p>
    public let nextToken: String?
    /// <p>The list of <code>ResourceCount</code> objects. Each object is
    /// 			listed in descending order by the number of resources.</p>
    public let resourceCounts: [ResourceCount]?
    /// <p>The total number of resources that AWS Config is recording in
    /// 			the region for your account. If you specify resource types in the
    /// 			request, AWS Config returns only the total number of resources for
    /// 			those resource types.</p>
    ///
    ///
    /// 		       <p class="title">
    ///             <b>Example</b>
    ///          </p>
    ///          <ol>
    ///             <li>
    /// 				           <p>AWS Config is recording three resource types in the US
    /// 					East (Ohio) Region for your account: 25 EC2 instances, 20
    /// 					IAM users, and 15 S3 buckets, for a total of 60
    /// 					resources.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>You make a call to the
    /// 						<code>GetDiscoveredResourceCounts</code> action and
    /// 					specify the resource type,
    /// 						<code>"AWS::EC2::Instances"</code>, in the
    /// 					request.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>AWS Config returns 25 for
    /// 						<code>totalDiscoveredResources</code>.</p>
    /// 			         </li>
    ///          </ol>
    public let totalDiscoveredResources: Int

    public init (
        nextToken: String? = nil,
        resourceCounts: [ResourceCount]? = nil,
        totalDiscoveredResources: Int = 0
    )
    {
        self.nextToken = nextToken
        self.resourceCounts = resourceCounts
        self.totalDiscoveredResources = totalDiscoveredResources
    }
}

struct GetDiscoveredResourceCountsOutputResponseBody: Equatable {
    public let totalDiscoveredResources: Int
    public let resourceCounts: [ResourceCount]?
    public let nextToken: String?
}

extension GetDiscoveredResourceCountsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case resourceCounts
        case totalDiscoveredResources
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDiscoveredResourcesDecoded = try containerValues.decode(Int.self, forKey: .totalDiscoveredResources)
        totalDiscoveredResources = totalDiscoveredResourcesDecoded
        let resourceCountsContainer = try containerValues.decodeIfPresent([ResourceCount?].self, forKey: .resourceCounts)
        var resourceCountsDecoded0:[ResourceCount]? = nil
        if let resourceCountsContainer = resourceCountsContainer {
            resourceCountsDecoded0 = [ResourceCount]()
            for structure0 in resourceCountsContainer {
                if let structure0 = structure0 {
                    resourceCountsDecoded0?.append(structure0)
                }
            }
        }
        resourceCounts = resourceCountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetOrganizationConfigRuleDetailedStatusInputBodyMiddleware: Middleware {
    public let id: String = "GetOrganizationConfigRuleDetailedStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOrganizationConfigRuleDetailedStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOrganizationConfigRuleDetailedStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOrganizationConfigRuleDetailedStatusInput>
    public typealias MOutput = OperationOutput<GetOrganizationConfigRuleDetailedStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOrganizationConfigRuleDetailedStatusOutputError>
}

extension GetOrganizationConfigRuleDetailedStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOrganizationConfigRuleDetailedStatusInput(filters: \(String(describing: filters)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), organizationConfigRuleName: \(String(describing: organizationConfigRuleName)))"}
}

extension GetOrganizationConfigRuleDetailedStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
        case organizationConfigRuleName = "OrganizationConfigRuleName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationConfigRuleName = organizationConfigRuleName {
            try encodeContainer.encode(organizationConfigRuleName, forKey: .organizationConfigRuleName)
        }
    }
}

public struct GetOrganizationConfigRuleDetailedStatusInputHeadersMiddleware: Middleware {
    public let id: String = "GetOrganizationConfigRuleDetailedStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOrganizationConfigRuleDetailedStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOrganizationConfigRuleDetailedStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOrganizationConfigRuleDetailedStatusInput>
    public typealias MOutput = OperationOutput<GetOrganizationConfigRuleDetailedStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOrganizationConfigRuleDetailedStatusOutputError>
}

public struct GetOrganizationConfigRuleDetailedStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "GetOrganizationConfigRuleDetailedStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOrganizationConfigRuleDetailedStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOrganizationConfigRuleDetailedStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOrganizationConfigRuleDetailedStatusInput>
    public typealias MOutput = OperationOutput<GetOrganizationConfigRuleDetailedStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOrganizationConfigRuleDetailedStatusOutputError>
}

public struct GetOrganizationConfigRuleDetailedStatusInput: Equatable {
    /// <p>A <code>StatusDetailFilters</code> object.</p>
    public let filters: StatusDetailFilters?
    /// <p>The maximum number of <code>OrganizationConfigRuleDetailedStatus</code> returned on each page. If you do not specify a number, AWS Config uses the default. The default is 100.</p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned on a previous page that you use to get the next page of results in a paginated response. </p>
    public let nextToken: String?
    /// <p>The name of organization config rule for which you want status details for member accounts.</p>
    public let organizationConfigRuleName: String?

    public init (
        filters: StatusDetailFilters? = nil,
        limit: Int = 0,
        nextToken: String? = nil,
        organizationConfigRuleName: String? = nil
    )
    {
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
        self.organizationConfigRuleName = organizationConfigRuleName
    }
}

struct GetOrganizationConfigRuleDetailedStatusInputBody: Equatable {
    public let organizationConfigRuleName: String?
    public let filters: StatusDetailFilters?
    public let limit: Int
    public let nextToken: String?
}

extension GetOrganizationConfigRuleDetailedStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
        case organizationConfigRuleName = "OrganizationConfigRuleName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConfigRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationConfigRuleName)
        organizationConfigRuleName = organizationConfigRuleNameDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(StatusDetailFilters.self, forKey: .filters)
        filters = filtersDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetOrganizationConfigRuleDetailedStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOrganizationConfigRuleDetailedStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOrganizationConfigRuleException" : self = .noSuchOrganizationConfigRuleException(try NoSuchOrganizationConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAccessDeniedException" : self = .organizationAccessDeniedException(try OrganizationAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOrganizationConfigRuleDetailedStatusOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchOrganizationConfigRuleException(NoSuchOrganizationConfigRuleException)
    case organizationAccessDeniedException(OrganizationAccessDeniedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOrganizationConfigRuleDetailedStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOrganizationConfigRuleDetailedStatusOutputResponse(nextToken: \(String(describing: nextToken)), organizationConfigRuleDetailedStatus: \(String(describing: organizationConfigRuleDetailedStatus)))"}
}

extension GetOrganizationConfigRuleDetailedStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetOrganizationConfigRuleDetailedStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.organizationConfigRuleDetailedStatus = output.organizationConfigRuleDetailedStatus
        } else {
            self.nextToken = nil
            self.organizationConfigRuleDetailedStatus = nil
        }
    }
}

public struct GetOrganizationConfigRuleDetailedStatusOutputResponse: Equatable {
    /// <p>The <code>nextToken</code> string returned on a previous page that you use to get the next page of results in a paginated response. </p>
    public let nextToken: String?
    /// <p>A list of <code>MemberAccountStatus</code> objects.</p>
    public let organizationConfigRuleDetailedStatus: [MemberAccountStatus]?

    public init (
        nextToken: String? = nil,
        organizationConfigRuleDetailedStatus: [MemberAccountStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationConfigRuleDetailedStatus = organizationConfigRuleDetailedStatus
    }
}

struct GetOrganizationConfigRuleDetailedStatusOutputResponseBody: Equatable {
    public let organizationConfigRuleDetailedStatus: [MemberAccountStatus]?
    public let nextToken: String?
}

extension GetOrganizationConfigRuleDetailedStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case organizationConfigRuleDetailedStatus = "OrganizationConfigRuleDetailedStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConfigRuleDetailedStatusContainer = try containerValues.decodeIfPresent([MemberAccountStatus?].self, forKey: .organizationConfigRuleDetailedStatus)
        var organizationConfigRuleDetailedStatusDecoded0:[MemberAccountStatus]? = nil
        if let organizationConfigRuleDetailedStatusContainer = organizationConfigRuleDetailedStatusContainer {
            organizationConfigRuleDetailedStatusDecoded0 = [MemberAccountStatus]()
            for structure0 in organizationConfigRuleDetailedStatusContainer {
                if let structure0 = structure0 {
                    organizationConfigRuleDetailedStatusDecoded0?.append(structure0)
                }
            }
        }
        organizationConfigRuleDetailedStatus = organizationConfigRuleDetailedStatusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetOrganizationConformancePackDetailedStatusInputBodyMiddleware: Middleware {
    public let id: String = "GetOrganizationConformancePackDetailedStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOrganizationConformancePackDetailedStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOrganizationConformancePackDetailedStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOrganizationConformancePackDetailedStatusInput>
    public typealias MOutput = OperationOutput<GetOrganizationConformancePackDetailedStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOrganizationConformancePackDetailedStatusOutputError>
}

extension GetOrganizationConformancePackDetailedStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOrganizationConformancePackDetailedStatusInput(filters: \(String(describing: filters)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), organizationConformancePackName: \(String(describing: organizationConformancePackName)))"}
}

extension GetOrganizationConformancePackDetailedStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
        case organizationConformancePackName = "OrganizationConformancePackName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationConformancePackName = organizationConformancePackName {
            try encodeContainer.encode(organizationConformancePackName, forKey: .organizationConformancePackName)
        }
    }
}

public struct GetOrganizationConformancePackDetailedStatusInputHeadersMiddleware: Middleware {
    public let id: String = "GetOrganizationConformancePackDetailedStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOrganizationConformancePackDetailedStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOrganizationConformancePackDetailedStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOrganizationConformancePackDetailedStatusInput>
    public typealias MOutput = OperationOutput<GetOrganizationConformancePackDetailedStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOrganizationConformancePackDetailedStatusOutputError>
}

public struct GetOrganizationConformancePackDetailedStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "GetOrganizationConformancePackDetailedStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOrganizationConformancePackDetailedStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOrganizationConformancePackDetailedStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOrganizationConformancePackDetailedStatusInput>
    public typealias MOutput = OperationOutput<GetOrganizationConformancePackDetailedStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOrganizationConformancePackDetailedStatusOutputError>
}

public struct GetOrganizationConformancePackDetailedStatusInput: Equatable {
    /// <p>An <code>OrganizationResourceDetailedStatusFilters</code> object.</p>
    public let filters: OrganizationResourceDetailedStatusFilters?
    /// <p>The maximum number of <code>OrganizationConformancePackDetailedStatuses</code> returned on each page.
    /// 			If you do not specify a number, AWS Config uses the default. The default is 100. </p>
    public let limit: Int
    /// <p>The nextToken string returned on a previous page that you use to get the next page of results in a paginated response. </p>
    public let nextToken: String?
    /// <p>The name of organization conformance pack for which you want status details for member accounts.</p>
    public let organizationConformancePackName: String?

    public init (
        filters: OrganizationResourceDetailedStatusFilters? = nil,
        limit: Int = 0,
        nextToken: String? = nil,
        organizationConformancePackName: String? = nil
    )
    {
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
        self.organizationConformancePackName = organizationConformancePackName
    }
}

struct GetOrganizationConformancePackDetailedStatusInputBody: Equatable {
    public let organizationConformancePackName: String?
    public let filters: OrganizationResourceDetailedStatusFilters?
    public let limit: Int
    public let nextToken: String?
}

extension GetOrganizationConformancePackDetailedStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
        case organizationConformancePackName = "OrganizationConformancePackName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConformancePackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationConformancePackName)
        organizationConformancePackName = organizationConformancePackNameDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(OrganizationResourceDetailedStatusFilters.self, forKey: .filters)
        filters = filtersDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetOrganizationConformancePackDetailedStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOrganizationConformancePackDetailedStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOrganizationConformancePackException" : self = .noSuchOrganizationConformancePackException(try NoSuchOrganizationConformancePackException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAccessDeniedException" : self = .organizationAccessDeniedException(try OrganizationAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOrganizationConformancePackDetailedStatusOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchOrganizationConformancePackException(NoSuchOrganizationConformancePackException)
    case organizationAccessDeniedException(OrganizationAccessDeniedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOrganizationConformancePackDetailedStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOrganizationConformancePackDetailedStatusOutputResponse(nextToken: \(String(describing: nextToken)), organizationConformancePackDetailedStatuses: \(String(describing: organizationConformancePackDetailedStatuses)))"}
}

extension GetOrganizationConformancePackDetailedStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetOrganizationConformancePackDetailedStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.organizationConformancePackDetailedStatuses = output.organizationConformancePackDetailedStatuses
        } else {
            self.nextToken = nil
            self.organizationConformancePackDetailedStatuses = nil
        }
    }
}

public struct GetOrganizationConformancePackDetailedStatusOutputResponse: Equatable {
    /// <p>The nextToken string returned on a previous page that you use to get the next page of results in a paginated response. </p>
    public let nextToken: String?
    /// <p>A list of <code>OrganizationConformancePackDetailedStatus</code> objects. </p>
    public let organizationConformancePackDetailedStatuses: [OrganizationConformancePackDetailedStatus]?

    public init (
        nextToken: String? = nil,
        organizationConformancePackDetailedStatuses: [OrganizationConformancePackDetailedStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationConformancePackDetailedStatuses = organizationConformancePackDetailedStatuses
    }
}

struct GetOrganizationConformancePackDetailedStatusOutputResponseBody: Equatable {
    public let organizationConformancePackDetailedStatuses: [OrganizationConformancePackDetailedStatus]?
    public let nextToken: String?
}

extension GetOrganizationConformancePackDetailedStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case organizationConformancePackDetailedStatuses = "OrganizationConformancePackDetailedStatuses"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConformancePackDetailedStatusesContainer = try containerValues.decodeIfPresent([OrganizationConformancePackDetailedStatus?].self, forKey: .organizationConformancePackDetailedStatuses)
        var organizationConformancePackDetailedStatusesDecoded0:[OrganizationConformancePackDetailedStatus]? = nil
        if let organizationConformancePackDetailedStatusesContainer = organizationConformancePackDetailedStatusesContainer {
            organizationConformancePackDetailedStatusesDecoded0 = [OrganizationConformancePackDetailedStatus]()
            for structure0 in organizationConformancePackDetailedStatusesContainer {
                if let structure0 = structure0 {
                    organizationConformancePackDetailedStatusesDecoded0?.append(structure0)
                }
            }
        }
        organizationConformancePackDetailedStatuses = organizationConformancePackDetailedStatusesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetResourceConfigHistoryInputBodyMiddleware: Middleware {
    public let id: String = "GetResourceConfigHistoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceConfigHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceConfigHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceConfigHistoryInput>
    public typealias MOutput = OperationOutput<GetResourceConfigHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceConfigHistoryOutputError>
}

extension GetResourceConfigHistoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourceConfigHistoryInput(chronologicalOrder: \(String(describing: chronologicalOrder)), earlierTime: \(String(describing: earlierTime)), laterTime: \(String(describing: laterTime)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension GetResourceConfigHistoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case chronologicalOrder
        case earlierTime
        case laterTime
        case limit
        case nextToken
        case resourceId
        case resourceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chronologicalOrder = chronologicalOrder {
            try encodeContainer.encode(chronologicalOrder.rawValue, forKey: .chronologicalOrder)
        }
        if let earlierTime = earlierTime {
            try encodeContainer.encode(earlierTime.timeIntervalSince1970, forKey: .earlierTime)
        }
        if let laterTime = laterTime {
            try encodeContainer.encode(laterTime.timeIntervalSince1970, forKey: .laterTime)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }
}

public struct GetResourceConfigHistoryInputHeadersMiddleware: Middleware {
    public let id: String = "GetResourceConfigHistoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceConfigHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceConfigHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceConfigHistoryInput>
    public typealias MOutput = OperationOutput<GetResourceConfigHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceConfigHistoryOutputError>
}

public struct GetResourceConfigHistoryInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResourceConfigHistoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceConfigHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceConfigHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceConfigHistoryInput>
    public typealias MOutput = OperationOutput<GetResourceConfigHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceConfigHistoryOutputError>
}

/// <p>The input for the <a>GetResourceConfigHistory</a>
/// 			action.</p>
public struct GetResourceConfigHistoryInput: Equatable {
    /// <p>The chronological order for configuration items listed. By
    /// 			default, the results are listed in reverse chronological
    /// 			order.</p>
    public let chronologicalOrder: ChronologicalOrder?
    /// <p>The time stamp that indicates an earlier time. If not
    /// 			specified, the action returns paginated results that contain
    /// 			configuration items that start when the first configuration item was
    /// 			recorded.</p>
    public let earlierTime: Date?
    /// <p>The time stamp that indicates a later time. If not specified,
    /// 			current time is taken.</p>
    public let laterTime: Date?
    /// <p>The maximum number of configuration items returned on each
    /// 			page. The default is 10. You cannot specify a number greater than
    /// 			100. If you specify 0, AWS Config uses the default.</p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned on a previous page
    /// 			that you use to get the next page of results in a paginated
    /// 			response.</p>
    public let nextToken: String?
    /// <p>The ID of the resource (for example.,
    /// 			<code>sg-xxxxxx</code>).</p>
    public let resourceId: String?
    /// <p>The resource type.</p>
    public let resourceType: ResourceType?

    public init (
        chronologicalOrder: ChronologicalOrder? = nil,
        earlierTime: Date? = nil,
        laterTime: Date? = nil,
        limit: Int = 0,
        nextToken: String? = nil,
        resourceId: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.chronologicalOrder = chronologicalOrder
        self.earlierTime = earlierTime
        self.laterTime = laterTime
        self.limit = limit
        self.nextToken = nextToken
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct GetResourceConfigHistoryInputBody: Equatable {
    public let resourceType: ResourceType?
    public let resourceId: String?
    public let laterTime: Date?
    public let earlierTime: Date?
    public let chronologicalOrder: ChronologicalOrder?
    public let limit: Int
    public let nextToken: String?
}

extension GetResourceConfigHistoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case chronologicalOrder
        case earlierTime
        case laterTime
        case limit
        case nextToken
        case resourceId
        case resourceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let laterTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .laterTime)
        laterTime = laterTimeDecoded
        let earlierTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .earlierTime)
        earlierTime = earlierTimeDecoded
        let chronologicalOrderDecoded = try containerValues.decodeIfPresent(ChronologicalOrder.self, forKey: .chronologicalOrder)
        chronologicalOrder = chronologicalOrderDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetResourceConfigHistoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceConfigHistoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTimeRangeException" : self = .invalidTimeRangeException(try InvalidTimeRangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableConfigurationRecorderException" : self = .noAvailableConfigurationRecorderException(try NoAvailableConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotDiscoveredException" : self = .resourceNotDiscoveredException(try ResourceNotDiscoveredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourceConfigHistoryOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidTimeRangeException(InvalidTimeRangeException)
    case noAvailableConfigurationRecorderException(NoAvailableConfigurationRecorderException)
    case resourceNotDiscoveredException(ResourceNotDiscoveredException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceConfigHistoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourceConfigHistoryOutputResponse(configurationItems: \(String(describing: configurationItems)), nextToken: \(String(describing: nextToken)))"}
}

extension GetResourceConfigHistoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResourceConfigHistoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationItems = output.configurationItems
            self.nextToken = output.nextToken
        } else {
            self.configurationItems = nil
            self.nextToken = nil
        }
    }
}

/// <p>The output for the <a>GetResourceConfigHistory</a>
/// 			action.</p>
public struct GetResourceConfigHistoryOutputResponse: Equatable {
    /// <p>A list that contains the configuration history of one or more
    /// 			resources.</p>
    public let configurationItems: [ConfigurationItem]?
    /// <p>The string that you use in a subsequent request to get the next
    /// 			page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        configurationItems: [ConfigurationItem]? = nil,
        nextToken: String? = nil
    )
    {
        self.configurationItems = configurationItems
        self.nextToken = nextToken
    }
}

struct GetResourceConfigHistoryOutputResponseBody: Equatable {
    public let configurationItems: [ConfigurationItem]?
    public let nextToken: String?
}

extension GetResourceConfigHistoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationItems
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationItemsContainer = try containerValues.decodeIfPresent([ConfigurationItem?].self, forKey: .configurationItems)
        var configurationItemsDecoded0:[ConfigurationItem]? = nil
        if let configurationItemsContainer = configurationItemsContainer {
            configurationItemsDecoded0 = [ConfigurationItem]()
            for structure0 in configurationItemsContainer {
                if let structure0 = structure0 {
                    configurationItemsDecoded0?.append(structure0)
                }
            }
        }
        configurationItems = configurationItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetStoredQueryInputBodyMiddleware: Middleware {
    public let id: String = "GetStoredQueryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStoredQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStoredQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStoredQueryInput>
    public typealias MOutput = OperationOutput<GetStoredQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStoredQueryOutputError>
}

extension GetStoredQueryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStoredQueryInput(queryName: \(String(describing: queryName)))"}
}

extension GetStoredQueryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case queryName = "QueryName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryName = queryName {
            try encodeContainer.encode(queryName, forKey: .queryName)
        }
    }
}

public struct GetStoredQueryInputHeadersMiddleware: Middleware {
    public let id: String = "GetStoredQueryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStoredQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStoredQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStoredQueryInput>
    public typealias MOutput = OperationOutput<GetStoredQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStoredQueryOutputError>
}

public struct GetStoredQueryInputQueryItemMiddleware: Middleware {
    public let id: String = "GetStoredQueryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStoredQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStoredQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStoredQueryInput>
    public typealias MOutput = OperationOutput<GetStoredQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStoredQueryOutputError>
}

public struct GetStoredQueryInput: Equatable {
    /// <p>The name of the query.</p>
    public let queryName: String?

    public init (
        queryName: String? = nil
    )
    {
        self.queryName = queryName
    }
}

struct GetStoredQueryInputBody: Equatable {
    public let queryName: String?
}

extension GetStoredQueryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case queryName = "QueryName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryName)
        queryName = queryNameDecoded
    }
}

extension GetStoredQueryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStoredQueryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStoredQueryOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStoredQueryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStoredQueryOutputResponse(storedQuery: \(String(describing: storedQuery)))"}
}

extension GetStoredQueryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetStoredQueryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.storedQuery = output.storedQuery
        } else {
            self.storedQuery = nil
        }
    }
}

public struct GetStoredQueryOutputResponse: Equatable {
    /// <p>Returns a <code>StoredQuery</code> object.</p>
    public let storedQuery: StoredQuery?

    public init (
        storedQuery: StoredQuery? = nil
    )
    {
        self.storedQuery = storedQuery
    }
}

struct GetStoredQueryOutputResponseBody: Equatable {
    public let storedQuery: StoredQuery?
}

extension GetStoredQueryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case storedQuery = "StoredQuery"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storedQueryDecoded = try containerValues.decodeIfPresent(StoredQuery.self, forKey: .storedQuery)
        storedQuery = storedQueryDecoded
    }
}

extension GroupedResourceCount: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupName = "GroupName"
        case resourceCount = "ResourceCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if resourceCount != 0 {
            try encodeContainer.encode(resourceCount, forKey: .resourceCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let resourceCountDecoded = try containerValues.decode(Int.self, forKey: .resourceCount)
        resourceCount = resourceCountDecoded
    }
}

extension GroupedResourceCount: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GroupedResourceCount(groupName: \(String(describing: groupName)), resourceCount: \(String(describing: resourceCount)))"}
}

/// <p>The count of resources that are grouped by the group name.</p>
public struct GroupedResourceCount: Equatable {
    /// <p>The name of the group that can be region, account ID, or resource type. For example, region1, region2 if the region was chosen as <code>GroupByKey</code>.</p>
    public let groupName: String?
    /// <p>The number of resources in the group.</p>
    public let resourceCount: Int

    public init (
        groupName: String? = nil,
        resourceCount: Int = 0
    )
    {
        self.groupName = groupName
        self.resourceCount = resourceCount
    }
}

extension InsufficientDeliveryPolicyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsufficientDeliveryPolicyException(message: \(String(describing: message)))"}
}

extension InsufficientDeliveryPolicyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InsufficientDeliveryPolicyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your Amazon S3 bucket policy does not permit AWS Config to
/// 			write to it.</p>
public struct InsufficientDeliveryPolicyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientDeliveryPolicyExceptionBody: Equatable {
    public let message: String?
}

extension InsufficientDeliveryPolicyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientPermissionsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsufficientPermissionsException(message: \(String(describing: message)))"}
}

extension InsufficientPermissionsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InsufficientPermissionsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates one of the following errors:</p>
/// 		       <ul>
///             <li>
///                <p>For PutConfigRule, the rule cannot be created because the IAM role assigned to AWS Config lacks permissions to perform the config:Put* action.</p>
///             </li>
///             <li>
///                <p>For PutConfigRule, the AWS Lambda function cannot be invoked. Check the function ARN, and check the function's permissions.</p>
///             </li>
///             <li>
///                <p>For PutOrganizationConfigRule, organization config rule cannot be created because you do not have permissions to call IAM <code>GetRole</code> action or create a service linked role.</p>
///             </li>
///             <li>
///                <p>For PutConformancePack and PutOrganizationConformancePack, a conformance pack cannot be created because you do not have permissions: </p>
/// 				           <ul>
///                   <li>
///                      <p>To call IAM <code>GetRole</code> action or create a service linked role.</p>
///                   </li>
///                   <li>
///                      <p>To read Amazon S3 bucket.</p>
///                   </li>
///                </ul>
/// 			         </li>
///          </ul>
public struct InsufficientPermissionsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientPermissionsExceptionBody: Equatable {
    public let message: String?
}

extension InsufficientPermissionsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidConfigurationRecorderNameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidConfigurationRecorderNameException(message: \(String(describing: message)))"}
}

extension InvalidConfigurationRecorderNameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidConfigurationRecorderNameExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have provided a configuration recorder name that is not
/// 			valid.</p>
public struct InvalidConfigurationRecorderNameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidConfigurationRecorderNameExceptionBody: Equatable {
    public let message: String?
}

extension InvalidConfigurationRecorderNameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDeliveryChannelNameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDeliveryChannelNameException(message: \(String(describing: message)))"}
}

extension InvalidDeliveryChannelNameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidDeliveryChannelNameExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified delivery channel name is not valid.</p>
public struct InvalidDeliveryChannelNameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDeliveryChannelNameExceptionBody: Equatable {
    public let message: String?
}

extension InvalidDeliveryChannelNameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidExpressionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidExpressionException(message: \(String(describing: message)))"}
}

extension InvalidExpressionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidExpressionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The syntax of the query is incorrect.</p>
public struct InvalidExpressionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidExpressionExceptionBody: Equatable {
    public let message: String?
}

extension InvalidExpressionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLimitException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidLimitException(message: \(String(describing: message)))"}
}

extension InvalidLimitException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidLimitExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified limit is outside the allowable range.</p>
public struct InvalidLimitException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLimitExceptionBody: Equatable {
    public let message: String?
}

extension InvalidLimitExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified next token is invalid. Specify the
/// 				<code>nextToken</code> string that was returned in the previous
/// 			response to get the next page of results.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterValueException(message: \(String(describing: message)))"}
}

extension InvalidParameterValueException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more of the specified parameters are invalid. Verify
/// 			that your parameters are valid and try again.</p>
public struct InvalidParameterValueException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterValueExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterValueExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRecordingGroupException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRecordingGroupException(message: \(String(describing: message)))"}
}

extension InvalidRecordingGroupException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRecordingGroupExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS Config throws an exception if the recording group does not contain a valid list of resource types. Invalid values might also be incorrectly formatted.</p>
public struct InvalidRecordingGroupException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRecordingGroupExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRecordingGroupExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResultTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidResultTokenException(message: \(String(describing: message)))"}
}

extension InvalidResultTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidResultTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified <code>ResultToken</code> is invalid.</p>
public struct InvalidResultTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResultTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidResultTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRoleException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRoleException(message: \(String(describing: message)))"}
}

extension InvalidRoleException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRoleExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have provided a null or empty role ARN.</p>
public struct InvalidRoleException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRoleExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRoleExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3KeyPrefixException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidS3KeyPrefixException(message: \(String(describing: message)))"}
}

extension InvalidS3KeyPrefixException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidS3KeyPrefixExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified Amazon S3 key prefix is not valid.</p>
public struct InvalidS3KeyPrefixException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidS3KeyPrefixExceptionBody: Equatable {
    public let message: String?
}

extension InvalidS3KeyPrefixExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3KmsKeyArnException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidS3KmsKeyArnException(message: \(String(describing: message)))"}
}

extension InvalidS3KmsKeyArnException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidS3KmsKeyArnExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified Amazon KMS Key ARN is not valid.</p>
public struct InvalidS3KmsKeyArnException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidS3KmsKeyArnExceptionBody: Equatable {
    public let message: String?
}

extension InvalidS3KmsKeyArnExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSNSTopicARNException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSNSTopicARNException(message: \(String(describing: message)))"}
}

extension InvalidSNSTopicARNException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidSNSTopicARNExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified Amazon SNS topic does not exist.</p>
public struct InvalidSNSTopicARNException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSNSTopicARNExceptionBody: Equatable {
    public let message: String?
}

extension InvalidSNSTopicARNExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTimeRangeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTimeRangeException(message: \(String(describing: message)))"}
}

extension InvalidTimeRangeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTimeRangeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified time range is not valid. The earlier time is not
/// 			chronologically before the later time.</p>
public struct InvalidTimeRangeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTimeRangeExceptionBody: Equatable {
    public let message: String?
}

extension InvalidTimeRangeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LastDeliveryChannelDeleteFailedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LastDeliveryChannelDeleteFailedException(message: \(String(describing: message)))"}
}

extension LastDeliveryChannelDeleteFailedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LastDeliveryChannelDeleteFailedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You cannot delete the delivery channel you specified because
/// 			the configuration recorder is running.</p>
public struct LastDeliveryChannelDeleteFailedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LastDeliveryChannelDeleteFailedExceptionBody: Equatable {
    public let message: String?
}

extension LastDeliveryChannelDeleteFailedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>For <code>StartConfigRulesEvaluation</code> API, this exception
/// 			is thrown if an evaluation is in progress or if you call the <a>StartConfigRulesEvaluation</a> API more than once per
/// 			minute.</p>
/// 		       <p>For <code>PutConfigurationAggregator</code> API, this exception
/// 			is thrown if the number of accounts and aggregators exceeds the
/// 			limit.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAggregateDiscoveredResourcesInputBodyMiddleware: Middleware {
    public let id: String = "ListAggregateDiscoveredResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAggregateDiscoveredResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAggregateDiscoveredResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAggregateDiscoveredResourcesInput>
    public typealias MOutput = OperationOutput<ListAggregateDiscoveredResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAggregateDiscoveredResourcesOutputError>
}

extension ListAggregateDiscoveredResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAggregateDiscoveredResourcesInput(configurationAggregatorName: \(String(describing: configurationAggregatorName)), filters: \(String(describing: filters)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), resourceType: \(String(describing: resourceType)))"}
}

extension ListAggregateDiscoveredResourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationAggregatorName = configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }
}

public struct ListAggregateDiscoveredResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "ListAggregateDiscoveredResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAggregateDiscoveredResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAggregateDiscoveredResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAggregateDiscoveredResourcesInput>
    public typealias MOutput = OperationOutput<ListAggregateDiscoveredResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAggregateDiscoveredResourcesOutputError>
}

public struct ListAggregateDiscoveredResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAggregateDiscoveredResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAggregateDiscoveredResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAggregateDiscoveredResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAggregateDiscoveredResourcesInput>
    public typealias MOutput = OperationOutput<ListAggregateDiscoveredResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAggregateDiscoveredResourcesOutputError>
}

public struct ListAggregateDiscoveredResourcesInput: Equatable {
    /// <p>The name of the configuration aggregator. </p>
    public let configurationAggregatorName: String?
    /// <p>Filters the results based on the <code>ResourceFilters</code> object.</p>
    public let filters: ResourceFilters?
    /// <p>The maximum number of resource identifiers returned on each page. You cannot specify a number greater than 100. If you specify 0, AWS Config uses the default.</p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned on a previous page that you use to get the next page of results in a paginated response.</p>
    public let nextToken: String?
    /// <p>The type of resources that you want AWS Config to list in the response.</p>
    public let resourceType: ResourceType?

    public init (
        configurationAggregatorName: String? = nil,
        filters: ResourceFilters? = nil,
        limit: Int = 0,
        nextToken: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

struct ListAggregateDiscoveredResourcesInputBody: Equatable {
    public let configurationAggregatorName: String?
    public let resourceType: ResourceType?
    public let filters: ResourceFilters?
    public let limit: Int
    public let nextToken: String?
}

extension ListAggregateDiscoveredResourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case filters = "Filters"
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(ResourceFilters.self, forKey: .filters)
        filters = filtersDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAggregateDiscoveredResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAggregateDiscoveredResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAggregateDiscoveredResourcesOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAggregateDiscoveredResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAggregateDiscoveredResourcesOutputResponse(nextToken: \(String(describing: nextToken)), resourceIdentifiers: \(String(describing: resourceIdentifiers)))"}
}

extension ListAggregateDiscoveredResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAggregateDiscoveredResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resourceIdentifiers = output.resourceIdentifiers
        } else {
            self.nextToken = nil
            self.resourceIdentifiers = nil
        }
    }
}

public struct ListAggregateDiscoveredResourcesOutputResponse: Equatable {
    /// <p>The <code>nextToken</code> string returned on a previous page that you use to get the next page of results in a paginated response.</p>
    public let nextToken: String?
    /// <p>Returns a list of <code>ResourceIdentifiers</code> objects.</p>
    public let resourceIdentifiers: [AggregateResourceIdentifier]?

    public init (
        nextToken: String? = nil,
        resourceIdentifiers: [AggregateResourceIdentifier]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceIdentifiers = resourceIdentifiers
    }
}

struct ListAggregateDiscoveredResourcesOutputResponseBody: Equatable {
    public let resourceIdentifiers: [AggregateResourceIdentifier]?
    public let nextToken: String?
}

extension ListAggregateDiscoveredResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case resourceIdentifiers = "ResourceIdentifiers"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdentifiersContainer = try containerValues.decodeIfPresent([AggregateResourceIdentifier?].self, forKey: .resourceIdentifiers)
        var resourceIdentifiersDecoded0:[AggregateResourceIdentifier]? = nil
        if let resourceIdentifiersContainer = resourceIdentifiersContainer {
            resourceIdentifiersDecoded0 = [AggregateResourceIdentifier]()
            for structure0 in resourceIdentifiersContainer {
                if let structure0 = structure0 {
                    resourceIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        resourceIdentifiers = resourceIdentifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDiscoveredResourcesInputBodyMiddleware: Middleware {
    public let id: String = "ListDiscoveredResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDiscoveredResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDiscoveredResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDiscoveredResourcesInput>
    public typealias MOutput = OperationOutput<ListDiscoveredResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDiscoveredResourcesOutputError>
}

extension ListDiscoveredResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDiscoveredResourcesInput(includeDeletedResources: \(String(describing: includeDeletedResources)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), resourceIds: \(String(describing: resourceIds)), resourceName: \(String(describing: resourceName)), resourceType: \(String(describing: resourceType)))"}
}

extension ListDiscoveredResourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case includeDeletedResources
        case limit
        case nextToken
        case resourceIds
        case resourceName
        case resourceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if includeDeletedResources != false {
            try encodeContainer.encode(includeDeletedResources, forKey: .includeDeletedResources)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceIds = resourceIds {
            var resourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIds)
            for resourceidlist0 in resourceIds {
                try resourceIdsContainer.encode(resourceidlist0)
            }
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }
}

public struct ListDiscoveredResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "ListDiscoveredResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDiscoveredResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDiscoveredResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDiscoveredResourcesInput>
    public typealias MOutput = OperationOutput<ListDiscoveredResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDiscoveredResourcesOutputError>
}

public struct ListDiscoveredResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDiscoveredResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDiscoveredResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDiscoveredResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDiscoveredResourcesInput>
    public typealias MOutput = OperationOutput<ListDiscoveredResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDiscoveredResourcesOutputError>
}

/// <p></p>
public struct ListDiscoveredResourcesInput: Equatable {
    /// <p>Specifies whether AWS Config includes deleted resources in the
    /// 			results. By default, deleted resources are not included.</p>
    public let includeDeletedResources: Bool
    /// <p>The maximum number of resource identifiers returned on each
    /// 			page. The default is 100. You cannot specify a number greater than
    /// 			100. If you specify 0, AWS Config uses the default.</p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned on a previous page
    /// 			that you use to get the next page of results in a paginated
    /// 			response.</p>
    public let nextToken: String?
    /// <p>The IDs of only those resources that you want AWS Config to
    /// 			list in the response. If you do not specify this parameter, AWS
    /// 			Config lists all resources of the specified type that it has
    /// 			discovered.</p>
    public let resourceIds: [String]?
    /// <p>The custom name of only those resources that you want AWS
    /// 			Config to list in the response. If you do not specify this
    /// 			parameter, AWS Config lists all resources of the specified type that
    /// 			it has discovered.</p>
    public let resourceName: String?
    /// <p>The type of resources that you want AWS Config to list in the
    /// 			response.</p>
    public let resourceType: ResourceType?

    public init (
        includeDeletedResources: Bool = false,
        limit: Int = 0,
        nextToken: String? = nil,
        resourceIds: [String]? = nil,
        resourceName: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.includeDeletedResources = includeDeletedResources
        self.limit = limit
        self.nextToken = nextToken
        self.resourceIds = resourceIds
        self.resourceName = resourceName
        self.resourceType = resourceType
    }
}

struct ListDiscoveredResourcesInputBody: Equatable {
    public let resourceType: ResourceType?
    public let resourceIds: [String]?
    public let resourceName: String?
    public let limit: Int
    public let includeDeletedResources: Bool
    public let nextToken: String?
}

extension ListDiscoveredResourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case includeDeletedResources
        case limit
        case nextToken
        case resourceIds
        case resourceName
        case resourceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceIds)
        var resourceIdsDecoded0:[String]? = nil
        if let resourceIdsContainer = resourceIdsContainer {
            resourceIdsDecoded0 = [String]()
            for string0 in resourceIdsContainer {
                if let string0 = string0 {
                    resourceIdsDecoded0?.append(string0)
                }
            }
        }
        resourceIds = resourceIdsDecoded0
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let includeDeletedResourcesDecoded = try containerValues.decode(Bool.self, forKey: .includeDeletedResources)
        includeDeletedResources = includeDeletedResourcesDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDiscoveredResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDiscoveredResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableConfigurationRecorderException" : self = .noAvailableConfigurationRecorderException(try NoAvailableConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDiscoveredResourcesOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noAvailableConfigurationRecorderException(NoAvailableConfigurationRecorderException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDiscoveredResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDiscoveredResourcesOutputResponse(nextToken: \(String(describing: nextToken)), resourceIdentifiers: \(String(describing: resourceIdentifiers)))"}
}

extension ListDiscoveredResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDiscoveredResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resourceIdentifiers = output.resourceIdentifiers
        } else {
            self.nextToken = nil
            self.resourceIdentifiers = nil
        }
    }
}

/// <p></p>
public struct ListDiscoveredResourcesOutputResponse: Equatable {
    /// <p>The string that you use in a subsequent request to get the next
    /// 			page of results in a paginated response.</p>
    public let nextToken: String?
    /// <p>The details that identify a resource that is discovered by AWS
    /// 			Config, including the resource type, ID, and (if available) the
    /// 			custom resource name.</p>
    public let resourceIdentifiers: [ResourceIdentifier]?

    public init (
        nextToken: String? = nil,
        resourceIdentifiers: [ResourceIdentifier]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceIdentifiers = resourceIdentifiers
    }
}

struct ListDiscoveredResourcesOutputResponseBody: Equatable {
    public let resourceIdentifiers: [ResourceIdentifier]?
    public let nextToken: String?
}

extension ListDiscoveredResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case resourceIdentifiers
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdentifiersContainer = try containerValues.decodeIfPresent([ResourceIdentifier?].self, forKey: .resourceIdentifiers)
        var resourceIdentifiersDecoded0:[ResourceIdentifier]? = nil
        if let resourceIdentifiersContainer = resourceIdentifiersContainer {
            resourceIdentifiersDecoded0 = [ResourceIdentifier]()
            for structure0 in resourceIdentifiersContainer {
                if let structure0 = structure0 {
                    resourceIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        resourceIdentifiers = resourceIdentifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListStoredQueriesInputBodyMiddleware: Middleware {
    public let id: String = "ListStoredQueriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStoredQueriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStoredQueriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStoredQueriesInput>
    public typealias MOutput = OperationOutput<ListStoredQueriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStoredQueriesOutputError>
}

extension ListStoredQueriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStoredQueriesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListStoredQueriesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListStoredQueriesInputHeadersMiddleware: Middleware {
    public let id: String = "ListStoredQueriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStoredQueriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStoredQueriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStoredQueriesInput>
    public typealias MOutput = OperationOutput<ListStoredQueriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStoredQueriesOutputError>
}

public struct ListStoredQueriesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListStoredQueriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStoredQueriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStoredQueriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStoredQueriesInput>
    public typealias MOutput = OperationOutput<ListStoredQueriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStoredQueriesOutputError>
}

public struct ListStoredQueriesInput: Equatable {
    /// <p>The maximum number of results to be returned with a single call.</p>
    public let maxResults: Int
    /// <p>The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListStoredQueriesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int
}

extension ListStoredQueriesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListStoredQueriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStoredQueriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStoredQueriesOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStoredQueriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStoredQueriesOutputResponse(nextToken: \(String(describing: nextToken)), storedQueryMetadata: \(String(describing: storedQueryMetadata)))"}
}

extension ListStoredQueriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListStoredQueriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.storedQueryMetadata = output.storedQueryMetadata
        } else {
            self.nextToken = nil
            self.storedQueryMetadata = nil
        }
    }
}

public struct ListStoredQueriesOutputResponse: Equatable {
    /// <p>If the previous paginated request didn't return all of the remaining results, the response object's <code>NextToken</code> parameter value is set to a token.
    /// 			To retrieve the next set of results, call this action again and assign that token to the request object's <code>NextToken</code> parameter.
    /// 			If there are no remaining results, the previous response object's <code>NextToken</code> parameter is set to <code>null</code>. </p>
    public let nextToken: String?
    /// <p>A list of <code>StoredQueryMetadata</code> objects.</p>
    public let storedQueryMetadata: [StoredQueryMetadata]?

    public init (
        nextToken: String? = nil,
        storedQueryMetadata: [StoredQueryMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.storedQueryMetadata = storedQueryMetadata
    }
}

struct ListStoredQueriesOutputResponseBody: Equatable {
    public let storedQueryMetadata: [StoredQueryMetadata]?
    public let nextToken: String?
}

extension ListStoredQueriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case storedQueryMetadata = "StoredQueryMetadata"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storedQueryMetadataContainer = try containerValues.decodeIfPresent([StoredQueryMetadata?].self, forKey: .storedQueryMetadata)
        var storedQueryMetadataDecoded0:[StoredQueryMetadata]? = nil
        if let storedQueryMetadataContainer = storedQueryMetadataContainer {
            storedQueryMetadataDecoded0 = [StoredQueryMetadata]()
            for structure0 in storedQueryMetadataContainer {
                if let structure0 = structure0 {
                    storedQueryMetadataDecoded0?.append(structure0)
                }
            }
        }
        storedQueryMetadata = storedQueryMetadataDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The maximum number of tags returned on each page. The limit maximum is 50. You cannot specify a number greater than 50. If you specify 0, AWS Config uses the default. </p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned on a previous page that you use to get the next page of results in a paginated response. </p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resources are <code>ConfigRule</code>, <code>ConfigurationAggregator</code> and <code>AggregatorAuthorization</code>.</p>
    public let resourceArn: String?

    public init (
        limit: Int = 0,
        nextToken: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
    public let limit: Int
    public let nextToken: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The <code>nextToken</code> string returned on a previous page that you use to get the next page of results in a paginated response. </p>
    public let nextToken: String?
    /// <p>The tags for the resource.</p>
    public let tags: [Tag]?

    public init (
        nextToken: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let nextToken: String?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MaxActiveResourcesExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaxActiveResourcesExceededException(message: \(String(describing: message)))"}
}

extension MaxActiveResourcesExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MaxActiveResourcesExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the limit (100,000) of active custom resource types in your account.
/// 			Delete unused resources using <code>DeleteResourceConfig</code>.</p>
public struct MaxActiveResourcesExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MaxActiveResourcesExceededExceptionBody: Equatable {
    public let message: String?
}

extension MaxActiveResourcesExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaxNumberOfConfigRulesExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaxNumberOfConfigRulesExceededException(message: \(String(describing: message)))"}
}

extension MaxNumberOfConfigRulesExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MaxNumberOfConfigRulesExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Failed to add the AWS Config rule because the account already
/// 			contains the maximum number of 150 rules. Consider deleting any
/// 			deactivated rules before you add new rules.</p>
public struct MaxNumberOfConfigRulesExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MaxNumberOfConfigRulesExceededExceptionBody: Equatable {
    public let message: String?
}

extension MaxNumberOfConfigRulesExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaxNumberOfConfigurationRecordersExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaxNumberOfConfigurationRecordersExceededException(message: \(String(describing: message)))"}
}

extension MaxNumberOfConfigurationRecordersExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MaxNumberOfConfigurationRecordersExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the limit of the number of recorders you can
/// 			create.</p>
public struct MaxNumberOfConfigurationRecordersExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MaxNumberOfConfigurationRecordersExceededExceptionBody: Equatable {
    public let message: String?
}

extension MaxNumberOfConfigurationRecordersExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaxNumberOfConformancePacksExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaxNumberOfConformancePacksExceededException(message: \(String(describing: message)))"}
}

extension MaxNumberOfConformancePacksExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MaxNumberOfConformancePacksExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the limit (6) of the number of conformance packs in an account (6 conformance pack with 25 AWS Config rules per pack).</p>
public struct MaxNumberOfConformancePacksExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MaxNumberOfConformancePacksExceededExceptionBody: Equatable {
    public let message: String?
}

extension MaxNumberOfConformancePacksExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaxNumberOfDeliveryChannelsExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaxNumberOfDeliveryChannelsExceededException(message: \(String(describing: message)))"}
}

extension MaxNumberOfDeliveryChannelsExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MaxNumberOfDeliveryChannelsExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the limit of the number of delivery channels
/// 			you can create.</p>
public struct MaxNumberOfDeliveryChannelsExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MaxNumberOfDeliveryChannelsExceededExceptionBody: Equatable {
    public let message: String?
}

extension MaxNumberOfDeliveryChannelsExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaxNumberOfOrganizationConfigRulesExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaxNumberOfOrganizationConfigRulesExceededException(message: \(String(describing: message)))"}
}

extension MaxNumberOfOrganizationConfigRulesExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MaxNumberOfOrganizationConfigRulesExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the limit of the number of organization config rules you can create.</p>
public struct MaxNumberOfOrganizationConfigRulesExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MaxNumberOfOrganizationConfigRulesExceededExceptionBody: Equatable {
    public let message: String?
}

extension MaxNumberOfOrganizationConfigRulesExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaxNumberOfOrganizationConformancePacksExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaxNumberOfOrganizationConformancePacksExceededException(message: \(String(describing: message)))"}
}

extension MaxNumberOfOrganizationConformancePacksExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MaxNumberOfOrganizationConformancePacksExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the limit (6) of the number of organization conformance packs in an account (6 conformance pack with 25 AWS Config rules per pack per account).</p>
public struct MaxNumberOfOrganizationConformancePacksExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MaxNumberOfOrganizationConformancePacksExceededExceptionBody: Equatable {
    public let message: String?
}

extension MaxNumberOfOrganizationConformancePacksExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaxNumberOfRetentionConfigurationsExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaxNumberOfRetentionConfigurationsExceededException(message: \(String(describing: message)))"}
}

extension MaxNumberOfRetentionConfigurationsExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MaxNumberOfRetentionConfigurationsExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Failed to add the retention configuration because a retention configuration with that name already exists.</p>
public struct MaxNumberOfRetentionConfigurationsExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MaxNumberOfRetentionConfigurationsExceededExceptionBody: Equatable {
    public let message: String?
}

extension MaxNumberOfRetentionConfigurationsExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum MaximumExecutionFrequency {
    case oneHour
    case sixHours
    case threeHours
    case twelveHours
    case twentyfourHours
    case sdkUnknown(String)
}

extension MaximumExecutionFrequency : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MaximumExecutionFrequency] {
        return [
            .oneHour,
            .sixHours,
            .threeHours,
            .twelveHours,
            .twentyfourHours,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .oneHour: return "One_Hour"
        case .sixHours: return "Six_Hours"
        case .threeHours: return "Three_Hours"
        case .twelveHours: return "Twelve_Hours"
        case .twentyfourHours: return "TwentyFour_Hours"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MaximumExecutionFrequency(rawValue: rawValue) ?? MaximumExecutionFrequency.sdkUnknown(rawValue)
    }
}

public enum MemberAccountRuleStatus {
    case createFailed
    case createInProgress
    case createSuccessful
    case deleteFailed
    case deleteInProgress
    case deleteSuccessful
    case updateFailed
    case updateInProgress
    case updateSuccessful
    case sdkUnknown(String)
}

extension MemberAccountRuleStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MemberAccountRuleStatus] {
        return [
            .createFailed,
            .createInProgress,
            .createSuccessful,
            .deleteFailed,
            .deleteInProgress,
            .deleteSuccessful,
            .updateFailed,
            .updateInProgress,
            .updateSuccessful,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createFailed: return "CREATE_FAILED"
        case .createInProgress: return "CREATE_IN_PROGRESS"
        case .createSuccessful: return "CREATE_SUCCESSFUL"
        case .deleteFailed: return "DELETE_FAILED"
        case .deleteInProgress: return "DELETE_IN_PROGRESS"
        case .deleteSuccessful: return "DELETE_SUCCESSFUL"
        case .updateFailed: return "UPDATE_FAILED"
        case .updateInProgress: return "UPDATE_IN_PROGRESS"
        case .updateSuccessful: return "UPDATE_SUCCESSFUL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MemberAccountRuleStatus(rawValue: rawValue) ?? MemberAccountRuleStatus.sdkUnknown(rawValue)
    }
}

extension MemberAccountStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case configRuleName = "ConfigRuleName"
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case lastUpdateTime = "LastUpdateTime"
        case memberAccountRuleStatus = "MemberAccountRuleStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let configRuleName = configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let memberAccountRuleStatus = memberAccountRuleStatus {
            try encodeContainer.encode(memberAccountRuleStatus.rawValue, forKey: .memberAccountRuleStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let configRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let memberAccountRuleStatusDecoded = try containerValues.decodeIfPresent(MemberAccountRuleStatus.self, forKey: .memberAccountRuleStatus)
        memberAccountRuleStatus = memberAccountRuleStatusDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension MemberAccountStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MemberAccountStatus(accountId: \(String(describing: accountId)), configRuleName: \(String(describing: configRuleName)), errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), lastUpdateTime: \(String(describing: lastUpdateTime)), memberAccountRuleStatus: \(String(describing: memberAccountRuleStatus)))"}
}

/// <p>Organization config rule creation or deletion status in each member account. This includes the name of the rule, the status, error code and error message when the rule creation or deletion failed.</p>
public struct MemberAccountStatus: Equatable {
    /// <p>The 12-digit account ID of a member account.</p>
    public let accountId: String?
    /// <p>The name of config rule deployed in the member account.</p>
    public let configRuleName: String?
    /// <p>An error code that is returned when config rule creation or deletion failed in the member account.</p>
    public let errorCode: String?
    /// <p>An error message indicating that config rule account creation or deletion has failed due to an error in the member account.</p>
    public let errorMessage: String?
    /// <p>The timestamp of the last status update.</p>
    public let lastUpdateTime: Date?
    /// <p>Indicates deployment status for config rule in the member account.
    /// 			When master account calls <code>PutOrganizationConfigRule</code> action for the first time, config rule status is created in the member account.
    /// 			When master account calls <code>PutOrganizationConfigRule</code> action for the second time, config rule status is updated in the member account.
    /// 			Config rule status is deleted when the master account deletes <code>OrganizationConfigRule</code> and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>.
    /// 		</p>
    /// 		       <p> AWS Config sets the state of the rule to:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_SUCCESSFUL</code> when config rule has been created in the member account. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_IN_PROGRESS</code> when config rule is being created in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_FAILED</code> when config rule creation has failed in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_FAILED</code> when config rule deletion has failed in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_IN_PROGRESS</code> when config rule is being deleted in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_SUCCESSFUL</code> when config rule has been deleted in the member account. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UPDATE_SUCCESSFUL</code> when config rule has been updated in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UPDATE_IN_PROGRESS</code> when config rule is being updated in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UPDATE_FAILED</code> when config rule deletion has failed in the member account.</p>
    ///             </li>
    ///          </ul>
    public let memberAccountRuleStatus: MemberAccountRuleStatus?

    public init (
        accountId: String? = nil,
        configRuleName: String? = nil,
        errorCode: String? = nil,
        errorMessage: String? = nil,
        lastUpdateTime: Date? = nil,
        memberAccountRuleStatus: MemberAccountRuleStatus? = nil
    )
    {
        self.accountId = accountId
        self.configRuleName = configRuleName
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.lastUpdateTime = lastUpdateTime
        self.memberAccountRuleStatus = memberAccountRuleStatus
    }
}

public enum MessageType {
    case configurationitemchangenotification
    case configurationsnapshotdeliverycompleted
    case oversizedconfigurationitemchangenotification
    case schedulednotification
    case sdkUnknown(String)
}

extension MessageType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MessageType] {
        return [
            .configurationitemchangenotification,
            .configurationsnapshotdeliverycompleted,
            .oversizedconfigurationitemchangenotification,
            .schedulednotification,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .configurationitemchangenotification: return "ConfigurationItemChangeNotification"
        case .configurationsnapshotdeliverycompleted: return "ConfigurationSnapshotDeliveryCompleted"
        case .oversizedconfigurationitemchangenotification: return "OversizedConfigurationItemChangeNotification"
        case .schedulednotification: return "ScheduledNotification"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MessageType(rawValue: rawValue) ?? MessageType.sdkUnknown(rawValue)
    }
}

extension NoAvailableConfigurationRecorderException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoAvailableConfigurationRecorderException(message: \(String(describing: message)))"}
}

extension NoAvailableConfigurationRecorderException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoAvailableConfigurationRecorderExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There are no configuration recorders available to provide the
/// 			role needed to describe your resources. Create a configuration
/// 			recorder.</p>
public struct NoAvailableConfigurationRecorderException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoAvailableConfigurationRecorderExceptionBody: Equatable {
    public let message: String?
}

extension NoAvailableConfigurationRecorderExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoAvailableDeliveryChannelException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoAvailableDeliveryChannelException(message: \(String(describing: message)))"}
}

extension NoAvailableDeliveryChannelException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoAvailableDeliveryChannelExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is no delivery channel available to record
/// 			configurations.</p>
public struct NoAvailableDeliveryChannelException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoAvailableDeliveryChannelExceptionBody: Equatable {
    public let message: String?
}

extension NoAvailableDeliveryChannelExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoAvailableOrganizationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoAvailableOrganizationException(message: \(String(describing: message)))"}
}

extension NoAvailableOrganizationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoAvailableOrganizationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Organization is no longer available.</p>
public struct NoAvailableOrganizationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoAvailableOrganizationExceptionBody: Equatable {
    public let message: String?
}

extension NoAvailableOrganizationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoRunningConfigurationRecorderException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoRunningConfigurationRecorderException(message: \(String(describing: message)))"}
}

extension NoRunningConfigurationRecorderException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoRunningConfigurationRecorderExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is no configuration recorder running.</p>
public struct NoRunningConfigurationRecorderException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoRunningConfigurationRecorderExceptionBody: Equatable {
    public let message: String?
}

extension NoRunningConfigurationRecorderExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchBucketException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchBucketException(message: \(String(describing: message)))"}
}

extension NoSuchBucketException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoSuchBucketExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified Amazon S3 bucket does not exist.</p>
public struct NoSuchBucketException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchBucketExceptionBody: Equatable {
    public let message: String?
}

extension NoSuchBucketExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchConfigRuleException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchConfigRuleException(message: \(String(describing: message)))"}
}

extension NoSuchConfigRuleException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoSuchConfigRuleExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more AWS Config rules in the request are invalid. Verify
/// 			that the rule names are correct and try again.</p>
public struct NoSuchConfigRuleException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchConfigRuleExceptionBody: Equatable {
    public let message: String?
}

extension NoSuchConfigRuleExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchConfigRuleInConformancePackException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchConfigRuleInConformancePackException(message: \(String(describing: message)))"}
}

extension NoSuchConfigRuleInConformancePackException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoSuchConfigRuleInConformancePackExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS Config rule that you passed in the filter does not exist.</p>
public struct NoSuchConfigRuleInConformancePackException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchConfigRuleInConformancePackExceptionBody: Equatable {
    public let message: String?
}

extension NoSuchConfigRuleInConformancePackExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchConfigurationAggregatorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchConfigurationAggregatorException(message: \(String(describing: message)))"}
}

extension NoSuchConfigurationAggregatorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoSuchConfigurationAggregatorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have specified a configuration aggregator that does not exist.</p>
public struct NoSuchConfigurationAggregatorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchConfigurationAggregatorExceptionBody: Equatable {
    public let message: String?
}

extension NoSuchConfigurationAggregatorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchConfigurationRecorderException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchConfigurationRecorderException(message: \(String(describing: message)))"}
}

extension NoSuchConfigurationRecorderException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoSuchConfigurationRecorderExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have specified a configuration recorder that does not
/// 			exist.</p>
public struct NoSuchConfigurationRecorderException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchConfigurationRecorderExceptionBody: Equatable {
    public let message: String?
}

extension NoSuchConfigurationRecorderExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchConformancePackException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchConformancePackException(message: \(String(describing: message)))"}
}

extension NoSuchConformancePackException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoSuchConformancePackExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You specified one or more conformance packs that do not exist.</p>
public struct NoSuchConformancePackException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchConformancePackExceptionBody: Equatable {
    public let message: String?
}

extension NoSuchConformancePackExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchDeliveryChannelException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchDeliveryChannelException(message: \(String(describing: message)))"}
}

extension NoSuchDeliveryChannelException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoSuchDeliveryChannelExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have specified a delivery channel that does not
/// 			exist.</p>
public struct NoSuchDeliveryChannelException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchDeliveryChannelExceptionBody: Equatable {
    public let message: String?
}

extension NoSuchDeliveryChannelExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchOrganizationConfigRuleException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchOrganizationConfigRuleException(message: \(String(describing: message)))"}
}

extension NoSuchOrganizationConfigRuleException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoSuchOrganizationConfigRuleExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You specified one or more organization config rules that do not exist.</p>
public struct NoSuchOrganizationConfigRuleException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchOrganizationConfigRuleExceptionBody: Equatable {
    public let message: String?
}

extension NoSuchOrganizationConfigRuleExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchOrganizationConformancePackException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchOrganizationConformancePackException(message: \(String(describing: message)))"}
}

extension NoSuchOrganizationConformancePackException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoSuchOrganizationConformancePackExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS Config organization conformance pack that you passed in the filter does not exist.</p>
/// 		       <p>For DeleteOrganizationConformancePack, you tried to delete an organization conformance pack that does not exist.</p>
public struct NoSuchOrganizationConformancePackException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchOrganizationConformancePackExceptionBody: Equatable {
    public let message: String?
}

extension NoSuchOrganizationConformancePackExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchRemediationConfigurationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchRemediationConfigurationException(message: \(String(describing: message)))"}
}

extension NoSuchRemediationConfigurationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoSuchRemediationConfigurationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You specified an AWS Config rule without a remediation configuration.</p>
public struct NoSuchRemediationConfigurationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchRemediationConfigurationExceptionBody: Equatable {
    public let message: String?
}

extension NoSuchRemediationConfigurationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchRemediationExceptionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchRemediationExceptionException(message: \(String(describing: message)))"}
}

extension NoSuchRemediationExceptionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoSuchRemediationExceptionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You tried to delete a remediation exception that does not exist.</p>
public struct NoSuchRemediationExceptionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchRemediationExceptionExceptionBody: Equatable {
    public let message: String?
}

extension NoSuchRemediationExceptionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchRetentionConfigurationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchRetentionConfigurationException(message: \(String(describing: message)))"}
}

extension NoSuchRetentionConfigurationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoSuchRetentionConfigurationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have specified a retention configuration that does not exist.</p>
public struct NoSuchRetentionConfigurationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchRetentionConfigurationExceptionBody: Equatable {
    public let message: String?
}

extension NoSuchRetentionConfigurationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationAccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationAccessDeniedException(message: \(String(describing: message)))"}
}

extension OrganizationAccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OrganizationAccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>For <code>PutConfigurationAggregator</code> API, you can see this exception for the following reasons:</p>
/// 		       <ul>
///             <li>
///                <p>No permission to call <code>EnableAWSServiceAccess</code> API</p>
///             </li>
///             <li>
///                <p>The configuration aggregator cannot be updated because your AWS Organization management account or the delegated administrator role changed.
/// 				Delete this aggregator and create a new one with the current AWS Organization.</p>
///             </li>
///             <li>
///                <p>The configuration aggregator is associated with a previous AWS Organization and AWS Config cannot aggregate data with current AWS Organization.
/// 				Delete this aggregator and create a new one with the current AWS Organization.</p>
///             </li>
///             <li>
///                <p>You are not a registered delegated administrator for AWS Config with permissions to call <code>ListDelegatedAdministrators</code> API.
/// 			Ensure that the management account registers delagated administrator for AWS Config service principle name before the delegated administrator creates an aggregator.</p>
///             </li>
///          </ul>	
/// 		       <p>For all <code>OrganizationConfigRule</code> and <code>OrganizationConformancePack</code> APIs, AWS Config throws an exception if APIs are called from member accounts. All APIs must be called from organization master account.</p>
public struct OrganizationAccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OrganizationAccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension OrganizationAccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationAggregationSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allAwsRegions = "AllAwsRegions"
        case awsRegions = "AwsRegions"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allAwsRegions != false {
            try encodeContainer.encode(allAwsRegions, forKey: .allAwsRegions)
        }
        if let awsRegions = awsRegions {
            var awsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsRegions)
            for aggregatorregionlist0 in awsRegions {
                try awsRegionsContainer.encode(aggregatorregionlist0)
            }
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let awsRegionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .awsRegions)
        var awsRegionsDecoded0:[String]? = nil
        if let awsRegionsContainer = awsRegionsContainer {
            awsRegionsDecoded0 = [String]()
            for string0 in awsRegionsContainer {
                if let string0 = string0 {
                    awsRegionsDecoded0?.append(string0)
                }
            }
        }
        awsRegions = awsRegionsDecoded0
        let allAwsRegionsDecoded = try containerValues.decode(Bool.self, forKey: .allAwsRegions)
        allAwsRegions = allAwsRegionsDecoded
    }
}

extension OrganizationAggregationSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationAggregationSource(allAwsRegions: \(String(describing: allAwsRegions)), awsRegions: \(String(describing: awsRegions)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>This object contains regions to set up the aggregator and an IAM
/// 			role to retrieve organization details.</p>
public struct OrganizationAggregationSource: Equatable {
    /// <p>If true, aggregate existing AWS Config regions and future
    /// 			regions.</p>
    public let allAwsRegions: Bool
    /// <p>The source regions being aggregated.</p>
    public let awsRegions: [String]?
    /// <p>ARN of the IAM role used to retrieve AWS Organization details
    /// 			associated with the aggregator account.</p>
    public let roleArn: String?

    public init (
        allAwsRegions: Bool = false,
        awsRegions: [String]? = nil,
        roleArn: String? = nil
    )
    {
        self.allAwsRegions = allAwsRegions
        self.awsRegions = awsRegions
        self.roleArn = roleArn
    }
}

extension OrganizationAllFeaturesNotEnabledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationAllFeaturesNotEnabledException(message: \(String(describing: message)))"}
}

extension OrganizationAllFeaturesNotEnabledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OrganizationAllFeaturesNotEnabledExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS Config resource cannot be created because your organization does not have all features enabled.</p>
public struct OrganizationAllFeaturesNotEnabledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OrganizationAllFeaturesNotEnabledExceptionBody: Equatable {
    public let message: String?
}

extension OrganizationAllFeaturesNotEnabledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationConfigRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case excludedAccounts = "ExcludedAccounts"
        case lastUpdateTime = "LastUpdateTime"
        case organizationConfigRuleArn = "OrganizationConfigRuleArn"
        case organizationConfigRuleName = "OrganizationConfigRuleName"
        case organizationCustomRuleMetadata = "OrganizationCustomRuleMetadata"
        case organizationManagedRuleMetadata = "OrganizationManagedRuleMetadata"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludedAccounts = excludedAccounts {
            var excludedAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludedAccounts)
            for excludedaccounts0 in excludedAccounts {
                try excludedAccountsContainer.encode(excludedaccounts0)
            }
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let organizationConfigRuleArn = organizationConfigRuleArn {
            try encodeContainer.encode(organizationConfigRuleArn, forKey: .organizationConfigRuleArn)
        }
        if let organizationConfigRuleName = organizationConfigRuleName {
            try encodeContainer.encode(organizationConfigRuleName, forKey: .organizationConfigRuleName)
        }
        if let organizationCustomRuleMetadata = organizationCustomRuleMetadata {
            try encodeContainer.encode(organizationCustomRuleMetadata, forKey: .organizationCustomRuleMetadata)
        }
        if let organizationManagedRuleMetadata = organizationManagedRuleMetadata {
            try encodeContainer.encode(organizationManagedRuleMetadata, forKey: .organizationManagedRuleMetadata)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConfigRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationConfigRuleName)
        organizationConfigRuleName = organizationConfigRuleNameDecoded
        let organizationConfigRuleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationConfigRuleArn)
        organizationConfigRuleArn = organizationConfigRuleArnDecoded
        let organizationManagedRuleMetadataDecoded = try containerValues.decodeIfPresent(OrganizationManagedRuleMetadata.self, forKey: .organizationManagedRuleMetadata)
        organizationManagedRuleMetadata = organizationManagedRuleMetadataDecoded
        let organizationCustomRuleMetadataDecoded = try containerValues.decodeIfPresent(OrganizationCustomRuleMetadata.self, forKey: .organizationCustomRuleMetadata)
        organizationCustomRuleMetadata = organizationCustomRuleMetadataDecoded
        let excludedAccountsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .excludedAccounts)
        var excludedAccountsDecoded0:[String]? = nil
        if let excludedAccountsContainer = excludedAccountsContainer {
            excludedAccountsDecoded0 = [String]()
            for string0 in excludedAccountsContainer {
                if let string0 = string0 {
                    excludedAccountsDecoded0?.append(string0)
                }
            }
        }
        excludedAccounts = excludedAccountsDecoded0
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension OrganizationConfigRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationConfigRule(excludedAccounts: \(String(describing: excludedAccounts)), lastUpdateTime: \(String(describing: lastUpdateTime)), organizationConfigRuleArn: \(String(describing: organizationConfigRuleArn)), organizationConfigRuleName: \(String(describing: organizationConfigRuleName)), organizationCustomRuleMetadata: \(String(describing: organizationCustomRuleMetadata)), organizationManagedRuleMetadata: \(String(describing: organizationManagedRuleMetadata)))"}
}

/// <p>An organization config rule that has information about config rules that AWS Config creates in member accounts.</p>
public struct OrganizationConfigRule: Equatable {
    /// <p>A comma-separated list of accounts excluded from organization config rule.</p>
    public let excludedAccounts: [String]?
    /// <p>The timestamp of the last update.</p>
    public let lastUpdateTime: Date?
    /// <p>Amazon Resource Name (ARN) of organization config rule.</p>
    public let organizationConfigRuleArn: String?
    /// <p>The name that you assign to organization config rule.</p>
    public let organizationConfigRuleName: String?
    /// <p>An <code>OrganizationCustomRuleMetadata</code> object.</p>
    public let organizationCustomRuleMetadata: OrganizationCustomRuleMetadata?
    /// <p>An <code>OrganizationManagedRuleMetadata</code> object.</p>
    public let organizationManagedRuleMetadata: OrganizationManagedRuleMetadata?

    public init (
        excludedAccounts: [String]? = nil,
        lastUpdateTime: Date? = nil,
        organizationConfigRuleArn: String? = nil,
        organizationConfigRuleName: String? = nil,
        organizationCustomRuleMetadata: OrganizationCustomRuleMetadata? = nil,
        organizationManagedRuleMetadata: OrganizationManagedRuleMetadata? = nil
    )
    {
        self.excludedAccounts = excludedAccounts
        self.lastUpdateTime = lastUpdateTime
        self.organizationConfigRuleArn = organizationConfigRuleArn
        self.organizationConfigRuleName = organizationConfigRuleName
        self.organizationCustomRuleMetadata = organizationCustomRuleMetadata
        self.organizationManagedRuleMetadata = organizationManagedRuleMetadata
    }
}

extension OrganizationConfigRuleStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case lastUpdateTime = "LastUpdateTime"
        case organizationConfigRuleName = "OrganizationConfigRuleName"
        case organizationRuleStatus = "OrganizationRuleStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let organizationConfigRuleName = organizationConfigRuleName {
            try encodeContainer.encode(organizationConfigRuleName, forKey: .organizationConfigRuleName)
        }
        if let organizationRuleStatus = organizationRuleStatus {
            try encodeContainer.encode(organizationRuleStatus.rawValue, forKey: .organizationRuleStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConfigRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationConfigRuleName)
        organizationConfigRuleName = organizationConfigRuleNameDecoded
        let organizationRuleStatusDecoded = try containerValues.decodeIfPresent(OrganizationRuleStatus.self, forKey: .organizationRuleStatus)
        organizationRuleStatus = organizationRuleStatusDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension OrganizationConfigRuleStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationConfigRuleStatus(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), lastUpdateTime: \(String(describing: lastUpdateTime)), organizationConfigRuleName: \(String(describing: organizationConfigRuleName)), organizationRuleStatus: \(String(describing: organizationRuleStatus)))"}
}

/// <p>Returns the status for an organization config rule in an organization.</p>
public struct OrganizationConfigRuleStatus: Equatable {
    /// <p>An error code that is returned when organization config rule creation or deletion has failed.</p>
    public let errorCode: String?
    /// <p>An error message indicating that organization config rule creation or deletion failed due to an error.</p>
    public let errorMessage: String?
    /// <p>The timestamp of the last update.</p>
    public let lastUpdateTime: Date?
    /// <p>The name that you assign to organization config rule.</p>
    public let organizationConfigRuleName: String?
    /// <p>Indicates deployment status of an organization config rule.
    /// 			When master account calls PutOrganizationConfigRule action for the first time, config rule status is created in all the member accounts.
    /// 			When master account calls PutOrganizationConfigRule action for the second time, config rule status is updated in all the member accounts. Additionally, config rule status is updated when one or more member accounts join or leave an organization.
    /// 			Config rule status is deleted when the master account deletes OrganizationConfigRule in all the member accounts and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>.</p>
    /// 			      <p>AWS Config sets the state of the rule to:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_SUCCESSFUL</code> when an organization config rule has been successfully created in all the member accounts. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_IN_PROGRESS</code> when an organization config rule creation is in progress.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_FAILED</code> when an organization config rule creation failed in one or more member accounts within that organization.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_FAILED</code> when an organization config rule deletion failed in one or more member accounts within that organization.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_IN_PROGRESS</code> when an organization config rule deletion is in progress.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_SUCCESSFUL</code> when an organization config rule has been successfully deleted from all the member accounts.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UPDATE_SUCCESSFUL</code> when an organization config rule has been successfully updated in all the member accounts.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UPDATE_IN_PROGRESS</code> when an organization config rule update is in progress.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UPDATE_FAILED</code> when an organization config rule update failed in one or more member accounts within that organization.</p>
    ///             </li>
    ///          </ul>
    public let organizationRuleStatus: OrganizationRuleStatus?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil,
        lastUpdateTime: Date? = nil,
        organizationConfigRuleName: String? = nil,
        organizationRuleStatus: OrganizationRuleStatus? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.lastUpdateTime = lastUpdateTime
        self.organizationConfigRuleName = organizationConfigRuleName
        self.organizationRuleStatus = organizationRuleStatus
    }
}

public enum OrganizationConfigRuleTriggerType {
    case configurationItemChangeNotification
    case oversizedConfigurationItemChangeNotifcation
    case scheduledNotification
    case sdkUnknown(String)
}

extension OrganizationConfigRuleTriggerType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OrganizationConfigRuleTriggerType] {
        return [
            .configurationItemChangeNotification,
            .oversizedConfigurationItemChangeNotifcation,
            .scheduledNotification,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .configurationItemChangeNotification: return "ConfigurationItemChangeNotification"
        case .oversizedConfigurationItemChangeNotifcation: return "OversizedConfigurationItemChangeNotification"
        case .scheduledNotification: return "ScheduledNotification"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OrganizationConfigRuleTriggerType(rawValue: rawValue) ?? OrganizationConfigRuleTriggerType.sdkUnknown(rawValue)
    }
}

extension OrganizationConformancePack: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conformancePackInputParameters = "ConformancePackInputParameters"
        case deliveryS3Bucket = "DeliveryS3Bucket"
        case deliveryS3KeyPrefix = "DeliveryS3KeyPrefix"
        case excludedAccounts = "ExcludedAccounts"
        case lastUpdateTime = "LastUpdateTime"
        case organizationConformancePackArn = "OrganizationConformancePackArn"
        case organizationConformancePackName = "OrganizationConformancePackName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackInputParameters = conformancePackInputParameters {
            var conformancePackInputParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conformancePackInputParameters)
            for conformancepackinputparameters0 in conformancePackInputParameters {
                try conformancePackInputParametersContainer.encode(conformancepackinputparameters0)
            }
        }
        if let deliveryS3Bucket = deliveryS3Bucket {
            try encodeContainer.encode(deliveryS3Bucket, forKey: .deliveryS3Bucket)
        }
        if let deliveryS3KeyPrefix = deliveryS3KeyPrefix {
            try encodeContainer.encode(deliveryS3KeyPrefix, forKey: .deliveryS3KeyPrefix)
        }
        if let excludedAccounts = excludedAccounts {
            var excludedAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludedAccounts)
            for excludedaccounts0 in excludedAccounts {
                try excludedAccountsContainer.encode(excludedaccounts0)
            }
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let organizationConformancePackArn = organizationConformancePackArn {
            try encodeContainer.encode(organizationConformancePackArn, forKey: .organizationConformancePackArn)
        }
        if let organizationConformancePackName = organizationConformancePackName {
            try encodeContainer.encode(organizationConformancePackName, forKey: .organizationConformancePackName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConformancePackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationConformancePackName)
        organizationConformancePackName = organizationConformancePackNameDecoded
        let organizationConformancePackArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationConformancePackArn)
        organizationConformancePackArn = organizationConformancePackArnDecoded
        let deliveryS3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deliveryS3Bucket)
        deliveryS3Bucket = deliveryS3BucketDecoded
        let deliveryS3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deliveryS3KeyPrefix)
        deliveryS3KeyPrefix = deliveryS3KeyPrefixDecoded
        let conformancePackInputParametersContainer = try containerValues.decodeIfPresent([ConformancePackInputParameter?].self, forKey: .conformancePackInputParameters)
        var conformancePackInputParametersDecoded0:[ConformancePackInputParameter]? = nil
        if let conformancePackInputParametersContainer = conformancePackInputParametersContainer {
            conformancePackInputParametersDecoded0 = [ConformancePackInputParameter]()
            for structure0 in conformancePackInputParametersContainer {
                if let structure0 = structure0 {
                    conformancePackInputParametersDecoded0?.append(structure0)
                }
            }
        }
        conformancePackInputParameters = conformancePackInputParametersDecoded0
        let excludedAccountsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .excludedAccounts)
        var excludedAccountsDecoded0:[String]? = nil
        if let excludedAccountsContainer = excludedAccountsContainer {
            excludedAccountsDecoded0 = [String]()
            for string0 in excludedAccountsContainer {
                if let string0 = string0 {
                    excludedAccountsDecoded0?.append(string0)
                }
            }
        }
        excludedAccounts = excludedAccountsDecoded0
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension OrganizationConformancePack: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationConformancePack(conformancePackInputParameters: \(String(describing: conformancePackInputParameters)), deliveryS3Bucket: \(String(describing: deliveryS3Bucket)), deliveryS3KeyPrefix: \(String(describing: deliveryS3KeyPrefix)), excludedAccounts: \(String(describing: excludedAccounts)), lastUpdateTime: \(String(describing: lastUpdateTime)), organizationConformancePackArn: \(String(describing: organizationConformancePackArn)), organizationConformancePackName: \(String(describing: organizationConformancePackName)))"}
}

/// <p>An organization conformance pack that has information about conformance packs that AWS Config creates in member accounts. </p>
public struct OrganizationConformancePack: Equatable {
    /// <p>A list of <code>ConformancePackInputParameter</code> objects.</p>
    public let conformancePackInputParameters: [ConformancePackInputParameter]?
    /// <p>Amazon S3 bucket where AWS Config stores conformance pack templates.  </p>
    /// 		       <note>
    ///             <p>This field is optional.</p>
    ///          </note>
    public let deliveryS3Bucket: String?
    /// <p>Any folder structure you want to add to an Amazon S3 bucket.</p>
    /// 		       <note>
    ///             <p>This field is optional.</p>
    ///          </note>
    public let deliveryS3KeyPrefix: String?
    /// <p>A comma-separated list of accounts excluded from organization conformance pack.</p>
    public let excludedAccounts: [String]?
    /// <p>Last time when organization conformation pack was updated.</p>
    public let lastUpdateTime: Date?
    /// <p>Amazon Resource Name (ARN) of organization conformance pack.</p>
    public let organizationConformancePackArn: String?
    /// <p>The name you assign to an organization conformance pack.</p>
    public let organizationConformancePackName: String?

    public init (
        conformancePackInputParameters: [ConformancePackInputParameter]? = nil,
        deliveryS3Bucket: String? = nil,
        deliveryS3KeyPrefix: String? = nil,
        excludedAccounts: [String]? = nil,
        lastUpdateTime: Date? = nil,
        organizationConformancePackArn: String? = nil,
        organizationConformancePackName: String? = nil
    )
    {
        self.conformancePackInputParameters = conformancePackInputParameters
        self.deliveryS3Bucket = deliveryS3Bucket
        self.deliveryS3KeyPrefix = deliveryS3KeyPrefix
        self.excludedAccounts = excludedAccounts
        self.lastUpdateTime = lastUpdateTime
        self.organizationConformancePackArn = organizationConformancePackArn
        self.organizationConformancePackName = organizationConformancePackName
    }
}

extension OrganizationConformancePackDetailedStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case conformancePackName = "ConformancePackName"
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case lastUpdateTime = "LastUpdateTime"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let conformancePackName = conformancePackName {
            try encodeContainer.encode(conformancePackName, forKey: .conformancePackName)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let conformancePackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conformancePackName)
        conformancePackName = conformancePackNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OrganizationResourceDetailedStatus.self, forKey: .status)
        status = statusDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension OrganizationConformancePackDetailedStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationConformancePackDetailedStatus(accountId: \(String(describing: accountId)), conformancePackName: \(String(describing: conformancePackName)), errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), lastUpdateTime: \(String(describing: lastUpdateTime)), status: \(String(describing: status)))"}
}

/// <p>Organization conformance pack creation or deletion status in each member account.
/// 			This includes the name of the conformance pack, the status, error code and error message
/// 			when the conformance pack creation or deletion failed. </p>
public struct OrganizationConformancePackDetailedStatus: Equatable {
    /// <p>The 12-digit account ID of a member account.</p>
    public let accountId: String?
    /// <p>The name of conformance pack deployed in the member account.</p>
    public let conformancePackName: String?
    /// <p>An error code that is returned when conformance pack creation or
    /// 			deletion failed in the member account. </p>
    public let errorCode: String?
    /// <p>An error message indicating that conformance pack account creation or deletion
    /// 			has failed due to an error in the member account. </p>
    public let errorMessage: String?
    /// <p>The timestamp of the last status update.</p>
    public let lastUpdateTime: Date?
    /// <p>Indicates deployment status for conformance pack in a member account.
    /// 			When master account calls <code>PutOrganizationConformancePack</code> action for the first time, conformance pack status is created in the member account.
    /// 			When master account calls <code>PutOrganizationConformancePack</code> action for the second time, conformance pack status is updated in the member account.
    /// 			Conformance pack status is deleted when the master account deletes <code>OrganizationConformancePack</code> and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>.
    /// 		</p>
    /// 		       <p> AWS Config sets the state of the conformance pack to:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_SUCCESSFUL</code> when conformance pack has been created in the member account. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_IN_PROGRESS</code> when conformance pack is being created in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_FAILED</code> when conformance pack creation has failed in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_FAILED</code> when conformance pack deletion has failed in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_IN_PROGRESS</code> when conformance pack is being deleted in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_SUCCESSFUL</code> when conformance pack has been deleted in the member account. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UPDATE_SUCCESSFUL</code> when conformance pack has been updated in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UPDATE_IN_PROGRESS</code> when conformance pack is being updated in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UPDATE_FAILED</code> when conformance pack deletion has failed in the member account.</p>
    ///             </li>
    ///          </ul>
    public let status: OrganizationResourceDetailedStatus?

    public init (
        accountId: String? = nil,
        conformancePackName: String? = nil,
        errorCode: String? = nil,
        errorMessage: String? = nil,
        lastUpdateTime: Date? = nil,
        status: OrganizationResourceDetailedStatus? = nil
    )
    {
        self.accountId = accountId
        self.conformancePackName = conformancePackName
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.lastUpdateTime = lastUpdateTime
        self.status = status
    }
}

extension OrganizationConformancePackStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case lastUpdateTime = "LastUpdateTime"
        case organizationConformancePackName = "OrganizationConformancePackName"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let organizationConformancePackName = organizationConformancePackName {
            try encodeContainer.encode(organizationConformancePackName, forKey: .organizationConformancePackName)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConformancePackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationConformancePackName)
        organizationConformancePackName = organizationConformancePackNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OrganizationResourceStatus.self, forKey: .status)
        status = statusDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension OrganizationConformancePackStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationConformancePackStatus(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), lastUpdateTime: \(String(describing: lastUpdateTime)), organizationConformancePackName: \(String(describing: organizationConformancePackName)), status: \(String(describing: status)))"}
}

/// <p>Returns the status for an organization conformance pack in an organization.</p>
public struct OrganizationConformancePackStatus: Equatable {
    /// <p>An error code that is returned when organization conformance pack creation or deletion has failed in a member account. </p>
    public let errorCode: String?
    /// <p>An error message indicating that organization conformance pack creation or deletion failed due to an error. </p>
    public let errorMessage: String?
    /// <p>The timestamp of the last update.</p>
    public let lastUpdateTime: Date?
    /// <p>The name that you assign to organization conformance pack.</p>
    public let organizationConformancePackName: String?
    /// <p>Indicates deployment status of an organization conformance pack.
    /// 			When master account calls PutOrganizationConformancePack for the first time,
    /// 			conformance pack status is created in all the member accounts.
    /// 			When master account calls PutOrganizationConformancePack for the second time,
    /// 			conformance pack status is updated in all the member accounts.
    /// 			Additionally, conformance pack status is updated when one or more member accounts join or leave an
    /// 			organization.
    /// 			Conformance pack status is deleted when the master account deletes
    /// 			OrganizationConformancePack in all the member accounts and disables service
    /// 			access for <code>config-multiaccountsetup.amazonaws.com</code>.</p>
    /// 		       <p>AWS Config sets the state of the conformance pack to:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_SUCCESSFUL</code> when an organization conformance pack has been successfully created in all the member accounts. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_IN_PROGRESS</code> when an organization conformance pack creation is in progress.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_FAILED</code> when an organization conformance pack creation failed in one or more member accounts within that organization.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_FAILED</code> when an organization conformance pack deletion failed in one or more member accounts within that organization.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_IN_PROGRESS</code> when an organization conformance pack deletion is in progress.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_SUCCESSFUL</code> when an organization conformance pack has been successfully deleted from all the member accounts.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UPDATE_SUCCESSFUL</code> when an organization conformance pack has been successfully updated in all the member accounts.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UPDATE_IN_PROGRESS</code> when an organization conformance pack update is in progress.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UPDATE_FAILED</code> when an organization conformance pack update failed in one or more member accounts within that organization.</p>
    ///             </li>
    ///          </ul>
    public let status: OrganizationResourceStatus?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil,
        lastUpdateTime: Date? = nil,
        organizationConformancePackName: String? = nil,
        status: OrganizationResourceStatus? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.lastUpdateTime = lastUpdateTime
        self.organizationConformancePackName = organizationConformancePackName
        self.status = status
    }
}

extension OrganizationConformancePackTemplateValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationConformancePackTemplateValidationException(message: \(String(describing: message)))"}
}

extension OrganizationConformancePackTemplateValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OrganizationConformancePackTemplateValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have specified a template that is not valid or supported.</p>
public struct OrganizationConformancePackTemplateValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OrganizationConformancePackTemplateValidationExceptionBody: Equatable {
    public let message: String?
}

extension OrganizationConformancePackTemplateValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationCustomRuleMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case inputParameters = "InputParameters"
        case lambdaFunctionArn = "LambdaFunctionArn"
        case maximumExecutionFrequency = "MaximumExecutionFrequency"
        case organizationConfigRuleTriggerTypes = "OrganizationConfigRuleTriggerTypes"
        case resourceIdScope = "ResourceIdScope"
        case resourceTypesScope = "ResourceTypesScope"
        case tagKeyScope = "TagKeyScope"
        case tagValueScope = "TagValueScope"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let inputParameters = inputParameters {
            try encodeContainer.encode(inputParameters, forKey: .inputParameters)
        }
        if let lambdaFunctionArn = lambdaFunctionArn {
            try encodeContainer.encode(lambdaFunctionArn, forKey: .lambdaFunctionArn)
        }
        if let maximumExecutionFrequency = maximumExecutionFrequency {
            try encodeContainer.encode(maximumExecutionFrequency.rawValue, forKey: .maximumExecutionFrequency)
        }
        if let organizationConfigRuleTriggerTypes = organizationConfigRuleTriggerTypes {
            var organizationConfigRuleTriggerTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationConfigRuleTriggerTypes)
            for organizationconfigruletriggertypes0 in organizationConfigRuleTriggerTypes {
                try organizationConfigRuleTriggerTypesContainer.encode(organizationconfigruletriggertypes0.rawValue)
            }
        }
        if let resourceIdScope = resourceIdScope {
            try encodeContainer.encode(resourceIdScope, forKey: .resourceIdScope)
        }
        if let resourceTypesScope = resourceTypesScope {
            var resourceTypesScopeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypesScope)
            for resourcetypesscope0 in resourceTypesScope {
                try resourceTypesScopeContainer.encode(resourcetypesscope0)
            }
        }
        if let tagKeyScope = tagKeyScope {
            try encodeContainer.encode(tagKeyScope, forKey: .tagKeyScope)
        }
        if let tagValueScope = tagValueScope {
            try encodeContainer.encode(tagValueScope, forKey: .tagValueScope)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let lambdaFunctionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lambdaFunctionArn)
        lambdaFunctionArn = lambdaFunctionArnDecoded
        let organizationConfigRuleTriggerTypesContainer = try containerValues.decodeIfPresent([OrganizationConfigRuleTriggerType?].self, forKey: .organizationConfigRuleTriggerTypes)
        var organizationConfigRuleTriggerTypesDecoded0:[OrganizationConfigRuleTriggerType]? = nil
        if let organizationConfigRuleTriggerTypesContainer = organizationConfigRuleTriggerTypesContainer {
            organizationConfigRuleTriggerTypesDecoded0 = [OrganizationConfigRuleTriggerType]()
            for string0 in organizationConfigRuleTriggerTypesContainer {
                if let string0 = string0 {
                    organizationConfigRuleTriggerTypesDecoded0?.append(string0)
                }
            }
        }
        organizationConfigRuleTriggerTypes = organizationConfigRuleTriggerTypesDecoded0
        let inputParametersDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputParameters)
        inputParameters = inputParametersDecoded
        let maximumExecutionFrequencyDecoded = try containerValues.decodeIfPresent(MaximumExecutionFrequency.self, forKey: .maximumExecutionFrequency)
        maximumExecutionFrequency = maximumExecutionFrequencyDecoded
        let resourceTypesScopeContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceTypesScope)
        var resourceTypesScopeDecoded0:[String]? = nil
        if let resourceTypesScopeContainer = resourceTypesScopeContainer {
            resourceTypesScopeDecoded0 = [String]()
            for string0 in resourceTypesScopeContainer {
                if let string0 = string0 {
                    resourceTypesScopeDecoded0?.append(string0)
                }
            }
        }
        resourceTypesScope = resourceTypesScopeDecoded0
        let resourceIdScopeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceIdScope)
        resourceIdScope = resourceIdScopeDecoded
        let tagKeyScopeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tagKeyScope)
        tagKeyScope = tagKeyScopeDecoded
        let tagValueScopeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tagValueScope)
        tagValueScope = tagValueScopeDecoded
    }
}

extension OrganizationCustomRuleMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationCustomRuleMetadata(description: \(String(describing: description)), inputParameters: \(String(describing: inputParameters)), lambdaFunctionArn: \(String(describing: lambdaFunctionArn)), maximumExecutionFrequency: \(String(describing: maximumExecutionFrequency)), organizationConfigRuleTriggerTypes: \(String(describing: organizationConfigRuleTriggerTypes)), resourceIdScope: \(String(describing: resourceIdScope)), resourceTypesScope: \(String(describing: resourceTypesScope)), tagKeyScope: \(String(describing: tagKeyScope)), tagValueScope: \(String(describing: tagValueScope)))"}
}

/// <p>An object that specifies organization custom rule metadata such as resource type, resource ID of AWS resource, Lamdba function ARN,
/// 			and organization trigger types that trigger AWS Config to evaluate your AWS resources against a rule.
/// 			It also provides the frequency with which you want AWS Config to run evaluations for the rule if the trigger type is periodic.</p>
public struct OrganizationCustomRuleMetadata: Equatable {
    /// <p>The description that you provide for organization config rule.</p>
    public let description: String?
    /// <p>A string, in JSON format, that is passed to organization config rule Lambda function.</p>
    public let inputParameters: String?
    /// <p>The lambda function ARN.</p>
    public let lambdaFunctionArn: String?
    /// <p>The maximum frequency with which AWS Config runs evaluations for a rule.
    /// 			Your custom rule is triggered when AWS Config delivers the configuration snapshot. For more information, see <a>ConfigSnapshotDeliveryProperties</a>.</p>
    /// 		       <note>
    ///             <p>By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid
    /// 			value for the <code>MaximumExecutionFrequency</code> parameter.</p>
    ///          </note>
    public let maximumExecutionFrequency: MaximumExecutionFrequency?
    /// <p>The type of notification that triggers AWS Config to run an evaluation for a rule. You can specify the following notification types:</p>
    /// 		
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ConfigurationItemChangeNotification</code> - Triggers an evaluation when AWS Config delivers a configuration item as a result of a resource change.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OversizedConfigurationItemChangeNotification</code> - Triggers an evaluation when AWS Config delivers an oversized configuration item.
    /// 			         	AWS Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ScheduledNotification</code> - Triggers a periodic evaluation at the frequency specified for <code>MaximumExecutionFrequency</code>.</p>
    ///             </li>
    ///          </ul>
    public let organizationConfigRuleTriggerTypes: [OrganizationConfigRuleTriggerType]?
    /// <p>The ID of the AWS resource that was evaluated.</p>
    public let resourceIdScope: String?
    /// <p>The type of the AWS resource that was evaluated.</p>
    public let resourceTypesScope: [String]?
    /// <p>One part of a key-value pair that make up a tag.
    /// 			A key is a general label that acts like a category for more specific tag values. </p>
    public let tagKeyScope: String?
    /// <p>The optional part of a key-value pair that make up a tag.
    /// 			A value acts as a descriptor within a tag category (key). </p>
    public let tagValueScope: String?

    public init (
        description: String? = nil,
        inputParameters: String? = nil,
        lambdaFunctionArn: String? = nil,
        maximumExecutionFrequency: MaximumExecutionFrequency? = nil,
        organizationConfigRuleTriggerTypes: [OrganizationConfigRuleTriggerType]? = nil,
        resourceIdScope: String? = nil,
        resourceTypesScope: [String]? = nil,
        tagKeyScope: String? = nil,
        tagValueScope: String? = nil
    )
    {
        self.description = description
        self.inputParameters = inputParameters
        self.lambdaFunctionArn = lambdaFunctionArn
        self.maximumExecutionFrequency = maximumExecutionFrequency
        self.organizationConfigRuleTriggerTypes = organizationConfigRuleTriggerTypes
        self.resourceIdScope = resourceIdScope
        self.resourceTypesScope = resourceTypesScope
        self.tagKeyScope = tagKeyScope
        self.tagValueScope = tagValueScope
    }
}

extension OrganizationManagedRuleMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case inputParameters = "InputParameters"
        case maximumExecutionFrequency = "MaximumExecutionFrequency"
        case resourceIdScope = "ResourceIdScope"
        case resourceTypesScope = "ResourceTypesScope"
        case ruleIdentifier = "RuleIdentifier"
        case tagKeyScope = "TagKeyScope"
        case tagValueScope = "TagValueScope"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let inputParameters = inputParameters {
            try encodeContainer.encode(inputParameters, forKey: .inputParameters)
        }
        if let maximumExecutionFrequency = maximumExecutionFrequency {
            try encodeContainer.encode(maximumExecutionFrequency.rawValue, forKey: .maximumExecutionFrequency)
        }
        if let resourceIdScope = resourceIdScope {
            try encodeContainer.encode(resourceIdScope, forKey: .resourceIdScope)
        }
        if let resourceTypesScope = resourceTypesScope {
            var resourceTypesScopeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypesScope)
            for resourcetypesscope0 in resourceTypesScope {
                try resourceTypesScopeContainer.encode(resourcetypesscope0)
            }
        }
        if let ruleIdentifier = ruleIdentifier {
            try encodeContainer.encode(ruleIdentifier, forKey: .ruleIdentifier)
        }
        if let tagKeyScope = tagKeyScope {
            try encodeContainer.encode(tagKeyScope, forKey: .tagKeyScope)
        }
        if let tagValueScope = tagValueScope {
            try encodeContainer.encode(tagValueScope, forKey: .tagValueScope)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let ruleIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleIdentifier)
        ruleIdentifier = ruleIdentifierDecoded
        let inputParametersDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputParameters)
        inputParameters = inputParametersDecoded
        let maximumExecutionFrequencyDecoded = try containerValues.decodeIfPresent(MaximumExecutionFrequency.self, forKey: .maximumExecutionFrequency)
        maximumExecutionFrequency = maximumExecutionFrequencyDecoded
        let resourceTypesScopeContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceTypesScope)
        var resourceTypesScopeDecoded0:[String]? = nil
        if let resourceTypesScopeContainer = resourceTypesScopeContainer {
            resourceTypesScopeDecoded0 = [String]()
            for string0 in resourceTypesScopeContainer {
                if let string0 = string0 {
                    resourceTypesScopeDecoded0?.append(string0)
                }
            }
        }
        resourceTypesScope = resourceTypesScopeDecoded0
        let resourceIdScopeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceIdScope)
        resourceIdScope = resourceIdScopeDecoded
        let tagKeyScopeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tagKeyScope)
        tagKeyScope = tagKeyScopeDecoded
        let tagValueScopeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tagValueScope)
        tagValueScope = tagValueScopeDecoded
    }
}

extension OrganizationManagedRuleMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationManagedRuleMetadata(description: \(String(describing: description)), inputParameters: \(String(describing: inputParameters)), maximumExecutionFrequency: \(String(describing: maximumExecutionFrequency)), resourceIdScope: \(String(describing: resourceIdScope)), resourceTypesScope: \(String(describing: resourceTypesScope)), ruleIdentifier: \(String(describing: ruleIdentifier)), tagKeyScope: \(String(describing: tagKeyScope)), tagValueScope: \(String(describing: tagValueScope)))"}
}

/// <p>An object that specifies organization managed rule metadata such as resource type and ID of AWS resource along with the rule identifier.
/// 			It also provides the frequency with which you want AWS Config to run evaluations for the rule if the trigger type is periodic.</p>
public struct OrganizationManagedRuleMetadata: Equatable {
    /// <p>The description that you provide for organization config rule.</p>
    public let description: String?
    /// <p>A string, in JSON format, that is passed to organization config rule Lambda function.</p>
    public let inputParameters: String?
    /// <p>The maximum frequency with which AWS Config runs evaluations for a rule. You are using an AWS managed rule that is triggered at a periodic frequency.</p>
    /// 		       <note>
    ///             <p>By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid
    /// 			value for the <code>MaximumExecutionFrequency</code> parameter.</p>
    ///          </note>
    public let maximumExecutionFrequency: MaximumExecutionFrequency?
    /// <p>The ID of the AWS resource that was evaluated.</p>
    public let resourceIdScope: String?
    /// <p>The type of the AWS resource that was evaluated.</p>
    public let resourceTypesScope: [String]?
    /// <p>For organization config managed rules, a predefined identifier from a
    /// 			list. For example, <code>IAM_PASSWORD_POLICY</code> is a managed
    /// 			rule. To reference a managed rule, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_use-managed-rules.html">Using AWS Managed Config Rules</a>.</p>
    public let ruleIdentifier: String?
    /// <p>One part of a key-value pair that make up a tag.
    /// 			A key is a general label that acts like a category for more specific tag values. </p>
    public let tagKeyScope: String?
    /// <p>The optional part of a key-value pair that make up a tag.
    /// 			A value acts as a descriptor within a tag category (key).</p>
    public let tagValueScope: String?

    public init (
        description: String? = nil,
        inputParameters: String? = nil,
        maximumExecutionFrequency: MaximumExecutionFrequency? = nil,
        resourceIdScope: String? = nil,
        resourceTypesScope: [String]? = nil,
        ruleIdentifier: String? = nil,
        tagKeyScope: String? = nil,
        tagValueScope: String? = nil
    )
    {
        self.description = description
        self.inputParameters = inputParameters
        self.maximumExecutionFrequency = maximumExecutionFrequency
        self.resourceIdScope = resourceIdScope
        self.resourceTypesScope = resourceTypesScope
        self.ruleIdentifier = ruleIdentifier
        self.tagKeyScope = tagKeyScope
        self.tagValueScope = tagValueScope
    }
}

public enum OrganizationResourceDetailedStatus {
    case createFailed
    case createInProgress
    case createSuccessful
    case deleteFailed
    case deleteInProgress
    case deleteSuccessful
    case updateFailed
    case updateInProgress
    case updateSuccessful
    case sdkUnknown(String)
}

extension OrganizationResourceDetailedStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OrganizationResourceDetailedStatus] {
        return [
            .createFailed,
            .createInProgress,
            .createSuccessful,
            .deleteFailed,
            .deleteInProgress,
            .deleteSuccessful,
            .updateFailed,
            .updateInProgress,
            .updateSuccessful,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createFailed: return "CREATE_FAILED"
        case .createInProgress: return "CREATE_IN_PROGRESS"
        case .createSuccessful: return "CREATE_SUCCESSFUL"
        case .deleteFailed: return "DELETE_FAILED"
        case .deleteInProgress: return "DELETE_IN_PROGRESS"
        case .deleteSuccessful: return "DELETE_SUCCESSFUL"
        case .updateFailed: return "UPDATE_FAILED"
        case .updateInProgress: return "UPDATE_IN_PROGRESS"
        case .updateSuccessful: return "UPDATE_SUCCESSFUL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OrganizationResourceDetailedStatus(rawValue: rawValue) ?? OrganizationResourceDetailedStatus.sdkUnknown(rawValue)
    }
}

extension OrganizationResourceDetailedStatusFilters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OrganizationResourceDetailedStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OrganizationResourceDetailedStatusFilters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationResourceDetailedStatusFilters(accountId: \(String(describing: accountId)), status: \(String(describing: status)))"}
}

/// <p>Status filter object to filter results based on specific member account ID or status type for an organization conformance pack.</p>
public struct OrganizationResourceDetailedStatusFilters: Equatable {
    /// <p>The 12-digit account ID of the member account within an organization.</p>
    public let accountId: String?
    /// <p>Indicates deployment status for conformance pack in a member account.
    /// 			When master account calls <code>PutOrganizationConformancePack</code> action for the first time, conformance pack status is created in the member account.
    /// 			When master account calls <code>PutOrganizationConformancePack</code> action for the second time, conformance pack status is updated in the member account.
    /// 			Conformance pack status is deleted when the master account deletes <code>OrganizationConformancePack</code> and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>.
    /// 		</p>
    /// 		       <p> AWS Config sets the state of the conformance pack to:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_SUCCESSFUL</code> when conformance pack has been created in the member account. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_IN_PROGRESS</code> when conformance pack is being created in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_FAILED</code> when conformance pack creation has failed in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_FAILED</code> when conformance pack deletion has failed in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_IN_PROGRESS</code> when conformance pack is being deleted in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_SUCCESSFUL</code> when conformance pack has been deleted in the member account. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UPDATE_SUCCESSFUL</code> when conformance pack has been updated in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UPDATE_IN_PROGRESS</code> when conformance pack is being updated in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UPDATE_FAILED</code> when conformance pack deletion has failed in the member account.</p>
    ///             </li>
    ///          </ul>
    public let status: OrganizationResourceDetailedStatus?

    public init (
        accountId: String? = nil,
        status: OrganizationResourceDetailedStatus? = nil
    )
    {
        self.accountId = accountId
        self.status = status
    }
}

public enum OrganizationResourceStatus {
    case createFailed
    case createInProgress
    case createSuccessful
    case deleteFailed
    case deleteInProgress
    case deleteSuccessful
    case updateFailed
    case updateInProgress
    case updateSuccessful
    case sdkUnknown(String)
}

extension OrganizationResourceStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OrganizationResourceStatus] {
        return [
            .createFailed,
            .createInProgress,
            .createSuccessful,
            .deleteFailed,
            .deleteInProgress,
            .deleteSuccessful,
            .updateFailed,
            .updateInProgress,
            .updateSuccessful,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createFailed: return "CREATE_FAILED"
        case .createInProgress: return "CREATE_IN_PROGRESS"
        case .createSuccessful: return "CREATE_SUCCESSFUL"
        case .deleteFailed: return "DELETE_FAILED"
        case .deleteInProgress: return "DELETE_IN_PROGRESS"
        case .deleteSuccessful: return "DELETE_SUCCESSFUL"
        case .updateFailed: return "UPDATE_FAILED"
        case .updateInProgress: return "UPDATE_IN_PROGRESS"
        case .updateSuccessful: return "UPDATE_SUCCESSFUL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OrganizationResourceStatus(rawValue: rawValue) ?? OrganizationResourceStatus.sdkUnknown(rawValue)
    }
}

public enum OrganizationRuleStatus {
    case createFailed
    case createInProgress
    case createSuccessful
    case deleteFailed
    case deleteInProgress
    case deleteSuccessful
    case updateFailed
    case updateInProgress
    case updateSuccessful
    case sdkUnknown(String)
}

extension OrganizationRuleStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OrganizationRuleStatus] {
        return [
            .createFailed,
            .createInProgress,
            .createSuccessful,
            .deleteFailed,
            .deleteInProgress,
            .deleteSuccessful,
            .updateFailed,
            .updateInProgress,
            .updateSuccessful,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createFailed: return "CREATE_FAILED"
        case .createInProgress: return "CREATE_IN_PROGRESS"
        case .createSuccessful: return "CREATE_SUCCESSFUL"
        case .deleteFailed: return "DELETE_FAILED"
        case .deleteInProgress: return "DELETE_IN_PROGRESS"
        case .deleteSuccessful: return "DELETE_SUCCESSFUL"
        case .updateFailed: return "UPDATE_FAILED"
        case .updateInProgress: return "UPDATE_IN_PROGRESS"
        case .updateSuccessful: return "UPDATE_SUCCESSFUL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OrganizationRuleStatus(rawValue: rawValue) ?? OrganizationRuleStatus.sdkUnknown(rawValue)
    }
}

extension OversizedConfigurationItemException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OversizedConfigurationItemException(message: \(String(describing: message)))"}
}

extension OversizedConfigurationItemException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OversizedConfigurationItemExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The configuration item size is outside the allowable range.</p>
public struct OversizedConfigurationItemException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OversizedConfigurationItemExceptionBody: Equatable {
    public let message: String?
}

extension OversizedConfigurationItemExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum Owner {
    case aws
    case customLambda
    case sdkUnknown(String)
}

extension Owner : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Owner] {
        return [
            .aws,
            .customLambda,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aws: return "AWS"
        case .customLambda: return "CUSTOM_LAMBDA"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Owner(rawValue: rawValue) ?? Owner.sdkUnknown(rawValue)
    }
}

extension PendingAggregationRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case requesterAccountId = "RequesterAccountId"
        case requesterAwsRegion = "RequesterAwsRegion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let requesterAccountId = requesterAccountId {
            try encodeContainer.encode(requesterAccountId, forKey: .requesterAccountId)
        }
        if let requesterAwsRegion = requesterAwsRegion {
            try encodeContainer.encode(requesterAwsRegion, forKey: .requesterAwsRegion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requesterAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requesterAccountId)
        requesterAccountId = requesterAccountIdDecoded
        let requesterAwsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requesterAwsRegion)
        requesterAwsRegion = requesterAwsRegionDecoded
    }
}

extension PendingAggregationRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PendingAggregationRequest(requesterAccountId: \(String(describing: requesterAccountId)), requesterAwsRegion: \(String(describing: requesterAwsRegion)))"}
}

/// <p>An object that represents the account ID and region of an
/// 			aggregator account that is requesting authorization but is not yet
/// 			authorized.</p>
public struct PendingAggregationRequest: Equatable {
    /// <p>The 12-digit account ID of the account requesting to aggregate
    /// 			data.</p>
    public let requesterAccountId: String?
    /// <p>The region requesting to aggregate data. </p>
    public let requesterAwsRegion: String?

    public init (
        requesterAccountId: String? = nil,
        requesterAwsRegion: String? = nil
    )
    {
        self.requesterAccountId = requesterAccountId
        self.requesterAwsRegion = requesterAwsRegion
    }
}

public struct PutAggregationAuthorizationInputBodyMiddleware: Middleware {
    public let id: String = "PutAggregationAuthorizationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAggregationAuthorizationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAggregationAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAggregationAuthorizationInput>
    public typealias MOutput = OperationOutput<PutAggregationAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAggregationAuthorizationOutputError>
}

extension PutAggregationAuthorizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAggregationAuthorizationInput(authorizedAccountId: \(String(describing: authorizedAccountId)), authorizedAwsRegion: \(String(describing: authorizedAwsRegion)), tags: \(String(describing: tags)))"}
}

extension PutAggregationAuthorizationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorizedAccountId = "AuthorizedAccountId"
        case authorizedAwsRegion = "AuthorizedAwsRegion"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizedAccountId = authorizedAccountId {
            try encodeContainer.encode(authorizedAccountId, forKey: .authorizedAccountId)
        }
        if let authorizedAwsRegion = authorizedAwsRegion {
            try encodeContainer.encode(authorizedAwsRegion, forKey: .authorizedAwsRegion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagslist0 in tags {
                try tagsContainer.encode(tagslist0)
            }
        }
    }
}

public struct PutAggregationAuthorizationInputHeadersMiddleware: Middleware {
    public let id: String = "PutAggregationAuthorizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAggregationAuthorizationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAggregationAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAggregationAuthorizationInput>
    public typealias MOutput = OperationOutput<PutAggregationAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAggregationAuthorizationOutputError>
}

public struct PutAggregationAuthorizationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutAggregationAuthorizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAggregationAuthorizationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAggregationAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAggregationAuthorizationInput>
    public typealias MOutput = OperationOutput<PutAggregationAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAggregationAuthorizationOutputError>
}

public struct PutAggregationAuthorizationInput: Equatable {
    /// <p>The 12-digit account ID of the account authorized to aggregate data.</p>
    public let authorizedAccountId: String?
    /// <p>The region authorized to collect aggregated data.</p>
    public let authorizedAwsRegion: String?
    /// <p>An array of tag object.</p>
    public let tags: [Tag]?

    public init (
        authorizedAccountId: String? = nil,
        authorizedAwsRegion: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.authorizedAccountId = authorizedAccountId
        self.authorizedAwsRegion = authorizedAwsRegion
        self.tags = tags
    }
}

struct PutAggregationAuthorizationInputBody: Equatable {
    public let authorizedAccountId: String?
    public let authorizedAwsRegion: String?
    public let tags: [Tag]?
}

extension PutAggregationAuthorizationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizedAccountId = "AuthorizedAccountId"
        case authorizedAwsRegion = "AuthorizedAwsRegion"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizedAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizedAccountId)
        authorizedAccountId = authorizedAccountIdDecoded
        let authorizedAwsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizedAwsRegion)
        authorizedAwsRegion = authorizedAwsRegionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutAggregationAuthorizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAggregationAuthorizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAggregationAuthorizationOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAggregationAuthorizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAggregationAuthorizationOutputResponse(aggregationAuthorization: \(String(describing: aggregationAuthorization)))"}
}

extension PutAggregationAuthorizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutAggregationAuthorizationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.aggregationAuthorization = output.aggregationAuthorization
        } else {
            self.aggregationAuthorization = nil
        }
    }
}

public struct PutAggregationAuthorizationOutputResponse: Equatable {
    /// <p>Returns an AggregationAuthorization object.
    /// 			
    /// 		</p>
    public let aggregationAuthorization: AggregationAuthorization?

    public init (
        aggregationAuthorization: AggregationAuthorization? = nil
    )
    {
        self.aggregationAuthorization = aggregationAuthorization
    }
}

struct PutAggregationAuthorizationOutputResponseBody: Equatable {
    public let aggregationAuthorization: AggregationAuthorization?
}

extension PutAggregationAuthorizationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aggregationAuthorization = "AggregationAuthorization"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregationAuthorizationDecoded = try containerValues.decodeIfPresent(AggregationAuthorization.self, forKey: .aggregationAuthorization)
        aggregationAuthorization = aggregationAuthorizationDecoded
    }
}

public struct PutConfigRuleInputBodyMiddleware: Middleware {
    public let id: String = "PutConfigRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigRuleInput>
    public typealias MOutput = OperationOutput<PutConfigRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigRuleOutputError>
}

extension PutConfigRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigRuleInput(configRule: \(String(describing: configRule)), tags: \(String(describing: tags)))"}
}

extension PutConfigRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configRule = "ConfigRule"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRule = configRule {
            try encodeContainer.encode(configRule, forKey: .configRule)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagslist0 in tags {
                try tagsContainer.encode(tagslist0)
            }
        }
    }
}

public struct PutConfigRuleInputHeadersMiddleware: Middleware {
    public let id: String = "PutConfigRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigRuleInput>
    public typealias MOutput = OperationOutput<PutConfigRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigRuleOutputError>
}

public struct PutConfigRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "PutConfigRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigRuleInput>
    public typealias MOutput = OperationOutput<PutConfigRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigRuleOutputError>
}

public struct PutConfigRuleInput: Equatable {
    /// <p>The rule that you want to add to your account.</p>
    public let configRule: ConfigRule?
    /// <p>An array of tag object.</p>
    public let tags: [Tag]?

    public init (
        configRule: ConfigRule? = nil,
        tags: [Tag]? = nil
    )
    {
        self.configRule = configRule
        self.tags = tags
    }
}

struct PutConfigRuleInputBody: Equatable {
    public let configRule: ConfigRule?
    public let tags: [Tag]?
}

extension PutConfigRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configRule = "ConfigRule"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleDecoded = try containerValues.decodeIfPresent(ConfigRule.self, forKey: .configRule)
        configRule = configRuleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutConfigRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutConfigRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPermissionsException" : self = .insufficientPermissionsException(try InsufficientPermissionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxNumberOfConfigRulesExceededException" : self = .maxNumberOfConfigRulesExceededException(try MaxNumberOfConfigRulesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableConfigurationRecorderException" : self = .noAvailableConfigurationRecorderException(try NoAvailableConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutConfigRuleOutputError: Equatable {
    case insufficientPermissionsException(InsufficientPermissionsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case maxNumberOfConfigRulesExceededException(MaxNumberOfConfigRulesExceededException)
    case noAvailableConfigurationRecorderException(NoAvailableConfigurationRecorderException)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutConfigRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigRuleOutputResponse()"}
}

extension PutConfigRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutConfigRuleOutputResponse: Equatable {

    public init() {}
}

struct PutConfigRuleOutputResponseBody: Equatable {
}

extension PutConfigRuleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutConfigurationAggregatorInputBodyMiddleware: Middleware {
    public let id: String = "PutConfigurationAggregatorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationAggregatorInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationAggregatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationAggregatorInput>
    public typealias MOutput = OperationOutput<PutConfigurationAggregatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationAggregatorOutputError>
}

extension PutConfigurationAggregatorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigurationAggregatorInput(accountAggregationSources: \(String(describing: accountAggregationSources)), configurationAggregatorName: \(String(describing: configurationAggregatorName)), organizationAggregationSource: \(String(describing: organizationAggregationSource)), tags: \(String(describing: tags)))"}
}

extension PutConfigurationAggregatorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountAggregationSources = "AccountAggregationSources"
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case organizationAggregationSource = "OrganizationAggregationSource"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountAggregationSources = accountAggregationSources {
            var accountAggregationSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountAggregationSources)
            for accountaggregationsourcelist0 in accountAggregationSources {
                try accountAggregationSourcesContainer.encode(accountaggregationsourcelist0)
            }
        }
        if let configurationAggregatorName = configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if let organizationAggregationSource = organizationAggregationSource {
            try encodeContainer.encode(organizationAggregationSource, forKey: .organizationAggregationSource)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagslist0 in tags {
                try tagsContainer.encode(tagslist0)
            }
        }
    }
}

public struct PutConfigurationAggregatorInputHeadersMiddleware: Middleware {
    public let id: String = "PutConfigurationAggregatorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationAggregatorInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationAggregatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationAggregatorInput>
    public typealias MOutput = OperationOutput<PutConfigurationAggregatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationAggregatorOutputError>
}

public struct PutConfigurationAggregatorInputQueryItemMiddleware: Middleware {
    public let id: String = "PutConfigurationAggregatorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationAggregatorInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationAggregatorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationAggregatorInput>
    public typealias MOutput = OperationOutput<PutConfigurationAggregatorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationAggregatorOutputError>
}

public struct PutConfigurationAggregatorInput: Equatable {
    /// <p>A list of AccountAggregationSource object.
    /// 			
    /// 		</p>
    public let accountAggregationSources: [AccountAggregationSource]?
    /// <p>The name of the configuration aggregator.</p>
    public let configurationAggregatorName: String?
    /// <p>An OrganizationAggregationSource object.</p>
    public let organizationAggregationSource: OrganizationAggregationSource?
    /// <p>An array of tag object.</p>
    public let tags: [Tag]?

    public init (
        accountAggregationSources: [AccountAggregationSource]? = nil,
        configurationAggregatorName: String? = nil,
        organizationAggregationSource: OrganizationAggregationSource? = nil,
        tags: [Tag]? = nil
    )
    {
        self.accountAggregationSources = accountAggregationSources
        self.configurationAggregatorName = configurationAggregatorName
        self.organizationAggregationSource = organizationAggregationSource
        self.tags = tags
    }
}

struct PutConfigurationAggregatorInputBody: Equatable {
    public let configurationAggregatorName: String?
    public let accountAggregationSources: [AccountAggregationSource]?
    public let organizationAggregationSource: OrganizationAggregationSource?
    public let tags: [Tag]?
}

extension PutConfigurationAggregatorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountAggregationSources = "AccountAggregationSources"
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case organizationAggregationSource = "OrganizationAggregationSource"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let accountAggregationSourcesContainer = try containerValues.decodeIfPresent([AccountAggregationSource?].self, forKey: .accountAggregationSources)
        var accountAggregationSourcesDecoded0:[AccountAggregationSource]? = nil
        if let accountAggregationSourcesContainer = accountAggregationSourcesContainer {
            accountAggregationSourcesDecoded0 = [AccountAggregationSource]()
            for structure0 in accountAggregationSourcesContainer {
                if let structure0 = structure0 {
                    accountAggregationSourcesDecoded0?.append(structure0)
                }
            }
        }
        accountAggregationSources = accountAggregationSourcesDecoded0
        let organizationAggregationSourceDecoded = try containerValues.decodeIfPresent(OrganizationAggregationSource.self, forKey: .organizationAggregationSource)
        organizationAggregationSource = organizationAggregationSourceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutConfigurationAggregatorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutConfigurationAggregatorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableOrganizationException" : self = .noAvailableOrganizationException(try NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAccessDeniedException" : self = .organizationAccessDeniedException(try OrganizationAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAllFeaturesNotEnabledException" : self = .organizationAllFeaturesNotEnabledException(try OrganizationAllFeaturesNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutConfigurationAggregatorOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case noAvailableOrganizationException(NoAvailableOrganizationException)
    case organizationAccessDeniedException(OrganizationAccessDeniedException)
    case organizationAllFeaturesNotEnabledException(OrganizationAllFeaturesNotEnabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutConfigurationAggregatorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigurationAggregatorOutputResponse(configurationAggregator: \(String(describing: configurationAggregator)))"}
}

extension PutConfigurationAggregatorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutConfigurationAggregatorOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationAggregator = output.configurationAggregator
        } else {
            self.configurationAggregator = nil
        }
    }
}

public struct PutConfigurationAggregatorOutputResponse: Equatable {
    /// <p>Returns a ConfigurationAggregator object.</p>
    public let configurationAggregator: ConfigurationAggregator?

    public init (
        configurationAggregator: ConfigurationAggregator? = nil
    )
    {
        self.configurationAggregator = configurationAggregator
    }
}

struct PutConfigurationAggregatorOutputResponseBody: Equatable {
    public let configurationAggregator: ConfigurationAggregator?
}

extension PutConfigurationAggregatorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationAggregator = "ConfigurationAggregator"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationAggregatorDecoded = try containerValues.decodeIfPresent(ConfigurationAggregator.self, forKey: .configurationAggregator)
        configurationAggregator = configurationAggregatorDecoded
    }
}

public struct PutConfigurationRecorderInputBodyMiddleware: Middleware {
    public let id: String = "PutConfigurationRecorderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationRecorderInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationRecorderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationRecorderInput>
    public typealias MOutput = OperationOutput<PutConfigurationRecorderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationRecorderOutputError>
}

extension PutConfigurationRecorderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigurationRecorderInput(configurationRecorder: \(String(describing: configurationRecorder)))"}
}

extension PutConfigurationRecorderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationRecorder = "ConfigurationRecorder"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationRecorder = configurationRecorder {
            try encodeContainer.encode(configurationRecorder, forKey: .configurationRecorder)
        }
    }
}

public struct PutConfigurationRecorderInputHeadersMiddleware: Middleware {
    public let id: String = "PutConfigurationRecorderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationRecorderInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationRecorderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationRecorderInput>
    public typealias MOutput = OperationOutput<PutConfigurationRecorderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationRecorderOutputError>
}

public struct PutConfigurationRecorderInputQueryItemMiddleware: Middleware {
    public let id: String = "PutConfigurationRecorderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationRecorderInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationRecorderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationRecorderInput>
    public typealias MOutput = OperationOutput<PutConfigurationRecorderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationRecorderOutputError>
}

/// <p>The input for the <a>PutConfigurationRecorder</a>
/// 			action.</p>
public struct PutConfigurationRecorderInput: Equatable {
    /// <p>The configuration recorder object that records each
    /// 			configuration change made to the resources.</p>
    public let configurationRecorder: ConfigurationRecorder?

    public init (
        configurationRecorder: ConfigurationRecorder? = nil
    )
    {
        self.configurationRecorder = configurationRecorder
    }
}

struct PutConfigurationRecorderInputBody: Equatable {
    public let configurationRecorder: ConfigurationRecorder?
}

extension PutConfigurationRecorderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationRecorder = "ConfigurationRecorder"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationRecorderDecoded = try containerValues.decodeIfPresent(ConfigurationRecorder.self, forKey: .configurationRecorder)
        configurationRecorder = configurationRecorderDecoded
    }
}

extension PutConfigurationRecorderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutConfigurationRecorderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidConfigurationRecorderNameException" : self = .invalidConfigurationRecorderNameException(try InvalidConfigurationRecorderNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRecordingGroupException" : self = .invalidRecordingGroupException(try InvalidRecordingGroupException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxNumberOfConfigurationRecordersExceededException" : self = .maxNumberOfConfigurationRecordersExceededException(try MaxNumberOfConfigurationRecordersExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutConfigurationRecorderOutputError: Equatable {
    case invalidConfigurationRecorderNameException(InvalidConfigurationRecorderNameException)
    case invalidRecordingGroupException(InvalidRecordingGroupException)
    case invalidRoleException(InvalidRoleException)
    case maxNumberOfConfigurationRecordersExceededException(MaxNumberOfConfigurationRecordersExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutConfigurationRecorderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigurationRecorderOutputResponse()"}
}

extension PutConfigurationRecorderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutConfigurationRecorderOutputResponse: Equatable {

    public init() {}
}

struct PutConfigurationRecorderOutputResponseBody: Equatable {
}

extension PutConfigurationRecorderOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutConformancePackInputBodyMiddleware: Middleware {
    public let id: String = "PutConformancePackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConformancePackInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConformancePackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConformancePackInput>
    public typealias MOutput = OperationOutput<PutConformancePackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConformancePackOutputError>
}

extension PutConformancePackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConformancePackInput(conformancePackInputParameters: \(String(describing: conformancePackInputParameters)), conformancePackName: \(String(describing: conformancePackName)), deliveryS3Bucket: \(String(describing: deliveryS3Bucket)), deliveryS3KeyPrefix: \(String(describing: deliveryS3KeyPrefix)), templateBody: \(String(describing: templateBody)), templateS3Uri: \(String(describing: templateS3Uri)))"}
}

extension PutConformancePackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conformancePackInputParameters = "ConformancePackInputParameters"
        case conformancePackName = "ConformancePackName"
        case deliveryS3Bucket = "DeliveryS3Bucket"
        case deliveryS3KeyPrefix = "DeliveryS3KeyPrefix"
        case templateBody = "TemplateBody"
        case templateS3Uri = "TemplateS3Uri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackInputParameters = conformancePackInputParameters {
            var conformancePackInputParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conformancePackInputParameters)
            for conformancepackinputparameters0 in conformancePackInputParameters {
                try conformancePackInputParametersContainer.encode(conformancepackinputparameters0)
            }
        }
        if let conformancePackName = conformancePackName {
            try encodeContainer.encode(conformancePackName, forKey: .conformancePackName)
        }
        if let deliveryS3Bucket = deliveryS3Bucket {
            try encodeContainer.encode(deliveryS3Bucket, forKey: .deliveryS3Bucket)
        }
        if let deliveryS3KeyPrefix = deliveryS3KeyPrefix {
            try encodeContainer.encode(deliveryS3KeyPrefix, forKey: .deliveryS3KeyPrefix)
        }
        if let templateBody = templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
        if let templateS3Uri = templateS3Uri {
            try encodeContainer.encode(templateS3Uri, forKey: .templateS3Uri)
        }
    }
}

public struct PutConformancePackInputHeadersMiddleware: Middleware {
    public let id: String = "PutConformancePackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConformancePackInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConformancePackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConformancePackInput>
    public typealias MOutput = OperationOutput<PutConformancePackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConformancePackOutputError>
}

public struct PutConformancePackInputQueryItemMiddleware: Middleware {
    public let id: String = "PutConformancePackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConformancePackInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConformancePackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConformancePackInput>
    public typealias MOutput = OperationOutput<PutConformancePackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConformancePackOutputError>
}

public struct PutConformancePackInput: Equatable {
    /// <p>A list of <code>ConformancePackInputParameter</code> objects.</p>
    public let conformancePackInputParameters: [ConformancePackInputParameter]?
    /// <p>Name of the conformance pack you want to create.</p>
    public let conformancePackName: String?
    /// <p>Amazon S3 bucket where AWS Config stores conformance pack templates.</p>
    /// 		       <note>
    ///             <p>This field is optional.</p>
    ///          </note>
    public let deliveryS3Bucket: String?
    /// <p>The prefix for the Amazon S3 bucket. </p>
    /// 		       <note>
    ///             <p>This field is optional.</p>
    ///          </note>
    public let deliveryS3KeyPrefix: String?
    /// <p>A string containing full conformance pack template body. Structure containing the template body with a minimum length of 1 byte and a maximum length of 51,200 bytes.</p>
    /// 		       <note>
    ///             <p>You can only use a YAML template with one resource type, that is, config rule and a remediation action. </p>
    ///          </note>
    public let templateBody: String?
    /// <p>Location of file containing the template body (<code>s3://bucketname/prefix</code>). The uri must point to the conformance pack template (max size: 300 KB) that is located in an Amazon S3 bucket in the same region as the conformance pack. </p>
    /// 		       <note>
    ///             <p>You must have access to read Amazon S3 bucket.</p>
    ///          </note>
    public let templateS3Uri: String?

    public init (
        conformancePackInputParameters: [ConformancePackInputParameter]? = nil,
        conformancePackName: String? = nil,
        deliveryS3Bucket: String? = nil,
        deliveryS3KeyPrefix: String? = nil,
        templateBody: String? = nil,
        templateS3Uri: String? = nil
    )
    {
        self.conformancePackInputParameters = conformancePackInputParameters
        self.conformancePackName = conformancePackName
        self.deliveryS3Bucket = deliveryS3Bucket
        self.deliveryS3KeyPrefix = deliveryS3KeyPrefix
        self.templateBody = templateBody
        self.templateS3Uri = templateS3Uri
    }
}

struct PutConformancePackInputBody: Equatable {
    public let conformancePackName: String?
    public let templateS3Uri: String?
    public let templateBody: String?
    public let deliveryS3Bucket: String?
    public let deliveryS3KeyPrefix: String?
    public let conformancePackInputParameters: [ConformancePackInputParameter]?
}

extension PutConformancePackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conformancePackInputParameters = "ConformancePackInputParameters"
        case conformancePackName = "ConformancePackName"
        case deliveryS3Bucket = "DeliveryS3Bucket"
        case deliveryS3KeyPrefix = "DeliveryS3KeyPrefix"
        case templateBody = "TemplateBody"
        case templateS3Uri = "TemplateS3Uri"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conformancePackName)
        conformancePackName = conformancePackNameDecoded
        let templateS3UriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateS3Uri)
        templateS3Uri = templateS3UriDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let deliveryS3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deliveryS3Bucket)
        deliveryS3Bucket = deliveryS3BucketDecoded
        let deliveryS3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deliveryS3KeyPrefix)
        deliveryS3KeyPrefix = deliveryS3KeyPrefixDecoded
        let conformancePackInputParametersContainer = try containerValues.decodeIfPresent([ConformancePackInputParameter?].self, forKey: .conformancePackInputParameters)
        var conformancePackInputParametersDecoded0:[ConformancePackInputParameter]? = nil
        if let conformancePackInputParametersContainer = conformancePackInputParametersContainer {
            conformancePackInputParametersDecoded0 = [ConformancePackInputParameter]()
            for structure0 in conformancePackInputParametersContainer {
                if let structure0 = structure0 {
                    conformancePackInputParametersDecoded0?.append(structure0)
                }
            }
        }
        conformancePackInputParameters = conformancePackInputParametersDecoded0
    }
}

extension PutConformancePackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutConformancePackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConformancePackTemplateValidationException" : self = .conformancePackTemplateValidationException(try ConformancePackTemplateValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientPermissionsException" : self = .insufficientPermissionsException(try InsufficientPermissionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxNumberOfConformancePacksExceededException" : self = .maxNumberOfConformancePacksExceededException(try MaxNumberOfConformancePacksExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutConformancePackOutputError: Equatable {
    case conformancePackTemplateValidationException(ConformancePackTemplateValidationException)
    case insufficientPermissionsException(InsufficientPermissionsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case maxNumberOfConformancePacksExceededException(MaxNumberOfConformancePacksExceededException)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutConformancePackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConformancePackOutputResponse(conformancePackArn: \(String(describing: conformancePackArn)))"}
}

extension PutConformancePackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutConformancePackOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.conformancePackArn = output.conformancePackArn
        } else {
            self.conformancePackArn = nil
        }
    }
}

public struct PutConformancePackOutputResponse: Equatable {
    /// <p>ARN of the conformance pack.</p>
    public let conformancePackArn: String?

    public init (
        conformancePackArn: String? = nil
    )
    {
        self.conformancePackArn = conformancePackArn
    }
}

struct PutConformancePackOutputResponseBody: Equatable {
    public let conformancePackArn: String?
}

extension PutConformancePackOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conformancePackArn = "ConformancePackArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conformancePackArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conformancePackArn)
        conformancePackArn = conformancePackArnDecoded
    }
}

public struct PutDeliveryChannelInputBodyMiddleware: Middleware {
    public let id: String = "PutDeliveryChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDeliveryChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDeliveryChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDeliveryChannelInput>
    public typealias MOutput = OperationOutput<PutDeliveryChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDeliveryChannelOutputError>
}

extension PutDeliveryChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutDeliveryChannelInput(deliveryChannel: \(String(describing: deliveryChannel)))"}
}

extension PutDeliveryChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deliveryChannel = "DeliveryChannel"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryChannel = deliveryChannel {
            try encodeContainer.encode(deliveryChannel, forKey: .deliveryChannel)
        }
    }
}

public struct PutDeliveryChannelInputHeadersMiddleware: Middleware {
    public let id: String = "PutDeliveryChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDeliveryChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDeliveryChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDeliveryChannelInput>
    public typealias MOutput = OperationOutput<PutDeliveryChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDeliveryChannelOutputError>
}

public struct PutDeliveryChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "PutDeliveryChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDeliveryChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDeliveryChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDeliveryChannelInput>
    public typealias MOutput = OperationOutput<PutDeliveryChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDeliveryChannelOutputError>
}

/// <p>The input for the <a>PutDeliveryChannel</a>
/// 			action.</p>
public struct PutDeliveryChannelInput: Equatable {
    /// <p>The configuration delivery channel object that delivers the
    /// 			configuration information to an Amazon S3 bucket and to an Amazon
    /// 			SNS topic.</p>
    public let deliveryChannel: DeliveryChannel?

    public init (
        deliveryChannel: DeliveryChannel? = nil
    )
    {
        self.deliveryChannel = deliveryChannel
    }
}

struct PutDeliveryChannelInputBody: Equatable {
    public let deliveryChannel: DeliveryChannel?
}

extension PutDeliveryChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deliveryChannel = "DeliveryChannel"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryChannelDecoded = try containerValues.decodeIfPresent(DeliveryChannel.self, forKey: .deliveryChannel)
        deliveryChannel = deliveryChannelDecoded
    }
}

extension PutDeliveryChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutDeliveryChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientDeliveryPolicyException" : self = .insufficientDeliveryPolicyException(try InsufficientDeliveryPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDeliveryChannelNameException" : self = .invalidDeliveryChannelNameException(try InvalidDeliveryChannelNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3KeyPrefixException" : self = .invalidS3KeyPrefixException(try InvalidS3KeyPrefixException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3KmsKeyArnException" : self = .invalidS3KmsKeyArnException(try InvalidS3KmsKeyArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSNSTopicARNException" : self = .invalidSNSTopicARNException(try InvalidSNSTopicARNException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxNumberOfDeliveryChannelsExceededException" : self = .maxNumberOfDeliveryChannelsExceededException(try MaxNumberOfDeliveryChannelsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableConfigurationRecorderException" : self = .noAvailableConfigurationRecorderException(try NoAvailableConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchBucketException" : self = .noSuchBucketException(try NoSuchBucketException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutDeliveryChannelOutputError: Equatable {
    case insufficientDeliveryPolicyException(InsufficientDeliveryPolicyException)
    case invalidDeliveryChannelNameException(InvalidDeliveryChannelNameException)
    case invalidS3KeyPrefixException(InvalidS3KeyPrefixException)
    case invalidS3KmsKeyArnException(InvalidS3KmsKeyArnException)
    case invalidSNSTopicARNException(InvalidSNSTopicARNException)
    case maxNumberOfDeliveryChannelsExceededException(MaxNumberOfDeliveryChannelsExceededException)
    case noAvailableConfigurationRecorderException(NoAvailableConfigurationRecorderException)
    case noSuchBucketException(NoSuchBucketException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutDeliveryChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutDeliveryChannelOutputResponse()"}
}

extension PutDeliveryChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutDeliveryChannelOutputResponse: Equatable {

    public init() {}
}

struct PutDeliveryChannelOutputResponseBody: Equatable {
}

extension PutDeliveryChannelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutEvaluationsInputBodyMiddleware: Middleware {
    public let id: String = "PutEvaluationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEvaluationsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEvaluationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEvaluationsInput>
    public typealias MOutput = OperationOutput<PutEvaluationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEvaluationsOutputError>
}

extension PutEvaluationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEvaluationsInput(evaluations: \(String(describing: evaluations)), resultToken: \(String(describing: resultToken)), testMode: \(String(describing: testMode)))"}
}

extension PutEvaluationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case evaluations = "Evaluations"
        case resultToken = "ResultToken"
        case testMode = "TestMode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluations = evaluations {
            var evaluationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .evaluations)
            for evaluations0 in evaluations {
                try evaluationsContainer.encode(evaluations0)
            }
        }
        if let resultToken = resultToken {
            try encodeContainer.encode(resultToken, forKey: .resultToken)
        }
        if testMode != false {
            try encodeContainer.encode(testMode, forKey: .testMode)
        }
    }
}

public struct PutEvaluationsInputHeadersMiddleware: Middleware {
    public let id: String = "PutEvaluationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEvaluationsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEvaluationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEvaluationsInput>
    public typealias MOutput = OperationOutput<PutEvaluationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEvaluationsOutputError>
}

public struct PutEvaluationsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutEvaluationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEvaluationsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEvaluationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEvaluationsInput>
    public typealias MOutput = OperationOutput<PutEvaluationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEvaluationsOutputError>
}

/// <p></p>
public struct PutEvaluationsInput: Equatable {
    /// <p>The assessments that the AWS Lambda function performs. Each
    /// 			evaluation identifies an AWS resource and indicates whether it
    /// 			complies with the AWS Config rule that invokes the AWS Lambda
    /// 			function.</p>
    public let evaluations: [Evaluation]?
    /// <p>An encrypted token that associates an evaluation with an AWS
    /// 			Config rule. Identifies the rule and the event that triggered the
    /// 			evaluation.</p>
    public let resultToken: String?
    /// <p>Use this parameter to specify a test run for
    /// 				<code>PutEvaluations</code>. You can verify whether your AWS
    /// 			Lambda function will deliver evaluation results to AWS Config. No
    /// 			updates occur to your existing evaluations, and evaluation results
    /// 			are not sent to AWS Config.</p>
    ///
    /// 		       <note>
    /// 			         <p>When <code>TestMode</code> is <code>true</code>,
    /// 					<code>PutEvaluations</code> doesn't require a valid value
    /// 				for the <code>ResultToken</code> parameter, but the value cannot
    /// 				be null.</p>
    /// 		       </note>
    public let testMode: Bool

    public init (
        evaluations: [Evaluation]? = nil,
        resultToken: String? = nil,
        testMode: Bool = false
    )
    {
        self.evaluations = evaluations
        self.resultToken = resultToken
        self.testMode = testMode
    }
}

struct PutEvaluationsInputBody: Equatable {
    public let evaluations: [Evaluation]?
    public let resultToken: String?
    public let testMode: Bool
}

extension PutEvaluationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case evaluations = "Evaluations"
        case resultToken = "ResultToken"
        case testMode = "TestMode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationsContainer = try containerValues.decodeIfPresent([Evaluation?].self, forKey: .evaluations)
        var evaluationsDecoded0:[Evaluation]? = nil
        if let evaluationsContainer = evaluationsContainer {
            evaluationsDecoded0 = [Evaluation]()
            for structure0 in evaluationsContainer {
                if let structure0 = structure0 {
                    evaluationsDecoded0?.append(structure0)
                }
            }
        }
        evaluations = evaluationsDecoded0
        let resultTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resultToken)
        resultToken = resultTokenDecoded
        let testModeDecoded = try containerValues.decode(Bool.self, forKey: .testMode)
        testMode = testModeDecoded
    }
}

extension PutEvaluationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEvaluationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResultTokenException" : self = .invalidResultTokenException(try InvalidResultTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigRuleException" : self = .noSuchConfigRuleException(try NoSuchConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutEvaluationsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidResultTokenException(InvalidResultTokenException)
    case noSuchConfigRuleException(NoSuchConfigRuleException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEvaluationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEvaluationsOutputResponse(failedEvaluations: \(String(describing: failedEvaluations)))"}
}

extension PutEvaluationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutEvaluationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedEvaluations = output.failedEvaluations
        } else {
            self.failedEvaluations = nil
        }
    }
}

/// <p></p>
public struct PutEvaluationsOutputResponse: Equatable {
    /// <p>Requests that failed because of a client or server
    /// 			error.</p>
    public let failedEvaluations: [Evaluation]?

    public init (
        failedEvaluations: [Evaluation]? = nil
    )
    {
        self.failedEvaluations = failedEvaluations
    }
}

struct PutEvaluationsOutputResponseBody: Equatable {
    public let failedEvaluations: [Evaluation]?
}

extension PutEvaluationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedEvaluations = "FailedEvaluations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedEvaluationsContainer = try containerValues.decodeIfPresent([Evaluation?].self, forKey: .failedEvaluations)
        var failedEvaluationsDecoded0:[Evaluation]? = nil
        if let failedEvaluationsContainer = failedEvaluationsContainer {
            failedEvaluationsDecoded0 = [Evaluation]()
            for structure0 in failedEvaluationsContainer {
                if let structure0 = structure0 {
                    failedEvaluationsDecoded0?.append(structure0)
                }
            }
        }
        failedEvaluations = failedEvaluationsDecoded0
    }
}

public struct PutExternalEvaluationInputBodyMiddleware: Middleware {
    public let id: String = "PutExternalEvaluationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutExternalEvaluationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutExternalEvaluationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutExternalEvaluationInput>
    public typealias MOutput = OperationOutput<PutExternalEvaluationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutExternalEvaluationOutputError>
}

extension PutExternalEvaluationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutExternalEvaluationInput(configRuleName: \(String(describing: configRuleName)), externalEvaluation: \(String(describing: externalEvaluation)))"}
}

extension PutExternalEvaluationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configRuleName = "ConfigRuleName"
        case externalEvaluation = "ExternalEvaluation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleName = configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let externalEvaluation = externalEvaluation {
            try encodeContainer.encode(externalEvaluation, forKey: .externalEvaluation)
        }
    }
}

public struct PutExternalEvaluationInputHeadersMiddleware: Middleware {
    public let id: String = "PutExternalEvaluationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutExternalEvaluationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutExternalEvaluationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutExternalEvaluationInput>
    public typealias MOutput = OperationOutput<PutExternalEvaluationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutExternalEvaluationOutputError>
}

public struct PutExternalEvaluationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutExternalEvaluationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutExternalEvaluationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutExternalEvaluationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutExternalEvaluationInput>
    public typealias MOutput = OperationOutput<PutExternalEvaluationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutExternalEvaluationOutputError>
}

public struct PutExternalEvaluationInput: Equatable {
    /// <p>The name of the AWS Config rule.</p>
    public let configRuleName: String?
    /// <p>An <code>ExternalEvaluation</code> object that provides details about compliance.</p>
    public let externalEvaluation: ExternalEvaluation?

    public init (
        configRuleName: String? = nil,
        externalEvaluation: ExternalEvaluation? = nil
    )
    {
        self.configRuleName = configRuleName
        self.externalEvaluation = externalEvaluation
    }
}

struct PutExternalEvaluationInputBody: Equatable {
    public let configRuleName: String?
    public let externalEvaluation: ExternalEvaluation?
}

extension PutExternalEvaluationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configRuleName = "ConfigRuleName"
        case externalEvaluation = "ExternalEvaluation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let externalEvaluationDecoded = try containerValues.decodeIfPresent(ExternalEvaluation.self, forKey: .externalEvaluation)
        externalEvaluation = externalEvaluationDecoded
    }
}

extension PutExternalEvaluationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutExternalEvaluationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigRuleException" : self = .noSuchConfigRuleException(try NoSuchConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutExternalEvaluationOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchConfigRuleException(NoSuchConfigRuleException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutExternalEvaluationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutExternalEvaluationOutputResponse()"}
}

extension PutExternalEvaluationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutExternalEvaluationOutputResponse: Equatable {

    public init() {}
}

struct PutExternalEvaluationOutputResponseBody: Equatable {
}

extension PutExternalEvaluationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutOrganizationConfigRuleInputBodyMiddleware: Middleware {
    public let id: String = "PutOrganizationConfigRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutOrganizationConfigRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<PutOrganizationConfigRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutOrganizationConfigRuleInput>
    public typealias MOutput = OperationOutput<PutOrganizationConfigRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutOrganizationConfigRuleOutputError>
}

extension PutOrganizationConfigRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutOrganizationConfigRuleInput(excludedAccounts: \(String(describing: excludedAccounts)), organizationConfigRuleName: \(String(describing: organizationConfigRuleName)), organizationCustomRuleMetadata: \(String(describing: organizationCustomRuleMetadata)), organizationManagedRuleMetadata: \(String(describing: organizationManagedRuleMetadata)))"}
}

extension PutOrganizationConfigRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case excludedAccounts = "ExcludedAccounts"
        case organizationConfigRuleName = "OrganizationConfigRuleName"
        case organizationCustomRuleMetadata = "OrganizationCustomRuleMetadata"
        case organizationManagedRuleMetadata = "OrganizationManagedRuleMetadata"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludedAccounts = excludedAccounts {
            var excludedAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludedAccounts)
            for excludedaccounts0 in excludedAccounts {
                try excludedAccountsContainer.encode(excludedaccounts0)
            }
        }
        if let organizationConfigRuleName = organizationConfigRuleName {
            try encodeContainer.encode(organizationConfigRuleName, forKey: .organizationConfigRuleName)
        }
        if let organizationCustomRuleMetadata = organizationCustomRuleMetadata {
            try encodeContainer.encode(organizationCustomRuleMetadata, forKey: .organizationCustomRuleMetadata)
        }
        if let organizationManagedRuleMetadata = organizationManagedRuleMetadata {
            try encodeContainer.encode(organizationManagedRuleMetadata, forKey: .organizationManagedRuleMetadata)
        }
    }
}

public struct PutOrganizationConfigRuleInputHeadersMiddleware: Middleware {
    public let id: String = "PutOrganizationConfigRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutOrganizationConfigRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<PutOrganizationConfigRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutOrganizationConfigRuleInput>
    public typealias MOutput = OperationOutput<PutOrganizationConfigRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutOrganizationConfigRuleOutputError>
}

public struct PutOrganizationConfigRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "PutOrganizationConfigRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutOrganizationConfigRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<PutOrganizationConfigRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutOrganizationConfigRuleInput>
    public typealias MOutput = OperationOutput<PutOrganizationConfigRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutOrganizationConfigRuleOutputError>
}

public struct PutOrganizationConfigRuleInput: Equatable {
    /// <p>A comma-separated list of accounts that you want to exclude from an organization config rule.</p>
    public let excludedAccounts: [String]?
    /// <p>The name that you assign to an organization config rule.</p>
    public let organizationConfigRuleName: String?
    /// <p>An <code>OrganizationCustomRuleMetadata</code> object.</p>
    public let organizationCustomRuleMetadata: OrganizationCustomRuleMetadata?
    /// <p>An <code>OrganizationManagedRuleMetadata</code> object. </p>
    public let organizationManagedRuleMetadata: OrganizationManagedRuleMetadata?

    public init (
        excludedAccounts: [String]? = nil,
        organizationConfigRuleName: String? = nil,
        organizationCustomRuleMetadata: OrganizationCustomRuleMetadata? = nil,
        organizationManagedRuleMetadata: OrganizationManagedRuleMetadata? = nil
    )
    {
        self.excludedAccounts = excludedAccounts
        self.organizationConfigRuleName = organizationConfigRuleName
        self.organizationCustomRuleMetadata = organizationCustomRuleMetadata
        self.organizationManagedRuleMetadata = organizationManagedRuleMetadata
    }
}

struct PutOrganizationConfigRuleInputBody: Equatable {
    public let organizationConfigRuleName: String?
    public let organizationManagedRuleMetadata: OrganizationManagedRuleMetadata?
    public let organizationCustomRuleMetadata: OrganizationCustomRuleMetadata?
    public let excludedAccounts: [String]?
}

extension PutOrganizationConfigRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case excludedAccounts = "ExcludedAccounts"
        case organizationConfigRuleName = "OrganizationConfigRuleName"
        case organizationCustomRuleMetadata = "OrganizationCustomRuleMetadata"
        case organizationManagedRuleMetadata = "OrganizationManagedRuleMetadata"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConfigRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationConfigRuleName)
        organizationConfigRuleName = organizationConfigRuleNameDecoded
        let organizationManagedRuleMetadataDecoded = try containerValues.decodeIfPresent(OrganizationManagedRuleMetadata.self, forKey: .organizationManagedRuleMetadata)
        organizationManagedRuleMetadata = organizationManagedRuleMetadataDecoded
        let organizationCustomRuleMetadataDecoded = try containerValues.decodeIfPresent(OrganizationCustomRuleMetadata.self, forKey: .organizationCustomRuleMetadata)
        organizationCustomRuleMetadata = organizationCustomRuleMetadataDecoded
        let excludedAccountsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .excludedAccounts)
        var excludedAccountsDecoded0:[String]? = nil
        if let excludedAccountsContainer = excludedAccountsContainer {
            excludedAccountsDecoded0 = [String]()
            for string0 in excludedAccountsContainer {
                if let string0 = string0 {
                    excludedAccountsDecoded0?.append(string0)
                }
            }
        }
        excludedAccounts = excludedAccountsDecoded0
    }
}

extension PutOrganizationConfigRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutOrganizationConfigRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPermissionsException" : self = .insufficientPermissionsException(try InsufficientPermissionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxNumberOfOrganizationConfigRulesExceededException" : self = .maxNumberOfOrganizationConfigRulesExceededException(try MaxNumberOfOrganizationConfigRulesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableOrganizationException" : self = .noAvailableOrganizationException(try NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAccessDeniedException" : self = .organizationAccessDeniedException(try OrganizationAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAllFeaturesNotEnabledException" : self = .organizationAllFeaturesNotEnabledException(try OrganizationAllFeaturesNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutOrganizationConfigRuleOutputError: Equatable {
    case insufficientPermissionsException(InsufficientPermissionsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case maxNumberOfOrganizationConfigRulesExceededException(MaxNumberOfOrganizationConfigRulesExceededException)
    case noAvailableOrganizationException(NoAvailableOrganizationException)
    case organizationAccessDeniedException(OrganizationAccessDeniedException)
    case organizationAllFeaturesNotEnabledException(OrganizationAllFeaturesNotEnabledException)
    case resourceInUseException(ResourceInUseException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutOrganizationConfigRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutOrganizationConfigRuleOutputResponse(organizationConfigRuleArn: \(String(describing: organizationConfigRuleArn)))"}
}

extension PutOrganizationConfigRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutOrganizationConfigRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.organizationConfigRuleArn = output.organizationConfigRuleArn
        } else {
            self.organizationConfigRuleArn = nil
        }
    }
}

public struct PutOrganizationConfigRuleOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of an organization config rule.</p>
    public let organizationConfigRuleArn: String?

    public init (
        organizationConfigRuleArn: String? = nil
    )
    {
        self.organizationConfigRuleArn = organizationConfigRuleArn
    }
}

struct PutOrganizationConfigRuleOutputResponseBody: Equatable {
    public let organizationConfigRuleArn: String?
}

extension PutOrganizationConfigRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case organizationConfigRuleArn = "OrganizationConfigRuleArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConfigRuleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationConfigRuleArn)
        organizationConfigRuleArn = organizationConfigRuleArnDecoded
    }
}

public struct PutOrganizationConformancePackInputBodyMiddleware: Middleware {
    public let id: String = "PutOrganizationConformancePackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutOrganizationConformancePackInput>,
                  next: H) -> Swift.Result<OperationOutput<PutOrganizationConformancePackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutOrganizationConformancePackInput>
    public typealias MOutput = OperationOutput<PutOrganizationConformancePackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutOrganizationConformancePackOutputError>
}

extension PutOrganizationConformancePackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutOrganizationConformancePackInput(conformancePackInputParameters: \(String(describing: conformancePackInputParameters)), deliveryS3Bucket: \(String(describing: deliveryS3Bucket)), deliveryS3KeyPrefix: \(String(describing: deliveryS3KeyPrefix)), excludedAccounts: \(String(describing: excludedAccounts)), organizationConformancePackName: \(String(describing: organizationConformancePackName)), templateBody: \(String(describing: templateBody)), templateS3Uri: \(String(describing: templateS3Uri)))"}
}

extension PutOrganizationConformancePackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conformancePackInputParameters = "ConformancePackInputParameters"
        case deliveryS3Bucket = "DeliveryS3Bucket"
        case deliveryS3KeyPrefix = "DeliveryS3KeyPrefix"
        case excludedAccounts = "ExcludedAccounts"
        case organizationConformancePackName = "OrganizationConformancePackName"
        case templateBody = "TemplateBody"
        case templateS3Uri = "TemplateS3Uri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conformancePackInputParameters = conformancePackInputParameters {
            var conformancePackInputParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conformancePackInputParameters)
            for conformancepackinputparameters0 in conformancePackInputParameters {
                try conformancePackInputParametersContainer.encode(conformancepackinputparameters0)
            }
        }
        if let deliveryS3Bucket = deliveryS3Bucket {
            try encodeContainer.encode(deliveryS3Bucket, forKey: .deliveryS3Bucket)
        }
        if let deliveryS3KeyPrefix = deliveryS3KeyPrefix {
            try encodeContainer.encode(deliveryS3KeyPrefix, forKey: .deliveryS3KeyPrefix)
        }
        if let excludedAccounts = excludedAccounts {
            var excludedAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludedAccounts)
            for excludedaccounts0 in excludedAccounts {
                try excludedAccountsContainer.encode(excludedaccounts0)
            }
        }
        if let organizationConformancePackName = organizationConformancePackName {
            try encodeContainer.encode(organizationConformancePackName, forKey: .organizationConformancePackName)
        }
        if let templateBody = templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
        if let templateS3Uri = templateS3Uri {
            try encodeContainer.encode(templateS3Uri, forKey: .templateS3Uri)
        }
    }
}

public struct PutOrganizationConformancePackInputHeadersMiddleware: Middleware {
    public let id: String = "PutOrganizationConformancePackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutOrganizationConformancePackInput>,
                  next: H) -> Swift.Result<OperationOutput<PutOrganizationConformancePackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutOrganizationConformancePackInput>
    public typealias MOutput = OperationOutput<PutOrganizationConformancePackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutOrganizationConformancePackOutputError>
}

public struct PutOrganizationConformancePackInputQueryItemMiddleware: Middleware {
    public let id: String = "PutOrganizationConformancePackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutOrganizationConformancePackInput>,
                  next: H) -> Swift.Result<OperationOutput<PutOrganizationConformancePackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutOrganizationConformancePackInput>
    public typealias MOutput = OperationOutput<PutOrganizationConformancePackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutOrganizationConformancePackOutputError>
}

public struct PutOrganizationConformancePackInput: Equatable {
    /// <p>A list of <code>ConformancePackInputParameter</code> objects.</p>
    public let conformancePackInputParameters: [ConformancePackInputParameter]?
    /// <p>Amazon S3 bucket where AWS Config stores conformance pack templates.</p>
    /// 		       <note>
    ///             <p>This field is optional. If used, it must be prefixed with <code>awsconfigconforms</code>.</p>
    ///          </note>
    public let deliveryS3Bucket: String?
    /// <p>The prefix for the Amazon S3 bucket.</p>
    /// 		       <note>
    ///             <p>This field is optional.</p>
    ///          </note>
    public let deliveryS3KeyPrefix: String?
    /// <p>A list of AWS accounts to be excluded from an organization conformance pack while deploying a conformance pack.</p>
    public let excludedAccounts: [String]?
    /// <p>Name of the organization conformance pack you want to create.</p>
    public let organizationConformancePackName: String?
    /// <p>A string containing full conformance pack template body. Structure containing the template body
    /// 			with a minimum length of 1 byte and a maximum length of 51,200 bytes.</p>
    public let templateBody: String?
    /// <p>Location of file containing the template body. The uri must point to the conformance pack template
    /// 			(max size: 300 KB).</p>
    /// 		       <note>
    ///             <p>You must have access to read Amazon S3 bucket.</p>
    ///          </note>
    public let templateS3Uri: String?

    public init (
        conformancePackInputParameters: [ConformancePackInputParameter]? = nil,
        deliveryS3Bucket: String? = nil,
        deliveryS3KeyPrefix: String? = nil,
        excludedAccounts: [String]? = nil,
        organizationConformancePackName: String? = nil,
        templateBody: String? = nil,
        templateS3Uri: String? = nil
    )
    {
        self.conformancePackInputParameters = conformancePackInputParameters
        self.deliveryS3Bucket = deliveryS3Bucket
        self.deliveryS3KeyPrefix = deliveryS3KeyPrefix
        self.excludedAccounts = excludedAccounts
        self.organizationConformancePackName = organizationConformancePackName
        self.templateBody = templateBody
        self.templateS3Uri = templateS3Uri
    }
}

struct PutOrganizationConformancePackInputBody: Equatable {
    public let organizationConformancePackName: String?
    public let templateS3Uri: String?
    public let templateBody: String?
    public let deliveryS3Bucket: String?
    public let deliveryS3KeyPrefix: String?
    public let conformancePackInputParameters: [ConformancePackInputParameter]?
    public let excludedAccounts: [String]?
}

extension PutOrganizationConformancePackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conformancePackInputParameters = "ConformancePackInputParameters"
        case deliveryS3Bucket = "DeliveryS3Bucket"
        case deliveryS3KeyPrefix = "DeliveryS3KeyPrefix"
        case excludedAccounts = "ExcludedAccounts"
        case organizationConformancePackName = "OrganizationConformancePackName"
        case templateBody = "TemplateBody"
        case templateS3Uri = "TemplateS3Uri"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConformancePackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationConformancePackName)
        organizationConformancePackName = organizationConformancePackNameDecoded
        let templateS3UriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateS3Uri)
        templateS3Uri = templateS3UriDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let deliveryS3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deliveryS3Bucket)
        deliveryS3Bucket = deliveryS3BucketDecoded
        let deliveryS3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deliveryS3KeyPrefix)
        deliveryS3KeyPrefix = deliveryS3KeyPrefixDecoded
        let conformancePackInputParametersContainer = try containerValues.decodeIfPresent([ConformancePackInputParameter?].self, forKey: .conformancePackInputParameters)
        var conformancePackInputParametersDecoded0:[ConformancePackInputParameter]? = nil
        if let conformancePackInputParametersContainer = conformancePackInputParametersContainer {
            conformancePackInputParametersDecoded0 = [ConformancePackInputParameter]()
            for structure0 in conformancePackInputParametersContainer {
                if let structure0 = structure0 {
                    conformancePackInputParametersDecoded0?.append(structure0)
                }
            }
        }
        conformancePackInputParameters = conformancePackInputParametersDecoded0
        let excludedAccountsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .excludedAccounts)
        var excludedAccountsDecoded0:[String]? = nil
        if let excludedAccountsContainer = excludedAccountsContainer {
            excludedAccountsDecoded0 = [String]()
            for string0 in excludedAccountsContainer {
                if let string0 = string0 {
                    excludedAccountsDecoded0?.append(string0)
                }
            }
        }
        excludedAccounts = excludedAccountsDecoded0
    }
}

extension PutOrganizationConformancePackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutOrganizationConformancePackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPermissionsException" : self = .insufficientPermissionsException(try InsufficientPermissionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxNumberOfOrganizationConformancePacksExceededException" : self = .maxNumberOfOrganizationConformancePacksExceededException(try MaxNumberOfOrganizationConformancePacksExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAvailableOrganizationException" : self = .noAvailableOrganizationException(try NoAvailableOrganizationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAccessDeniedException" : self = .organizationAccessDeniedException(try OrganizationAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationAllFeaturesNotEnabledException" : self = .organizationAllFeaturesNotEnabledException(try OrganizationAllFeaturesNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationConformancePackTemplateValidationException" : self = .organizationConformancePackTemplateValidationException(try OrganizationConformancePackTemplateValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutOrganizationConformancePackOutputError: Equatable {
    case insufficientPermissionsException(InsufficientPermissionsException)
    case maxNumberOfOrganizationConformancePacksExceededException(MaxNumberOfOrganizationConformancePacksExceededException)
    case noAvailableOrganizationException(NoAvailableOrganizationException)
    case organizationAccessDeniedException(OrganizationAccessDeniedException)
    case organizationAllFeaturesNotEnabledException(OrganizationAllFeaturesNotEnabledException)
    case organizationConformancePackTemplateValidationException(OrganizationConformancePackTemplateValidationException)
    case resourceInUseException(ResourceInUseException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutOrganizationConformancePackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutOrganizationConformancePackOutputResponse(organizationConformancePackArn: \(String(describing: organizationConformancePackArn)))"}
}

extension PutOrganizationConformancePackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutOrganizationConformancePackOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.organizationConformancePackArn = output.organizationConformancePackArn
        } else {
            self.organizationConformancePackArn = nil
        }
    }
}

public struct PutOrganizationConformancePackOutputResponse: Equatable {
    /// <p>ARN of the organization conformance pack.</p>
    public let organizationConformancePackArn: String?

    public init (
        organizationConformancePackArn: String? = nil
    )
    {
        self.organizationConformancePackArn = organizationConformancePackArn
    }
}

struct PutOrganizationConformancePackOutputResponseBody: Equatable {
    public let organizationConformancePackArn: String?
}

extension PutOrganizationConformancePackOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case organizationConformancePackArn = "OrganizationConformancePackArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationConformancePackArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationConformancePackArn)
        organizationConformancePackArn = organizationConformancePackArnDecoded
    }
}

public struct PutRemediationConfigurationsInputBodyMiddleware: Middleware {
    public let id: String = "PutRemediationConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRemediationConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRemediationConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRemediationConfigurationsInput>
    public typealias MOutput = OperationOutput<PutRemediationConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRemediationConfigurationsOutputError>
}

extension PutRemediationConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRemediationConfigurationsInput(remediationConfigurations: \(String(describing: remediationConfigurations)))"}
}

extension PutRemediationConfigurationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case remediationConfigurations = "RemediationConfigurations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let remediationConfigurations = remediationConfigurations {
            var remediationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .remediationConfigurations)
            for remediationconfigurations0 in remediationConfigurations {
                try remediationConfigurationsContainer.encode(remediationconfigurations0)
            }
        }
    }
}

public struct PutRemediationConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "PutRemediationConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRemediationConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRemediationConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRemediationConfigurationsInput>
    public typealias MOutput = OperationOutput<PutRemediationConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRemediationConfigurationsOutputError>
}

public struct PutRemediationConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutRemediationConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRemediationConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRemediationConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRemediationConfigurationsInput>
    public typealias MOutput = OperationOutput<PutRemediationConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRemediationConfigurationsOutputError>
}

public struct PutRemediationConfigurationsInput: Equatable {
    /// <p>A list of remediation configuration objects.</p>
    public let remediationConfigurations: [RemediationConfiguration]?

    public init (
        remediationConfigurations: [RemediationConfiguration]? = nil
    )
    {
        self.remediationConfigurations = remediationConfigurations
    }
}

struct PutRemediationConfigurationsInputBody: Equatable {
    public let remediationConfigurations: [RemediationConfiguration]?
}

extension PutRemediationConfigurationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case remediationConfigurations = "RemediationConfigurations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remediationConfigurationsContainer = try containerValues.decodeIfPresent([RemediationConfiguration?].self, forKey: .remediationConfigurations)
        var remediationConfigurationsDecoded0:[RemediationConfiguration]? = nil
        if let remediationConfigurationsContainer = remediationConfigurationsContainer {
            remediationConfigurationsDecoded0 = [RemediationConfiguration]()
            for structure0 in remediationConfigurationsContainer {
                if let structure0 = structure0 {
                    remediationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        remediationConfigurations = remediationConfigurationsDecoded0
    }
}

extension PutRemediationConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRemediationConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPermissionsException" : self = .insufficientPermissionsException(try InsufficientPermissionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRemediationConfigurationsOutputError: Equatable {
    case insufficientPermissionsException(InsufficientPermissionsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRemediationConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRemediationConfigurationsOutputResponse(failedBatches: \(String(describing: failedBatches)))"}
}

extension PutRemediationConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutRemediationConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedBatches = output.failedBatches
        } else {
            self.failedBatches = nil
        }
    }
}

public struct PutRemediationConfigurationsOutputResponse: Equatable {
    /// <p>Returns a list of failed remediation batch objects.</p>
    public let failedBatches: [FailedRemediationBatch]?

    public init (
        failedBatches: [FailedRemediationBatch]? = nil
    )
    {
        self.failedBatches = failedBatches
    }
}

struct PutRemediationConfigurationsOutputResponseBody: Equatable {
    public let failedBatches: [FailedRemediationBatch]?
}

extension PutRemediationConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedBatches = "FailedBatches"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedBatchesContainer = try containerValues.decodeIfPresent([FailedRemediationBatch?].self, forKey: .failedBatches)
        var failedBatchesDecoded0:[FailedRemediationBatch]? = nil
        if let failedBatchesContainer = failedBatchesContainer {
            failedBatchesDecoded0 = [FailedRemediationBatch]()
            for structure0 in failedBatchesContainer {
                if let structure0 = structure0 {
                    failedBatchesDecoded0?.append(structure0)
                }
            }
        }
        failedBatches = failedBatchesDecoded0
    }
}

public struct PutRemediationExceptionsInputBodyMiddleware: Middleware {
    public let id: String = "PutRemediationExceptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRemediationExceptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRemediationExceptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRemediationExceptionsInput>
    public typealias MOutput = OperationOutput<PutRemediationExceptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRemediationExceptionsOutputError>
}

extension PutRemediationExceptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRemediationExceptionsInput(configRuleName: \(String(describing: configRuleName)), expirationTime: \(String(describing: expirationTime)), message: \(String(describing: message)), resourceKeys: \(String(describing: resourceKeys)))"}
}

extension PutRemediationExceptionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configRuleName = "ConfigRuleName"
        case expirationTime = "ExpirationTime"
        case message = "Message"
        case resourceKeys = "ResourceKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleName = configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let expirationTime = expirationTime {
            try encodeContainer.encode(expirationTime.timeIntervalSince1970, forKey: .expirationTime)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let resourceKeys = resourceKeys {
            var resourceKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceKeys)
            for remediationexceptionresourcekeys0 in resourceKeys {
                try resourceKeysContainer.encode(remediationexceptionresourcekeys0)
            }
        }
    }
}

public struct PutRemediationExceptionsInputHeadersMiddleware: Middleware {
    public let id: String = "PutRemediationExceptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRemediationExceptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRemediationExceptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRemediationExceptionsInput>
    public typealias MOutput = OperationOutput<PutRemediationExceptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRemediationExceptionsOutputError>
}

public struct PutRemediationExceptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutRemediationExceptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRemediationExceptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRemediationExceptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRemediationExceptionsInput>
    public typealias MOutput = OperationOutput<PutRemediationExceptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRemediationExceptionsOutputError>
}

public struct PutRemediationExceptionsInput: Equatable {
    /// <p>The name of the AWS Config rule for which you want to create remediation exception.</p>
    public let configRuleName: String?
    /// <p>The exception is automatically deleted after the expiration date.</p>
    public let expirationTime: Date?
    /// <p>The message contains an explanation of the exception.</p>
    public let message: String?
    /// <p>An exception list of resource exception keys to be processed with the current request. AWS Config adds exception for each resource key. For example, AWS Config adds 3 exceptions for 3 resource keys. </p>
    public let resourceKeys: [RemediationExceptionResourceKey]?

    public init (
        configRuleName: String? = nil,
        expirationTime: Date? = nil,
        message: String? = nil,
        resourceKeys: [RemediationExceptionResourceKey]? = nil
    )
    {
        self.configRuleName = configRuleName
        self.expirationTime = expirationTime
        self.message = message
        self.resourceKeys = resourceKeys
    }
}

struct PutRemediationExceptionsInputBody: Equatable {
    public let configRuleName: String?
    public let resourceKeys: [RemediationExceptionResourceKey]?
    public let message: String?
    public let expirationTime: Date?
}

extension PutRemediationExceptionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configRuleName = "ConfigRuleName"
        case expirationTime = "ExpirationTime"
        case message = "Message"
        case resourceKeys = "ResourceKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let resourceKeysContainer = try containerValues.decodeIfPresent([RemediationExceptionResourceKey?].self, forKey: .resourceKeys)
        var resourceKeysDecoded0:[RemediationExceptionResourceKey]? = nil
        if let resourceKeysContainer = resourceKeysContainer {
            resourceKeysDecoded0 = [RemediationExceptionResourceKey]()
            for structure0 in resourceKeysContainer {
                if let structure0 = structure0 {
                    resourceKeysDecoded0?.append(structure0)
                }
            }
        }
        resourceKeys = resourceKeysDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let expirationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
    }
}

extension PutRemediationExceptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRemediationExceptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPermissionsException" : self = .insufficientPermissionsException(try InsufficientPermissionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRemediationExceptionsOutputError: Equatable {
    case insufficientPermissionsException(InsufficientPermissionsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRemediationExceptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRemediationExceptionsOutputResponse(failedBatches: \(String(describing: failedBatches)))"}
}

extension PutRemediationExceptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutRemediationExceptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedBatches = output.failedBatches
        } else {
            self.failedBatches = nil
        }
    }
}

public struct PutRemediationExceptionsOutputResponse: Equatable {
    /// <p>Returns a list of failed remediation exceptions batch objects. Each object in the batch consists of a list of failed items and failure messages.</p>
    public let failedBatches: [FailedRemediationExceptionBatch]?

    public init (
        failedBatches: [FailedRemediationExceptionBatch]? = nil
    )
    {
        self.failedBatches = failedBatches
    }
}

struct PutRemediationExceptionsOutputResponseBody: Equatable {
    public let failedBatches: [FailedRemediationExceptionBatch]?
}

extension PutRemediationExceptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedBatches = "FailedBatches"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedBatchesContainer = try containerValues.decodeIfPresent([FailedRemediationExceptionBatch?].self, forKey: .failedBatches)
        var failedBatchesDecoded0:[FailedRemediationExceptionBatch]? = nil
        if let failedBatchesContainer = failedBatchesContainer {
            failedBatchesDecoded0 = [FailedRemediationExceptionBatch]()
            for structure0 in failedBatchesContainer {
                if let structure0 = structure0 {
                    failedBatchesDecoded0?.append(structure0)
                }
            }
        }
        failedBatches = failedBatchesDecoded0
    }
}

public struct PutResourceConfigInputBodyMiddleware: Middleware {
    public let id: String = "PutResourceConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourceConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourceConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourceConfigInput>
    public typealias MOutput = OperationOutput<PutResourceConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourceConfigOutputError>
}

extension PutResourceConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutResourceConfigInput(configuration: \(String(describing: configuration)), resourceId: \(String(describing: resourceId)), resourceName: \(String(describing: resourceName)), resourceType: \(String(describing: resourceType)), schemaVersionId: \(String(describing: schemaVersionId)), tags: \(String(describing: tags)))"}
}

extension PutResourceConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configuration = "Configuration"
        case resourceId = "ResourceId"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
        case schemaVersionId = "SchemaVersionId"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let schemaVersionId = schemaVersionId {
            try encodeContainer.encode(schemaVersionId, forKey: .schemaVersionId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct PutResourceConfigInputHeadersMiddleware: Middleware {
    public let id: String = "PutResourceConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourceConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourceConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourceConfigInput>
    public typealias MOutput = OperationOutput<PutResourceConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourceConfigOutputError>
}

public struct PutResourceConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "PutResourceConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourceConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourceConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourceConfigInput>
    public typealias MOutput = OperationOutput<PutResourceConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourceConfigOutputError>
}

public struct PutResourceConfigInput: Equatable {
    /// <p>The configuration object of the resource in valid JSON format. It must match the schema registered with AWS CloudFormation.</p>
    /// 		       <note>
    ///             <p>The configuration JSON must not exceed 64 KB.</p>
    ///          </note>
    public let configuration: String?
    /// <p>Unique identifier of the resource.</p>
    public let resourceId: String?
    /// <p>Name of the resource.</p>
    public let resourceName: String?
    /// <p>The type of the resource. The custom resource type must be registered with AWS CloudFormation. </p>
    /// 		       <note>
    ///             <p>You cannot use the organization names “aws”, “amzn”, “amazon”, “alexa”, “custom” with custom resource types. It is the first part of the ResourceType up to the first ::.</p>
    ///          </note>
    public let resourceType: String?
    /// <p>Version of the schema registered for the ResourceType in AWS CloudFormation.</p>
    public let schemaVersionId: String?
    /// <p>Tags associated with the resource.</p>
    public let tags: [String:String]?

    public init (
        configuration: String? = nil,
        resourceId: String? = nil,
        resourceName: String? = nil,
        resourceType: String? = nil,
        schemaVersionId: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.configuration = configuration
        self.resourceId = resourceId
        self.resourceName = resourceName
        self.resourceType = resourceType
        self.schemaVersionId = schemaVersionId
        self.tags = tags
    }
}

struct PutResourceConfigInputBody: Equatable {
    public let resourceType: String?
    public let schemaVersionId: String?
    public let resourceId: String?
    public let resourceName: String?
    public let configuration: String?
    public let tags: [String:String]?
}

extension PutResourceConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configuration = "Configuration"
        case resourceId = "ResourceId"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
        case schemaVersionId = "SchemaVersionId"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let schemaVersionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersionId)
        schemaVersionId = schemaVersionIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configuration)
        configuration = configurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, value0) in tagsContainer {
                if let value0 = value0 {
                    tagsDecoded0?[key0] = value0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutResourceConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourceConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPermissionsException" : self = .insufficientPermissionsException(try InsufficientPermissionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxActiveResourcesExceededException" : self = .maxActiveResourcesExceededException(try MaxActiveResourcesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoRunningConfigurationRecorderException" : self = .noRunningConfigurationRecorderException(try NoRunningConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutResourceConfigOutputError: Equatable {
    case insufficientPermissionsException(InsufficientPermissionsException)
    case maxActiveResourcesExceededException(MaxActiveResourcesExceededException)
    case noRunningConfigurationRecorderException(NoRunningConfigurationRecorderException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourceConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutResourceConfigOutputResponse()"}
}

extension PutResourceConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutResourceConfigOutputResponse: Equatable {

    public init() {}
}

struct PutResourceConfigOutputResponseBody: Equatable {
}

extension PutResourceConfigOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutRetentionConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "PutRetentionConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRetentionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRetentionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRetentionConfigurationInput>
    public typealias MOutput = OperationOutput<PutRetentionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRetentionConfigurationOutputError>
}

extension PutRetentionConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRetentionConfigurationInput(retentionPeriodInDays: \(String(describing: retentionPeriodInDays)))"}
}

extension PutRetentionConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case retentionPeriodInDays = "RetentionPeriodInDays"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if retentionPeriodInDays != 0 {
            try encodeContainer.encode(retentionPeriodInDays, forKey: .retentionPeriodInDays)
        }
    }
}

public struct PutRetentionConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "PutRetentionConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRetentionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRetentionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRetentionConfigurationInput>
    public typealias MOutput = OperationOutput<PutRetentionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRetentionConfigurationOutputError>
}

public struct PutRetentionConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutRetentionConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRetentionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRetentionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRetentionConfigurationInput>
    public typealias MOutput = OperationOutput<PutRetentionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRetentionConfigurationOutputError>
}

public struct PutRetentionConfigurationInput: Equatable {
    /// <p>Number of days AWS Config stores your historical
    /// 			information.</p>
    /// 		       <note>
    /// 			         <p>Currently, only applicable to the configuration item
    /// 				history.</p>
    /// 		       </note>
    public let retentionPeriodInDays: Int

    public init (
        retentionPeriodInDays: Int = 0
    )
    {
        self.retentionPeriodInDays = retentionPeriodInDays
    }
}

struct PutRetentionConfigurationInputBody: Equatable {
    public let retentionPeriodInDays: Int
}

extension PutRetentionConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case retentionPeriodInDays = "RetentionPeriodInDays"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionPeriodInDaysDecoded = try containerValues.decode(Int.self, forKey: .retentionPeriodInDays)
        retentionPeriodInDays = retentionPeriodInDaysDecoded
    }
}

extension PutRetentionConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRetentionConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxNumberOfRetentionConfigurationsExceededException" : self = .maxNumberOfRetentionConfigurationsExceededException(try MaxNumberOfRetentionConfigurationsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRetentionConfigurationOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case maxNumberOfRetentionConfigurationsExceededException(MaxNumberOfRetentionConfigurationsExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRetentionConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRetentionConfigurationOutputResponse(retentionConfiguration: \(String(describing: retentionConfiguration)))"}
}

extension PutRetentionConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutRetentionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.retentionConfiguration = output.retentionConfiguration
        } else {
            self.retentionConfiguration = nil
        }
    }
}

public struct PutRetentionConfigurationOutputResponse: Equatable {
    /// <p>Returns a retention configuration object.</p>
    public let retentionConfiguration: RetentionConfiguration?

    public init (
        retentionConfiguration: RetentionConfiguration? = nil
    )
    {
        self.retentionConfiguration = retentionConfiguration
    }
}

struct PutRetentionConfigurationOutputResponseBody: Equatable {
    public let retentionConfiguration: RetentionConfiguration?
}

extension PutRetentionConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case retentionConfiguration = "RetentionConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionConfigurationDecoded = try containerValues.decodeIfPresent(RetentionConfiguration.self, forKey: .retentionConfiguration)
        retentionConfiguration = retentionConfigurationDecoded
    }
}

public struct PutStoredQueryInputBodyMiddleware: Middleware {
    public let id: String = "PutStoredQueryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutStoredQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<PutStoredQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutStoredQueryInput>
    public typealias MOutput = OperationOutput<PutStoredQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutStoredQueryOutputError>
}

extension PutStoredQueryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutStoredQueryInput(storedQuery: \(String(describing: storedQuery)), tags: \(String(describing: tags)))"}
}

extension PutStoredQueryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case storedQuery = "StoredQuery"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let storedQuery = storedQuery {
            try encodeContainer.encode(storedQuery, forKey: .storedQuery)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagslist0 in tags {
                try tagsContainer.encode(tagslist0)
            }
        }
    }
}

public struct PutStoredQueryInputHeadersMiddleware: Middleware {
    public let id: String = "PutStoredQueryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutStoredQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<PutStoredQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutStoredQueryInput>
    public typealias MOutput = OperationOutput<PutStoredQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutStoredQueryOutputError>
}

public struct PutStoredQueryInputQueryItemMiddleware: Middleware {
    public let id: String = "PutStoredQueryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutStoredQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<PutStoredQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutStoredQueryInput>
    public typealias MOutput = OperationOutput<PutStoredQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutStoredQueryOutputError>
}

public struct PutStoredQueryInput: Equatable {
    /// <p>A list of <code>StoredQuery</code> objects.
    /// 			The mandatory fields are <code>QueryName</code> and <code>Expression</code>.</p>
    /// 		       <note>
    ///             <p>When you are creating a query, you must provide a query name and an expression.
    /// 			When you are updating a query, you must provide a query name but updating the description is optional.</p>
    ///          </note>
    public let storedQuery: StoredQuery?
    /// <p>A list of <code>Tags</code> object.</p>
    public let tags: [Tag]?

    public init (
        storedQuery: StoredQuery? = nil,
        tags: [Tag]? = nil
    )
    {
        self.storedQuery = storedQuery
        self.tags = tags
    }
}

struct PutStoredQueryInputBody: Equatable {
    public let storedQuery: StoredQuery?
    public let tags: [Tag]?
}

extension PutStoredQueryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case storedQuery = "StoredQuery"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storedQueryDecoded = try containerValues.decodeIfPresent(StoredQuery.self, forKey: .storedQuery)
        storedQuery = storedQueryDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutStoredQueryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutStoredQueryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceConcurrentModificationException" : self = .resourceConcurrentModificationException(try ResourceConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutStoredQueryOutputError: Equatable {
    case resourceConcurrentModificationException(ResourceConcurrentModificationException)
    case tooManyTagsException(TooManyTagsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutStoredQueryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutStoredQueryOutputResponse(queryArn: \(String(describing: queryArn)))"}
}

extension PutStoredQueryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutStoredQueryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.queryArn = output.queryArn
        } else {
            self.queryArn = nil
        }
    }
}

public struct PutStoredQueryOutputResponse: Equatable {
    /// <p>Amazon Resource Name (ARN) of the query.
    /// 			For example, arn:partition:service:region:account-id:resource-type/resource-name/resource-id.</p>
    public let queryArn: String?

    public init (
        queryArn: String? = nil
    )
    {
        self.queryArn = queryArn
    }
}

struct PutStoredQueryOutputResponseBody: Equatable {
    public let queryArn: String?
}

extension PutStoredQueryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case queryArn = "QueryArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryArn)
        queryArn = queryArnDecoded
    }
}

extension QueryInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case selectFields = "SelectFields"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let selectFields = selectFields {
            var selectFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectFields)
            for fieldinfolist0 in selectFields {
                try selectFieldsContainer.encode(fieldinfolist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectFieldsContainer = try containerValues.decodeIfPresent([FieldInfo?].self, forKey: .selectFields)
        var selectFieldsDecoded0:[FieldInfo]? = nil
        if let selectFieldsContainer = selectFieldsContainer {
            selectFieldsDecoded0 = [FieldInfo]()
            for structure0 in selectFieldsContainer {
                if let structure0 = structure0 {
                    selectFieldsDecoded0?.append(structure0)
                }
            }
        }
        selectFields = selectFieldsDecoded0
    }
}

extension QueryInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryInfo(selectFields: \(String(describing: selectFields)))"}
}

/// <p>Details about the query.</p>
public struct QueryInfo: Equatable {
    /// <p>Returns a <code>FieldInfo</code> object.</p>
    public let selectFields: [FieldInfo]?

    public init (
        selectFields: [FieldInfo]? = nil
    )
    {
        self.selectFields = selectFields
    }
}

public enum RecorderStatus {
    case failure
    case pending
    case success
    case sdkUnknown(String)
}

extension RecorderStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RecorderStatus] {
        return [
            .failure,
            .pending,
            .success,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failure: return "Failure"
        case .pending: return "Pending"
        case .success: return "Success"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RecorderStatus(rawValue: rawValue) ?? RecorderStatus.sdkUnknown(rawValue)
    }
}

extension RecordingGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allSupported
        case includeGlobalResourceTypes
        case resourceTypes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allSupported != false {
            try encodeContainer.encode(allSupported, forKey: .allSupported)
        }
        if includeGlobalResourceTypes != false {
            try encodeContainer.encode(includeGlobalResourceTypes, forKey: .includeGlobalResourceTypes)
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for resourcetypelist0 in resourceTypes {
                try resourceTypesContainer.encode(resourcetypelist0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allSupportedDecoded = try containerValues.decode(Bool.self, forKey: .allSupported)
        allSupported = allSupportedDecoded
        let includeGlobalResourceTypesDecoded = try containerValues.decode(Bool.self, forKey: .includeGlobalResourceTypes)
        includeGlobalResourceTypes = includeGlobalResourceTypesDecoded
        let resourceTypesContainer = try containerValues.decodeIfPresent([ResourceType?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[ResourceType]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [ResourceType]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
    }
}

extension RecordingGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecordingGroup(allSupported: \(String(describing: allSupported)), includeGlobalResourceTypes: \(String(describing: includeGlobalResourceTypes)), resourceTypes: \(String(describing: resourceTypes)))"}
}

/// <p>Specifies the types of AWS resource for which AWS Config
/// 			records configuration changes.</p>
/// 		       <p>In the recording group, you specify whether all supported types
/// 			or specific types of resources are recorded.</p>
/// 		       <p>By default, AWS Config records configuration changes for all
/// 			supported types of regional resources that AWS Config discovers in
/// 			the region in which it is running. Regional resources are tied to a
/// 			region and can be used only in that region. Examples of regional
/// 			resources are EC2 instances and EBS volumes.</p>
/// 		       <p>You can also have AWS Config record configuration changes for
/// 			supported types of global resources (for example, IAM resources).
/// 			Global resources are not tied to an individual region and can be
/// 			used in all regions.</p>
/// 		       <important>
/// 			         <p>The configuration details for any global resource are the
/// 				same in all regions. If you customize AWS Config in multiple
/// 				regions to record global resources, it will create multiple
/// 				configuration items each time a global resource changes: one
/// 				configuration item for each region. These configuration items
/// 				will contain identical data. To prevent duplicate configuration
/// 				items, you should consider customizing AWS Config in only one
/// 				region to record global resources, unless you want the
/// 				configuration items to be available in multiple
/// 				regions.</p>
/// 		       </important>
/// 		       <p>If you don't want AWS Config to record all resources, you can
/// 			specify which types of resources it will record with the
/// 				<code>resourceTypes</code> parameter.</p>
/// 		       <p>For a list of supported resource types, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/resource-config-reference.html#supported-resources">Supported Resource Types</a>.</p>
/// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/select-resources.html">Selecting Which Resources AWS Config Records</a>.</p>
public struct RecordingGroup: Equatable {
    /// <p>Specifies whether AWS Config records configuration changes for
    /// 			every supported type of regional resource.</p>
    /// 		       <p>If you set this option to <code>true</code>, when AWS Config
    /// 			adds support for a new type of regional resource, it starts
    /// 			recording resources of that type automatically.</p>
    /// 		       <p>If you set this option to <code>true</code>, you cannot
    /// 			enumerate a list of <code>resourceTypes</code>.</p>
    public let allSupported: Bool
    /// <p>Specifies whether AWS Config includes all supported types of
    /// 			global resources (for example, IAM resources) with the resources
    /// 			that it records.</p>
    /// 		       <p>Before you can set this option to <code>true</code>, you must
    /// 			set the <code>allSupported</code> option to
    /// 			<code>true</code>.</p>
    /// 		       <p>If you set this option to <code>true</code>, when AWS Config
    /// 			adds support for a new type of global resource, it starts recording
    /// 			resources of that type automatically.</p>
    /// 		       <p>The configuration details for any global resource are the same
    /// 			in all regions. To prevent duplicate configuration items, you should
    /// 			consider customizing AWS Config in only one region to record global
    /// 			resources.</p>
    public let includeGlobalResourceTypes: Bool
    /// <p>A comma-separated list that specifies the types of AWS
    /// 			resources for which AWS Config records configuration changes (for
    /// 			example, <code>AWS::EC2::Instance</code> or
    /// 				<code>AWS::CloudTrail::Trail</code>).</p>
    /// 		       <p>To record all configuration changes, you must
    /// 			set the <code>allSupported</code> option to
    /// 			<code>true</code>.</p>
    /// 		       <p>If you set this option to <code>false</code>, when AWS Config
    /// 			adds support for a new type of resource, it will not record
    /// 			resources of that type unless you manually add that type to your
    /// 			recording group.</p>
    /// 		       <p>For a list of valid <code>resourceTypes</code> values, see the
    /// 				<b>resourceType Value</b> column in
    /// 				<a href="https://docs.aws.amazon.com/config/latest/developerguide/resource-config-reference.html#supported-resources">Supported AWS Resource Types</a>.</p>
    public let resourceTypes: [ResourceType]?

    public init (
        allSupported: Bool = false,
        includeGlobalResourceTypes: Bool = false,
        resourceTypes: [ResourceType]? = nil
    )
    {
        self.allSupported = allSupported
        self.includeGlobalResourceTypes = includeGlobalResourceTypes
        self.resourceTypes = resourceTypes
    }
}

extension Relationship: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case relationshipName
        case resourceId
        case resourceName
        case resourceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let relationshipName = relationshipName {
            try encodeContainer.encode(relationshipName, forKey: .relationshipName)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let relationshipNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .relationshipName)
        relationshipName = relationshipNameDecoded
    }
}

extension Relationship: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Relationship(relationshipName: \(String(describing: relationshipName)), resourceId: \(String(describing: resourceId)), resourceName: \(String(describing: resourceName)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>The relationship of the related resource to the main
/// 			resource.</p>
public struct Relationship: Equatable {
    /// <p>The type of relationship with the related resource.</p>
    public let relationshipName: String?
    /// <p>The ID of the related resource (for example,
    /// 				<code>sg-xxxxxx</code>).</p>
    public let resourceId: String?
    /// <p>The custom name of the related resource, if
    /// 			available.</p>
    public let resourceName: String?
    /// <p>The resource type of the related resource.</p>
    public let resourceType: ResourceType?

    public init (
        relationshipName: String? = nil,
        resourceId: String? = nil,
        resourceName: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.relationshipName = relationshipName
        self.resourceId = resourceId
        self.resourceName = resourceName
        self.resourceType = resourceType
    }
}

extension RemediationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case automatic = "Automatic"
        case configRuleName = "ConfigRuleName"
        case createdByService = "CreatedByService"
        case executionControls = "ExecutionControls"
        case maximumAutomaticAttempts = "MaximumAutomaticAttempts"
        case parameters = "Parameters"
        case resourceType = "ResourceType"
        case retryAttemptSeconds = "RetryAttemptSeconds"
        case targetId = "TargetId"
        case targetType = "TargetType"
        case targetVersion = "TargetVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if automatic != false {
            try encodeContainer.encode(automatic, forKey: .automatic)
        }
        if let configRuleName = configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let createdByService = createdByService {
            try encodeContainer.encode(createdByService, forKey: .createdByService)
        }
        if let executionControls = executionControls {
            try encodeContainer.encode(executionControls, forKey: .executionControls)
        }
        if let maximumAutomaticAttempts = maximumAutomaticAttempts {
            try encodeContainer.encode(maximumAutomaticAttempts, forKey: .maximumAutomaticAttempts)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, remediationparameters0) in parameters {
                try parametersContainer.encode(remediationparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let retryAttemptSeconds = retryAttemptSeconds {
            try encodeContainer.encode(retryAttemptSeconds, forKey: .retryAttemptSeconds)
        }
        if let targetId = targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
        if let targetVersion = targetVersion {
            try encodeContainer.encode(targetVersion, forKey: .targetVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(RemediationTargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let targetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let targetVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetVersion)
        targetVersion = targetVersionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: RemediationParameterValue?].self, forKey: .parameters)
        var parametersDecoded0: [String:RemediationParameterValue]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:RemediationParameterValue]()
            for (key0, remediationparametervalue0) in parametersContainer {
                if let remediationparametervalue0 = remediationparametervalue0 {
                    parametersDecoded0?[key0] = remediationparametervalue0
                }
            }
        }
        parameters = parametersDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let automaticDecoded = try containerValues.decode(Bool.self, forKey: .automatic)
        automatic = automaticDecoded
        let executionControlsDecoded = try containerValues.decodeIfPresent(ExecutionControls.self, forKey: .executionControls)
        executionControls = executionControlsDecoded
        let maximumAutomaticAttemptsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumAutomaticAttempts)
        maximumAutomaticAttempts = maximumAutomaticAttemptsDecoded
        let retryAttemptSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .retryAttemptSeconds)
        retryAttemptSeconds = retryAttemptSecondsDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createdByServiceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdByService)
        createdByService = createdByServiceDecoded
    }
}

extension RemediationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemediationConfiguration(arn: \(String(describing: arn)), automatic: \(String(describing: automatic)), configRuleName: \(String(describing: configRuleName)), createdByService: \(String(describing: createdByService)), executionControls: \(String(describing: executionControls)), maximumAutomaticAttempts: \(String(describing: maximumAutomaticAttempts)), parameters: \(String(describing: parameters)), resourceType: \(String(describing: resourceType)), retryAttemptSeconds: \(String(describing: retryAttemptSeconds)), targetId: \(String(describing: targetId)), targetType: \(String(describing: targetType)), targetVersion: \(String(describing: targetVersion)))"}
}

/// <p>An object that represents the details about the remediation configuration that includes the remediation action, parameters, and data to execute the action.</p>
public struct RemediationConfiguration: Equatable {
    /// <p>Amazon Resource Name (ARN) of remediation configuration.</p>
    public let arn: String?
    /// <p>The remediation is triggered automatically.</p>
    public let automatic: Bool
    /// <p>The name of the AWS Config rule.</p>
    public let configRuleName: String?
    /// <p>Name of the service that owns the service linked rule, if applicable.</p>
    public let createdByService: String?
    /// <p>An ExecutionControls object.</p>
    public let executionControls: ExecutionControls?
    /// <p>The maximum number of failed attempts for auto-remediation. If you do not select a number, the default is 5.</p>
    /// 		       <p>For example, if you specify MaximumAutomaticAttempts as 5 with RetryAttemptSeconds as 50 seconds,
    /// 			
    /// 			AWS Config will put a RemediationException on your behalf for the failing resource after the 5th failed attempt within 50 seconds.</p>
    public let maximumAutomaticAttempts: Int?
    /// <p>An object of the RemediationParameterValue.</p>
    public let parameters: [String:RemediationParameterValue]?
    /// <p>The type of a resource. </p>
    public let resourceType: String?
    /// <p>Maximum time in seconds that AWS Config runs auto-remediation. If you do not select a number, the default is 60 seconds. </p>
    /// 		       <p>For example, if you specify RetryAttemptSeconds as 50 seconds and MaximumAutomaticAttempts as 5,
    /// 		AWS Config will run auto-remediations 5 times within 50 seconds before throwing an exception.</p>
    public let retryAttemptSeconds: Int?
    /// <p>Target ID is the name of the public document.</p>
    public let targetId: String?
    /// <p>The type of the target. Target executes remediation. For example, SSM document.</p>
    public let targetType: RemediationTargetType?
    /// <p>Version of the target. For example, version of the SSM document.</p>
    /// 		       <note>
    ///             <p>If you make backward incompatible changes to the SSM document,
    /// 			you must call PutRemediationConfiguration API again to ensure the remediations can run.</p>
    ///          </note>
    public let targetVersion: String?

    public init (
        arn: String? = nil,
        automatic: Bool = false,
        configRuleName: String? = nil,
        createdByService: String? = nil,
        executionControls: ExecutionControls? = nil,
        maximumAutomaticAttempts: Int? = nil,
        parameters: [String:RemediationParameterValue]? = nil,
        resourceType: String? = nil,
        retryAttemptSeconds: Int? = nil,
        targetId: String? = nil,
        targetType: RemediationTargetType? = nil,
        targetVersion: String? = nil
    )
    {
        self.arn = arn
        self.automatic = automatic
        self.configRuleName = configRuleName
        self.createdByService = createdByService
        self.executionControls = executionControls
        self.maximumAutomaticAttempts = maximumAutomaticAttempts
        self.parameters = parameters
        self.resourceType = resourceType
        self.retryAttemptSeconds = retryAttemptSeconds
        self.targetId = targetId
        self.targetType = targetType
        self.targetVersion = targetVersion
    }
}

extension RemediationException: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configRuleName = "ConfigRuleName"
        case expirationTime = "ExpirationTime"
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleName = configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let expirationTime = expirationTime {
            try encodeContainer.encode(expirationTime.timeIntervalSince1970, forKey: .expirationTime)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let expirationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
    }
}

extension RemediationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemediationException(configRuleName: \(String(describing: configRuleName)), expirationTime: \(String(describing: expirationTime)), message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>An object that represents the details about the remediation exception. The details include the rule name, an explanation of an exception, the time when the exception will be deleted, the resource ID, and resource type. </p>
public struct RemediationException: Equatable {
    /// <p>The name of the AWS Config rule.</p>
    public let configRuleName: String?
    /// <p>The time when the remediation exception will be deleted.</p>
    public let expirationTime: Date?
    /// <p>An explanation of an remediation exception.</p>
    public let message: String?
    /// <p>The ID of the resource (for example., sg-xxxxxx).</p>
    public let resourceId: String?
    /// <p>The type of a resource.</p>
    public let resourceType: String?

    public init (
        configRuleName: String? = nil,
        expirationTime: Date? = nil,
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.configRuleName = configRuleName
        self.expirationTime = expirationTime
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

extension RemediationExceptionResourceKey: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension RemediationExceptionResourceKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemediationExceptionResourceKey(resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>The details that identify a resource within AWS Config, including the resource type and resource ID. </p>
public struct RemediationExceptionResourceKey: Equatable {
    /// <p>The ID of the resource (for example., sg-xxxxxx).</p>
    public let resourceId: String?
    /// <p>The type of a resource.</p>
    public let resourceType: String?

    public init (
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

public enum RemediationExecutionState {
    case failed
    case inProgress
    case queued
    case succeeded
    case sdkUnknown(String)
}

extension RemediationExecutionState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RemediationExecutionState] {
        return [
            .failed,
            .inProgress,
            .queued,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .queued: return "QUEUED"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RemediationExecutionState(rawValue: rawValue) ?? RemediationExecutionState.sdkUnknown(rawValue)
    }
}

extension RemediationExecutionStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case invocationTime = "InvocationTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case resourceKey = "ResourceKey"
        case state = "State"
        case stepDetails = "StepDetails"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invocationTime = invocationTime {
            try encodeContainer.encode(invocationTime.timeIntervalSince1970, forKey: .invocationTime)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let resourceKey = resourceKey {
            try encodeContainer.encode(resourceKey, forKey: .resourceKey)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stepDetails = stepDetails {
            var stepDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stepDetails)
            for remediationexecutionsteps0 in stepDetails {
                try stepDetailsContainer.encode(remediationexecutionsteps0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceKeyDecoded = try containerValues.decodeIfPresent(ResourceKey.self, forKey: .resourceKey)
        resourceKey = resourceKeyDecoded
        let stateDecoded = try containerValues.decodeIfPresent(RemediationExecutionState.self, forKey: .state)
        state = stateDecoded
        let stepDetailsContainer = try containerValues.decodeIfPresent([RemediationExecutionStep?].self, forKey: .stepDetails)
        var stepDetailsDecoded0:[RemediationExecutionStep]? = nil
        if let stepDetailsContainer = stepDetailsContainer {
            stepDetailsDecoded0 = [RemediationExecutionStep]()
            for structure0 in stepDetailsContainer {
                if let structure0 = structure0 {
                    stepDetailsDecoded0?.append(structure0)
                }
            }
        }
        stepDetails = stepDetailsDecoded0
        let invocationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .invocationTime)
        invocationTime = invocationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension RemediationExecutionStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemediationExecutionStatus(invocationTime: \(String(describing: invocationTime)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), resourceKey: \(String(describing: resourceKey)), state: \(String(describing: state)), stepDetails: \(String(describing: stepDetails)))"}
}

/// <p>Provides details of the current status of the invoked remediation action for that resource.</p>
public struct RemediationExecutionStatus: Equatable {
    /// <p>Start time when the remediation was executed.</p>
    public let invocationTime: Date?
    /// <p>The time when the remediation execution was last updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>The details that identify a resource within AWS Config, including
    /// 			the resource type and resource ID.</p>
    public let resourceKey: ResourceKey?
    /// <p>ENUM of the values.</p>
    public let state: RemediationExecutionState?
    /// <p>Details of every step.</p>
    public let stepDetails: [RemediationExecutionStep]?

    public init (
        invocationTime: Date? = nil,
        lastUpdatedTime: Date? = nil,
        resourceKey: ResourceKey? = nil,
        state: RemediationExecutionState? = nil,
        stepDetails: [RemediationExecutionStep]? = nil
    )
    {
        self.invocationTime = invocationTime
        self.lastUpdatedTime = lastUpdatedTime
        self.resourceKey = resourceKey
        self.state = state
        self.stepDetails = stepDetails
    }
}

extension RemediationExecutionStep: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorMessage = "ErrorMessage"
        case name = "Name"
        case startTime = "StartTime"
        case state = "State"
        case stopTime = "StopTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stopTime = stopTime {
            try encodeContainer.encode(stopTime.timeIntervalSince1970, forKey: .stopTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(RemediationExecutionStepState.self, forKey: .state)
        state = stateDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let stopTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .stopTime)
        stopTime = stopTimeDecoded
    }
}

extension RemediationExecutionStep: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemediationExecutionStep(errorMessage: \(String(describing: errorMessage)), name: \(String(describing: name)), startTime: \(String(describing: startTime)), state: \(String(describing: state)), stopTime: \(String(describing: stopTime)))"}
}

/// <p>Name of the step from the SSM document.</p>
public struct RemediationExecutionStep: Equatable {
    /// <p>An error message if the step was interrupted during execution.</p>
    public let errorMessage: String?
    /// <p>The details of the step.</p>
    public let name: String?
    /// <p>The time when the step started.</p>
    public let startTime: Date?
    /// <p>The valid status of the step.</p>
    public let state: RemediationExecutionStepState?
    /// <p>The time when the step stopped.</p>
    public let stopTime: Date?

    public init (
        errorMessage: String? = nil,
        name: String? = nil,
        startTime: Date? = nil,
        state: RemediationExecutionStepState? = nil,
        stopTime: Date? = nil
    )
    {
        self.errorMessage = errorMessage
        self.name = name
        self.startTime = startTime
        self.state = state
        self.stopTime = stopTime
    }
}

public enum RemediationExecutionStepState {
    case failed
    case pending
    case succeeded
    case sdkUnknown(String)
}

extension RemediationExecutionStepState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RemediationExecutionStepState] {
        return [
            .failed,
            .pending,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .pending: return "PENDING"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RemediationExecutionStepState(rawValue: rawValue) ?? RemediationExecutionStepState.sdkUnknown(rawValue)
    }
}

extension RemediationInProgressException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemediationInProgressException(message: \(String(describing: message)))"}
}

extension RemediationInProgressException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RemediationInProgressExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Remediation action is in progress. You can either cancel execution in AWS Systems Manager or wait and try again later. </p>
public struct RemediationInProgressException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RemediationInProgressExceptionBody: Equatable {
    public let message: String?
}

extension RemediationInProgressExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RemediationParameterValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceValue = "ResourceValue"
        case staticValue = "StaticValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceValue = resourceValue {
            try encodeContainer.encode(resourceValue, forKey: .resourceValue)
        }
        if let staticValue = staticValue {
            try encodeContainer.encode(staticValue, forKey: .staticValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceValueDecoded = try containerValues.decodeIfPresent(ResourceValue.self, forKey: .resourceValue)
        resourceValue = resourceValueDecoded
        let staticValueDecoded = try containerValues.decodeIfPresent(StaticValue.self, forKey: .staticValue)
        staticValue = staticValueDecoded
    }
}

extension RemediationParameterValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemediationParameterValue(resourceValue: \(String(describing: resourceValue)), staticValue: \(String(describing: staticValue)))"}
}

/// <p>The value is either a dynamic (resource) value or a static value. You must select either a dynamic value or a static value.</p>
public struct RemediationParameterValue: Equatable {
    /// <p>The value is dynamic and changes at run-time.</p>
    public let resourceValue: ResourceValue?
    /// <p>The value is static and does not change at run-time.</p>
    public let staticValue: StaticValue?

    public init (
        resourceValue: ResourceValue? = nil,
        staticValue: StaticValue? = nil
    )
    {
        self.resourceValue = resourceValue
        self.staticValue = staticValue
    }
}

public enum RemediationTargetType {
    case ssmDocument
    case sdkUnknown(String)
}

extension RemediationTargetType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RemediationTargetType] {
        return [
            .ssmDocument,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ssmDocument: return "SSM_DOCUMENT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RemediationTargetType(rawValue: rawValue) ?? RemediationTargetType.sdkUnknown(rawValue)
    }
}

extension ResourceConcurrentModificationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceConcurrentModificationException(message: \(String(describing: message)))"}
}

extension ResourceConcurrentModificationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Two users are trying to modify the same query at the same time. Wait for a moment and try again.</p>
public struct ResourceConcurrentModificationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceConcurrentModificationExceptionBody: Equatable {
    public let message: String?
}

extension ResourceConcurrentModificationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceCount: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case count
        case resourceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let countDecoded = try containerValues.decode(Int.self, forKey: .count)
        count = countDecoded
    }
}

extension ResourceCount: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceCount(count: \(String(describing: count)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>An object that contains the resource type and the number of
/// 			resources.</p>
public struct ResourceCount: Equatable {
    /// <p>The number of resources.</p>
    public let count: Int
    /// <p>The resource type (for example,
    /// 				<code>"AWS::EC2::Instance"</code>).</p>
    public let resourceType: ResourceType?

    public init (
        count: Int = 0,
        resourceType: ResourceType? = nil
    )
    {
        self.count = count
        self.resourceType = resourceType
    }
}

extension ResourceCountFilters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case region = "Region"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
    }
}

extension ResourceCountFilters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceCountFilters(accountId: \(String(describing: accountId)), region: \(String(describing: region)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Filters the resource count based on account ID, region, and resource type.</p>
public struct ResourceCountFilters: Equatable {
    /// <p>The 12-digit ID of the account.</p>
    public let accountId: String?
    /// <p>The region where the account is located.</p>
    public let region: String?
    /// <p>The type of the AWS resource.</p>
    public let resourceType: ResourceType?

    public init (
        accountId: String? = nil,
        region: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.accountId = accountId
        self.region = region
        self.resourceType = resourceType
    }
}

public enum ResourceCountGroupKey {
    case accountId
    case awsRegion
    case resourceType
    case sdkUnknown(String)
}

extension ResourceCountGroupKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceCountGroupKey] {
        return [
            .accountId,
            .awsRegion,
            .resourceType,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accountId: return "ACCOUNT_ID"
        case .awsRegion: return "AWS_REGION"
        case .resourceType: return "RESOURCE_TYPE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceCountGroupKey(rawValue: rawValue) ?? ResourceCountGroupKey.sdkUnknown(rawValue)
    }
}

extension ResourceFilters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case region = "Region"
        case resourceId = "ResourceId"
        case resourceName = "ResourceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
    }
}

extension ResourceFilters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceFilters(accountId: \(String(describing: accountId)), region: \(String(describing: region)), resourceId: \(String(describing: resourceId)), resourceName: \(String(describing: resourceName)))"}
}

/// <p>Filters the results by resource account ID, region, resource ID, and resource name.</p>
public struct ResourceFilters: Equatable {
    /// <p>The 12-digit source account ID.</p>
    public let accountId: String?
    /// <p>The source region.</p>
    public let region: String?
    /// <p>The ID of the resource.</p>
    public let resourceId: String?
    /// <p>The name of the resource.</p>
    public let resourceName: String?

    public init (
        accountId: String? = nil,
        region: String? = nil,
        resourceId: String? = nil,
        resourceName: String? = nil
    )
    {
        self.accountId = accountId
        self.region = region
        self.resourceId = resourceId
        self.resourceName = resourceName
    }
}

extension ResourceIdentifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceDeletionTime
        case resourceId
        case resourceName
        case resourceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceDeletionTime = resourceDeletionTime {
            try encodeContainer.encode(resourceDeletionTime.timeIntervalSince1970, forKey: .resourceDeletionTime)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let resourceDeletionTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .resourceDeletionTime)
        resourceDeletionTime = resourceDeletionTimeDecoded
    }
}

extension ResourceIdentifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceIdentifier(resourceDeletionTime: \(String(describing: resourceDeletionTime)), resourceId: \(String(describing: resourceId)), resourceName: \(String(describing: resourceName)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>The details that identify a resource that is discovered by AWS
/// 			Config, including the resource type, ID, and (if available) the
/// 			custom resource name.</p>
public struct ResourceIdentifier: Equatable {
    /// <p>The time that the resource was deleted.</p>
    public let resourceDeletionTime: Date?
    /// <p>The ID of the resource (for example,
    /// 			<code>sg-xxxxxx</code>).</p>
    public let resourceId: String?
    /// <p>The custom name of the resource (if available).</p>
    public let resourceName: String?
    /// <p>The type of resource.</p>
    public let resourceType: ResourceType?

    public init (
        resourceDeletionTime: Date? = nil,
        resourceId: String? = nil,
        resourceName: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.resourceDeletionTime = resourceDeletionTime
        self.resourceId = resourceId
        self.resourceName = resourceName
        self.resourceType = resourceType
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You see this exception in the following cases: </p>
/// 		       <ul>
///             <li>
///                <p>For DeleteConfigRule, AWS Config is deleting this rule. Try your request again later.</p>
///             </li>
///             <li>
///                <p>For DeleteConfigRule, the rule is deleting your evaluation results. Try your request again later.</p>
///             </li>
///             <li>
///                <p>For DeleteConfigRule, a remediation action is associated with the rule and AWS Config cannot delete this rule. Delete the remediation action associated with the rule before deleting the rule and try your request again later.</p>
///             </li>
///             <li>
///                <p>For PutConfigOrganizationRule, organization config rule deletion is in progress. Try your request again later.</p>
///             </li>
///             <li>
///                <p>For DeleteOrganizationConfigRule, organization config rule creation is in progress. Try your request again later.</p>
///             </li>
///             <li>
///                <p>For PutConformancePack and PutOrganizationConformancePack, a conformance pack creation, update, and deletion is in progress. Try your request again later.</p>
///             </li>
///             <li>
///                <p>For DeleteConformancePack, a conformance pack creation, update, and deletion is in progress. Try your request again later.</p>
///             </li>
///          </ul>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceKey: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId
        case resourceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension ResourceKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceKey(resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>The details that identify a resource within AWS Config, including
/// 			the resource type and resource ID.</p>
public struct ResourceKey: Equatable {
    /// <p>The ID of the resource (for example., sg-xxxxxx). </p>
    public let resourceId: String?
    /// <p>The resource type.</p>
    public let resourceType: ResourceType?

    public init (
        resourceId: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

extension ResourceNotDiscoveredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotDiscoveredException(message: \(String(describing: message)))"}
}

extension ResourceNotDiscoveredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotDiscoveredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have specified a resource that is either unknown or has not
/// 			been discovered.</p>
public struct ResourceNotDiscoveredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotDiscoveredExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotDiscoveredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have specified a resource that does not exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ResourceType {
    case accountpublicaccessblock
    case alarm
    case api
    case application
    case applicationversion
    case associationcompliance
    case autoscalinggroup
    case bucket
    case certificate
    case cloudformationproduct
    case cloudformationprovisionedproduct
    case cluster
    case clusterparametergroup
    case clustersecuritygroup
    case clustersnapshot
    case clustersubnetgroup
    case conformancepackcompliance
    case customergateway
    case dbcluster
    case dbclustersnapshot
    case dbinstance
    case dbsecuritygroup
    case dbsnapshot
    case dbsubnetgroup
    case distribution
    case domain
    case eip
    case egressonlyinternetgateway
    case encryptionconfig
    case environment
    case eventsubscription
    case filedata
    case flowlog
    case function
    case group
    case host
    case ipsetv2
    case instance
    case internetgateway
    case key
    case launchconfiguration
    case loadbalancer
    case loadbalancerv2
    case managedinstanceinventory
    case managedrulesetv2
    case natgateway
    case networkacl
    case networkfirewallfirewall
    case networkfirewallfirewallpolicy
    case networkfirewallrulegroup
    case networkinterface
    case patchcompliance
    case pipeline
    case policy
    case portfolio
    case project
    case protection
    case qldbledger
    case queue
    case ratebasedrule
    case redshifteventsubscription
    case regexpatternsetv2
    case regionalprotection
    case regionalratebasedrule
    case regionalrule
    case regionalrulegroup
    case regionalwebacl
    case registeredhainstance
    case resourcecompliance
    case restapi
    case role
    case routetable
    case rule
    case rulegroup
    case rulegroupv2
    case scalingpolicy
    case scheduledaction
    case secret
    case securitygroup
    case stack
    case stage
    case stagev2
    case streamingdistribution
    case subnet
    case table
    case topic
    case trail
    case user
    case vpc
    case vpcendpoint
    case vpcendpointservice
    case vpcpeeringconnection
    case vpnconnection
    case vpngateway
    case volume
    case webacl
    case webaclv2
    case sdkUnknown(String)
}

extension ResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceType] {
        return [
            .accountpublicaccessblock,
            .alarm,
            .api,
            .application,
            .applicationversion,
            .associationcompliance,
            .autoscalinggroup,
            .bucket,
            .certificate,
            .cloudformationproduct,
            .cloudformationprovisionedproduct,
            .cluster,
            .clusterparametergroup,
            .clustersecuritygroup,
            .clustersnapshot,
            .clustersubnetgroup,
            .conformancepackcompliance,
            .customergateway,
            .dbcluster,
            .dbclustersnapshot,
            .dbinstance,
            .dbsecuritygroup,
            .dbsnapshot,
            .dbsubnetgroup,
            .distribution,
            .domain,
            .eip,
            .egressonlyinternetgateway,
            .encryptionconfig,
            .environment,
            .eventsubscription,
            .filedata,
            .flowlog,
            .function,
            .group,
            .host,
            .ipsetv2,
            .instance,
            .internetgateway,
            .key,
            .launchconfiguration,
            .loadbalancer,
            .loadbalancerv2,
            .managedinstanceinventory,
            .managedrulesetv2,
            .natgateway,
            .networkacl,
            .networkfirewallfirewall,
            .networkfirewallfirewallpolicy,
            .networkfirewallrulegroup,
            .networkinterface,
            .patchcompliance,
            .pipeline,
            .policy,
            .portfolio,
            .project,
            .protection,
            .qldbledger,
            .queue,
            .ratebasedrule,
            .redshifteventsubscription,
            .regexpatternsetv2,
            .regionalprotection,
            .regionalratebasedrule,
            .regionalrule,
            .regionalrulegroup,
            .regionalwebacl,
            .registeredhainstance,
            .resourcecompliance,
            .restapi,
            .role,
            .routetable,
            .rule,
            .rulegroup,
            .rulegroupv2,
            .scalingpolicy,
            .scheduledaction,
            .secret,
            .securitygroup,
            .stack,
            .stage,
            .stagev2,
            .streamingdistribution,
            .subnet,
            .table,
            .topic,
            .trail,
            .user,
            .vpc,
            .vpcendpoint,
            .vpcendpointservice,
            .vpcpeeringconnection,
            .vpnconnection,
            .vpngateway,
            .volume,
            .webacl,
            .webaclv2,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accountpublicaccessblock: return "AWS::S3::AccountPublicAccessBlock"
        case .alarm: return "AWS::CloudWatch::Alarm"
        case .api: return "AWS::ApiGatewayV2::Api"
        case .application: return "AWS::ElasticBeanstalk::Application"
        case .applicationversion: return "AWS::ElasticBeanstalk::ApplicationVersion"
        case .associationcompliance: return "AWS::SSM::AssociationCompliance"
        case .autoscalinggroup: return "AWS::AutoScaling::AutoScalingGroup"
        case .bucket: return "AWS::S3::Bucket"
        case .certificate: return "AWS::ACM::Certificate"
        case .cloudformationproduct: return "AWS::ServiceCatalog::CloudFormationProduct"
        case .cloudformationprovisionedproduct: return "AWS::ServiceCatalog::CloudFormationProvisionedProduct"
        case .cluster: return "AWS::Redshift::Cluster"
        case .clusterparametergroup: return "AWS::Redshift::ClusterParameterGroup"
        case .clustersecuritygroup: return "AWS::Redshift::ClusterSecurityGroup"
        case .clustersnapshot: return "AWS::Redshift::ClusterSnapshot"
        case .clustersubnetgroup: return "AWS::Redshift::ClusterSubnetGroup"
        case .conformancepackcompliance: return "AWS::Config::ConformancePackCompliance"
        case .customergateway: return "AWS::EC2::CustomerGateway"
        case .dbcluster: return "AWS::RDS::DBCluster"
        case .dbclustersnapshot: return "AWS::RDS::DBClusterSnapshot"
        case .dbinstance: return "AWS::RDS::DBInstance"
        case .dbsecuritygroup: return "AWS::RDS::DBSecurityGroup"
        case .dbsnapshot: return "AWS::RDS::DBSnapshot"
        case .dbsubnetgroup: return "AWS::RDS::DBSubnetGroup"
        case .distribution: return "AWS::CloudFront::Distribution"
        case .domain: return "AWS::Elasticsearch::Domain"
        case .eip: return "AWS::EC2::EIP"
        case .egressonlyinternetgateway: return "AWS::EC2::EgressOnlyInternetGateway"
        case .encryptionconfig: return "AWS::XRay::EncryptionConfig"
        case .environment: return "AWS::ElasticBeanstalk::Environment"
        case .eventsubscription: return "AWS::RDS::EventSubscription"
        case .filedata: return "AWS::SSM::FileData"
        case .flowlog: return "AWS::EC2::FlowLog"
        case .function: return "AWS::Lambda::Function"
        case .group: return "AWS::IAM::Group"
        case .host: return "AWS::EC2::Host"
        case .ipsetv2: return "AWS::WAFv2::IPSet"
        case .instance: return "AWS::EC2::Instance"
        case .internetgateway: return "AWS::EC2::InternetGateway"
        case .key: return "AWS::KMS::Key"
        case .launchconfiguration: return "AWS::AutoScaling::LaunchConfiguration"
        case .loadbalancer: return "AWS::ElasticLoadBalancing::LoadBalancer"
        case .loadbalancerv2: return "AWS::ElasticLoadBalancingV2::LoadBalancer"
        case .managedinstanceinventory: return "AWS::SSM::ManagedInstanceInventory"
        case .managedrulesetv2: return "AWS::WAFv2::ManagedRuleSet"
        case .natgateway: return "AWS::EC2::NatGateway"
        case .networkacl: return "AWS::EC2::NetworkAcl"
        case .networkfirewallfirewall: return "AWS::NetworkFirewall::Firewall"
        case .networkfirewallfirewallpolicy: return "AWS::NetworkFirewall::FirewallPolicy"
        case .networkfirewallrulegroup: return "AWS::NetworkFirewall::RuleGroup"
        case .networkinterface: return "AWS::EC2::NetworkInterface"
        case .patchcompliance: return "AWS::SSM::PatchCompliance"
        case .pipeline: return "AWS::CodePipeline::Pipeline"
        case .policy: return "AWS::IAM::Policy"
        case .portfolio: return "AWS::ServiceCatalog::Portfolio"
        case .project: return "AWS::CodeBuild::Project"
        case .protection: return "AWS::Shield::Protection"
        case .qldbledger: return "AWS::QLDB::Ledger"
        case .queue: return "AWS::SQS::Queue"
        case .ratebasedrule: return "AWS::WAF::RateBasedRule"
        case .redshifteventsubscription: return "AWS::Redshift::EventSubscription"
        case .regexpatternsetv2: return "AWS::WAFv2::RegexPatternSet"
        case .regionalprotection: return "AWS::ShieldRegional::Protection"
        case .regionalratebasedrule: return "AWS::WAFRegional::RateBasedRule"
        case .regionalrule: return "AWS::WAFRegional::Rule"
        case .regionalrulegroup: return "AWS::WAFRegional::RuleGroup"
        case .regionalwebacl: return "AWS::WAFRegional::WebACL"
        case .registeredhainstance: return "AWS::EC2::RegisteredHAInstance"
        case .resourcecompliance: return "AWS::Config::ResourceCompliance"
        case .restapi: return "AWS::ApiGateway::RestApi"
        case .role: return "AWS::IAM::Role"
        case .routetable: return "AWS::EC2::RouteTable"
        case .rule: return "AWS::WAF::Rule"
        case .rulegroup: return "AWS::WAF::RuleGroup"
        case .rulegroupv2: return "AWS::WAFv2::RuleGroup"
        case .scalingpolicy: return "AWS::AutoScaling::ScalingPolicy"
        case .scheduledaction: return "AWS::AutoScaling::ScheduledAction"
        case .secret: return "AWS::SecretsManager::Secret"
        case .securitygroup: return "AWS::EC2::SecurityGroup"
        case .stack: return "AWS::CloudFormation::Stack"
        case .stage: return "AWS::ApiGateway::Stage"
        case .stagev2: return "AWS::ApiGatewayV2::Stage"
        case .streamingdistribution: return "AWS::CloudFront::StreamingDistribution"
        case .subnet: return "AWS::EC2::Subnet"
        case .table: return "AWS::DynamoDB::Table"
        case .topic: return "AWS::SNS::Topic"
        case .trail: return "AWS::CloudTrail::Trail"
        case .user: return "AWS::IAM::User"
        case .vpc: return "AWS::EC2::VPC"
        case .vpcendpoint: return "AWS::EC2::VPCEndpoint"
        case .vpcendpointservice: return "AWS::EC2::VPCEndpointService"
        case .vpcpeeringconnection: return "AWS::EC2::VPCPeeringConnection"
        case .vpnconnection: return "AWS::EC2::VPNConnection"
        case .vpngateway: return "AWS::EC2::VPNGateway"
        case .volume: return "AWS::EC2::Volume"
        case .webacl: return "AWS::WAF::WebACL"
        case .webaclv2: return "AWS::WAFv2::WebACL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
    }
}

extension ResourceValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = value {
            try encodeContainer.encode(value.rawValue, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(ResourceValueType.self, forKey: .value)
        value = valueDecoded
    }
}

extension ResourceValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceValue(value: \(String(describing: value)))"}
}

/// <p>The dynamic value of the resource.</p>
public struct ResourceValue: Equatable {
    /// <p>The value is a resource ID.</p>
    public let value: ResourceValueType?

    public init (
        value: ResourceValueType? = nil
    )
    {
        self.value = value
    }
}

public enum ResourceValueType {
    case resourceId
    case sdkUnknown(String)
}

extension ResourceValueType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceValueType] {
        return [
            .resourceId,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .resourceId: return "RESOURCE_ID"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceValueType(rawValue: rawValue) ?? ResourceValueType.sdkUnknown(rawValue)
    }
}

extension RetentionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case retentionPeriodInDays = "RetentionPeriodInDays"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if retentionPeriodInDays != 0 {
            try encodeContainer.encode(retentionPeriodInDays, forKey: .retentionPeriodInDays)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let retentionPeriodInDaysDecoded = try containerValues.decode(Int.self, forKey: .retentionPeriodInDays)
        retentionPeriodInDays = retentionPeriodInDaysDecoded
    }
}

extension RetentionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RetentionConfiguration(name: \(String(describing: name)), retentionPeriodInDays: \(String(describing: retentionPeriodInDays)))"}
}

/// <p>An object with the name of the retention configuration and the retention period in days. The object stores the configuration for data retention in AWS Config.</p>
public struct RetentionConfiguration: Equatable {
    /// <p>The name of the retention configuration object.</p>
    public let name: String?
    /// <p>Number of days AWS Config stores your historical information.</p>
    /// 		       <note>
    ///             <p>Currently, only applicable to the configuration item history.</p>
    ///          </note>
    public let retentionPeriodInDays: Int

    public init (
        name: String? = nil,
        retentionPeriodInDays: Int = 0
    )
    {
        self.name = name
        self.retentionPeriodInDays = retentionPeriodInDays
    }
}

extension Scope: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceResourceId = "ComplianceResourceId"
        case complianceResourceTypes = "ComplianceResourceTypes"
        case tagKey = "TagKey"
        case tagValue = "TagValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceResourceId = complianceResourceId {
            try encodeContainer.encode(complianceResourceId, forKey: .complianceResourceId)
        }
        if let complianceResourceTypes = complianceResourceTypes {
            var complianceResourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .complianceResourceTypes)
            for complianceresourcetypes0 in complianceResourceTypes {
                try complianceResourceTypesContainer.encode(complianceresourcetypes0)
            }
        }
        if let tagKey = tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let tagValue = tagValue {
            try encodeContainer.encode(tagValue, forKey: .tagValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceResourceTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .complianceResourceTypes)
        var complianceResourceTypesDecoded0:[String]? = nil
        if let complianceResourceTypesContainer = complianceResourceTypesContainer {
            complianceResourceTypesDecoded0 = [String]()
            for string0 in complianceResourceTypesContainer {
                if let string0 = string0 {
                    complianceResourceTypesDecoded0?.append(string0)
                }
            }
        }
        complianceResourceTypes = complianceResourceTypesDecoded0
        let tagKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let tagValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tagValue)
        tagValue = tagValueDecoded
        let complianceResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .complianceResourceId)
        complianceResourceId = complianceResourceIdDecoded
    }
}

extension Scope: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Scope(complianceResourceId: \(String(describing: complianceResourceId)), complianceResourceTypes: \(String(describing: complianceResourceTypes)), tagKey: \(String(describing: tagKey)), tagValue: \(String(describing: tagValue)))"}
}

/// <p>Defines which resources trigger an evaluation for an AWS Config
/// 			rule. The scope can include one or more resource types, a
/// 			combination of a tag key and value, or a combination of one resource
/// 			type and one resource ID. Specify a scope to constrain which
/// 			resources trigger an evaluation for a rule. Otherwise, evaluations
/// 			for the rule are triggered when any resource in your recording group
/// 			changes in configuration.</p>
public struct Scope: Equatable {
    /// <p>The ID of the only AWS resource that you want to trigger an
    /// 			evaluation for the rule. If you specify a resource ID, you must
    /// 			specify one resource type for
    /// 			<code>ComplianceResourceTypes</code>.</p>
    public let complianceResourceId: String?
    /// <p>The resource types of only those AWS resources that you want to
    /// 			trigger an evaluation for the rule. You can only specify one type if
    /// 			you also specify a resource ID for
    /// 			<code>ComplianceResourceId</code>.</p>
    public let complianceResourceTypes: [String]?
    /// <p>The tag key that is applied to only those AWS resources that
    /// 			you want to trigger an evaluation for the rule.</p>
    public let tagKey: String?
    /// <p>The tag value applied to only those AWS resources that you want
    /// 			to trigger an evaluation for the rule. If you specify a value for
    /// 				<code>TagValue</code>, you must also specify a value for
    /// 				<code>TagKey</code>.</p>
    public let tagValue: String?

    public init (
        complianceResourceId: String? = nil,
        complianceResourceTypes: [String]? = nil,
        tagKey: String? = nil,
        tagValue: String? = nil
    )
    {
        self.complianceResourceId = complianceResourceId
        self.complianceResourceTypes = complianceResourceTypes
        self.tagKey = tagKey
        self.tagValue = tagValue
    }
}

public struct SelectAggregateResourceConfigInputBodyMiddleware: Middleware {
    public let id: String = "SelectAggregateResourceConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SelectAggregateResourceConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<SelectAggregateResourceConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SelectAggregateResourceConfigInput>
    public typealias MOutput = OperationOutput<SelectAggregateResourceConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SelectAggregateResourceConfigOutputError>
}

extension SelectAggregateResourceConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SelectAggregateResourceConfigInput(configurationAggregatorName: \(String(describing: configurationAggregatorName)), expression: \(String(describing: expression)), limit: \(String(describing: limit)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension SelectAggregateResourceConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case expression = "Expression"
        case limit = "Limit"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationAggregatorName = configurationAggregatorName {
            try encodeContainer.encode(configurationAggregatorName, forKey: .configurationAggregatorName)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct SelectAggregateResourceConfigInputHeadersMiddleware: Middleware {
    public let id: String = "SelectAggregateResourceConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SelectAggregateResourceConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<SelectAggregateResourceConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SelectAggregateResourceConfigInput>
    public typealias MOutput = OperationOutput<SelectAggregateResourceConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SelectAggregateResourceConfigOutputError>
}

public struct SelectAggregateResourceConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "SelectAggregateResourceConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SelectAggregateResourceConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<SelectAggregateResourceConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SelectAggregateResourceConfigInput>
    public typealias MOutput = OperationOutput<SelectAggregateResourceConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SelectAggregateResourceConfigOutputError>
}

public struct SelectAggregateResourceConfigInput: Equatable {
    /// <p>The name of the configuration aggregator.</p>
    public let configurationAggregatorName: String?
    /// <p>The SQL query SELECT command. </p>
    public let expression: String?
    /// <p>The maximum number of query results returned on each page. </p>
    public let limit: Int
    /// <p>The maximum number of query results returned on each page. AWS Config also allows the Limit request parameter.</p>
    public let maxResults: Int
    /// <p>The nextToken string returned in a previous request that you use to request the next page of results in a paginated response. </p>
    public let nextToken: String?

    public init (
        configurationAggregatorName: String? = nil,
        expression: String? = nil,
        limit: Int = 0,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.expression = expression
        self.limit = limit
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SelectAggregateResourceConfigInputBody: Equatable {
    public let expression: String?
    public let configurationAggregatorName: String?
    public let limit: Int
    public let maxResults: Int
    public let nextToken: String?
}

extension SelectAggregateResourceConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationAggregatorName = "ConfigurationAggregatorName"
        case expression = "Expression"
        case limit = "Limit"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expression)
        expression = expressionDecoded
        let configurationAggregatorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationAggregatorName)
        configurationAggregatorName = configurationAggregatorNameDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SelectAggregateResourceConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SelectAggregateResourceConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidExpressionException" : self = .invalidExpressionException(try InvalidExpressionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigurationAggregatorException" : self = .noSuchConfigurationAggregatorException(try NoSuchConfigurationAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SelectAggregateResourceConfigOutputError: Equatable {
    case invalidExpressionException(InvalidExpressionException)
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case noSuchConfigurationAggregatorException(NoSuchConfigurationAggregatorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SelectAggregateResourceConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SelectAggregateResourceConfigOutputResponse(nextToken: \(String(describing: nextToken)), queryInfo: \(String(describing: queryInfo)), results: \(String(describing: results)))"}
}

extension SelectAggregateResourceConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SelectAggregateResourceConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.queryInfo = output.queryInfo
            self.results = output.results
        } else {
            self.nextToken = nil
            self.queryInfo = nil
            self.results = nil
        }
    }
}

public struct SelectAggregateResourceConfigOutputResponse: Equatable {
    /// <p>The nextToken string returned in a previous request that you use to request the next page of results in a paginated response. </p>
    public let nextToken: String?
    /// <p>Details about the query.</p>
    public let queryInfo: QueryInfo?
    /// <p>Returns the results for the SQL query.</p>
    public let results: [String]?

    public init (
        nextToken: String? = nil,
        queryInfo: QueryInfo? = nil,
        results: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.queryInfo = queryInfo
        self.results = results
    }
}

struct SelectAggregateResourceConfigOutputResponseBody: Equatable {
    public let results: [String]?
    public let queryInfo: QueryInfo?
    public let nextToken: String?
}

extension SelectAggregateResourceConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case queryInfo = "QueryInfo"
        case results = "Results"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .results)
        var resultsDecoded0:[String]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [String]()
            for string0 in resultsContainer {
                if let string0 = string0 {
                    resultsDecoded0?.append(string0)
                }
            }
        }
        results = resultsDecoded0
        let queryInfoDecoded = try containerValues.decodeIfPresent(QueryInfo.self, forKey: .queryInfo)
        queryInfo = queryInfoDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct SelectResourceConfigInputBodyMiddleware: Middleware {
    public let id: String = "SelectResourceConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SelectResourceConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<SelectResourceConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SelectResourceConfigInput>
    public typealias MOutput = OperationOutput<SelectResourceConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SelectResourceConfigOutputError>
}

extension SelectResourceConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SelectResourceConfigInput(expression: \(String(describing: expression)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension SelectResourceConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case expression = "Expression"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct SelectResourceConfigInputHeadersMiddleware: Middleware {
    public let id: String = "SelectResourceConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SelectResourceConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<SelectResourceConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SelectResourceConfigInput>
    public typealias MOutput = OperationOutput<SelectResourceConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SelectResourceConfigOutputError>
}

public struct SelectResourceConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "SelectResourceConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SelectResourceConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<SelectResourceConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SelectResourceConfigInput>
    public typealias MOutput = OperationOutput<SelectResourceConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SelectResourceConfigOutputError>
}

public struct SelectResourceConfigInput: Equatable {
    /// <p>The SQL query <code>SELECT</code> command.</p>
    public let expression: String?
    /// <p>The maximum number of query results returned on each page. </p>
    public let limit: Int
    /// <p>The <code>nextToken</code> string returned in a previous request that you use to request the next page of results in a paginated response. </p>
    public let nextToken: String?

    public init (
        expression: String? = nil,
        limit: Int = 0,
        nextToken: String? = nil
    )
    {
        self.expression = expression
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct SelectResourceConfigInputBody: Equatable {
    public let expression: String?
    public let limit: Int
    public let nextToken: String?
}

extension SelectResourceConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case expression = "Expression"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expression)
        expression = expressionDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SelectResourceConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SelectResourceConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidExpressionException" : self = .invalidExpressionException(try InvalidExpressionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLimitException" : self = .invalidLimitException(try InvalidLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SelectResourceConfigOutputError: Equatable {
    case invalidExpressionException(InvalidExpressionException)
    case invalidLimitException(InvalidLimitException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SelectResourceConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SelectResourceConfigOutputResponse(nextToken: \(String(describing: nextToken)), queryInfo: \(String(describing: queryInfo)), results: \(String(describing: results)))"}
}

extension SelectResourceConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SelectResourceConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.queryInfo = output.queryInfo
            self.results = output.results
        } else {
            self.nextToken = nil
            self.queryInfo = nil
            self.results = nil
        }
    }
}

public struct SelectResourceConfigOutputResponse: Equatable {
    /// <p>The <code>nextToken</code> string returned in a previous request that you use to request the next page of results in a paginated response. </p>
    public let nextToken: String?
    /// <p>Returns the <code>QueryInfo</code> object.</p>
    public let queryInfo: QueryInfo?
    /// <p>Returns the results for the SQL query.</p>
    public let results: [String]?

    public init (
        nextToken: String? = nil,
        queryInfo: QueryInfo? = nil,
        results: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.queryInfo = queryInfo
        self.results = results
    }
}

struct SelectResourceConfigOutputResponseBody: Equatable {
    public let results: [String]?
    public let queryInfo: QueryInfo?
    public let nextToken: String?
}

extension SelectResourceConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case queryInfo = "QueryInfo"
        case results = "Results"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .results)
        var resultsDecoded0:[String]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [String]()
            for string0 in resultsContainer {
                if let string0 = string0 {
                    resultsDecoded0?.append(string0)
                }
            }
        }
        results = resultsDecoded0
        let queryInfoDecoded = try containerValues.decodeIfPresent(QueryInfo.self, forKey: .queryInfo)
        queryInfo = queryInfoDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension Source: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case owner = "Owner"
        case sourceDetails = "SourceDetails"
        case sourceIdentifier = "SourceIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let owner = owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
        if let sourceDetails = sourceDetails {
            var sourceDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceDetails)
            for sourcedetails0 in sourceDetails {
                try sourceDetailsContainer.encode(sourcedetails0)
            }
        }
        if let sourceIdentifier = sourceIdentifier {
            try encodeContainer.encode(sourceIdentifier, forKey: .sourceIdentifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(Owner.self, forKey: .owner)
        owner = ownerDecoded
        let sourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceIdentifier)
        sourceIdentifier = sourceIdentifierDecoded
        let sourceDetailsContainer = try containerValues.decodeIfPresent([SourceDetail?].self, forKey: .sourceDetails)
        var sourceDetailsDecoded0:[SourceDetail]? = nil
        if let sourceDetailsContainer = sourceDetailsContainer {
            sourceDetailsDecoded0 = [SourceDetail]()
            for structure0 in sourceDetailsContainer {
                if let structure0 = structure0 {
                    sourceDetailsDecoded0?.append(structure0)
                }
            }
        }
        sourceDetails = sourceDetailsDecoded0
    }
}

extension Source: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Source(owner: \(String(describing: owner)), sourceDetails: \(String(describing: sourceDetails)), sourceIdentifier: \(String(describing: sourceIdentifier)))"}
}

/// <p>Provides the AWS Config rule owner (AWS or customer), the rule
/// 			identifier, and the events that trigger the evaluation of your AWS
/// 			resources.</p>
public struct Source: Equatable {
    /// <p>Indicates whether AWS or the customer owns and manages the AWS
    /// 			Config rule.</p>
    public let owner: Owner?
    /// <p>Provides the source and type of the event that causes AWS
    /// 			Config to evaluate your AWS resources.</p>
    public let sourceDetails: [SourceDetail]?
    /// <p>For AWS Config managed rules, a predefined identifier from a
    /// 			list. For example, <code>IAM_PASSWORD_POLICY</code> is a managed
    /// 			rule. To reference a managed rule, see <a href="https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_use-managed-rules.html">Using AWS Managed Config Rules</a>.</p>
    /// 		       <p>For custom rules, the identifier is the Amazon Resource Name
    /// 			(ARN) of the rule's AWS Lambda function, such as
    /// 				<code>arn:aws:lambda:us-east-2:123456789012:function:custom_rule_name</code>.</p>
    public let sourceIdentifier: String?

    public init (
        owner: Owner? = nil,
        sourceDetails: [SourceDetail]? = nil,
        sourceIdentifier: String? = nil
    )
    {
        self.owner = owner
        self.sourceDetails = sourceDetails
        self.sourceIdentifier = sourceIdentifier
    }
}

extension SourceDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventSource = "EventSource"
        case maximumExecutionFrequency = "MaximumExecutionFrequency"
        case messageType = "MessageType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventSource = eventSource {
            try encodeContainer.encode(eventSource.rawValue, forKey: .eventSource)
        }
        if let maximumExecutionFrequency = maximumExecutionFrequency {
            try encodeContainer.encode(maximumExecutionFrequency.rawValue, forKey: .maximumExecutionFrequency)
        }
        if let messageType = messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSourceDecoded = try containerValues.decodeIfPresent(EventSource.self, forKey: .eventSource)
        eventSource = eventSourceDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let maximumExecutionFrequencyDecoded = try containerValues.decodeIfPresent(MaximumExecutionFrequency.self, forKey: .maximumExecutionFrequency)
        maximumExecutionFrequency = maximumExecutionFrequencyDecoded
    }
}

extension SourceDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceDetail(eventSource: \(String(describing: eventSource)), maximumExecutionFrequency: \(String(describing: maximumExecutionFrequency)), messageType: \(String(describing: messageType)))"}
}

/// <p>Provides the source and the message types that trigger AWS
/// 			Config to evaluate your AWS resources against a rule. It also
/// 			provides the frequency with which you want AWS Config to run
/// 			evaluations for the rule if the trigger type is periodic. You can
/// 			specify the parameter values for <code>SourceDetail</code> only for
/// 			custom rules. </p>
public struct SourceDetail: Equatable {
    /// <p>The source of the event, such as an AWS service, that triggers
    /// 			AWS Config to evaluate your AWS resources.</p>
    public let eventSource: EventSource?
    /// <p>The frequency at which you want AWS Config to run evaluations
    /// 			for a custom rule with a periodic trigger. If you specify a value
    /// 			for <code>MaximumExecutionFrequency</code>, then
    /// 				<code>MessageType</code> must use the
    /// 				<code>ScheduledNotification</code> value.</p>
    ///
    ///
    /// 		
    ///
    ///
    /// 		       <note>
    /// 			         <p>By default, rules with a periodic trigger are evaluated
    /// 				every 24 hours. To change the frequency, specify a valid value
    /// 				for the <code>MaximumExecutionFrequency</code>
    /// 				parameter.</p>
    /// 			         <p>Based on the valid value you choose, AWS Config runs
    /// 				evaluations once for each valid value. For example, if you
    /// 				choose <code>Three_Hours</code>, AWS Config runs evaluations
    /// 				once every three hours. In this case, <code>Three_Hours</code>
    /// 				is the frequency of this rule. </p>
    /// 		       </note>
    public let maximumExecutionFrequency: MaximumExecutionFrequency?
    /// <p>The type of notification that triggers AWS Config to run an
    /// 			evaluation for a rule. You can specify the following notification
    /// 			types:</p>
    ///
    ///
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    /// 					             <code>ConfigurationItemChangeNotification</code> - Triggers
    /// 					an evaluation when AWS Config delivers a configuration item
    /// 					as a result of a resource change.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>OversizedConfigurationItemChangeNotification</code>
    /// 					- Triggers an evaluation when AWS Config delivers an
    /// 					oversized configuration item. AWS Config may generate this
    /// 					notification type when a resource changes and the
    /// 					notification exceeds the maximum size allowed by Amazon
    /// 					SNS.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>ScheduledNotification</code> - Triggers a
    /// 					periodic evaluation at the frequency specified for
    /// 						<code>MaximumExecutionFrequency</code>.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>ConfigurationSnapshotDeliveryCompleted</code> -
    /// 					Triggers a periodic evaluation when AWS Config delivers a
    /// 					configuration snapshot.</p>
    /// 			         </li>
    ///          </ul>
    ///
    /// 		       <p>If you want your custom rule to be triggered by configuration
    /// 			changes, specify two SourceDetail objects, one for
    /// 				<code>ConfigurationItemChangeNotification</code> and one for
    /// 				<code>OversizedConfigurationItemChangeNotification</code>.</p>
    public let messageType: MessageType?

    public init (
        eventSource: EventSource? = nil,
        maximumExecutionFrequency: MaximumExecutionFrequency? = nil,
        messageType: MessageType? = nil
    )
    {
        self.eventSource = eventSource
        self.maximumExecutionFrequency = maximumExecutionFrequency
        self.messageType = messageType
    }
}

extension SsmControls: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case concurrentExecutionRatePercentage = "ConcurrentExecutionRatePercentage"
        case errorPercentage = "ErrorPercentage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let concurrentExecutionRatePercentage = concurrentExecutionRatePercentage {
            try encodeContainer.encode(concurrentExecutionRatePercentage, forKey: .concurrentExecutionRatePercentage)
        }
        if let errorPercentage = errorPercentage {
            try encodeContainer.encode(errorPercentage, forKey: .errorPercentage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let concurrentExecutionRatePercentageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .concurrentExecutionRatePercentage)
        concurrentExecutionRatePercentage = concurrentExecutionRatePercentageDecoded
        let errorPercentageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .errorPercentage)
        errorPercentage = errorPercentageDecoded
    }
}

extension SsmControls: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SsmControls(concurrentExecutionRatePercentage: \(String(describing: concurrentExecutionRatePercentage)), errorPercentage: \(String(describing: errorPercentage)))"}
}

/// <p>AWS Systems Manager (SSM) specific remediation controls.</p>
public struct SsmControls: Equatable {
    /// <p>The maximum percentage of remediation actions allowed to run in parallel on the non-compliant resources for that specific rule. You can specify a percentage, such as 10%. The default value is 10. </p>
    public let concurrentExecutionRatePercentage: Int?
    /// <p>The percentage of errors that are allowed before SSM stops running automations on non-compliant resources for that specific rule.
    /// 			You can specify a percentage of errors, for example 10%. If you do not specifiy a percentage, the default is 50%.
    /// 			For example, if you set the ErrorPercentage to 40% for 10 non-compliant resources, then SSM stops running the automations when the fifth error is received. </p>
    public let errorPercentage: Int?

    public init (
        concurrentExecutionRatePercentage: Int? = nil,
        errorPercentage: Int? = nil
    )
    {
        self.concurrentExecutionRatePercentage = concurrentExecutionRatePercentage
        self.errorPercentage = errorPercentage
    }
}

public struct StartConfigRulesEvaluationInputBodyMiddleware: Middleware {
    public let id: String = "StartConfigRulesEvaluationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartConfigRulesEvaluationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartConfigRulesEvaluationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartConfigRulesEvaluationInput>
    public typealias MOutput = OperationOutput<StartConfigRulesEvaluationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartConfigRulesEvaluationOutputError>
}

extension StartConfigRulesEvaluationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartConfigRulesEvaluationInput(configRuleNames: \(String(describing: configRuleNames)))"}
}

extension StartConfigRulesEvaluationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configRuleNames = "ConfigRuleNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleNames = configRuleNames {
            var configRuleNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configRuleNames)
            for reevaluateconfigrulenames0 in configRuleNames {
                try configRuleNamesContainer.encode(reevaluateconfigrulenames0)
            }
        }
    }
}

public struct StartConfigRulesEvaluationInputHeadersMiddleware: Middleware {
    public let id: String = "StartConfigRulesEvaluationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartConfigRulesEvaluationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartConfigRulesEvaluationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartConfigRulesEvaluationInput>
    public typealias MOutput = OperationOutput<StartConfigRulesEvaluationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartConfigRulesEvaluationOutputError>
}

public struct StartConfigRulesEvaluationInputQueryItemMiddleware: Middleware {
    public let id: String = "StartConfigRulesEvaluationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartConfigRulesEvaluationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartConfigRulesEvaluationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartConfigRulesEvaluationInput>
    public typealias MOutput = OperationOutput<StartConfigRulesEvaluationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartConfigRulesEvaluationOutputError>
}

/// <p></p>
public struct StartConfigRulesEvaluationInput: Equatable {
    /// <p>The list of names of AWS Config rules that you want to run
    /// 			evaluations for.</p>
    public let configRuleNames: [String]?

    public init (
        configRuleNames: [String]? = nil
    )
    {
        self.configRuleNames = configRuleNames
    }
}

struct StartConfigRulesEvaluationInputBody: Equatable {
    public let configRuleNames: [String]?
}

extension StartConfigRulesEvaluationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configRuleNames = "ConfigRuleNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .configRuleNames)
        var configRuleNamesDecoded0:[String]? = nil
        if let configRuleNamesContainer = configRuleNamesContainer {
            configRuleNamesDecoded0 = [String]()
            for string0 in configRuleNamesContainer {
                if let string0 = string0 {
                    configRuleNamesDecoded0?.append(string0)
                }
            }
        }
        configRuleNames = configRuleNamesDecoded0
    }
}

extension StartConfigRulesEvaluationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartConfigRulesEvaluationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigRuleException" : self = .noSuchConfigRuleException(try NoSuchConfigRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartConfigRulesEvaluationOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case noSuchConfigRuleException(NoSuchConfigRuleException)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartConfigRulesEvaluationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartConfigRulesEvaluationOutputResponse()"}
}

extension StartConfigRulesEvaluationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The output when you start the evaluation for the specified AWS
/// 			Config rule.</p>
public struct StartConfigRulesEvaluationOutputResponse: Equatable {

    public init() {}
}

struct StartConfigRulesEvaluationOutputResponseBody: Equatable {
}

extension StartConfigRulesEvaluationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct StartConfigurationRecorderInputBodyMiddleware: Middleware {
    public let id: String = "StartConfigurationRecorderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartConfigurationRecorderInput>,
                  next: H) -> Swift.Result<OperationOutput<StartConfigurationRecorderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartConfigurationRecorderInput>
    public typealias MOutput = OperationOutput<StartConfigurationRecorderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartConfigurationRecorderOutputError>
}

extension StartConfigurationRecorderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartConfigurationRecorderInput(configurationRecorderName: \(String(describing: configurationRecorderName)))"}
}

extension StartConfigurationRecorderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationRecorderName = "ConfigurationRecorderName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationRecorderName = configurationRecorderName {
            try encodeContainer.encode(configurationRecorderName, forKey: .configurationRecorderName)
        }
    }
}

public struct StartConfigurationRecorderInputHeadersMiddleware: Middleware {
    public let id: String = "StartConfigurationRecorderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartConfigurationRecorderInput>,
                  next: H) -> Swift.Result<OperationOutput<StartConfigurationRecorderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartConfigurationRecorderInput>
    public typealias MOutput = OperationOutput<StartConfigurationRecorderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartConfigurationRecorderOutputError>
}

public struct StartConfigurationRecorderInputQueryItemMiddleware: Middleware {
    public let id: String = "StartConfigurationRecorderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartConfigurationRecorderInput>,
                  next: H) -> Swift.Result<OperationOutput<StartConfigurationRecorderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartConfigurationRecorderInput>
    public typealias MOutput = OperationOutput<StartConfigurationRecorderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartConfigurationRecorderOutputError>
}

/// <p>The input for the <a>StartConfigurationRecorder</a>
/// 			action.</p>
public struct StartConfigurationRecorderInput: Equatable {
    /// <p>The name of the recorder object that records each configuration
    /// 			change made to the resources.</p>
    public let configurationRecorderName: String?

    public init (
        configurationRecorderName: String? = nil
    )
    {
        self.configurationRecorderName = configurationRecorderName
    }
}

struct StartConfigurationRecorderInputBody: Equatable {
    public let configurationRecorderName: String?
}

extension StartConfigurationRecorderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationRecorderName = "ConfigurationRecorderName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationRecorderNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationRecorderName)
        configurationRecorderName = configurationRecorderNameDecoded
    }
}

extension StartConfigurationRecorderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartConfigurationRecorderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoAvailableDeliveryChannelException" : self = .noAvailableDeliveryChannelException(try NoAvailableDeliveryChannelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchConfigurationRecorderException" : self = .noSuchConfigurationRecorderException(try NoSuchConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartConfigurationRecorderOutputError: Equatable {
    case noAvailableDeliveryChannelException(NoAvailableDeliveryChannelException)
    case noSuchConfigurationRecorderException(NoSuchConfigurationRecorderException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartConfigurationRecorderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartConfigurationRecorderOutputResponse()"}
}

extension StartConfigurationRecorderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StartConfigurationRecorderOutputResponse: Equatable {

    public init() {}
}

struct StartConfigurationRecorderOutputResponseBody: Equatable {
}

extension StartConfigurationRecorderOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct StartRemediationExecutionInputBodyMiddleware: Middleware {
    public let id: String = "StartRemediationExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartRemediationExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartRemediationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartRemediationExecutionInput>
    public typealias MOutput = OperationOutput<StartRemediationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartRemediationExecutionOutputError>
}

extension StartRemediationExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartRemediationExecutionInput(configRuleName: \(String(describing: configRuleName)), resourceKeys: \(String(describing: resourceKeys)))"}
}

extension StartRemediationExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configRuleName = "ConfigRuleName"
        case resourceKeys = "ResourceKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configRuleName = configRuleName {
            try encodeContainer.encode(configRuleName, forKey: .configRuleName)
        }
        if let resourceKeys = resourceKeys {
            var resourceKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceKeys)
            for resourcekeys0 in resourceKeys {
                try resourceKeysContainer.encode(resourcekeys0)
            }
        }
    }
}

public struct StartRemediationExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "StartRemediationExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartRemediationExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartRemediationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartRemediationExecutionInput>
    public typealias MOutput = OperationOutput<StartRemediationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartRemediationExecutionOutputError>
}

public struct StartRemediationExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "StartRemediationExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartRemediationExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartRemediationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartRemediationExecutionInput>
    public typealias MOutput = OperationOutput<StartRemediationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartRemediationExecutionOutputError>
}

public struct StartRemediationExecutionInput: Equatable {
    /// <p>The list of names of AWS Config rules that you want to run remediation execution for.</p>
    public let configRuleName: String?
    /// <p>A list of resource keys to be processed with the current request. Each element in the list consists of the resource type and resource ID. </p>
    public let resourceKeys: [ResourceKey]?

    public init (
        configRuleName: String? = nil,
        resourceKeys: [ResourceKey]? = nil
    )
    {
        self.configRuleName = configRuleName
        self.resourceKeys = resourceKeys
    }
}

struct StartRemediationExecutionInputBody: Equatable {
    public let configRuleName: String?
    public let resourceKeys: [ResourceKey]?
}

extension StartRemediationExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configRuleName = "ConfigRuleName"
        case resourceKeys = "ResourceKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configRuleName)
        configRuleName = configRuleNameDecoded
        let resourceKeysContainer = try containerValues.decodeIfPresent([ResourceKey?].self, forKey: .resourceKeys)
        var resourceKeysDecoded0:[ResourceKey]? = nil
        if let resourceKeysContainer = resourceKeysContainer {
            resourceKeysDecoded0 = [ResourceKey]()
            for structure0 in resourceKeysContainer {
                if let structure0 = structure0 {
                    resourceKeysDecoded0?.append(structure0)
                }
            }
        }
        resourceKeys = resourceKeysDecoded0
    }
}

extension StartRemediationExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartRemediationExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientPermissionsException" : self = .insufficientPermissionsException(try InsufficientPermissionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRemediationConfigurationException" : self = .noSuchRemediationConfigurationException(try NoSuchRemediationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartRemediationExecutionOutputError: Equatable {
    case insufficientPermissionsException(InsufficientPermissionsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case noSuchRemediationConfigurationException(NoSuchRemediationConfigurationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartRemediationExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartRemediationExecutionOutputResponse(failedItems: \(String(describing: failedItems)), failureMessage: \(String(describing: failureMessage)))"}
}

extension StartRemediationExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartRemediationExecutionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedItems = output.failedItems
            self.failureMessage = output.failureMessage
        } else {
            self.failedItems = nil
            self.failureMessage = nil
        }
    }
}

public struct StartRemediationExecutionOutputResponse: Equatable {
    /// <p>For resources that have failed to start execution, the API returns a resource key object.</p>
    public let failedItems: [ResourceKey]?
    /// <p>Returns a failure message. For example, the resource is already compliant.</p>
    public let failureMessage: String?

    public init (
        failedItems: [ResourceKey]? = nil,
        failureMessage: String? = nil
    )
    {
        self.failedItems = failedItems
        self.failureMessage = failureMessage
    }
}

struct StartRemediationExecutionOutputResponseBody: Equatable {
    public let failureMessage: String?
    public let failedItems: [ResourceKey]?
}

extension StartRemediationExecutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedItems = "FailedItems"
        case failureMessage = "FailureMessage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let failedItemsContainer = try containerValues.decodeIfPresent([ResourceKey?].self, forKey: .failedItems)
        var failedItemsDecoded0:[ResourceKey]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [ResourceKey]()
            for structure0 in failedItemsContainer {
                if let structure0 = structure0 {
                    failedItemsDecoded0?.append(structure0)
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

extension StaticValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for staticparametervalues0 in values {
                try valuesContainer.encode(staticparametervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension StaticValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StaticValue(values: \(String(describing: values)))"}
}

/// <p>The static value of the resource.</p>
public struct StaticValue: Equatable {
    /// <p>A list of values. For example, the ARN of the assumed role. </p>
    public let values: [String]?

    public init (
        values: [String]? = nil
    )
    {
        self.values = values
    }
}

extension StatusDetailFilters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case memberAccountRuleStatus = "MemberAccountRuleStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let memberAccountRuleStatus = memberAccountRuleStatus {
            try encodeContainer.encode(memberAccountRuleStatus.rawValue, forKey: .memberAccountRuleStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let memberAccountRuleStatusDecoded = try containerValues.decodeIfPresent(MemberAccountRuleStatus.self, forKey: .memberAccountRuleStatus)
        memberAccountRuleStatus = memberAccountRuleStatusDecoded
    }
}

extension StatusDetailFilters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StatusDetailFilters(accountId: \(String(describing: accountId)), memberAccountRuleStatus: \(String(describing: memberAccountRuleStatus)))"}
}

/// <p>Status filter object to filter results based on specific member account ID or status type for an organization config rule. </p>
public struct StatusDetailFilters: Equatable {
    /// <p>The 12-digit account ID of the member account within an organization.</p>
    public let accountId: String?
    /// <p>Indicates deployment status for config rule in the member account.
    /// 			When master account calls <code>PutOrganizationConfigRule</code> action for the first time, config rule status is created in the member account.
    /// 			When master account calls <code>PutOrganizationConfigRule</code> action for the second time, config rule status is updated in the member account.
    /// 			Config rule status is deleted when the master account deletes <code>OrganizationConfigRule</code> and disables service access for <code>config-multiaccountsetup.amazonaws.com</code>.
    /// 			</p>
    /// 		       <p>AWS Config sets the state of the rule to:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_SUCCESSFUL</code> when config rule has been created in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_IN_PROGRESS</code> when config rule is being created in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_FAILED</code> when config rule creation has failed in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_FAILED</code> when config rule deletion has failed in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_IN_PROGRESS</code> when config rule is being deleted in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_SUCCESSFUL</code> when config rule has been deleted in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UPDATE_SUCCESSFUL</code> when config rule has been updated in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UPDATE_IN_PROGRESS</code> when config rule is being updated in the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UPDATE_FAILED</code> when config rule deletion has failed in the member account.</p>
    ///             </li>
    ///          </ul>
    public let memberAccountRuleStatus: MemberAccountRuleStatus?

    public init (
        accountId: String? = nil,
        memberAccountRuleStatus: MemberAccountRuleStatus? = nil
    )
    {
        self.accountId = accountId
        self.memberAccountRuleStatus = memberAccountRuleStatus
    }
}

public struct StopConfigurationRecorderInputBodyMiddleware: Middleware {
    public let id: String = "StopConfigurationRecorderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopConfigurationRecorderInput>,
                  next: H) -> Swift.Result<OperationOutput<StopConfigurationRecorderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopConfigurationRecorderInput>
    public typealias MOutput = OperationOutput<StopConfigurationRecorderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopConfigurationRecorderOutputError>
}

extension StopConfigurationRecorderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopConfigurationRecorderInput(configurationRecorderName: \(String(describing: configurationRecorderName)))"}
}

extension StopConfigurationRecorderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationRecorderName = "ConfigurationRecorderName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationRecorderName = configurationRecorderName {
            try encodeContainer.encode(configurationRecorderName, forKey: .configurationRecorderName)
        }
    }
}

public struct StopConfigurationRecorderInputHeadersMiddleware: Middleware {
    public let id: String = "StopConfigurationRecorderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopConfigurationRecorderInput>,
                  next: H) -> Swift.Result<OperationOutput<StopConfigurationRecorderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopConfigurationRecorderInput>
    public typealias MOutput = OperationOutput<StopConfigurationRecorderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopConfigurationRecorderOutputError>
}

public struct StopConfigurationRecorderInputQueryItemMiddleware: Middleware {
    public let id: String = "StopConfigurationRecorderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopConfigurationRecorderInput>,
                  next: H) -> Swift.Result<OperationOutput<StopConfigurationRecorderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopConfigurationRecorderInput>
    public typealias MOutput = OperationOutput<StopConfigurationRecorderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopConfigurationRecorderOutputError>
}

/// <p>The input for the <a>StopConfigurationRecorder</a> action.</p>
public struct StopConfigurationRecorderInput: Equatable {
    /// <p>The name of the recorder object that records each configuration change made to the resources.</p>
    public let configurationRecorderName: String?

    public init (
        configurationRecorderName: String? = nil
    )
    {
        self.configurationRecorderName = configurationRecorderName
    }
}

struct StopConfigurationRecorderInputBody: Equatable {
    public let configurationRecorderName: String?
}

extension StopConfigurationRecorderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationRecorderName = "ConfigurationRecorderName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationRecorderNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationRecorderName)
        configurationRecorderName = configurationRecorderNameDecoded
    }
}

extension StopConfigurationRecorderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopConfigurationRecorderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchConfigurationRecorderException" : self = .noSuchConfigurationRecorderException(try NoSuchConfigurationRecorderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopConfigurationRecorderOutputError: Equatable {
    case noSuchConfigurationRecorderException(NoSuchConfigurationRecorderException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopConfigurationRecorderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopConfigurationRecorderOutputResponse()"}
}

extension StopConfigurationRecorderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopConfigurationRecorderOutputResponse: Equatable {

    public init() {}
}

struct StopConfigurationRecorderOutputResponseBody: Equatable {
}

extension StopConfigurationRecorderOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StoredQuery: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case expression = "Expression"
        case queryArn = "QueryArn"
        case queryId = "QueryId"
        case queryName = "QueryName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let queryArn = queryArn {
            try encodeContainer.encode(queryArn, forKey: .queryArn)
        }
        if let queryId = queryId {
            try encodeContainer.encode(queryId, forKey: .queryId)
        }
        if let queryName = queryName {
            try encodeContainer.encode(queryName, forKey: .queryName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryId)
        queryId = queryIdDecoded
        let queryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryArn)
        queryArn = queryArnDecoded
        let queryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryName)
        queryName = queryNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expression)
        expression = expressionDecoded
    }
}

extension StoredQuery: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StoredQuery(description: \(String(describing: description)), expression: \(String(describing: expression)), queryArn: \(String(describing: queryArn)), queryId: \(String(describing: queryId)), queryName: \(String(describing: queryName)))"}
}

/// <p>Provides the details of a stored query.</p>
public struct StoredQuery: Equatable {
    /// <p>A unique description for the query.</p>
    public let description: String?
    /// <p>The expression of the query. For example, <code>SELECT
    /// 			resourceId,
    /// 			resourceType,
    /// 			supplementaryConfiguration.BucketVersioningConfiguration.status
    /// 			WHERE
    /// 			resourceType = 'AWS::S3::Bucket'
    /// 			AND supplementaryConfiguration.BucketVersioningConfiguration.status = 'Off'.</code>
    ///          </p>
    public let expression: String?
    /// <p>Amazon Resource Name (ARN) of the query. For example, arn:partition:service:region:account-id:resource-type/resource-name/resource-id.</p>
    public let queryArn: String?
    /// <p>The ID of the query.</p>
    public let queryId: String?
    /// <p>The name of the query.</p>
    public let queryName: String?

    public init (
        description: String? = nil,
        expression: String? = nil,
        queryArn: String? = nil,
        queryId: String? = nil,
        queryName: String? = nil
    )
    {
        self.description = description
        self.expression = expression
        self.queryArn = queryArn
        self.queryId = queryId
        self.queryName = queryName
    }
}

extension StoredQueryMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case queryArn = "QueryArn"
        case queryId = "QueryId"
        case queryName = "QueryName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let queryArn = queryArn {
            try encodeContainer.encode(queryArn, forKey: .queryArn)
        }
        if let queryId = queryId {
            try encodeContainer.encode(queryId, forKey: .queryId)
        }
        if let queryName = queryName {
            try encodeContainer.encode(queryName, forKey: .queryName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryId)
        queryId = queryIdDecoded
        let queryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryArn)
        queryArn = queryArnDecoded
        let queryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryName)
        queryName = queryNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension StoredQueryMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StoredQueryMetadata(description: \(String(describing: description)), queryArn: \(String(describing: queryArn)), queryId: \(String(describing: queryId)), queryName: \(String(describing: queryName)))"}
}

/// <p>Returns details of a specific query. </p>
public struct StoredQueryMetadata: Equatable {
    /// <p>A unique description for the query.</p>
    public let description: String?
    /// <p>Amazon Resource Name (ARN) of the query. For example, arn:partition:service:region:account-id:resource-type/resource-name/resource-id.</p>
    public let queryArn: String?
    /// <p>The ID of the query. </p>
    public let queryId: String?
    /// <p>The name of the query.</p>
    public let queryName: String?

    public init (
        description: String? = nil,
        queryArn: String? = nil,
        queryId: String? = nil,
        queryName: String? = nil
    )
    {
        self.description = description
        self.queryArn = queryArn
        self.queryId = queryId
        self.queryName = queryName
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>The tags for the resource. The metadata that you apply to a resource to help you categorize and organize them.
/// 			Each tag consists of a key and an optional value, both of which you define.
/// 			Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.</p>
public struct Tag: Equatable {
    /// <p>One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.</p>
    public let key: String?
    /// <p>The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resources are <code>ConfigRule</code>, <code>ConfigurationAggregator</code> and <code>AggregatorAuthorization</code>.</p>
    public let resourceArn: String?
    /// <p>An array of tag object.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TooManyTagsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTagsException(message: \(String(describing: message)))"}
}

extension TooManyTagsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the limit of the number of tags you can use. You have more than 50 tags.</p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyTagsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resources are <code>ConfigRule</code>, <code>ConfigurationAggregator</code> and <code>AggregatorAuthorization</code>.</p>
    public let resourceArn: String?
    /// <p>The keys of the tags to be removed.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested action is not valid.</p>
/// 		       <p>For PutStoredQuery, you will see this exception if there are missing required fields or if the input value fails the validation, or if you are trying to create more than 300 queries.</p>
/// 		       <p>For GetStoredQuery, ListStoredQuery, and DeleteStoredQuery you will see this exception if there are missing required fields or if the input value fails the validation.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error executing the command</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
