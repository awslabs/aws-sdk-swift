// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AcceptInvitationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitationId = "invitationId"
        case masterId = "masterId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invitationId = invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
        if let masterId = masterId {
            try encodeContainer.encode(masterId, forKey: .masterId)
        }
    }
}

extension AcceptInvitationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/master"
    }
}

public struct AcceptInvitationInput: Swift.Equatable {
    /// The unique ID of the detector of the GuardDuty member account.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The value that is used to validate the administrator account to the member account.
    /// This member is required.
    public var invitationId: Swift.String?
    /// The account ID of the GuardDuty administrator account whose invitation you're accepting.
    /// This member is required.
    public var masterId: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        invitationId: Swift.String? = nil,
        masterId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.invitationId = invitationId
        self.masterId = masterId
    }
}

struct AcceptInvitationInputBody: Swift.Equatable {
    let masterId: Swift.String?
    let invitationId: Swift.String?
}

extension AcceptInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitationId = "invitationId"
        case masterId = "masterId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let masterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterId)
        masterId = masterIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
    }
}

extension AcceptInvitationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptInvitationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptInvitationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptInvitationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AcceptInvitationOutputResponse: Swift.Equatable {

}

extension GuardDutyClientTypes.AccessControlList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowsPublicReadAccess = "allowsPublicReadAccess"
        case allowsPublicWriteAccess = "allowsPublicWriteAccess"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowsPublicReadAccess != false {
            try encodeContainer.encode(allowsPublicReadAccess, forKey: .allowsPublicReadAccess)
        }
        if allowsPublicWriteAccess != false {
            try encodeContainer.encode(allowsPublicWriteAccess, forKey: .allowsPublicWriteAccess)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowsPublicReadAccessDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowsPublicReadAccess)
        allowsPublicReadAccess = allowsPublicReadAccessDecoded
        let allowsPublicWriteAccessDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowsPublicWriteAccess)
        allowsPublicWriteAccess = allowsPublicWriteAccessDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the current access control policies for the bucket.
    public struct AccessControlList: Swift.Equatable {
        /// A value that indicates whether public read access for the bucket is enabled through an Access Control List (ACL).
        public var allowsPublicReadAccess: Swift.Bool
        /// A value that indicates whether public write access for the bucket is enabled through an Access Control List (ACL).
        public var allowsPublicWriteAccess: Swift.Bool

        public init (
            allowsPublicReadAccess: Swift.Bool = false,
            allowsPublicWriteAccess: Swift.Bool = false
        )
        {
            self.allowsPublicReadAccess = allowsPublicReadAccess
            self.allowsPublicWriteAccess = allowsPublicWriteAccess
        }
    }

}

extension GuardDutyClientTypes.AccessKeyDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "accessKeyId"
        case principalId = "principalId"
        case userName = "userName"
        case userType = "userType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userType = userType {
            try encodeContainer.encode(userType, forKey: .userType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let userTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userType)
        userType = userTypeDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the access keys.
    public struct AccessKeyDetails: Swift.Equatable {
        /// The access key ID of the user.
        public var accessKeyId: Swift.String?
        /// The principal ID of the user.
        public var principalId: Swift.String?
        /// The name of the user.
        public var userName: Swift.String?
        /// The type of the user.
        public var userType: Swift.String?

        public init (
            accessKeyId: Swift.String? = nil,
            principalId: Swift.String? = nil,
            userName: Swift.String? = nil,
            userType: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.principalId = principalId
            self.userName = userName
            self.userType = userType
        }
    }

}

extension GuardDutyClientTypes.AccountDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case email = "email"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the account.
    public struct AccountDetail: Swift.Equatable {
        /// The member account ID.
        /// This member is required.
        public var accountId: Swift.String?
        /// The email address of the member account.
        /// This member is required.
        public var email: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            email: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.email = email
        }
    }

}

extension GuardDutyClientTypes.AccountLevelPermissions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockPublicAccess = "blockPublicAccess"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockPublicAccess = blockPublicAccess {
            try encodeContainer.encode(blockPublicAccess, forKey: .blockPublicAccess)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockPublicAccessDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.BlockPublicAccess.self, forKey: .blockPublicAccess)
        blockPublicAccess = blockPublicAccessDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the account level permissions on the S3 bucket.
    public struct AccountLevelPermissions: Swift.Equatable {
        /// Describes the S3 Block Public Access settings of the bucket's parent account.
        public var blockPublicAccess: GuardDutyClientTypes.BlockPublicAccess?

        public init (
            blockPublicAccess: GuardDutyClientTypes.BlockPublicAccess? = nil
        )
        {
            self.blockPublicAccess = blockPublicAccess
        }
    }

}

extension GuardDutyClientTypes.Action: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionType = "actionType"
        case awsApiCallAction = "awsApiCallAction"
        case dnsRequestAction = "dnsRequestAction"
        case networkConnectionAction = "networkConnectionAction"
        case portProbeAction = "portProbeAction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionType = actionType {
            try encodeContainer.encode(actionType, forKey: .actionType)
        }
        if let awsApiCallAction = awsApiCallAction {
            try encodeContainer.encode(awsApiCallAction, forKey: .awsApiCallAction)
        }
        if let dnsRequestAction = dnsRequestAction {
            try encodeContainer.encode(dnsRequestAction, forKey: .dnsRequestAction)
        }
        if let networkConnectionAction = networkConnectionAction {
            try encodeContainer.encode(networkConnectionAction, forKey: .networkConnectionAction)
        }
        if let portProbeAction = portProbeAction {
            try encodeContainer.encode(portProbeAction, forKey: .portProbeAction)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let awsApiCallActionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.AwsApiCallAction.self, forKey: .awsApiCallAction)
        awsApiCallAction = awsApiCallActionDecoded
        let dnsRequestActionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DnsRequestAction.self, forKey: .dnsRequestAction)
        dnsRequestAction = dnsRequestActionDecoded
        let networkConnectionActionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.NetworkConnectionAction.self, forKey: .networkConnectionAction)
        networkConnectionAction = networkConnectionActionDecoded
        let portProbeActionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.PortProbeAction.self, forKey: .portProbeAction)
        portProbeAction = portProbeActionDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about actions.
    public struct Action: Swift.Equatable {
        /// The GuardDuty finding activity type.
        public var actionType: Swift.String?
        /// Information about the AWS_API_CALL action described in this finding.
        public var awsApiCallAction: GuardDutyClientTypes.AwsApiCallAction?
        /// Information about the DNS_REQUEST action described in this finding.
        public var dnsRequestAction: GuardDutyClientTypes.DnsRequestAction?
        /// Information about the NETWORK_CONNECTION action described in this finding.
        public var networkConnectionAction: GuardDutyClientTypes.NetworkConnectionAction?
        /// Information about the PORT_PROBE action described in this finding.
        public var portProbeAction: GuardDutyClientTypes.PortProbeAction?

        public init (
            actionType: Swift.String? = nil,
            awsApiCallAction: GuardDutyClientTypes.AwsApiCallAction? = nil,
            dnsRequestAction: GuardDutyClientTypes.DnsRequestAction? = nil,
            networkConnectionAction: GuardDutyClientTypes.NetworkConnectionAction? = nil,
            portProbeAction: GuardDutyClientTypes.PortProbeAction? = nil
        )
        {
            self.actionType = actionType
            self.awsApiCallAction = awsApiCallAction
            self.dnsRequestAction = dnsRequestAction
            self.networkConnectionAction = networkConnectionAction
            self.portProbeAction = portProbeAction
        }
    }

}

extension GuardDutyClientTypes.AdminAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId = "adminAccountId"
        case adminStatus = "adminStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccountId = adminAccountId {
            try encodeContainer.encode(adminAccountId, forKey: .adminAccountId)
        }
        if let adminStatus = adminStatus {
            try encodeContainer.encode(adminStatus.rawValue, forKey: .adminStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
        let adminStatusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.AdminStatus.self, forKey: .adminStatus)
        adminStatus = adminStatusDecoded
    }
}

extension GuardDutyClientTypes {
    /// The account within the organization specified as the GuardDuty delegated administrator.
    public struct AdminAccount: Swift.Equatable {
        /// The AWS account ID for the account.
        public var adminAccountId: Swift.String?
        /// Indicates whether the account is enabled as the delegated administrator.
        public var adminStatus: GuardDutyClientTypes.AdminStatus?

        public init (
            adminAccountId: Swift.String? = nil,
            adminStatus: GuardDutyClientTypes.AdminStatus? = nil
        )
        {
            self.adminAccountId = adminAccountId
            self.adminStatus = adminStatus
        }
    }

}

extension GuardDutyClientTypes {
    public enum AdminStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disableInProgress
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AdminStatus] {
            return [
                .disableInProgress,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disableInProgress: return "DISABLE_IN_PROGRESS"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AdminStatus(rawValue: rawValue) ?? AdminStatus.sdkUnknown(rawValue)
        }
    }
}

extension ArchiveFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIds = "findingIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingIds = findingIds {
            var findingIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingIds)
            for findingids0 in findingIds {
                try findingIdsContainer.encode(findingids0)
            }
        }
    }
}

extension ArchiveFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/findings/archive"
    }
}

public struct ArchiveFindingsInput: Swift.Equatable {
    /// The ID of the detector that specifies the GuardDuty service whose findings you want to archive.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The IDs of the findings that you want to archive.
    /// This member is required.
    public var findingIds: [Swift.String]?

    public init (
        detectorId: Swift.String? = nil,
        findingIds: [Swift.String]? = nil
    )
    {
        self.detectorId = detectorId
        self.findingIds = findingIds
    }
}

struct ArchiveFindingsInputBody: Swift.Equatable {
    let findingIds: [Swift.String]?
}

extension ArchiveFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIds = "findingIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[Swift.String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [Swift.String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
    }
}

extension ArchiveFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ArchiveFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ArchiveFindingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ArchiveFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ArchiveFindingsOutputResponse: Swift.Equatable {

}

extension GuardDutyClientTypes.AwsApiCallAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case api = "api"
        case callerType = "callerType"
        case domainDetails = "domainDetails"
        case errorCode = "errorCode"
        case remoteIpDetails = "remoteIpDetails"
        case serviceName = "serviceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let api = api {
            try encodeContainer.encode(api, forKey: .api)
        }
        if let callerType = callerType {
            try encodeContainer.encode(callerType, forKey: .callerType)
        }
        if let domainDetails = domainDetails {
            try encodeContainer.encode(domainDetails, forKey: .domainDetails)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let remoteIpDetails = remoteIpDetails {
            try encodeContainer.encode(remoteIpDetails, forKey: .remoteIpDetails)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .api)
        api = apiDecoded
        let callerTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerType)
        callerType = callerTypeDecoded
        let domainDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DomainDetails.self, forKey: .domainDetails)
        domainDetails = domainDetailsDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let remoteIpDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.RemoteIpDetails.self, forKey: .remoteIpDetails)
        remoteIpDetails = remoteIpDetailsDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the API action.
    public struct AwsApiCallAction: Swift.Equatable {
        /// The AWS API name.
        public var api: Swift.String?
        /// The AWS API caller type.
        public var callerType: Swift.String?
        /// The domain information for the AWS API call.
        public var domainDetails: GuardDutyClientTypes.DomainDetails?
        /// The error code of the failed AWS API action.
        public var errorCode: Swift.String?
        /// The remote IP information of the connection that initiated the AWS API call.
        public var remoteIpDetails: GuardDutyClientTypes.RemoteIpDetails?
        /// The AWS service name whose API was invoked.
        public var serviceName: Swift.String?

        public init (
            api: Swift.String? = nil,
            callerType: Swift.String? = nil,
            domainDetails: GuardDutyClientTypes.DomainDetails? = nil,
            errorCode: Swift.String? = nil,
            remoteIpDetails: GuardDutyClientTypes.RemoteIpDetails? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.api = api
            self.callerType = callerType
            self.domainDetails = domainDetails
            self.errorCode = errorCode
            self.remoteIpDetails = remoteIpDetails
            self.serviceName = serviceName
        }
    }

}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A bad request exception object.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message.
    public var message: Swift.String?
    /// The error type.
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let type: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
        case type = "__type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension GuardDutyClientTypes.BlockPublicAccess: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockPublicAcls = "blockPublicAcls"
        case blockPublicPolicy = "blockPublicPolicy"
        case ignorePublicAcls = "ignorePublicAcls"
        case restrictPublicBuckets = "restrictPublicBuckets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blockPublicAcls != false {
            try encodeContainer.encode(blockPublicAcls, forKey: .blockPublicAcls)
        }
        if blockPublicPolicy != false {
            try encodeContainer.encode(blockPublicPolicy, forKey: .blockPublicPolicy)
        }
        if ignorePublicAcls != false {
            try encodeContainer.encode(ignorePublicAcls, forKey: .ignorePublicAcls)
        }
        if restrictPublicBuckets != false {
            try encodeContainer.encode(restrictPublicBuckets, forKey: .restrictPublicBuckets)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ignorePublicAclsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .ignorePublicAcls)
        ignorePublicAcls = ignorePublicAclsDecoded
        let restrictPublicBucketsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .restrictPublicBuckets)
        restrictPublicBuckets = restrictPublicBucketsDecoded
        let blockPublicAclsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .blockPublicAcls)
        blockPublicAcls = blockPublicAclsDecoded
        let blockPublicPolicyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .blockPublicPolicy)
        blockPublicPolicy = blockPublicPolicyDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on how the bucker owner's S3 Block Public Access settings are being applied to the S3 bucket. See [S3 Block Public Access](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html) for more information.
    public struct BlockPublicAccess: Swift.Equatable {
        /// Indicates if S3 Block Public Access is set to BlockPublicAcls.
        public var blockPublicAcls: Swift.Bool
        /// Indicates if S3 Block Public Access is set to BlockPublicPolicy.
        public var blockPublicPolicy: Swift.Bool
        /// Indicates if S3 Block Public Access is set to IgnorePublicAcls.
        public var ignorePublicAcls: Swift.Bool
        /// Indicates if S3 Block Public Access is set to RestrictPublicBuckets.
        public var restrictPublicBuckets: Swift.Bool

        public init (
            blockPublicAcls: Swift.Bool = false,
            blockPublicPolicy: Swift.Bool = false,
            ignorePublicAcls: Swift.Bool = false,
            restrictPublicBuckets: Swift.Bool = false
        )
        {
            self.blockPublicAcls = blockPublicAcls
            self.blockPublicPolicy = blockPublicPolicy
            self.ignorePublicAcls = ignorePublicAcls
            self.restrictPublicBuckets = restrictPublicBuckets
        }
    }

}

extension GuardDutyClientTypes.BucketLevelPermissions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlList = "accessControlList"
        case blockPublicAccess = "blockPublicAccess"
        case bucketPolicy = "bucketPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessControlList = accessControlList {
            try encodeContainer.encode(accessControlList, forKey: .accessControlList)
        }
        if let blockPublicAccess = blockPublicAccess {
            try encodeContainer.encode(blockPublicAccess, forKey: .blockPublicAccess)
        }
        if let bucketPolicy = bucketPolicy {
            try encodeContainer.encode(bucketPolicy, forKey: .bucketPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessControlListDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.AccessControlList.self, forKey: .accessControlList)
        accessControlList = accessControlListDecoded
        let bucketPolicyDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.BucketPolicy.self, forKey: .bucketPolicy)
        bucketPolicy = bucketPolicyDecoded
        let blockPublicAccessDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.BlockPublicAccess.self, forKey: .blockPublicAccess)
        blockPublicAccess = blockPublicAccessDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the bucket level permissions for the S3 bucket.
    public struct BucketLevelPermissions: Swift.Equatable {
        /// Contains information on how Access Control Policies are applied to the bucket.
        public var accessControlList: GuardDutyClientTypes.AccessControlList?
        /// Contains information on which account level S3 Block Public Access settings are applied to the S3 bucket.
        public var blockPublicAccess: GuardDutyClientTypes.BlockPublicAccess?
        /// Contains information on the bucket policies for the S3 bucket.
        public var bucketPolicy: GuardDutyClientTypes.BucketPolicy?

        public init (
            accessControlList: GuardDutyClientTypes.AccessControlList? = nil,
            blockPublicAccess: GuardDutyClientTypes.BlockPublicAccess? = nil,
            bucketPolicy: GuardDutyClientTypes.BucketPolicy? = nil
        )
        {
            self.accessControlList = accessControlList
            self.blockPublicAccess = blockPublicAccess
            self.bucketPolicy = bucketPolicy
        }
    }

}

extension GuardDutyClientTypes.BucketPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowsPublicReadAccess = "allowsPublicReadAccess"
        case allowsPublicWriteAccess = "allowsPublicWriteAccess"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowsPublicReadAccess != false {
            try encodeContainer.encode(allowsPublicReadAccess, forKey: .allowsPublicReadAccess)
        }
        if allowsPublicWriteAccess != false {
            try encodeContainer.encode(allowsPublicWriteAccess, forKey: .allowsPublicWriteAccess)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowsPublicReadAccessDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowsPublicReadAccess)
        allowsPublicReadAccess = allowsPublicReadAccessDecoded
        let allowsPublicWriteAccessDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowsPublicWriteAccess)
        allowsPublicWriteAccess = allowsPublicWriteAccessDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the current bucket policies for the S3 bucket.
    public struct BucketPolicy: Swift.Equatable {
        /// A value that indicates whether public read access for the bucket is enabled through a bucket policy.
        public var allowsPublicReadAccess: Swift.Bool
        /// A value that indicates whether public write access for the bucket is enabled through a bucket policy.
        public var allowsPublicWriteAccess: Swift.Bool

        public init (
            allowsPublicReadAccess: Swift.Bool = false,
            allowsPublicWriteAccess: Swift.Bool = false
        )
        {
            self.allowsPublicReadAccess = allowsPublicReadAccess
            self.allowsPublicWriteAccess = allowsPublicWriteAccess
        }
    }

}

extension GuardDutyClientTypes.City: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cityName = "cityName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cityName = cityName {
            try encodeContainer.encode(cityName, forKey: .cityName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cityName)
        cityName = cityNameDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the city associated with the IP address.
    public struct City: Swift.Equatable {
        /// The city name of the remote IP address.
        public var cityName: Swift.String?

        public init (
            cityName: Swift.String? = nil
        )
        {
            self.cityName = cityName
        }
    }

}

extension GuardDutyClientTypes.CloudTrailConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the status of CloudTrail as a data source for the detector.
    public struct CloudTrailConfigurationResult: Swift.Equatable {
        /// Describes whether CloudTrail is enabled as a data source for the detector.
        /// This member is required.
        public var status: GuardDutyClientTypes.DataSourceStatus?

        public init (
            status: GuardDutyClientTypes.DataSourceStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension GuardDutyClientTypes.Condition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eq = "eq"
        case equals = "equals"
        case greaterThan = "greaterThan"
        case greaterThanOrEqual = "greaterThanOrEqual"
        case gt = "gt"
        case gte = "gte"
        case lessThan = "lessThan"
        case lessThanOrEqual = "lessThanOrEqual"
        case lt = "lt"
        case lte = "lte"
        case neq = "neq"
        case notEquals = "notEquals"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eq = eq {
            var eqContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eq)
            for eq0 in eq {
                try eqContainer.encode(eq0)
            }
        }
        if let equals = equals {
            var equalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .equals)
            for equals0 in equals {
                try equalsContainer.encode(equals0)
            }
        }
        if greaterThan != 0 {
            try encodeContainer.encode(greaterThan, forKey: .greaterThan)
        }
        if greaterThanOrEqual != 0 {
            try encodeContainer.encode(greaterThanOrEqual, forKey: .greaterThanOrEqual)
        }
        if gt != 0 {
            try encodeContainer.encode(gt, forKey: .gt)
        }
        if gte != 0 {
            try encodeContainer.encode(gte, forKey: .gte)
        }
        if lessThan != 0 {
            try encodeContainer.encode(lessThan, forKey: .lessThan)
        }
        if lessThanOrEqual != 0 {
            try encodeContainer.encode(lessThanOrEqual, forKey: .lessThanOrEqual)
        }
        if lt != 0 {
            try encodeContainer.encode(lt, forKey: .lt)
        }
        if lte != 0 {
            try encodeContainer.encode(lte, forKey: .lte)
        }
        if let neq = neq {
            var neqContainer = encodeContainer.nestedUnkeyedContainer(forKey: .neq)
            for neq0 in neq {
                try neqContainer.encode(neq0)
            }
        }
        if let notEquals = notEquals {
            var notEqualsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notEquals)
            for notequals0 in notEquals {
                try notEqualsContainer.encode(notequals0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eqContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eq)
        var eqDecoded0:[Swift.String]? = nil
        if let eqContainer = eqContainer {
            eqDecoded0 = [Swift.String]()
            for string0 in eqContainer {
                if let string0 = string0 {
                    eqDecoded0?.append(string0)
                }
            }
        }
        eq = eqDecoded0
        let neqContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .neq)
        var neqDecoded0:[Swift.String]? = nil
        if let neqContainer = neqContainer {
            neqDecoded0 = [Swift.String]()
            for string0 in neqContainer {
                if let string0 = string0 {
                    neqDecoded0?.append(string0)
                }
            }
        }
        neq = neqDecoded0
        let gtDecoded = try containerValues.decode(Swift.Int.self, forKey: .gt)
        gt = gtDecoded
        let gteDecoded = try containerValues.decode(Swift.Int.self, forKey: .gte)
        gte = gteDecoded
        let ltDecoded = try containerValues.decode(Swift.Int.self, forKey: .lt)
        lt = ltDecoded
        let lteDecoded = try containerValues.decode(Swift.Int.self, forKey: .lte)
        lte = lteDecoded
        let equalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .equals)
        var equalsDecoded0:[Swift.String]? = nil
        if let equalsContainer = equalsContainer {
            equalsDecoded0 = [Swift.String]()
            for string0 in equalsContainer {
                if let string0 = string0 {
                    equalsDecoded0?.append(string0)
                }
            }
        }
        equals = equalsDecoded0
        let notEqualsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notEquals)
        var notEqualsDecoded0:[Swift.String]? = nil
        if let notEqualsContainer = notEqualsContainer {
            notEqualsDecoded0 = [Swift.String]()
            for string0 in notEqualsContainer {
                if let string0 = string0 {
                    notEqualsDecoded0?.append(string0)
                }
            }
        }
        notEquals = notEqualsDecoded0
        let greaterThanDecoded = try containerValues.decode(Swift.Int.self, forKey: .greaterThan)
        greaterThan = greaterThanDecoded
        let greaterThanOrEqualDecoded = try containerValues.decode(Swift.Int.self, forKey: .greaterThanOrEqual)
        greaterThanOrEqual = greaterThanOrEqualDecoded
        let lessThanDecoded = try containerValues.decode(Swift.Int.self, forKey: .lessThan)
        lessThan = lessThanDecoded
        let lessThanOrEqualDecoded = try containerValues.decode(Swift.Int.self, forKey: .lessThanOrEqual)
        lessThanOrEqual = lessThanOrEqualDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the condition.
    public struct Condition: Swift.Equatable {
        /// Represents the equal condition to be applied to a single field when querying for findings.
        @available(*, deprecated)
        public var eq: [Swift.String]?
        /// Represents an equal condition to be applied to a single field when querying for findings.
        public var equals: [Swift.String]?
        /// Represents a greater than condition to be applied to a single field when querying for findings.
        public var greaterThan: Swift.Int
        /// Represents a greater than or equal condition to be applied to a single field when querying for findings.
        public var greaterThanOrEqual: Swift.Int
        /// Represents a greater than condition to be applied to a single field when querying for findings.
        @available(*, deprecated)
        public var gt: Swift.Int
        /// Represents a greater than or equal condition to be applied to a single field when querying for findings.
        @available(*, deprecated)
        public var gte: Swift.Int
        /// Represents a less than condition to be applied to a single field when querying for findings.
        public var lessThan: Swift.Int
        /// Represents a less than or equal condition to be applied to a single field when querying for findings.
        public var lessThanOrEqual: Swift.Int
        /// Represents a less than condition to be applied to a single field when querying for findings.
        @available(*, deprecated)
        public var lt: Swift.Int
        /// Represents a less than or equal condition to be applied to a single field when querying for findings.
        @available(*, deprecated)
        public var lte: Swift.Int
        /// Represents the not equal condition to be applied to a single field when querying for findings.
        @available(*, deprecated)
        public var neq: [Swift.String]?
        /// Represents a not equal condition to be applied to a single field when querying for findings.
        public var notEquals: [Swift.String]?

        public init (
            eq: [Swift.String]? = nil,
            equals: [Swift.String]? = nil,
            greaterThan: Swift.Int = 0,
            greaterThanOrEqual: Swift.Int = 0,
            gt: Swift.Int = 0,
            gte: Swift.Int = 0,
            lessThan: Swift.Int = 0,
            lessThanOrEqual: Swift.Int = 0,
            lt: Swift.Int = 0,
            lte: Swift.Int = 0,
            neq: [Swift.String]? = nil,
            notEquals: [Swift.String]? = nil
        )
        {
            self.eq = eq
            self.equals = equals
            self.greaterThan = greaterThan
            self.greaterThanOrEqual = greaterThanOrEqual
            self.gt = gt
            self.gte = gte
            self.lessThan = lessThan
            self.lessThanOrEqual = lessThanOrEqual
            self.lt = lt
            self.lte = lte
            self.neq = neq
            self.notEquals = notEquals
        }
    }

}

extension GuardDutyClientTypes.Country: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countryCode = "countryCode"
        case countryName = "countryName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countryCode = countryCode {
            try encodeContainer.encode(countryCode, forKey: .countryCode)
        }
        if let countryName = countryName {
            try encodeContainer.encode(countryName, forKey: .countryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let countryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryName)
        countryName = countryNameDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the country where the remote IP address is located.
    public struct Country: Swift.Equatable {
        /// The country code of the remote IP address.
        public var countryCode: Swift.String?
        /// The country name of the remote IP address.
        public var countryName: Swift.String?

        public init (
            countryCode: Swift.String? = nil,
            countryName: Swift.String? = nil
        )
        {
            self.countryCode = countryCode
            self.countryName = countryName
        }
    }

}

extension CreateDetectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "clientToken"
        case dataSources = "dataSources"
        case enable = "enable"
        case findingPublishingFrequency = "findingPublishingFrequency"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataSources = dataSources {
            try encodeContainer.encode(dataSources, forKey: .dataSources)
        }
        if enable != false {
            try encodeContainer.encode(enable, forKey: .enable)
        }
        if let findingPublishingFrequency = findingPublishingFrequency {
            try encodeContainer.encode(findingPublishingFrequency.rawValue, forKey: .findingPublishingFrequency)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/detector"
    }
}

public struct CreateDetectorInput: Swift.Equatable {
    /// The idempotency token for the create request.
    public var clientToken: Swift.String?
    /// Describes which data sources will be enabled for the detector.
    public var dataSources: GuardDutyClientTypes.DataSourceConfigurations?
    /// A Boolean value that specifies whether the detector is to be enabled.
    /// This member is required.
    public var enable: Swift.Bool
    /// A value that specifies how frequently updated findings are exported.
    public var findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency?
    /// The tags to be added to a new detector resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        dataSources: GuardDutyClientTypes.DataSourceConfigurations? = nil,
        enable: Swift.Bool = false,
        findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.dataSources = dataSources
        self.enable = enable
        self.findingPublishingFrequency = findingPublishingFrequency
        self.tags = tags
    }
}

struct CreateDetectorInputBody: Swift.Equatable {
    let enable: Swift.Bool
    let clientToken: Swift.String?
    let findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency?
    let dataSources: GuardDutyClientTypes.DataSourceConfigurations?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "clientToken"
        case dataSources = "dataSources"
        case enable = "enable"
        case findingPublishingFrequency = "findingPublishingFrequency"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enable)
        enable = enableDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let findingPublishingFrequencyDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingPublishingFrequency.self, forKey: .findingPublishingFrequency)
        findingPublishingFrequency = findingPublishingFrequencyDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceConfigurations.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDetectorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDetectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.detectorId = output.detectorId
        } else {
            self.detectorId = nil
        }
    }
}

public struct CreateDetectorOutputResponse: Swift.Equatable {
    /// The unique ID of the created detector.
    public var detectorId: Swift.String?

    public init (
        detectorId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct CreateDetectorOutputResponseBody: Swift.Equatable {
    let detectorId: Swift.String?
}

extension CreateDetectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId = "detectorId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
    }
}

extension CreateFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "action"
        case clientToken = "clientToken"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case name = "name"
        case rank = "rank"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let findingCriteria = findingCriteria {
            try encodeContainer.encode(findingCriteria, forKey: .findingCriteria)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if rank != 0 {
            try encodeContainer.encode(rank, forKey: .rank)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/filter"
    }
}

public struct CreateFilterInput: Swift.Equatable {
    /// Specifies the action that is to be applied to the findings that match the filter.
    public var action: GuardDutyClientTypes.FilterAction?
    /// The idempotency token for the create request.
    public var clientToken: Swift.String?
    /// The description of the filter.
    public var description: Swift.String?
    /// The ID of the detector belonging to the GuardDuty account that you want to create a filter for.
    /// This member is required.
    public var detectorId: Swift.String?
    /// Represents the criteria to be used in the filter for querying findings. You can only use the following attributes to query findings:
    ///
    /// * accountId
    ///
    /// * region
    ///
    /// * confidence
    ///
    /// * id
    ///
    /// * resource.accessKeyDetails.accessKeyId
    ///
    /// * resource.accessKeyDetails.principalId
    ///
    /// * resource.accessKeyDetails.userName
    ///
    /// * resource.accessKeyDetails.userType
    ///
    /// * resource.instanceDetails.iamInstanceProfile.id
    ///
    /// * resource.instanceDetails.imageId
    ///
    /// * resource.instanceDetails.instanceId
    ///
    /// * resource.instanceDetails.outpostArn
    ///
    /// * resource.instanceDetails.networkInterfaces.ipv6Addresses
    ///
    /// * resource.instanceDetails.networkInterfaces.privateIpAddresses.privateIpAddress
    ///
    /// * resource.instanceDetails.networkInterfaces.publicDnsName
    ///
    /// * resource.instanceDetails.networkInterfaces.publicIp
    ///
    /// * resource.instanceDetails.networkInterfaces.securityGroups.groupId
    ///
    /// * resource.instanceDetails.networkInterfaces.securityGroups.groupName
    ///
    /// * resource.instanceDetails.networkInterfaces.subnetId
    ///
    /// * resource.instanceDetails.networkInterfaces.vpcId
    ///
    /// * resource.instanceDetails.tags.key
    ///
    /// * resource.instanceDetails.tags.value
    ///
    /// * resource.resourceType
    ///
    /// * service.action.actionType
    ///
    /// * service.action.awsApiCallAction.api
    ///
    /// * service.action.awsApiCallAction.callerType
    ///
    /// * service.action.awsApiCallAction.errorCode
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.city.cityName
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.country.countryName
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.ipAddressV4
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.organization.asn
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.organization.asnOrg
    ///
    /// * service.action.awsApiCallAction.serviceName
    ///
    /// * service.action.dnsRequestAction.domain
    ///
    /// * service.action.networkConnectionAction.blocked
    ///
    /// * service.action.networkConnectionAction.connectionDirection
    ///
    /// * service.action.networkConnectionAction.localPortDetails.port
    ///
    /// * service.action.networkConnectionAction.protocol
    ///
    /// * service.action.networkConnectionAction.localIpDetails.ipAddressV4
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.city.cityName
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.country.countryName
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.ipAddressV4
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.organization.asn
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.organization.asnOrg
    ///
    /// * service.action.networkConnectionAction.remotePortDetails.port
    ///
    /// * service.additionalInfo.threatListName
    ///
    /// * service.archived When this attribute is set to TRUE, only archived findings are listed. When it's set to FALSE, only unarchived findings are listed. When this attribute is not set, all existing findings are listed.
    ///
    /// * service.resourceRole
    ///
    /// * severity
    ///
    /// * type
    ///
    /// * updatedAt Type: ISO 8601 string format: YYYY-MM-DDTHH:MM:SS.SSSZ or YYYY-MM-DDTHH:MM:SSZ depending on whether the value contains milliseconds.
    /// This member is required.
    public var findingCriteria: GuardDutyClientTypes.FindingCriteria?
    /// The name of the filter. Minimum length of 3. Maximum length of 64. Valid characters include alphanumeric characters, dot (.), underscore (_), and dash (-). Spaces are not allowed.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the position of the filter in the list of current filters. Also specifies the order in which this filter is applied to the findings.
    public var rank: Swift.Int
    /// The tags to be added to a new filter resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        action: GuardDutyClientTypes.FilterAction? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        findingCriteria: GuardDutyClientTypes.FindingCriteria? = nil,
        name: Swift.String? = nil,
        rank: Swift.Int = 0,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.action = action
        self.clientToken = clientToken
        self.description = description
        self.detectorId = detectorId
        self.findingCriteria = findingCriteria
        self.name = name
        self.rank = rank
        self.tags = tags
    }
}

struct CreateFilterInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let action: GuardDutyClientTypes.FilterAction?
    let rank: Swift.Int
    let findingCriteria: GuardDutyClientTypes.FindingCriteria?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "action"
        case clientToken = "clientToken"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case name = "name"
        case rank = "rank"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let actionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FilterAction.self, forKey: .action)
        action = actionDecoded
        let rankDecoded = try containerValues.decode(Swift.Int.self, forKey: .rank)
        rank = rankDecoded
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFilterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFilterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFilterOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFilterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFilterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct CreateFilterOutputResponse: Swift.Equatable {
    /// The name of the successfully created filter.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct CreateFilterOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
}

extension CreateFilterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateIPSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activate = "activate"
        case clientToken = "clientToken"
        case format = "format"
        case location = "location"
        case name = "name"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if activate != false {
            try encodeContainer.encode(activate, forKey: .activate)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateIPSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/ipset"
    }
}

public struct CreateIPSetInput: Swift.Equatable {
    /// A Boolean value that indicates whether GuardDuty is to start using the uploaded IPSet.
    /// This member is required.
    public var activate: Swift.Bool
    /// The idempotency token for the create request.
    public var clientToken: Swift.String?
    /// The unique ID of the detector of the GuardDuty account that you want to create an IPSet for.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The format of the file that contains the IPSet.
    /// This member is required.
    public var format: GuardDutyClientTypes.IpSetFormat?
    /// The URI of the file that contains the IPSet. For example: https://s3.us-west-2.amazonaws.com/my-bucket/my-object-key.
    /// This member is required.
    public var location: Swift.String?
    /// The user-friendly name to identify the IPSet. Allowed characters are alphanumerics, spaces, hyphens (-), and underscores (_).
    /// This member is required.
    public var name: Swift.String?
    /// The tags to be added to a new IP set resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        activate: Swift.Bool = false,
        clientToken: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        format: GuardDutyClientTypes.IpSetFormat? = nil,
        location: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.activate = activate
        self.clientToken = clientToken
        self.detectorId = detectorId
        self.format = format
        self.location = location
        self.name = name
        self.tags = tags
    }
}

struct CreateIPSetInputBody: Swift.Equatable {
    let name: Swift.String?
    let format: GuardDutyClientTypes.IpSetFormat?
    let location: Swift.String?
    let activate: Swift.Bool
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateIPSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activate = "activate"
        case clientToken = "clientToken"
        case format = "format"
        case location = "location"
        case name = "name"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.IpSetFormat.self, forKey: .format)
        format = formatDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let activateDecoded = try containerValues.decode(Swift.Bool.self, forKey: .activate)
        activate = activateDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateIPSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIPSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIPSetOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIPSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateIPSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ipSetId = output.ipSetId
        } else {
            self.ipSetId = nil
        }
    }
}

public struct CreateIPSetOutputResponse: Swift.Equatable {
    /// The ID of the IPSet resource.
    /// This member is required.
    public var ipSetId: Swift.String?

    public init (
        ipSetId: Swift.String? = nil
    )
    {
        self.ipSetId = ipSetId
    }
}

struct CreateIPSetOutputResponseBody: Swift.Equatable {
    let ipSetId: Swift.String?
}

extension CreateIPSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipSetId = "ipSetId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipSetId)
        ipSetId = ipSetIdDecoded
    }
}

extension CreateMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountDetails = "accountDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountDetails = accountDetails {
            var accountDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountDetails)
            for accountdetails0 in accountDetails {
                try accountDetailsContainer.encode(accountdetails0)
            }
        }
    }
}

extension CreateMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member"
    }
}

public struct CreateMembersInput: Swift.Equatable {
    /// A list of account ID and email address pairs of the accounts that you want to associate with the GuardDuty administrator account.
    /// This member is required.
    public var accountDetails: [GuardDutyClientTypes.AccountDetail]?
    /// The unique ID of the detector of the GuardDuty account that you want to associate member accounts with.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        accountDetails: [GuardDutyClientTypes.AccountDetail]? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.accountDetails = accountDetails
        self.detectorId = detectorId
    }
}

struct CreateMembersInputBody: Swift.Equatable {
    let accountDetails: [GuardDutyClientTypes.AccountDetail]?
}

extension CreateMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountDetails = "accountDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDetailsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.AccountDetail?].self, forKey: .accountDetails)
        var accountDetailsDecoded0:[GuardDutyClientTypes.AccountDetail]? = nil
        if let accountDetailsContainer = accountDetailsContainer {
            accountDetailsDecoded0 = [GuardDutyClientTypes.AccountDetail]()
            for structure0 in accountDetailsContainer {
                if let structure0 = structure0 {
                    accountDetailsDecoded0?.append(structure0)
                }
            }
        }
        accountDetails = accountDetailsDecoded0
    }
}

extension CreateMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMembersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct CreateMembersOutputResponse: Swift.Equatable {
    /// A list of objects that include the accountIds of the unprocessed accounts and a result string that explains why each was unprocessed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init (
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct CreateMembersOutputResponseBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension CreateMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension CreatePublishingDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "clientToken"
        case destinationProperties = "destinationProperties"
        case destinationType = "destinationType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let destinationProperties = destinationProperties {
            try encodeContainer.encode(destinationProperties, forKey: .destinationProperties)
        }
        if let destinationType = destinationType {
            try encodeContainer.encode(destinationType.rawValue, forKey: .destinationType)
        }
    }
}

extension CreatePublishingDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/publishingDestination"
    }
}

public struct CreatePublishingDestinationInput: Swift.Equatable {
    /// The idempotency token for the request.
    public var clientToken: Swift.String?
    /// The properties of the publishing destination, including the ARNs for the destination and the KMS key used for encryption.
    /// This member is required.
    public var destinationProperties: GuardDutyClientTypes.DestinationProperties?
    /// The type of resource for the publishing destination. Currently only Amazon S3 buckets are supported.
    /// This member is required.
    public var destinationType: GuardDutyClientTypes.DestinationType?
    /// The ID of the GuardDuty detector associated with the publishing destination.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        destinationProperties: GuardDutyClientTypes.DestinationProperties? = nil,
        destinationType: GuardDutyClientTypes.DestinationType? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.destinationProperties = destinationProperties
        self.destinationType = destinationType
        self.detectorId = detectorId
    }
}

struct CreatePublishingDestinationInputBody: Swift.Equatable {
    let destinationType: GuardDutyClientTypes.DestinationType?
    let destinationProperties: GuardDutyClientTypes.DestinationProperties?
    let clientToken: Swift.String?
}

extension CreatePublishingDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "clientToken"
        case destinationProperties = "destinationProperties"
        case destinationType = "destinationType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationTypeDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DestinationType.self, forKey: .destinationType)
        destinationType = destinationTypeDecoded
        let destinationPropertiesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DestinationProperties.self, forKey: .destinationProperties)
        destinationProperties = destinationPropertiesDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreatePublishingDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePublishingDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePublishingDestinationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePublishingDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePublishingDestinationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinationId = output.destinationId
        } else {
            self.destinationId = nil
        }
    }
}

public struct CreatePublishingDestinationOutputResponse: Swift.Equatable {
    /// The ID of the publishing destination that is created.
    /// This member is required.
    public var destinationId: Swift.String?

    public init (
        destinationId: Swift.String? = nil
    )
    {
        self.destinationId = destinationId
    }
}

struct CreatePublishingDestinationOutputResponseBody: Swift.Equatable {
    let destinationId: Swift.String?
}

extension CreatePublishingDestinationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationId = "destinationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationId)
        destinationId = destinationIdDecoded
    }
}

extension CreateSampleFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingTypes = "findingTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingTypes = findingTypes {
            var findingTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingTypes)
            for findingtypes0 in findingTypes {
                try findingTypesContainer.encode(findingtypes0)
            }
        }
    }
}

extension CreateSampleFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/findings/create"
    }
}

public struct CreateSampleFindingsInput: Swift.Equatable {
    /// The ID of the detector to create sample findings for.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The types of sample findings to generate.
    public var findingTypes: [Swift.String]?

    public init (
        detectorId: Swift.String? = nil,
        findingTypes: [Swift.String]? = nil
    )
    {
        self.detectorId = detectorId
        self.findingTypes = findingTypes
    }
}

struct CreateSampleFindingsInputBody: Swift.Equatable {
    let findingTypes: [Swift.String]?
}

extension CreateSampleFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingTypes = "findingTypes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingTypes)
        var findingTypesDecoded0:[Swift.String]? = nil
        if let findingTypesContainer = findingTypesContainer {
            findingTypesDecoded0 = [Swift.String]()
            for string0 in findingTypesContainer {
                if let string0 = string0 {
                    findingTypesDecoded0?.append(string0)
                }
            }
        }
        findingTypes = findingTypesDecoded0
    }
}

extension CreateSampleFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSampleFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSampleFindingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSampleFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateSampleFindingsOutputResponse: Swift.Equatable {

}

extension CreateThreatIntelSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activate = "activate"
        case clientToken = "clientToken"
        case format = "format"
        case location = "location"
        case name = "name"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if activate != false {
            try encodeContainer.encode(activate, forKey: .activate)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateThreatIntelSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/threatintelset"
    }
}

public struct CreateThreatIntelSetInput: Swift.Equatable {
    /// A Boolean value that indicates whether GuardDuty is to start using the uploaded ThreatIntelSet.
    /// This member is required.
    public var activate: Swift.Bool
    /// The idempotency token for the create request.
    public var clientToken: Swift.String?
    /// The unique ID of the detector of the GuardDuty account that you want to create a threatIntelSet for.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The format of the file that contains the ThreatIntelSet.
    /// This member is required.
    public var format: GuardDutyClientTypes.ThreatIntelSetFormat?
    /// The URI of the file that contains the ThreatIntelSet. For example: https://s3.us-west-2.amazonaws.com/my-bucket/my-object-key.
    /// This member is required.
    public var location: Swift.String?
    /// A user-friendly ThreatIntelSet name displayed in all findings that are generated by activity that involves IP addresses included in this ThreatIntelSet.
    /// This member is required.
    public var name: Swift.String?
    /// The tags to be added to a new threat list resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        activate: Swift.Bool = false,
        clientToken: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        format: GuardDutyClientTypes.ThreatIntelSetFormat? = nil,
        location: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.activate = activate
        self.clientToken = clientToken
        self.detectorId = detectorId
        self.format = format
        self.location = location
        self.name = name
        self.tags = tags
    }
}

struct CreateThreatIntelSetInputBody: Swift.Equatable {
    let name: Swift.String?
    let format: GuardDutyClientTypes.ThreatIntelSetFormat?
    let location: Swift.String?
    let activate: Swift.Bool
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateThreatIntelSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activate = "activate"
        case clientToken = "clientToken"
        case format = "format"
        case location = "location"
        case name = "name"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ThreatIntelSetFormat.self, forKey: .format)
        format = formatDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let activateDecoded = try containerValues.decode(Swift.Bool.self, forKey: .activate)
        activate = activateDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateThreatIntelSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateThreatIntelSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateThreatIntelSetOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateThreatIntelSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateThreatIntelSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.threatIntelSetId = output.threatIntelSetId
        } else {
            self.threatIntelSetId = nil
        }
    }
}

public struct CreateThreatIntelSetOutputResponse: Swift.Equatable {
    /// The ID of the ThreatIntelSet resource.
    /// This member is required.
    public var threatIntelSetId: Swift.String?

    public init (
        threatIntelSetId: Swift.String? = nil
    )
    {
        self.threatIntelSetId = threatIntelSetId
    }
}

struct CreateThreatIntelSetOutputResponseBody: Swift.Equatable {
    let threatIntelSetId: Swift.String?
}

extension CreateThreatIntelSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case threatIntelSetId = "threatIntelSetId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let threatIntelSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .threatIntelSetId)
        threatIntelSetId = threatIntelSetIdDecoded
    }
}

extension GuardDutyClientTypes.DNSLogsConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the status of DNS logs as a data source.
    public struct DNSLogsConfigurationResult: Swift.Equatable {
        /// Denotes whether DNS logs is enabled as a data source.
        /// This member is required.
        public var status: GuardDutyClientTypes.DataSourceStatus?

        public init (
            status: GuardDutyClientTypes.DataSourceStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension GuardDutyClientTypes {
    public enum DataSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudTrail
        case dnsLogs
        case flowLogs
        case s3Logs
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSource] {
            return [
                .cloudTrail,
                .dnsLogs,
                .flowLogs,
                .s3Logs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudTrail: return "CLOUD_TRAIL"
            case .dnsLogs: return "DNS_LOGS"
            case .flowLogs: return "FLOW_LOGS"
            case .s3Logs: return "S3_LOGS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSource(rawValue: rawValue) ?? DataSource.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.DataSourceConfigurations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Logs = "s3Logs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Logs = s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.S3LogsConfiguration.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about which data sources are enabled.
    public struct DataSourceConfigurations: Swift.Equatable {
        /// Describes whether S3 data event logs are enabled as a data source.
        public var s3Logs: GuardDutyClientTypes.S3LogsConfiguration?

        public init (
            s3Logs: GuardDutyClientTypes.S3LogsConfiguration? = nil
        )
        {
            self.s3Logs = s3Logs
        }
    }

}

extension GuardDutyClientTypes.DataSourceConfigurationsResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudTrail = "cloudTrail"
        case dNSLogs = "dnsLogs"
        case flowLogs = "flowLogs"
        case s3Logs = "s3Logs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudTrail = cloudTrail {
            try encodeContainer.encode(cloudTrail, forKey: .cloudTrail)
        }
        if let dNSLogs = dNSLogs {
            try encodeContainer.encode(dNSLogs, forKey: .dNSLogs)
        }
        if let flowLogs = flowLogs {
            try encodeContainer.encode(flowLogs, forKey: .flowLogs)
        }
        if let s3Logs = s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudTrailDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.CloudTrailConfigurationResult.self, forKey: .cloudTrail)
        cloudTrail = cloudTrailDecoded
        let dNSLogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DNSLogsConfigurationResult.self, forKey: .dNSLogs)
        dNSLogs = dNSLogsDecoded
        let flowLogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FlowLogsConfigurationResult.self, forKey: .flowLogs)
        flowLogs = flowLogsDecoded
        let s3LogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.S3LogsConfigurationResult.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the status of data sources for the detector.
    public struct DataSourceConfigurationsResult: Swift.Equatable {
        /// An object that contains information on the status of CloudTrail as a data source.
        /// This member is required.
        public var cloudTrail: GuardDutyClientTypes.CloudTrailConfigurationResult?
        /// An object that contains information on the status of DNS logs as a data source.
        /// This member is required.
        public var dNSLogs: GuardDutyClientTypes.DNSLogsConfigurationResult?
        /// An object that contains information on the status of VPC flow logs as a data source.
        /// This member is required.
        public var flowLogs: GuardDutyClientTypes.FlowLogsConfigurationResult?
        /// An object that contains information on the status of S3 Data event logs as a data source.
        /// This member is required.
        public var s3Logs: GuardDutyClientTypes.S3LogsConfigurationResult?

        public init (
            cloudTrail: GuardDutyClientTypes.CloudTrailConfigurationResult? = nil,
            dNSLogs: GuardDutyClientTypes.DNSLogsConfigurationResult? = nil,
            flowLogs: GuardDutyClientTypes.FlowLogsConfigurationResult? = nil,
            s3Logs: GuardDutyClientTypes.S3LogsConfigurationResult? = nil
        )
        {
            self.cloudTrail = cloudTrail
            self.dNSLogs = dNSLogs
            self.flowLogs = flowLogs
            self.s3Logs = s3Logs
        }
    }

}

extension GuardDutyClientTypes {
    public enum DataSourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceStatus(rawValue: rawValue) ?? DataSourceStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeclineInvitationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
    }
}

extension DeclineInvitationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/invitation/decline"
    }
}

public struct DeclineInvitationsInput: Swift.Equatable {
    /// A list of account IDs of the AWS accounts that sent invitations to the current member account that you want to decline invitations from.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init (
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct DeclineInvitationsInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension DeclineInvitationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DeclineInvitationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeclineInvitationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeclineInvitationsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeclineInvitationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeclineInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DeclineInvitationsOutputResponse: Swift.Equatable {
    /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init (
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DeclineInvitationsOutputResponseBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension DeclineInvitationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension GuardDutyClientTypes.DefaultServerSideEncryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType = "encryptionType"
        case kmsMasterKeyArn = "kmsMasterKeyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = encryptionType {
            try encodeContainer.encode(encryptionType, forKey: .encryptionType)
        }
        if let kmsMasterKeyArn = kmsMasterKeyArn {
            try encodeContainer.encode(kmsMasterKeyArn, forKey: .kmsMasterKeyArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kmsMasterKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsMasterKeyArn)
        kmsMasterKeyArn = kmsMasterKeyArnDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the server side encryption method used in the S3 bucket. See [S3 Server-Side Encryption](https://docs.aws.amazon.com/AmazonS3/latest/dev/serv-side-encryption.html) for more information.
    public struct DefaultServerSideEncryption: Swift.Equatable {
        /// The type of encryption used for objects within the S3 bucket.
        public var encryptionType: Swift.String?
        /// The Amazon Resource Name (ARN) of the KMS encryption key. Only available if the bucket EncryptionType is aws:kms.
        public var kmsMasterKeyArn: Swift.String?

        public init (
            encryptionType: Swift.String? = nil,
            kmsMasterKeyArn: Swift.String? = nil
        )
        {
            self.encryptionType = encryptionType
            self.kmsMasterKeyArn = kmsMasterKeyArn
        }
    }

}

extension DeleteDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())"
    }
}

public struct DeleteDetectorInput: Swift.Equatable {
    /// The unique ID of the detector that you want to delete.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        detectorId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct DeleteDetectorInputBody: Swift.Equatable {
}

extension DeleteDetectorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDetectorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDetectorOutputResponse: Swift.Equatable {

}

extension DeleteFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let filterName = filterName else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/filter/\(filterName.urlPercentEncoding())"
    }
}

public struct DeleteFilterInput: Swift.Equatable {
    /// The unique ID of the detector that the filter is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The name of the filter that you want to delete.
    /// This member is required.
    public var filterName: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        filterName: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.filterName = filterName
    }
}

struct DeleteFilterInputBody: Swift.Equatable {
}

extension DeleteFilterInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFilterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFilterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFilterOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFilterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFilterOutputResponse: Swift.Equatable {

}

extension DeleteIPSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let ipSetId = ipSetId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/ipset/\(ipSetId.urlPercentEncoding())"
    }
}

public struct DeleteIPSetInput: Swift.Equatable {
    /// The unique ID of the detector associated with the IPSet.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The unique ID of the IPSet to delete.
    /// This member is required.
    public var ipSetId: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        ipSetId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.ipSetId = ipSetId
    }
}

struct DeleteIPSetInputBody: Swift.Equatable {
}

extension DeleteIPSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIPSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIPSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIPSetOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIPSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIPSetOutputResponse: Swift.Equatable {

}

extension DeleteInvitationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
    }
}

extension DeleteInvitationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/invitation/delete"
    }
}

public struct DeleteInvitationsInput: Swift.Equatable {
    /// A list of account IDs of the AWS accounts that sent invitations to the current member account that you want to delete invitations from.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init (
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct DeleteInvitationsInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension DeleteInvitationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DeleteInvitationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInvitationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInvitationsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInvitationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DeleteInvitationsOutputResponse: Swift.Equatable {
    /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init (
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DeleteInvitationsOutputResponseBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension DeleteInvitationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension DeleteMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
    }
}

extension DeleteMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member/delete"
    }
}

public struct DeleteMembersInput: Swift.Equatable {
    /// A list of account IDs of the GuardDuty member accounts that you want to delete.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The unique ID of the detector of the GuardDuty account whose members you want to delete.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct DeleteMembersInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension DeleteMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DeleteMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMembersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DeleteMembersOutputResponse: Swift.Equatable {
    /// The accounts that could not be processed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init (
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DeleteMembersOutputResponseBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension DeleteMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension DeletePublishingDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let destinationId = destinationId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/publishingDestination/\(destinationId.urlPercentEncoding())"
    }
}

public struct DeletePublishingDestinationInput: Swift.Equatable {
    /// The ID of the publishing destination to delete.
    /// This member is required.
    public var destinationId: Swift.String?
    /// The unique ID of the detector associated with the publishing destination to delete.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        destinationId: Swift.String? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.destinationId = destinationId
        self.detectorId = detectorId
    }
}

struct DeletePublishingDestinationInputBody: Swift.Equatable {
}

extension DeletePublishingDestinationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePublishingDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePublishingDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePublishingDestinationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePublishingDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePublishingDestinationOutputResponse: Swift.Equatable {

}

extension DeleteThreatIntelSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let threatIntelSetId = threatIntelSetId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/threatintelset/\(threatIntelSetId.urlPercentEncoding())"
    }
}

public struct DeleteThreatIntelSetInput: Swift.Equatable {
    /// The unique ID of the detector that the threatIntelSet is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The unique ID of the threatIntelSet that you want to delete.
    /// This member is required.
    public var threatIntelSetId: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        threatIntelSetId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.threatIntelSetId = threatIntelSetId
    }
}

struct DeleteThreatIntelSetInputBody: Swift.Equatable {
}

extension DeleteThreatIntelSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteThreatIntelSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteThreatIntelSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteThreatIntelSetOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteThreatIntelSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteThreatIntelSetOutputResponse: Swift.Equatable {

}

extension DescribeOrganizationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/admin"
    }
}

public struct DescribeOrganizationConfigurationInput: Swift.Equatable {
    /// The ID of the detector to retrieve information about the delegated administrator from.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        detectorId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct DescribeOrganizationConfigurationInputBody: Swift.Equatable {
}

extension DescribeOrganizationConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeOrganizationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOrganizationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOrganizationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrganizationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeOrganizationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoEnable = output.autoEnable
            self.dataSources = output.dataSources
            self.memberAccountLimitReached = output.memberAccountLimitReached
        } else {
            self.autoEnable = false
            self.dataSources = nil
            self.memberAccountLimitReached = false
        }
    }
}

public struct DescribeOrganizationConfigurationOutputResponse: Swift.Equatable {
    /// Indicates whether GuardDuty is automatically enabled for accounts added to the organization.
    /// This member is required.
    public var autoEnable: Swift.Bool
    /// Describes which data sources are enabled automatically for member accounts.
    public var dataSources: GuardDutyClientTypes.OrganizationDataSourceConfigurationsResult?
    /// Indicates whether the maximum number of allowed member accounts are already associated with the delegated administrator account for your organization.
    /// This member is required.
    public var memberAccountLimitReached: Swift.Bool

    public init (
        autoEnable: Swift.Bool = false,
        dataSources: GuardDutyClientTypes.OrganizationDataSourceConfigurationsResult? = nil,
        memberAccountLimitReached: Swift.Bool = false
    )
    {
        self.autoEnable = autoEnable
        self.dataSources = dataSources
        self.memberAccountLimitReached = memberAccountLimitReached
    }
}

struct DescribeOrganizationConfigurationOutputResponseBody: Swift.Equatable {
    let autoEnable: Swift.Bool
    let memberAccountLimitReached: Swift.Bool
    let dataSources: GuardDutyClientTypes.OrganizationDataSourceConfigurationsResult?
}

extension DescribeOrganizationConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
        case dataSources = "dataSources"
        case memberAccountLimitReached = "memberAccountLimitReached"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
        let memberAccountLimitReachedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .memberAccountLimitReached)
        memberAccountLimitReached = memberAccountLimitReachedDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationDataSourceConfigurationsResult.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
    }
}

extension DescribePublishingDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let destinationId = destinationId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/publishingDestination/\(destinationId.urlPercentEncoding())"
    }
}

public struct DescribePublishingDestinationInput: Swift.Equatable {
    /// The ID of the publishing destination to retrieve.
    /// This member is required.
    public var destinationId: Swift.String?
    /// The unique ID of the detector associated with the publishing destination to retrieve.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        destinationId: Swift.String? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.destinationId = destinationId
        self.detectorId = detectorId
    }
}

struct DescribePublishingDestinationInputBody: Swift.Equatable {
}

extension DescribePublishingDestinationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribePublishingDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePublishingDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePublishingDestinationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePublishingDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePublishingDestinationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinationId = output.destinationId
            self.destinationProperties = output.destinationProperties
            self.destinationType = output.destinationType
            self.publishingFailureStartTimestamp = output.publishingFailureStartTimestamp
            self.status = output.status
        } else {
            self.destinationId = nil
            self.destinationProperties = nil
            self.destinationType = nil
            self.publishingFailureStartTimestamp = 0
            self.status = nil
        }
    }
}

public struct DescribePublishingDestinationOutputResponse: Swift.Equatable {
    /// The ID of the publishing destination.
    /// This member is required.
    public var destinationId: Swift.String?
    /// A DestinationProperties object that includes the DestinationArn and KmsKeyArn of the publishing destination.
    /// This member is required.
    public var destinationProperties: GuardDutyClientTypes.DestinationProperties?
    /// The type of publishing destination. Currently, only Amazon S3 buckets are supported.
    /// This member is required.
    public var destinationType: GuardDutyClientTypes.DestinationType?
    /// The time, in epoch millisecond format, at which GuardDuty was first unable to publish findings to the destination.
    /// This member is required.
    public var publishingFailureStartTimestamp: Swift.Int
    /// The status of the publishing destination.
    /// This member is required.
    public var status: GuardDutyClientTypes.PublishingStatus?

    public init (
        destinationId: Swift.String? = nil,
        destinationProperties: GuardDutyClientTypes.DestinationProperties? = nil,
        destinationType: GuardDutyClientTypes.DestinationType? = nil,
        publishingFailureStartTimestamp: Swift.Int = 0,
        status: GuardDutyClientTypes.PublishingStatus? = nil
    )
    {
        self.destinationId = destinationId
        self.destinationProperties = destinationProperties
        self.destinationType = destinationType
        self.publishingFailureStartTimestamp = publishingFailureStartTimestamp
        self.status = status
    }
}

struct DescribePublishingDestinationOutputResponseBody: Swift.Equatable {
    let destinationId: Swift.String?
    let destinationType: GuardDutyClientTypes.DestinationType?
    let status: GuardDutyClientTypes.PublishingStatus?
    let publishingFailureStartTimestamp: Swift.Int
    let destinationProperties: GuardDutyClientTypes.DestinationProperties?
}

extension DescribePublishingDestinationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationId = "destinationId"
        case destinationProperties = "destinationProperties"
        case destinationType = "destinationType"
        case publishingFailureStartTimestamp = "publishingFailureStartTimestamp"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationId)
        destinationId = destinationIdDecoded
        let destinationTypeDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DestinationType.self, forKey: .destinationType)
        destinationType = destinationTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.PublishingStatus.self, forKey: .status)
        status = statusDecoded
        let publishingFailureStartTimestampDecoded = try containerValues.decode(Swift.Int.self, forKey: .publishingFailureStartTimestamp)
        publishingFailureStartTimestamp = publishingFailureStartTimestampDecoded
        let destinationPropertiesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DestinationProperties.self, forKey: .destinationProperties)
        destinationProperties = destinationPropertiesDecoded
    }
}

extension GuardDutyClientTypes.Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationId = "destinationId"
        case destinationType = "destinationType"
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationId = destinationId {
            try encodeContainer.encode(destinationId, forKey: .destinationId)
        }
        if let destinationType = destinationType {
            try encodeContainer.encode(destinationType.rawValue, forKey: .destinationType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationId)
        destinationId = destinationIdDecoded
        let destinationTypeDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DestinationType.self, forKey: .destinationType)
        destinationType = destinationTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.PublishingStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the publishing destination, including the ID, type, and status.
    public struct Destination: Swift.Equatable {
        /// The unique ID of the publishing destination.
        /// This member is required.
        public var destinationId: Swift.String?
        /// The type of resource used for the publishing destination. Currently, only Amazon S3 buckets are supported.
        /// This member is required.
        public var destinationType: GuardDutyClientTypes.DestinationType?
        /// The status of the publishing destination.
        /// This member is required.
        public var status: GuardDutyClientTypes.PublishingStatus?

        public init (
            destinationId: Swift.String? = nil,
            destinationType: GuardDutyClientTypes.DestinationType? = nil,
            status: GuardDutyClientTypes.PublishingStatus? = nil
        )
        {
            self.destinationId = destinationId
            self.destinationType = destinationType
            self.status = status
        }
    }

}

extension GuardDutyClientTypes.DestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationArn = "destinationArn"
        case kmsKeyArn = "kmsKeyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationArn = destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains the Amazon Resource Name (ARN) of the resource to publish to, such as an S3 bucket, and the ARN of the KMS key to use to encrypt published findings.
    public struct DestinationProperties: Swift.Equatable {
        /// The ARN of the resource to publish to.
        public var destinationArn: Swift.String?
        /// The ARN of the KMS key to use for encryption.
        public var kmsKeyArn: Swift.String?

        public init (
            destinationArn: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil
        )
        {
            self.destinationArn = destinationArn
            self.kmsKeyArn = kmsKeyArn
        }
    }

}

extension GuardDutyClientTypes {
    public enum DestinationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [DestinationType] {
            return [
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DestinationType(rawValue: rawValue) ?? DestinationType.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes {
    public enum DetectorStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DetectorStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DetectorStatus(rawValue: rawValue) ?? DetectorStatus.sdkUnknown(rawValue)
        }
    }
}

extension DisableOrganizationAdminAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId = "adminAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccountId = adminAccountId {
            try encodeContainer.encode(adminAccountId, forKey: .adminAccountId)
        }
    }
}

extension DisableOrganizationAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/admin/disable"
    }
}

public struct DisableOrganizationAdminAccountInput: Swift.Equatable {
    /// The AWS Account ID for the organizations account to be disabled as a GuardDuty delegated administrator.
    /// This member is required.
    public var adminAccountId: Swift.String?

    public init (
        adminAccountId: Swift.String? = nil
    )
    {
        self.adminAccountId = adminAccountId
    }
}

struct DisableOrganizationAdminAccountInputBody: Swift.Equatable {
    let adminAccountId: Swift.String?
}

extension DisableOrganizationAdminAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId = "adminAccountId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
    }
}

extension DisableOrganizationAdminAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableOrganizationAdminAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableOrganizationAdminAccountOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableOrganizationAdminAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisableOrganizationAdminAccountOutputResponse: Swift.Equatable {

}

extension DisassociateFromMasterAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/master/disassociate"
    }
}

public struct DisassociateFromMasterAccountInput: Swift.Equatable {
    /// The unique ID of the detector of the GuardDuty member account.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        detectorId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct DisassociateFromMasterAccountInputBody: Swift.Equatable {
}

extension DisassociateFromMasterAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateFromMasterAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateFromMasterAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateFromMasterAccountOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateFromMasterAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateFromMasterAccountOutputResponse: Swift.Equatable {

}

extension DisassociateMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
    }
}

extension DisassociateMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member/disassociate"
    }
}

public struct DisassociateMembersInput: Swift.Equatable {
    /// A list of account IDs of the GuardDuty member accounts that you want to disassociate from the administrator account.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The unique ID of the detector of the GuardDuty account whose members you want to disassociate from the administrator account.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct DisassociateMembersInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension DisassociateMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DisassociateMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateMembersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DisassociateMembersOutputResponse: Swift.Equatable {
    /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init (
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DisassociateMembersOutputResponseBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension DisassociateMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension GuardDutyClientTypes.DnsRequestAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "domain"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the DNS_REQUEST action described in this finding.
    public struct DnsRequestAction: Swift.Equatable {
        /// The domain information for the API request.
        public var domain: Swift.String?

        public init (
            domain: Swift.String? = nil
        )
        {
            self.domain = domain
        }
    }

}

extension GuardDutyClientTypes.DomainDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "domain"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the domain.
    public struct DomainDetails: Swift.Equatable {
        /// The domain information for the AWS API call.
        public var domain: Swift.String?

        public init (
            domain: Swift.String? = nil
        )
        {
            self.domain = domain
        }
    }

}

extension EnableOrganizationAdminAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId = "adminAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccountId = adminAccountId {
            try encodeContainer.encode(adminAccountId, forKey: .adminAccountId)
        }
    }
}

extension EnableOrganizationAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/admin/enable"
    }
}

public struct EnableOrganizationAdminAccountInput: Swift.Equatable {
    /// The AWS Account ID for the organization account to be enabled as a GuardDuty delegated administrator.
    /// This member is required.
    public var adminAccountId: Swift.String?

    public init (
        adminAccountId: Swift.String? = nil
    )
    {
        self.adminAccountId = adminAccountId
    }
}

struct EnableOrganizationAdminAccountInputBody: Swift.Equatable {
    let adminAccountId: Swift.String?
}

extension EnableOrganizationAdminAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId = "adminAccountId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
    }
}

extension EnableOrganizationAdminAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableOrganizationAdminAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableOrganizationAdminAccountOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableOrganizationAdminAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct EnableOrganizationAdminAccountOutputResponse: Swift.Equatable {

}

extension GuardDutyClientTypes.Evidence: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case threatIntelligenceDetails = "threatIntelligenceDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let threatIntelligenceDetails = threatIntelligenceDetails {
            var threatIntelligenceDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threatIntelligenceDetails)
            for threatintelligencedetails0 in threatIntelligenceDetails {
                try threatIntelligenceDetailsContainer.encode(threatintelligencedetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let threatIntelligenceDetailsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.ThreatIntelligenceDetail?].self, forKey: .threatIntelligenceDetails)
        var threatIntelligenceDetailsDecoded0:[GuardDutyClientTypes.ThreatIntelligenceDetail]? = nil
        if let threatIntelligenceDetailsContainer = threatIntelligenceDetailsContainer {
            threatIntelligenceDetailsDecoded0 = [GuardDutyClientTypes.ThreatIntelligenceDetail]()
            for structure0 in threatIntelligenceDetailsContainer {
                if let structure0 = structure0 {
                    threatIntelligenceDetailsDecoded0?.append(structure0)
                }
            }
        }
        threatIntelligenceDetails = threatIntelligenceDetailsDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the reason that the finding was generated.
    public struct Evidence: Swift.Equatable {
        /// A list of threat intelligence details related to the evidence.
        public var threatIntelligenceDetails: [GuardDutyClientTypes.ThreatIntelligenceDetail]?

        public init (
            threatIntelligenceDetails: [GuardDutyClientTypes.ThreatIntelligenceDetail]? = nil
        )
        {
            self.threatIntelligenceDetails = threatIntelligenceDetails
        }
    }

}

extension GuardDutyClientTypes {
    public enum Feedback: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notUseful
        case useful
        case sdkUnknown(Swift.String)

        public static var allCases: [Feedback] {
            return [
                .notUseful,
                .useful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notUseful: return "NOT_USEFUL"
            case .useful: return "USEFUL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Feedback(rawValue: rawValue) ?? Feedback.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes {
    public enum FilterAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case archive
        case noop
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterAction] {
            return [
                .archive,
                .noop,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .archive: return "ARCHIVE"
            case .noop: return "NOOP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterAction(rawValue: rawValue) ?? FilterAction.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.Finding: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case arn = "arn"
        case confidence = "confidence"
        case createdAt = "createdAt"
        case description = "description"
        case id = "id"
        case partition = "partition"
        case region = "region"
        case resource = "resource"
        case schemaVersion = "schemaVersion"
        case service = "service"
        case severity = "severity"
        case title = "title"
        case type = "type"
        case updatedAt = "updatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if confidence != 0.0 {
            try encodeContainer.encode(confidence, forKey: .confidence)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let partition = partition {
            try encodeContainer.encode(partition, forKey: .partition)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let schemaVersion = schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let service = service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if severity != 0.0 {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let confidenceDecoded = try containerValues.decode(Swift.Double.self, forKey: .confidence)
        confidence = confidenceDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let partitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partition)
        partition = partitionDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Resource.self, forKey: .resource)
        resource = resourceDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let severityDecoded = try containerValues.decode(Swift.Double.self, forKey: .severity)
        severity = severityDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the finding, which is generated when abnormal or suspicious activity is detected.
    public struct Finding: Swift.Equatable {
        /// The ID of the account in which the finding was generated.
        /// This member is required.
        public var accountId: Swift.String?
        /// The ARN of the finding.
        /// This member is required.
        public var arn: Swift.String?
        /// The confidence score for the finding.
        public var confidence: Swift.Double
        /// The time and date when the finding was created.
        /// This member is required.
        public var createdAt: Swift.String?
        /// The description of the finding.
        public var description: Swift.String?
        /// The ID of the finding.
        /// This member is required.
        public var id: Swift.String?
        /// The partition associated with the finding.
        public var partition: Swift.String?
        /// The Region where the finding was generated.
        /// This member is required.
        public var region: Swift.String?
        /// Contains information about the AWS resource associated with the activity that prompted GuardDuty to generate a finding.
        /// This member is required.
        public var resource: GuardDutyClientTypes.Resource?
        /// The version of the schema used for the finding.
        /// This member is required.
        public var schemaVersion: Swift.String?
        /// Contains additional information about the generated finding.
        public var service: GuardDutyClientTypes.Service?
        /// The severity of the finding.
        /// This member is required.
        public var severity: Swift.Double
        /// The title of the finding.
        public var title: Swift.String?
        /// The type of finding.
        /// This member is required.
        public var type: Swift.String?
        /// The time and date when the finding was last updated.
        /// This member is required.
        public var updatedAt: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            confidence: Swift.Double = 0.0,
            createdAt: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            partition: Swift.String? = nil,
            region: Swift.String? = nil,
            resource: GuardDutyClientTypes.Resource? = nil,
            schemaVersion: Swift.String? = nil,
            service: GuardDutyClientTypes.Service? = nil,
            severity: Swift.Double = 0.0,
            title: Swift.String? = nil,
            type: Swift.String? = nil,
            updatedAt: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.arn = arn
            self.confidence = confidence
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.partition = partition
            self.region = region
            self.resource = resource
            self.schemaVersion = schemaVersion
            self.service = service
            self.severity = severity
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension GuardDutyClientTypes.FindingCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case criterion = "criterion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let criterion = criterion {
            var criterionContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .criterion)
            for (dictKey0, criterion0) in criterion {
                try criterionContainer.encode(criterion0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let criterionContainer = try containerValues.decodeIfPresent([Swift.String: GuardDutyClientTypes.Condition?].self, forKey: .criterion)
        var criterionDecoded0: [Swift.String:GuardDutyClientTypes.Condition]? = nil
        if let criterionContainer = criterionContainer {
            criterionDecoded0 = [Swift.String:GuardDutyClientTypes.Condition]()
            for (key0, condition0) in criterionContainer {
                if let condition0 = condition0 {
                    criterionDecoded0?[key0] = condition0
                }
            }
        }
        criterion = criterionDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the criteria used for querying findings.
    public struct FindingCriteria: Swift.Equatable {
        /// Represents a map of finding properties that match specified conditions and values when querying findings.
        public var criterion: [Swift.String:GuardDutyClientTypes.Condition]?

        public init (
            criterion: [Swift.String:GuardDutyClientTypes.Condition]? = nil
        )
        {
            self.criterion = criterion
        }
    }

}

extension GuardDutyClientTypes {
    public enum FindingPublishingFrequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fifteenMinutes
        case oneHour
        case sixHours
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingPublishingFrequency] {
            return [
                .fifteenMinutes,
                .oneHour,
                .sixHours,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fifteenMinutes: return "FIFTEEN_MINUTES"
            case .oneHour: return "ONE_HOUR"
            case .sixHours: return "SIX_HOURS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingPublishingFrequency(rawValue: rawValue) ?? FindingPublishingFrequency.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes {
    public enum FindingStatisticType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case countBySeverity
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingStatisticType] {
            return [
                .countBySeverity,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .countBySeverity: return "COUNT_BY_SEVERITY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingStatisticType(rawValue: rawValue) ?? FindingStatisticType.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.FindingStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countBySeverity = "countBySeverity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countBySeverity = countBySeverity {
            var countBySeverityContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .countBySeverity)
            for (dictKey0, countbyseverity0) in countBySeverity {
                try countBySeverityContainer.encode(countbyseverity0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countBySeverityContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .countBySeverity)
        var countBySeverityDecoded0: [Swift.String:Swift.Int]? = nil
        if let countBySeverityContainer = countBySeverityContainer {
            countBySeverityDecoded0 = [Swift.String:Swift.Int]()
            for (key0, integer0) in countBySeverityContainer {
                if let integer0 = integer0 {
                    countBySeverityDecoded0?[key0] = integer0
                }
            }
        }
        countBySeverity = countBySeverityDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about finding statistics.
    public struct FindingStatistics: Swift.Equatable {
        /// Represents a map of severity to count statistics for a set of findings.
        public var countBySeverity: [Swift.String:Swift.Int]?

        public init (
            countBySeverity: [Swift.String:Swift.Int]? = nil
        )
        {
            self.countBySeverity = countBySeverity
        }
    }

}

extension GuardDutyClientTypes.FlowLogsConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the status of VPC flow logs as a data source.
    public struct FlowLogsConfigurationResult: Swift.Equatable {
        /// Denotes whether VPC flow logs is enabled as a data source.
        /// This member is required.
        public var status: GuardDutyClientTypes.DataSourceStatus?

        public init (
            status: GuardDutyClientTypes.DataSourceStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension GuardDutyClientTypes.GeoLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lat = "lat"
        case lon = "lon"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if lat != 0.0 {
            try encodeContainer.encode(lat, forKey: .lat)
        }
        if lon != 0.0 {
            try encodeContainer.encode(lon, forKey: .lon)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latDecoded = try containerValues.decode(Swift.Double.self, forKey: .lat)
        lat = latDecoded
        let lonDecoded = try containerValues.decode(Swift.Double.self, forKey: .lon)
        lon = lonDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the location of the remote IP address.
    public struct GeoLocation: Swift.Equatable {
        /// The latitude information of the remote IP address.
        public var lat: Swift.Double
        /// The longitude information of the remote IP address.
        public var lon: Swift.Double

        public init (
            lat: Swift.Double = 0.0,
            lon: Swift.Double = 0.0
        )
        {
            self.lat = lat
            self.lon = lon
        }
    }

}

extension GetDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())"
    }
}

public struct GetDetectorInput: Swift.Equatable {
    /// The unique ID of the detector that you want to get.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        detectorId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct GetDetectorInputBody: Swift.Equatable {
}

extension GetDetectorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDetectorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDetectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.dataSources = output.dataSources
            self.findingPublishingFrequency = output.findingPublishingFrequency
            self.serviceRole = output.serviceRole
            self.status = output.status
            self.tags = output.tags
            self.updatedAt = output.updatedAt
        } else {
            self.createdAt = nil
            self.dataSources = nil
            self.findingPublishingFrequency = nil
            self.serviceRole = nil
            self.status = nil
            self.tags = nil
            self.updatedAt = nil
        }
    }
}

public struct GetDetectorOutputResponse: Swift.Equatable {
    /// The timestamp of when the detector was created.
    public var createdAt: Swift.String?
    /// Describes which data sources are enabled for the detector.
    public var dataSources: GuardDutyClientTypes.DataSourceConfigurationsResult?
    /// The publishing frequency of the finding.
    public var findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency?
    /// The GuardDuty service role.
    /// This member is required.
    public var serviceRole: Swift.String?
    /// The detector status.
    /// This member is required.
    public var status: GuardDutyClientTypes.DetectorStatus?
    /// The tags of the detector resource.
    public var tags: [Swift.String:Swift.String]?
    /// The last-updated timestamp for the detector.
    public var updatedAt: Swift.String?

    public init (
        createdAt: Swift.String? = nil,
        dataSources: GuardDutyClientTypes.DataSourceConfigurationsResult? = nil,
        findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency? = nil,
        serviceRole: Swift.String? = nil,
        status: GuardDutyClientTypes.DetectorStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updatedAt: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.dataSources = dataSources
        self.findingPublishingFrequency = findingPublishingFrequency
        self.serviceRole = serviceRole
        self.status = status
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

struct GetDetectorOutputResponseBody: Swift.Equatable {
    let createdAt: Swift.String?
    let findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency?
    let serviceRole: Swift.String?
    let status: GuardDutyClientTypes.DetectorStatus?
    let updatedAt: Swift.String?
    let dataSources: GuardDutyClientTypes.DataSourceConfigurationsResult?
    let tags: [Swift.String:Swift.String]?
}

extension GetDetectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "createdAt"
        case dataSources = "dataSources"
        case findingPublishingFrequency = "findingPublishingFrequency"
        case serviceRole = "serviceRole"
        case status = "status"
        case tags = "tags"
        case updatedAt = "updatedAt"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let findingPublishingFrequencyDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingPublishingFrequency.self, forKey: .findingPublishingFrequency)
        findingPublishingFrequency = findingPublishingFrequencyDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DetectorStatus.self, forKey: .status)
        status = statusDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceConfigurationsResult.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let filterName = filterName else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/filter/\(filterName.urlPercentEncoding())"
    }
}

public struct GetFilterInput: Swift.Equatable {
    /// The unique ID of the detector that the filter is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The name of the filter you want to get.
    /// This member is required.
    public var filterName: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        filterName: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.filterName = filterName
    }
}

struct GetFilterInputBody: Swift.Equatable {
}

extension GetFilterInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFilterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFilterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFilterOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFilterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFilterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.action = output.action
            self.description = output.description
            self.findingCriteria = output.findingCriteria
            self.name = output.name
            self.rank = output.rank
            self.tags = output.tags
        } else {
            self.action = nil
            self.description = nil
            self.findingCriteria = nil
            self.name = nil
            self.rank = 0
            self.tags = nil
        }
    }
}

public struct GetFilterOutputResponse: Swift.Equatable {
    /// Specifies the action that is to be applied to the findings that match the filter.
    /// This member is required.
    public var action: GuardDutyClientTypes.FilterAction?
    /// The description of the filter.
    public var description: Swift.String?
    /// Represents the criteria to be used in the filter for querying findings.
    /// This member is required.
    public var findingCriteria: GuardDutyClientTypes.FindingCriteria?
    /// The name of the filter.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the position of the filter in the list of current filters. Also specifies the order in which this filter is applied to the findings.
    public var rank: Swift.Int
    /// The tags of the filter resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        action: GuardDutyClientTypes.FilterAction? = nil,
        description: Swift.String? = nil,
        findingCriteria: GuardDutyClientTypes.FindingCriteria? = nil,
        name: Swift.String? = nil,
        rank: Swift.Int = 0,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.action = action
        self.description = description
        self.findingCriteria = findingCriteria
        self.name = name
        self.rank = rank
        self.tags = tags
    }
}

struct GetFilterOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let action: GuardDutyClientTypes.FilterAction?
    let rank: Swift.Int
    let findingCriteria: GuardDutyClientTypes.FindingCriteria?
    let tags: [Swift.String:Swift.String]?
}

extension GetFilterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "action"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case name = "name"
        case rank = "rank"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let actionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FilterAction.self, forKey: .action)
        action = actionDecoded
        let rankDecoded = try containerValues.decode(Swift.Int.self, forKey: .rank)
        rank = rankDecoded
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIds = "findingIds"
        case sortCriteria = "sortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingIds = findingIds {
            var findingIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingIds)
            for findingids0 in findingIds {
                try findingIdsContainer.encode(findingids0)
            }
        }
        if let sortCriteria = sortCriteria {
            try encodeContainer.encode(sortCriteria, forKey: .sortCriteria)
        }
    }
}

extension GetFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/findings/get"
    }
}

public struct GetFindingsInput: Swift.Equatable {
    /// The ID of the detector that specifies the GuardDuty service whose findings you want to retrieve.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The IDs of the findings that you want to retrieve.
    /// This member is required.
    public var findingIds: [Swift.String]?
    /// Represents the criteria used for sorting findings.
    public var sortCriteria: GuardDutyClientTypes.SortCriteria?

    public init (
        detectorId: Swift.String? = nil,
        findingIds: [Swift.String]? = nil,
        sortCriteria: GuardDutyClientTypes.SortCriteria? = nil
    )
    {
        self.detectorId = detectorId
        self.findingIds = findingIds
        self.sortCriteria = sortCriteria
    }
}

struct GetFindingsInputBody: Swift.Equatable {
    let findingIds: [Swift.String]?
    let sortCriteria: GuardDutyClientTypes.SortCriteria?
}

extension GetFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIds = "findingIds"
        case sortCriteria = "sortCriteria"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[Swift.String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [Swift.String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
        let sortCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.SortCriteria.self, forKey: .sortCriteria)
        sortCriteria = sortCriteriaDecoded
    }
}

extension GetFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFindingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFindingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.findings = output.findings
        } else {
            self.findings = nil
        }
    }
}

public struct GetFindingsOutputResponse: Swift.Equatable {
    /// A list of findings.
    /// This member is required.
    public var findings: [GuardDutyClientTypes.Finding]?

    public init (
        findings: [GuardDutyClientTypes.Finding]? = nil
    )
    {
        self.findings = findings
    }
}

struct GetFindingsOutputResponseBody: Swift.Equatable {
    let findings: [GuardDutyClientTypes.Finding]?
}

extension GetFindingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findings = "findings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Finding?].self, forKey: .findings)
        var findingsDecoded0:[GuardDutyClientTypes.Finding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [GuardDutyClientTypes.Finding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
    }
}

extension GetFindingsStatisticsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingCriteria = "findingCriteria"
        case findingStatisticTypes = "findingStatisticTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingCriteria = findingCriteria {
            try encodeContainer.encode(findingCriteria, forKey: .findingCriteria)
        }
        if let findingStatisticTypes = findingStatisticTypes {
            var findingStatisticTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingStatisticTypes)
            for findingstatistictypes0 in findingStatisticTypes {
                try findingStatisticTypesContainer.encode(findingstatistictypes0.rawValue)
            }
        }
    }
}

extension GetFindingsStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/findings/statistics"
    }
}

public struct GetFindingsStatisticsInput: Swift.Equatable {
    /// The ID of the detector that specifies the GuardDuty service whose findings' statistics you want to retrieve.
    /// This member is required.
    public var detectorId: Swift.String?
    /// Represents the criteria that is used for querying findings.
    public var findingCriteria: GuardDutyClientTypes.FindingCriteria?
    /// The types of finding statistics to retrieve.
    /// This member is required.
    public var findingStatisticTypes: [GuardDutyClientTypes.FindingStatisticType]?

    public init (
        detectorId: Swift.String? = nil,
        findingCriteria: GuardDutyClientTypes.FindingCriteria? = nil,
        findingStatisticTypes: [GuardDutyClientTypes.FindingStatisticType]? = nil
    )
    {
        self.detectorId = detectorId
        self.findingCriteria = findingCriteria
        self.findingStatisticTypes = findingStatisticTypes
    }
}

struct GetFindingsStatisticsInputBody: Swift.Equatable {
    let findingStatisticTypes: [GuardDutyClientTypes.FindingStatisticType]?
    let findingCriteria: GuardDutyClientTypes.FindingCriteria?
}

extension GetFindingsStatisticsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingCriteria = "findingCriteria"
        case findingStatisticTypes = "findingStatisticTypes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingStatisticTypesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.FindingStatisticType?].self, forKey: .findingStatisticTypes)
        var findingStatisticTypesDecoded0:[GuardDutyClientTypes.FindingStatisticType]? = nil
        if let findingStatisticTypesContainer = findingStatisticTypesContainer {
            findingStatisticTypesDecoded0 = [GuardDutyClientTypes.FindingStatisticType]()
            for string0 in findingStatisticTypesContainer {
                if let string0 = string0 {
                    findingStatisticTypesDecoded0?.append(string0)
                }
            }
        }
        findingStatisticTypes = findingStatisticTypesDecoded0
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
    }
}

extension GetFindingsStatisticsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFindingsStatisticsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFindingsStatisticsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFindingsStatisticsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFindingsStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.findingStatistics = output.findingStatistics
        } else {
            self.findingStatistics = nil
        }
    }
}

public struct GetFindingsStatisticsOutputResponse: Swift.Equatable {
    /// The finding statistics object.
    /// This member is required.
    public var findingStatistics: GuardDutyClientTypes.FindingStatistics?

    public init (
        findingStatistics: GuardDutyClientTypes.FindingStatistics? = nil
    )
    {
        self.findingStatistics = findingStatistics
    }
}

struct GetFindingsStatisticsOutputResponseBody: Swift.Equatable {
    let findingStatistics: GuardDutyClientTypes.FindingStatistics?
}

extension GetFindingsStatisticsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingStatistics = "findingStatistics"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingStatisticsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingStatistics.self, forKey: .findingStatistics)
        findingStatistics = findingStatisticsDecoded
    }
}

extension GetIPSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let ipSetId = ipSetId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/ipset/\(ipSetId.urlPercentEncoding())"
    }
}

public struct GetIPSetInput: Swift.Equatable {
    /// The unique ID of the detector that the IPSet is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The unique ID of the IPSet to retrieve.
    /// This member is required.
    public var ipSetId: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        ipSetId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.ipSetId = ipSetId
    }
}

struct GetIPSetInputBody: Swift.Equatable {
}

extension GetIPSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetIPSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIPSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIPSetOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIPSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetIPSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.format = output.format
            self.location = output.location
            self.name = output.name
            self.status = output.status
            self.tags = output.tags
        } else {
            self.format = nil
            self.location = nil
            self.name = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct GetIPSetOutputResponse: Swift.Equatable {
    /// The format of the file that contains the IPSet.
    /// This member is required.
    public var format: GuardDutyClientTypes.IpSetFormat?
    /// The URI of the file that contains the IPSet. For example: https://s3.us-west-2.amazonaws.com/my-bucket/my-object-key.
    /// This member is required.
    public var location: Swift.String?
    /// The user-friendly name for the IPSet.
    /// This member is required.
    public var name: Swift.String?
    /// The status of IPSet file that was uploaded.
    /// This member is required.
    public var status: GuardDutyClientTypes.IpSetStatus?
    /// The tags of the IPSet resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        format: GuardDutyClientTypes.IpSetFormat? = nil,
        location: Swift.String? = nil,
        name: Swift.String? = nil,
        status: GuardDutyClientTypes.IpSetStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.format = format
        self.location = location
        self.name = name
        self.status = status
        self.tags = tags
    }
}

struct GetIPSetOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let format: GuardDutyClientTypes.IpSetFormat?
    let location: Swift.String?
    let status: GuardDutyClientTypes.IpSetStatus?
    let tags: [Swift.String:Swift.String]?
}

extension GetIPSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format = "format"
        case location = "location"
        case name = "name"
        case status = "status"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.IpSetFormat.self, forKey: .format)
        format = formatDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.IpSetStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetInvitationsCountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/invitation/count"
    }
}

public struct GetInvitationsCountInput: Swift.Equatable {

}

struct GetInvitationsCountInputBody: Swift.Equatable {
}

extension GetInvitationsCountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetInvitationsCountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInvitationsCountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInvitationsCountOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInvitationsCountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetInvitationsCountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.invitationsCount = output.invitationsCount
        } else {
            self.invitationsCount = 0
        }
    }
}

public struct GetInvitationsCountOutputResponse: Swift.Equatable {
    /// The number of received invitations.
    public var invitationsCount: Swift.Int

    public init (
        invitationsCount: Swift.Int = 0
    )
    {
        self.invitationsCount = invitationsCount
    }
}

struct GetInvitationsCountOutputResponseBody: Swift.Equatable {
    let invitationsCount: Swift.Int
}

extension GetInvitationsCountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitationsCount = "invitationsCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitationsCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .invitationsCount)
        invitationsCount = invitationsCountDecoded
    }
}

extension GetMasterAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/master"
    }
}

public struct GetMasterAccountInput: Swift.Equatable {
    /// The unique ID of the detector of the GuardDuty member account.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        detectorId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct GetMasterAccountInputBody: Swift.Equatable {
}

extension GetMasterAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMasterAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMasterAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMasterAccountOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMasterAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMasterAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.master = output.master
        } else {
            self.master = nil
        }
    }
}

public struct GetMasterAccountOutputResponse: Swift.Equatable {
    /// The administrator account details.
    /// This member is required.
    public var master: GuardDutyClientTypes.Master?

    public init (
        master: GuardDutyClientTypes.Master? = nil
    )
    {
        self.master = master
    }
}

struct GetMasterAccountOutputResponseBody: Swift.Equatable {
    let master: GuardDutyClientTypes.Master?
}

extension GetMasterAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case master = "master"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let masterDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Master.self, forKey: .master)
        master = masterDecoded
    }
}

extension GetMemberDetectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
    }
}

extension GetMemberDetectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member/detector/get"
    }
}

public struct GetMemberDetectorsInput: Swift.Equatable {
    /// The account ID of the member account.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The detector ID for the administrator account.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct GetMemberDetectorsInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension GetMemberDetectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension GetMemberDetectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMemberDetectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMemberDetectorsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMemberDetectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMemberDetectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.memberDataSourceConfigurations = output.memberDataSourceConfigurations
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.memberDataSourceConfigurations = nil
            self.unprocessedAccounts = nil
        }
    }
}

public struct GetMemberDetectorsOutputResponse: Swift.Equatable {
    /// An object that describes which data sources are enabled for a member account.
    /// This member is required.
    public var memberDataSourceConfigurations: [GuardDutyClientTypes.MemberDataSourceConfiguration]?
    /// A list of member account IDs that were unable to be processed along with an explanation for why they were not processed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init (
        memberDataSourceConfigurations: [GuardDutyClientTypes.MemberDataSourceConfiguration]? = nil,
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.memberDataSourceConfigurations = memberDataSourceConfigurations
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct GetMemberDetectorsOutputResponseBody: Swift.Equatable {
    let memberDataSourceConfigurations: [GuardDutyClientTypes.MemberDataSourceConfiguration]?
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension GetMemberDetectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberDataSourceConfigurations = "members"
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDataSourceConfigurationsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.MemberDataSourceConfiguration?].self, forKey: .memberDataSourceConfigurations)
        var memberDataSourceConfigurationsDecoded0:[GuardDutyClientTypes.MemberDataSourceConfiguration]? = nil
        if let memberDataSourceConfigurationsContainer = memberDataSourceConfigurationsContainer {
            memberDataSourceConfigurationsDecoded0 = [GuardDutyClientTypes.MemberDataSourceConfiguration]()
            for structure0 in memberDataSourceConfigurationsContainer {
                if let structure0 = structure0 {
                    memberDataSourceConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        memberDataSourceConfigurations = memberDataSourceConfigurationsDecoded0
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension GetMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
    }
}

extension GetMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member/get"
    }
}

public struct GetMembersInput: Swift.Equatable {
    /// A list of account IDs of the GuardDuty member accounts that you want to describe.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The unique ID of the detector of the GuardDuty account whose members you want to retrieve.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct GetMembersInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension GetMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension GetMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMembersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.members = nil
            self.unprocessedAccounts = nil
        }
    }
}

public struct GetMembersOutputResponse: Swift.Equatable {
    /// A list of members.
    /// This member is required.
    public var members: [GuardDutyClientTypes.Member]?
    /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init (
        members: [GuardDutyClientTypes.Member]? = nil,
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.members = members
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct GetMembersOutputResponseBody: Swift.Equatable {
    let members: [GuardDutyClientTypes.Member]?
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension GetMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members = "members"
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Member?].self, forKey: .members)
        var membersDecoded0:[GuardDutyClientTypes.Member]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [GuardDutyClientTypes.Member]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension GetThreatIntelSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let threatIntelSetId = threatIntelSetId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/threatintelset/\(threatIntelSetId.urlPercentEncoding())"
    }
}

public struct GetThreatIntelSetInput: Swift.Equatable {
    /// The unique ID of the detector that the threatIntelSet is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The unique ID of the threatIntelSet that you want to get.
    /// This member is required.
    public var threatIntelSetId: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        threatIntelSetId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.threatIntelSetId = threatIntelSetId
    }
}

struct GetThreatIntelSetInputBody: Swift.Equatable {
}

extension GetThreatIntelSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetThreatIntelSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetThreatIntelSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetThreatIntelSetOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetThreatIntelSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetThreatIntelSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.format = output.format
            self.location = output.location
            self.name = output.name
            self.status = output.status
            self.tags = output.tags
        } else {
            self.format = nil
            self.location = nil
            self.name = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct GetThreatIntelSetOutputResponse: Swift.Equatable {
    /// The format of the threatIntelSet.
    /// This member is required.
    public var format: GuardDutyClientTypes.ThreatIntelSetFormat?
    /// The URI of the file that contains the ThreatIntelSet. For example: https://s3.us-west-2.amazonaws.com/my-bucket/my-object-key.
    /// This member is required.
    public var location: Swift.String?
    /// A user-friendly ThreatIntelSet name displayed in all findings that are generated by activity that involves IP addresses included in this ThreatIntelSet.
    /// This member is required.
    public var name: Swift.String?
    /// The status of threatIntelSet file uploaded.
    /// This member is required.
    public var status: GuardDutyClientTypes.ThreatIntelSetStatus?
    /// The tags of the threat list resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        format: GuardDutyClientTypes.ThreatIntelSetFormat? = nil,
        location: Swift.String? = nil,
        name: Swift.String? = nil,
        status: GuardDutyClientTypes.ThreatIntelSetStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.format = format
        self.location = location
        self.name = name
        self.status = status
        self.tags = tags
    }
}

struct GetThreatIntelSetOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let format: GuardDutyClientTypes.ThreatIntelSetFormat?
    let location: Swift.String?
    let status: GuardDutyClientTypes.ThreatIntelSetStatus?
    let tags: [Swift.String:Swift.String]?
}

extension GetThreatIntelSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format = "format"
        case location = "location"
        case name = "name"
        case status = "status"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ThreatIntelSetFormat.self, forKey: .format)
        format = formatDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ThreatIntelSetStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetUsageStatisticsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case unit = "unit"
        case usageCriteria = "usageCriteria"
        case usageStatisticType = "usageStatisticsType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
        if let usageCriteria = usageCriteria {
            try encodeContainer.encode(usageCriteria, forKey: .usageCriteria)
        }
        if let usageStatisticType = usageStatisticType {
            try encodeContainer.encode(usageStatisticType.rawValue, forKey: .usageStatisticType)
        }
    }
}

extension GetUsageStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/usage/statistics"
    }
}

public struct GetUsageStatisticsInput: Swift.Equatable {
    /// The ID of the detector that specifies the GuardDuty service whose usage statistics you want to retrieve.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// The currency unit you would like to view your usage statistics in. Current valid values are USD.
    public var unit: Swift.String?
    /// Represents the criteria used for querying usage.
    /// This member is required.
    public var usageCriteria: GuardDutyClientTypes.UsageCriteria?
    /// The type of usage statistics to retrieve.
    /// This member is required.
    public var usageStatisticType: GuardDutyClientTypes.UsageStatisticType?

    public init (
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        unit: Swift.String? = nil,
        usageCriteria: GuardDutyClientTypes.UsageCriteria? = nil,
        usageStatisticType: GuardDutyClientTypes.UsageStatisticType? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.unit = unit
        self.usageCriteria = usageCriteria
        self.usageStatisticType = usageStatisticType
    }
}

struct GetUsageStatisticsInputBody: Swift.Equatable {
    let usageStatisticType: GuardDutyClientTypes.UsageStatisticType?
    let usageCriteria: GuardDutyClientTypes.UsageCriteria?
    let unit: Swift.String?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension GetUsageStatisticsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case unit = "unit"
        case usageCriteria = "usageCriteria"
        case usageStatisticType = "usageStatisticsType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageStatisticTypeDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.UsageStatisticType.self, forKey: .usageStatisticType)
        usageStatisticType = usageStatisticTypeDecoded
        let usageCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.UsageCriteria.self, forKey: .usageCriteria)
        usageCriteria = usageCriteriaDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetUsageStatisticsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUsageStatisticsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUsageStatisticsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUsageStatisticsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetUsageStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.usageStatistics = output.usageStatistics
        } else {
            self.nextToken = nil
            self.usageStatistics = nil
        }
    }
}

public struct GetUsageStatisticsOutputResponse: Swift.Equatable {
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?
    /// The usage statistics object. If a UsageStatisticType was provided, the objects representing other types will be null.
    public var usageStatistics: GuardDutyClientTypes.UsageStatistics?

    public init (
        nextToken: Swift.String? = nil,
        usageStatistics: GuardDutyClientTypes.UsageStatistics? = nil
    )
    {
        self.nextToken = nextToken
        self.usageStatistics = usageStatistics
    }
}

struct GetUsageStatisticsOutputResponseBody: Swift.Equatable {
    let usageStatistics: GuardDutyClientTypes.UsageStatistics?
    let nextToken: Swift.String?
}

extension GetUsageStatisticsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case usageStatistics = "usageStatistics"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageStatisticsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.UsageStatistics.self, forKey: .usageStatistics)
        usageStatistics = usageStatisticsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GuardDutyClientTypes.IamInstanceProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case id = "id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the EC2 instance profile.
    public struct IamInstanceProfile: Swift.Equatable {
        /// The profile ARN of the EC2 instance.
        public var arn: Swift.String?
        /// The profile ID of the EC2 instance.
        public var id: Swift.String?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
        }
    }

}

extension GuardDutyClientTypes.InstanceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "availabilityZone"
        case iamInstanceProfile = "iamInstanceProfile"
        case imageDescription = "imageDescription"
        case imageId = "imageId"
        case instanceId = "instanceId"
        case instanceState = "instanceState"
        case instanceType = "instanceType"
        case launchTime = "launchTime"
        case networkInterfaces = "networkInterfaces"
        case outpostArn = "outpostArn"
        case platform = "platform"
        case productCodes = "productCodes"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let iamInstanceProfile = iamInstanceProfile {
            try encodeContainer.encode(iamInstanceProfile, forKey: .iamInstanceProfile)
        }
        if let imageDescription = imageDescription {
            try encodeContainer.encode(imageDescription, forKey: .imageDescription)
        }
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let instanceState = instanceState {
            try encodeContainer.encode(instanceState, forKey: .instanceState)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let launchTime = launchTime {
            try encodeContainer.encode(launchTime, forKey: .launchTime)
        }
        if let networkInterfaces = networkInterfaces {
            var networkInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaces)
            for networkinterfaces0 in networkInterfaces {
                try networkInterfacesContainer.encode(networkinterfaces0)
            }
        }
        if let outpostArn = outpostArn {
            try encodeContainer.encode(outpostArn, forKey: .outpostArn)
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let productCodes = productCodes {
            var productCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productCodes)
            for productcodes0 in productCodes {
                try productCodesContainer.encode(productcodes0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let iamInstanceProfileDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.IamInstanceProfile.self, forKey: .iamInstanceProfile)
        iamInstanceProfile = iamInstanceProfileDecoded
        let imageDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDescription)
        imageDescription = imageDescriptionDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let instanceStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceState)
        instanceState = instanceStateDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let outpostArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostArn)
        outpostArn = outpostArnDecoded
        let launchTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchTime)
        launchTime = launchTimeDecoded
        let networkInterfacesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.NetworkInterface?].self, forKey: .networkInterfaces)
        var networkInterfacesDecoded0:[GuardDutyClientTypes.NetworkInterface]? = nil
        if let networkInterfacesContainer = networkInterfacesContainer {
            networkInterfacesDecoded0 = [GuardDutyClientTypes.NetworkInterface]()
            for structure0 in networkInterfacesContainer {
                if let structure0 = structure0 {
                    networkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaces = networkInterfacesDecoded0
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
        let productCodesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.ProductCode?].self, forKey: .productCodes)
        var productCodesDecoded0:[GuardDutyClientTypes.ProductCode]? = nil
        if let productCodesContainer = productCodesContainer {
            productCodesDecoded0 = [GuardDutyClientTypes.ProductCode]()
            for structure0 in productCodesContainer {
                if let structure0 = structure0 {
                    productCodesDecoded0?.append(structure0)
                }
            }
        }
        productCodes = productCodesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GuardDutyClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GuardDutyClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the details of an instance.
    public struct InstanceDetails: Swift.Equatable {
        /// The Availability Zone of the EC2 instance.
        public var availabilityZone: Swift.String?
        /// The profile information of the EC2 instance.
        public var iamInstanceProfile: GuardDutyClientTypes.IamInstanceProfile?
        /// The image description of the EC2 instance.
        public var imageDescription: Swift.String?
        /// The image ID of the EC2 instance.
        public var imageId: Swift.String?
        /// The ID of the EC2 instance.
        public var instanceId: Swift.String?
        /// The state of the EC2 instance.
        public var instanceState: Swift.String?
        /// The type of the EC2 instance.
        public var instanceType: Swift.String?
        /// The launch time of the EC2 instance.
        public var launchTime: Swift.String?
        /// The elastic network interface information of the EC2 instance.
        public var networkInterfaces: [GuardDutyClientTypes.NetworkInterface]?
        /// The Amazon Resource Name (ARN) of the AWS Outpost. Only applicable to AWS Outposts instances.
        public var outpostArn: Swift.String?
        /// The platform of the EC2 instance.
        public var platform: Swift.String?
        /// The product code of the EC2 instance.
        public var productCodes: [GuardDutyClientTypes.ProductCode]?
        /// The tags of the EC2 instance.
        public var tags: [GuardDutyClientTypes.Tag]?

        public init (
            availabilityZone: Swift.String? = nil,
            iamInstanceProfile: GuardDutyClientTypes.IamInstanceProfile? = nil,
            imageDescription: Swift.String? = nil,
            imageId: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            instanceState: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            launchTime: Swift.String? = nil,
            networkInterfaces: [GuardDutyClientTypes.NetworkInterface]? = nil,
            outpostArn: Swift.String? = nil,
            platform: Swift.String? = nil,
            productCodes: [GuardDutyClientTypes.ProductCode]? = nil,
            tags: [GuardDutyClientTypes.Tag]? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.iamInstanceProfile = iamInstanceProfile
            self.imageDescription = imageDescription
            self.imageId = imageId
            self.instanceId = instanceId
            self.instanceState = instanceState
            self.instanceType = instanceType
            self.launchTime = launchTime
            self.networkInterfaces = networkInterfaces
            self.outpostArn = outpostArn
            self.platform = platform
            self.productCodes = productCodes
            self.tags = tags
        }
    }

}

extension InternalServerErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal server error exception object.
public struct InternalServerErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The error message.
    public var message: Swift.String?
    /// The error type.
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let type: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
        case type = "__type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension GuardDutyClientTypes.Invitation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case invitationId = "invitationId"
        case invitedAt = "invitedAt"
        case relationshipStatus = "relationshipStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let invitationId = invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
        if let invitedAt = invitedAt {
            try encodeContainer.encode(invitedAt, forKey: .invitedAt)
        }
        if let relationshipStatus = relationshipStatus {
            try encodeContainer.encode(relationshipStatus, forKey: .relationshipStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
        let relationshipStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relationshipStatus)
        relationshipStatus = relationshipStatusDecoded
        let invitedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitedAt)
        invitedAt = invitedAtDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the invitation to become a member account.
    public struct Invitation: Swift.Equatable {
        /// The ID of the account that the invitation was sent from.
        public var accountId: Swift.String?
        /// The ID of the invitation. This value is used to validate the inviter account to the member account.
        public var invitationId: Swift.String?
        /// The timestamp when the invitation was sent.
        public var invitedAt: Swift.String?
        /// The status of the relationship between the inviter and invitee accounts.
        public var relationshipStatus: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            invitationId: Swift.String? = nil,
            invitedAt: Swift.String? = nil,
            relationshipStatus: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.invitationId = invitationId
            self.invitedAt = invitedAt
            self.relationshipStatus = relationshipStatus
        }
    }

}

extension InviteMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
        case disableEmailNotification = "disableEmailNotification"
        case message = "message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
        if disableEmailNotification != false {
            try encodeContainer.encode(disableEmailNotification, forKey: .disableEmailNotification)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }
}

extension InviteMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member/invite"
    }
}

public struct InviteMembersInput: Swift.Equatable {
    /// A list of account IDs of the accounts that you want to invite to GuardDuty as members.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The unique ID of the detector of the GuardDuty account that you want to invite members with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// A Boolean value that specifies whether you want to disable email notification to the accounts that you are inviting to GuardDuty as members.
    public var disableEmailNotification: Swift.Bool
    /// The invitation message that you want to send to the accounts that you're inviting to GuardDuty as members.
    public var message: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        detectorId: Swift.String? = nil,
        disableEmailNotification: Swift.Bool = false,
        message: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
        self.disableEmailNotification = disableEmailNotification
        self.message = message
    }
}

struct InviteMembersInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
    let disableEmailNotification: Swift.Bool
    let message: Swift.String?
}

extension InviteMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
        case disableEmailNotification = "disableEmailNotification"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let disableEmailNotificationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .disableEmailNotification)
        disableEmailNotification = disableEmailNotificationDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InviteMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InviteMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InviteMembersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InviteMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InviteMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct InviteMembersOutputResponse: Swift.Equatable {
    /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init (
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct InviteMembersOutputResponseBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension InviteMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension GuardDutyClientTypes {
    public enum IpSetFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alienVault
        case fireEye
        case otxCsv
        case proofPoint
        case stix
        case txt
        case sdkUnknown(Swift.String)

        public static var allCases: [IpSetFormat] {
            return [
                .alienVault,
                .fireEye,
                .otxCsv,
                .proofPoint,
                .stix,
                .txt,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alienVault: return "ALIEN_VAULT"
            case .fireEye: return "FIRE_EYE"
            case .otxCsv: return "OTX_CSV"
            case .proofPoint: return "PROOF_POINT"
            case .stix: return "STIX"
            case .txt: return "TXT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IpSetFormat(rawValue: rawValue) ?? IpSetFormat.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes {
    public enum IpSetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activating
        case active
        case deactivating
        case deleted
        case deletePending
        case error
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [IpSetStatus] {
            return [
                .activating,
                .active,
                .deactivating,
                .deleted,
                .deletePending,
                .error,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activating: return "ACTIVATING"
            case .active: return "ACTIVE"
            case .deactivating: return "DEACTIVATING"
            case .deleted: return "DELETED"
            case .deletePending: return "DELETE_PENDING"
            case .error: return "ERROR"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IpSetStatus(rawValue: rawValue) ?? IpSetStatus.sdkUnknown(rawValue)
        }
    }
}

extension ListDetectorsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDetectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/detector"
    }
}

public struct ListDetectorsInput: Swift.Equatable {
    /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 50. The maximum value is 50.
    public var maxResults: Swift.Int
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDetectorsInputBody: Swift.Equatable {
}

extension ListDetectorsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDetectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDetectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDetectorsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDetectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDetectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.detectorIds = output.detectorIds
            self.nextToken = output.nextToken
        } else {
            self.detectorIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListDetectorsOutputResponse: Swift.Equatable {
    /// A list of detector IDs.
    /// This member is required.
    public var detectorIds: [Swift.String]?
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?

    public init (
        detectorIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorIds = detectorIds
        self.nextToken = nextToken
    }
}

struct ListDetectorsOutputResponseBody: Swift.Equatable {
    let detectorIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListDetectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorIds = "detectorIds"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .detectorIds)
        var detectorIdsDecoded0:[Swift.String]? = nil
        if let detectorIdsContainer = detectorIdsContainer {
            detectorIdsDecoded0 = [Swift.String]()
            for string0 in detectorIdsContainer {
                if let string0 = string0 {
                    detectorIdsDecoded0?.append(string0)
                }
            }
        }
        detectorIds = detectorIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFiltersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListFiltersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/filter"
    }
}

public struct ListFiltersInput: Swift.Equatable {
    /// The unique ID of the detector that the filter is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 50. The maximum value is 50.
    public var maxResults: Swift.Int
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFiltersInputBody: Swift.Equatable {
}

extension ListFiltersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFiltersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFiltersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFiltersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFiltersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFiltersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.filterNames = output.filterNames
            self.nextToken = output.nextToken
        } else {
            self.filterNames = nil
            self.nextToken = nil
        }
    }
}

public struct ListFiltersOutputResponse: Swift.Equatable {
    /// A list of filter names.
    /// This member is required.
    public var filterNames: [Swift.String]?
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?

    public init (
        filterNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filterNames = filterNames
        self.nextToken = nextToken
    }
}

struct ListFiltersOutputResponseBody: Swift.Equatable {
    let filterNames: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListFiltersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterNames = "filterNames"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .filterNames)
        var filterNamesDecoded0:[Swift.String]? = nil
        if let filterNamesContainer = filterNamesContainer {
            filterNamesDecoded0 = [Swift.String]()
            for string0 in filterNamesContainer {
                if let string0 = string0 {
                    filterNamesDecoded0?.append(string0)
                }
            }
        }
        filterNames = filterNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingCriteria = "findingCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingCriteria = findingCriteria {
            try encodeContainer.encode(findingCriteria, forKey: .findingCriteria)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            try encodeContainer.encode(sortCriteria, forKey: .sortCriteria)
        }
    }
}

extension ListFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/findings"
    }
}

public struct ListFindingsInput: Swift.Equatable {
    /// The ID of the detector that specifies the GuardDuty service whose findings you want to list.
    /// This member is required.
    public var detectorId: Swift.String?
    /// Represents the criteria used for querying findings. Valid values include:
    ///
    /// * JSON field name
    ///
    /// * accountId
    ///
    /// * region
    ///
    /// * confidence
    ///
    /// * id
    ///
    /// * resource.accessKeyDetails.accessKeyId
    ///
    /// * resource.accessKeyDetails.principalId
    ///
    /// * resource.accessKeyDetails.userName
    ///
    /// * resource.accessKeyDetails.userType
    ///
    /// * resource.instanceDetails.iamInstanceProfile.id
    ///
    /// * resource.instanceDetails.imageId
    ///
    /// * resource.instanceDetails.instanceId
    ///
    /// * resource.instanceDetails.networkInterfaces.ipv6Addresses
    ///
    /// * resource.instanceDetails.networkInterfaces.privateIpAddresses.privateIpAddress
    ///
    /// * resource.instanceDetails.networkInterfaces.publicDnsName
    ///
    /// * resource.instanceDetails.networkInterfaces.publicIp
    ///
    /// * resource.instanceDetails.networkInterfaces.securityGroups.groupId
    ///
    /// * resource.instanceDetails.networkInterfaces.securityGroups.groupName
    ///
    /// * resource.instanceDetails.networkInterfaces.subnetId
    ///
    /// * resource.instanceDetails.networkInterfaces.vpcId
    ///
    /// * resource.instanceDetails.tags.key
    ///
    /// * resource.instanceDetails.tags.value
    ///
    /// * resource.resourceType
    ///
    /// * service.action.actionType
    ///
    /// * service.action.awsApiCallAction.api
    ///
    /// * service.action.awsApiCallAction.callerType
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.city.cityName
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.country.countryName
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.ipAddressV4
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.organization.asn
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.organization.asnOrg
    ///
    /// * service.action.awsApiCallAction.serviceName
    ///
    /// * service.action.dnsRequestAction.domain
    ///
    /// * service.action.networkConnectionAction.blocked
    ///
    /// * service.action.networkConnectionAction.connectionDirection
    ///
    /// * service.action.networkConnectionAction.localPortDetails.port
    ///
    /// * service.action.networkConnectionAction.protocol
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.city.cityName
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.country.countryName
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.ipAddressV4
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.organization.asn
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.organization.asnOrg
    ///
    /// * service.action.networkConnectionAction.remotePortDetails.port
    ///
    /// * service.additionalInfo.threatListName
    ///
    /// * service.archived When this attribute is set to 'true', only archived findings are listed. When it's set to 'false', only unarchived findings are listed. When this attribute is not set, all existing findings are listed.
    ///
    /// * service.resourceRole
    ///
    /// * severity
    ///
    /// * type
    ///
    /// * updatedAt Type: Timestamp in Unix Epoch millisecond format: 1486685375000
    public var findingCriteria: GuardDutyClientTypes.FindingCriteria?
    /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 50. The maximum value is 50.
    public var maxResults: Swift.Int
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?
    /// Represents the criteria used for sorting findings.
    public var sortCriteria: GuardDutyClientTypes.SortCriteria?

    public init (
        detectorId: Swift.String? = nil,
        findingCriteria: GuardDutyClientTypes.FindingCriteria? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        sortCriteria: GuardDutyClientTypes.SortCriteria? = nil
    )
    {
        self.detectorId = detectorId
        self.findingCriteria = findingCriteria
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct ListFindingsInputBody: Swift.Equatable {
    let findingCriteria: GuardDutyClientTypes.FindingCriteria?
    let sortCriteria: GuardDutyClientTypes.SortCriteria?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension ListFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingCriteria = "findingCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
        let sortCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.SortCriteria.self, forKey: .sortCriteria)
        sortCriteria = sortCriteriaDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFindingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFindingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.findingIds = output.findingIds
            self.nextToken = output.nextToken
        } else {
            self.findingIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListFindingsOutputResponse: Swift.Equatable {
    /// The IDs of the findings that you're listing.
    /// This member is required.
    public var findingIds: [Swift.String]?
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?

    public init (
        findingIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findingIds = findingIds
        self.nextToken = nextToken
    }
}

struct ListFindingsOutputResponseBody: Swift.Equatable {
    let findingIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListFindingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIds = "findingIds"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[Swift.String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [Swift.String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIPSetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListIPSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/ipset"
    }
}

public struct ListIPSetsInput: Swift.Equatable {
    /// The unique ID of the detector that the IPSet is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 50. The maximum value is 50.
    public var maxResults: Swift.Int
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIPSetsInputBody: Swift.Equatable {
}

extension ListIPSetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListIPSetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIPSetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIPSetsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIPSetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListIPSetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ipSetIds = output.ipSetIds
            self.nextToken = output.nextToken
        } else {
            self.ipSetIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListIPSetsOutputResponse: Swift.Equatable {
    /// The IDs of the IPSet resources.
    /// This member is required.
    public var ipSetIds: [Swift.String]?
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?

    public init (
        ipSetIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ipSetIds = ipSetIds
        self.nextToken = nextToken
    }
}

struct ListIPSetsOutputResponseBody: Swift.Equatable {
    let ipSetIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListIPSetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipSetIds = "ipSetIds"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipSetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipSetIds)
        var ipSetIdsDecoded0:[Swift.String]? = nil
        if let ipSetIdsContainer = ipSetIdsContainer {
            ipSetIdsDecoded0 = [Swift.String]()
            for string0 in ipSetIdsContainer {
                if let string0 = string0 {
                    ipSetIdsDecoded0?.append(string0)
                }
            }
        }
        ipSetIds = ipSetIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInvitationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListInvitationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/invitation"
    }
}

public struct ListInvitationsInput: Swift.Equatable {
    /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 50. The maximum value is 50.
    public var maxResults: Swift.Int
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInvitationsInputBody: Swift.Equatable {
}

extension ListInvitationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListInvitationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInvitationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInvitationsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInvitationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.invitations = output.invitations
            self.nextToken = output.nextToken
        } else {
            self.invitations = nil
            self.nextToken = nil
        }
    }
}

public struct ListInvitationsOutputResponse: Swift.Equatable {
    /// A list of invitation descriptions.
    public var invitations: [GuardDutyClientTypes.Invitation]?
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?

    public init (
        invitations: [GuardDutyClientTypes.Invitation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.invitations = invitations
        self.nextToken = nextToken
    }
}

struct ListInvitationsOutputResponseBody: Swift.Equatable {
    let invitations: [GuardDutyClientTypes.Invitation]?
    let nextToken: Swift.String?
}

extension ListInvitationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitations = "invitations"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitationsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Invitation?].self, forKey: .invitations)
        var invitationsDecoded0:[GuardDutyClientTypes.Invitation]? = nil
        if let invitationsContainer = invitationsContainer {
            invitationsDecoded0 = [GuardDutyClientTypes.Invitation]()
            for structure0 in invitationsContainer {
                if let structure0 = structure0 {
                    invitationsDecoded0?.append(structure0)
                }
            }
        }
        invitations = invitationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMembersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let onlyAssociated = onlyAssociated {
            let onlyAssociatedQueryItem = ClientRuntime.URLQueryItem(name: "onlyAssociated".urlPercentEncoding(), value: Swift.String(onlyAssociated).urlPercentEncoding())
            items.append(onlyAssociatedQueryItem)
        }
        return items
    }
}

extension ListMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member"
    }
}

public struct ListMembersInput: Swift.Equatable {
    /// The unique ID of the detector the member is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 50. The maximum value is 50.
    public var maxResults: Swift.Int
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?
    /// Specifies whether to only return associated members or to return all members (including members who haven't been invited yet or have been disassociated).
    public var onlyAssociated: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        onlyAssociated: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.onlyAssociated = onlyAssociated
    }
}

struct ListMembersInputBody: Swift.Equatable {
}

extension ListMembersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMembersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

public struct ListMembersOutputResponse: Swift.Equatable {
    /// A list of members.
    public var members: [GuardDutyClientTypes.Member]?
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?

    public init (
        members: [GuardDutyClientTypes.Member]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListMembersOutputResponseBody: Swift.Equatable {
    let members: [GuardDutyClientTypes.Member]?
    let nextToken: Swift.String?
}

extension ListMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members = "members"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Member?].self, forKey: .members)
        var membersDecoded0:[GuardDutyClientTypes.Member]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [GuardDutyClientTypes.Member]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOrganizationAdminAccountsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListOrganizationAdminAccountsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/admin"
    }
}

public struct ListOrganizationAdminAccountsInput: Swift.Equatable {
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOrganizationAdminAccountsInputBody: Swift.Equatable {
}

extension ListOrganizationAdminAccountsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListOrganizationAdminAccountsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOrganizationAdminAccountsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOrganizationAdminAccountsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOrganizationAdminAccountsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOrganizationAdminAccountsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.adminAccounts = output.adminAccounts
            self.nextToken = output.nextToken
        } else {
            self.adminAccounts = nil
            self.nextToken = nil
        }
    }
}

public struct ListOrganizationAdminAccountsOutputResponse: Swift.Equatable {
    /// A list of accounts configured as GuardDuty delegated administrators.
    public var adminAccounts: [GuardDutyClientTypes.AdminAccount]?
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?

    public init (
        adminAccounts: [GuardDutyClientTypes.AdminAccount]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.adminAccounts = adminAccounts
        self.nextToken = nextToken
    }
}

struct ListOrganizationAdminAccountsOutputResponseBody: Swift.Equatable {
    let adminAccounts: [GuardDutyClientTypes.AdminAccount]?
    let nextToken: Swift.String?
}

extension ListOrganizationAdminAccountsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccounts = "adminAccounts"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.AdminAccount?].self, forKey: .adminAccounts)
        var adminAccountsDecoded0:[GuardDutyClientTypes.AdminAccount]? = nil
        if let adminAccountsContainer = adminAccountsContainer {
            adminAccountsDecoded0 = [GuardDutyClientTypes.AdminAccount]()
            for structure0 in adminAccountsContainer {
                if let structure0 = structure0 {
                    adminAccountsDecoded0?.append(structure0)
                }
            }
        }
        adminAccounts = adminAccountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPublishingDestinationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListPublishingDestinationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/publishingDestination"
    }
}

public struct ListPublishingDestinationsInput: Swift.Equatable {
    /// The ID of the detector to retrieve publishing destinations for.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPublishingDestinationsInputBody: Swift.Equatable {
}

extension ListPublishingDestinationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPublishingDestinationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPublishingDestinationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPublishingDestinationsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPublishingDestinationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPublishingDestinationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinations = output.destinations
            self.nextToken = output.nextToken
        } else {
            self.destinations = nil
            self.nextToken = nil
        }
    }
}

public struct ListPublishingDestinationsOutputResponse: Swift.Equatable {
    /// A Destinations object that includes information about each publishing destination returned.
    /// This member is required.
    public var destinations: [GuardDutyClientTypes.Destination]?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init (
        destinations: [GuardDutyClientTypes.Destination]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destinations = destinations
        self.nextToken = nextToken
    }
}

struct ListPublishingDestinationsOutputResponseBody: Swift.Equatable {
    let destinations: [GuardDutyClientTypes.Destination]?
    let nextToken: Swift.String?
}

extension ListPublishingDestinationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinations = "destinations"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Destination?].self, forKey: .destinations)
        var destinationsDecoded0:[GuardDutyClientTypes.Destination]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [GuardDutyClientTypes.Destination]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the given GuardDuty resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListThreatIntelSetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListThreatIntelSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/threatintelset"
    }
}

public struct ListThreatIntelSetsInput: Swift.Equatable {
    /// The unique ID of the detector that the threatIntelSet is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 50. The maximum value is 50.
    public var maxResults: Swift.Int
    /// You can use this parameter to paginate results in the response. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListThreatIntelSetsInputBody: Swift.Equatable {
}

extension ListThreatIntelSetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListThreatIntelSetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThreatIntelSetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListThreatIntelSetsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThreatIntelSetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListThreatIntelSetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.threatIntelSetIds = output.threatIntelSetIds
        } else {
            self.nextToken = nil
            self.threatIntelSetIds = nil
        }
    }
}

public struct ListThreatIntelSetsOutputResponse: Swift.Equatable {
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?
    /// The IDs of the ThreatIntelSet resources.
    /// This member is required.
    public var threatIntelSetIds: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        threatIntelSetIds: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.threatIntelSetIds = threatIntelSetIds
    }
}

struct ListThreatIntelSetsOutputResponseBody: Swift.Equatable {
    let threatIntelSetIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListThreatIntelSetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case threatIntelSetIds = "threatIntelSetIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let threatIntelSetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .threatIntelSetIds)
        var threatIntelSetIdsDecoded0:[Swift.String]? = nil
        if let threatIntelSetIdsContainer = threatIntelSetIdsContainer {
            threatIntelSetIdsDecoded0 = [Swift.String]()
            for string0 in threatIntelSetIdsContainer {
                if let string0 = string0 {
                    threatIntelSetIdsDecoded0?.append(string0)
                }
            }
        }
        threatIntelSetIds = threatIntelSetIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GuardDutyClientTypes.LocalIpDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddressV4 = "ipAddressV4"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddressV4 = ipAddressV4 {
            try encodeContainer.encode(ipAddressV4, forKey: .ipAddressV4)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressV4Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddressV4)
        ipAddressV4 = ipAddressV4Decoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the local IP address of the connection.
    public struct LocalIpDetails: Swift.Equatable {
        /// The IPv4 local address of the connection.
        public var ipAddressV4: Swift.String?

        public init (
            ipAddressV4: Swift.String? = nil
        )
        {
            self.ipAddressV4 = ipAddressV4
        }
    }

}

extension GuardDutyClientTypes.LocalPortDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case port = "port"
        case portName = "portName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let portName = portName {
            try encodeContainer.encode(portName, forKey: .portName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let portNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portName)
        portName = portNameDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the port for the local connection.
    public struct LocalPortDetails: Swift.Equatable {
        /// The port number of the local connection.
        public var port: Swift.Int
        /// The port name of the local connection.
        public var portName: Swift.String?

        public init (
            port: Swift.Int = 0,
            portName: Swift.String? = nil
        )
        {
            self.port = port
            self.portName = portName
        }
    }

}

extension GuardDutyClientTypes.Master: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case invitationId = "invitationId"
        case invitedAt = "invitedAt"
        case relationshipStatus = "relationshipStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let invitationId = invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
        if let invitedAt = invitedAt {
            try encodeContainer.encode(invitedAt, forKey: .invitedAt)
        }
        if let relationshipStatus = relationshipStatus {
            try encodeContainer.encode(relationshipStatus, forKey: .relationshipStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
        let relationshipStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relationshipStatus)
        relationshipStatus = relationshipStatusDecoded
        let invitedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitedAt)
        invitedAt = invitedAtDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the administrator account and invitation.
    public struct Master: Swift.Equatable {
        /// The ID of the account used as the administrator account.
        public var accountId: Swift.String?
        /// The value used to validate the administrator account to the member account.
        public var invitationId: Swift.String?
        /// The timestamp when the invitation was sent.
        public var invitedAt: Swift.String?
        /// The status of the relationship between the administrator and member accounts.
        public var relationshipStatus: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            invitationId: Swift.String? = nil,
            invitedAt: Swift.String? = nil,
            relationshipStatus: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.invitationId = invitationId
            self.invitedAt = invitedAt
            self.relationshipStatus = relationshipStatus
        }
    }

}

extension GuardDutyClientTypes.Member: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case detectorId = "detectorId"
        case email = "email"
        case invitedAt = "invitedAt"
        case masterId = "masterId"
        case relationshipStatus = "relationshipStatus"
        case updatedAt = "updatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let invitedAt = invitedAt {
            try encodeContainer.encode(invitedAt, forKey: .invitedAt)
        }
        if let masterId = masterId {
            try encodeContainer.encode(masterId, forKey: .masterId)
        }
        if let relationshipStatus = relationshipStatus {
            try encodeContainer.encode(relationshipStatus, forKey: .relationshipStatus)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let masterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterId)
        masterId = masterIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let relationshipStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relationshipStatus)
        relationshipStatus = relationshipStatusDecoded
        let invitedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitedAt)
        invitedAt = invitedAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the member account.
    public struct Member: Swift.Equatable {
        /// The ID of the member account.
        /// This member is required.
        public var accountId: Swift.String?
        /// The detector ID of the member account.
        public var detectorId: Swift.String?
        /// The email address of the member account.
        /// This member is required.
        public var email: Swift.String?
        /// The timestamp when the invitation was sent.
        public var invitedAt: Swift.String?
        /// The administrator account ID.
        /// This member is required.
        public var masterId: Swift.String?
        /// The status of the relationship between the member and the administrator.
        /// This member is required.
        public var relationshipStatus: Swift.String?
        /// The last-updated timestamp of the member.
        /// This member is required.
        public var updatedAt: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            detectorId: Swift.String? = nil,
            email: Swift.String? = nil,
            invitedAt: Swift.String? = nil,
            masterId: Swift.String? = nil,
            relationshipStatus: Swift.String? = nil,
            updatedAt: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.detectorId = detectorId
            self.email = email
            self.invitedAt = invitedAt
            self.masterId = masterId
            self.relationshipStatus = relationshipStatus
            self.updatedAt = updatedAt
        }
    }

}

extension GuardDutyClientTypes.MemberDataSourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case dataSources = "dataSources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let dataSources = dataSources {
            try encodeContainer.encode(dataSources, forKey: .dataSources)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceConfigurationsResult.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on which data sources are enabled for a member account.
    public struct MemberDataSourceConfiguration: Swift.Equatable {
        /// The account ID for the member account.
        /// This member is required.
        public var accountId: Swift.String?
        /// Contains information on the status of data sources for the account.
        /// This member is required.
        public var dataSources: GuardDutyClientTypes.DataSourceConfigurationsResult?

        public init (
            accountId: Swift.String? = nil,
            dataSources: GuardDutyClientTypes.DataSourceConfigurationsResult? = nil
        )
        {
            self.accountId = accountId
            self.dataSources = dataSources
        }
    }

}

extension GuardDutyClientTypes.NetworkConnectionAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blocked = "blocked"
        case connectionDirection = "connectionDirection"
        case localIpDetails = "localIpDetails"
        case localPortDetails = "localPortDetails"
        case `protocol` = "protocol"
        case remoteIpDetails = "remoteIpDetails"
        case remotePortDetails = "remotePortDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blocked != false {
            try encodeContainer.encode(blocked, forKey: .blocked)
        }
        if let connectionDirection = connectionDirection {
            try encodeContainer.encode(connectionDirection, forKey: .connectionDirection)
        }
        if let localIpDetails = localIpDetails {
            try encodeContainer.encode(localIpDetails, forKey: .localIpDetails)
        }
        if let localPortDetails = localPortDetails {
            try encodeContainer.encode(localPortDetails, forKey: .localPortDetails)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
        if let remoteIpDetails = remoteIpDetails {
            try encodeContainer.encode(remoteIpDetails, forKey: .remoteIpDetails)
        }
        if let remotePortDetails = remotePortDetails {
            try encodeContainer.encode(remotePortDetails, forKey: .remotePortDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .blocked)
        blocked = blockedDecoded
        let connectionDirectionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionDirection)
        connectionDirection = connectionDirectionDecoded
        let localPortDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.LocalPortDetails.self, forKey: .localPortDetails)
        localPortDetails = localPortDetailsDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let localIpDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.LocalIpDetails.self, forKey: .localIpDetails)
        localIpDetails = localIpDetailsDecoded
        let remoteIpDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.RemoteIpDetails.self, forKey: .remoteIpDetails)
        remoteIpDetails = remoteIpDetailsDecoded
        let remotePortDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.RemotePortDetails.self, forKey: .remotePortDetails)
        remotePortDetails = remotePortDetailsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the NETWORK_CONNECTION action described in the finding.
    public struct NetworkConnectionAction: Swift.Equatable {
        /// Indicates whether EC2 blocked the network connection to your instance.
        public var blocked: Swift.Bool
        /// The network connection direction.
        public var connectionDirection: Swift.String?
        /// The local IP information of the connection.
        public var localIpDetails: GuardDutyClientTypes.LocalIpDetails?
        /// The local port information of the connection.
        public var localPortDetails: GuardDutyClientTypes.LocalPortDetails?
        /// The network connection protocol.
        public var `protocol`: Swift.String?
        /// The remote IP information of the connection.
        public var remoteIpDetails: GuardDutyClientTypes.RemoteIpDetails?
        /// The remote port information of the connection.
        public var remotePortDetails: GuardDutyClientTypes.RemotePortDetails?

        public init (
            blocked: Swift.Bool = false,
            connectionDirection: Swift.String? = nil,
            localIpDetails: GuardDutyClientTypes.LocalIpDetails? = nil,
            localPortDetails: GuardDutyClientTypes.LocalPortDetails? = nil,
            `protocol`: Swift.String? = nil,
            remoteIpDetails: GuardDutyClientTypes.RemoteIpDetails? = nil,
            remotePortDetails: GuardDutyClientTypes.RemotePortDetails? = nil
        )
        {
            self.blocked = blocked
            self.connectionDirection = connectionDirection
            self.localIpDetails = localIpDetails
            self.localPortDetails = localPortDetails
            self.`protocol` = `protocol`
            self.remoteIpDetails = remoteIpDetails
            self.remotePortDetails = remotePortDetails
        }
    }

}

extension GuardDutyClientTypes.NetworkInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipv6Addresses = "ipv6Addresses"
        case networkInterfaceId = "networkInterfaceId"
        case privateDnsName = "privateDnsName"
        case privateIpAddress = "privateIpAddress"
        case privateIpAddresses = "privateIpAddresses"
        case publicDnsName = "publicDnsName"
        case publicIp = "publicIp"
        case securityGroups = "securityGroups"
        case subnetId = "subnetId"
        case vpcId = "vpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipv6Addresses = ipv6Addresses {
            var ipv6AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipv6Addresses)
            for ipv6addresses0 in ipv6Addresses {
                try ipv6AddressesContainer.encode(ipv6addresses0)
            }
        }
        if let networkInterfaceId = networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let privateDnsName = privateDnsName {
            try encodeContainer.encode(privateDnsName, forKey: .privateDnsName)
        }
        if let privateIpAddress = privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
        if let privateIpAddresses = privateIpAddresses {
            var privateIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .privateIpAddresses)
            for privateipaddresses0 in privateIpAddresses {
                try privateIpAddressesContainer.encode(privateipaddresses0)
            }
        }
        if let publicDnsName = publicDnsName {
            try encodeContainer.encode(publicDnsName, forKey: .publicDnsName)
        }
        if let publicIp = publicIp {
            try encodeContainer.encode(publicIp, forKey: .publicIp)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroups0 in securityGroups {
                try securityGroupsContainer.encode(securitygroups0)
            }
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipv6AddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipv6Addresses)
        var ipv6AddressesDecoded0:[Swift.String]? = nil
        if let ipv6AddressesContainer = ipv6AddressesContainer {
            ipv6AddressesDecoded0 = [Swift.String]()
            for string0 in ipv6AddressesContainer {
                if let string0 = string0 {
                    ipv6AddressesDecoded0?.append(string0)
                }
            }
        }
        ipv6Addresses = ipv6AddressesDecoded0
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let privateDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateDnsName)
        privateDnsName = privateDnsNameDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        let privateIpAddressesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.PrivateIpAddressDetails?].self, forKey: .privateIpAddresses)
        var privateIpAddressesDecoded0:[GuardDutyClientTypes.PrivateIpAddressDetails]? = nil
        if let privateIpAddressesContainer = privateIpAddressesContainer {
            privateIpAddressesDecoded0 = [GuardDutyClientTypes.PrivateIpAddressDetails]()
            for structure0 in privateIpAddressesContainer {
                if let structure0 = structure0 {
                    privateIpAddressesDecoded0?.append(structure0)
                }
            }
        }
        privateIpAddresses = privateIpAddressesDecoded0
        let publicDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicDnsName)
        publicDnsName = publicDnsNameDecoded
        let publicIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicIp)
        publicIp = publicIpDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.SecurityGroup?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[GuardDutyClientTypes.SecurityGroup]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [GuardDutyClientTypes.SecurityGroup]()
            for structure0 in securityGroupsContainer {
                if let structure0 = structure0 {
                    securityGroupsDecoded0?.append(structure0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the elastic network interface of the EC2 instance.
    public struct NetworkInterface: Swift.Equatable {
        /// A list of IPv6 addresses for the EC2 instance.
        public var ipv6Addresses: [Swift.String]?
        /// The ID of the network interface.
        public var networkInterfaceId: Swift.String?
        /// The private DNS name of the EC2 instance.
        public var privateDnsName: Swift.String?
        /// The private IP address of the EC2 instance.
        public var privateIpAddress: Swift.String?
        /// Other private IP address information of the EC2 instance.
        public var privateIpAddresses: [GuardDutyClientTypes.PrivateIpAddressDetails]?
        /// The public DNS name of the EC2 instance.
        public var publicDnsName: Swift.String?
        /// The public IP address of the EC2 instance.
        public var publicIp: Swift.String?
        /// The security groups associated with the EC2 instance.
        public var securityGroups: [GuardDutyClientTypes.SecurityGroup]?
        /// The subnet ID of the EC2 instance.
        public var subnetId: Swift.String?
        /// The VPC ID of the EC2 instance.
        public var vpcId: Swift.String?

        public init (
            ipv6Addresses: [Swift.String]? = nil,
            networkInterfaceId: Swift.String? = nil,
            privateDnsName: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil,
            privateIpAddresses: [GuardDutyClientTypes.PrivateIpAddressDetails]? = nil,
            publicDnsName: Swift.String? = nil,
            publicIp: Swift.String? = nil,
            securityGroups: [GuardDutyClientTypes.SecurityGroup]? = nil,
            subnetId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.ipv6Addresses = ipv6Addresses
            self.networkInterfaceId = networkInterfaceId
            self.privateDnsName = privateDnsName
            self.privateIpAddress = privateIpAddress
            self.privateIpAddresses = privateIpAddresses
            self.publicDnsName = publicDnsName
            self.publicIp = publicIp
            self.securityGroups = securityGroups
            self.subnetId = subnetId
            self.vpcId = vpcId
        }
    }

}

extension GuardDutyClientTypes {
    public enum OrderBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderBy] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderBy(rawValue: rawValue) ?? OrderBy.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.Organization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asn = "asn"
        case asnOrg = "asnOrg"
        case isp = "isp"
        case org = "org"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let asn = asn {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let asnOrg = asnOrg {
            try encodeContainer.encode(asnOrg, forKey: .asnOrg)
        }
        if let isp = isp {
            try encodeContainer.encode(isp, forKey: .isp)
        }
        if let org = org {
            try encodeContainer.encode(org, forKey: .org)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let asnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .asn)
        asn = asnDecoded
        let asnOrgDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .asnOrg)
        asnOrg = asnOrgDecoded
        let ispDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isp)
        isp = ispDecoded
        let orgDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .org)
        org = orgDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the ISP organization of the remote IP address.
    public struct Organization: Swift.Equatable {
        /// The Autonomous System Number (ASN) of the internet provider of the remote IP address.
        public var asn: Swift.String?
        /// The organization that registered this ASN.
        public var asnOrg: Swift.String?
        /// The ISP information for the internet provider.
        public var isp: Swift.String?
        /// The name of the internet provider.
        public var org: Swift.String?

        public init (
            asn: Swift.String? = nil,
            asnOrg: Swift.String? = nil,
            isp: Swift.String? = nil,
            org: Swift.String? = nil
        )
        {
            self.asn = asn
            self.asnOrg = asnOrg
            self.isp = isp
            self.org = org
        }
    }

}

extension GuardDutyClientTypes.OrganizationDataSourceConfigurations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Logs = "s3Logs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Logs = s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationS3LogsConfiguration.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
    }
}

extension GuardDutyClientTypes {
    /// An object that contains information on which data sources will be configured to be automatically enabled for new members within the organization.
    public struct OrganizationDataSourceConfigurations: Swift.Equatable {
        /// Describes whether S3 data event logs are enabled for new members of the organization.
        public var s3Logs: GuardDutyClientTypes.OrganizationS3LogsConfiguration?

        public init (
            s3Logs: GuardDutyClientTypes.OrganizationS3LogsConfiguration? = nil
        )
        {
            self.s3Logs = s3Logs
        }
    }

}

extension GuardDutyClientTypes.OrganizationDataSourceConfigurationsResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Logs = "s3Logs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Logs = s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationS3LogsConfigurationResult.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
    }
}

extension GuardDutyClientTypes {
    /// An object that contains information on which data sources are automatically enabled for new members within the organization.
    public struct OrganizationDataSourceConfigurationsResult: Swift.Equatable {
        /// Describes whether S3 data event logs are enabled as a data source.
        /// This member is required.
        public var s3Logs: GuardDutyClientTypes.OrganizationS3LogsConfigurationResult?

        public init (
            s3Logs: GuardDutyClientTypes.OrganizationS3LogsConfigurationResult? = nil
        )
        {
            self.s3Logs = s3Logs
        }
    }

}

extension GuardDutyClientTypes.OrganizationS3LogsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoEnable != false {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes whether S3 data event logs will be automatically enabled for new members of the organization.
    public struct OrganizationS3LogsConfiguration: Swift.Equatable {
        /// A value that contains information on whether S3 data event logs will be enabled automatically as a data source for the organization.
        /// This member is required.
        public var autoEnable: Swift.Bool

        public init (
            autoEnable: Swift.Bool = false
        )
        {
            self.autoEnable = autoEnable
        }
    }

}

extension GuardDutyClientTypes.OrganizationS3LogsConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoEnable != false {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
    }
}

extension GuardDutyClientTypes {
    /// The current configuration of S3 data event logs as a data source for the organization.
    public struct OrganizationS3LogsConfigurationResult: Swift.Equatable {
        /// A value that describes whether S3 data event logs are automatically enabled for new members of the organization.
        /// This member is required.
        public var autoEnable: Swift.Bool

        public init (
            autoEnable: Swift.Bool = false
        )
        {
            self.autoEnable = autoEnable
        }
    }

}

extension GuardDutyClientTypes.Owner: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the owner of the bucket.
    public struct Owner: Swift.Equatable {
        /// The canonical user ID of the bucket owner. For information about locating your canonical user ID see [Finding Your Account Canonical User ID.](https://docs.aws.amazon.com/general/latest/gr/acct-identifiers.html#FindingCanonicalId)
        public var id: Swift.String?

        public init (
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension GuardDutyClientTypes.PermissionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountLevelPermissions = "accountLevelPermissions"
        case bucketLevelPermissions = "bucketLevelPermissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountLevelPermissions = accountLevelPermissions {
            try encodeContainer.encode(accountLevelPermissions, forKey: .accountLevelPermissions)
        }
        if let bucketLevelPermissions = bucketLevelPermissions {
            try encodeContainer.encode(bucketLevelPermissions, forKey: .bucketLevelPermissions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketLevelPermissionsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.BucketLevelPermissions.self, forKey: .bucketLevelPermissions)
        bucketLevelPermissions = bucketLevelPermissionsDecoded
        let accountLevelPermissionsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.AccountLevelPermissions.self, forKey: .accountLevelPermissions)
        accountLevelPermissions = accountLevelPermissionsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about how permissions are configured for the S3 bucket.
    public struct PermissionConfiguration: Swift.Equatable {
        /// Contains information about the account level permissions on the S3 bucket.
        public var accountLevelPermissions: GuardDutyClientTypes.AccountLevelPermissions?
        /// Contains information about the bucket level permissions for the S3 bucket.
        public var bucketLevelPermissions: GuardDutyClientTypes.BucketLevelPermissions?

        public init (
            accountLevelPermissions: GuardDutyClientTypes.AccountLevelPermissions? = nil,
            bucketLevelPermissions: GuardDutyClientTypes.BucketLevelPermissions? = nil
        )
        {
            self.accountLevelPermissions = accountLevelPermissions
            self.bucketLevelPermissions = bucketLevelPermissions
        }
    }

}

extension GuardDutyClientTypes.PortProbeAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blocked = "blocked"
        case portProbeDetails = "portProbeDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blocked != false {
            try encodeContainer.encode(blocked, forKey: .blocked)
        }
        if let portProbeDetails = portProbeDetails {
            var portProbeDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portProbeDetails)
            for portprobedetails0 in portProbeDetails {
                try portProbeDetailsContainer.encode(portprobedetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .blocked)
        blocked = blockedDecoded
        let portProbeDetailsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.PortProbeDetail?].self, forKey: .portProbeDetails)
        var portProbeDetailsDecoded0:[GuardDutyClientTypes.PortProbeDetail]? = nil
        if let portProbeDetailsContainer = portProbeDetailsContainer {
            portProbeDetailsDecoded0 = [GuardDutyClientTypes.PortProbeDetail]()
            for structure0 in portProbeDetailsContainer {
                if let structure0 = structure0 {
                    portProbeDetailsDecoded0?.append(structure0)
                }
            }
        }
        portProbeDetails = portProbeDetailsDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the PORT_PROBE action described in the finding.
    public struct PortProbeAction: Swift.Equatable {
        /// Indicates whether EC2 blocked the port probe to the instance, such as with an ACL.
        public var blocked: Swift.Bool
        /// A list of objects related to port probe details.
        public var portProbeDetails: [GuardDutyClientTypes.PortProbeDetail]?

        public init (
            blocked: Swift.Bool = false,
            portProbeDetails: [GuardDutyClientTypes.PortProbeDetail]? = nil
        )
        {
            self.blocked = blocked
            self.portProbeDetails = portProbeDetails
        }
    }

}

extension GuardDutyClientTypes.PortProbeDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case localIpDetails = "localIpDetails"
        case localPortDetails = "localPortDetails"
        case remoteIpDetails = "remoteIpDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let localIpDetails = localIpDetails {
            try encodeContainer.encode(localIpDetails, forKey: .localIpDetails)
        }
        if let localPortDetails = localPortDetails {
            try encodeContainer.encode(localPortDetails, forKey: .localPortDetails)
        }
        if let remoteIpDetails = remoteIpDetails {
            try encodeContainer.encode(remoteIpDetails, forKey: .remoteIpDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localPortDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.LocalPortDetails.self, forKey: .localPortDetails)
        localPortDetails = localPortDetailsDecoded
        let localIpDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.LocalIpDetails.self, forKey: .localIpDetails)
        localIpDetails = localIpDetailsDecoded
        let remoteIpDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.RemoteIpDetails.self, forKey: .remoteIpDetails)
        remoteIpDetails = remoteIpDetailsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the port probe details.
    public struct PortProbeDetail: Swift.Equatable {
        /// The local IP information of the connection.
        public var localIpDetails: GuardDutyClientTypes.LocalIpDetails?
        /// The local port information of the connection.
        public var localPortDetails: GuardDutyClientTypes.LocalPortDetails?
        /// The remote IP information of the connection.
        public var remoteIpDetails: GuardDutyClientTypes.RemoteIpDetails?

        public init (
            localIpDetails: GuardDutyClientTypes.LocalIpDetails? = nil,
            localPortDetails: GuardDutyClientTypes.LocalPortDetails? = nil,
            remoteIpDetails: GuardDutyClientTypes.RemoteIpDetails? = nil
        )
        {
            self.localIpDetails = localIpDetails
            self.localPortDetails = localPortDetails
            self.remoteIpDetails = remoteIpDetails
        }
    }

}

extension GuardDutyClientTypes.PrivateIpAddressDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case privateDnsName = "privateDnsName"
        case privateIpAddress = "privateIpAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let privateDnsName = privateDnsName {
            try encodeContainer.encode(privateDnsName, forKey: .privateDnsName)
        }
        if let privateIpAddress = privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let privateDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateDnsName)
        privateDnsName = privateDnsNameDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains other private IP address information of the EC2 instance.
    public struct PrivateIpAddressDetails: Swift.Equatable {
        /// The private DNS name of the EC2 instance.
        public var privateDnsName: Swift.String?
        /// The private IP address of the EC2 instance.
        public var privateIpAddress: Swift.String?

        public init (
            privateDnsName: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil
        )
        {
            self.privateDnsName = privateDnsName
            self.privateIpAddress = privateIpAddress
        }
    }

}

extension GuardDutyClientTypes.ProductCode: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "code"
        case productType = "productType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let productType = productType {
            try encodeContainer.encode(productType, forKey: .productType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productType)
        productType = productTypeDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the product code for the EC2 instance.
    public struct ProductCode: Swift.Equatable {
        /// The product code information.
        public var code: Swift.String?
        /// The product code type.
        public var productType: Swift.String?

        public init (
            code: Swift.String? = nil,
            productType: Swift.String? = nil
        )
        {
            self.code = code
            self.productType = productType
        }
    }

}

extension GuardDutyClientTypes.PublicAccess: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effectivePermission = "effectivePermission"
        case permissionConfiguration = "permissionConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let effectivePermission = effectivePermission {
            try encodeContainer.encode(effectivePermission, forKey: .effectivePermission)
        }
        if let permissionConfiguration = permissionConfiguration {
            try encodeContainer.encode(permissionConfiguration, forKey: .permissionConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionConfigurationDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.PermissionConfiguration.self, forKey: .permissionConfiguration)
        permissionConfiguration = permissionConfigurationDecoded
        let effectivePermissionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectivePermission)
        effectivePermission = effectivePermissionDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes the public access policies that apply to the S3 bucket.
    public struct PublicAccess: Swift.Equatable {
        /// Describes the effective permission on this bucket after factoring all attached policies.
        public var effectivePermission: Swift.String?
        /// Contains information about how permissions are configured for the S3 bucket.
        public var permissionConfiguration: GuardDutyClientTypes.PermissionConfiguration?

        public init (
            effectivePermission: Swift.String? = nil,
            permissionConfiguration: GuardDutyClientTypes.PermissionConfiguration? = nil
        )
        {
            self.effectivePermission = effectivePermission
            self.permissionConfiguration = permissionConfiguration
        }
    }

}

extension GuardDutyClientTypes {
    public enum PublishingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pendingVerification
        case publishing
        case stopped
        case unableToPublishFixDestinationProperty
        case sdkUnknown(Swift.String)

        public static var allCases: [PublishingStatus] {
            return [
                .pendingVerification,
                .publishing,
                .stopped,
                .unableToPublishFixDestinationProperty,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pendingVerification: return "PENDING_VERIFICATION"
            case .publishing: return "PUBLISHING"
            case .stopped: return "STOPPED"
            case .unableToPublishFixDestinationProperty: return "UNABLE_TO_PUBLISH_FIX_DESTINATION_PROPERTY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PublishingStatus(rawValue: rawValue) ?? PublishingStatus.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.RemoteIpDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case city = "city"
        case country = "country"
        case geoLocation = "geoLocation"
        case ipAddressV4 = "ipAddressV4"
        case organization = "organization"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let city = city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let country = country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let geoLocation = geoLocation {
            try encodeContainer.encode(geoLocation, forKey: .geoLocation)
        }
        if let ipAddressV4 = ipAddressV4 {
            try encodeContainer.encode(ipAddressV4, forKey: .ipAddressV4)
        }
        if let organization = organization {
            try encodeContainer.encode(organization, forKey: .organization)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cityDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.City.self, forKey: .city)
        city = cityDecoded
        let countryDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Country.self, forKey: .country)
        country = countryDecoded
        let geoLocationDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.GeoLocation.self, forKey: .geoLocation)
        geoLocation = geoLocationDecoded
        let ipAddressV4Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddressV4)
        ipAddressV4 = ipAddressV4Decoded
        let organizationDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Organization.self, forKey: .organization)
        organization = organizationDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the remote IP address of the connection.
    public struct RemoteIpDetails: Swift.Equatable {
        /// The city information of the remote IP address.
        public var city: GuardDutyClientTypes.City?
        /// The country code of the remote IP address.
        public var country: GuardDutyClientTypes.Country?
        /// The location information of the remote IP address.
        public var geoLocation: GuardDutyClientTypes.GeoLocation?
        /// The IPv4 remote address of the connection.
        public var ipAddressV4: Swift.String?
        /// The ISP organization information of the remote IP address.
        public var organization: GuardDutyClientTypes.Organization?

        public init (
            city: GuardDutyClientTypes.City? = nil,
            country: GuardDutyClientTypes.Country? = nil,
            geoLocation: GuardDutyClientTypes.GeoLocation? = nil,
            ipAddressV4: Swift.String? = nil,
            organization: GuardDutyClientTypes.Organization? = nil
        )
        {
            self.city = city
            self.country = country
            self.geoLocation = geoLocation
            self.ipAddressV4 = ipAddressV4
            self.organization = organization
        }
    }

}

extension GuardDutyClientTypes.RemotePortDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case port = "port"
        case portName = "portName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let portName = portName {
            try encodeContainer.encode(portName, forKey: .portName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let portNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portName)
        portName = portNameDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the remote port.
    public struct RemotePortDetails: Swift.Equatable {
        /// The port number of the remote connection.
        public var port: Swift.Int
        /// The port name of the remote connection.
        public var portName: Swift.String?

        public init (
            port: Swift.Int = 0,
            portName: Swift.String? = nil
        )
        {
            self.port = port
            self.portName = portName
        }
    }

}

extension GuardDutyClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyDetails = "accessKeyDetails"
        case instanceDetails = "instanceDetails"
        case resourceType = "resourceType"
        case s3BucketDetails = "s3BucketDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyDetails = accessKeyDetails {
            try encodeContainer.encode(accessKeyDetails, forKey: .accessKeyDetails)
        }
        if let instanceDetails = instanceDetails {
            try encodeContainer.encode(instanceDetails, forKey: .instanceDetails)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let s3BucketDetails = s3BucketDetails {
            var s3BucketDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3BucketDetails)
            for s3bucketdetails0 in s3BucketDetails {
                try s3BucketDetailsContainer.encode(s3bucketdetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.AccessKeyDetails.self, forKey: .accessKeyDetails)
        accessKeyDetails = accessKeyDetailsDecoded
        let s3BucketDetailsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.S3BucketDetail?].self, forKey: .s3BucketDetails)
        var s3BucketDetailsDecoded0:[GuardDutyClientTypes.S3BucketDetail]? = nil
        if let s3BucketDetailsContainer = s3BucketDetailsContainer {
            s3BucketDetailsDecoded0 = [GuardDutyClientTypes.S3BucketDetail]()
            for structure0 in s3BucketDetailsContainer {
                if let structure0 = structure0 {
                    s3BucketDetailsDecoded0?.append(structure0)
                }
            }
        }
        s3BucketDetails = s3BucketDetailsDecoded0
        let instanceDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.InstanceDetails.self, forKey: .instanceDetails)
        instanceDetails = instanceDetailsDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the AWS resource associated with the activity that prompted GuardDuty to generate a finding.
    public struct Resource: Swift.Equatable {
        /// The IAM access key details (IAM user information) of a user that engaged in the activity that prompted GuardDuty to generate a finding.
        public var accessKeyDetails: GuardDutyClientTypes.AccessKeyDetails?
        /// The information about the EC2 instance associated with the activity that prompted GuardDuty to generate a finding.
        public var instanceDetails: GuardDutyClientTypes.InstanceDetails?
        /// The type of AWS resource.
        public var resourceType: Swift.String?
        /// Contains information on the S3 bucket.
        public var s3BucketDetails: [GuardDutyClientTypes.S3BucketDetail]?

        public init (
            accessKeyDetails: GuardDutyClientTypes.AccessKeyDetails? = nil,
            instanceDetails: GuardDutyClientTypes.InstanceDetails? = nil,
            resourceType: Swift.String? = nil,
            s3BucketDetails: [GuardDutyClientTypes.S3BucketDetail]? = nil
        )
        {
            self.accessKeyDetails = accessKeyDetails
            self.instanceDetails = instanceDetails
            self.resourceType = resourceType
            self.s3BucketDetails = s3BucketDetails
        }
    }

}

extension GuardDutyClientTypes.S3BucketDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case defaultServerSideEncryption = "defaultServerSideEncryption"
        case name = "name"
        case owner = "owner"
        case publicAccess = "publicAccess"
        case tags = "tags"
        case type = "type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let defaultServerSideEncryption = defaultServerSideEncryption {
            try encodeContainer.encode(defaultServerSideEncryption, forKey: .defaultServerSideEncryption)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let publicAccess = publicAccess {
            try encodeContainer.encode(publicAccess, forKey: .publicAccess)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Owner.self, forKey: .owner)
        owner = ownerDecoded
        let tagsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GuardDutyClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GuardDutyClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let defaultServerSideEncryptionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DefaultServerSideEncryption.self, forKey: .defaultServerSideEncryption)
        defaultServerSideEncryption = defaultServerSideEncryptionDecoded
        let publicAccessDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.PublicAccess.self, forKey: .publicAccess)
        publicAccess = publicAccessDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the S3 bucket.
    public struct S3BucketDetail: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the S3 bucket.
        public var arn: Swift.String?
        /// The date and time the bucket was created at.
        public var createdAt: ClientRuntime.Date?
        /// Describes the server side encryption method used in the S3 bucket.
        public var defaultServerSideEncryption: GuardDutyClientTypes.DefaultServerSideEncryption?
        /// The name of the S3 bucket.
        public var name: Swift.String?
        /// The owner of the S3 bucket.
        public var owner: GuardDutyClientTypes.Owner?
        /// Describes the public access policies that apply to the S3 bucket.
        public var publicAccess: GuardDutyClientTypes.PublicAccess?
        /// All tags attached to the S3 bucket
        public var tags: [GuardDutyClientTypes.Tag]?
        /// Describes whether the bucket is a source or destination bucket.
        public var type: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            defaultServerSideEncryption: GuardDutyClientTypes.DefaultServerSideEncryption? = nil,
            name: Swift.String? = nil,
            owner: GuardDutyClientTypes.Owner? = nil,
            publicAccess: GuardDutyClientTypes.PublicAccess? = nil,
            tags: [GuardDutyClientTypes.Tag]? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.defaultServerSideEncryption = defaultServerSideEncryption
            self.name = name
            self.owner = owner
            self.publicAccess = publicAccess
            self.tags = tags
            self.type = type
        }
    }

}

extension GuardDutyClientTypes.S3LogsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enable = "enable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enable != false {
            try encodeContainer.encode(enable, forKey: .enable)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enable)
        enable = enableDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes whether S3 data event logs will be enabled as a data source.
    public struct S3LogsConfiguration: Swift.Equatable {
        /// The status of S3 data event logs as a data source.
        /// This member is required.
        public var enable: Swift.Bool

        public init (
            enable: Swift.Bool = false
        )
        {
            self.enable = enable
        }
    }

}

extension GuardDutyClientTypes.S3LogsConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes whether S3 data event logs will be enabled as a data source.
    public struct S3LogsConfigurationResult: Swift.Equatable {
        /// A value that describes whether S3 data event logs are automatically enabled for new members of the organization.
        /// This member is required.
        public var status: GuardDutyClientTypes.DataSourceStatus?

        public init (
            status: GuardDutyClientTypes.DataSourceStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension GuardDutyClientTypes.SecurityGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "groupId"
        case groupName = "groupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the security groups associated with the EC2 instance.
    public struct SecurityGroup: Swift.Equatable {
        /// The security group ID of the EC2 instance.
        public var groupId: Swift.String?
        /// The security group name of the EC2 instance.
        public var groupName: Swift.String?

        public init (
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil
        )
        {
            self.groupId = groupId
            self.groupName = groupName
        }
    }

}

extension GuardDutyClientTypes.Service: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "action"
        case archived = "archived"
        case count = "count"
        case detectorId = "detectorId"
        case eventFirstSeen = "eventFirstSeen"
        case eventLastSeen = "eventLastSeen"
        case evidence = "evidence"
        case resourceRole = "resourceRole"
        case serviceName = "serviceName"
        case userFeedback = "userFeedback"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if archived != false {
            try encodeContainer.encode(archived, forKey: .archived)
        }
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let eventFirstSeen = eventFirstSeen {
            try encodeContainer.encode(eventFirstSeen, forKey: .eventFirstSeen)
        }
        if let eventLastSeen = eventLastSeen {
            try encodeContainer.encode(eventLastSeen, forKey: .eventLastSeen)
        }
        if let evidence = evidence {
            try encodeContainer.encode(evidence, forKey: .evidence)
        }
        if let resourceRole = resourceRole {
            try encodeContainer.encode(resourceRole, forKey: .resourceRole)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let userFeedback = userFeedback {
            try encodeContainer.encode(userFeedback, forKey: .userFeedback)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let evidenceDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Evidence.self, forKey: .evidence)
        evidence = evidenceDecoded
        let archivedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .archived)
        archived = archivedDecoded
        let countDecoded = try containerValues.decode(Swift.Int.self, forKey: .count)
        count = countDecoded
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let eventFirstSeenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventFirstSeen)
        eventFirstSeen = eventFirstSeenDecoded
        let eventLastSeenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventLastSeen)
        eventLastSeen = eventLastSeenDecoded
        let resourceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceRole)
        resourceRole = resourceRoleDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let userFeedbackDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userFeedback)
        userFeedback = userFeedbackDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains additional information about the generated finding.
    public struct Service: Swift.Equatable {
        /// Information about the activity that is described in a finding.
        public var action: GuardDutyClientTypes.Action?
        /// Indicates whether this finding is archived.
        public var archived: Swift.Bool
        /// The total count of the occurrences of this finding type.
        public var count: Swift.Int
        /// The detector ID for the GuardDuty service.
        public var detectorId: Swift.String?
        /// The first-seen timestamp of the activity that prompted GuardDuty to generate this finding.
        public var eventFirstSeen: Swift.String?
        /// The last-seen timestamp of the activity that prompted GuardDuty to generate this finding.
        public var eventLastSeen: Swift.String?
        /// An evidence object associated with the service.
        public var evidence: GuardDutyClientTypes.Evidence?
        /// The resource role information for this finding.
        public var resourceRole: Swift.String?
        /// The name of the AWS service (GuardDuty) that generated a finding.
        public var serviceName: Swift.String?
        /// Feedback that was submitted about the finding.
        public var userFeedback: Swift.String?

        public init (
            action: GuardDutyClientTypes.Action? = nil,
            archived: Swift.Bool = false,
            count: Swift.Int = 0,
            detectorId: Swift.String? = nil,
            eventFirstSeen: Swift.String? = nil,
            eventLastSeen: Swift.String? = nil,
            evidence: GuardDutyClientTypes.Evidence? = nil,
            resourceRole: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            userFeedback: Swift.String? = nil
        )
        {
            self.action = action
            self.archived = archived
            self.count = count
            self.detectorId = detectorId
            self.eventFirstSeen = eventFirstSeen
            self.eventLastSeen = eventLastSeen
            self.evidence = evidence
            self.resourceRole = resourceRole
            self.serviceName = serviceName
            self.userFeedback = userFeedback
        }
    }

}

extension GuardDutyClientTypes.SortCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "attributeName"
        case orderBy = "orderBy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let orderBy = orderBy {
            try encodeContainer.encode(orderBy.rawValue, forKey: .orderBy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let orderByDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrderBy.self, forKey: .orderBy)
        orderBy = orderByDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the criteria used for sorting findings.
    public struct SortCriteria: Swift.Equatable {
        /// Represents the finding attribute (for example, accountId) to sort findings by.
        public var attributeName: Swift.String?
        /// The order by which the sorted findings are to be displayed.
        public var orderBy: GuardDutyClientTypes.OrderBy?

        public init (
            attributeName: Swift.String? = nil,
            orderBy: GuardDutyClientTypes.OrderBy? = nil
        )
        {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }
    }

}

extension StartMonitoringMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
    }
}

extension StartMonitoringMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member/start"
    }
}

public struct StartMonitoringMembersInput: Swift.Equatable {
    /// A list of account IDs of the GuardDuty member accounts to start monitoring.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The unique ID of the detector of the GuardDuty administrator account associated with the member accounts to monitor.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct StartMonitoringMembersInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension StartMonitoringMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension StartMonitoringMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartMonitoringMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartMonitoringMembersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartMonitoringMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartMonitoringMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct StartMonitoringMembersOutputResponse: Swift.Equatable {
    /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init (
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct StartMonitoringMembersOutputResponseBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension StartMonitoringMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension StopMonitoringMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
    }
}

extension StopMonitoringMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member/stop"
    }
}

public struct StopMonitoringMembersInput: Swift.Equatable {
    /// A list of account IDs for the member accounts to stop monitoring.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The unique ID of the detector associated with the GuardDuty administrator account that is monitoring member accounts.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct StopMonitoringMembersInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension StopMonitoringMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension StopMonitoringMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopMonitoringMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopMonitoringMembersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopMonitoringMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopMonitoringMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct StopMonitoringMembersOutputResponse: Swift.Equatable {
    /// A list of objects that contain an accountId for each account that could not be processed, and a result string that indicates why the account was not processed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init (
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct StopMonitoringMembersOutputResponseBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension StopMonitoringMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension GuardDutyClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "key"
        case value = "value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about a tag associated with the EC2 instance.
    public struct Tag: Swift.Equatable {
        /// The EC2 instance tag key.
        public var key: Swift.String?
        /// The EC2 instance tag value.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the GuardDuty resource to apply a tag to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to be added to a resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension GuardDutyClientTypes {
    public enum ThreatIntelSetFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alienVault
        case fireEye
        case otxCsv
        case proofPoint
        case stix
        case txt
        case sdkUnknown(Swift.String)

        public static var allCases: [ThreatIntelSetFormat] {
            return [
                .alienVault,
                .fireEye,
                .otxCsv,
                .proofPoint,
                .stix,
                .txt,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alienVault: return "ALIEN_VAULT"
            case .fireEye: return "FIRE_EYE"
            case .otxCsv: return "OTX_CSV"
            case .proofPoint: return "PROOF_POINT"
            case .stix: return "STIX"
            case .txt: return "TXT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThreatIntelSetFormat(rawValue: rawValue) ?? ThreatIntelSetFormat.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes {
    public enum ThreatIntelSetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activating
        case active
        case deactivating
        case deleted
        case deletePending
        case error
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [ThreatIntelSetStatus] {
            return [
                .activating,
                .active,
                .deactivating,
                .deleted,
                .deletePending,
                .error,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activating: return "ACTIVATING"
            case .active: return "ACTIVE"
            case .deactivating: return "DEACTIVATING"
            case .deleted: return "DELETED"
            case .deletePending: return "DELETE_PENDING"
            case .error: return "ERROR"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThreatIntelSetStatus(rawValue: rawValue) ?? ThreatIntelSetStatus.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.ThreatIntelligenceDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case threatListName = "threatListName"
        case threatNames = "threatNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let threatListName = threatListName {
            try encodeContainer.encode(threatListName, forKey: .threatListName)
        }
        if let threatNames = threatNames {
            var threatNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threatNames)
            for threatnames0 in threatNames {
                try threatNamesContainer.encode(threatnames0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let threatListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .threatListName)
        threatListName = threatListNameDecoded
        let threatNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .threatNames)
        var threatNamesDecoded0:[Swift.String]? = nil
        if let threatNamesContainer = threatNamesContainer {
            threatNamesDecoded0 = [Swift.String]()
            for string0 in threatNamesContainer {
                if let string0 = string0 {
                    threatNamesDecoded0?.append(string0)
                }
            }
        }
        threatNames = threatNamesDecoded0
    }
}

extension GuardDutyClientTypes {
    /// An instance of a threat intelligence detail that constitutes evidence for the finding.
    public struct ThreatIntelligenceDetail: Swift.Equatable {
        /// The name of the threat intelligence list that triggered the finding.
        public var threatListName: Swift.String?
        /// A list of names of the threats in the threat intelligence list that triggered the finding.
        public var threatNames: [Swift.String]?

        public init (
            threatListName: Swift.String? = nil,
            threatNames: [Swift.String]? = nil
        )
        {
            self.threatListName = threatListName
            self.threatNames = threatNames
        }
    }

}

extension GuardDutyClientTypes.Total: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount = "amount"
        case unit = "unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amount = amount {
            try encodeContainer.encode(amount, forKey: .amount)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amount)
        amount = amountDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains the total usage with the corresponding currency unit for that value.
    public struct Total: Swift.Equatable {
        /// The total usage.
        public var amount: Swift.String?
        /// The currency unit that the amount is given in.
        public var unit: Swift.String?

        public init (
            amount: Swift.String? = nil,
            unit: Swift.String? = nil
        )
        {
            self.amount = amount
            self.unit = unit
        }
    }

}

extension UnarchiveFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIds = "findingIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingIds = findingIds {
            var findingIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingIds)
            for findingids0 in findingIds {
                try findingIdsContainer.encode(findingids0)
            }
        }
    }
}

extension UnarchiveFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/findings/unarchive"
    }
}

public struct UnarchiveFindingsInput: Swift.Equatable {
    /// The ID of the detector associated with the findings to unarchive.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The IDs of the findings to unarchive.
    /// This member is required.
    public var findingIds: [Swift.String]?

    public init (
        detectorId: Swift.String? = nil,
        findingIds: [Swift.String]? = nil
    )
    {
        self.detectorId = detectorId
        self.findingIds = findingIds
    }
}

struct UnarchiveFindingsInputBody: Swift.Equatable {
    let findingIds: [Swift.String]?
}

extension UnarchiveFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIds = "findingIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[Swift.String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [Swift.String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
    }
}

extension UnarchiveFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnarchiveFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnarchiveFindingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnarchiveFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UnarchiveFindingsOutputResponse: Swift.Equatable {

}

extension GuardDutyClientTypes.UnprocessedAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case result = "result"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let result = result {
            try encodeContainer.encode(result, forKey: .result)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let resultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .result)
        result = resultDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the accounts that weren't processed.
    public struct UnprocessedAccount: Swift.Equatable {
        /// The AWS account ID.
        /// This member is required.
        public var accountId: Swift.String?
        /// A reason why the account hasn't been processed.
        /// This member is required.
        public var result: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            result: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.result = result
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the resource to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateDetectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSources = "dataSources"
        case enable = "enable"
        case findingPublishingFrequency = "findingPublishingFrequency"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSources = dataSources {
            try encodeContainer.encode(dataSources, forKey: .dataSources)
        }
        if enable != false {
            try encodeContainer.encode(enable, forKey: .enable)
        }
        if let findingPublishingFrequency = findingPublishingFrequency {
            try encodeContainer.encode(findingPublishingFrequency.rawValue, forKey: .findingPublishingFrequency)
        }
    }
}

extension UpdateDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())"
    }
}

public struct UpdateDetectorInput: Swift.Equatable {
    /// Describes which data sources will be updated.
    public var dataSources: GuardDutyClientTypes.DataSourceConfigurations?
    /// The unique ID of the detector to update.
    /// This member is required.
    public var detectorId: Swift.String?
    /// Specifies whether the detector is enabled or not enabled.
    public var enable: Swift.Bool
    /// An enum value that specifies how frequently findings are exported, such as to CloudWatch Events.
    public var findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency?

    public init (
        dataSources: GuardDutyClientTypes.DataSourceConfigurations? = nil,
        detectorId: Swift.String? = nil,
        enable: Swift.Bool = false,
        findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency? = nil
    )
    {
        self.dataSources = dataSources
        self.detectorId = detectorId
        self.enable = enable
        self.findingPublishingFrequency = findingPublishingFrequency
    }
}

struct UpdateDetectorInputBody: Swift.Equatable {
    let enable: Swift.Bool
    let findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency?
    let dataSources: GuardDutyClientTypes.DataSourceConfigurations?
}

extension UpdateDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSources = "dataSources"
        case enable = "enable"
        case findingPublishingFrequency = "findingPublishingFrequency"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enable)
        enable = enableDecoded
        let findingPublishingFrequencyDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingPublishingFrequency.self, forKey: .findingPublishingFrequency)
        findingPublishingFrequency = findingPublishingFrequencyDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceConfigurations.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
    }
}

extension UpdateDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDetectorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDetectorOutputResponse: Swift.Equatable {

}

extension UpdateFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "action"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case rank = "rank"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let findingCriteria = findingCriteria {
            try encodeContainer.encode(findingCriteria, forKey: .findingCriteria)
        }
        if rank != 0 {
            try encodeContainer.encode(rank, forKey: .rank)
        }
    }
}

extension UpdateFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let filterName = filterName else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/filter/\(filterName.urlPercentEncoding())"
    }
}

public struct UpdateFilterInput: Swift.Equatable {
    /// Specifies the action that is to be applied to the findings that match the filter.
    public var action: GuardDutyClientTypes.FilterAction?
    /// The description of the filter.
    public var description: Swift.String?
    /// The unique ID of the detector that specifies the GuardDuty service where you want to update a filter.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The name of the filter.
    /// This member is required.
    public var filterName: Swift.String?
    /// Represents the criteria to be used in the filter for querying findings.
    public var findingCriteria: GuardDutyClientTypes.FindingCriteria?
    /// Specifies the position of the filter in the list of current filters. Also specifies the order in which this filter is applied to the findings.
    public var rank: Swift.Int

    public init (
        action: GuardDutyClientTypes.FilterAction? = nil,
        description: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        filterName: Swift.String? = nil,
        findingCriteria: GuardDutyClientTypes.FindingCriteria? = nil,
        rank: Swift.Int = 0
    )
    {
        self.action = action
        self.description = description
        self.detectorId = detectorId
        self.filterName = filterName
        self.findingCriteria = findingCriteria
        self.rank = rank
    }
}

struct UpdateFilterInputBody: Swift.Equatable {
    let description: Swift.String?
    let action: GuardDutyClientTypes.FilterAction?
    let rank: Swift.Int
    let findingCriteria: GuardDutyClientTypes.FindingCriteria?
}

extension UpdateFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "action"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case rank = "rank"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let actionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FilterAction.self, forKey: .action)
        action = actionDecoded
        let rankDecoded = try containerValues.decode(Swift.Int.self, forKey: .rank)
        rank = rankDecoded
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
    }
}

extension UpdateFilterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFilterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFilterOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFilterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFilterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct UpdateFilterOutputResponse: Swift.Equatable {
    /// The name of the filter.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct UpdateFilterOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateFilterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateFindingsFeedbackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comments = "comments"
        case feedback = "feedback"
        case findingIds = "findingIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comments = comments {
            try encodeContainer.encode(comments, forKey: .comments)
        }
        if let feedback = feedback {
            try encodeContainer.encode(feedback.rawValue, forKey: .feedback)
        }
        if let findingIds = findingIds {
            var findingIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingIds)
            for findingids0 in findingIds {
                try findingIdsContainer.encode(findingids0)
            }
        }
    }
}

extension UpdateFindingsFeedbackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/findings/feedback"
    }
}

public struct UpdateFindingsFeedbackInput: Swift.Equatable {
    /// Additional feedback about the GuardDuty findings.
    public var comments: Swift.String?
    /// The ID of the detector associated with the findings to update feedback for.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The feedback for the finding.
    /// This member is required.
    public var feedback: GuardDutyClientTypes.Feedback?
    /// The IDs of the findings that you want to mark as useful or not useful.
    /// This member is required.
    public var findingIds: [Swift.String]?

    public init (
        comments: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        feedback: GuardDutyClientTypes.Feedback? = nil,
        findingIds: [Swift.String]? = nil
    )
    {
        self.comments = comments
        self.detectorId = detectorId
        self.feedback = feedback
        self.findingIds = findingIds
    }
}

struct UpdateFindingsFeedbackInputBody: Swift.Equatable {
    let findingIds: [Swift.String]?
    let feedback: GuardDutyClientTypes.Feedback?
    let comments: Swift.String?
}

extension UpdateFindingsFeedbackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comments = "comments"
        case feedback = "feedback"
        case findingIds = "findingIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[Swift.String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [Swift.String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
        let feedbackDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Feedback.self, forKey: .feedback)
        feedback = feedbackDecoded
        let commentsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comments)
        comments = commentsDecoded
    }
}

extension UpdateFindingsFeedbackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFindingsFeedbackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFindingsFeedbackOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFindingsFeedbackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateFindingsFeedbackOutputResponse: Swift.Equatable {

}

extension UpdateIPSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activate = "activate"
        case location = "location"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if activate != false {
            try encodeContainer.encode(activate, forKey: .activate)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateIPSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let ipSetId = ipSetId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/ipset/\(ipSetId.urlPercentEncoding())"
    }
}

public struct UpdateIPSetInput: Swift.Equatable {
    /// The updated Boolean value that specifies whether the IPSet is active or not.
    public var activate: Swift.Bool
    /// The detectorID that specifies the GuardDuty service whose IPSet you want to update.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The unique ID that specifies the IPSet that you want to update.
    /// This member is required.
    public var ipSetId: Swift.String?
    /// The updated URI of the file that contains the IPSet. For example: https://s3.us-west-2.amazonaws.com/my-bucket/my-object-key.
    public var location: Swift.String?
    /// The unique ID that specifies the IPSet that you want to update.
    public var name: Swift.String?

    public init (
        activate: Swift.Bool = false,
        detectorId: Swift.String? = nil,
        ipSetId: Swift.String? = nil,
        location: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.activate = activate
        self.detectorId = detectorId
        self.ipSetId = ipSetId
        self.location = location
        self.name = name
    }
}

struct UpdateIPSetInputBody: Swift.Equatable {
    let name: Swift.String?
    let location: Swift.String?
    let activate: Swift.Bool
}

extension UpdateIPSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activate = "activate"
        case location = "location"
        case name = "name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let activateDecoded = try containerValues.decode(Swift.Bool.self, forKey: .activate)
        activate = activateDecoded
    }
}

extension UpdateIPSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIPSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIPSetOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIPSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateIPSetOutputResponse: Swift.Equatable {

}

extension UpdateMemberDetectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
        case dataSources = "dataSources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
        if let dataSources = dataSources {
            try encodeContainer.encode(dataSources, forKey: .dataSources)
        }
    }
}

extension UpdateMemberDetectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member/detector/update"
    }
}

public struct UpdateMemberDetectorsInput: Swift.Equatable {
    /// A list of member account IDs to be updated.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// Describes which data sources will be updated.
    public var dataSources: GuardDutyClientTypes.DataSourceConfigurations?
    /// The detector ID of the administrator account.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        dataSources: GuardDutyClientTypes.DataSourceConfigurations? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.dataSources = dataSources
        self.detectorId = detectorId
    }
}

struct UpdateMemberDetectorsInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
    let dataSources: GuardDutyClientTypes.DataSourceConfigurations?
}

extension UpdateMemberDetectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
        case dataSources = "dataSources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let dataSourcesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceConfigurations.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
    }
}

extension UpdateMemberDetectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMemberDetectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMemberDetectorsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMemberDetectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateMemberDetectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct UpdateMemberDetectorsOutputResponse: Swift.Equatable {
    /// A list of member account IDs that were unable to be processed along with an explanation for why they were not processed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init (
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct UpdateMemberDetectorsOutputResponseBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension UpdateMemberDetectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension UpdateOrganizationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
        case dataSources = "dataSources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoEnable != false {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
        if let dataSources = dataSources {
            try encodeContainer.encode(dataSources, forKey: .dataSources)
        }
    }
}

extension UpdateOrganizationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/admin"
    }
}

public struct UpdateOrganizationConfigurationInput: Swift.Equatable {
    /// Indicates whether to automatically enable member accounts in the organization.
    /// This member is required.
    public var autoEnable: Swift.Bool
    /// Describes which data sources will be updated.
    public var dataSources: GuardDutyClientTypes.OrganizationDataSourceConfigurations?
    /// The ID of the detector to update the delegated administrator for.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        autoEnable: Swift.Bool = false,
        dataSources: GuardDutyClientTypes.OrganizationDataSourceConfigurations? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.autoEnable = autoEnable
        self.dataSources = dataSources
        self.detectorId = detectorId
    }
}

struct UpdateOrganizationConfigurationInputBody: Swift.Equatable {
    let autoEnable: Swift.Bool
    let dataSources: GuardDutyClientTypes.OrganizationDataSourceConfigurations?
}

extension UpdateOrganizationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
        case dataSources = "dataSources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationDataSourceConfigurations.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
    }
}

extension UpdateOrganizationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateOrganizationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateOrganizationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateOrganizationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateOrganizationConfigurationOutputResponse: Swift.Equatable {

}

extension UpdatePublishingDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationProperties = "destinationProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationProperties = destinationProperties {
            try encodeContainer.encode(destinationProperties, forKey: .destinationProperties)
        }
    }
}

extension UpdatePublishingDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let destinationId = destinationId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/publishingDestination/\(destinationId.urlPercentEncoding())"
    }
}

public struct UpdatePublishingDestinationInput: Swift.Equatable {
    /// The ID of the publishing destination to update.
    /// This member is required.
    public var destinationId: Swift.String?
    /// A DestinationProperties object that includes the DestinationArn and KmsKeyArn of the publishing destination.
    public var destinationProperties: GuardDutyClientTypes.DestinationProperties?
    /// The ID of the detector associated with the publishing destinations to update.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        destinationId: Swift.String? = nil,
        destinationProperties: GuardDutyClientTypes.DestinationProperties? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.destinationId = destinationId
        self.destinationProperties = destinationProperties
        self.detectorId = detectorId
    }
}

struct UpdatePublishingDestinationInputBody: Swift.Equatable {
    let destinationProperties: GuardDutyClientTypes.DestinationProperties?
}

extension UpdatePublishingDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationProperties = "destinationProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPropertiesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DestinationProperties.self, forKey: .destinationProperties)
        destinationProperties = destinationPropertiesDecoded
    }
}

extension UpdatePublishingDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePublishingDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePublishingDestinationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePublishingDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdatePublishingDestinationOutputResponse: Swift.Equatable {

}

extension UpdateThreatIntelSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activate = "activate"
        case location = "location"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if activate != false {
            try encodeContainer.encode(activate, forKey: .activate)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateThreatIntelSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let threatIntelSetId = threatIntelSetId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/threatintelset/\(threatIntelSetId.urlPercentEncoding())"
    }
}

public struct UpdateThreatIntelSetInput: Swift.Equatable {
    /// The updated Boolean value that specifies whether the ThreateIntelSet is active or not.
    public var activate: Swift.Bool
    /// The detectorID that specifies the GuardDuty service whose ThreatIntelSet you want to update.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The updated URI of the file that contains the ThreateIntelSet.
    public var location: Swift.String?
    /// The unique ID that specifies the ThreatIntelSet that you want to update.
    public var name: Swift.String?
    /// The unique ID that specifies the ThreatIntelSet that you want to update.
    /// This member is required.
    public var threatIntelSetId: Swift.String?

    public init (
        activate: Swift.Bool = false,
        detectorId: Swift.String? = nil,
        location: Swift.String? = nil,
        name: Swift.String? = nil,
        threatIntelSetId: Swift.String? = nil
    )
    {
        self.activate = activate
        self.detectorId = detectorId
        self.location = location
        self.name = name
        self.threatIntelSetId = threatIntelSetId
    }
}

struct UpdateThreatIntelSetInputBody: Swift.Equatable {
    let name: Swift.String?
    let location: Swift.String?
    let activate: Swift.Bool
}

extension UpdateThreatIntelSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activate = "activate"
        case location = "location"
        case name = "name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let activateDecoded = try containerValues.decode(Swift.Bool.self, forKey: .activate)
        activate = activateDecoded
    }
}

extension UpdateThreatIntelSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateThreatIntelSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateThreatIntelSetOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateThreatIntelSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateThreatIntelSetOutputResponse: Swift.Equatable {

}

extension GuardDutyClientTypes.UsageAccountResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case total = "total"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let total = total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let totalDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Total.self, forKey: .total)
        total = totalDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the total of usage based on account IDs.
    public struct UsageAccountResult: Swift.Equatable {
        /// The Account ID that generated usage.
        public var accountId: Swift.String?
        /// Represents the total of usage for the Account ID.
        public var total: GuardDutyClientTypes.Total?

        public init (
            accountId: Swift.String? = nil,
            total: GuardDutyClientTypes.Total? = nil
        )
        {
            self.accountId = accountId
            self.total = total
        }
    }

}

extension GuardDutyClientTypes.UsageCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
        case dataSources = "dataSources"
        case resources = "resources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasourcelist0 in dataSources {
                try dataSourcesContainer.encode(datasourcelist0.rawValue)
            }
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resourcelist0 in resources {
                try resourcesContainer.encode(resourcelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let dataSourcesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[GuardDutyClientTypes.DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [GuardDutyClientTypes.DataSource]()
            for string0 in dataSourcesContainer {
                if let string0 = string0 {
                    dataSourcesDecoded0?.append(string0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let resourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resources)
        var resourcesDecoded0:[Swift.String]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Swift.String]()
            for string0 in resourcesContainer {
                if let string0 = string0 {
                    resourcesDecoded0?.append(string0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the criteria used to query usage statistics.
    public struct UsageCriteria: Swift.Equatable {
        /// The account IDs to aggregate usage statistics from.
        public var accountIds: [Swift.String]?
        /// The data sources to aggregate usage statistics from.
        /// This member is required.
        public var dataSources: [GuardDutyClientTypes.DataSource]?
        /// The resources to aggregate usage statistics from. Only accepts exact resource names.
        public var resources: [Swift.String]?

        public init (
            accountIds: [Swift.String]? = nil,
            dataSources: [GuardDutyClientTypes.DataSource]? = nil,
            resources: [Swift.String]? = nil
        )
        {
            self.accountIds = accountIds
            self.dataSources = dataSources
            self.resources = resources
        }
    }

}

extension GuardDutyClientTypes.UsageDataSourceResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "dataSource"
        case total = "total"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource.rawValue, forKey: .dataSource)
        }
        if let total = total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let totalDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Total.self, forKey: .total)
        total = totalDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the result of usage based on data source type.
    public struct UsageDataSourceResult: Swift.Equatable {
        /// The data source type that generated usage.
        public var dataSource: GuardDutyClientTypes.DataSource?
        /// Represents the total of usage for the specified data source.
        public var total: GuardDutyClientTypes.Total?

        public init (
            dataSource: GuardDutyClientTypes.DataSource? = nil,
            total: GuardDutyClientTypes.Total? = nil
        )
        {
            self.dataSource = dataSource
            self.total = total
        }
    }

}

extension GuardDutyClientTypes.UsageResourceResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resource = "resource"
        case total = "total"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let total = total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let totalDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Total.self, forKey: .total)
        total = totalDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the sum of usage based on an AWS resource.
    public struct UsageResourceResult: Swift.Equatable {
        /// The AWS resource that generated usage.
        public var resource: Swift.String?
        /// Represents the sum total of usage for the specified resource type.
        public var total: GuardDutyClientTypes.Total?

        public init (
            resource: Swift.String? = nil,
            total: GuardDutyClientTypes.Total? = nil
        )
        {
            self.resource = resource
            self.total = total
        }
    }

}

extension GuardDutyClientTypes {
    public enum UsageStatisticType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sumByAccount
        case sumByDataSource
        case sumByResource
        case topResources
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageStatisticType] {
            return [
                .sumByAccount,
                .sumByDataSource,
                .sumByResource,
                .topResources,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sumByAccount: return "SUM_BY_ACCOUNT"
            case .sumByDataSource: return "SUM_BY_DATA_SOURCE"
            case .sumByResource: return "SUM_BY_RESOURCE"
            case .topResources: return "TOP_RESOURCES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageStatisticType(rawValue: rawValue) ?? UsageStatisticType.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.UsageStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sumByAccount = "sumByAccount"
        case sumByDataSource = "sumByDataSource"
        case sumByResource = "sumByResource"
        case topResources = "topResources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sumByAccount = sumByAccount {
            var sumByAccountContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sumByAccount)
            for usageaccountresultlist0 in sumByAccount {
                try sumByAccountContainer.encode(usageaccountresultlist0)
            }
        }
        if let sumByDataSource = sumByDataSource {
            var sumByDataSourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sumByDataSource)
            for usagedatasourceresultlist0 in sumByDataSource {
                try sumByDataSourceContainer.encode(usagedatasourceresultlist0)
            }
        }
        if let sumByResource = sumByResource {
            var sumByResourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sumByResource)
            for usageresourceresultlist0 in sumByResource {
                try sumByResourceContainer.encode(usageresourceresultlist0)
            }
        }
        if let topResources = topResources {
            var topResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topResources)
            for usageresourceresultlist0 in topResources {
                try topResourcesContainer.encode(usageresourceresultlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sumByAccountContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UsageAccountResult?].self, forKey: .sumByAccount)
        var sumByAccountDecoded0:[GuardDutyClientTypes.UsageAccountResult]? = nil
        if let sumByAccountContainer = sumByAccountContainer {
            sumByAccountDecoded0 = [GuardDutyClientTypes.UsageAccountResult]()
            for structure0 in sumByAccountContainer {
                if let structure0 = structure0 {
                    sumByAccountDecoded0?.append(structure0)
                }
            }
        }
        sumByAccount = sumByAccountDecoded0
        let sumByDataSourceContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UsageDataSourceResult?].self, forKey: .sumByDataSource)
        var sumByDataSourceDecoded0:[GuardDutyClientTypes.UsageDataSourceResult]? = nil
        if let sumByDataSourceContainer = sumByDataSourceContainer {
            sumByDataSourceDecoded0 = [GuardDutyClientTypes.UsageDataSourceResult]()
            for structure0 in sumByDataSourceContainer {
                if let structure0 = structure0 {
                    sumByDataSourceDecoded0?.append(structure0)
                }
            }
        }
        sumByDataSource = sumByDataSourceDecoded0
        let sumByResourceContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UsageResourceResult?].self, forKey: .sumByResource)
        var sumByResourceDecoded0:[GuardDutyClientTypes.UsageResourceResult]? = nil
        if let sumByResourceContainer = sumByResourceContainer {
            sumByResourceDecoded0 = [GuardDutyClientTypes.UsageResourceResult]()
            for structure0 in sumByResourceContainer {
                if let structure0 = structure0 {
                    sumByResourceDecoded0?.append(structure0)
                }
            }
        }
        sumByResource = sumByResourceDecoded0
        let topResourcesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UsageResourceResult?].self, forKey: .topResources)
        var topResourcesDecoded0:[GuardDutyClientTypes.UsageResourceResult]? = nil
        if let topResourcesContainer = topResourcesContainer {
            topResourcesDecoded0 = [GuardDutyClientTypes.UsageResourceResult]()
            for structure0 in topResourcesContainer {
                if let structure0 = structure0 {
                    topResourcesDecoded0?.append(structure0)
                }
            }
        }
        topResources = topResourcesDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains the result of GuardDuty usage. If a UsageStatisticType is provided the result for other types will be null.
    public struct UsageStatistics: Swift.Equatable {
        /// The usage statistic sum organized by account ID.
        public var sumByAccount: [GuardDutyClientTypes.UsageAccountResult]?
        /// The usage statistic sum organized by on data source.
        public var sumByDataSource: [GuardDutyClientTypes.UsageDataSourceResult]?
        /// The usage statistic sum organized by resource.
        public var sumByResource: [GuardDutyClientTypes.UsageResourceResult]?
        /// Lists the top 50 resources that have generated the most GuardDuty usage, in order from most to least expensive.
        public var topResources: [GuardDutyClientTypes.UsageResourceResult]?

        public init (
            sumByAccount: [GuardDutyClientTypes.UsageAccountResult]? = nil,
            sumByDataSource: [GuardDutyClientTypes.UsageDataSourceResult]? = nil,
            sumByResource: [GuardDutyClientTypes.UsageResourceResult]? = nil,
            topResources: [GuardDutyClientTypes.UsageResourceResult]? = nil
        )
        {
            self.sumByAccount = sumByAccount
            self.sumByDataSource = sumByDataSource
            self.sumByResource = sumByResource
            self.topResources = topResources
        }
    }

}
