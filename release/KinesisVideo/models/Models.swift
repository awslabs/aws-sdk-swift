// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public enum APIName {
    case getClip
    case getDashStreamingSessionUrl
    case getHlsStreamingSessionUrl
    case getMedia
    case getMediaForFragmentList
    case listFragments
    case putMedia
    case sdkUnknown(String)
}

extension APIName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [APIName] {
        return [
            .getClip,
            .getDashStreamingSessionUrl,
            .getHlsStreamingSessionUrl,
            .getMedia,
            .getMediaForFragmentList,
            .listFragments,
            .putMedia,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .getClip: return "GET_CLIP"
        case .getDashStreamingSessionUrl: return "GET_DASH_STREAMING_SESSION_URL"
        case .getHlsStreamingSessionUrl: return "GET_HLS_STREAMING_SESSION_URL"
        case .getMedia: return "GET_MEDIA"
        case .getMediaForFragmentList: return "GET_MEDIA_FOR_FRAGMENT_LIST"
        case .listFragments: return "LIST_FRAGMENTS"
        case .putMedia: return "PUT_MEDIA"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = APIName(rawValue: rawValue) ?? APIName.sdkUnknown(rawValue)
    }
}

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have required permissions to perform this operation.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccountChannelLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountChannelLimitExceededException(message: \(String(describing: message)))"}
}

extension AccountChannelLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccountChannelLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the maximum limit of active signaling channels for this AWS account
///             in this region.</p>
public struct AccountChannelLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccountChannelLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension AccountChannelLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccountStreamLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountStreamLimitExceededException(message: \(String(describing: message)))"}
}

extension AccountStreamLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccountStreamLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of streams created for the account is too high.</p>
public struct AccountStreamLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccountStreamLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension AccountStreamLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChannelInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelARN = "ChannelARN"
        case channelName = "ChannelName"
        case channelStatus = "ChannelStatus"
        case channelType = "ChannelType"
        case creationTime = "CreationTime"
        case singleMasterConfiguration = "SingleMasterConfiguration"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let channelName = channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let channelStatus = channelStatus {
            try encodeContainer.encode(channelStatus.rawValue, forKey: .channelStatus)
        }
        if let channelType = channelType {
            try encodeContainer.encode(channelType.rawValue, forKey: .channelType)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let singleMasterConfiguration = singleMasterConfiguration {
            try encodeContainer.encode(singleMasterConfiguration, forKey: .singleMasterConfiguration)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
        let channelTypeDecoded = try containerValues.decodeIfPresent(ChannelType.self, forKey: .channelType)
        channelType = channelTypeDecoded
        let channelStatusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .channelStatus)
        channelStatus = channelStatusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let singleMasterConfigurationDecoded = try containerValues.decodeIfPresent(SingleMasterConfiguration.self, forKey: .singleMasterConfiguration)
        singleMasterConfiguration = singleMasterConfigurationDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension ChannelInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChannelInfo(channelARN: \(String(describing: channelARN)), channelName: \(String(describing: channelName)), channelStatus: \(String(describing: channelStatus)), channelType: \(String(describing: channelType)), creationTime: \(String(describing: creationTime)), singleMasterConfiguration: \(String(describing: singleMasterConfiguration)), version: \(String(describing: version)))"}
}

/// <p>A structure that encapsulates a signaling channel's metadata and properties.</p>
public struct ChannelInfo: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the signaling channel.</p>
    public let channelARN: String?
    /// <p>The name of the signaling channel.</p>
    public let channelName: String?
    /// <p>Current status of the signaling channel.</p>
    public let channelStatus: Status?
    /// <p>The type of the signaling channel.</p>
    public let channelType: ChannelType?
    /// <p>The time at which the signaling channel was created.</p>
    public let creationTime: Date?
    /// <p>A structure that contains the configuration for the <code>SINGLE_MASTER</code> channel
    ///             type.</p>
    public let singleMasterConfiguration: SingleMasterConfiguration?
    /// <p>The current version of the signaling channel.</p>
    public let version: String?

    public init (
        channelARN: String? = nil,
        channelName: String? = nil,
        channelStatus: Status? = nil,
        channelType: ChannelType? = nil,
        creationTime: Date? = nil,
        singleMasterConfiguration: SingleMasterConfiguration? = nil,
        version: String? = nil
    )
    {
        self.channelARN = channelARN
        self.channelName = channelName
        self.channelStatus = channelStatus
        self.channelType = channelType
        self.creationTime = creationTime
        self.singleMasterConfiguration = singleMasterConfiguration
        self.version = version
    }
}

extension ChannelNameCondition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comparisonOperator = "ComparisonOperator"
        case comparisonValue = "ComparisonValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let comparisonValue = comparisonValue {
            try encodeContainer.encode(comparisonValue, forKey: .comparisonValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let comparisonValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comparisonValue)
        comparisonValue = comparisonValueDecoded
    }
}

extension ChannelNameCondition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChannelNameCondition(comparisonOperator: \(String(describing: comparisonOperator)), comparisonValue: \(String(describing: comparisonValue)))"}
}

/// <p>An optional input parameter for the <code>ListSignalingChannels</code> API. When this
///             parameter is specified while invoking <code>ListSignalingChannels</code>, the API
///             returns only the channels that satisfy a condition specified in
///                 <code>ChannelNameCondition</code>.</p>
public struct ChannelNameCondition: Equatable {
    /// <p>A comparison operator. Currently, you can only specify the <code>BEGINS_WITH</code>
    ///             operator, which finds signaling channels whose names begin with a given prefix.</p>
    public let comparisonOperator: ComparisonOperator?
    /// <p>A value to compare.</p>
    public let comparisonValue: String?

    public init (
        comparisonOperator: ComparisonOperator? = nil,
        comparisonValue: String? = nil
    )
    {
        self.comparisonOperator = comparisonOperator
        self.comparisonValue = comparisonValue
    }
}

public enum ChannelProtocol {
    case https
    case wss
    case sdkUnknown(String)
}

extension ChannelProtocol : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChannelProtocol] {
        return [
            .https,
            .wss,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .https: return "HTTPS"
        case .wss: return "WSS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChannelProtocol(rawValue: rawValue) ?? ChannelProtocol.sdkUnknown(rawValue)
    }
}

public enum ChannelRole {
    case master
    case viewer
    case sdkUnknown(String)
}

extension ChannelRole : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChannelRole] {
        return [
            .master,
            .viewer,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .master: return "MASTER"
        case .viewer: return "VIEWER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChannelRole(rawValue: rawValue) ?? ChannelRole.sdkUnknown(rawValue)
    }
}

public enum ChannelType {
    case singleMaster
    case sdkUnknown(String)
}

extension ChannelType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChannelType] {
        return [
            .singleMaster,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .singleMaster: return "SINGLE_MASTER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChannelType(rawValue: rawValue) ?? ChannelType.sdkUnknown(rawValue)
    }
}

extension ClientLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClientLimitExceededException(message: \(String(describing: message)))"}
}

extension ClientLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ClientLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Kinesis Video Streams has throttled the request because you have exceeded the limit of
///             allowed client calls. Try making the call later.</p>
public struct ClientLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClientLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension ClientLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ComparisonOperator {
    case beginsWith
    case sdkUnknown(String)
}

extension ComparisonOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ComparisonOperator] {
        return [
            .beginsWith,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .beginsWith: return "BEGINS_WITH"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ComparisonOperator(rawValue: rawValue) ?? ComparisonOperator.sdkUnknown(rawValue)
    }
}

public struct CreateSignalingChannelInputBodyMiddleware: Middleware {
    public let id: String = "CreateSignalingChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSignalingChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSignalingChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSignalingChannelInput>
    public typealias MOutput = OperationOutput<CreateSignalingChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSignalingChannelOutputError>
}

extension CreateSignalingChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSignalingChannelInput(channelName: \(String(describing: channelName)), channelType: \(String(describing: channelType)), singleMasterConfiguration: \(String(describing: singleMasterConfiguration)), tags: \(String(describing: tags)))"}
}

extension CreateSignalingChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelName = "ChannelName"
        case channelType = "ChannelType"
        case singleMasterConfiguration = "SingleMasterConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelName = channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let channelType = channelType {
            try encodeContainer.encode(channelType.rawValue, forKey: .channelType)
        }
        if let singleMasterConfiguration = singleMasterConfiguration {
            try encodeContainer.encode(singleMasterConfiguration, forKey: .singleMasterConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagoncreatelist0 in tags {
                try tagsContainer.encode(tagoncreatelist0)
            }
        }
    }
}

public struct CreateSignalingChannelInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSignalingChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSignalingChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSignalingChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSignalingChannelInput>
    public typealias MOutput = OperationOutput<CreateSignalingChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSignalingChannelOutputError>
}

public struct CreateSignalingChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSignalingChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSignalingChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSignalingChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSignalingChannelInput>
    public typealias MOutput = OperationOutput<CreateSignalingChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSignalingChannelOutputError>
}

public struct CreateSignalingChannelInput: Equatable {
    /// <p>A name for the signaling channel that you are creating. It must be unique for each AWS
    ///             account and AWS Region.</p>
    public let channelName: String?
    /// <p>A type of the signaling channel that you are creating. Currently,
    ///                 <code>SINGLE_MASTER</code> is the only supported channel type. </p>
    public let channelType: ChannelType?
    /// <p>A structure containing the configuration for the <code>SINGLE_MASTER</code> channel
    ///             type. </p>
    public let singleMasterConfiguration: SingleMasterConfiguration?
    /// <p>A set of tags (key-value pairs) that you want to associate with this channel.</p>
    public let tags: [Tag]?

    public init (
        channelName: String? = nil,
        channelType: ChannelType? = nil,
        singleMasterConfiguration: SingleMasterConfiguration? = nil,
        tags: [Tag]? = nil
    )
    {
        self.channelName = channelName
        self.channelType = channelType
        self.singleMasterConfiguration = singleMasterConfiguration
        self.tags = tags
    }
}

struct CreateSignalingChannelInputBody: Equatable {
    public let channelName: String?
    public let channelType: ChannelType?
    public let singleMasterConfiguration: SingleMasterConfiguration?
    public let tags: [Tag]?
}

extension CreateSignalingChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channelName = "ChannelName"
        case channelType = "ChannelType"
        case singleMasterConfiguration = "SingleMasterConfiguration"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelTypeDecoded = try containerValues.decodeIfPresent(ChannelType.self, forKey: .channelType)
        channelType = channelTypeDecoded
        let singleMasterConfigurationDecoded = try containerValues.decodeIfPresent(SingleMasterConfiguration.self, forKey: .singleMasterConfiguration)
        singleMasterConfiguration = singleMasterConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSignalingChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSignalingChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountChannelLimitExceededException" : self = .accountChannelLimitExceededException(try AccountChannelLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagsPerResourceExceededLimitException" : self = .tagsPerResourceExceededLimitException(try TagsPerResourceExceededLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSignalingChannelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountChannelLimitExceededException(AccountChannelLimitExceededException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case tagsPerResourceExceededLimitException(TagsPerResourceExceededLimitException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSignalingChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSignalingChannelOutputResponse(channelARN: \(String(describing: channelARN)))"}
}

extension CreateSignalingChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSignalingChannelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.channelARN = output.channelARN
        } else {
            self.channelARN = nil
        }
    }
}

public struct CreateSignalingChannelOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the created channel.</p>
    public let channelARN: String?

    public init (
        channelARN: String? = nil
    )
    {
        self.channelARN = channelARN
    }
}

struct CreateSignalingChannelOutputResponseBody: Equatable {
    public let channelARN: String?
}

extension CreateSignalingChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channelARN = "ChannelARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
    }
}

public struct CreateStreamInputBodyMiddleware: Middleware {
    public let id: String = "CreateStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamInput>
    public typealias MOutput = OperationOutput<CreateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamOutputError>
}

extension CreateStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStreamInput(dataRetentionInHours: \(String(describing: dataRetentionInHours)), deviceName: \(String(describing: deviceName)), kmsKeyId: \(String(describing: kmsKeyId)), mediaType: \(String(describing: mediaType)), streamName: \(String(describing: streamName)), tags: \(String(describing: tags)))"}
}

extension CreateStreamInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataRetentionInHours = "DataRetentionInHours"
        case deviceName = "DeviceName"
        case kmsKeyId = "KmsKeyId"
        case mediaType = "MediaType"
        case streamName = "StreamName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataRetentionInHours = dataRetentionInHours {
            try encodeContainer.encode(dataRetentionInHours, forKey: .dataRetentionInHours)
        }
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let mediaType = mediaType {
            try encodeContainer.encode(mediaType, forKey: .mediaType)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, resourcetags0) in tags {
                try tagsContainer.encode(resourcetags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateStreamInputHeadersMiddleware: Middleware {
    public let id: String = "CreateStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamInput>
    public typealias MOutput = OperationOutput<CreateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamOutputError>
}

public struct CreateStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamInput>
    public typealias MOutput = OperationOutput<CreateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamOutputError>
}

public struct CreateStreamInput: Equatable {
    /// <p>The number of hours that you want to retain the data in the stream. Kinesis Video
    ///             Streams retains the data in a data store that is associated with the stream.</p>
    ///         <p>The default value is 0, indicating that the stream does not persist data.</p>
    ///         <p>When the <code>DataRetentionInHours</code> value is 0, consumers can still consume
    ///             the fragments that remain in the service host buffer, which has a retention time limit
    ///             of 5 minutes and a retention memory limit of 200 MB. Fragments are removed from the
    ///             buffer when either limit is reached.</p>
    public let dataRetentionInHours: Int?
    /// <p>The name of the device that is writing to the stream. </p>
    ///         <note>
    ///             <p>In the current implementation, Kinesis Video Streams does not use this
    ///                 name.</p>
    ///         </note>
    public let deviceName: String?
    /// <p>The ID of the AWS Key Management Service (AWS KMS) key that you want Kinesis Video
    ///             Streams to use to encrypt stream data.</p>
    ///         <p>If no key ID is specified, the default, Kinesis Video-managed key
    ///                 (<code>aws/kinesisvideo</code>) is used.</p>
    ///         <p> For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters">DescribeKey</a>. </p>
    public let kmsKeyId: String?
    /// <p>The media type of the stream. Consumers of the stream can use this information when
    ///             processing the stream. For more information about media types, see <a href="http://www.iana.org/assignments/media-types/media-types.xhtml">Media
    ///                 Types</a>. If you choose to specify the <code>MediaType</code>, see <a href="https://tools.ietf.org/html/rfc6838#section-4.2">Naming Requirements</a>
    ///             for guidelines.</p>
    ///
    ///         <p>Example valid values include "video/h264" and "video/h264,audio/aac".</p>
    ///         <p>This parameter is optional; the default value is <code>null</code> (or empty in
    ///             JSON).</p>
    public let mediaType: String?
    /// <p>A name for the stream that you are creating.</p>
    ///         <p>The stream name is an identifier for the stream, and must be unique for each
    ///             account and region.</p>
    public let streamName: String?
    /// <p>A list of tags to associate with the specified stream. Each tag is a key-value pair
    ///             (the value is optional).</p>
    public let tags: [String:String]?

    public init (
        dataRetentionInHours: Int? = nil,
        deviceName: String? = nil,
        kmsKeyId: String? = nil,
        mediaType: String? = nil,
        streamName: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.dataRetentionInHours = dataRetentionInHours
        self.deviceName = deviceName
        self.kmsKeyId = kmsKeyId
        self.mediaType = mediaType
        self.streamName = streamName
        self.tags = tags
    }
}

struct CreateStreamInputBody: Equatable {
    public let deviceName: String?
    public let streamName: String?
    public let mediaType: String?
    public let kmsKeyId: String?
    public let dataRetentionInHours: Int?
    public let tags: [String:String]?
}

extension CreateStreamInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataRetentionInHours = "DataRetentionInHours"
        case deviceName = "DeviceName"
        case kmsKeyId = "KmsKeyId"
        case mediaType = "MediaType"
        case streamName = "StreamName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let mediaTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mediaType)
        mediaType = mediaTypeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dataRetentionInHoursDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .dataRetentionInHours)
        dataRetentionInHours = dataRetentionInHoursDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccountStreamLimitExceededException" : self = .accountStreamLimitExceededException(try AccountStreamLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DeviceStreamLimitExceededException" : self = .deviceStreamLimitExceededException(try DeviceStreamLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDeviceException" : self = .invalidDeviceException(try InvalidDeviceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagsPerResourceExceededLimitException" : self = .tagsPerResourceExceededLimitException(try TagsPerResourceExceededLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamOutputError: Equatable {
    case accountStreamLimitExceededException(AccountStreamLimitExceededException)
    case clientLimitExceededException(ClientLimitExceededException)
    case deviceStreamLimitExceededException(DeviceStreamLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidDeviceException(InvalidDeviceException)
    case resourceInUseException(ResourceInUseException)
    case tagsPerResourceExceededLimitException(TagsPerResourceExceededLimitException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStreamOutputResponse(streamARN: \(String(describing: streamARN)))"}
}

extension CreateStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateStreamOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.streamARN = output.streamARN
        } else {
            self.streamARN = nil
        }
    }
}

public struct CreateStreamOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the stream.</p>
    public let streamARN: String?

    public init (
        streamARN: String? = nil
    )
    {
        self.streamARN = streamARN
    }
}

struct CreateStreamOutputResponseBody: Equatable {
    public let streamARN: String?
}

extension CreateStreamOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamARN = "StreamARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
    }
}

public struct DeleteSignalingChannelInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSignalingChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSignalingChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSignalingChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSignalingChannelInput>
    public typealias MOutput = OperationOutput<DeleteSignalingChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSignalingChannelOutputError>
}

extension DeleteSignalingChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSignalingChannelInput(channelARN: \(String(describing: channelARN)), currentVersion: \(String(describing: currentVersion)))"}
}

extension DeleteSignalingChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelARN = "ChannelARN"
        case currentVersion = "CurrentVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
    }
}

public struct DeleteSignalingChannelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSignalingChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSignalingChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSignalingChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSignalingChannelInput>
    public typealias MOutput = OperationOutput<DeleteSignalingChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSignalingChannelOutputError>
}

public struct DeleteSignalingChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSignalingChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSignalingChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSignalingChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSignalingChannelInput>
    public typealias MOutput = OperationOutput<DeleteSignalingChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSignalingChannelOutputError>
}

public struct DeleteSignalingChannelInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the signaling channel that you want to
    ///             delete.</p>
    public let channelARN: String?
    /// <p>The current version of the signaling channel that you want to delete. You can obtain
    ///             the current version by invoking the <code>DescribeSignalingChannel</code> or
    ///                 <code>ListSignalingChannels</code> API operations.</p>
    public let currentVersion: String?

    public init (
        channelARN: String? = nil,
        currentVersion: String? = nil
    )
    {
        self.channelARN = channelARN
        self.currentVersion = currentVersion
    }
}

struct DeleteSignalingChannelInputBody: Equatable {
    public let channelARN: String?
    public let currentVersion: String?
}

extension DeleteSignalingChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channelARN = "ChannelARN"
        case currentVersion = "CurrentVersion"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
    }
}

extension DeleteSignalingChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSignalingChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionMismatchException" : self = .versionMismatchException(try VersionMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSignalingChannelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case versionMismatchException(VersionMismatchException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSignalingChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSignalingChannelOutputResponse()"}
}

extension DeleteSignalingChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSignalingChannelOutputResponse: Equatable {

    public init() {}
}

struct DeleteSignalingChannelOutputResponseBody: Equatable {
}

extension DeleteSignalingChannelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteStreamInputBodyMiddleware: Middleware {
    public let id: String = "DeleteStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStreamInput>
    public typealias MOutput = OperationOutput<DeleteStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStreamOutputError>
}

extension DeleteStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStreamInput(currentVersion: \(String(describing: currentVersion)), streamARN: \(String(describing: streamARN)))"}
}

extension DeleteStreamInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentVersion = "CurrentVersion"
        case streamARN = "StreamARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
    }
}

public struct DeleteStreamInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStreamInput>
    public typealias MOutput = OperationOutput<DeleteStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStreamOutputError>
}

public struct DeleteStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStreamInput>
    public typealias MOutput = OperationOutput<DeleteStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStreamOutputError>
}

public struct DeleteStreamInput: Equatable {
    /// <p>Optional: The version of the stream that you want to delete. </p>
    ///         <p>Specify the version as a safeguard to ensure that your are deleting the correct
    ///             stream. To get the stream version, use the <code>DescribeStream</code> API.</p>
    ///         <p>If not specified, only the <code>CreationTime</code> is checked before deleting the
    ///             stream.</p>
    public let currentVersion: String?
    /// <p>The Amazon Resource Name (ARN) of the stream that you want to delete. </p>
    public let streamARN: String?

    public init (
        currentVersion: String? = nil,
        streamARN: String? = nil
    )
    {
        self.currentVersion = currentVersion
        self.streamARN = streamARN
    }
}

struct DeleteStreamInputBody: Equatable {
    public let streamARN: String?
    public let currentVersion: String?
}

extension DeleteStreamInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case currentVersion = "CurrentVersion"
        case streamARN = "StreamARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
    }
}

extension DeleteStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionMismatchException" : self = .versionMismatchException(try VersionMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStreamOutputError: Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case versionMismatchException(VersionMismatchException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStreamOutputResponse()"}
}

extension DeleteStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStreamOutputResponse: Equatable {

    public init() {}
}

struct DeleteStreamOutputResponseBody: Equatable {
}

extension DeleteStreamOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeSignalingChannelInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSignalingChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSignalingChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSignalingChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSignalingChannelInput>
    public typealias MOutput = OperationOutput<DescribeSignalingChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSignalingChannelOutputError>
}

extension DescribeSignalingChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSignalingChannelInput(channelARN: \(String(describing: channelARN)), channelName: \(String(describing: channelName)))"}
}

extension DescribeSignalingChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelARN = "ChannelARN"
        case channelName = "ChannelName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let channelName = channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
    }
}

public struct DescribeSignalingChannelInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSignalingChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSignalingChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSignalingChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSignalingChannelInput>
    public typealias MOutput = OperationOutput<DescribeSignalingChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSignalingChannelOutputError>
}

public struct DescribeSignalingChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSignalingChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSignalingChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSignalingChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSignalingChannelInput>
    public typealias MOutput = OperationOutput<DescribeSignalingChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSignalingChannelOutputError>
}

public struct DescribeSignalingChannelInput: Equatable {
    /// <p>The ARN of the signaling channel that you want to describe.</p>
    public let channelARN: String?
    /// <p>The name of the signaling channel that you want to describe.</p>
    public let channelName: String?

    public init (
        channelARN: String? = nil,
        channelName: String? = nil
    )
    {
        self.channelARN = channelARN
        self.channelName = channelName
    }
}

struct DescribeSignalingChannelInputBody: Equatable {
    public let channelName: String?
    public let channelARN: String?
}

extension DescribeSignalingChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channelARN = "ChannelARN"
        case channelName = "ChannelName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
    }
}

extension DescribeSignalingChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSignalingChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSignalingChannelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSignalingChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSignalingChannelOutputResponse(channelInfo: \(String(describing: channelInfo)))"}
}

extension DescribeSignalingChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSignalingChannelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.channelInfo = output.channelInfo
        } else {
            self.channelInfo = nil
        }
    }
}

public struct DescribeSignalingChannelOutputResponse: Equatable {
    /// <p>A structure that encapsulates the specified signaling channel's metadata and
    ///             properties.</p>
    public let channelInfo: ChannelInfo?

    public init (
        channelInfo: ChannelInfo? = nil
    )
    {
        self.channelInfo = channelInfo
    }
}

struct DescribeSignalingChannelOutputResponseBody: Equatable {
    public let channelInfo: ChannelInfo?
}

extension DescribeSignalingChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channelInfo = "ChannelInfo"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelInfoDecoded = try containerValues.decodeIfPresent(ChannelInfo.self, forKey: .channelInfo)
        channelInfo = channelInfoDecoded
    }
}

public struct DescribeStreamInputBodyMiddleware: Middleware {
    public let id: String = "DescribeStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStreamInput>
    public typealias MOutput = OperationOutput<DescribeStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStreamOutputError>
}

extension DescribeStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStreamInput(streamARN: \(String(describing: streamARN)), streamName: \(String(describing: streamName)))"}
}

extension DescribeStreamInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct DescribeStreamInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStreamInput>
    public typealias MOutput = OperationOutput<DescribeStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStreamOutputError>
}

public struct DescribeStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStreamInput>
    public typealias MOutput = OperationOutput<DescribeStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStreamOutputError>
}

public struct DescribeStreamInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the stream.</p>
    public let streamARN: String?
    /// <p>The name of the stream.</p>
    public let streamName: String?

    public init (
        streamARN: String? = nil,
        streamName: String? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct DescribeStreamInputBody: Equatable {
    public let streamName: String?
    public let streamARN: String?
}

extension DescribeStreamInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
    }
}

extension DescribeStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStreamOutputError: Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStreamOutputResponse(streamInfo: \(String(describing: streamInfo)))"}
}

extension DescribeStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeStreamOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.streamInfo = output.streamInfo
        } else {
            self.streamInfo = nil
        }
    }
}

public struct DescribeStreamOutputResponse: Equatable {
    /// <p>An object that describes the stream.</p>
    public let streamInfo: StreamInfo?

    public init (
        streamInfo: StreamInfo? = nil
    )
    {
        self.streamInfo = streamInfo
    }
}

struct DescribeStreamOutputResponseBody: Equatable {
    public let streamInfo: StreamInfo?
}

extension DescribeStreamOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamInfo = "StreamInfo"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamInfoDecoded = try containerValues.decodeIfPresent(StreamInfo.self, forKey: .streamInfo)
        streamInfo = streamInfoDecoded
    }
}

extension DeviceStreamLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceStreamLimitExceededException(message: \(String(describing: message)))"}
}

extension DeviceStreamLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeviceStreamLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Not implemented.
///             </p>
public struct DeviceStreamLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DeviceStreamLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension DeviceStreamLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GetDataEndpointInputBodyMiddleware: Middleware {
    public let id: String = "GetDataEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDataEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDataEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDataEndpointInput>
    public typealias MOutput = OperationOutput<GetDataEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDataEndpointOutputError>
}

extension GetDataEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDataEndpointInput(aPIName: \(String(describing: aPIName)), streamARN: \(String(describing: streamARN)), streamName: \(String(describing: streamName)))"}
}

extension GetDataEndpointInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aPIName = "APIName"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aPIName = aPIName {
            try encodeContainer.encode(aPIName.rawValue, forKey: .aPIName)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct GetDataEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "GetDataEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDataEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDataEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDataEndpointInput>
    public typealias MOutput = OperationOutput<GetDataEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDataEndpointOutputError>
}

public struct GetDataEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDataEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDataEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDataEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDataEndpointInput>
    public typealias MOutput = OperationOutput<GetDataEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDataEndpointOutputError>
}

public struct GetDataEndpointInput: Equatable {
    /// <p>The name of the API action for which to get an endpoint.</p>
    public let aPIName: APIName?
    /// <p>The Amazon Resource Name (ARN) of the stream that you want to get the endpoint for.
    ///             You must specify either this parameter or a <code>StreamName</code> in the request.
    ///         </p>
    public let streamARN: String?
    /// <p>The name of the stream that you want to get the endpoint for. You must specify
    ///             either this parameter or a <code>StreamARN</code> in the request.</p>
    public let streamName: String?

    public init (
        aPIName: APIName? = nil,
        streamARN: String? = nil,
        streamName: String? = nil
    )
    {
        self.aPIName = aPIName
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct GetDataEndpointInputBody: Equatable {
    public let streamName: String?
    public let streamARN: String?
    public let aPIName: APIName?
}

extension GetDataEndpointInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aPIName = "APIName"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let aPINameDecoded = try containerValues.decodeIfPresent(APIName.self, forKey: .aPIName)
        aPIName = aPINameDecoded
    }
}

extension GetDataEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDataEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDataEndpointOutputError: Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDataEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDataEndpointOutputResponse(dataEndpoint: \(String(describing: dataEndpoint)))"}
}

extension GetDataEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDataEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataEndpoint = output.dataEndpoint
        } else {
            self.dataEndpoint = nil
        }
    }
}

public struct GetDataEndpointOutputResponse: Equatable {
    /// <p>The endpoint value. To read data from the stream or to write data to it, specify
    ///             this endpoint in your application.</p>
    public let dataEndpoint: String?

    public init (
        dataEndpoint: String? = nil
    )
    {
        self.dataEndpoint = dataEndpoint
    }
}

struct GetDataEndpointOutputResponseBody: Equatable {
    public let dataEndpoint: String?
}

extension GetDataEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataEndpoint = "DataEndpoint"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataEndpoint)
        dataEndpoint = dataEndpointDecoded
    }
}

public struct GetSignalingChannelEndpointInputBodyMiddleware: Middleware {
    public let id: String = "GetSignalingChannelEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSignalingChannelEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSignalingChannelEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSignalingChannelEndpointInput>
    public typealias MOutput = OperationOutput<GetSignalingChannelEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSignalingChannelEndpointOutputError>
}

extension GetSignalingChannelEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSignalingChannelEndpointInput(channelARN: \(String(describing: channelARN)), singleMasterChannelEndpointConfiguration: \(String(describing: singleMasterChannelEndpointConfiguration)))"}
}

extension GetSignalingChannelEndpointInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelARN = "ChannelARN"
        case singleMasterChannelEndpointConfiguration = "SingleMasterChannelEndpointConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let singleMasterChannelEndpointConfiguration = singleMasterChannelEndpointConfiguration {
            try encodeContainer.encode(singleMasterChannelEndpointConfiguration, forKey: .singleMasterChannelEndpointConfiguration)
        }
    }
}

public struct GetSignalingChannelEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "GetSignalingChannelEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSignalingChannelEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSignalingChannelEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSignalingChannelEndpointInput>
    public typealias MOutput = OperationOutput<GetSignalingChannelEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSignalingChannelEndpointOutputError>
}

public struct GetSignalingChannelEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSignalingChannelEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSignalingChannelEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSignalingChannelEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSignalingChannelEndpointInput>
    public typealias MOutput = OperationOutput<GetSignalingChannelEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSignalingChannelEndpointOutputError>
}

public struct GetSignalingChannelEndpointInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the signalling channel for which you want to get an
    ///             endpoint.</p>
    public let channelARN: String?
    /// <p>A structure containing the endpoint configuration for the <code>SINGLE_MASTER</code>
    ///             channel type.</p>
    public let singleMasterChannelEndpointConfiguration: SingleMasterChannelEndpointConfiguration?

    public init (
        channelARN: String? = nil,
        singleMasterChannelEndpointConfiguration: SingleMasterChannelEndpointConfiguration? = nil
    )
    {
        self.channelARN = channelARN
        self.singleMasterChannelEndpointConfiguration = singleMasterChannelEndpointConfiguration
    }
}

struct GetSignalingChannelEndpointInputBody: Equatable {
    public let channelARN: String?
    public let singleMasterChannelEndpointConfiguration: SingleMasterChannelEndpointConfiguration?
}

extension GetSignalingChannelEndpointInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channelARN = "ChannelARN"
        case singleMasterChannelEndpointConfiguration = "SingleMasterChannelEndpointConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
        let singleMasterChannelEndpointConfigurationDecoded = try containerValues.decodeIfPresent(SingleMasterChannelEndpointConfiguration.self, forKey: .singleMasterChannelEndpointConfiguration)
        singleMasterChannelEndpointConfiguration = singleMasterChannelEndpointConfigurationDecoded
    }
}

extension GetSignalingChannelEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSignalingChannelEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSignalingChannelEndpointOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSignalingChannelEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSignalingChannelEndpointOutputResponse(resourceEndpointList: \(String(describing: resourceEndpointList)))"}
}

extension GetSignalingChannelEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSignalingChannelEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resourceEndpointList = output.resourceEndpointList
        } else {
            self.resourceEndpointList = nil
        }
    }
}

public struct GetSignalingChannelEndpointOutputResponse: Equatable {
    /// <p>A list of endpoints for the specified signaling channel.</p>
    public let resourceEndpointList: [ResourceEndpointListItem]?

    public init (
        resourceEndpointList: [ResourceEndpointListItem]? = nil
    )
    {
        self.resourceEndpointList = resourceEndpointList
    }
}

struct GetSignalingChannelEndpointOutputResponseBody: Equatable {
    public let resourceEndpointList: [ResourceEndpointListItem]?
}

extension GetSignalingChannelEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceEndpointList = "ResourceEndpointList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceEndpointListContainer = try containerValues.decodeIfPresent([ResourceEndpointListItem?].self, forKey: .resourceEndpointList)
        var resourceEndpointListDecoded0:[ResourceEndpointListItem]? = nil
        if let resourceEndpointListContainer = resourceEndpointListContainer {
            resourceEndpointListDecoded0 = [ResourceEndpointListItem]()
            for structure0 in resourceEndpointListContainer {
                if let structure0 = structure0 {
                    resourceEndpointListDecoded0?.append(structure0)
                }
            }
        }
        resourceEndpointList = resourceEndpointListDecoded0
    }
}

extension InvalidArgumentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidArgumentException(message: \(String(describing: message)))"}
}

extension InvalidArgumentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value for this input parameter is invalid.</p>
public struct InvalidArgumentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentExceptionBody: Equatable {
    public let message: String?
}

extension InvalidArgumentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDeviceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDeviceException(message: \(String(describing: message)))"}
}

extension InvalidDeviceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidDeviceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Not implemented.</p>
public struct InvalidDeviceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDeviceExceptionBody: Equatable {
    public let message: String?
}

extension InvalidDeviceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceFormatException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidResourceFormatException(message: \(String(describing: message)))"}
}

extension InvalidResourceFormatException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidResourceFormatExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The format of the <code>StreamARN</code> is invalid.</p>
public struct InvalidResourceFormatException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResourceFormatExceptionBody: Equatable {
    public let message: String?
}

extension InvalidResourceFormatExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListSignalingChannelsInputBodyMiddleware: Middleware {
    public let id: String = "ListSignalingChannelsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSignalingChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSignalingChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSignalingChannelsInput>
    public typealias MOutput = OperationOutput<ListSignalingChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSignalingChannelsOutputError>
}

extension ListSignalingChannelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSignalingChannelsInput(channelNameCondition: \(String(describing: channelNameCondition)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSignalingChannelsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelNameCondition = "ChannelNameCondition"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelNameCondition = channelNameCondition {
            try encodeContainer.encode(channelNameCondition, forKey: .channelNameCondition)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListSignalingChannelsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSignalingChannelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSignalingChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSignalingChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSignalingChannelsInput>
    public typealias MOutput = OperationOutput<ListSignalingChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSignalingChannelsOutputError>
}

public struct ListSignalingChannelsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSignalingChannelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSignalingChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSignalingChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSignalingChannelsInput>
    public typealias MOutput = OperationOutput<ListSignalingChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSignalingChannelsOutputError>
}

public struct ListSignalingChannelsInput: Equatable {
    /// <p>Optional: Returns only the channels that satisfy a specific condition.</p>
    public let channelNameCondition: ChannelNameCondition?
    /// <p>The maximum number of channels to return in the response. The default is 500.</p>
    public let maxResults: Int?
    /// <p>If you specify this parameter, when the result of a <code>ListSignalingChannels</code>
    ///             operation is truncated, the call returns the <code>NextToken</code> in the response. To
    ///             get another batch of channels, provide this token in your next request.</p>
    public let nextToken: String?

    public init (
        channelNameCondition: ChannelNameCondition? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.channelNameCondition = channelNameCondition
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSignalingChannelsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
    public let channelNameCondition: ChannelNameCondition?
}

extension ListSignalingChannelsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channelNameCondition = "ChannelNameCondition"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let channelNameConditionDecoded = try containerValues.decodeIfPresent(ChannelNameCondition.self, forKey: .channelNameCondition)
        channelNameCondition = channelNameConditionDecoded
    }
}

extension ListSignalingChannelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSignalingChannelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSignalingChannelsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSignalingChannelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSignalingChannelsOutputResponse(channelInfoList: \(String(describing: channelInfoList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSignalingChannelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSignalingChannelsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.channelInfoList = output.channelInfoList
            self.nextToken = output.nextToken
        } else {
            self.channelInfoList = nil
            self.nextToken = nil
        }
    }
}

public struct ListSignalingChannelsOutputResponse: Equatable {
    /// <p>An array of <code>ChannelInfo</code> objects.</p>
    public let channelInfoList: [ChannelInfo]?
    /// <p>If the response is truncated, the call returns this element with a token. To get the
    ///             next batch of streams, use this token in your next request.</p>
    public let nextToken: String?

    public init (
        channelInfoList: [ChannelInfo]? = nil,
        nextToken: String? = nil
    )
    {
        self.channelInfoList = channelInfoList
        self.nextToken = nextToken
    }
}

struct ListSignalingChannelsOutputResponseBody: Equatable {
    public let channelInfoList: [ChannelInfo]?
    public let nextToken: String?
}

extension ListSignalingChannelsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channelInfoList = "ChannelInfoList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelInfoListContainer = try containerValues.decodeIfPresent([ChannelInfo?].self, forKey: .channelInfoList)
        var channelInfoListDecoded0:[ChannelInfo]? = nil
        if let channelInfoListContainer = channelInfoListContainer {
            channelInfoListDecoded0 = [ChannelInfo]()
            for structure0 in channelInfoListContainer {
                if let structure0 = structure0 {
                    channelInfoListDecoded0?.append(structure0)
                }
            }
        }
        channelInfoList = channelInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListStreamsInputBodyMiddleware: Middleware {
    public let id: String = "ListStreamsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamsInput>
    public typealias MOutput = OperationOutput<ListStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamsOutputError>
}

extension ListStreamsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStreamsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), streamNameCondition: \(String(describing: streamNameCondition)))"}
}

extension ListStreamsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case streamNameCondition = "StreamNameCondition"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let streamNameCondition = streamNameCondition {
            try encodeContainer.encode(streamNameCondition, forKey: .streamNameCondition)
        }
    }
}

public struct ListStreamsInputHeadersMiddleware: Middleware {
    public let id: String = "ListStreamsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamsInput>
    public typealias MOutput = OperationOutput<ListStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamsOutputError>
}

public struct ListStreamsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListStreamsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamsInput>
    public typealias MOutput = OperationOutput<ListStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamsOutputError>
}

public struct ListStreamsInput: Equatable {
    /// <p>The maximum number of streams to return in the response. The default is
    ///             10,000.</p>
    public let maxResults: Int?
    /// <p>If you specify this parameter, when the result of a <code>ListStreams</code>
    ///             operation is truncated, the call returns the <code>NextToken</code> in the response. To
    ///             get another batch of streams, provide this token in your next request.</p>
    public let nextToken: String?
    /// <p>Optional: Returns only streams that satisfy a specific condition. Currently, you
    ///             can specify only the prefix of a stream name as a condition. </p>
    public let streamNameCondition: StreamNameCondition?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        streamNameCondition: StreamNameCondition? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.streamNameCondition = streamNameCondition
    }
}

struct ListStreamsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
    public let streamNameCondition: StreamNameCondition?
}

extension ListStreamsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case streamNameCondition = "StreamNameCondition"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let streamNameConditionDecoded = try containerValues.decodeIfPresent(StreamNameCondition.self, forKey: .streamNameCondition)
        streamNameCondition = streamNameConditionDecoded
    }
}

extension ListStreamsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStreamsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStreamsOutputError: Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStreamsOutputResponse(nextToken: \(String(describing: nextToken)), streamInfoList: \(String(describing: streamInfoList)))"}
}

extension ListStreamsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListStreamsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.streamInfoList = output.streamInfoList
        } else {
            self.nextToken = nil
            self.streamInfoList = nil
        }
    }
}

public struct ListStreamsOutputResponse: Equatable {
    /// <p>If the response is truncated, the call returns this element with a token. To get
    ///             the next batch of streams, use this token in your next request. </p>
    public let nextToken: String?
    /// <p>An array of <code>StreamInfo</code> objects.</p>
    public let streamInfoList: [StreamInfo]?

    public init (
        nextToken: String? = nil,
        streamInfoList: [StreamInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.streamInfoList = streamInfoList
    }
}

struct ListStreamsOutputResponseBody: Equatable {
    public let streamInfoList: [StreamInfo]?
    public let nextToken: String?
}

extension ListStreamsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case streamInfoList = "StreamInfoList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamInfoListContainer = try containerValues.decodeIfPresent([StreamInfo?].self, forKey: .streamInfoList)
        var streamInfoListDecoded0:[StreamInfo]? = nil
        if let streamInfoListContainer = streamInfoListContainer {
            streamInfoListDecoded0 = [StreamInfo]()
            for structure0 in streamInfoListContainer {
                if let structure0 = structure0 {
                    streamInfoListDecoded0?.append(structure0)
                }
            }
        }
        streamInfoList = streamInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(nextToken: \(String(describing: nextToken)), resourceARN: \(String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>If you specify this parameter and the result of a <code>ListTagsForResource</code>
    ///             call is truncated, the response includes a token that you can use in the next request to
    ///             fetch the next batch of tags. </p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of the signaling channel for which you want to list
    ///             tags.</p>
    public let resourceARN: String?

    public init (
        nextToken: String? = nil,
        resourceARN: String? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let nextToken: String?
    public let resourceARN: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>If you specify this parameter and the result of a <code>ListTagsForResource</code>
    ///             call is truncated, the response includes a token that you can use in the next request to
    ///             fetch the next set of tags. </p>
    public let nextToken: String?
    /// <p>A map of tag keys and values associated with the specified signaling channel.</p>
    public let tags: [String:String]?

    public init (
        nextToken: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let nextToken: String?
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct ListTagsForStreamInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForStreamInput>
    public typealias MOutput = OperationOutput<ListTagsForStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForStreamOutputError>
}

extension ListTagsForStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForStreamInput(nextToken: \(String(describing: nextToken)), streamARN: \(String(describing: streamARN)), streamName: \(String(describing: streamName)))"}
}

extension ListTagsForStreamInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct ListTagsForStreamInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForStreamInput>
    public typealias MOutput = OperationOutput<ListTagsForStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForStreamOutputError>
}

public struct ListTagsForStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForStreamInput>
    public typealias MOutput = OperationOutput<ListTagsForStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForStreamOutputError>
}

public struct ListTagsForStreamInput: Equatable {
    /// <p>If you specify this parameter and the result of a <code>ListTagsForStream</code>
    ///             call is truncated, the response includes a token that you can use in the next request to
    ///             fetch the next batch of tags.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of the stream that you want to list tags
    ///             for.</p>
    public let streamARN: String?
    /// <p>The name of the stream that you want to list tags for.</p>
    public let streamName: String?

    public init (
        nextToken: String? = nil,
        streamARN: String? = nil,
        streamName: String? = nil
    )
    {
        self.nextToken = nextToken
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct ListTagsForStreamInputBody: Equatable {
    public let nextToken: String?
    public let streamARN: String?
    public let streamName: String?
}

extension ListTagsForStreamInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
    }
}

extension ListTagsForStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceFormatException" : self = .invalidResourceFormatException(try InvalidResourceFormatException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForStreamOutputError: Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidResourceFormatException(InvalidResourceFormatException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForStreamOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsForStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForStreamOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForStreamOutputResponse: Equatable {
    /// <p>If you specify this parameter and the result of a <code>ListTags</code> call is
    ///             truncated, the response includes a token that you can use in the next request to fetch
    ///             the next set of tags.</p>
    public let nextToken: String?
    /// <p>A map of tag keys and values associated with the specified stream.</p>
    public let tags: [String:String]?

    public init (
        nextToken: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForStreamOutputResponseBody: Equatable {
    public let nextToken: String?
    public let tags: [String:String]?
}

extension ListTagsForStreamOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NotAuthorizedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotAuthorizedException(message: \(String(describing: message)))"}
}

extension NotAuthorizedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotAuthorizedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The caller is not authorized to perform this operation.</p>
public struct NotAuthorizedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotAuthorizedExceptionBody: Equatable {
    public let message: String?
}

extension NotAuthorizedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceEndpointListItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case `protocol` = "Protocol"
        case resourceEndpoint = "ResourceEndpoint"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let resourceEndpoint = resourceEndpoint {
            try encodeContainer.encode(resourceEndpoint, forKey: .resourceEndpoint)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolDecoded = try containerValues.decodeIfPresent(ChannelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let resourceEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceEndpoint)
        resourceEndpoint = resourceEndpointDecoded
    }
}

extension ResourceEndpointListItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceEndpointListItem(protocol: \(String(describing: `protocol`)), resourceEndpoint: \(String(describing: resourceEndpoint)))"}
}

/// <p>An object that describes the endpoint of the signaling channel returned by the
///                 <code>GetSignalingChannelEndpoint</code> API.</p>
public struct ResourceEndpointListItem: Equatable {
    /// <p>The protocol of the signaling channel returned by the
    ///                 <code>GetSignalingChannelEndpoint</code> API.</p>
    public let `protocol`: ChannelProtocol?
    /// <p>The endpoint of the signaling channel returned by the
    ///                 <code>GetSignalingChannelEndpoint</code> API.</p>
    public let resourceEndpoint: String?

    public init (
        `protocol`: ChannelProtocol? = nil,
        resourceEndpoint: String? = nil
    )
    {
        self.`protocol` = `protocol`
        self.resourceEndpoint = resourceEndpoint
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The signaling channel is currently not available for this operation.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Amazon Kinesis Video Streams can't find the stream that you specified.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SingleMasterChannelEndpointConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case protocols = "Protocols"
        case role = "Role"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for listofprotocols0 in protocols {
                try protocolsContainer.encode(listofprotocols0.rawValue)
            }
        }
        if let role = role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolsContainer = try containerValues.decodeIfPresent([ChannelProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[ChannelProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [ChannelProtocol]()
            for string0 in protocolsContainer {
                if let string0 = string0 {
                    protocolsDecoded0?.append(string0)
                }
            }
        }
        protocols = protocolsDecoded0
        let roleDecoded = try containerValues.decodeIfPresent(ChannelRole.self, forKey: .role)
        role = roleDecoded
    }
}

extension SingleMasterChannelEndpointConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SingleMasterChannelEndpointConfiguration(protocols: \(String(describing: protocols)), role: \(String(describing: role)))"}
}

/// <p>An object that contains the endpoint configuration for the <code>SINGLE_MASTER</code>
///             channel type. </p>
public struct SingleMasterChannelEndpointConfiguration: Equatable {
    /// <p>This property is used to determine the nature of communication over this
    ///                 <code>SINGLE_MASTER</code> signaling channel. If <code>WSS</code> is specified, this
    ///             API returns a websocket endpoint. If <code>HTTPS</code> is specified, this API returns
    ///             an <code>HTTPS</code> endpoint.</p>
    public let protocols: [ChannelProtocol]?
    /// <p>This property is used to determine messaging permissions in this
    ///                 <code>SINGLE_MASTER</code> signaling channel. If <code>MASTER</code> is specified,
    ///             this API returns an endpoint that a client can use to receive offers from and send
    ///             answers to any of the viewers on this signaling channel. If <code>VIEWER</code> is
    ///             specified, this API returns an endpoint that a client can use only to send offers to
    ///             another <code>MASTER</code> client on this signaling channel. </p>
    public let role: ChannelRole?

    public init (
        protocols: [ChannelProtocol]? = nil,
        role: ChannelRole? = nil
    )
    {
        self.protocols = protocols
        self.role = role
    }
}

extension SingleMasterConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case messageTtlSeconds = "MessageTtlSeconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageTtlSeconds = messageTtlSeconds {
            try encodeContainer.encode(messageTtlSeconds, forKey: .messageTtlSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageTtlSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .messageTtlSeconds)
        messageTtlSeconds = messageTtlSecondsDecoded
    }
}

extension SingleMasterConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SingleMasterConfiguration(messageTtlSeconds: \(String(describing: messageTtlSeconds)))"}
}

/// <p>A structure that contains the configuration for the <code>SINGLE_MASTER</code> channel
///             type.</p>
public struct SingleMasterConfiguration: Equatable {
    /// <p>The period of time a signaling channel retains underlivered messages before they are
    ///             discarded.</p>
    public let messageTtlSeconds: Int?

    public init (
        messageTtlSeconds: Int? = nil
    )
    {
        self.messageTtlSeconds = messageTtlSeconds
    }
}

public enum Status {
    case active
    case creating
    case deleting
    case updating
    case sdkUnknown(String)
}

extension Status : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Status] {
        return [
            .active,
            .creating,
            .deleting,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
    }
}

extension StreamInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case dataRetentionInHours = "DataRetentionInHours"
        case deviceName = "DeviceName"
        case kmsKeyId = "KmsKeyId"
        case mediaType = "MediaType"
        case status = "Status"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let dataRetentionInHours = dataRetentionInHours {
            try encodeContainer.encode(dataRetentionInHours, forKey: .dataRetentionInHours)
        }
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let mediaType = mediaType {
            try encodeContainer.encode(mediaType, forKey: .mediaType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let mediaTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mediaType)
        mediaType = mediaTypeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let dataRetentionInHoursDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .dataRetentionInHours)
        dataRetentionInHours = dataRetentionInHoursDecoded
    }
}

extension StreamInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamInfo(creationTime: \(String(describing: creationTime)), dataRetentionInHours: \(String(describing: dataRetentionInHours)), deviceName: \(String(describing: deviceName)), kmsKeyId: \(String(describing: kmsKeyId)), mediaType: \(String(describing: mediaType)), status: \(String(describing: status)), streamARN: \(String(describing: streamARN)), streamName: \(String(describing: streamName)), version: \(String(describing: version)))"}
}

/// <p>An object describing a Kinesis video stream.</p>
public struct StreamInfo: Equatable {
    /// <p>A time stamp that indicates when the stream was created.</p>
    public let creationTime: Date?
    /// <p>How long the stream retains data, in hours.</p>
    public let dataRetentionInHours: Int?
    /// <p>The name of the device that is associated with the stream.</p>
    public let deviceName: String?
    /// <p>The ID of the AWS Key Management Service (AWS KMS) key that Kinesis Video Streams
    ///             uses to encrypt data on the stream.</p>
    public let kmsKeyId: String?
    /// <p>The <code>MediaType</code> of the stream. </p>
    public let mediaType: String?
    /// <p>The status of the stream.</p>
    public let status: Status?
    /// <p>The Amazon Resource Name (ARN) of the stream.</p>
    public let streamARN: String?
    /// <p>The name of the stream.</p>
    public let streamName: String?
    /// <p>The version of the stream.</p>
    public let version: String?

    public init (
        creationTime: Date? = nil,
        dataRetentionInHours: Int? = nil,
        deviceName: String? = nil,
        kmsKeyId: String? = nil,
        mediaType: String? = nil,
        status: Status? = nil,
        streamARN: String? = nil,
        streamName: String? = nil,
        version: String? = nil
    )
    {
        self.creationTime = creationTime
        self.dataRetentionInHours = dataRetentionInHours
        self.deviceName = deviceName
        self.kmsKeyId = kmsKeyId
        self.mediaType = mediaType
        self.status = status
        self.streamARN = streamARN
        self.streamName = streamName
        self.version = version
    }
}

extension StreamNameCondition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comparisonOperator = "ComparisonOperator"
        case comparisonValue = "ComparisonValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let comparisonValue = comparisonValue {
            try encodeContainer.encode(comparisonValue, forKey: .comparisonValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let comparisonValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comparisonValue)
        comparisonValue = comparisonValueDecoded
    }
}

extension StreamNameCondition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamNameCondition(comparisonOperator: \(String(describing: comparisonOperator)), comparisonValue: \(String(describing: comparisonValue)))"}
}

/// <p>Specifies the condition that streams must satisfy to be returned when you list
///             streams (see the <code>ListStreams</code> API). A condition has a comparison operation
///             and a value. Currently, you can specify only the <code>BEGINS_WITH</code> operator,
///             which finds streams whose names start with a given prefix. </p>
public struct StreamNameCondition: Equatable {
    /// <p>A comparison operator. Currently, you can specify only the <code>BEGINS_WITH</code>
    ///             operator, which finds streams whose names start with a given prefix.</p>
    public let comparisonOperator: ComparisonOperator?
    /// <p>A value to compare.</p>
    public let comparisonValue: String?

    public init (
        comparisonOperator: ComparisonOperator? = nil,
        comparisonValue: String? = nil
    )
    {
        self.comparisonOperator = comparisonOperator
        self.comparisonValue = comparisonValue
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A key and value pair that is associated with the specified signaling channel.</p>
public struct Tag: Equatable {
    /// <p>The key of the tag that is associated with the specified signaling channel.</p>
    public let key: String?
    /// <p>The value of the tag that is associated with the specified signaling channel.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceARN: \(String(describing: resourceARN)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the signaling channel to which you want to add
    ///             tags.</p>
    public let resourceARN: String?
    /// <p>A list of tags to associate with the specified signaling channel. Each tag is a
    ///             key-value pair.</p>
    public let tags: [Tag]?

    public init (
        resourceARN: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagsPerResourceExceededLimitException" : self = .tagsPerResourceExceededLimitException(try TagsPerResourceExceededLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagsPerResourceExceededLimitException(TagsPerResourceExceededLimitException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct TagStreamInputBodyMiddleware: Middleware {
    public let id: String = "TagStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<TagStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagStreamInput>
    public typealias MOutput = OperationOutput<TagStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagStreamOutputError>
}

extension TagStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagStreamInput(streamARN: \(String(describing: streamARN)), streamName: \(String(describing: streamName)), tags: \(String(describing: tags)))"}
}

extension TagStreamInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, resourcetags0) in tags {
                try tagsContainer.encode(resourcetags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagStreamInputHeadersMiddleware: Middleware {
    public let id: String = "TagStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<TagStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagStreamInput>
    public typealias MOutput = OperationOutput<TagStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagStreamOutputError>
}

public struct TagStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "TagStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<TagStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagStreamInput>
    public typealias MOutput = OperationOutput<TagStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagStreamOutputError>
}

public struct TagStreamInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to add the tag or tags
    ///             to.</p>
    public let streamARN: String?
    /// <p>The name of the stream that you want to add the tag or tags to.</p>
    public let streamName: String?
    /// <p>A list of tags to associate with the specified stream. Each tag is a key-value pair
    ///             (the value is optional).</p>
    public let tags: [String:String]?

    public init (
        streamARN: String? = nil,
        streamName: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
        self.tags = tags
    }
}

struct TagStreamInputBody: Equatable {
    public let streamARN: String?
    public let streamName: String?
    public let tags: [String:String]?
}

extension TagStreamInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceFormatException" : self = .invalidResourceFormatException(try InvalidResourceFormatException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagsPerResourceExceededLimitException" : self = .tagsPerResourceExceededLimitException(try TagsPerResourceExceededLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagStreamOutputError: Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidResourceFormatException(InvalidResourceFormatException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagsPerResourceExceededLimitException(TagsPerResourceExceededLimitException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagStreamOutputResponse()"}
}

extension TagStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagStreamOutputResponse: Equatable {

    public init() {}
}

struct TagStreamOutputResponseBody: Equatable {
}

extension TagStreamOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TagsPerResourceExceededLimitException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagsPerResourceExceededLimitException(message: \(String(describing: message)))"}
}

extension TagsPerResourceExceededLimitException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TagsPerResourceExceededLimitExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the limit of tags that you can associate with the resource.
///             Kinesis video streams support up to 50 tags. </p>
public struct TagsPerResourceExceededLimitException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TagsPerResourceExceededLimitExceptionBody: Equatable {
    public let message: String?
}

extension TagsPerResourceExceededLimitExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceARN: \(String(describing: resourceARN)), tagKeyList: \(String(describing: tagKeyList)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeyList = "TagKeyList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeyList = tagKeyList {
            var tagKeyListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeyList)
            for tagkeylist0 in tagKeyList {
                try tagKeyListContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the signaling channel from which you want to remove
    ///             tags.</p>
    public let resourceARN: String?
    /// <p>A list of the keys of the tags that you want to remove.</p>
    public let tagKeyList: [String]?

    public init (
        resourceARN: String? = nil,
        tagKeyList: [String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeyList = tagKeyList
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tagKeyList: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeyList = "TagKeyList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeyListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeyList)
        var tagKeyListDecoded0:[String]? = nil
        if let tagKeyListContainer = tagKeyListContainer {
            tagKeyListDecoded0 = [String]()
            for string0 in tagKeyListContainer {
                if let string0 = string0 {
                    tagKeyListDecoded0?.append(string0)
                }
            }
        }
        tagKeyList = tagKeyListDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UntagStreamInputBodyMiddleware: Middleware {
    public let id: String = "UntagStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagStreamInput>
    public typealias MOutput = OperationOutput<UntagStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagStreamOutputError>
}

extension UntagStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagStreamInput(streamARN: \(String(describing: streamARN)), streamName: \(String(describing: streamName)), tagKeyList: \(String(describing: tagKeyList)))"}
}

extension UntagStreamInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
        case tagKeyList = "TagKeyList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let tagKeyList = tagKeyList {
            var tagKeyListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeyList)
            for tagkeylist0 in tagKeyList {
                try tagKeyListContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagStreamInputHeadersMiddleware: Middleware {
    public let id: String = "UntagStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagStreamInput>
    public typealias MOutput = OperationOutput<UntagStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagStreamOutputError>
}

public struct UntagStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagStreamInput>
    public typealias MOutput = OperationOutput<UntagStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagStreamOutputError>
}

public struct UntagStreamInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the stream that you want to remove tags
    ///             from.</p>
    public let streamARN: String?
    /// <p>The name of the stream that you want to remove tags from.</p>
    public let streamName: String?
    /// <p>A list of the keys of the tags that you want to remove.</p>
    public let tagKeyList: [String]?

    public init (
        streamARN: String? = nil,
        streamName: String? = nil,
        tagKeyList: [String]? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
        self.tagKeyList = tagKeyList
    }
}

struct UntagStreamInputBody: Equatable {
    public let streamARN: String?
    public let streamName: String?
    public let tagKeyList: [String]?
}

extension UntagStreamInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
        case tagKeyList = "TagKeyList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let tagKeyListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeyList)
        var tagKeyListDecoded0:[String]? = nil
        if let tagKeyListContainer = tagKeyListContainer {
            tagKeyListDecoded0 = [String]()
            for string0 in tagKeyListContainer {
                if let string0 = string0 {
                    tagKeyListDecoded0?.append(string0)
                }
            }
        }
        tagKeyList = tagKeyListDecoded0
    }
}

extension UntagStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceFormatException" : self = .invalidResourceFormatException(try InvalidResourceFormatException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagStreamOutputError: Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidResourceFormatException(InvalidResourceFormatException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagStreamOutputResponse()"}
}

extension UntagStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagStreamOutputResponse: Equatable {

    public init() {}
}

struct UntagStreamOutputResponseBody: Equatable {
}

extension UntagStreamOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDataRetentionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDataRetentionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataRetentionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataRetentionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataRetentionInput>
    public typealias MOutput = OperationOutput<UpdateDataRetentionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataRetentionOutputError>
}

extension UpdateDataRetentionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDataRetentionInput(currentVersion: \(String(describing: currentVersion)), dataRetentionChangeInHours: \(String(describing: dataRetentionChangeInHours)), operation: \(String(describing: operation)), streamARN: \(String(describing: streamARN)), streamName: \(String(describing: streamName)))"}
}

extension UpdateDataRetentionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentVersion = "CurrentVersion"
        case dataRetentionChangeInHours = "DataRetentionChangeInHours"
        case operation = "Operation"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let dataRetentionChangeInHours = dataRetentionChangeInHours {
            try encodeContainer.encode(dataRetentionChangeInHours, forKey: .dataRetentionChangeInHours)
        }
        if let operation = operation {
            try encodeContainer.encode(operation.rawValue, forKey: .operation)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct UpdateDataRetentionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDataRetentionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataRetentionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataRetentionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataRetentionInput>
    public typealias MOutput = OperationOutput<UpdateDataRetentionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataRetentionOutputError>
}

public struct UpdateDataRetentionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDataRetentionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataRetentionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataRetentionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataRetentionInput>
    public typealias MOutput = OperationOutput<UpdateDataRetentionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataRetentionOutputError>
}

public struct UpdateDataRetentionInput: Equatable {
    /// <p>The version of the stream whose retention period you want to change. To get the
    ///             version, call either the <code>DescribeStream</code> or the <code>ListStreams</code>
    ///             API.</p>
    public let currentVersion: String?
    /// <p>The retention period, in hours. The value you specify replaces the current value.
    ///             The maximum value for this parameter is 87600 (ten years).</p>
    public let dataRetentionChangeInHours: Int?
    /// <p>Indicates whether you want to increase or decrease the retention period.</p>
    public let operation: UpdateDataRetentionOperation?
    /// <p>The Amazon Resource Name (ARN) of the stream whose retention period you want to
    ///             change.</p>
    public let streamARN: String?
    /// <p>The name of the stream whose retention period you want to change.</p>
    public let streamName: String?

    public init (
        currentVersion: String? = nil,
        dataRetentionChangeInHours: Int? = nil,
        operation: UpdateDataRetentionOperation? = nil,
        streamARN: String? = nil,
        streamName: String? = nil
    )
    {
        self.currentVersion = currentVersion
        self.dataRetentionChangeInHours = dataRetentionChangeInHours
        self.operation = operation
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct UpdateDataRetentionInputBody: Equatable {
    public let streamName: String?
    public let streamARN: String?
    public let currentVersion: String?
    public let operation: UpdateDataRetentionOperation?
    public let dataRetentionChangeInHours: Int?
}

extension UpdateDataRetentionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case currentVersion = "CurrentVersion"
        case dataRetentionChangeInHours = "DataRetentionChangeInHours"
        case operation = "Operation"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let operationDecoded = try containerValues.decodeIfPresent(UpdateDataRetentionOperation.self, forKey: .operation)
        operation = operationDecoded
        let dataRetentionChangeInHoursDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .dataRetentionChangeInHours)
        dataRetentionChangeInHours = dataRetentionChangeInHoursDecoded
    }
}

public enum UpdateDataRetentionOperation {
    case decreaseDataRetention
    case increaseDataRetention
    case sdkUnknown(String)
}

extension UpdateDataRetentionOperation : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UpdateDataRetentionOperation] {
        return [
            .decreaseDataRetention,
            .increaseDataRetention,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .decreaseDataRetention: return "DECREASE_DATA_RETENTION"
        case .increaseDataRetention: return "INCREASE_DATA_RETENTION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UpdateDataRetentionOperation(rawValue: rawValue) ?? UpdateDataRetentionOperation.sdkUnknown(rawValue)
    }
}

extension UpdateDataRetentionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDataRetentionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionMismatchException" : self = .versionMismatchException(try VersionMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDataRetentionOutputError: Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case versionMismatchException(VersionMismatchException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDataRetentionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDataRetentionOutputResponse()"}
}

extension UpdateDataRetentionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDataRetentionOutputResponse: Equatable {

    public init() {}
}

struct UpdateDataRetentionOutputResponseBody: Equatable {
}

extension UpdateDataRetentionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateSignalingChannelInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSignalingChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSignalingChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSignalingChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSignalingChannelInput>
    public typealias MOutput = OperationOutput<UpdateSignalingChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSignalingChannelOutputError>
}

extension UpdateSignalingChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSignalingChannelInput(channelARN: \(String(describing: channelARN)), currentVersion: \(String(describing: currentVersion)), singleMasterConfiguration: \(String(describing: singleMasterConfiguration)))"}
}

extension UpdateSignalingChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelARN = "ChannelARN"
        case currentVersion = "CurrentVersion"
        case singleMasterConfiguration = "SingleMasterConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let singleMasterConfiguration = singleMasterConfiguration {
            try encodeContainer.encode(singleMasterConfiguration, forKey: .singleMasterConfiguration)
        }
    }
}

public struct UpdateSignalingChannelInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSignalingChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSignalingChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSignalingChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSignalingChannelInput>
    public typealias MOutput = OperationOutput<UpdateSignalingChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSignalingChannelOutputError>
}

public struct UpdateSignalingChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSignalingChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSignalingChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSignalingChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSignalingChannelInput>
    public typealias MOutput = OperationOutput<UpdateSignalingChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSignalingChannelOutputError>
}

public struct UpdateSignalingChannelInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the signaling channel that you want to
    ///             update.</p>
    public let channelARN: String?
    /// <p>The current version of the signaling channel that you want to update.</p>
    public let currentVersion: String?
    /// <p>The structure containing the configuration for the <code>SINGLE_MASTER</code> type of
    ///             the signaling channel that you want to update. </p>
    public let singleMasterConfiguration: SingleMasterConfiguration?

    public init (
        channelARN: String? = nil,
        currentVersion: String? = nil,
        singleMasterConfiguration: SingleMasterConfiguration? = nil
    )
    {
        self.channelARN = channelARN
        self.currentVersion = currentVersion
        self.singleMasterConfiguration = singleMasterConfiguration
    }
}

struct UpdateSignalingChannelInputBody: Equatable {
    public let channelARN: String?
    public let currentVersion: String?
    public let singleMasterConfiguration: SingleMasterConfiguration?
}

extension UpdateSignalingChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channelARN = "ChannelARN"
        case currentVersion = "CurrentVersion"
        case singleMasterConfiguration = "SingleMasterConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let singleMasterConfigurationDecoded = try containerValues.decodeIfPresent(SingleMasterConfiguration.self, forKey: .singleMasterConfiguration)
        singleMasterConfiguration = singleMasterConfigurationDecoded
    }
}

extension UpdateSignalingChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSignalingChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionMismatchException" : self = .versionMismatchException(try VersionMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSignalingChannelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case versionMismatchException(VersionMismatchException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSignalingChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSignalingChannelOutputResponse()"}
}

extension UpdateSignalingChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateSignalingChannelOutputResponse: Equatable {

    public init() {}
}

struct UpdateSignalingChannelOutputResponseBody: Equatable {
}

extension UpdateSignalingChannelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateStreamInputBodyMiddleware: Middleware {
    public let id: String = "UpdateStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStreamInput>
    public typealias MOutput = OperationOutput<UpdateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStreamOutputError>
}

extension UpdateStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStreamInput(currentVersion: \(String(describing: currentVersion)), deviceName: \(String(describing: deviceName)), mediaType: \(String(describing: mediaType)), streamARN: \(String(describing: streamARN)), streamName: \(String(describing: streamName)))"}
}

extension UpdateStreamInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentVersion = "CurrentVersion"
        case deviceName = "DeviceName"
        case mediaType = "MediaType"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let mediaType = mediaType {
            try encodeContainer.encode(mediaType, forKey: .mediaType)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct UpdateStreamInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStreamInput>
    public typealias MOutput = OperationOutput<UpdateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStreamOutputError>
}

public struct UpdateStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStreamInput>
    public typealias MOutput = OperationOutput<UpdateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStreamOutputError>
}

public struct UpdateStreamInput: Equatable {
    /// <p>The version of the stream whose metadata you want to update.</p>
    public let currentVersion: String?
    /// <p>The name of the device that is writing to the stream. </p>
    ///         <note>
    ///             <p> In the current implementation, Kinesis Video Streams does not use this name.
    ///             </p>
    ///         </note>
    public let deviceName: String?
    /// <p>The stream's media type. Use <code>MediaType</code> to specify the type of content
    ///             that the stream contains to the consumers of the stream. For more information about
    ///             media types, see <a href="http://www.iana.org/assignments/media-types/media-types.xhtml">Media
    ///                 Types</a>. If you choose to specify the <code>MediaType</code>, see <a href="https://tools.ietf.org/html/rfc6838#section-4.2">Naming
    ///             Requirements</a>.</p>
    ///         <p>To play video on the console, you must specify the correct video type. For example,
    ///             if the video in the stream is H.264, specify <code>video/h264</code> as the
    ///                 <code>MediaType</code>.</p>
    public let mediaType: String?
    /// <p>The ARN of the stream whose metadata you want to update.</p>
    public let streamARN: String?
    /// <p>The name of the stream whose metadata you want to update.</p>
    ///         <p>The stream name is an identifier for the stream, and must be unique for each
    ///             account and region.</p>
    public let streamName: String?

    public init (
        currentVersion: String? = nil,
        deviceName: String? = nil,
        mediaType: String? = nil,
        streamARN: String? = nil,
        streamName: String? = nil
    )
    {
        self.currentVersion = currentVersion
        self.deviceName = deviceName
        self.mediaType = mediaType
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct UpdateStreamInputBody: Equatable {
    public let streamName: String?
    public let streamARN: String?
    public let currentVersion: String?
    public let deviceName: String?
    public let mediaType: String?
}

extension UpdateStreamInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case currentVersion = "CurrentVersion"
        case deviceName = "DeviceName"
        case mediaType = "MediaType"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let mediaTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mediaType)
        mediaType = mediaTypeDecoded
    }
}

extension UpdateStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionMismatchException" : self = .versionMismatchException(try VersionMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStreamOutputError: Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case versionMismatchException(VersionMismatchException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStreamOutputResponse()"}
}

extension UpdateStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateStreamOutputResponse: Equatable {

    public init() {}
}

struct UpdateStreamOutputResponseBody: Equatable {
}

extension UpdateStreamOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension VersionMismatchException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VersionMismatchException(message: \(String(describing: message)))"}
}

extension VersionMismatchException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: VersionMismatchExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The stream version that you specified is not the latest version. To get the latest
///             version, use the <a href="https://docs.aws.amazon.com/kinesisvideostreams/latest/dg/API_DescribeStream.html">DescribeStream</a>
///             API.</p>
public struct VersionMismatchException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct VersionMismatchExceptionBody: Equatable {
    public let message: String?
}

extension VersionMismatchExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
