// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You don't have access to this item. The provided credentials couldn't be validated. You might not be authorized to carry out the request. Make sure that your account is authorized to use the Amazon QuickSight service, that your policies have the correct permissions, and that you are using the correct access keys.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.AccountCustomization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultEmailCustomizationTemplate = "DefaultEmailCustomizationTemplate"
        case defaultTheme = "DefaultTheme"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultEmailCustomizationTemplate = defaultEmailCustomizationTemplate {
            try encodeContainer.encode(defaultEmailCustomizationTemplate, forKey: .defaultEmailCustomizationTemplate)
        }
        if let defaultTheme = defaultTheme {
            try encodeContainer.encode(defaultTheme, forKey: .defaultTheme)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultThemeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultTheme)
        defaultTheme = defaultThemeDecoded
        let defaultEmailCustomizationTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultEmailCustomizationTemplate)
        defaultEmailCustomizationTemplate = defaultEmailCustomizationTemplateDecoded
    }
}

extension QuickSightClientTypes {
    /// The Amazon QuickSight customizations associated with your Amazon Web Services account or a QuickSight namespace in a specific Amazon Web Services Region.
    public struct AccountCustomization: Swift.Equatable {
        /// The default email customization template.
        public var defaultEmailCustomizationTemplate: Swift.String?
        /// The default theme for this Amazon QuickSight subscription.
        public var defaultTheme: Swift.String?

        public init (
            defaultEmailCustomizationTemplate: Swift.String? = nil,
            defaultTheme: Swift.String? = nil
        )
        {
            self.defaultEmailCustomizationTemplate = defaultEmailCustomizationTemplate
            self.defaultTheme = defaultTheme
        }
    }

}

extension QuickSightClientTypes.AccountSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountName = "AccountName"
        case defaultNamespace = "DefaultNamespace"
        case edition = "Edition"
        case notificationEmail = "NotificationEmail"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountName = accountName {
            try encodeContainer.encode(accountName, forKey: .accountName)
        }
        if let defaultNamespace = defaultNamespace {
            try encodeContainer.encode(defaultNamespace, forKey: .defaultNamespace)
        }
        if let edition = edition {
            try encodeContainer.encode(edition.rawValue, forKey: .edition)
        }
        if let notificationEmail = notificationEmail {
            try encodeContainer.encode(notificationEmail, forKey: .notificationEmail)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountName)
        accountName = accountNameDecoded
        let editionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Edition.self, forKey: .edition)
        edition = editionDecoded
        let defaultNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultNamespace)
        defaultNamespace = defaultNamespaceDecoded
        let notificationEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationEmail)
        notificationEmail = notificationEmailDecoded
    }
}

extension QuickSightClientTypes {
    /// The Amazon QuickSight settings associated with your Amazon Web Services account.
    public struct AccountSettings: Swift.Equatable {
        /// The "account name" you provided for the Amazon QuickSight subscription in your Amazon Web Services account. You create this name when you sign up for Amazon QuickSight. It is unique in all of Amazon Web Services and it appears only when users sign in.
        public var accountName: Swift.String?
        /// The default Amazon QuickSight namespace for your Amazon Web Services account.
        public var defaultNamespace: Swift.String?
        /// The edition of Amazon QuickSight that you're currently subscribed to: Enterprise edition or Standard edition.
        public var edition: QuickSightClientTypes.Edition?
        /// The main notification email for your Amazon QuickSight subscription.
        public var notificationEmail: Swift.String?

        public init (
            accountName: Swift.String? = nil,
            defaultNamespace: Swift.String? = nil,
            edition: QuickSightClientTypes.Edition? = nil,
            notificationEmail: Swift.String? = nil
        )
        {
            self.accountName = accountName
            self.defaultNamespace = defaultNamespace
            self.edition = edition
            self.notificationEmail = notificationEmail
        }
    }

}

extension QuickSightClientTypes.ActiveIAMPolicyAssignment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentName = "AssignmentName"
        case policyArn = "PolicyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentName = assignmentName {
            try encodeContainer.encode(assignmentName, forKey: .assignmentName)
        }
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentName)
        assignmentName = assignmentNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension QuickSightClientTypes {
    /// The active Identity and Access Management (IAM) policy assignment.
    public struct ActiveIAMPolicyAssignment: Swift.Equatable {
        /// A name for the IAM policy assignment.
        public var assignmentName: Swift.String?
        /// The Amazon Resource Name (ARN) of the resource.
        public var policyArn: Swift.String?

        public init (
            assignmentName: Swift.String? = nil,
            policyArn: Swift.String? = nil
        )
        {
            self.assignmentName = assignmentName
            self.policyArn = policyArn
        }
    }

}

extension QuickSightClientTypes.AdHocFilteringOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityStatus = "AvailabilityStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityStatus = availabilityStatus {
            try encodeContainer.encode(availabilityStatus.rawValue, forKey: .availabilityStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardBehavior.self, forKey: .availabilityStatus)
        availabilityStatus = availabilityStatusDecoded
    }
}

extension QuickSightClientTypes {
    /// Ad hoc (one-time) filtering option.
    public struct AdHocFilteringOption: Swift.Equatable {
        /// Availability status.
        public var availabilityStatus: QuickSightClientTypes.DashboardBehavior?

        public init (
            availabilityStatus: QuickSightClientTypes.DashboardBehavior? = nil
        )
        {
            self.availabilityStatus = availabilityStatus
        }
    }

}

extension QuickSightClientTypes.AmazonElasticsearchParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for OpenSearch.
    public struct AmazonElasticsearchParameters: Swift.Equatable {
        /// The OpenSearch domain.
        /// This member is required.
        public var domain: Swift.String?

        public init (
            domain: Swift.String? = nil
        )
        {
            self.domain = domain
        }
    }

}

extension QuickSightClientTypes.AmazonOpenSearchParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for OpenSearch.
    public struct AmazonOpenSearchParameters: Swift.Equatable {
        /// The OpenSearch domain.
        /// This member is required.
        public var domain: Swift.String?

        public init (
            domain: Swift.String? = nil
        )
        {
            self.domain = domain
        }
    }

}

extension QuickSightClientTypes.Analysis: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisId = "AnalysisId"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case dataSetArns = "DataSetArns"
        case errors = "Errors"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case sheets = "Sheets"
        case status = "Status"
        case themeArn = "ThemeArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisId = analysisId {
            try encodeContainer.encode(analysisId, forKey: .analysisId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let dataSetArns = dataSetArns {
            var dataSetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSetArns)
            for datasetarnslist0 in dataSetArns {
                try dataSetArnsContainer.encode(datasetarnslist0)
            }
        }
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for analysiserrorlist0 in errors {
                try errorsContainer.encode(analysiserrorlist0)
            }
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sheets = sheets {
            var sheetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sheets)
            for sheetlist0 in sheets {
                try sheetsContainer.encode(sheetlist0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let themeArn = themeArn {
            try encodeContainer.encode(themeArn, forKey: .themeArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let errorsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.AnalysisError?].self, forKey: .errors)
        var errorsDecoded0:[QuickSightClientTypes.AnalysisError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [QuickSightClientTypes.AnalysisError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let dataSetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dataSetArns)
        var dataSetArnsDecoded0:[Swift.String]? = nil
        if let dataSetArnsContainer = dataSetArnsContainer {
            dataSetArnsDecoded0 = [Swift.String]()
            for string0 in dataSetArnsContainer {
                if let string0 = string0 {
                    dataSetArnsDecoded0?.append(string0)
                }
            }
        }
        dataSetArns = dataSetArnsDecoded0
        let themeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let sheetsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Sheet?].self, forKey: .sheets)
        var sheetsDecoded0:[QuickSightClientTypes.Sheet]? = nil
        if let sheetsContainer = sheetsContainer {
            sheetsDecoded0 = [QuickSightClientTypes.Sheet]()
            for structure0 in sheetsContainer {
                if let structure0 = structure0 {
                    sheetsDecoded0?.append(structure0)
                }
            }
        }
        sheets = sheetsDecoded0
    }
}

extension QuickSightClientTypes {
    /// Metadata structure for an analysis in Amazon QuickSight
    public struct Analysis: Swift.Equatable {
        /// The ID of the analysis.
        public var analysisId: Swift.String?
        /// The Amazon Resource Name (ARN) of the analysis.
        public var arn: Swift.String?
        /// The time that the analysis was created.
        public var createdTime: ClientRuntime.Date?
        /// The ARNs of the datasets of the analysis.
        public var dataSetArns: [Swift.String]?
        /// Errors associated with the analysis.
        public var errors: [QuickSightClientTypes.AnalysisError]?
        /// The time that the analysis was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The descriptive name of the analysis.
        public var name: Swift.String?
        /// A list of the associated sheets with the unique identifier and name of each sheet.
        public var sheets: [QuickSightClientTypes.Sheet]?
        /// Status associated with the analysis.
        public var status: QuickSightClientTypes.ResourceStatus?
        /// The ARN of the theme of the analysis.
        public var themeArn: Swift.String?

        public init (
            analysisId: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            dataSetArns: [Swift.String]? = nil,
            errors: [QuickSightClientTypes.AnalysisError]? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            sheets: [QuickSightClientTypes.Sheet]? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil,
            themeArn: Swift.String? = nil
        )
        {
            self.analysisId = analysisId
            self.arn = arn
            self.createdTime = createdTime
            self.dataSetArns = dataSetArns
            self.errors = errors
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.sheets = sheets
            self.status = status
            self.themeArn = themeArn
        }
    }

}

extension QuickSightClientTypes.AnalysisError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AnalysisErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QuickSightClientTypes {
    /// Analysis error.
    public struct AnalysisError: Swift.Equatable {
        /// The message associated with the analysis error.
        public var message: Swift.String?
        /// The type of the analysis error.
        public var type: QuickSightClientTypes.AnalysisErrorType?

        public init (
            message: Swift.String? = nil,
            type: QuickSightClientTypes.AnalysisErrorType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }

}

extension QuickSightClientTypes {
    public enum AnalysisErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case columnGeographicRoleMismatch
        case columnReplacementMissing
        case columnTypeMismatch
        case dataSetNotFound
        case internalFailure
        case parameterNotFound
        case parameterTypeInvalid
        case parameterValueIncompatible
        case sourceNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisErrorType] {
            return [
                .accessDenied,
                .columnGeographicRoleMismatch,
                .columnReplacementMissing,
                .columnTypeMismatch,
                .dataSetNotFound,
                .internalFailure,
                .parameterNotFound,
                .parameterTypeInvalid,
                .parameterValueIncompatible,
                .sourceNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .columnGeographicRoleMismatch: return "COLUMN_GEOGRAPHIC_ROLE_MISMATCH"
            case .columnReplacementMissing: return "COLUMN_REPLACEMENT_MISSING"
            case .columnTypeMismatch: return "COLUMN_TYPE_MISMATCH"
            case .dataSetNotFound: return "DATA_SET_NOT_FOUND"
            case .internalFailure: return "INTERNAL_FAILURE"
            case .parameterNotFound: return "PARAMETER_NOT_FOUND"
            case .parameterTypeInvalid: return "PARAMETER_TYPE_INVALID"
            case .parameterValueIncompatible: return "PARAMETER_VALUE_INCOMPATIBLE"
            case .sourceNotFound: return "SOURCE_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalysisErrorType(rawValue: rawValue) ?? AnalysisErrorType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum AnalysisFilterAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case quicksightUser
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisFilterAttribute] {
            return [
                .quicksightUser,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .quicksightUser: return "QUICKSIGHT_USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalysisFilterAttribute(rawValue: rawValue) ?? AnalysisFilterAttribute.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.AnalysisSearchFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case `operator` = "Operator"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let nameDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AnalysisFilterAttribute.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension QuickSightClientTypes {
    /// A filter that you apply when searching for one or more analyses.
    public struct AnalysisSearchFilter: Swift.Equatable {
        /// The name of the value that you want to use as a filter, for example "Name": "QUICKSIGHT_USER".
        public var name: QuickSightClientTypes.AnalysisFilterAttribute?
        /// The comparison operator that you want to use as a filter, for example "Operator": "StringEquals".
        public var `operator`: QuickSightClientTypes.FilterOperator?
        /// The value of the named item, in this case QUICKSIGHT_USER, that you want to use as a filter, for example "Value". An example is "arn:aws:quicksight:us-east-1:1:user/default/UserName1".
        public var value: Swift.String?

        public init (
            name: QuickSightClientTypes.AnalysisFilterAttribute? = nil,
            `operator`: QuickSightClientTypes.FilterOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }
    }

}

extension QuickSightClientTypes.AnalysisSourceEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceTemplate = "SourceTemplate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceTemplate = sourceTemplate {
            try encodeContainer.encode(sourceTemplate, forKey: .sourceTemplate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTemplateDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AnalysisSourceTemplate.self, forKey: .sourceTemplate)
        sourceTemplate = sourceTemplateDecoded
    }
}

extension QuickSightClientTypes {
    /// The source entity of an analysis.
    public struct AnalysisSourceEntity: Swift.Equatable {
        /// The source template for the source entity of the analysis.
        public var sourceTemplate: QuickSightClientTypes.AnalysisSourceTemplate?

        public init (
            sourceTemplate: QuickSightClientTypes.AnalysisSourceTemplate? = nil
        )
        {
            self.sourceTemplate = sourceTemplate
        }
    }

}

extension QuickSightClientTypes.AnalysisSourceTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case dataSetReferences = "DataSetReferences"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dataSetReferences = dataSetReferences {
            var dataSetReferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSetReferences)
            for datasetreferencelist0 in dataSetReferences {
                try dataSetReferencesContainer.encode(datasetreferencelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetReferencesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataSetReference?].self, forKey: .dataSetReferences)
        var dataSetReferencesDecoded0:[QuickSightClientTypes.DataSetReference]? = nil
        if let dataSetReferencesContainer = dataSetReferencesContainer {
            dataSetReferencesDecoded0 = [QuickSightClientTypes.DataSetReference]()
            for structure0 in dataSetReferencesContainer {
                if let structure0 = structure0 {
                    dataSetReferencesDecoded0?.append(structure0)
                }
            }
        }
        dataSetReferences = dataSetReferencesDecoded0
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension QuickSightClientTypes {
    /// The source template of an analysis.
    public struct AnalysisSourceTemplate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the source template of an analysis.
        /// This member is required.
        public var arn: Swift.String?
        /// The dataset references of the source template of an analysis.
        /// This member is required.
        public var dataSetReferences: [QuickSightClientTypes.DataSetReference]?

        public init (
            arn: Swift.String? = nil,
            dataSetReferences: [QuickSightClientTypes.DataSetReference]? = nil
        )
        {
            self.arn = arn
            self.dataSetReferences = dataSetReferences
        }
    }

}

extension QuickSightClientTypes.AnalysisSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisId = "AnalysisId"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisId = analysisId {
            try encodeContainer.encode(analysisId, forKey: .analysisId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let analysisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension QuickSightClientTypes {
    /// The summary metadata that describes an analysis.
    public struct AnalysisSummary: Swift.Equatable {
        /// The ID of the analysis. This ID displays in the URL.
        public var analysisId: Swift.String?
        /// The Amazon Resource Name (ARN) for the analysis.
        public var arn: Swift.String?
        /// The time that the analysis was created.
        public var createdTime: ClientRuntime.Date?
        /// The time that the analysis was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the analysis. This name is displayed in the Amazon QuickSight console.
        public var name: Swift.String?
        /// The last known status for the analysis.
        public var status: QuickSightClientTypes.ResourceStatus?

        public init (
            analysisId: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil
        )
        {
            self.analysisId = analysisId
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.status = status
        }
    }

}

extension QuickSightClientTypes.AnonymousUserDashboardEmbeddingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialDashboardId = "InitialDashboardId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialDashboardId = initialDashboardId {
            try encodeContainer.encode(initialDashboardId, forKey: .initialDashboardId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialDashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialDashboardId)
        initialDashboardId = initialDashboardIdDecoded
    }
}

extension QuickSightClientTypes {
    /// Information about the dashboard that you want to embed.
    public struct AnonymousUserDashboardEmbeddingConfiguration: Swift.Equatable {
        /// The dashboard ID for the dashboard that you want the user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this dashboard. The Amazon Resource Name (ARN) of this dashboard must be included in the AuthorizedResourceArns parameter. Otherwise, the request will fail with InvalidParameterValueException.
        /// This member is required.
        public var initialDashboardId: Swift.String?

        public init (
            initialDashboardId: Swift.String? = nil
        )
        {
            self.initialDashboardId = initialDashboardId
        }
    }

}

extension QuickSightClientTypes.AnonymousUserEmbeddingExperienceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboard = "Dashboard"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dashboard = dashboard {
            try encodeContainer.encode(dashboard, forKey: .dashboard)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AnonymousUserDashboardEmbeddingConfiguration.self, forKey: .dashboard)
        dashboard = dashboardDecoded
    }
}

extension QuickSightClientTypes {
    /// The type of experience you want to embed. For anonymous users, you can embed Amazon QuickSight dashboards.
    public struct AnonymousUserEmbeddingExperienceConfiguration: Swift.Equatable {
        /// The type of embedding experience. In this case, Amazon QuickSight dashboards.
        public var dashboard: QuickSightClientTypes.AnonymousUserDashboardEmbeddingConfiguration?

        public init (
            dashboard: QuickSightClientTypes.AnonymousUserDashboardEmbeddingConfiguration? = nil
        )
        {
            self.dashboard = dashboard
        }
    }

}

extension QuickSightClientTypes {
    public enum AssignmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case draft
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AssignmentStatus] {
            return [
                .disabled,
                .draft,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .draft: return "DRAFT"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssignmentStatus(rawValue: rawValue) ?? AssignmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.AthenaParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension QuickSightClientTypes {
    /// Parameters for Amazon Athena.
    public struct AthenaParameters: Swift.Equatable {
        /// The workgroup that Amazon Athena uses.
        public var workGroup: Swift.String?

        public init (
            workGroup: Swift.String? = nil
        )
        {
            self.workGroup = workGroup
        }
    }

}

extension QuickSightClientTypes.AuroraParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension QuickSightClientTypes {
    /// Parameters for Amazon Aurora.
    public struct AuroraParameters: Swift.Equatable {
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int

        public init (
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.database = database
            self.host = host
            self.port = port
        }
    }

}

extension QuickSightClientTypes.AuroraPostgreSqlParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension QuickSightClientTypes {
    /// Parameters for Amazon Aurora PostgreSQL-Compatible Edition.
    public struct AuroraPostgreSqlParameters: Swift.Equatable {
        /// The Amazon Aurora PostgreSQL database to connect to.
        /// This member is required.
        public var database: Swift.String?
        /// The Amazon Aurora PostgreSQL-Compatible host to connect to.
        /// This member is required.
        public var host: Swift.String?
        /// The port that Amazon Aurora PostgreSQL is listening on.
        /// This member is required.
        public var port: Swift.Int

        public init (
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.database = database
            self.host = host
            self.port = port
        }
    }

}

extension QuickSightClientTypes.AwsIotAnalyticsParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetName = "DataSetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSetName = dataSetName {
            try encodeContainer.encode(dataSetName, forKey: .dataSetName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetName)
        dataSetName = dataSetNameDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for IoT Analytics.
    public struct AwsIotAnalyticsParameters: Swift.Equatable {
        /// Dataset name.
        /// This member is required.
        public var dataSetName: Swift.String?

        public init (
            dataSetName: Swift.String? = nil
        )
        {
            self.dataSetName = dataSetName
        }
    }

}

extension QuickSightClientTypes.BorderStyle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case show = "Show"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if show != false {
            try encodeContainer.encode(show, forKey: .show)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let showDecoded = try containerValues.decode(Swift.Bool.self, forKey: .show)
        show = showDecoded
    }
}

extension QuickSightClientTypes {
    /// The display options for tile borders for visuals.
    public struct BorderStyle: Swift.Equatable {
        /// The option to enable display of borders for visuals.
        public var show: Swift.Bool

        public init (
            show: Swift.Bool = false
        )
        {
            self.show = show
        }
    }

}

extension QuickSightClientTypes.CalculatedColumn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnId = "ColumnId"
        case columnName = "ColumnName"
        case expression = "Expression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnId = columnId {
            try encodeContainer.encode(columnId, forKey: .columnId)
        }
        if let columnName = columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let columnIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnId)
        columnId = columnIdDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
    }
}

extension QuickSightClientTypes {
    /// A calculated column for a dataset.
    public struct CalculatedColumn: Swift.Equatable {
        /// A unique ID to identify a calculated column. During a dataset update, if the column ID of a calculated column matches that of an existing calculated column, Amazon QuickSight preserves the existing calculated column.
        /// This member is required.
        public var columnId: Swift.String?
        /// Column name.
        /// This member is required.
        public var columnName: Swift.String?
        /// An expression that defines the calculated column.
        /// This member is required.
        public var expression: Swift.String?

        public init (
            columnId: Swift.String? = nil,
            columnName: Swift.String? = nil,
            expression: Swift.String? = nil
        )
        {
            self.columnId = columnId
            self.columnName = columnName
            self.expression = expression
        }
    }

}

extension CancelIngestionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSetId = dataSetId else {
            return nil
        }
        guard let ingestionId = ingestionId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/ingestions/\(ingestionId.urlPercentEncoding())"
    }
}

public struct CancelIngestionInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dataset used in the ingestion.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// An ID for the ingestion.
    /// This member is required.
    public var ingestionId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        ingestionId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
        self.ingestionId = ingestionId
    }
}

struct CancelIngestionInputBody: Swift.Equatable {
}

extension CancelIngestionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelIngestionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelIngestionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelIngestionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelIngestionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelIngestionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.ingestionId = output.ingestionId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.ingestionId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CancelIngestionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the data ingestion.
    public var arn: Swift.String?
    /// An ID for the ingestion.
    public var ingestionId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        ingestionId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.ingestionId = ingestionId
        self.requestId = requestId
        self.status = status
    }
}

struct CancelIngestionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let ingestionId: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension CancelIngestionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case ingestionId = "IngestionId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ingestionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ingestionId)
        ingestionId = ingestionIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension QuickSightClientTypes.CastColumnTypeOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnName = "ColumnName"
        case format = "Format"
        case newColumnType = "NewColumnType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnName = columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let format = format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let newColumnType = newColumnType {
            try encodeContainer.encode(newColumnType.rawValue, forKey: .newColumnType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let newColumnTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnDataType.self, forKey: .newColumnType)
        newColumnType = newColumnTypeDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
    }
}

extension QuickSightClientTypes {
    /// A transform operation that casts a column to a different type.
    public struct CastColumnTypeOperation: Swift.Equatable {
        /// Column name.
        /// This member is required.
        public var columnName: Swift.String?
        /// When casting a column from string to datetime type, you can supply a string in a format supported by Amazon QuickSight to denote the source data format.
        public var format: Swift.String?
        /// New column data type.
        /// This member is required.
        public var newColumnType: QuickSightClientTypes.ColumnDataType?

        public init (
            columnName: Swift.String? = nil,
            format: Swift.String? = nil,
            newColumnType: QuickSightClientTypes.ColumnDataType? = nil
        )
        {
            self.columnName = columnName
            self.format = format
            self.newColumnType = newColumnType
        }
    }

}

extension QuickSightClientTypes {
    public enum ColumnDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case datetime
        case decimal
        case integer
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnDataType] {
            return [
                .datetime,
                .decimal,
                .integer,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .datetime: return "DATETIME"
            case .decimal: return "DECIMAL"
            case .integer: return "INTEGER"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ColumnDataType(rawValue: rawValue) ?? ColumnDataType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.ColumnDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension QuickSightClientTypes {
    /// Metadata that contains a description for a column.
    public struct ColumnDescription: Swift.Equatable {
        /// The text of a description for a column.
        public var text: Swift.String?

        public init (
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension QuickSightClientTypes.ColumnGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geoSpatialColumnGroup = "GeoSpatialColumnGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let geoSpatialColumnGroup = geoSpatialColumnGroup {
            try encodeContainer.encode(geoSpatialColumnGroup, forKey: .geoSpatialColumnGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geoSpatialColumnGroupDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GeoSpatialColumnGroup.self, forKey: .geoSpatialColumnGroup)
        geoSpatialColumnGroup = geoSpatialColumnGroupDecoded
    }
}

extension QuickSightClientTypes {
    /// Groupings of columns that work together in certain Amazon QuickSight features. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
    public struct ColumnGroup: Swift.Equatable {
        /// Geospatial column group that denotes a hierarchy.
        public var geoSpatialColumnGroup: QuickSightClientTypes.GeoSpatialColumnGroup?

        public init (
            geoSpatialColumnGroup: QuickSightClientTypes.GeoSpatialColumnGroup? = nil
        )
        {
            self.geoSpatialColumnGroup = geoSpatialColumnGroup
        }
    }

}

extension QuickSightClientTypes.ColumnGroupColumnSchema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension QuickSightClientTypes {
    /// A structure describing the name, data type, and geographic role of the columns.
    public struct ColumnGroupColumnSchema: Swift.Equatable {
        /// The name of the column group's column schema.
        public var name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension QuickSightClientTypes.ColumnGroupSchema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnGroupColumnSchemaList = "ColumnGroupColumnSchemaList"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnGroupColumnSchemaList = columnGroupColumnSchemaList {
            var columnGroupColumnSchemaListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnGroupColumnSchemaList)
            for columngroupcolumnschemalist0 in columnGroupColumnSchemaList {
                try columnGroupColumnSchemaListContainer.encode(columngroupcolumnschemalist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let columnGroupColumnSchemaListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnGroupColumnSchema?].self, forKey: .columnGroupColumnSchemaList)
        var columnGroupColumnSchemaListDecoded0:[QuickSightClientTypes.ColumnGroupColumnSchema]? = nil
        if let columnGroupColumnSchemaListContainer = columnGroupColumnSchemaListContainer {
            columnGroupColumnSchemaListDecoded0 = [QuickSightClientTypes.ColumnGroupColumnSchema]()
            for structure0 in columnGroupColumnSchemaListContainer {
                if let structure0 = structure0 {
                    columnGroupColumnSchemaListDecoded0?.append(structure0)
                }
            }
        }
        columnGroupColumnSchemaList = columnGroupColumnSchemaListDecoded0
    }
}

extension QuickSightClientTypes {
    /// The column group schema.
    public struct ColumnGroupSchema: Swift.Equatable {
        /// A structure containing the list of schemas for column group columns.
        public var columnGroupColumnSchemaList: [QuickSightClientTypes.ColumnGroupColumnSchema]?
        /// The name of the column group schema.
        public var name: Swift.String?

        public init (
            columnGroupColumnSchemaList: [QuickSightClientTypes.ColumnGroupColumnSchema]? = nil,
            name: Swift.String? = nil
        )
        {
            self.columnGroupColumnSchemaList = columnGroupColumnSchemaList
            self.name = name
        }
    }

}

extension QuickSightClientTypes.ColumnLevelPermissionRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnNames = "ColumnNames"
        case principals = "Principals"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnNames = columnNames {
            var columnNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnNames)
            for columnnamelist0 in columnNames {
                try columnNamesContainer.encode(columnnamelist0)
            }
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for principallist0 in principals {
                try principalsContainer.encode(principallist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let columnNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .columnNames)
        var columnNamesDecoded0:[Swift.String]? = nil
        if let columnNamesContainer = columnNamesContainer {
            columnNamesDecoded0 = [Swift.String]()
            for string0 in columnNamesContainer {
                if let string0 = string0 {
                    columnNamesDecoded0?.append(string0)
                }
            }
        }
        columnNames = columnNamesDecoded0
    }
}

extension QuickSightClientTypes {
    /// A rule defined to grant access on one or more restricted columns. Each dataset can have multiple rules. To create a restricted column, you add it to one or more rules. Each rule must contain at least one column and at least one user or group. To be able to see a restricted column, a user or group needs to be added to a rule for that column.
    public struct ColumnLevelPermissionRule: Swift.Equatable {
        /// An array of column names.
        public var columnNames: [Swift.String]?
        /// An array of Amazon Resource Names (ARNs) for Amazon QuickSight users or groups.
        public var principals: [Swift.String]?

        public init (
            columnNames: [Swift.String]? = nil,
            principals: [Swift.String]? = nil
        )
        {
            self.columnNames = columnNames
            self.principals = principals
        }
    }

}

extension QuickSightClientTypes.ColumnSchema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataType = "DataType"
        case geographicRole = "GeographicRole"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataType = dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let geographicRole = geographicRole {
            try encodeContainer.encode(geographicRole, forKey: .geographicRole)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let geographicRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geographicRole)
        geographicRole = geographicRoleDecoded
    }
}

extension QuickSightClientTypes {
    /// The column schema.
    public struct ColumnSchema: Swift.Equatable {
        /// The data type of the column schema.
        public var dataType: Swift.String?
        /// The geographic role of the column schema.
        public var geographicRole: Swift.String?
        /// The name of the column schema.
        public var name: Swift.String?

        public init (
            dataType: Swift.String? = nil,
            geographicRole: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.dataType = dataType
            self.geographicRole = geographicRole
            self.name = name
        }
    }

}

extension QuickSightClientTypes.ColumnTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnDescription = "ColumnDescription"
        case columnGeographicRole = "ColumnGeographicRole"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnDescription = columnDescription {
            try encodeContainer.encode(columnDescription, forKey: .columnDescription)
        }
        if let columnGeographicRole = columnGeographicRole {
            try encodeContainer.encode(columnGeographicRole.rawValue, forKey: .columnGeographicRole)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnGeographicRoleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GeoSpatialDataRole.self, forKey: .columnGeographicRole)
        columnGeographicRole = columnGeographicRoleDecoded
        let columnDescriptionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnDescription.self, forKey: .columnDescription)
        columnDescription = columnDescriptionDecoded
    }
}

extension QuickSightClientTypes {
    /// A tag for a column in a [TagColumnOperation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_TagColumnOperation.html) structure. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
    public struct ColumnTag: Swift.Equatable {
        /// A description for a column.
        public var columnDescription: QuickSightClientTypes.ColumnDescription?
        /// A geospatial role for a column.
        public var columnGeographicRole: QuickSightClientTypes.GeoSpatialDataRole?

        public init (
            columnDescription: QuickSightClientTypes.ColumnDescription? = nil,
            columnGeographicRole: QuickSightClientTypes.GeoSpatialDataRole? = nil
        )
        {
            self.columnDescription = columnDescription
            self.columnGeographicRole = columnGeographicRole
        }
    }

}

extension QuickSightClientTypes {
    public enum ColumnTagName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case columnDescription
        case columnGeographicRole
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnTagName] {
            return [
                .columnDescription,
                .columnGeographicRole,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .columnDescription: return "COLUMN_DESCRIPTION"
            case .columnGeographicRole: return "COLUMN_GEOGRAPHIC_ROLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ColumnTagName(rawValue: rawValue) ?? ColumnTagName.sdkUnknown(rawValue)
        }
    }
}

extension ConcurrentUpdatingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConcurrentUpdatingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A resource is already in a state that indicates an operation is happening that must complete before a new update can be applied.
public struct ConcurrentUpdatingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct ConcurrentUpdatingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ConcurrentUpdatingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension CreateAccountCustomizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountCustomization = "AccountCustomization"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountCustomization = accountCustomization {
            try encodeContainer.encode(accountCustomization, forKey: .accountCustomization)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateAccountCustomizationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let namespace = namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        return items
    }
}

extension CreateAccountCustomizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/customizations"
    }
}

public struct CreateAccountCustomizationInput: Swift.Equatable {
    /// The Amazon QuickSight customizations you're adding in the current Amazon Web Services Region. You can add these to an Amazon Web Services account and a QuickSight namespace. For example, you can add a default theme by setting AccountCustomization to the midnight theme: "AccountCustomization": { "DefaultTheme": "arn:aws:quicksight::aws:theme/MIDNIGHT" }. Or, you can add a custom theme by specifying "AccountCustomization": { "DefaultTheme": "arn:aws:quicksight:us-west-2:111122223333:theme/bdb844d0-0fe9-4d9d-b520-0fe602d93639" }.
    /// This member is required.
    public var accountCustomization: QuickSightClientTypes.AccountCustomization?
    /// The ID for the Amazon Web Services account that you want to customize Amazon QuickSight for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The Amazon QuickSight namespace that you want to add customizations to.
    public var namespace: Swift.String?
    /// A list of the tags that you want to attach to this resource.
    public var tags: [QuickSightClientTypes.Tag]?

    public init (
        accountCustomization: QuickSightClientTypes.AccountCustomization? = nil,
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil
    )
    {
        self.accountCustomization = accountCustomization
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.tags = tags
    }
}

struct CreateAccountCustomizationInputBody: Swift.Equatable {
    let accountCustomization: QuickSightClientTypes.AccountCustomization?
    let tags: [QuickSightClientTypes.Tag]?
}

extension CreateAccountCustomizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountCustomization = "AccountCustomization"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountCustomizationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AccountCustomization.self, forKey: .accountCustomization)
        accountCustomization = accountCustomizationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QuickSightClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QuickSightClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAccountCustomizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAccountCustomizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAccountCustomizationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccountCustomizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAccountCustomizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountCustomization = output.accountCustomization
            self.arn = output.arn
            self.awsAccountId = output.awsAccountId
            self.namespace = output.namespace
            self.requestId = output.requestId
        } else {
            self.accountCustomization = nil
            self.arn = nil
            self.awsAccountId = nil
            self.namespace = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateAccountCustomizationOutputResponse: Swift.Equatable {
    /// The Amazon QuickSight customizations you're adding in the current Amazon Web Services Region.
    public var accountCustomization: QuickSightClientTypes.AccountCustomization?
    /// The Amazon Resource Name (ARN) for the customization that you created for this Amazon Web Services account.
    public var arn: Swift.String?
    /// The ID for the Amazon Web Services account that you want to customize Amazon QuickSight for.
    public var awsAccountId: Swift.String?
    /// The namespace associated with the customization you're creating.
    public var namespace: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        accountCustomization: QuickSightClientTypes.AccountCustomization? = nil,
        arn: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.accountCustomization = accountCustomization
        self.arn = arn
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.requestId = requestId
        self.status = status
    }
}

struct CreateAccountCustomizationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let awsAccountId: Swift.String?
    let namespace: Swift.String?
    let accountCustomization: QuickSightClientTypes.AccountCustomization?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension CreateAccountCustomizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountCustomization = "AccountCustomization"
        case arn = "Arn"
        case awsAccountId = "AwsAccountId"
        case namespace = "Namespace"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let accountCustomizationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AccountCustomization.self, forKey: .accountCustomization)
        accountCustomization = accountCustomizationDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension CreateAnalysisInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case parameters = "Parameters"
        case permissions = "Permissions"
        case sourceEntity = "SourceEntity"
        case tags = "Tags"
        case themeArn = "ThemeArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for resourcepermissionlist0 in permissions {
                try permissionsContainer.encode(resourcepermissionlist0)
            }
        }
        if let sourceEntity = sourceEntity {
            try encodeContainer.encode(sourceEntity, forKey: .sourceEntity)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let themeArn = themeArn {
            try encodeContainer.encode(themeArn, forKey: .themeArn)
        }
    }
}

extension CreateAnalysisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let analysisId = analysisId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/analyses/\(analysisId.urlPercentEncoding())"
    }
}

public struct CreateAnalysisInput: Swift.Equatable {
    /// The ID for the analysis that you're creating. This ID displays in the URL of the analysis.
    /// This member is required.
    public var analysisId: Swift.String?
    /// The ID of the Amazon Web Services account where you are creating an analysis.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A descriptive name for the analysis that you're creating. This name displays for the analysis in the Amazon QuickSight console.
    /// This member is required.
    public var name: Swift.String?
    /// The parameter names and override values that you want to use. An analysis can have any parameter type, and some parameters might accept multiple values.
    public var parameters: QuickSightClientTypes.Parameters?
    /// A structure that describes the principals and the resource-level permissions on an analysis. You can use the Permissions structure to grant permissions by providing a list of Identity and Access Management (IAM) action information for each principal listed by Amazon Resource Name (ARN). To specify no permissions, omit Permissions.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// A source entity to use for the analysis that you're creating. This metadata structure contains details that describe a source template and one or more datasets.
    /// This member is required.
    public var sourceEntity: QuickSightClientTypes.AnalysisSourceEntity?
    /// Contains a map of the key-value pairs for the resource tag or tags assigned to the analysis.
    public var tags: [QuickSightClientTypes.Tag]?
    /// The ARN for the theme to apply to the analysis that you're creating. To see the theme in the Amazon QuickSight console, make sure that you have access to it.
    public var themeArn: Swift.String?

    public init (
        analysisId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        name: Swift.String? = nil,
        parameters: QuickSightClientTypes.Parameters? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        sourceEntity: QuickSightClientTypes.AnalysisSourceEntity? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil,
        themeArn: Swift.String? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
        self.name = name
        self.parameters = parameters
        self.permissions = permissions
        self.sourceEntity = sourceEntity
        self.tags = tags
        self.themeArn = themeArn
    }
}

struct CreateAnalysisInputBody: Swift.Equatable {
    let name: Swift.String?
    let parameters: QuickSightClientTypes.Parameters?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let sourceEntity: QuickSightClientTypes.AnalysisSourceEntity?
    let themeArn: Swift.String?
    let tags: [QuickSightClientTypes.Tag]?
}

extension CreateAnalysisInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case parameters = "Parameters"
        case permissions = "Permissions"
        case sourceEntity = "SourceEntity"
        case tags = "Tags"
        case themeArn = "ThemeArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Parameters.self, forKey: .parameters)
        parameters = parametersDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let sourceEntityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AnalysisSourceEntity.self, forKey: .sourceEntity)
        sourceEntity = sourceEntityDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QuickSightClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QuickSightClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAnalysisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAnalysisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAnalysisOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAnalysisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisId = output.analysisId
            self.arn = output.arn
            self.creationStatus = output.creationStatus
            self.requestId = output.requestId
        } else {
            self.analysisId = nil
            self.arn = nil
            self.creationStatus = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateAnalysisOutputResponse: Swift.Equatable {
    /// The ID of the analysis.
    public var analysisId: Swift.String?
    /// The ARN for the analysis.
    public var arn: Swift.String?
    /// The status of the creation of the analysis.
    public var creationStatus: QuickSightClientTypes.ResourceStatus?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        analysisId: Swift.String? = nil,
        arn: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.ResourceStatus? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.analysisId = analysisId
        self.arn = arn
        self.creationStatus = creationStatus
        self.requestId = requestId
        self.status = status
    }
}

struct CreateAnalysisOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let analysisId: Swift.String?
    let creationStatus: QuickSightClientTypes.ResourceStatus?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension CreateAnalysisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisId = "AnalysisId"
        case arn = "Arn"
        case creationStatus = "CreationStatus"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let analysisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.CreateColumnsOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columns = "Columns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for calculatedcolumnlist0 in columns {
                try columnsContainer.encode(calculatedcolumnlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.CalculatedColumn?].self, forKey: .columns)
        var columnsDecoded0:[QuickSightClientTypes.CalculatedColumn]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [QuickSightClientTypes.CalculatedColumn]()
            for structure0 in columnsContainer {
                if let structure0 = structure0 {
                    columnsDecoded0?.append(structure0)
                }
            }
        }
        columns = columnsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A transform operation that creates calculated columns. Columns created in one such operation form a lexical closure.
    public struct CreateColumnsOperation: Swift.Equatable {
        /// Calculated columns to create.
        /// This member is required.
        public var columns: [QuickSightClientTypes.CalculatedColumn]?

        public init (
            columns: [QuickSightClientTypes.CalculatedColumn]? = nil
        )
        {
            self.columns = columns
        }
    }

}

extension CreateDashboardInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardPublishOptions = "DashboardPublishOptions"
        case name = "Name"
        case parameters = "Parameters"
        case permissions = "Permissions"
        case sourceEntity = "SourceEntity"
        case tags = "Tags"
        case themeArn = "ThemeArn"
        case versionDescription = "VersionDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dashboardPublishOptions = dashboardPublishOptions {
            try encodeContainer.encode(dashboardPublishOptions, forKey: .dashboardPublishOptions)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for resourcepermissionlist0 in permissions {
                try permissionsContainer.encode(resourcepermissionlist0)
            }
        }
        if let sourceEntity = sourceEntity {
            try encodeContainer.encode(sourceEntity, forKey: .sourceEntity)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let themeArn = themeArn {
            try encodeContainer.encode(themeArn, forKey: .themeArn)
        }
        if let versionDescription = versionDescription {
            try encodeContainer.encode(versionDescription, forKey: .versionDescription)
        }
    }
}

extension CreateDashboardInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dashboardId = dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())"
    }
}

public struct CreateDashboardInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account where you want to create the dashboard.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard, also added to the IAM policy.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// Options for publishing the dashboard when you create it:
    ///
    /// * AvailabilityStatus for AdHocFilteringOption - This status can be either ENABLED or DISABLED. When this is set to DISABLED, Amazon QuickSight disables the left filter pane on the published dashboard, which can be used for ad hoc (one-time) filtering. This option is ENABLED by default.
    ///
    /// * AvailabilityStatus for ExportToCSVOption - This status can be either ENABLED or DISABLED. The visual option to export data to .CSV format isn't enabled when this is set to DISABLED. This option is ENABLED by default.
    ///
    /// * VisibilityState for SheetControlsOption - This visibility state can be either COLLAPSED or EXPANDED. This option is COLLAPSED by default.
    public var dashboardPublishOptions: QuickSightClientTypes.DashboardPublishOptions?
    /// The display name of the dashboard.
    /// This member is required.
    public var name: Swift.String?
    /// The parameters for the creation of the dashboard, which you want to use to override the default settings. A dashboard can have any type of parameters, and some parameters might accept multiple values.
    public var parameters: QuickSightClientTypes.Parameters?
    /// A structure that contains the permissions of the dashboard. You can use this structure for granting permissions by providing a list of IAM action information for each principal ARN. To specify no permissions, omit the permissions list.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The entity that you are using as a source when you create the dashboard. In SourceEntity, you specify the type of object you're using as source. You can only create a dashboard from a template, so you use a SourceTemplate entity. If you need to create a dashboard from an analysis, first convert the analysis to a template by using the [CreateTemplate](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_CreateTemplate.html) API operation. For SourceTemplate, specify the Amazon Resource Name (ARN) of the source template. The SourceTemplateARN can contain any Amazon Web Services account and any Amazon QuickSight-supported Amazon Web Services Region. Use the DataSetReferences entity within SourceTemplate to list the replacement datasets for the placeholders listed in the original. The schema in each dataset must match its placeholder.
    /// This member is required.
    public var sourceEntity: QuickSightClientTypes.DashboardSourceEntity?
    /// Contains a map of the key-value pairs for the resource tag or tags assigned to the dashboard.
    public var tags: [QuickSightClientTypes.Tag]?
    /// The Amazon Resource Name (ARN) of the theme that is being used for this dashboard. If you add a value for this field, it overrides the value that is used in the source entity. The theme ARN must exist in the same Amazon Web Services account where you create the dashboard.
    public var themeArn: Swift.String?
    /// A description for the first version of the dashboard being created.
    public var versionDescription: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        dashboardPublishOptions: QuickSightClientTypes.DashboardPublishOptions? = nil,
        name: Swift.String? = nil,
        parameters: QuickSightClientTypes.Parameters? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        sourceEntity: QuickSightClientTypes.DashboardSourceEntity? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil,
        themeArn: Swift.String? = nil,
        versionDescription: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.dashboardPublishOptions = dashboardPublishOptions
        self.name = name
        self.parameters = parameters
        self.permissions = permissions
        self.sourceEntity = sourceEntity
        self.tags = tags
        self.themeArn = themeArn
        self.versionDescription = versionDescription
    }
}

struct CreateDashboardInputBody: Swift.Equatable {
    let name: Swift.String?
    let parameters: QuickSightClientTypes.Parameters?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let sourceEntity: QuickSightClientTypes.DashboardSourceEntity?
    let tags: [QuickSightClientTypes.Tag]?
    let versionDescription: Swift.String?
    let dashboardPublishOptions: QuickSightClientTypes.DashboardPublishOptions?
    let themeArn: Swift.String?
}

extension CreateDashboardInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardPublishOptions = "DashboardPublishOptions"
        case name = "Name"
        case parameters = "Parameters"
        case permissions = "Permissions"
        case sourceEntity = "SourceEntity"
        case tags = "Tags"
        case themeArn = "ThemeArn"
        case versionDescription = "VersionDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Parameters.self, forKey: .parameters)
        parameters = parametersDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let sourceEntityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardSourceEntity.self, forKey: .sourceEntity)
        sourceEntity = sourceEntityDecoded
        let tagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QuickSightClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QuickSightClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let versionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionDescription)
        versionDescription = versionDescriptionDecoded
        let dashboardPublishOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardPublishOptions.self, forKey: .dashboardPublishOptions)
        dashboardPublishOptions = dashboardPublishOptionsDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
    }
}

extension CreateDashboardOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDashboardOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDashboardOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDashboardOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDashboardOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationStatus = output.creationStatus
            self.dashboardId = output.dashboardId
            self.requestId = output.requestId
            self.versionArn = output.versionArn
        } else {
            self.arn = nil
            self.creationStatus = nil
            self.dashboardId = nil
            self.requestId = nil
            self.versionArn = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateDashboardOutputResponse: Swift.Equatable {
    /// The ARN of the dashboard.
    public var arn: Swift.String?
    /// The status of the dashboard creation request.
    public var creationStatus: QuickSightClientTypes.ResourceStatus?
    /// The ID for the dashboard.
    public var dashboardId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ARN of the dashboard, including the version number of the first version that is created.
    public var versionArn: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.ResourceStatus? = nil,
        dashboardId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        versionArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.dashboardId = dashboardId
        self.requestId = requestId
        self.status = status
        self.versionArn = versionArn
    }
}

struct CreateDashboardOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let versionArn: Swift.String?
    let dashboardId: Swift.String?
    let creationStatus: QuickSightClientTypes.ResourceStatus?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension CreateDashboardOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationStatus = "CreationStatus"
        case dashboardId = "DashboardId"
        case requestId = "RequestId"
        case status = "Status"
        case versionArn = "VersionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionArn)
        versionArn = versionArnDecoded
        let dashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension CreateDataSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnGroups = "ColumnGroups"
        case columnLevelPermissionRules = "ColumnLevelPermissionRules"
        case dataSetId = "DataSetId"
        case dataSetUsageConfiguration = "DataSetUsageConfiguration"
        case fieldFolders = "FieldFolders"
        case importMode = "ImportMode"
        case logicalTableMap = "LogicalTableMap"
        case name = "Name"
        case permissions = "Permissions"
        case physicalTableMap = "PhysicalTableMap"
        case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
        case rowLevelPermissionTagConfiguration = "RowLevelPermissionTagConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnGroups = columnGroups {
            var columnGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnGroups)
            for columngrouplist0 in columnGroups {
                try columnGroupsContainer.encode(columngrouplist0)
            }
        }
        if let columnLevelPermissionRules = columnLevelPermissionRules {
            var columnLevelPermissionRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnLevelPermissionRules)
            for columnlevelpermissionrulelist0 in columnLevelPermissionRules {
                try columnLevelPermissionRulesContainer.encode(columnlevelpermissionrulelist0)
            }
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let dataSetUsageConfiguration = dataSetUsageConfiguration {
            try encodeContainer.encode(dataSetUsageConfiguration, forKey: .dataSetUsageConfiguration)
        }
        if let fieldFolders = fieldFolders {
            var fieldFoldersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .fieldFolders)
            for (dictKey0, fieldfoldermap0) in fieldFolders {
                try fieldFoldersContainer.encode(fieldfoldermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let importMode = importMode {
            try encodeContainer.encode(importMode.rawValue, forKey: .importMode)
        }
        if let logicalTableMap = logicalTableMap {
            var logicalTableMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .logicalTableMap)
            for (dictKey0, logicaltablemap0) in logicalTableMap {
                try logicalTableMapContainer.encode(logicaltablemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for resourcepermissionlist0 in permissions {
                try permissionsContainer.encode(resourcepermissionlist0)
            }
        }
        if let physicalTableMap = physicalTableMap {
            var physicalTableMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .physicalTableMap)
            for (dictKey0, physicaltablemap0) in physicalTableMap {
                try physicalTableMapContainer.encode(physicaltablemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let rowLevelPermissionDataSet = rowLevelPermissionDataSet {
            try encodeContainer.encode(rowLevelPermissionDataSet, forKey: .rowLevelPermissionDataSet)
        }
        if let rowLevelPermissionTagConfiguration = rowLevelPermissionTagConfiguration {
            try encodeContainer.encode(rowLevelPermissionTagConfiguration, forKey: .rowLevelPermissionTagConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateDataSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets"
    }
}

public struct CreateDataSetInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// Groupings of columns that work together in certain Amazon QuickSight features. Currently, only geospatial hierarchy is supported.
    public var columnGroups: [QuickSightClientTypes.ColumnGroup]?
    /// A set of one or more definitions of a [ColumnLevelPermissionRule](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ColumnLevelPermissionRule.html).
    public var columnLevelPermissionRules: [QuickSightClientTypes.ColumnLevelPermissionRule]?
    /// An ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The usage configuration to apply to child datasets that reference this dataset as a source.
    public var dataSetUsageConfiguration: QuickSightClientTypes.DataSetUsageConfiguration?
    /// The folder that contains fields and nested subfolders for your dataset.
    public var fieldFolders: [Swift.String:QuickSightClientTypes.FieldFolder]?
    /// Indicates whether you want to import the data into SPICE.
    /// This member is required.
    public var importMode: QuickSightClientTypes.DataSetImportMode?
    /// Configures the combination and transformation of the data from the physical tables.
    public var logicalTableMap: [Swift.String:QuickSightClientTypes.LogicalTable]?
    /// The display name for the dataset.
    /// This member is required.
    public var name: Swift.String?
    /// A list of resource permissions on the dataset.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// Declares the physical tables that are available in the underlying data sources.
    /// This member is required.
    public var physicalTableMap: [Swift.String:QuickSightClientTypes.PhysicalTable]?
    /// The row-level security configuration for the data that you want to create.
    public var rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet?
    /// The configuration of tags on a dataset to set row-level security. Row-level security tags are currently supported for anonymous embedding only.
    public var rowLevelPermissionTagConfiguration: QuickSightClientTypes.RowLevelPermissionTagConfiguration?
    /// Contains a map of the key-value pairs for the resource tag or tags assigned to the dataset.
    public var tags: [QuickSightClientTypes.Tag]?

    public init (
        awsAccountId: Swift.String? = nil,
        columnGroups: [QuickSightClientTypes.ColumnGroup]? = nil,
        columnLevelPermissionRules: [QuickSightClientTypes.ColumnLevelPermissionRule]? = nil,
        dataSetId: Swift.String? = nil,
        dataSetUsageConfiguration: QuickSightClientTypes.DataSetUsageConfiguration? = nil,
        fieldFolders: [Swift.String:QuickSightClientTypes.FieldFolder]? = nil,
        importMode: QuickSightClientTypes.DataSetImportMode? = nil,
        logicalTableMap: [Swift.String:QuickSightClientTypes.LogicalTable]? = nil,
        name: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        physicalTableMap: [Swift.String:QuickSightClientTypes.PhysicalTable]? = nil,
        rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet? = nil,
        rowLevelPermissionTagConfiguration: QuickSightClientTypes.RowLevelPermissionTagConfiguration? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.columnGroups = columnGroups
        self.columnLevelPermissionRules = columnLevelPermissionRules
        self.dataSetId = dataSetId
        self.dataSetUsageConfiguration = dataSetUsageConfiguration
        self.fieldFolders = fieldFolders
        self.importMode = importMode
        self.logicalTableMap = logicalTableMap
        self.name = name
        self.permissions = permissions
        self.physicalTableMap = physicalTableMap
        self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
        self.rowLevelPermissionTagConfiguration = rowLevelPermissionTagConfiguration
        self.tags = tags
    }
}

struct CreateDataSetInputBody: Swift.Equatable {
    let dataSetId: Swift.String?
    let name: Swift.String?
    let physicalTableMap: [Swift.String:QuickSightClientTypes.PhysicalTable]?
    let logicalTableMap: [Swift.String:QuickSightClientTypes.LogicalTable]?
    let importMode: QuickSightClientTypes.DataSetImportMode?
    let columnGroups: [QuickSightClientTypes.ColumnGroup]?
    let fieldFolders: [Swift.String:QuickSightClientTypes.FieldFolder]?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet?
    let rowLevelPermissionTagConfiguration: QuickSightClientTypes.RowLevelPermissionTagConfiguration?
    let columnLevelPermissionRules: [QuickSightClientTypes.ColumnLevelPermissionRule]?
    let tags: [QuickSightClientTypes.Tag]?
    let dataSetUsageConfiguration: QuickSightClientTypes.DataSetUsageConfiguration?
}

extension CreateDataSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnGroups = "ColumnGroups"
        case columnLevelPermissionRules = "ColumnLevelPermissionRules"
        case dataSetId = "DataSetId"
        case dataSetUsageConfiguration = "DataSetUsageConfiguration"
        case fieldFolders = "FieldFolders"
        case importMode = "ImportMode"
        case logicalTableMap = "LogicalTableMap"
        case name = "Name"
        case permissions = "Permissions"
        case physicalTableMap = "PhysicalTableMap"
        case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
        case rowLevelPermissionTagConfiguration = "RowLevelPermissionTagConfiguration"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let physicalTableMapContainer = try containerValues.decodeIfPresent([Swift.String: QuickSightClientTypes.PhysicalTable?].self, forKey: .physicalTableMap)
        var physicalTableMapDecoded0: [Swift.String:QuickSightClientTypes.PhysicalTable]? = nil
        if let physicalTableMapContainer = physicalTableMapContainer {
            physicalTableMapDecoded0 = [Swift.String:QuickSightClientTypes.PhysicalTable]()
            for (key0, physicaltable0) in physicalTableMapContainer {
                if let physicaltable0 = physicaltable0 {
                    physicalTableMapDecoded0?[key0] = physicaltable0
                }
            }
        }
        physicalTableMap = physicalTableMapDecoded0
        let logicalTableMapContainer = try containerValues.decodeIfPresent([Swift.String: QuickSightClientTypes.LogicalTable?].self, forKey: .logicalTableMap)
        var logicalTableMapDecoded0: [Swift.String:QuickSightClientTypes.LogicalTable]? = nil
        if let logicalTableMapContainer = logicalTableMapContainer {
            logicalTableMapDecoded0 = [Swift.String:QuickSightClientTypes.LogicalTable]()
            for (key0, logicaltable0) in logicalTableMapContainer {
                if let logicaltable0 = logicaltable0 {
                    logicalTableMapDecoded0?[key0] = logicaltable0
                }
            }
        }
        logicalTableMap = logicalTableMapDecoded0
        let importModeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSetImportMode.self, forKey: .importMode)
        importMode = importModeDecoded
        let columnGroupsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnGroup?].self, forKey: .columnGroups)
        var columnGroupsDecoded0:[QuickSightClientTypes.ColumnGroup]? = nil
        if let columnGroupsContainer = columnGroupsContainer {
            columnGroupsDecoded0 = [QuickSightClientTypes.ColumnGroup]()
            for structure0 in columnGroupsContainer {
                if let structure0 = structure0 {
                    columnGroupsDecoded0?.append(structure0)
                }
            }
        }
        columnGroups = columnGroupsDecoded0
        let fieldFoldersContainer = try containerValues.decodeIfPresent([Swift.String: QuickSightClientTypes.FieldFolder?].self, forKey: .fieldFolders)
        var fieldFoldersDecoded0: [Swift.String:QuickSightClientTypes.FieldFolder]? = nil
        if let fieldFoldersContainer = fieldFoldersContainer {
            fieldFoldersDecoded0 = [Swift.String:QuickSightClientTypes.FieldFolder]()
            for (key0, fieldfolder0) in fieldFoldersContainer {
                if let fieldfolder0 = fieldfolder0 {
                    fieldFoldersDecoded0?[key0] = fieldfolder0
                }
            }
        }
        fieldFolders = fieldFoldersDecoded0
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let rowLevelPermissionDataSetDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RowLevelPermissionDataSet.self, forKey: .rowLevelPermissionDataSet)
        rowLevelPermissionDataSet = rowLevelPermissionDataSetDecoded
        let rowLevelPermissionTagConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RowLevelPermissionTagConfiguration.self, forKey: .rowLevelPermissionTagConfiguration)
        rowLevelPermissionTagConfiguration = rowLevelPermissionTagConfigurationDecoded
        let columnLevelPermissionRulesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnLevelPermissionRule?].self, forKey: .columnLevelPermissionRules)
        var columnLevelPermissionRulesDecoded0:[QuickSightClientTypes.ColumnLevelPermissionRule]? = nil
        if let columnLevelPermissionRulesContainer = columnLevelPermissionRulesContainer {
            columnLevelPermissionRulesDecoded0 = [QuickSightClientTypes.ColumnLevelPermissionRule]()
            for structure0 in columnLevelPermissionRulesContainer {
                if let structure0 = structure0 {
                    columnLevelPermissionRulesDecoded0?.append(structure0)
                }
            }
        }
        columnLevelPermissionRules = columnLevelPermissionRulesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QuickSightClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QuickSightClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let dataSetUsageConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSetUsageConfiguration.self, forKey: .dataSetUsageConfiguration)
        dataSetUsageConfiguration = dataSetUsageConfigurationDecoded
    }
}

extension CreateDataSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDataSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDataSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDataSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDataSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.dataSetId = output.dataSetId
            self.ingestionArn = output.ingestionArn
            self.ingestionId = output.ingestionId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.dataSetId = nil
            self.ingestionArn = nil
            self.ingestionId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateDataSetOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset.
    public var arn: Swift.String?
    /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSetId: Swift.String?
    /// The ARN for the ingestion, which is triggered as a result of dataset creation if the import mode is SPICE.
    public var ingestionArn: Swift.String?
    /// The ID of the ingestion, which is triggered as a result of dataset creation if the import mode is SPICE.
    public var ingestionId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        ingestionArn: Swift.String? = nil,
        ingestionId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.dataSetId = dataSetId
        self.ingestionArn = ingestionArn
        self.ingestionId = ingestionId
        self.requestId = requestId
        self.status = status
    }
}

struct CreateDataSetOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let dataSetId: Swift.String?
    let ingestionArn: Swift.String?
    let ingestionId: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension CreateDataSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case dataSetId = "DataSetId"
        case ingestionArn = "IngestionArn"
        case ingestionId = "IngestionId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let ingestionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ingestionArn)
        ingestionArn = ingestionArnDecoded
        let ingestionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ingestionId)
        ingestionId = ingestionIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension CreateDataSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
        case dataSourceId = "DataSourceId"
        case dataSourceParameters = "DataSourceParameters"
        case name = "Name"
        case permissions = "Permissions"
        case sslProperties = "SslProperties"
        case tags = "Tags"
        case type = "Type"
        case vpcConnectionProperties = "VpcConnectionProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credentials = credentials {
            try encodeContainer.encode(credentials, forKey: .credentials)
        }
        if let dataSourceId = dataSourceId {
            try encodeContainer.encode(dataSourceId, forKey: .dataSourceId)
        }
        if let dataSourceParameters = dataSourceParameters {
            try encodeContainer.encode(dataSourceParameters, forKey: .dataSourceParameters)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for resourcepermissionlist0 in permissions {
                try permissionsContainer.encode(resourcepermissionlist0)
            }
        }
        if let sslProperties = sslProperties {
            try encodeContainer.encode(sslProperties, forKey: .sslProperties)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let vpcConnectionProperties = vpcConnectionProperties {
            try encodeContainer.encode(vpcConnectionProperties, forKey: .vpcConnectionProperties)
        }
    }
}

extension CreateDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sources"
    }
}

public struct CreateDataSourceInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The credentials Amazon QuickSight that uses to connect to your underlying source. Currently, only credentials based on user name and password are supported.
    public var credentials: QuickSightClientTypes.DataSourceCredentials?
    /// An ID for the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The parameters that Amazon QuickSight uses to connect to your underlying source.
    public var dataSourceParameters: QuickSightClientTypes.DataSourceParameters?
    /// A display name for the data source.
    /// This member is required.
    public var name: Swift.String?
    /// A list of resource permissions on the data source.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// Secure Socket Layer (SSL) properties that apply when Amazon QuickSight connects to your underlying source.
    public var sslProperties: QuickSightClientTypes.SslProperties?
    /// Contains a map of the key-value pairs for the resource tag or tags assigned to the data source.
    public var tags: [QuickSightClientTypes.Tag]?
    /// The type of the data source. To return a list of all data sources, use ListDataSources. Use AMAZON_ELASTICSEARCH for Amazon OpenSearch Service.
    /// This member is required.
    public var type: QuickSightClientTypes.DataSourceType?
    /// Use this parameter only when you want Amazon QuickSight to use a VPC connection when connecting to your underlying source.
    public var vpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties?

    public init (
        awsAccountId: Swift.String? = nil,
        credentials: QuickSightClientTypes.DataSourceCredentials? = nil,
        dataSourceId: Swift.String? = nil,
        dataSourceParameters: QuickSightClientTypes.DataSourceParameters? = nil,
        name: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        sslProperties: QuickSightClientTypes.SslProperties? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil,
        type: QuickSightClientTypes.DataSourceType? = nil,
        vpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.credentials = credentials
        self.dataSourceId = dataSourceId
        self.dataSourceParameters = dataSourceParameters
        self.name = name
        self.permissions = permissions
        self.sslProperties = sslProperties
        self.tags = tags
        self.type = type
        self.vpcConnectionProperties = vpcConnectionProperties
    }
}

struct CreateDataSourceInputBody: Swift.Equatable {
    let dataSourceId: Swift.String?
    let name: Swift.String?
    let type: QuickSightClientTypes.DataSourceType?
    let dataSourceParameters: QuickSightClientTypes.DataSourceParameters?
    let credentials: QuickSightClientTypes.DataSourceCredentials?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let vpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties?
    let sslProperties: QuickSightClientTypes.SslProperties?
    let tags: [QuickSightClientTypes.Tag]?
}

extension CreateDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
        case dataSourceId = "DataSourceId"
        case dataSourceParameters = "DataSourceParameters"
        case name = "Name"
        case permissions = "Permissions"
        case sslProperties = "SslProperties"
        case tags = "Tags"
        case type = "Type"
        case vpcConnectionProperties = "VpcConnectionProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSourceType.self, forKey: .type)
        type = typeDecoded
        let dataSourceParametersDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSourceParameters.self, forKey: .dataSourceParameters)
        dataSourceParameters = dataSourceParametersDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSourceCredentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let vpcConnectionPropertiesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VpcConnectionProperties.self, forKey: .vpcConnectionProperties)
        vpcConnectionProperties = vpcConnectionPropertiesDecoded
        let sslPropertiesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SslProperties.self, forKey: .sslProperties)
        sslProperties = sslPropertiesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QuickSightClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QuickSightClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDataSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDataSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDataSourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDataSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationStatus = output.creationStatus
            self.dataSourceId = output.dataSourceId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.creationStatus = nil
            self.dataSourceId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateDataSourceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the data source.
    public var arn: Swift.String?
    /// The status of creating the data source.
    public var creationStatus: QuickSightClientTypes.ResourceStatus?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSourceId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.ResourceStatus? = nil,
        dataSourceId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.dataSourceId = dataSourceId
        self.requestId = requestId
        self.status = status
    }
}

struct CreateDataSourceOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let dataSourceId: Swift.String?
    let creationStatus: QuickSightClientTypes.ResourceStatus?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension CreateDataSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationStatus = "CreationStatus"
        case dataSourceId = "DataSourceId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension CreateFolderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case folderType = "FolderType"
        case name = "Name"
        case parentFolderArn = "ParentFolderArn"
        case permissions = "Permissions"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let folderType = folderType {
            try encodeContainer.encode(folderType.rawValue, forKey: .folderType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentFolderArn = parentFolderArn {
            try encodeContainer.encode(parentFolderArn, forKey: .parentFolderArn)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for resourcepermissionlist0 in permissions {
                try permissionsContainer.encode(resourcepermissionlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let folderId = folderId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())"
    }
}

public struct CreateFolderInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account where you want to create the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The type of folder. By default, folderType is SHARED.
    public var folderType: QuickSightClientTypes.FolderType?
    /// The name of the folder.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) for the parent folder. ParentFolderArn can be null. An empty parentFolderArn creates a root-level folder.
    public var parentFolderArn: Swift.String?
    /// A structure that describes the principals and the resource-level permissions of a folder. To specify no permissions, omit Permissions.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// Tags for the folder.
    public var tags: [QuickSightClientTypes.Tag]?

    public init (
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil,
        folderType: QuickSightClientTypes.FolderType? = nil,
        name: Swift.String? = nil,
        parentFolderArn: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
        self.folderType = folderType
        self.name = name
        self.parentFolderArn = parentFolderArn
        self.permissions = permissions
        self.tags = tags
    }
}

struct CreateFolderInputBody: Swift.Equatable {
    let name: Swift.String?
    let folderType: QuickSightClientTypes.FolderType?
    let parentFolderArn: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let tags: [QuickSightClientTypes.Tag]?
}

extension CreateFolderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case folderType = "FolderType"
        case name = "Name"
        case parentFolderArn = "ParentFolderArn"
        case permissions = "Permissions"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let folderTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FolderType.self, forKey: .folderType)
        folderType = folderTypeDecoded
        let parentFolderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentFolderArn)
        parentFolderArn = parentFolderArnDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QuickSightClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QuickSightClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFolderMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let folderId = folderId else {
            return nil
        }
        guard let memberType = memberType else {
            return nil
        }
        guard let memberId = memberId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())/members/\(memberType.rawValue.urlPercentEncoding())/\(memberId.urlPercentEncoding())"
    }
}

public struct CreateFolderMembershipInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The ID of the asset (the dashboard, analysis, or dataset).
    /// This member is required.
    public var memberId: Swift.String?
    /// The type of the member, including DASHBOARD, ANALYSIS, and DATASET.
    /// This member is required.
    public var memberType: QuickSightClientTypes.MemberType?

    public init (
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil,
        memberId: Swift.String? = nil,
        memberType: QuickSightClientTypes.MemberType? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
        self.memberId = memberId
        self.memberType = memberType
    }
}

struct CreateFolderMembershipInputBody: Swift.Equatable {
}

extension CreateFolderMembershipInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CreateFolderMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFolderMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFolderMembershipOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFolderMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFolderMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.folderMember = output.folderMember
            self.requestId = output.requestId
            self.status = output.status
        } else {
            self.folderMember = nil
            self.requestId = nil
            self.status = 0
        }
    }
}

public struct CreateFolderMembershipOutputResponse: Swift.Equatable {
    /// Information about the member in the folder.
    public var folderMember: QuickSightClientTypes.FolderMember?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        folderMember: QuickSightClientTypes.FolderMember? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.folderMember = folderMember
        self.requestId = requestId
        self.status = status
    }
}

struct CreateFolderMembershipOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let folderMember: QuickSightClientTypes.FolderMember?
    let requestId: Swift.String?
}

extension CreateFolderMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case folderMember = "FolderMember"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let folderMemberDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FolderMember.self, forKey: .folderMember)
        folderMember = folderMemberDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension CreateFolderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFolderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFolderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFolderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFolderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.folderId = output.folderId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.folderId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateFolderOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the newly created folder.
    public var arn: Swift.String?
    /// The folder ID for the newly created folder.
    public var folderId: Swift.String?
    /// The request ID for the newly created folder.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        folderId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.folderId = folderId
        self.requestId = requestId
        self.status = status
    }
}

struct CreateFolderOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let arn: Swift.String?
    let folderId: Swift.String?
    let requestId: Swift.String?
}

extension CreateFolderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case folderId = "FolderId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let folderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .folderId)
        folderId = folderIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension CreateGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case groupName = "GroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }
}

extension CreateGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups"
    }
}

/// The request object for this operation.
public struct CreateGroupInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A description for the group that you want to create.
    public var description: Swift.String?
    /// A name for the group that you want to create.
    /// This member is required.
    public var groupName: Swift.String?
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        description: Swift.String? = nil,
        groupName: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.description = description
        self.groupName = groupName
        self.namespace = namespace
    }
}

struct CreateGroupInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let description: Swift.String?
}

extension CreateGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case groupName = "GroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateGroupMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let groupName = groupName else {
            return nil
        }
        guard let memberName = memberName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups/\(groupName.urlPercentEncoding())/members/\(memberName.urlPercentEncoding())"
    }
}

public struct CreateGroupMembershipInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The name of the group that you want to add the user to.
    /// This member is required.
    public var groupName: Swift.String?
    /// The name of the user that you want to add to the group membership.
    /// This member is required.
    public var memberName: Swift.String?
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        memberName: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.groupName = groupName
        self.memberName = memberName
        self.namespace = namespace
    }
}

struct CreateGroupMembershipInputBody: Swift.Equatable {
}

extension CreateGroupMembershipInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CreateGroupMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGroupMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGroupMembershipOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGroupMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateGroupMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groupMember = output.groupMember
            self.requestId = output.requestId
        } else {
            self.groupMember = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateGroupMembershipOutputResponse: Swift.Equatable {
    /// The group member.
    public var groupMember: QuickSightClientTypes.GroupMember?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        groupMember: QuickSightClientTypes.GroupMember? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.groupMember = groupMember
        self.requestId = requestId
        self.status = status
    }
}

struct CreateGroupMembershipOutputResponseBody: Swift.Equatable {
    let groupMember: QuickSightClientTypes.GroupMember?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension CreateGroupMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupMember = "GroupMember"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupMemberDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GroupMember.self, forKey: .groupMember)
        groupMember = groupMemberDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension CreateGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.group = output.group
            self.requestId = output.requestId
        } else {
            self.group = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

/// The response object for this operation.
public struct CreateGroupOutputResponse: Swift.Equatable {
    /// The name of the group.
    public var group: QuickSightClientTypes.Group?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        group: QuickSightClientTypes.Group? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.group = group
        self.requestId = requestId
        self.status = status
    }
}

struct CreateGroupOutputResponseBody: Swift.Equatable {
    let group: QuickSightClientTypes.Group?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension CreateGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group = "Group"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Group.self, forKey: .group)
        group = groupDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension CreateIAMPolicyAssignmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentName = "AssignmentName"
        case assignmentStatus = "AssignmentStatus"
        case identities = "Identities"
        case policyArn = "PolicyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentName = assignmentName {
            try encodeContainer.encode(assignmentName, forKey: .assignmentName)
        }
        if let assignmentStatus = assignmentStatus {
            try encodeContainer.encode(assignmentStatus.rawValue, forKey: .assignmentStatus)
        }
        if let identities = identities {
            var identitiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .identities)
            for (dictKey0, identitymap0) in identities {
                try identitiesContainer.encode(identitymap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
    }
}

extension CreateIAMPolicyAssignmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/iam-policy-assignments"
    }
}

public struct CreateIAMPolicyAssignmentInput: Swift.Equatable {
    /// The name of the assignment, also called a rule. It must be unique within an Amazon Web Services account.
    /// This member is required.
    public var assignmentName: Swift.String?
    /// The status of the assignment. Possible values are as follows:
    ///
    /// * ENABLED - Anything specified in this assignment is used when creating the data source.
    ///
    /// * DISABLED - This assignment isn't used when creating the data source.
    ///
    /// * DRAFT - This assignment is an unfinished draft and isn't used when creating the data source.
    /// This member is required.
    public var assignmentStatus: QuickSightClientTypes.AssignmentStatus?
    /// The ID of the Amazon Web Services account where you want to assign an IAM policy to Amazon QuickSight users or groups.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The Amazon QuickSight users, groups, or both that you want to assign the policy to.
    public var identities: [Swift.String:[Swift.String]]?
    /// The namespace that contains the assignment.
    /// This member is required.
    public var namespace: Swift.String?
    /// The ARN for the IAM policy to apply to the Amazon QuickSight users and groups specified in this assignment.
    public var policyArn: Swift.String?

    public init (
        assignmentName: Swift.String? = nil,
        assignmentStatus: QuickSightClientTypes.AssignmentStatus? = nil,
        awsAccountId: Swift.String? = nil,
        identities: [Swift.String:[Swift.String]]? = nil,
        namespace: Swift.String? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.assignmentName = assignmentName
        self.assignmentStatus = assignmentStatus
        self.awsAccountId = awsAccountId
        self.identities = identities
        self.namespace = namespace
        self.policyArn = policyArn
    }
}

struct CreateIAMPolicyAssignmentInputBody: Swift.Equatable {
    let assignmentName: Swift.String?
    let assignmentStatus: QuickSightClientTypes.AssignmentStatus?
    let policyArn: Swift.String?
    let identities: [Swift.String:[Swift.String]]?
}

extension CreateIAMPolicyAssignmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentName = "AssignmentName"
        case assignmentStatus = "AssignmentStatus"
        case identities = "Identities"
        case policyArn = "PolicyArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentName)
        assignmentName = assignmentNameDecoded
        let assignmentStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AssignmentStatus.self, forKey: .assignmentStatus)
        assignmentStatus = assignmentStatusDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let identitiesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .identities)
        var identitiesDecoded0: [Swift.String:[Swift.String]]? = nil
        if let identitiesContainer = identitiesContainer {
            identitiesDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, identitynamelist0) in identitiesContainer {
                var identitynamelist0Decoded0: [Swift.String]? = nil
                if let identitynamelist0 = identitynamelist0 {
                    identitynamelist0Decoded0 = [Swift.String]()
                    for string1 in identitynamelist0 {
                        if let string1 = string1 {
                            identitynamelist0Decoded0?.append(string1)
                        }
                    }
                }
                identitiesDecoded0?[key0] = identitynamelist0Decoded0
            }
        }
        identities = identitiesDecoded0
    }
}

extension CreateIAMPolicyAssignmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIAMPolicyAssignmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentUpdatingException" : self = .concurrentUpdatingException(try ConcurrentUpdatingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIAMPolicyAssignmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case concurrentUpdatingException(ConcurrentUpdatingException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIAMPolicyAssignmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateIAMPolicyAssignmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assignmentId = output.assignmentId
            self.assignmentName = output.assignmentName
            self.assignmentStatus = output.assignmentStatus
            self.identities = output.identities
            self.policyArn = output.policyArn
            self.requestId = output.requestId
        } else {
            self.assignmentId = nil
            self.assignmentName = nil
            self.assignmentStatus = nil
            self.identities = nil
            self.policyArn = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateIAMPolicyAssignmentOutputResponse: Swift.Equatable {
    /// The ID for the assignment.
    public var assignmentId: Swift.String?
    /// The name of the assignment. This name must be unique within the Amazon Web Services account.
    public var assignmentName: Swift.String?
    /// The status of the assignment. Possible values are as follows:
    ///
    /// * ENABLED - Anything specified in this assignment is used when creating the data source.
    ///
    /// * DISABLED - This assignment isn't used when creating the data source.
    ///
    /// * DRAFT - This assignment is an unfinished draft and isn't used when creating the data source.
    public var assignmentStatus: QuickSightClientTypes.AssignmentStatus?
    /// The Amazon QuickSight users, groups, or both that the IAM policy is assigned to.
    public var identities: [Swift.String:[Swift.String]]?
    /// The ARN for the IAM policy that is applied to the Amazon QuickSight users and groups specified in this assignment.
    public var policyArn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        assignmentId: Swift.String? = nil,
        assignmentName: Swift.String? = nil,
        assignmentStatus: QuickSightClientTypes.AssignmentStatus? = nil,
        identities: [Swift.String:[Swift.String]]? = nil,
        policyArn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.assignmentId = assignmentId
        self.assignmentName = assignmentName
        self.assignmentStatus = assignmentStatus
        self.identities = identities
        self.policyArn = policyArn
        self.requestId = requestId
        self.status = status
    }
}

struct CreateIAMPolicyAssignmentOutputResponseBody: Swift.Equatable {
    let assignmentName: Swift.String?
    let assignmentId: Swift.String?
    let assignmentStatus: QuickSightClientTypes.AssignmentStatus?
    let policyArn: Swift.String?
    let identities: [Swift.String:[Swift.String]]?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension CreateIAMPolicyAssignmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentId = "AssignmentId"
        case assignmentName = "AssignmentName"
        case assignmentStatus = "AssignmentStatus"
        case identities = "Identities"
        case policyArn = "PolicyArn"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentName)
        assignmentName = assignmentNameDecoded
        let assignmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentId)
        assignmentId = assignmentIdDecoded
        let assignmentStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AssignmentStatus.self, forKey: .assignmentStatus)
        assignmentStatus = assignmentStatusDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let identitiesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .identities)
        var identitiesDecoded0: [Swift.String:[Swift.String]]? = nil
        if let identitiesContainer = identitiesContainer {
            identitiesDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, identitynamelist0) in identitiesContainer {
                var identitynamelist0Decoded0: [Swift.String]? = nil
                if let identitynamelist0 = identitynamelist0 {
                    identitynamelist0Decoded0 = [Swift.String]()
                    for string1 in identitynamelist0 {
                        if let string1 = string1 {
                            identitynamelist0Decoded0?.append(string1)
                        }
                    }
                }
                identitiesDecoded0?[key0] = identitynamelist0Decoded0
            }
        }
        identities = identitiesDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension CreateIngestionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingestionType = "IngestionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ingestionType = ingestionType {
            try encodeContainer.encode(ingestionType.rawValue, forKey: .ingestionType)
        }
    }
}

extension CreateIngestionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSetId = dataSetId else {
            return nil
        }
        guard let ingestionId = ingestionId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/ingestions/\(ingestionId.urlPercentEncoding())"
    }
}

public struct CreateIngestionInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dataset used in the ingestion.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// An ID for the ingestion.
    /// This member is required.
    public var ingestionId: Swift.String?
    /// The type of ingestion that you want to create.
    public var ingestionType: QuickSightClientTypes.IngestionType?

    public init (
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        ingestionId: Swift.String? = nil,
        ingestionType: QuickSightClientTypes.IngestionType? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
        self.ingestionId = ingestionId
        self.ingestionType = ingestionType
    }
}

struct CreateIngestionInputBody: Swift.Equatable {
    let ingestionType: QuickSightClientTypes.IngestionType?
}

extension CreateIngestionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingestionType = "IngestionType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ingestionTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IngestionType.self, forKey: .ingestionType)
        ingestionType = ingestionTypeDecoded
    }
}

extension CreateIngestionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIngestionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIngestionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIngestionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateIngestionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.ingestionId = output.ingestionId
            self.ingestionStatus = output.ingestionStatus
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.ingestionId = nil
            self.ingestionStatus = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateIngestionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the data ingestion.
    public var arn: Swift.String?
    /// An ID for the ingestion.
    public var ingestionId: Swift.String?
    /// The ingestion status.
    public var ingestionStatus: QuickSightClientTypes.IngestionStatus?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        ingestionId: Swift.String? = nil,
        ingestionStatus: QuickSightClientTypes.IngestionStatus? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.ingestionId = ingestionId
        self.ingestionStatus = ingestionStatus
        self.requestId = requestId
        self.status = status
    }
}

struct CreateIngestionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let ingestionId: Swift.String?
    let ingestionStatus: QuickSightClientTypes.IngestionStatus?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension CreateIngestionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case ingestionId = "IngestionId"
        case ingestionStatus = "IngestionStatus"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ingestionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ingestionId)
        ingestionId = ingestionIdDecoded
        let ingestionStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IngestionStatus.self, forKey: .ingestionStatus)
        ingestionStatus = ingestionStatusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension CreateNamespaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStore = "IdentityStore"
        case namespace = "Namespace"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStore = identityStore {
            try encodeContainer.encode(identityStore.rawValue, forKey: .identityStore)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())"
    }
}

public struct CreateNamespaceInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that you want to create the Amazon QuickSight namespace in.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// Specifies the type of your user identity directory. Currently, this supports users with an identity type of QUICKSIGHT.
    /// This member is required.
    public var identityStore: QuickSightClientTypes.IdentityStore?
    /// The name that you want to use to describe the new namespace.
    /// This member is required.
    public var namespace: Swift.String?
    /// The tags that you want to associate with the namespace that you're creating.
    public var tags: [QuickSightClientTypes.Tag]?

    public init (
        awsAccountId: Swift.String? = nil,
        identityStore: QuickSightClientTypes.IdentityStore? = nil,
        namespace: Swift.String? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.identityStore = identityStore
        self.namespace = namespace
        self.tags = tags
    }
}

struct CreateNamespaceInputBody: Swift.Equatable {
    let namespace: Swift.String?
    let identityStore: QuickSightClientTypes.IdentityStore?
    let tags: [QuickSightClientTypes.Tag]?
}

extension CreateNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStore = "IdentityStore"
        case namespace = "Namespace"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let identityStoreDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IdentityStore.self, forKey: .identityStore)
        identityStore = identityStoreDecoded
        let tagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QuickSightClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QuickSightClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateNamespaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.capacityRegion = output.capacityRegion
            self.creationStatus = output.creationStatus
            self.identityStore = output.identityStore
            self.name = output.name
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.capacityRegion = nil
            self.creationStatus = nil
            self.identityStore = nil
            self.name = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateNamespaceOutputResponse: Swift.Equatable {
    /// The ARN of the Amazon QuickSight namespace you created.
    public var arn: Swift.String?
    /// The Amazon Web Services Region; that you want to use for the free SPICE capacity for the new namespace. This is set to the region that you run CreateNamespace in.
    public var capacityRegion: Swift.String?
    /// The status of the creation of the namespace. This is an asynchronous process. A status of CREATED means that your namespace is ready to use. If an error occurs, it indicates if the process is retryable or non-retryable. In the case of a non-retryable error, refer to the error message for follow-up tasks.
    public var creationStatus: QuickSightClientTypes.NamespaceStatus?
    /// Specifies the type of your user identity directory. Currently, this supports users with an identity type of QUICKSIGHT.
    public var identityStore: QuickSightClientTypes.IdentityStore?
    /// The name of the new namespace that you created.
    public var name: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        capacityRegion: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.NamespaceStatus? = nil,
        identityStore: QuickSightClientTypes.IdentityStore? = nil,
        name: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.capacityRegion = capacityRegion
        self.creationStatus = creationStatus
        self.identityStore = identityStore
        self.name = name
        self.requestId = requestId
        self.status = status
    }
}

struct CreateNamespaceOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let capacityRegion: Swift.String?
    let creationStatus: QuickSightClientTypes.NamespaceStatus?
    let identityStore: QuickSightClientTypes.IdentityStore?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension CreateNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case capacityRegion = "CapacityRegion"
        case creationStatus = "CreationStatus"
        case identityStore = "IdentityStore"
        case name = "Name"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let capacityRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacityRegion)
        capacityRegion = capacityRegionDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NamespaceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let identityStoreDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IdentityStore.self, forKey: .identityStore)
        identityStore = identityStoreDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension CreateTemplateAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateVersionNumber = "TemplateVersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateVersionNumber = templateVersionNumber {
            try encodeContainer.encode(templateVersionNumber, forKey: .templateVersionNumber)
        }
    }
}

extension CreateTemplateAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        guard let aliasName = aliasName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/aliases/\(aliasName.urlPercentEncoding())"
    }
}

public struct CreateTemplateAliasInput: Swift.Equatable {
    /// The name that you want to give to the template alias that you're creating. Don't start the alias name with the $ character. Alias names that start with $ are reserved by Amazon QuickSight.
    /// This member is required.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the template that you creating an alias for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// An ID for the template.
    /// This member is required.
    public var templateId: Swift.String?
    /// The version number of the template.
    /// This member is required.
    public var templateVersionNumber: Swift.Int?

    public init (
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        templateId: Swift.String? = nil,
        templateVersionNumber: Swift.Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.templateId = templateId
        self.templateVersionNumber = templateVersionNumber
    }
}

struct CreateTemplateAliasInputBody: Swift.Equatable {
    let templateVersionNumber: Swift.Int?
}

extension CreateTemplateAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateVersionNumber = "TemplateVersionNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .templateVersionNumber)
        templateVersionNumber = templateVersionNumberDecoded
    }
}

extension CreateTemplateAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTemplateAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTemplateAliasOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTemplateAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateTemplateAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.templateAlias = output.templateAlias
        } else {
            self.requestId = nil
            self.templateAlias = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateTemplateAliasOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// Information about the template alias.
    public var templateAlias: QuickSightClientTypes.TemplateAlias?

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateAlias: QuickSightClientTypes.TemplateAlias? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.templateAlias = templateAlias
    }
}

struct CreateTemplateAliasOutputResponseBody: Swift.Equatable {
    let templateAlias: QuickSightClientTypes.TemplateAlias?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension CreateTemplateAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case templateAlias = "TemplateAlias"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateAliasDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TemplateAlias.self, forKey: .templateAlias)
        templateAlias = templateAliasDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension CreateTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case permissions = "Permissions"
        case sourceEntity = "SourceEntity"
        case tags = "Tags"
        case versionDescription = "VersionDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for resourcepermissionlist0 in permissions {
                try permissionsContainer.encode(resourcepermissionlist0)
            }
        }
        if let sourceEntity = sourceEntity {
            try encodeContainer.encode(sourceEntity, forKey: .sourceEntity)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let versionDescription = versionDescription {
            try encodeContainer.encode(versionDescription, forKey: .versionDescription)
        }
    }
}

extension CreateTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())"
    }
}

public struct CreateTemplateInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the group is in. You use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A display name for the template.
    public var name: Swift.String?
    /// A list of resource permissions to be set on the template.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The entity that you are using as a source when you create the template. In SourceEntity, you specify the type of object you're using as source: SourceTemplate for a template or SourceAnalysis for an analysis. Both of these require an Amazon Resource Name (ARN). For SourceTemplate, specify the ARN of the source template. For SourceAnalysis, specify the ARN of the source analysis. The SourceTemplate ARN can contain any Amazon Web Services account and any Amazon QuickSight-supported Amazon Web Services Region. Use the DataSetReferences entity within SourceTemplate or SourceAnalysis to list the replacement datasets for the placeholders listed in the original. The schema in each dataset must match its placeholder.
    /// This member is required.
    public var sourceEntity: QuickSightClientTypes.TemplateSourceEntity?
    /// Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.
    public var tags: [QuickSightClientTypes.Tag]?
    /// An ID for the template that you want to create. This template is unique per Amazon Web Services Region; in each Amazon Web Services account.
    /// This member is required.
    public var templateId: Swift.String?
    /// A description of the current template version being created. This API operation creates the first version of the template. Every time UpdateTemplate is called, a new version is created. Each version of the template maintains a description of the version in the VersionDescription field.
    public var versionDescription: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        name: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        sourceEntity: QuickSightClientTypes.TemplateSourceEntity? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil,
        templateId: Swift.String? = nil,
        versionDescription: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.name = name
        self.permissions = permissions
        self.sourceEntity = sourceEntity
        self.tags = tags
        self.templateId = templateId
        self.versionDescription = versionDescription
    }
}

struct CreateTemplateInputBody: Swift.Equatable {
    let name: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let sourceEntity: QuickSightClientTypes.TemplateSourceEntity?
    let tags: [QuickSightClientTypes.Tag]?
    let versionDescription: Swift.String?
}

extension CreateTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case permissions = "Permissions"
        case sourceEntity = "SourceEntity"
        case tags = "Tags"
        case versionDescription = "VersionDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let sourceEntityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TemplateSourceEntity.self, forKey: .sourceEntity)
        sourceEntity = sourceEntityDecoded
        let tagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QuickSightClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QuickSightClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let versionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionDescription)
        versionDescription = versionDescriptionDecoded
    }
}

extension CreateTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationStatus = output.creationStatus
            self.requestId = output.requestId
            self.templateId = output.templateId
            self.versionArn = output.versionArn
        } else {
            self.arn = nil
            self.creationStatus = nil
            self.requestId = nil
            self.templateId = nil
            self.versionArn = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateTemplateOutputResponse: Swift.Equatable {
    /// The ARN for the template.
    public var arn: Swift.String?
    /// The template creation status.
    public var creationStatus: QuickSightClientTypes.ResourceStatus?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ID of the template.
    public var templateId: Swift.String?
    /// The ARN for the template, including the version information of the first version.
    public var versionArn: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.ResourceStatus? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateId: Swift.String? = nil,
        versionArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.requestId = requestId
        self.status = status
        self.templateId = templateId
        self.versionArn = versionArn
    }
}

struct CreateTemplateOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let versionArn: Swift.String?
    let templateId: Swift.String?
    let creationStatus: QuickSightClientTypes.ResourceStatus?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension CreateTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationStatus = "CreationStatus"
        case requestId = "RequestId"
        case status = "Status"
        case templateId = "TemplateId"
        case versionArn = "VersionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionArn)
        versionArn = versionArnDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension CreateThemeAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case themeVersionNumber = "ThemeVersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let themeVersionNumber = themeVersionNumber {
            try encodeContainer.encode(themeVersionNumber, forKey: .themeVersionNumber)
        }
    }
}

extension CreateThemeAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let themeId = themeId else {
            return nil
        }
        guard let aliasName = aliasName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())/aliases/\(aliasName.urlPercentEncoding())"
    }
}

public struct CreateThemeAliasInput: Swift.Equatable {
    /// The name that you want to give to the theme alias that you are creating. The alias name can't begin with a $. Alias names that start with $ are reserved by Amazon QuickSight.
    /// This member is required.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the theme for the new theme alias.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// An ID for the theme alias.
    /// This member is required.
    public var themeId: Swift.String?
    /// The version number of the theme.
    /// This member is required.
    public var themeVersionNumber: Swift.Int?

    public init (
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        themeId: Swift.String? = nil,
        themeVersionNumber: Swift.Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.themeId = themeId
        self.themeVersionNumber = themeVersionNumber
    }
}

struct CreateThemeAliasInputBody: Swift.Equatable {
    let themeVersionNumber: Swift.Int?
}

extension CreateThemeAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case themeVersionNumber = "ThemeVersionNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .themeVersionNumber)
        themeVersionNumber = themeVersionNumberDecoded
    }
}

extension CreateThemeAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateThemeAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateThemeAliasOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateThemeAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateThemeAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.themeAlias = output.themeAlias
        } else {
            self.requestId = nil
            self.themeAlias = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateThemeAliasOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// Information about the theme alias.
    public var themeAlias: QuickSightClientTypes.ThemeAlias?

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeAlias: QuickSightClientTypes.ThemeAlias? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.themeAlias = themeAlias
    }
}

struct CreateThemeAliasOutputResponseBody: Swift.Equatable {
    let themeAlias: QuickSightClientTypes.ThemeAlias?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension CreateThemeAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case themeAlias = "ThemeAlias"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeAliasDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ThemeAlias.self, forKey: .themeAlias)
        themeAlias = themeAliasDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension CreateThemeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseThemeId = "BaseThemeId"
        case configuration = "Configuration"
        case name = "Name"
        case permissions = "Permissions"
        case tags = "Tags"
        case versionDescription = "VersionDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseThemeId = baseThemeId {
            try encodeContainer.encode(baseThemeId, forKey: .baseThemeId)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for resourcepermissionlist0 in permissions {
                try permissionsContainer.encode(resourcepermissionlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let versionDescription = versionDescription {
            try encodeContainer.encode(versionDescription, forKey: .versionDescription)
        }
    }
}

extension CreateThemeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let themeId = themeId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())"
    }
}

public struct CreateThemeInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account where you want to store the new theme.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the theme that a custom theme will inherit from. All themes inherit from one of the starting themes defined by Amazon QuickSight. For a list of the starting themes, use ListThemes or choose Themes from within an analysis.
    /// This member is required.
    public var baseThemeId: Swift.String?
    /// The theme configuration, which contains the theme display properties.
    /// This member is required.
    public var configuration: QuickSightClientTypes.ThemeConfiguration?
    /// A display name for the theme.
    /// This member is required.
    public var name: Swift.String?
    /// A valid grouping of resource permissions to apply to the new theme.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// A map of the key-value pairs for the resource tag or tags that you want to add to the resource.
    public var tags: [QuickSightClientTypes.Tag]?
    /// An ID for the theme that you want to create. The theme ID is unique per Amazon Web Services Region in each Amazon Web Services account.
    /// This member is required.
    public var themeId: Swift.String?
    /// A description of the first version of the theme that you're creating. Every time UpdateTheme is called, a new version is created. Each version of the theme has a description of the version in the VersionDescription field.
    public var versionDescription: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        baseThemeId: Swift.String? = nil,
        configuration: QuickSightClientTypes.ThemeConfiguration? = nil,
        name: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil,
        themeId: Swift.String? = nil,
        versionDescription: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.baseThemeId = baseThemeId
        self.configuration = configuration
        self.name = name
        self.permissions = permissions
        self.tags = tags
        self.themeId = themeId
        self.versionDescription = versionDescription
    }
}

struct CreateThemeInputBody: Swift.Equatable {
    let name: Swift.String?
    let baseThemeId: Swift.String?
    let versionDescription: Swift.String?
    let configuration: QuickSightClientTypes.ThemeConfiguration?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let tags: [QuickSightClientTypes.Tag]?
}

extension CreateThemeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseThemeId = "BaseThemeId"
        case configuration = "Configuration"
        case name = "Name"
        case permissions = "Permissions"
        case tags = "Tags"
        case versionDescription = "VersionDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let baseThemeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseThemeId)
        baseThemeId = baseThemeIdDecoded
        let versionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionDescription)
        versionDescription = versionDescriptionDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ThemeConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QuickSightClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QuickSightClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateThemeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateThemeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateThemeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateThemeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateThemeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationStatus = output.creationStatus
            self.requestId = output.requestId
            self.themeId = output.themeId
            self.versionArn = output.versionArn
        } else {
            self.arn = nil
            self.creationStatus = nil
            self.requestId = nil
            self.themeId = nil
            self.versionArn = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateThemeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the theme.
    public var arn: Swift.String?
    /// The theme creation status.
    public var creationStatus: QuickSightClientTypes.ResourceStatus?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ID of the theme.
    public var themeId: Swift.String?
    /// The Amazon Resource Name (ARN) for the new theme.
    public var versionArn: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.ResourceStatus? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeId: Swift.String? = nil,
        versionArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.requestId = requestId
        self.status = status
        self.themeId = themeId
        self.versionArn = versionArn
    }
}

struct CreateThemeOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let versionArn: Swift.String?
    let themeId: Swift.String?
    let creationStatus: QuickSightClientTypes.ResourceStatus?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension CreateThemeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationStatus = "CreationStatus"
        case requestId = "RequestId"
        case status = "Status"
        case themeId = "ThemeId"
        case versionArn = "VersionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionArn)
        versionArn = versionArnDecoded
        let themeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeId)
        themeId = themeIdDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.CredentialPair: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alternateDataSourceParameters = "AlternateDataSourceParameters"
        case password = "Password"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alternateDataSourceParameters = alternateDataSourceParameters {
            var alternateDataSourceParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .alternateDataSourceParameters)
            for datasourceparameterslist0 in alternateDataSourceParameters {
                try alternateDataSourceParametersContainer.encode(datasourceparameterslist0)
            }
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let alternateDataSourceParametersContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataSourceParameters?].self, forKey: .alternateDataSourceParameters)
        var alternateDataSourceParametersDecoded0:[QuickSightClientTypes.DataSourceParameters]? = nil
        if let alternateDataSourceParametersContainer = alternateDataSourceParametersContainer {
            alternateDataSourceParametersDecoded0 = [QuickSightClientTypes.DataSourceParameters]()
            for union0 in alternateDataSourceParametersContainer {
                if let union0 = union0 {
                    alternateDataSourceParametersDecoded0?.append(union0)
                }
            }
        }
        alternateDataSourceParameters = alternateDataSourceParametersDecoded0
    }
}

extension QuickSightClientTypes {
    /// The combination of user name and password that are used as credentials.
    public struct CredentialPair: Swift.Equatable {
        /// A set of alternate data source parameters that you want to share for these credentials. The credentials are applied in tandem with the data source parameters when you copy a data source by using a create or update request. The API operation compares the DataSourceParameters structure that's in the request with the structures in the AlternateDataSourceParameters allow list. If the structures are an exact match, the request is allowed to use the new data source with the existing credentials. If the AlternateDataSourceParameters list is null, the DataSourceParameters originally used with these Credentials is automatically allowed.
        public var alternateDataSourceParameters: [QuickSightClientTypes.DataSourceParameters]?
        /// Password.
        /// This member is required.
        public var password: Swift.String?
        /// User name.
        /// This member is required.
        public var username: Swift.String?

        public init (
            alternateDataSourceParameters: [QuickSightClientTypes.DataSourceParameters]? = nil,
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.alternateDataSourceParameters = alternateDataSourceParameters
            self.password = password
            self.username = username
        }
    }

}

extension QuickSightClientTypes.CustomSql: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columns = "Columns"
        case dataSourceArn = "DataSourceArn"
        case name = "Name"
        case sqlQuery = "SqlQuery"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for inputcolumnlist0 in columns {
                try columnsContainer.encode(inputcolumnlist0)
            }
        }
        if let dataSourceArn = dataSourceArn {
            try encodeContainer.encode(dataSourceArn, forKey: .dataSourceArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sqlQuery = sqlQuery {
            try encodeContainer.encode(sqlQuery, forKey: .sqlQuery)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceArn)
        dataSourceArn = dataSourceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sqlQueryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sqlQuery)
        sqlQuery = sqlQueryDecoded
        let columnsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.InputColumn?].self, forKey: .columns)
        var columnsDecoded0:[QuickSightClientTypes.InputColumn]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [QuickSightClientTypes.InputColumn]()
            for structure0 in columnsContainer {
                if let structure0 = structure0 {
                    columnsDecoded0?.append(structure0)
                }
            }
        }
        columns = columnsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A physical table type built from the results of the custom SQL query.
    public struct CustomSql: Swift.Equatable {
        /// The column schema from the SQL query result set.
        public var columns: [QuickSightClientTypes.InputColumn]?
        /// The Amazon Resource Name (ARN) of the data source.
        /// This member is required.
        public var dataSourceArn: Swift.String?
        /// A display name for the SQL query result.
        /// This member is required.
        public var name: Swift.String?
        /// The SQL query.
        /// This member is required.
        public var sqlQuery: Swift.String?

        public init (
            columns: [QuickSightClientTypes.InputColumn]? = nil,
            dataSourceArn: Swift.String? = nil,
            name: Swift.String? = nil,
            sqlQuery: Swift.String? = nil
        )
        {
            self.columns = columns
            self.dataSourceArn = dataSourceArn
            self.name = name
            self.sqlQuery = sqlQuery
        }
    }

}

extension QuickSightClientTypes.Dashboard: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case dashboardId = "DashboardId"
        case lastPublishedTime = "LastPublishedTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let dashboardId = dashboardId {
            try encodeContainer.encode(dashboardId, forKey: .dashboardId)
        }
        if let lastPublishedTime = lastPublishedTime {
            try encodeContainer.encode(lastPublishedTime.timeIntervalSince1970, forKey: .lastPublishedTime)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardVersion.self, forKey: .version)
        version = versionDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastPublishedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastPublishedTime)
        lastPublishedTime = lastPublishedTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension QuickSightClientTypes {
    /// Dashboard.
    public struct Dashboard: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// The time that this dataset was created.
        public var createdTime: ClientRuntime.Date?
        /// Dashboard ID.
        public var dashboardId: Swift.String?
        /// The last time that this dataset was published.
        public var lastPublishedTime: ClientRuntime.Date?
        /// The last time that this dataset was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// A display name for the dashboard.
        public var name: Swift.String?
        /// Version.
        public var version: QuickSightClientTypes.DashboardVersion?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            dashboardId: Swift.String? = nil,
            lastPublishedTime: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            version: QuickSightClientTypes.DashboardVersion? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.dashboardId = dashboardId
            self.lastPublishedTime = lastPublishedTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.version = version
        }
    }

}

extension QuickSightClientTypes {
    public enum DashboardBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DashboardBehavior] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DashboardBehavior(rawValue: rawValue) ?? DashboardBehavior.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.DashboardError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QuickSightClientTypes {
    /// Dashboard error.
    public struct DashboardError: Swift.Equatable {
        /// Message.
        public var message: Swift.String?
        /// Type.
        public var type: QuickSightClientTypes.DashboardErrorType?

        public init (
            message: Swift.String? = nil,
            type: QuickSightClientTypes.DashboardErrorType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }

}

extension QuickSightClientTypes {
    public enum DashboardErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case columnGeographicRoleMismatch
        case columnReplacementMissing
        case columnTypeMismatch
        case dataSetNotFound
        case internalFailure
        case parameterNotFound
        case parameterTypeInvalid
        case parameterValueIncompatible
        case sourceNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [DashboardErrorType] {
            return [
                .accessDenied,
                .columnGeographicRoleMismatch,
                .columnReplacementMissing,
                .columnTypeMismatch,
                .dataSetNotFound,
                .internalFailure,
                .parameterNotFound,
                .parameterTypeInvalid,
                .parameterValueIncompatible,
                .sourceNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .columnGeographicRoleMismatch: return "COLUMN_GEOGRAPHIC_ROLE_MISMATCH"
            case .columnReplacementMissing: return "COLUMN_REPLACEMENT_MISSING"
            case .columnTypeMismatch: return "COLUMN_TYPE_MISMATCH"
            case .dataSetNotFound: return "DATA_SET_NOT_FOUND"
            case .internalFailure: return "INTERNAL_FAILURE"
            case .parameterNotFound: return "PARAMETER_NOT_FOUND"
            case .parameterTypeInvalid: return "PARAMETER_TYPE_INVALID"
            case .parameterValueIncompatible: return "PARAMETER_VALUE_INCOMPATIBLE"
            case .sourceNotFound: return "SOURCE_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DashboardErrorType(rawValue: rawValue) ?? DashboardErrorType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum DashboardFilterAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case quicksightUser
        case sdkUnknown(Swift.String)

        public static var allCases: [DashboardFilterAttribute] {
            return [
                .quicksightUser,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .quicksightUser: return "QUICKSIGHT_USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DashboardFilterAttribute(rawValue: rawValue) ?? DashboardFilterAttribute.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.DashboardPublishOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adHocFilteringOption = "AdHocFilteringOption"
        case exportToCSVOption = "ExportToCSVOption"
        case sheetControlsOption = "SheetControlsOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adHocFilteringOption = adHocFilteringOption {
            try encodeContainer.encode(adHocFilteringOption, forKey: .adHocFilteringOption)
        }
        if let exportToCSVOption = exportToCSVOption {
            try encodeContainer.encode(exportToCSVOption, forKey: .exportToCSVOption)
        }
        if let sheetControlsOption = sheetControlsOption {
            try encodeContainer.encode(sheetControlsOption, forKey: .sheetControlsOption)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adHocFilteringOptionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AdHocFilteringOption.self, forKey: .adHocFilteringOption)
        adHocFilteringOption = adHocFilteringOptionDecoded
        let exportToCSVOptionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ExportToCSVOption.self, forKey: .exportToCSVOption)
        exportToCSVOption = exportToCSVOptionDecoded
        let sheetControlsOptionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SheetControlsOption.self, forKey: .sheetControlsOption)
        sheetControlsOption = sheetControlsOptionDecoded
    }
}

extension QuickSightClientTypes {
    /// Dashboard publish options.
    public struct DashboardPublishOptions: Swift.Equatable {
        /// Ad hoc (one-time) filtering option.
        public var adHocFilteringOption: QuickSightClientTypes.AdHocFilteringOption?
        /// Export to .csv option.
        public var exportToCSVOption: QuickSightClientTypes.ExportToCSVOption?
        /// Sheet controls option.
        public var sheetControlsOption: QuickSightClientTypes.SheetControlsOption?

        public init (
            adHocFilteringOption: QuickSightClientTypes.AdHocFilteringOption? = nil,
            exportToCSVOption: QuickSightClientTypes.ExportToCSVOption? = nil,
            sheetControlsOption: QuickSightClientTypes.SheetControlsOption? = nil
        )
        {
            self.adHocFilteringOption = adHocFilteringOption
            self.exportToCSVOption = exportToCSVOption
            self.sheetControlsOption = sheetControlsOption
        }
    }

}

extension QuickSightClientTypes.DashboardSearchFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case `operator` = "Operator"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let nameDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardFilterAttribute.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension QuickSightClientTypes {
    /// A filter that you apply when searching for dashboards.
    public struct DashboardSearchFilter: Swift.Equatable {
        /// The name of the value that you want to use as a filter, for example, "Name": "QUICKSIGHT_USER".
        public var name: QuickSightClientTypes.DashboardFilterAttribute?
        /// The comparison operator that you want to use as a filter, for example, "Operator": "StringEquals".
        /// This member is required.
        public var `operator`: QuickSightClientTypes.FilterOperator?
        /// The value of the named item, in this case QUICKSIGHT_USER, that you want to use as a filter, for example, "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1".
        public var value: Swift.String?

        public init (
            name: QuickSightClientTypes.DashboardFilterAttribute? = nil,
            `operator`: QuickSightClientTypes.FilterOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }
    }

}

extension QuickSightClientTypes.DashboardSourceEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceTemplate = "SourceTemplate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceTemplate = sourceTemplate {
            try encodeContainer.encode(sourceTemplate, forKey: .sourceTemplate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTemplateDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardSourceTemplate.self, forKey: .sourceTemplate)
        sourceTemplate = sourceTemplateDecoded
    }
}

extension QuickSightClientTypes {
    /// Dashboard source entity.
    public struct DashboardSourceEntity: Swift.Equatable {
        /// Source template.
        public var sourceTemplate: QuickSightClientTypes.DashboardSourceTemplate?

        public init (
            sourceTemplate: QuickSightClientTypes.DashboardSourceTemplate? = nil
        )
        {
            self.sourceTemplate = sourceTemplate
        }
    }

}

extension QuickSightClientTypes.DashboardSourceTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case dataSetReferences = "DataSetReferences"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dataSetReferences = dataSetReferences {
            var dataSetReferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSetReferences)
            for datasetreferencelist0 in dataSetReferences {
                try dataSetReferencesContainer.encode(datasetreferencelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetReferencesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataSetReference?].self, forKey: .dataSetReferences)
        var dataSetReferencesDecoded0:[QuickSightClientTypes.DataSetReference]? = nil
        if let dataSetReferencesContainer = dataSetReferencesContainer {
            dataSetReferencesDecoded0 = [QuickSightClientTypes.DataSetReference]()
            for structure0 in dataSetReferencesContainer {
                if let structure0 = structure0 {
                    dataSetReferencesDecoded0?.append(structure0)
                }
            }
        }
        dataSetReferences = dataSetReferencesDecoded0
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension QuickSightClientTypes {
    /// Dashboard source template.
    public struct DashboardSourceTemplate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        /// This member is required.
        public var arn: Swift.String?
        /// Dataset references.
        /// This member is required.
        public var dataSetReferences: [QuickSightClientTypes.DataSetReference]?

        public init (
            arn: Swift.String? = nil,
            dataSetReferences: [QuickSightClientTypes.DataSetReference]? = nil
        )
        {
            self.arn = arn
            self.dataSetReferences = dataSetReferences
        }
    }

}

extension QuickSightClientTypes.DashboardSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case dashboardId = "DashboardId"
        case lastPublishedTime = "LastPublishedTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case publishedVersionNumber = "PublishedVersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let dashboardId = dashboardId {
            try encodeContainer.encode(dashboardId, forKey: .dashboardId)
        }
        if let lastPublishedTime = lastPublishedTime {
            try encodeContainer.encode(lastPublishedTime.timeIntervalSince1970, forKey: .lastPublishedTime)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let publishedVersionNumber = publishedVersionNumber {
            try encodeContainer.encode(publishedVersionNumber, forKey: .publishedVersionNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let dashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let publishedVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .publishedVersionNumber)
        publishedVersionNumber = publishedVersionNumberDecoded
        let lastPublishedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastPublishedTime)
        lastPublishedTime = lastPublishedTimeDecoded
    }
}

extension QuickSightClientTypes {
    /// Dashboard summary.
    public struct DashboardSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// The time that this dashboard was created.
        public var createdTime: ClientRuntime.Date?
        /// Dashboard ID.
        public var dashboardId: Swift.String?
        /// The last time that this dashboard was published.
        public var lastPublishedTime: ClientRuntime.Date?
        /// The last time that this dashboard was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// A display name for the dashboard.
        public var name: Swift.String?
        /// Published version number.
        public var publishedVersionNumber: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            dashboardId: Swift.String? = nil,
            lastPublishedTime: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            publishedVersionNumber: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.dashboardId = dashboardId
            self.lastPublishedTime = lastPublishedTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.publishedVersionNumber = publishedVersionNumber
        }
    }

}

extension QuickSightClientTypes {
    public enum DashboardUIState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case collapsed
        case expanded
        case sdkUnknown(Swift.String)

        public static var allCases: [DashboardUIState] {
            return [
                .collapsed,
                .expanded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .collapsed: return "COLLAPSED"
            case .expanded: return "EXPANDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DashboardUIState(rawValue: rawValue) ?? DashboardUIState.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.DashboardVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case dataSetArns = "DataSetArns"
        case description = "Description"
        case errors = "Errors"
        case sheets = "Sheets"
        case sourceEntityArn = "SourceEntityArn"
        case status = "Status"
        case themeArn = "ThemeArn"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let dataSetArns = dataSetArns {
            var dataSetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSetArns)
            for datasetarnslist0 in dataSetArns {
                try dataSetArnsContainer.encode(datasetarnslist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for dashboarderrorlist0 in errors {
                try errorsContainer.encode(dashboarderrorlist0)
            }
        }
        if let sheets = sheets {
            var sheetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sheets)
            for sheetlist0 in sheets {
                try sheetsContainer.encode(sheetlist0)
            }
        }
        if let sourceEntityArn = sourceEntityArn {
            try encodeContainer.encode(sourceEntityArn, forKey: .sourceEntityArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let themeArn = themeArn {
            try encodeContainer.encode(themeArn, forKey: .themeArn)
        }
        if let versionNumber = versionNumber {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let errorsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DashboardError?].self, forKey: .errors)
        var errorsDecoded0:[QuickSightClientTypes.DashboardError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [QuickSightClientTypes.DashboardError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let sourceEntityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceEntityArn)
        sourceEntityArn = sourceEntityArnDecoded
        let dataSetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dataSetArns)
        var dataSetArnsDecoded0:[Swift.String]? = nil
        if let dataSetArnsContainer = dataSetArnsContainer {
            dataSetArnsDecoded0 = [Swift.String]()
            for string0 in dataSetArnsContainer {
                if let string0 = string0 {
                    dataSetArnsDecoded0?.append(string0)
                }
            }
        }
        dataSetArns = dataSetArnsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
        let sheetsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Sheet?].self, forKey: .sheets)
        var sheetsDecoded0:[QuickSightClientTypes.Sheet]? = nil
        if let sheetsContainer = sheetsContainer {
            sheetsDecoded0 = [QuickSightClientTypes.Sheet]()
            for structure0 in sheetsContainer {
                if let structure0 = structure0 {
                    sheetsDecoded0?.append(structure0)
                }
            }
        }
        sheets = sheetsDecoded0
    }
}

extension QuickSightClientTypes {
    /// Dashboard version.
    public struct DashboardVersion: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// The time that this dashboard version was created.
        public var createdTime: ClientRuntime.Date?
        /// The Amazon Resource Numbers (ARNs) for the datasets that are associated with this version of the dashboard.
        public var dataSetArns: [Swift.String]?
        /// Description.
        public var description: Swift.String?
        /// Errors associated with this dashboard version.
        public var errors: [QuickSightClientTypes.DashboardError]?
        /// A list of the associated sheets with the unique identifier and name of each sheet.
        public var sheets: [QuickSightClientTypes.Sheet]?
        /// Source entity ARN.
        public var sourceEntityArn: Swift.String?
        /// The HTTP status of the request.
        public var status: QuickSightClientTypes.ResourceStatus?
        /// The ARN of the theme associated with a version of the dashboard.
        public var themeArn: Swift.String?
        /// Version number for this version of the dashboard.
        public var versionNumber: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            dataSetArns: [Swift.String]? = nil,
            description: Swift.String? = nil,
            errors: [QuickSightClientTypes.DashboardError]? = nil,
            sheets: [QuickSightClientTypes.Sheet]? = nil,
            sourceEntityArn: Swift.String? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil,
            themeArn: Swift.String? = nil,
            versionNumber: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.dataSetArns = dataSetArns
            self.description = description
            self.errors = errors
            self.sheets = sheets
            self.sourceEntityArn = sourceEntityArn
            self.status = status
            self.themeArn = themeArn
            self.versionNumber = versionNumber
        }
    }

}

extension QuickSightClientTypes.DashboardVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case sourceEntityArn = "SourceEntityArn"
        case status = "Status"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let sourceEntityArn = sourceEntityArn {
            try encodeContainer.encode(sourceEntityArn, forKey: .sourceEntityArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let versionNumber = versionNumber {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let sourceEntityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceEntityArn)
        sourceEntityArn = sourceEntityArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension QuickSightClientTypes {
    /// Dashboard version summary.
    public struct DashboardVersionSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// The time that this dashboard version was created.
        public var createdTime: ClientRuntime.Date?
        /// Description.
        public var description: Swift.String?
        /// Source entity ARN.
        public var sourceEntityArn: Swift.String?
        /// The HTTP status of the request.
        public var status: QuickSightClientTypes.ResourceStatus?
        /// Version number.
        public var versionNumber: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            sourceEntityArn: Swift.String? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil,
            versionNumber: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.sourceEntityArn = sourceEntityArn
            self.status = status
            self.versionNumber = versionNumber
        }
    }

}

extension QuickSightClientTypes.DataColorPalette: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case colors = "Colors"
        case emptyFillColor = "EmptyFillColor"
        case minMaxGradient = "MinMaxGradient"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let colors = colors {
            var colorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .colors)
            for colorlist0 in colors {
                try colorsContainer.encode(colorlist0)
            }
        }
        if let emptyFillColor = emptyFillColor {
            try encodeContainer.encode(emptyFillColor, forKey: .emptyFillColor)
        }
        if let minMaxGradient = minMaxGradient {
            var minMaxGradientContainer = encodeContainer.nestedUnkeyedContainer(forKey: .minMaxGradient)
            for colorlist0 in minMaxGradient {
                try minMaxGradientContainer.encode(colorlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let colorsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .colors)
        var colorsDecoded0:[Swift.String]? = nil
        if let colorsContainer = colorsContainer {
            colorsDecoded0 = [Swift.String]()
            for string0 in colorsContainer {
                if let string0 = string0 {
                    colorsDecoded0?.append(string0)
                }
            }
        }
        colors = colorsDecoded0
        let minMaxGradientContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .minMaxGradient)
        var minMaxGradientDecoded0:[Swift.String]? = nil
        if let minMaxGradientContainer = minMaxGradientContainer {
            minMaxGradientDecoded0 = [Swift.String]()
            for string0 in minMaxGradientContainer {
                if let string0 = string0 {
                    minMaxGradientDecoded0?.append(string0)
                }
            }
        }
        minMaxGradient = minMaxGradientDecoded0
        let emptyFillColorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emptyFillColor)
        emptyFillColor = emptyFillColorDecoded
    }
}

extension QuickSightClientTypes {
    /// The theme colors that are used for data colors in charts. The colors description is a hexadecimal color code that consists of six alphanumerical characters, prefixed with #, for example #37BFF5.
    public struct DataColorPalette: Swift.Equatable {
        /// The hexadecimal codes for the colors.
        public var colors: [Swift.String]?
        /// The hexadecimal code of a color that applies to charts where a lack of data is highlighted.
        public var emptyFillColor: Swift.String?
        /// The minimum and maximum hexadecimal codes that describe a color gradient.
        public var minMaxGradient: [Swift.String]?

        public init (
            colors: [Swift.String]? = nil,
            emptyFillColor: Swift.String? = nil,
            minMaxGradient: [Swift.String]? = nil
        )
        {
            self.colors = colors
            self.emptyFillColor = emptyFillColor
            self.minMaxGradient = minMaxGradient
        }
    }

}

extension QuickSightClientTypes.DataSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case columnGroups = "ColumnGroups"
        case columnLevelPermissionRules = "ColumnLevelPermissionRules"
        case consumedSpiceCapacityInBytes = "ConsumedSpiceCapacityInBytes"
        case createdTime = "CreatedTime"
        case dataSetId = "DataSetId"
        case dataSetUsageConfiguration = "DataSetUsageConfiguration"
        case fieldFolders = "FieldFolders"
        case importMode = "ImportMode"
        case lastUpdatedTime = "LastUpdatedTime"
        case logicalTableMap = "LogicalTableMap"
        case name = "Name"
        case outputColumns = "OutputColumns"
        case physicalTableMap = "PhysicalTableMap"
        case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
        case rowLevelPermissionTagConfiguration = "RowLevelPermissionTagConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let columnGroups = columnGroups {
            var columnGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnGroups)
            for columngrouplist0 in columnGroups {
                try columnGroupsContainer.encode(columngrouplist0)
            }
        }
        if let columnLevelPermissionRules = columnLevelPermissionRules {
            var columnLevelPermissionRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnLevelPermissionRules)
            for columnlevelpermissionrulelist0 in columnLevelPermissionRules {
                try columnLevelPermissionRulesContainer.encode(columnlevelpermissionrulelist0)
            }
        }
        if consumedSpiceCapacityInBytes != 0 {
            try encodeContainer.encode(consumedSpiceCapacityInBytes, forKey: .consumedSpiceCapacityInBytes)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let dataSetUsageConfiguration = dataSetUsageConfiguration {
            try encodeContainer.encode(dataSetUsageConfiguration, forKey: .dataSetUsageConfiguration)
        }
        if let fieldFolders = fieldFolders {
            var fieldFoldersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .fieldFolders)
            for (dictKey0, fieldfoldermap0) in fieldFolders {
                try fieldFoldersContainer.encode(fieldfoldermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let importMode = importMode {
            try encodeContainer.encode(importMode.rawValue, forKey: .importMode)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let logicalTableMap = logicalTableMap {
            var logicalTableMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .logicalTableMap)
            for (dictKey0, logicaltablemap0) in logicalTableMap {
                try logicalTableMapContainer.encode(logicaltablemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputColumns = outputColumns {
            var outputColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputColumns)
            for outputcolumnlist0 in outputColumns {
                try outputColumnsContainer.encode(outputcolumnlist0)
            }
        }
        if let physicalTableMap = physicalTableMap {
            var physicalTableMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .physicalTableMap)
            for (dictKey0, physicaltablemap0) in physicalTableMap {
                try physicalTableMapContainer.encode(physicaltablemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let rowLevelPermissionDataSet = rowLevelPermissionDataSet {
            try encodeContainer.encode(rowLevelPermissionDataSet, forKey: .rowLevelPermissionDataSet)
        }
        if let rowLevelPermissionTagConfiguration = rowLevelPermissionTagConfiguration {
            try encodeContainer.encode(rowLevelPermissionTagConfiguration, forKey: .rowLevelPermissionTagConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let physicalTableMapContainer = try containerValues.decodeIfPresent([Swift.String: QuickSightClientTypes.PhysicalTable?].self, forKey: .physicalTableMap)
        var physicalTableMapDecoded0: [Swift.String:QuickSightClientTypes.PhysicalTable]? = nil
        if let physicalTableMapContainer = physicalTableMapContainer {
            physicalTableMapDecoded0 = [Swift.String:QuickSightClientTypes.PhysicalTable]()
            for (key0, physicaltable0) in physicalTableMapContainer {
                if let physicaltable0 = physicaltable0 {
                    physicalTableMapDecoded0?[key0] = physicaltable0
                }
            }
        }
        physicalTableMap = physicalTableMapDecoded0
        let logicalTableMapContainer = try containerValues.decodeIfPresent([Swift.String: QuickSightClientTypes.LogicalTable?].self, forKey: .logicalTableMap)
        var logicalTableMapDecoded0: [Swift.String:QuickSightClientTypes.LogicalTable]? = nil
        if let logicalTableMapContainer = logicalTableMapContainer {
            logicalTableMapDecoded0 = [Swift.String:QuickSightClientTypes.LogicalTable]()
            for (key0, logicaltable0) in logicalTableMapContainer {
                if let logicaltable0 = logicaltable0 {
                    logicalTableMapDecoded0?[key0] = logicaltable0
                }
            }
        }
        logicalTableMap = logicalTableMapDecoded0
        let outputColumnsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.OutputColumn?].self, forKey: .outputColumns)
        var outputColumnsDecoded0:[QuickSightClientTypes.OutputColumn]? = nil
        if let outputColumnsContainer = outputColumnsContainer {
            outputColumnsDecoded0 = [QuickSightClientTypes.OutputColumn]()
            for structure0 in outputColumnsContainer {
                if let structure0 = structure0 {
                    outputColumnsDecoded0?.append(structure0)
                }
            }
        }
        outputColumns = outputColumnsDecoded0
        let importModeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSetImportMode.self, forKey: .importMode)
        importMode = importModeDecoded
        let consumedSpiceCapacityInBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .consumedSpiceCapacityInBytes)
        consumedSpiceCapacityInBytes = consumedSpiceCapacityInBytesDecoded
        let columnGroupsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnGroup?].self, forKey: .columnGroups)
        var columnGroupsDecoded0:[QuickSightClientTypes.ColumnGroup]? = nil
        if let columnGroupsContainer = columnGroupsContainer {
            columnGroupsDecoded0 = [QuickSightClientTypes.ColumnGroup]()
            for structure0 in columnGroupsContainer {
                if let structure0 = structure0 {
                    columnGroupsDecoded0?.append(structure0)
                }
            }
        }
        columnGroups = columnGroupsDecoded0
        let fieldFoldersContainer = try containerValues.decodeIfPresent([Swift.String: QuickSightClientTypes.FieldFolder?].self, forKey: .fieldFolders)
        var fieldFoldersDecoded0: [Swift.String:QuickSightClientTypes.FieldFolder]? = nil
        if let fieldFoldersContainer = fieldFoldersContainer {
            fieldFoldersDecoded0 = [Swift.String:QuickSightClientTypes.FieldFolder]()
            for (key0, fieldfolder0) in fieldFoldersContainer {
                if let fieldfolder0 = fieldfolder0 {
                    fieldFoldersDecoded0?[key0] = fieldfolder0
                }
            }
        }
        fieldFolders = fieldFoldersDecoded0
        let rowLevelPermissionDataSetDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RowLevelPermissionDataSet.self, forKey: .rowLevelPermissionDataSet)
        rowLevelPermissionDataSet = rowLevelPermissionDataSetDecoded
        let rowLevelPermissionTagConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RowLevelPermissionTagConfiguration.self, forKey: .rowLevelPermissionTagConfiguration)
        rowLevelPermissionTagConfiguration = rowLevelPermissionTagConfigurationDecoded
        let columnLevelPermissionRulesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnLevelPermissionRule?].self, forKey: .columnLevelPermissionRules)
        var columnLevelPermissionRulesDecoded0:[QuickSightClientTypes.ColumnLevelPermissionRule]? = nil
        if let columnLevelPermissionRulesContainer = columnLevelPermissionRulesContainer {
            columnLevelPermissionRulesDecoded0 = [QuickSightClientTypes.ColumnLevelPermissionRule]()
            for structure0 in columnLevelPermissionRulesContainer {
                if let structure0 = structure0 {
                    columnLevelPermissionRulesDecoded0?.append(structure0)
                }
            }
        }
        columnLevelPermissionRules = columnLevelPermissionRulesDecoded0
        let dataSetUsageConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSetUsageConfiguration.self, forKey: .dataSetUsageConfiguration)
        dataSetUsageConfiguration = dataSetUsageConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// Dataset.
    public struct DataSet: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// Groupings of columns that work together in certain Amazon QuickSight features. Currently, only geospatial hierarchy is supported.
        public var columnGroups: [QuickSightClientTypes.ColumnGroup]?
        /// A set of one or more definitions of a [ColumnLevelPermissionRule](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ColumnLevelPermissionRule.html).
        public var columnLevelPermissionRules: [QuickSightClientTypes.ColumnLevelPermissionRule]?
        /// The amount of SPICE capacity used by this dataset. This is 0 if the dataset isn't imported into SPICE.
        public var consumedSpiceCapacityInBytes: Swift.Int
        /// The time that this dataset was created.
        public var createdTime: ClientRuntime.Date?
        /// The ID of the dataset.
        public var dataSetId: Swift.String?
        /// The usage configuration to apply to child datasets that reference this dataset as a source.
        public var dataSetUsageConfiguration: QuickSightClientTypes.DataSetUsageConfiguration?
        /// The folder that contains fields and nested subfolders for your dataset.
        public var fieldFolders: [Swift.String:QuickSightClientTypes.FieldFolder]?
        /// A value that indicates whether you want to import the data into SPICE.
        public var importMode: QuickSightClientTypes.DataSetImportMode?
        /// The last time that this dataset was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// Configures the combination and transformation of the data from the physical tables.
        public var logicalTableMap: [Swift.String:QuickSightClientTypes.LogicalTable]?
        /// A display name for the dataset.
        public var name: Swift.String?
        /// The list of columns after all transforms. These columns are available in templates, analyses, and dashboards.
        public var outputColumns: [QuickSightClientTypes.OutputColumn]?
        /// Declares the physical tables that are available in the underlying data sources.
        public var physicalTableMap: [Swift.String:QuickSightClientTypes.PhysicalTable]?
        /// The row-level security configuration for the dataset.
        public var rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet?
        /// The element you can use to define tags for row-level security.
        public var rowLevelPermissionTagConfiguration: QuickSightClientTypes.RowLevelPermissionTagConfiguration?

        public init (
            arn: Swift.String? = nil,
            columnGroups: [QuickSightClientTypes.ColumnGroup]? = nil,
            columnLevelPermissionRules: [QuickSightClientTypes.ColumnLevelPermissionRule]? = nil,
            consumedSpiceCapacityInBytes: Swift.Int = 0,
            createdTime: ClientRuntime.Date? = nil,
            dataSetId: Swift.String? = nil,
            dataSetUsageConfiguration: QuickSightClientTypes.DataSetUsageConfiguration? = nil,
            fieldFolders: [Swift.String:QuickSightClientTypes.FieldFolder]? = nil,
            importMode: QuickSightClientTypes.DataSetImportMode? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            logicalTableMap: [Swift.String:QuickSightClientTypes.LogicalTable]? = nil,
            name: Swift.String? = nil,
            outputColumns: [QuickSightClientTypes.OutputColumn]? = nil,
            physicalTableMap: [Swift.String:QuickSightClientTypes.PhysicalTable]? = nil,
            rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet? = nil,
            rowLevelPermissionTagConfiguration: QuickSightClientTypes.RowLevelPermissionTagConfiguration? = nil
        )
        {
            self.arn = arn
            self.columnGroups = columnGroups
            self.columnLevelPermissionRules = columnLevelPermissionRules
            self.consumedSpiceCapacityInBytes = consumedSpiceCapacityInBytes
            self.createdTime = createdTime
            self.dataSetId = dataSetId
            self.dataSetUsageConfiguration = dataSetUsageConfiguration
            self.fieldFolders = fieldFolders
            self.importMode = importMode
            self.lastUpdatedTime = lastUpdatedTime
            self.logicalTableMap = logicalTableMap
            self.name = name
            self.outputColumns = outputColumns
            self.physicalTableMap = physicalTableMap
            self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
            self.rowLevelPermissionTagConfiguration = rowLevelPermissionTagConfiguration
        }
    }

}

extension QuickSightClientTypes.DataSetConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnGroupSchemaList = "ColumnGroupSchemaList"
        case dataSetSchema = "DataSetSchema"
        case placeholder = "Placeholder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnGroupSchemaList = columnGroupSchemaList {
            var columnGroupSchemaListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnGroupSchemaList)
            for columngroupschemalist0 in columnGroupSchemaList {
                try columnGroupSchemaListContainer.encode(columngroupschemalist0)
            }
        }
        if let dataSetSchema = dataSetSchema {
            try encodeContainer.encode(dataSetSchema, forKey: .dataSetSchema)
        }
        if let placeholder = placeholder {
            try encodeContainer.encode(placeholder, forKey: .placeholder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let placeholderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .placeholder)
        placeholder = placeholderDecoded
        let dataSetSchemaDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSetSchema.self, forKey: .dataSetSchema)
        dataSetSchema = dataSetSchemaDecoded
        let columnGroupSchemaListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnGroupSchema?].self, forKey: .columnGroupSchemaList)
        var columnGroupSchemaListDecoded0:[QuickSightClientTypes.ColumnGroupSchema]? = nil
        if let columnGroupSchemaListContainer = columnGroupSchemaListContainer {
            columnGroupSchemaListDecoded0 = [QuickSightClientTypes.ColumnGroupSchema]()
            for structure0 in columnGroupSchemaListContainer {
                if let structure0 = structure0 {
                    columnGroupSchemaListDecoded0?.append(structure0)
                }
            }
        }
        columnGroupSchemaList = columnGroupSchemaListDecoded0
    }
}

extension QuickSightClientTypes {
    /// Dataset configuration.
    public struct DataSetConfiguration: Swift.Equatable {
        /// A structure containing the list of column group schemas.
        public var columnGroupSchemaList: [QuickSightClientTypes.ColumnGroupSchema]?
        /// Dataset schema.
        public var dataSetSchema: QuickSightClientTypes.DataSetSchema?
        /// Placeholder.
        public var placeholder: Swift.String?

        public init (
            columnGroupSchemaList: [QuickSightClientTypes.ColumnGroupSchema]? = nil,
            dataSetSchema: QuickSightClientTypes.DataSetSchema? = nil,
            placeholder: Swift.String? = nil
        )
        {
            self.columnGroupSchemaList = columnGroupSchemaList
            self.dataSetSchema = dataSetSchema
            self.placeholder = placeholder
        }
    }

}

extension QuickSightClientTypes {
    public enum DataSetImportMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case directQuery
        case spice
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSetImportMode] {
            return [
                .directQuery,
                .spice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .directQuery: return "DIRECT_QUERY"
            case .spice: return "SPICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSetImportMode(rawValue: rawValue) ?? DataSetImportMode.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.DataSetReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetArn = "DataSetArn"
        case dataSetPlaceholder = "DataSetPlaceholder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSetArn = dataSetArn {
            try encodeContainer.encode(dataSetArn, forKey: .dataSetArn)
        }
        if let dataSetPlaceholder = dataSetPlaceholder {
            try encodeContainer.encode(dataSetPlaceholder, forKey: .dataSetPlaceholder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetPlaceholderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetPlaceholder)
        dataSetPlaceholder = dataSetPlaceholderDecoded
        let dataSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetArn)
        dataSetArn = dataSetArnDecoded
    }
}

extension QuickSightClientTypes {
    /// Dataset reference.
    public struct DataSetReference: Swift.Equatable {
        /// Dataset Amazon Resource Name (ARN).
        /// This member is required.
        public var dataSetArn: Swift.String?
        /// Dataset placeholder.
        /// This member is required.
        public var dataSetPlaceholder: Swift.String?

        public init (
            dataSetArn: Swift.String? = nil,
            dataSetPlaceholder: Swift.String? = nil
        )
        {
            self.dataSetArn = dataSetArn
            self.dataSetPlaceholder = dataSetPlaceholder
        }
    }

}

extension QuickSightClientTypes.DataSetSchema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnSchemaList = "ColumnSchemaList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnSchemaList = columnSchemaList {
            var columnSchemaListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnSchemaList)
            for columnschemalist0 in columnSchemaList {
                try columnSchemaListContainer.encode(columnschemalist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnSchemaListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnSchema?].self, forKey: .columnSchemaList)
        var columnSchemaListDecoded0:[QuickSightClientTypes.ColumnSchema]? = nil
        if let columnSchemaListContainer = columnSchemaListContainer {
            columnSchemaListDecoded0 = [QuickSightClientTypes.ColumnSchema]()
            for structure0 in columnSchemaListContainer {
                if let structure0 = structure0 {
                    columnSchemaListDecoded0?.append(structure0)
                }
            }
        }
        columnSchemaList = columnSchemaListDecoded0
    }
}

extension QuickSightClientTypes {
    /// Dataset schema.
    public struct DataSetSchema: Swift.Equatable {
        /// A structure containing the list of column schemas.
        public var columnSchemaList: [QuickSightClientTypes.ColumnSchema]?

        public init (
            columnSchemaList: [QuickSightClientTypes.ColumnSchema]? = nil
        )
        {
            self.columnSchemaList = columnSchemaList
        }
    }

}

extension QuickSightClientTypes.DataSetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case columnLevelPermissionRulesApplied = "ColumnLevelPermissionRulesApplied"
        case createdTime = "CreatedTime"
        case dataSetId = "DataSetId"
        case importMode = "ImportMode"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
        case rowLevelPermissionTagConfigurationApplied = "RowLevelPermissionTagConfigurationApplied"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if columnLevelPermissionRulesApplied != false {
            try encodeContainer.encode(columnLevelPermissionRulesApplied, forKey: .columnLevelPermissionRulesApplied)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let importMode = importMode {
            try encodeContainer.encode(importMode.rawValue, forKey: .importMode)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rowLevelPermissionDataSet = rowLevelPermissionDataSet {
            try encodeContainer.encode(rowLevelPermissionDataSet, forKey: .rowLevelPermissionDataSet)
        }
        if rowLevelPermissionTagConfigurationApplied != false {
            try encodeContainer.encode(rowLevelPermissionTagConfigurationApplied, forKey: .rowLevelPermissionTagConfigurationApplied)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let importModeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSetImportMode.self, forKey: .importMode)
        importMode = importModeDecoded
        let rowLevelPermissionDataSetDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RowLevelPermissionDataSet.self, forKey: .rowLevelPermissionDataSet)
        rowLevelPermissionDataSet = rowLevelPermissionDataSetDecoded
        let rowLevelPermissionTagConfigurationAppliedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .rowLevelPermissionTagConfigurationApplied)
        rowLevelPermissionTagConfigurationApplied = rowLevelPermissionTagConfigurationAppliedDecoded
        let columnLevelPermissionRulesAppliedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .columnLevelPermissionRulesApplied)
        columnLevelPermissionRulesApplied = columnLevelPermissionRulesAppliedDecoded
    }
}

extension QuickSightClientTypes {
    /// Dataset summary.
    public struct DataSetSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the dataset.
        public var arn: Swift.String?
        /// A value that indicates if the dataset has column level permission configured.
        public var columnLevelPermissionRulesApplied: Swift.Bool
        /// The time that this dataset was created.
        public var createdTime: ClientRuntime.Date?
        /// The ID of the dataset.
        public var dataSetId: Swift.String?
        /// A value that indicates whether you want to import the data into SPICE.
        public var importMode: QuickSightClientTypes.DataSetImportMode?
        /// The last time that this dataset was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// A display name for the dataset.
        public var name: Swift.String?
        /// The row-level security configuration for the dataset.
        public var rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet?
        /// Whether or not the row level permission tags are applied.
        public var rowLevelPermissionTagConfigurationApplied: Swift.Bool

        public init (
            arn: Swift.String? = nil,
            columnLevelPermissionRulesApplied: Swift.Bool = false,
            createdTime: ClientRuntime.Date? = nil,
            dataSetId: Swift.String? = nil,
            importMode: QuickSightClientTypes.DataSetImportMode? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet? = nil,
            rowLevelPermissionTagConfigurationApplied: Swift.Bool = false
        )
        {
            self.arn = arn
            self.columnLevelPermissionRulesApplied = columnLevelPermissionRulesApplied
            self.createdTime = createdTime
            self.dataSetId = dataSetId
            self.importMode = importMode
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
            self.rowLevelPermissionTagConfigurationApplied = rowLevelPermissionTagConfigurationApplied
        }
    }

}

extension QuickSightClientTypes.DataSetUsageConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disableUseAsDirectQuerySource = "DisableUseAsDirectQuerySource"
        case disableUseAsImportedSource = "DisableUseAsImportedSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if disableUseAsDirectQuerySource != false {
            try encodeContainer.encode(disableUseAsDirectQuerySource, forKey: .disableUseAsDirectQuerySource)
        }
        if disableUseAsImportedSource != false {
            try encodeContainer.encode(disableUseAsImportedSource, forKey: .disableUseAsImportedSource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disableUseAsDirectQuerySourceDecoded = try containerValues.decode(Swift.Bool.self, forKey: .disableUseAsDirectQuerySource)
        disableUseAsDirectQuerySource = disableUseAsDirectQuerySourceDecoded
        let disableUseAsImportedSourceDecoded = try containerValues.decode(Swift.Bool.self, forKey: .disableUseAsImportedSource)
        disableUseAsImportedSource = disableUseAsImportedSourceDecoded
    }
}

extension QuickSightClientTypes {
    /// The usage configuration to apply to child datasets that reference this dataset as a source.
    public struct DataSetUsageConfiguration: Swift.Equatable {
        /// An option that controls whether a child dataset of a direct query can use this dataset as a source.
        public var disableUseAsDirectQuerySource: Swift.Bool
        /// An option that controls whether a child dataset that's stored in QuickSight can use this dataset as a source.
        public var disableUseAsImportedSource: Swift.Bool

        public init (
            disableUseAsDirectQuerySource: Swift.Bool = false,
            disableUseAsImportedSource: Swift.Bool = false
        )
        {
            self.disableUseAsDirectQuerySource = disableUseAsDirectQuerySource
            self.disableUseAsImportedSource = disableUseAsImportedSource
        }
    }

}

extension QuickSightClientTypes.DataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alternateDataSourceParameters = "AlternateDataSourceParameters"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case dataSourceId = "DataSourceId"
        case dataSourceParameters = "DataSourceParameters"
        case errorInfo = "ErrorInfo"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case sslProperties = "SslProperties"
        case status = "Status"
        case type = "Type"
        case vpcConnectionProperties = "VpcConnectionProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alternateDataSourceParameters = alternateDataSourceParameters {
            var alternateDataSourceParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .alternateDataSourceParameters)
            for datasourceparameterslist0 in alternateDataSourceParameters {
                try alternateDataSourceParametersContainer.encode(datasourceparameterslist0)
            }
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let dataSourceId = dataSourceId {
            try encodeContainer.encode(dataSourceId, forKey: .dataSourceId)
        }
        if let dataSourceParameters = dataSourceParameters {
            try encodeContainer.encode(dataSourceParameters, forKey: .dataSourceParameters)
        }
        if let errorInfo = errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sslProperties = sslProperties {
            try encodeContainer.encode(sslProperties, forKey: .sslProperties)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let vpcConnectionProperties = vpcConnectionProperties {
            try encodeContainer.encode(vpcConnectionProperties, forKey: .vpcConnectionProperties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSourceType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let dataSourceParametersDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSourceParameters.self, forKey: .dataSourceParameters)
        dataSourceParameters = dataSourceParametersDecoded
        let alternateDataSourceParametersContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataSourceParameters?].self, forKey: .alternateDataSourceParameters)
        var alternateDataSourceParametersDecoded0:[QuickSightClientTypes.DataSourceParameters]? = nil
        if let alternateDataSourceParametersContainer = alternateDataSourceParametersContainer {
            alternateDataSourceParametersDecoded0 = [QuickSightClientTypes.DataSourceParameters]()
            for union0 in alternateDataSourceParametersContainer {
                if let union0 = union0 {
                    alternateDataSourceParametersDecoded0?.append(union0)
                }
            }
        }
        alternateDataSourceParameters = alternateDataSourceParametersDecoded0
        let vpcConnectionPropertiesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VpcConnectionProperties.self, forKey: .vpcConnectionProperties)
        vpcConnectionProperties = vpcConnectionPropertiesDecoded
        let sslPropertiesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SslProperties.self, forKey: .sslProperties)
        sslProperties = sslPropertiesDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSourceErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
    }
}

extension QuickSightClientTypes {
    /// The structure of a data source.
    public struct DataSource: Swift.Equatable {
        /// A set of alternate data source parameters that you want to share for the credentials stored with this data source. The credentials are applied in tandem with the data source parameters when you copy a data source by using a create or update request. The API operation compares the DataSourceParameters structure that's in the request with the structures in the AlternateDataSourceParameters allow list. If the structures are an exact match, the request is allowed to use the credentials from this existing data source. If the AlternateDataSourceParameters list is null, the Credentials originally used with this DataSourceParameters are automatically allowed.
        public var alternateDataSourceParameters: [QuickSightClientTypes.DataSourceParameters]?
        /// The Amazon Resource Name (ARN) of the data source.
        public var arn: Swift.String?
        /// The time that this data source was created.
        public var createdTime: ClientRuntime.Date?
        /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public var dataSourceId: Swift.String?
        /// The parameters that Amazon QuickSight uses to connect to your underlying source. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
        public var dataSourceParameters: QuickSightClientTypes.DataSourceParameters?
        /// Error information from the last update or the creation of the data source.
        public var errorInfo: QuickSightClientTypes.DataSourceErrorInfo?
        /// The last time that this data source was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// A display name for the data source.
        public var name: Swift.String?
        /// Secure Socket Layer (SSL) properties that apply when Amazon QuickSight connects to your underlying source.
        public var sslProperties: QuickSightClientTypes.SslProperties?
        /// The HTTP status of the request.
        public var status: QuickSightClientTypes.ResourceStatus?
        /// The type of the data source. This type indicates which database engine the data source connects to.
        public var type: QuickSightClientTypes.DataSourceType?
        /// The VPC connection information. You need to use this parameter only when you want Amazon QuickSight to use a VPC connection when connecting to your underlying source.
        public var vpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties?

        public init (
            alternateDataSourceParameters: [QuickSightClientTypes.DataSourceParameters]? = nil,
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            dataSourceId: Swift.String? = nil,
            dataSourceParameters: QuickSightClientTypes.DataSourceParameters? = nil,
            errorInfo: QuickSightClientTypes.DataSourceErrorInfo? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            sslProperties: QuickSightClientTypes.SslProperties? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil,
            type: QuickSightClientTypes.DataSourceType? = nil,
            vpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties? = nil
        )
        {
            self.alternateDataSourceParameters = alternateDataSourceParameters
            self.arn = arn
            self.createdTime = createdTime
            self.dataSourceId = dataSourceId
            self.dataSourceParameters = dataSourceParameters
            self.errorInfo = errorInfo
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.sslProperties = sslProperties
            self.status = status
            self.type = type
            self.vpcConnectionProperties = vpcConnectionProperties
        }
    }

}

extension QuickSightClientTypes.DataSourceCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copySourceArn = "CopySourceArn"
        case credentialPair = "CredentialPair"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let copySourceArn = copySourceArn {
            try encodeContainer.encode(copySourceArn, forKey: .copySourceArn)
        }
        if let credentialPair = credentialPair {
            try encodeContainer.encode(credentialPair, forKey: .credentialPair)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialPairDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CredentialPair.self, forKey: .credentialPair)
        credentialPair = credentialPairDecoded
        let copySourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .copySourceArn)
        copySourceArn = copySourceArnDecoded
    }
}

extension QuickSightClientTypes.DataSourceCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension QuickSightClientTypes {
    /// Data source credentials. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
    public struct DataSourceCredentials: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of a data source that has the credential pair that you want to use. When CopySourceArn is not null, the credential pair from the data source in the ARN is used as the credentials for the DataSourceCredentials structure.
        public var copySourceArn: Swift.String?
        /// Credential pair. For more information, see [CredentialPair](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_CredentialPair.html).
        public var credentialPair: QuickSightClientTypes.CredentialPair?

        public init (
            copySourceArn: Swift.String? = nil,
            credentialPair: QuickSightClientTypes.CredentialPair? = nil
        )
        {
            self.copySourceArn = copySourceArn
            self.credentialPair = credentialPair
        }
    }

}

extension QuickSightClientTypes.DataSourceErrorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSourceErrorInfoType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QuickSightClientTypes {
    /// Error information for the data source creation or update.
    public struct DataSourceErrorInfo: Swift.Equatable {
        /// Error message.
        public var message: Swift.String?
        /// Error type.
        public var type: QuickSightClientTypes.DataSourceErrorInfoType?

        public init (
            message: Swift.String? = nil,
            type: QuickSightClientTypes.DataSourceErrorInfoType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }

}

extension QuickSightClientTypes {
    public enum DataSourceErrorInfoType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case conflict
        case copySourceNotFound
        case engineVersionNotSupported
        case genericSqlFailure
        case timeout
        case unknown
        case unknownHost
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceErrorInfoType] {
            return [
                .accessDenied,
                .conflict,
                .copySourceNotFound,
                .engineVersionNotSupported,
                .genericSqlFailure,
                .timeout,
                .unknown,
                .unknownHost,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .conflict: return "CONFLICT"
            case .copySourceNotFound: return "COPY_SOURCE_NOT_FOUND"
            case .engineVersionNotSupported: return "ENGINE_VERSION_NOT_SUPPORTED"
            case .genericSqlFailure: return "GENERIC_SQL_FAILURE"
            case .timeout: return "TIMEOUT"
            case .unknown: return "UNKNOWN"
            case .unknownHost: return "UNKNOWN_HOST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceErrorInfoType(rawValue: rawValue) ?? DataSourceErrorInfoType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.DataSourceParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonelasticsearchparameters = "AmazonElasticsearchParameters"
        case amazonopensearchparameters = "AmazonOpenSearchParameters"
        case athenaparameters = "AthenaParameters"
        case auroraparameters = "AuroraParameters"
        case aurorapostgresqlparameters = "AuroraPostgreSqlParameters"
        case awsiotanalyticsparameters = "AwsIotAnalyticsParameters"
        case exasolparameters = "ExasolParameters"
        case jiraparameters = "JiraParameters"
        case mariadbparameters = "MariaDbParameters"
        case mysqlparameters = "MySqlParameters"
        case oracleparameters = "OracleParameters"
        case postgresqlparameters = "PostgreSqlParameters"
        case prestoparameters = "PrestoParameters"
        case rdsparameters = "RdsParameters"
        case redshiftparameters = "RedshiftParameters"
        case s3parameters = "S3Parameters"
        case servicenowparameters = "ServiceNowParameters"
        case snowflakeparameters = "SnowflakeParameters"
        case sparkparameters = "SparkParameters"
        case sqlserverparameters = "SqlServerParameters"
        case teradataparameters = "TeradataParameters"
        case twitterparameters = "TwitterParameters"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .amazonelasticsearchparameters(amazonelasticsearchparameters):
                try container.encode(amazonelasticsearchparameters, forKey: .amazonelasticsearchparameters)
            case let .amazonopensearchparameters(amazonopensearchparameters):
                try container.encode(amazonopensearchparameters, forKey: .amazonopensearchparameters)
            case let .athenaparameters(athenaparameters):
                try container.encode(athenaparameters, forKey: .athenaparameters)
            case let .auroraparameters(auroraparameters):
                try container.encode(auroraparameters, forKey: .auroraparameters)
            case let .aurorapostgresqlparameters(aurorapostgresqlparameters):
                try container.encode(aurorapostgresqlparameters, forKey: .aurorapostgresqlparameters)
            case let .awsiotanalyticsparameters(awsiotanalyticsparameters):
                try container.encode(awsiotanalyticsparameters, forKey: .awsiotanalyticsparameters)
            case let .exasolparameters(exasolparameters):
                try container.encode(exasolparameters, forKey: .exasolparameters)
            case let .jiraparameters(jiraparameters):
                try container.encode(jiraparameters, forKey: .jiraparameters)
            case let .mariadbparameters(mariadbparameters):
                try container.encode(mariadbparameters, forKey: .mariadbparameters)
            case let .mysqlparameters(mysqlparameters):
                try container.encode(mysqlparameters, forKey: .mysqlparameters)
            case let .oracleparameters(oracleparameters):
                try container.encode(oracleparameters, forKey: .oracleparameters)
            case let .postgresqlparameters(postgresqlparameters):
                try container.encode(postgresqlparameters, forKey: .postgresqlparameters)
            case let .prestoparameters(prestoparameters):
                try container.encode(prestoparameters, forKey: .prestoparameters)
            case let .rdsparameters(rdsparameters):
                try container.encode(rdsparameters, forKey: .rdsparameters)
            case let .redshiftparameters(redshiftparameters):
                try container.encode(redshiftparameters, forKey: .redshiftparameters)
            case let .s3parameters(s3parameters):
                try container.encode(s3parameters, forKey: .s3parameters)
            case let .servicenowparameters(servicenowparameters):
                try container.encode(servicenowparameters, forKey: .servicenowparameters)
            case let .snowflakeparameters(snowflakeparameters):
                try container.encode(snowflakeparameters, forKey: .snowflakeparameters)
            case let .sparkparameters(sparkparameters):
                try container.encode(sparkparameters, forKey: .sparkparameters)
            case let .sqlserverparameters(sqlserverparameters):
                try container.encode(sqlserverparameters, forKey: .sqlserverparameters)
            case let .teradataparameters(teradataparameters):
                try container.encode(teradataparameters, forKey: .teradataparameters)
            case let .twitterparameters(twitterparameters):
                try container.encode(twitterparameters, forKey: .twitterparameters)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let amazonelasticsearchparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.AmazonElasticsearchParameters.self, forKey: .amazonelasticsearchparameters)
        if let amazonelasticsearchparameters = amazonelasticsearchparametersDecoded {
            self = .amazonelasticsearchparameters(amazonelasticsearchparameters)
            return
        }
        let athenaparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.AthenaParameters.self, forKey: .athenaparameters)
        if let athenaparameters = athenaparametersDecoded {
            self = .athenaparameters(athenaparameters)
            return
        }
        let auroraparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.AuroraParameters.self, forKey: .auroraparameters)
        if let auroraparameters = auroraparametersDecoded {
            self = .auroraparameters(auroraparameters)
            return
        }
        let aurorapostgresqlparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.AuroraPostgreSqlParameters.self, forKey: .aurorapostgresqlparameters)
        if let aurorapostgresqlparameters = aurorapostgresqlparametersDecoded {
            self = .aurorapostgresqlparameters(aurorapostgresqlparameters)
            return
        }
        let awsiotanalyticsparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.AwsIotAnalyticsParameters.self, forKey: .awsiotanalyticsparameters)
        if let awsiotanalyticsparameters = awsiotanalyticsparametersDecoded {
            self = .awsiotanalyticsparameters(awsiotanalyticsparameters)
            return
        }
        let jiraparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.JiraParameters.self, forKey: .jiraparameters)
        if let jiraparameters = jiraparametersDecoded {
            self = .jiraparameters(jiraparameters)
            return
        }
        let mariadbparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.MariaDbParameters.self, forKey: .mariadbparameters)
        if let mariadbparameters = mariadbparametersDecoded {
            self = .mariadbparameters(mariadbparameters)
            return
        }
        let mysqlparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.MySqlParameters.self, forKey: .mysqlparameters)
        if let mysqlparameters = mysqlparametersDecoded {
            self = .mysqlparameters(mysqlparameters)
            return
        }
        let oracleparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.OracleParameters.self, forKey: .oracleparameters)
        if let oracleparameters = oracleparametersDecoded {
            self = .oracleparameters(oracleparameters)
            return
        }
        let postgresqlparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.PostgreSqlParameters.self, forKey: .postgresqlparameters)
        if let postgresqlparameters = postgresqlparametersDecoded {
            self = .postgresqlparameters(postgresqlparameters)
            return
        }
        let prestoparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.PrestoParameters.self, forKey: .prestoparameters)
        if let prestoparameters = prestoparametersDecoded {
            self = .prestoparameters(prestoparameters)
            return
        }
        let rdsparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.RdsParameters.self, forKey: .rdsparameters)
        if let rdsparameters = rdsparametersDecoded {
            self = .rdsparameters(rdsparameters)
            return
        }
        let redshiftparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.RedshiftParameters.self, forKey: .redshiftparameters)
        if let redshiftparameters = redshiftparametersDecoded {
            self = .redshiftparameters(redshiftparameters)
            return
        }
        let s3parametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.S3Parameters.self, forKey: .s3parameters)
        if let s3parameters = s3parametersDecoded {
            self = .s3parameters(s3parameters)
            return
        }
        let servicenowparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.ServiceNowParameters.self, forKey: .servicenowparameters)
        if let servicenowparameters = servicenowparametersDecoded {
            self = .servicenowparameters(servicenowparameters)
            return
        }
        let snowflakeparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.SnowflakeParameters.self, forKey: .snowflakeparameters)
        if let snowflakeparameters = snowflakeparametersDecoded {
            self = .snowflakeparameters(snowflakeparameters)
            return
        }
        let sparkparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.SparkParameters.self, forKey: .sparkparameters)
        if let sparkparameters = sparkparametersDecoded {
            self = .sparkparameters(sparkparameters)
            return
        }
        let sqlserverparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.SqlServerParameters.self, forKey: .sqlserverparameters)
        if let sqlserverparameters = sqlserverparametersDecoded {
            self = .sqlserverparameters(sqlserverparameters)
            return
        }
        let teradataparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.TeradataParameters.self, forKey: .teradataparameters)
        if let teradataparameters = teradataparametersDecoded {
            self = .teradataparameters(teradataparameters)
            return
        }
        let twitterparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.TwitterParameters.self, forKey: .twitterparameters)
        if let twitterparameters = twitterparametersDecoded {
            self = .twitterparameters(twitterparameters)
            return
        }
        let amazonopensearchparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.AmazonOpenSearchParameters.self, forKey: .amazonopensearchparameters)
        if let amazonopensearchparameters = amazonopensearchparametersDecoded {
            self = .amazonopensearchparameters(amazonopensearchparameters)
            return
        }
        let exasolparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.ExasolParameters.self, forKey: .exasolparameters)
        if let exasolparameters = exasolparametersDecoded {
            self = .exasolparameters(exasolparameters)
            return
        }
        self = .sdkUnknown("")
    }
}

extension QuickSightClientTypes {
    /// The parameters that Amazon QuickSight uses to connect to your underlying data source. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
    public enum DataSourceParameters: Swift.Equatable {
        /// The parameters for OpenSearch.
        case amazonelasticsearchparameters(QuickSightClientTypes.AmazonElasticsearchParameters)
        /// The parameters for Amazon Athena.
        case athenaparameters(QuickSightClientTypes.AthenaParameters)
        /// The parameters for Amazon Aurora MySQL.
        case auroraparameters(QuickSightClientTypes.AuroraParameters)
        /// The parameters for Amazon Aurora.
        case aurorapostgresqlparameters(QuickSightClientTypes.AuroraPostgreSqlParameters)
        /// The parameters for IoT Analytics.
        case awsiotanalyticsparameters(QuickSightClientTypes.AwsIotAnalyticsParameters)
        /// The parameters for Jira.
        case jiraparameters(QuickSightClientTypes.JiraParameters)
        /// The parameters for MariaDB.
        case mariadbparameters(QuickSightClientTypes.MariaDbParameters)
        /// The parameters for MySQL.
        case mysqlparameters(QuickSightClientTypes.MySqlParameters)
        /// The parameters for Oracle.
        case oracleparameters(QuickSightClientTypes.OracleParameters)
        /// The parameters for PostgreSQL.
        case postgresqlparameters(QuickSightClientTypes.PostgreSqlParameters)
        /// The parameters for Presto.
        case prestoparameters(QuickSightClientTypes.PrestoParameters)
        /// The parameters for Amazon RDS.
        case rdsparameters(QuickSightClientTypes.RdsParameters)
        /// The parameters for Amazon Redshift.
        case redshiftparameters(QuickSightClientTypes.RedshiftParameters)
        /// The parameters for S3.
        case s3parameters(QuickSightClientTypes.S3Parameters)
        /// The parameters for ServiceNow.
        case servicenowparameters(QuickSightClientTypes.ServiceNowParameters)
        /// The parameters for Snowflake.
        case snowflakeparameters(QuickSightClientTypes.SnowflakeParameters)
        /// The parameters for Spark.
        case sparkparameters(QuickSightClientTypes.SparkParameters)
        /// The parameters for SQL Server.
        case sqlserverparameters(QuickSightClientTypes.SqlServerParameters)
        /// The parameters for Teradata.
        case teradataparameters(QuickSightClientTypes.TeradataParameters)
        /// The parameters for Twitter.
        case twitterparameters(QuickSightClientTypes.TwitterParameters)
        /// The parameters for OpenSearch.
        case amazonopensearchparameters(QuickSightClientTypes.AmazonOpenSearchParameters)
        /// The parameters for Exasol.
        case exasolparameters(QuickSightClientTypes.ExasolParameters)
        case sdkUnknown(Swift.String)
    }

}

extension QuickSightClientTypes {
    public enum DataSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case adobeAnalytics
        case amazonElasticsearch
        case amazonOpensearch
        case athena
        case aurora
        case auroraPostgresql
        case awsIotAnalytics
        case exasol
        case github
        case jira
        case mariadb
        case mysql
        case oracle
        case postgresql
        case presto
        case redshift
        case s3
        case salesforce
        case servicenow
        case snowflake
        case spark
        case sqlserver
        case teradata
        case timestream
        case twitter
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceType] {
            return [
                .adobeAnalytics,
                .amazonElasticsearch,
                .amazonOpensearch,
                .athena,
                .aurora,
                .auroraPostgresql,
                .awsIotAnalytics,
                .exasol,
                .github,
                .jira,
                .mariadb,
                .mysql,
                .oracle,
                .postgresql,
                .presto,
                .redshift,
                .s3,
                .salesforce,
                .servicenow,
                .snowflake,
                .spark,
                .sqlserver,
                .teradata,
                .timestream,
                .twitter,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .adobeAnalytics: return "ADOBE_ANALYTICS"
            case .amazonElasticsearch: return "AMAZON_ELASTICSEARCH"
            case .amazonOpensearch: return "AMAZON_OPENSEARCH"
            case .athena: return "ATHENA"
            case .aurora: return "AURORA"
            case .auroraPostgresql: return "AURORA_POSTGRESQL"
            case .awsIotAnalytics: return "AWS_IOT_ANALYTICS"
            case .exasol: return "EXASOL"
            case .github: return "GITHUB"
            case .jira: return "JIRA"
            case .mariadb: return "MARIADB"
            case .mysql: return "MYSQL"
            case .oracle: return "ORACLE"
            case .postgresql: return "POSTGRESQL"
            case .presto: return "PRESTO"
            case .redshift: return "REDSHIFT"
            case .s3: return "S3"
            case .salesforce: return "SALESFORCE"
            case .servicenow: return "SERVICENOW"
            case .snowflake: return "SNOWFLAKE"
            case .spark: return "SPARK"
            case .sqlserver: return "SQLSERVER"
            case .teradata: return "TERADATA"
            case .timestream: return "TIMESTREAM"
            case .twitter: return "TWITTER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceType(rawValue: rawValue) ?? DataSourceType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.DateTimeParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for timestamplist0 in values {
                try valuesContainer.encode(timestamplist0.timeIntervalSince1970)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([ClientRuntime.Date?].self, forKey: .values)
        var valuesDecoded0:[ClientRuntime.Date]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [ClientRuntime.Date]()
            for timestamp0 in valuesContainer {
                if let timestamp0 = timestamp0 {
                    valuesDecoded0?.append(timestamp0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension QuickSightClientTypes {
    /// A date-time parameter.
    public struct DateTimeParameter: Swift.Equatable {
        /// A display name for the date-time parameter.
        /// This member is required.
        public var name: Swift.String?
        /// The values for the date-time parameter.
        /// This member is required.
        public var values: [ClientRuntime.Date]?

        public init (
            name: Swift.String? = nil,
            values: [ClientRuntime.Date]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension QuickSightClientTypes.DecimalParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for doublelist0 in values {
                try valuesContainer.encode(doublelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .values)
        var valuesDecoded0:[Swift.Double]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.Double]()
            for double0 in valuesContainer {
                if let double0 = double0 {
                    valuesDecoded0?.append(double0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension QuickSightClientTypes {
    /// A decimal parameter.
    public struct DecimalParameter: Swift.Equatable {
        /// A display name for the decimal parameter.
        /// This member is required.
        public var name: Swift.String?
        /// The values for the decimal parameter.
        /// This member is required.
        public var values: [Swift.Double]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.Double]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension DeleteAccountCustomizationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let namespace = namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        return items
    }
}

extension DeleteAccountCustomizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/customizations"
    }
}

public struct DeleteAccountCustomizationInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that you want to delete Amazon QuickSight customizations from in this Amazon Web Services Region.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The Amazon QuickSight namespace that you're deleting the customizations from.
    public var namespace: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
    }
}

struct DeleteAccountCustomizationInputBody: Swift.Equatable {
}

extension DeleteAccountCustomizationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAccountCustomizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccountCustomizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAccountCustomizationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccountCustomizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteAccountCustomizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteAccountCustomizationOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteAccountCustomizationOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DeleteAccountCustomizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteAnalysisInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let recoveryWindowInDays = recoveryWindowInDays {
            let recoveryWindowInDaysQueryItem = ClientRuntime.URLQueryItem(name: "recovery-window-in-days".urlPercentEncoding(), value: Swift.String(recoveryWindowInDays).urlPercentEncoding())
            items.append(recoveryWindowInDaysQueryItem)
        }
        if forceDeleteWithoutRecovery != false {
            let forceDeleteWithoutRecoveryQueryItem = ClientRuntime.URLQueryItem(name: "force-delete-without-recovery".urlPercentEncoding(), value: Swift.String(forceDeleteWithoutRecovery).urlPercentEncoding())
            items.append(forceDeleteWithoutRecoveryQueryItem)
        }
        return items
    }
}

extension DeleteAnalysisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let analysisId = analysisId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/analyses/\(analysisId.urlPercentEncoding())"
    }
}

public struct DeleteAnalysisInput: Swift.Equatable {
    /// The ID of the analysis that you're deleting.
    /// This member is required.
    public var analysisId: Swift.String?
    /// The ID of the Amazon Web Services account where you want to delete an analysis.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// This option defaults to the value NoForceDeleteWithoutRecovery. To immediately delete the analysis, add the ForceDeleteWithoutRecovery option. You can't restore an analysis after it's deleted.
    public var forceDeleteWithoutRecovery: Swift.Bool
    /// A value that specifies the number of days that Amazon QuickSight waits before it deletes the analysis. You can't use this parameter with the ForceDeleteWithoutRecovery option in the same API call. The default value is 30.
    public var recoveryWindowInDays: Swift.Int?

    public init (
        analysisId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        forceDeleteWithoutRecovery: Swift.Bool = false,
        recoveryWindowInDays: Swift.Int? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
        self.forceDeleteWithoutRecovery = forceDeleteWithoutRecovery
        self.recoveryWindowInDays = recoveryWindowInDays
    }
}

struct DeleteAnalysisInputBody: Swift.Equatable {
}

extension DeleteAnalysisInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAnalysisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAnalysisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAnalysisOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAnalysisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisId = output.analysisId
            self.arn = output.arn
            self.deletionTime = output.deletionTime
            self.requestId = output.requestId
        } else {
            self.analysisId = nil
            self.arn = nil
            self.deletionTime = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteAnalysisOutputResponse: Swift.Equatable {
    /// The ID of the deleted analysis.
    public var analysisId: Swift.String?
    /// The Amazon Resource Name (ARN) of the deleted analysis.
    public var arn: Swift.String?
    /// The date and time that the analysis is scheduled to be deleted.
    public var deletionTime: ClientRuntime.Date?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        analysisId: Swift.String? = nil,
        arn: Swift.String? = nil,
        deletionTime: ClientRuntime.Date? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.analysisId = analysisId
        self.arn = arn
        self.deletionTime = deletionTime
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteAnalysisOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let arn: Swift.String?
    let analysisId: Swift.String?
    let deletionTime: ClientRuntime.Date?
    let requestId: Swift.String?
}

extension DeleteAnalysisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisId = "AnalysisId"
        case arn = "Arn"
        case deletionTime = "DeletionTime"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let analysisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
        let deletionTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deletionTime)
        deletionTime = deletionTimeDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DeleteDashboardInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let versionNumber = versionNumber {
            let versionNumberQueryItem = ClientRuntime.URLQueryItem(name: "version-number".urlPercentEncoding(), value: Swift.String(versionNumber).urlPercentEncoding())
            items.append(versionNumberQueryItem)
        }
        return items
    }
}

extension DeleteDashboardInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dashboardId = dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())"
    }
}

public struct DeleteDashboardInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the dashboard that you're deleting.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// The version number of the dashboard. If the version number property is provided, only the specified version of the dashboard is deleted.
    public var versionNumber: Swift.Int?

    public init (
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.versionNumber = versionNumber
    }
}

struct DeleteDashboardInputBody: Swift.Equatable {
}

extension DeleteDashboardInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDashboardOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDashboardOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDashboardOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDashboardOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDashboardOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.dashboardId = output.dashboardId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.dashboardId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteDashboardOutputResponse: Swift.Equatable {
    /// The Secure Socket Layer (SSL) properties that apply for the resource.
    public var arn: Swift.String?
    /// The ID of the dashboard.
    public var dashboardId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.dashboardId = dashboardId
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteDashboardOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let arn: Swift.String?
    let dashboardId: Swift.String?
    let requestId: Swift.String?
}

extension DeleteDashboardOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case dashboardId = "DashboardId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let dashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DeleteDataSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSetId = dataSetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())"
    }
}

public struct DeleteDataSetInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSetId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
    }
}

struct DeleteDataSetInputBody: Swift.Equatable {
}

extension DeleteDataSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDataSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDataSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDataSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDataSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDataSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.dataSetId = output.dataSetId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.dataSetId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteDataSetOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset.
    public var arn: Swift.String?
    /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSetId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.dataSetId = dataSetId
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteDataSetOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let dataSetId: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DeleteDataSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case dataSetId = "DataSetId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSourceId = dataSourceId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sources/\(dataSourceId.urlPercentEncoding())"
    }
}

public struct DeleteDataSourceInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSourceId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSourceId = dataSourceId
    }
}

struct DeleteDataSourceInputBody: Swift.Equatable {
}

extension DeleteDataSourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDataSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDataSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDataSourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDataSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.dataSourceId = output.dataSourceId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.dataSourceId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteDataSourceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the data source that you deleted.
    public var arn: Swift.String?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSourceId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.dataSourceId = dataSourceId
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteDataSourceOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let dataSourceId: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DeleteDataSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case dataSourceId = "DataSourceId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let folderId = folderId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())"
    }
}

public struct DeleteFolderInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
    }
}

struct DeleteFolderInputBody: Swift.Equatable {
}

extension DeleteFolderInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFolderMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let folderId = folderId else {
            return nil
        }
        guard let memberType = memberType else {
            return nil
        }
        guard let memberId = memberId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())/members/\(memberType.rawValue.urlPercentEncoding())/\(memberId.urlPercentEncoding())"
    }
}

public struct DeleteFolderMembershipInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The Folder ID.
    /// This member is required.
    public var folderId: Swift.String?
    /// The ID of the asset (the dashboard, analysis, or dataset) that you want to delete.
    /// This member is required.
    public var memberId: Swift.String?
    /// The type of the member, including DASHBOARD, ANALYSIS, and DATASET
    /// This member is required.
    public var memberType: QuickSightClientTypes.MemberType?

    public init (
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil,
        memberId: Swift.String? = nil,
        memberType: QuickSightClientTypes.MemberType? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
        self.memberId = memberId
        self.memberType = memberType
    }
}

struct DeleteFolderMembershipInputBody: Swift.Equatable {
}

extension DeleteFolderMembershipInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFolderMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFolderMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFolderMembershipOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFolderMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteFolderMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.status = output.status
        } else {
            self.requestId = nil
            self.status = 0
        }
    }
}

public struct DeleteFolderMembershipOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteFolderMembershipOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let requestId: Swift.String?
}

extension DeleteFolderMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DeleteFolderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFolderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFolderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFolderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteFolderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.folderId = output.folderId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.folderId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteFolderOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the deleted folder.
    public var arn: Swift.String?
    /// The ID of the folder.
    public var folderId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        folderId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.folderId = folderId
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteFolderOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let arn: Swift.String?
    let folderId: Swift.String?
    let requestId: Swift.String?
}

extension DeleteFolderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case folderId = "FolderId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let folderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .folderId)
        folderId = folderIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DeleteGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let groupName = groupName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups/\(groupName.urlPercentEncoding())"
    }
}

public struct DeleteGroupInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The name of the group that you want to delete.
    /// This member is required.
    public var groupName: Swift.String?
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.groupName = groupName
        self.namespace = namespace
    }
}

struct DeleteGroupInputBody: Swift.Equatable {
}

extension DeleteGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGroupMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let groupName = groupName else {
            return nil
        }
        guard let memberName = memberName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups/\(groupName.urlPercentEncoding())/members/\(memberName.urlPercentEncoding())"
    }
}

public struct DeleteGroupMembershipInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The name of the group that you want to delete the user from.
    /// This member is required.
    public var groupName: Swift.String?
    /// The name of the user that you want to delete from the group membership.
    /// This member is required.
    public var memberName: Swift.String?
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        memberName: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.groupName = groupName
        self.memberName = memberName
        self.namespace = namespace
    }
}

struct DeleteGroupMembershipInputBody: Swift.Equatable {
}

extension DeleteGroupMembershipInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGroupMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGroupMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGroupMembershipOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGroupMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteGroupMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteGroupMembershipOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteGroupMembershipOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DeleteGroupMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteGroupOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteGroupOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DeleteGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteIAMPolicyAssignmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let assignmentName = assignmentName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespace/\(namespace.urlPercentEncoding())/iam-policy-assignments/\(assignmentName.urlPercentEncoding())"
    }
}

public struct DeleteIAMPolicyAssignmentInput: Swift.Equatable {
    /// The name of the assignment.
    /// This member is required.
    public var assignmentName: Swift.String?
    /// The Amazon Web Services account ID where you want to delete the IAM policy assignment.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace that contains the assignment.
    /// This member is required.
    public var namespace: Swift.String?

    public init (
        assignmentName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.assignmentName = assignmentName
        self.awsAccountId = awsAccountId
        self.namespace = namespace
    }
}

struct DeleteIAMPolicyAssignmentInputBody: Swift.Equatable {
}

extension DeleteIAMPolicyAssignmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIAMPolicyAssignmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIAMPolicyAssignmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentUpdatingException" : self = .concurrentUpdatingException(try ConcurrentUpdatingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIAMPolicyAssignmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case concurrentUpdatingException(ConcurrentUpdatingException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIAMPolicyAssignmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteIAMPolicyAssignmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assignmentName = output.assignmentName
            self.requestId = output.requestId
        } else {
            self.assignmentName = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteIAMPolicyAssignmentOutputResponse: Swift.Equatable {
    /// The name of the assignment.
    public var assignmentName: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        assignmentName: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.assignmentName = assignmentName
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteIAMPolicyAssignmentOutputResponseBody: Swift.Equatable {
    let assignmentName: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DeleteIAMPolicyAssignmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentName = "AssignmentName"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentName)
        assignmentName = assignmentNameDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())"
    }
}

public struct DeleteNamespaceInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that you want to delete the Amazon QuickSight namespace from.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace that you want to delete.
    /// This member is required.
    public var namespace: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
    }
}

struct DeleteNamespaceInputBody: Swift.Equatable {
}

extension DeleteNamespaceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteNamespaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteNamespaceOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteNamespaceOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DeleteNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteTemplateAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        guard let aliasName = aliasName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/aliases/\(aliasName.urlPercentEncoding())"
    }
}

public struct DeleteTemplateAliasInput: Swift.Equatable {
    /// The name for the template alias. To delete a specific alias, you delete the version that the alias points to. You can specify the alias name, or specify the latest version of the template by providing the keyword $LATEST in the AliasName parameter.
    /// This member is required.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the item to delete.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the template that the specified alias is for.
    /// This member is required.
    public var templateId: Swift.String?

    public init (
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.templateId = templateId
    }
}

struct DeleteTemplateAliasInputBody: Swift.Equatable {
}

extension DeleteTemplateAliasInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTemplateAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTemplateAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTemplateAliasOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTemplateAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteTemplateAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aliasName = output.aliasName
            self.arn = output.arn
            self.requestId = output.requestId
            self.templateId = output.templateId
        } else {
            self.aliasName = nil
            self.arn = nil
            self.requestId = nil
            self.templateId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteTemplateAliasOutputResponse: Swift.Equatable {
    /// The name for the template alias.
    public var aliasName: Swift.String?
    /// The Amazon Resource Name (ARN) of the template you want to delete.
    public var arn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// An ID for the template associated with the deletion.
    public var templateId: Swift.String?

    public init (
        aliasName: Swift.String? = nil,
        arn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateId: Swift.String? = nil
    )
    {
        self.aliasName = aliasName
        self.arn = arn
        self.requestId = requestId
        self.status = status
        self.templateId = templateId
    }
}

struct DeleteTemplateAliasOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let templateId: Swift.String?
    let aliasName: Swift.String?
    let arn: Swift.String?
    let requestId: Swift.String?
}

extension DeleteTemplateAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasName = "AliasName"
        case arn = "Arn"
        case requestId = "RequestId"
        case status = "Status"
        case templateId = "TemplateId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let aliasNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasName)
        aliasName = aliasNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DeleteTemplateInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let versionNumber = versionNumber {
            let versionNumberQueryItem = ClientRuntime.URLQueryItem(name: "version-number".urlPercentEncoding(), value: Swift.String(versionNumber).urlPercentEncoding())
            items.append(versionNumberQueryItem)
        }
        return items
    }
}

extension DeleteTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())"
    }
}

public struct DeleteTemplateInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the template that you're deleting.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// An ID for the template you want to delete.
    /// This member is required.
    public var templateId: Swift.String?
    /// Specifies the version of the template that you want to delete. If you don't provide a version number, DeleteTemplate deletes all versions of the template.
    public var versionNumber: Swift.Int?

    public init (
        awsAccountId: Swift.String? = nil,
        templateId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.templateId = templateId
        self.versionNumber = versionNumber
    }
}

struct DeleteTemplateInputBody: Swift.Equatable {
}

extension DeleteTemplateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTemplateOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.requestId = output.requestId
            self.templateId = output.templateId
        } else {
            self.arn = nil
            self.requestId = nil
            self.templateId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteTemplateOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    public var arn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// An ID for the template.
    public var templateId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.requestId = requestId
        self.status = status
        self.templateId = templateId
    }
}

struct DeleteTemplateOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let arn: Swift.String?
    let templateId: Swift.String?
    let status: Swift.Int
}

extension DeleteTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case requestId = "RequestId"
        case status = "Status"
        case templateId = "TemplateId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteThemeAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let themeId = themeId else {
            return nil
        }
        guard let aliasName = aliasName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())/aliases/\(aliasName.urlPercentEncoding())"
    }
}

public struct DeleteThemeAliasInput: Swift.Equatable {
    /// The unique name for the theme alias to delete.
    /// This member is required.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the theme alias to delete.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the theme that the specified alias is for.
    /// This member is required.
    public var themeId: Swift.String?

    public init (
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        themeId: Swift.String? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.themeId = themeId
    }
}

struct DeleteThemeAliasInputBody: Swift.Equatable {
}

extension DeleteThemeAliasInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteThemeAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteThemeAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteThemeAliasOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteThemeAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteThemeAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aliasName = output.aliasName
            self.arn = output.arn
            self.requestId = output.requestId
            self.themeId = output.themeId
        } else {
            self.aliasName = nil
            self.arn = nil
            self.requestId = nil
            self.themeId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteThemeAliasOutputResponse: Swift.Equatable {
    /// The name for the theme alias.
    public var aliasName: Swift.String?
    /// The Amazon Resource Name (ARN) of the theme resource using the deleted alias.
    public var arn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// An ID for the theme associated with the deletion.
    public var themeId: Swift.String?

    public init (
        aliasName: Swift.String? = nil,
        arn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeId: Swift.String? = nil
    )
    {
        self.aliasName = aliasName
        self.arn = arn
        self.requestId = requestId
        self.status = status
        self.themeId = themeId
    }
}

struct DeleteThemeAliasOutputResponseBody: Swift.Equatable {
    let aliasName: Swift.String?
    let arn: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
    let themeId: Swift.String?
}

extension DeleteThemeAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasName = "AliasName"
        case arn = "Arn"
        case requestId = "RequestId"
        case status = "Status"
        case themeId = "ThemeId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasName)
        aliasName = aliasNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let themeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeId)
        themeId = themeIdDecoded
    }
}

extension DeleteThemeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let versionNumber = versionNumber {
            let versionNumberQueryItem = ClientRuntime.URLQueryItem(name: "version-number".urlPercentEncoding(), value: Swift.String(versionNumber).urlPercentEncoding())
            items.append(versionNumberQueryItem)
        }
        return items
    }
}

extension DeleteThemeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let themeId = themeId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())"
    }
}

public struct DeleteThemeInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the theme that you're deleting.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// An ID for the theme that you want to delete.
    /// This member is required.
    public var themeId: Swift.String?
    /// The version of the theme that you want to delete. Note: If you don't provide a version number, you're using this call to DeleteTheme to delete all versions of the theme.
    public var versionNumber: Swift.Int?

    public init (
        awsAccountId: Swift.String? = nil,
        themeId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.themeId = themeId
        self.versionNumber = versionNumber
    }
}

struct DeleteThemeInputBody: Swift.Equatable {
}

extension DeleteThemeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteThemeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteThemeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteThemeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteThemeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteThemeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.requestId = output.requestId
            self.themeId = output.themeId
        } else {
            self.arn = nil
            self.requestId = nil
            self.themeId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteThemeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    public var arn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// An ID for the theme.
    public var themeId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.requestId = requestId
        self.status = status
        self.themeId = themeId
    }
}

struct DeleteThemeOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
    let themeId: Swift.String?
}

extension DeleteThemeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case requestId = "RequestId"
        case status = "Status"
        case themeId = "ThemeId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let themeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeId)
        themeId = themeIdDecoded
    }
}

extension DeleteUserByPrincipalIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let principalId = principalId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/user-principals/\(principalId.urlPercentEncoding())"
    }
}

///
public struct DeleteUserByPrincipalIdInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// The principal ID of the user.
    /// This member is required.
    public var principalId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        principalId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.principalId = principalId
    }
}

struct DeleteUserByPrincipalIdInputBody: Swift.Equatable {
}

extension DeleteUserByPrincipalIdInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUserByPrincipalIdOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserByPrincipalIdOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserByPrincipalIdOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserByPrincipalIdOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteUserByPrincipalIdOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteUserByPrincipalIdOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteUserByPrincipalIdOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DeleteUserByPrincipalIdOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let userName = userName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/users/\(userName.urlPercentEncoding())"
    }
}

public struct DeleteUserInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// The name of the user that you want to delete.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.userName = userName
    }
}

struct DeleteUserInputBody: Swift.Equatable {
}

extension DeleteUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteUserOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteUserOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DeleteUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeAccountCustomizationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if resolved != false {
            let resolvedQueryItem = ClientRuntime.URLQueryItem(name: "resolved".urlPercentEncoding(), value: Swift.String(resolved).urlPercentEncoding())
            items.append(resolvedQueryItem)
        }
        if let namespace = namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        return items
    }
}

extension DescribeAccountCustomizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/customizations"
    }
}

public struct DescribeAccountCustomizationInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that you want to describe Amazon QuickSight customizations for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The Amazon QuickSight namespace that you want to describe Amazon QuickSight customizations for.
    public var namespace: Swift.String?
    /// The Resolved flag works with the other parameters to determine which view of Amazon QuickSight customizations is returned. You can add this flag to your command to use the same view that Amazon QuickSight uses to identify which customizations to apply to the console. Omit this flag, or set it to no-resolved, to reveal customizations that are configured at different levels.
    public var resolved: Swift.Bool

    public init (
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        resolved: Swift.Bool = false
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.resolved = resolved
    }
}

struct DescribeAccountCustomizationInputBody: Swift.Equatable {
}

extension DescribeAccountCustomizationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAccountCustomizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountCustomizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountCustomizationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountCustomizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAccountCustomizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountCustomization = output.accountCustomization
            self.arn = output.arn
            self.awsAccountId = output.awsAccountId
            self.namespace = output.namespace
            self.requestId = output.requestId
        } else {
            self.accountCustomization = nil
            self.arn = nil
            self.awsAccountId = nil
            self.namespace = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeAccountCustomizationOutputResponse: Swift.Equatable {
    /// The Amazon QuickSight customizations that exist in the current Amazon Web Services Region.
    public var accountCustomization: QuickSightClientTypes.AccountCustomization?
    /// The Amazon Resource Name (ARN) of the customization that's associated with this Amazon Web Services account.
    public var arn: Swift.String?
    /// The ID for the Amazon Web Services account that you're describing.
    public var awsAccountId: Swift.String?
    /// The Amazon QuickSight namespace that you're describing.
    public var namespace: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        accountCustomization: QuickSightClientTypes.AccountCustomization? = nil,
        arn: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.accountCustomization = accountCustomization
        self.arn = arn
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeAccountCustomizationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let awsAccountId: Swift.String?
    let namespace: Swift.String?
    let accountCustomization: QuickSightClientTypes.AccountCustomization?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeAccountCustomizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountCustomization = "AccountCustomization"
        case arn = "Arn"
        case awsAccountId = "AwsAccountId"
        case namespace = "Namespace"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let accountCustomizationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AccountCustomization.self, forKey: .accountCustomization)
        accountCustomization = accountCustomizationDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeAccountSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/settings"
    }
}

public struct DescribeAccountSettingsInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the settings that you want to list.
    /// This member is required.
    public var awsAccountId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
    }
}

struct DescribeAccountSettingsInputBody: Swift.Equatable {
}

extension DescribeAccountSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAccountSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAccountSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountSettings = output.accountSettings
            self.requestId = output.requestId
        } else {
            self.accountSettings = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeAccountSettingsOutputResponse: Swift.Equatable {
    /// The Amazon QuickSight settings for this Amazon Web Services account. This information includes the edition of Amazon Amazon QuickSight that you subscribed to (Standard or Enterprise) and the notification email for the Amazon QuickSight subscription. In the QuickSight console, the Amazon QuickSight subscription is sometimes referred to as a QuickSight "account" even though it's technically not an account by itself. Instead, it's a subscription to the Amazon QuickSight service for your Amazon Web Services account. The edition that you subscribe to applies to Amazon QuickSight in every Amazon Web Services Region where you use it.
    public var accountSettings: QuickSightClientTypes.AccountSettings?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        accountSettings: QuickSightClientTypes.AccountSettings? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.accountSettings = accountSettings
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeAccountSettingsOutputResponseBody: Swift.Equatable {
    let accountSettings: QuickSightClientTypes.AccountSettings?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeAccountSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountSettings = "AccountSettings"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountSettingsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AccountSettings.self, forKey: .accountSettings)
        accountSettings = accountSettingsDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeAnalysisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let analysisId = analysisId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/analyses/\(analysisId.urlPercentEncoding())"
    }
}

public struct DescribeAnalysisInput: Swift.Equatable {
    /// The ID of the analysis that you're describing. The ID is part of the URL of the analysis.
    /// This member is required.
    public var analysisId: Swift.String?
    /// The ID of the Amazon Web Services account that contains the analysis. You must be using the Amazon Web Services account that the analysis is in.
    /// This member is required.
    public var awsAccountId: Swift.String?

    public init (
        analysisId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
    }
}

struct DescribeAnalysisInputBody: Swift.Equatable {
}

extension DescribeAnalysisInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAnalysisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAnalysisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAnalysisOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAnalysisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysis = output.analysis
            self.requestId = output.requestId
        } else {
            self.analysis = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeAnalysisOutputResponse: Swift.Equatable {
    /// A metadata structure that contains summary information for the analysis that you're describing.
    public var analysis: QuickSightClientTypes.Analysis?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        analysis: QuickSightClientTypes.Analysis? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.analysis = analysis
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeAnalysisOutputResponseBody: Swift.Equatable {
    let analysis: QuickSightClientTypes.Analysis?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension DescribeAnalysisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysis = "Analysis"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Analysis.self, forKey: .analysis)
        analysis = analysisDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeAnalysisPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let analysisId = analysisId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/analyses/\(analysisId.urlPercentEncoding())/permissions"
    }
}

public struct DescribeAnalysisPermissionsInput: Swift.Equatable {
    /// The ID of the analysis whose permissions you're describing. The ID is part of the analysis URL.
    /// This member is required.
    public var analysisId: Swift.String?
    /// The ID of the Amazon Web Services account that contains the analysis whose permissions you're describing. You must be using the Amazon Web Services account that the analysis is in.
    /// This member is required.
    public var awsAccountId: Swift.String?

    public init (
        analysisId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
    }
}

struct DescribeAnalysisPermissionsInputBody: Swift.Equatable {
}

extension DescribeAnalysisPermissionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAnalysisPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAnalysisPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAnalysisPermissionsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAnalysisPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAnalysisPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisArn = output.analysisArn
            self.analysisId = output.analysisId
            self.permissions = output.permissions
            self.requestId = output.requestId
        } else {
            self.analysisArn = nil
            self.analysisId = nil
            self.permissions = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeAnalysisPermissionsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the analysis whose permissions you're describing.
    public var analysisArn: Swift.String?
    /// The ID of the analysis whose permissions you're describing.
    public var analysisId: Swift.String?
    /// A structure that describes the principals and the resource-level permissions on an analysis.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        analysisArn: Swift.String? = nil,
        analysisId: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.analysisArn = analysisArn
        self.analysisId = analysisId
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeAnalysisPermissionsOutputResponseBody: Swift.Equatable {
    let analysisId: Swift.String?
    let analysisArn: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension DescribeAnalysisPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisArn = "AnalysisArn"
        case analysisId = "AnalysisId"
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
        let analysisArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisArn)
        analysisArn = analysisArnDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeDashboardInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let aliasName = aliasName {
            let aliasNameQueryItem = ClientRuntime.URLQueryItem(name: "alias-name".urlPercentEncoding(), value: Swift.String(aliasName).urlPercentEncoding())
            items.append(aliasNameQueryItem)
        }
        if let versionNumber = versionNumber {
            let versionNumberQueryItem = ClientRuntime.URLQueryItem(name: "version-number".urlPercentEncoding(), value: Swift.String(versionNumber).urlPercentEncoding())
            items.append(versionNumberQueryItem)
        }
        return items
    }
}

extension DescribeDashboardInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dashboardId = dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())"
    }
}

public struct DescribeDashboardInput: Swift.Equatable {
    /// The alias name.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the dashboard that you're describing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// The version number for the dashboard. If a version number isn't passed, the latest published dashboard version is described.
    public var versionNumber: Swift.Int?

    public init (
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.versionNumber = versionNumber
    }
}

struct DescribeDashboardInputBody: Swift.Equatable {
}

extension DescribeDashboardInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDashboardOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDashboardOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDashboardOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDashboardOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDashboardOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dashboard = output.dashboard
            self.requestId = output.requestId
        } else {
            self.dashboard = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeDashboardOutputResponse: Swift.Equatable {
    /// Information about the dashboard.
    public var dashboard: QuickSightClientTypes.Dashboard?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of this request.
    public var status: Swift.Int

    public init (
        dashboard: QuickSightClientTypes.Dashboard? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dashboard = dashboard
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeDashboardOutputResponseBody: Swift.Equatable {
    let dashboard: QuickSightClientTypes.Dashboard?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension DescribeDashboardOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboard = "Dashboard"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Dashboard.self, forKey: .dashboard)
        dashboard = dashboardDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeDashboardPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dashboardId = dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())/permissions"
    }
}

public struct DescribeDashboardPermissionsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the dashboard that you're describing permissions for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard, also added to the IAM policy.
    /// This member is required.
    public var dashboardId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
    }
}

struct DescribeDashboardPermissionsInputBody: Swift.Equatable {
}

extension DescribeDashboardPermissionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDashboardPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDashboardPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDashboardPermissionsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDashboardPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDashboardPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dashboardArn = output.dashboardArn
            self.dashboardId = output.dashboardId
            self.linkSharingConfiguration = output.linkSharingConfiguration
            self.permissions = output.permissions
            self.requestId = output.requestId
        } else {
            self.dashboardArn = nil
            self.dashboardId = nil
            self.linkSharingConfiguration = nil
            self.permissions = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeDashboardPermissionsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dashboard.
    public var dashboardArn: Swift.String?
    /// The ID for the dashboard.
    public var dashboardId: Swift.String?
    /// A structure that contains the configuration of a shareable link that grants access to the dashboard. Your users can use the link to view and interact with the dashboard, if the dashboard has been shared with them. For more information about sharing dashboards, see [Sharing Dashboards](https://docs.aws.amazon.com/quicksight/latest/user/sharing-a-dashboard.html).
    public var linkSharingConfiguration: QuickSightClientTypes.LinkSharingConfiguration?
    /// A structure that contains the permissions for the dashboard.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dashboardArn: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        linkSharingConfiguration: QuickSightClientTypes.LinkSharingConfiguration? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dashboardArn = dashboardArn
        self.dashboardId = dashboardId
        self.linkSharingConfiguration = linkSharingConfiguration
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeDashboardPermissionsOutputResponseBody: Swift.Equatable {
    let dashboardId: Swift.String?
    let dashboardArn: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let status: Swift.Int
    let requestId: Swift.String?
    let linkSharingConfiguration: QuickSightClientTypes.LinkSharingConfiguration?
}

extension DescribeDashboardPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardArn = "DashboardArn"
        case dashboardId = "DashboardId"
        case linkSharingConfiguration = "LinkSharingConfiguration"
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let dashboardArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardArn)
        dashboardArn = dashboardArnDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let linkSharingConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LinkSharingConfiguration.self, forKey: .linkSharingConfiguration)
        linkSharingConfiguration = linkSharingConfigurationDecoded
    }
}

extension DescribeDataSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSetId = dataSetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())"
    }
}

public struct DescribeDataSetInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSetId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
    }
}

struct DescribeDataSetInputBody: Swift.Equatable {
}

extension DescribeDataSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDataSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDataSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDataSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDataSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDataSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSet = output.dataSet
            self.requestId = output.requestId
        } else {
            self.dataSet = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeDataSetOutputResponse: Swift.Equatable {
    /// Information on the dataset.
    public var dataSet: QuickSightClientTypes.DataSet?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dataSet: QuickSightClientTypes.DataSet? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSet = dataSet
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeDataSetOutputResponseBody: Swift.Equatable {
    let dataSet: QuickSightClientTypes.DataSet?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeDataSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSet = "DataSet"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSet.self, forKey: .dataSet)
        dataSet = dataSetDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeDataSetPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSetId = dataSetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/permissions"
    }
}

public struct DescribeDataSetPermissionsInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSetId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
    }
}

struct DescribeDataSetPermissionsInputBody: Swift.Equatable {
}

extension DescribeDataSetPermissionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDataSetPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDataSetPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDataSetPermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDataSetPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDataSetPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSetArn = output.dataSetArn
            self.dataSetId = output.dataSetId
            self.permissions = output.permissions
            self.requestId = output.requestId
        } else {
            self.dataSetArn = nil
            self.dataSetId = nil
            self.permissions = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeDataSetPermissionsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset.
    public var dataSetArn: Swift.String?
    /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSetId: Swift.String?
    /// A list of resource permissions on the dataset.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dataSetArn: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSetArn = dataSetArn
        self.dataSetId = dataSetId
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeDataSetPermissionsOutputResponseBody: Swift.Equatable {
    let dataSetArn: Swift.String?
    let dataSetId: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeDataSetPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetArn = "DataSetArn"
        case dataSetId = "DataSetId"
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetArn)
        dataSetArn = dataSetArnDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSourceId = dataSourceId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sources/\(dataSourceId.urlPercentEncoding())"
    }
}

public struct DescribeDataSourceInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSourceId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSourceId = dataSourceId
    }
}

struct DescribeDataSourceInputBody: Swift.Equatable {
}

extension DescribeDataSourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDataSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDataSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDataSourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDataSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSource = output.dataSource
            self.requestId = output.requestId
        } else {
            self.dataSource = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeDataSourceOutputResponse: Swift.Equatable {
    /// The information on the data source.
    public var dataSource: QuickSightClientTypes.DataSource?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dataSource: QuickSightClientTypes.DataSource? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSource = dataSource
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeDataSourceOutputResponseBody: Swift.Equatable {
    let dataSource: QuickSightClientTypes.DataSource?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeDataSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeDataSourcePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSourceId = dataSourceId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sources/\(dataSourceId.urlPercentEncoding())/permissions"
    }
}

public struct DescribeDataSourcePermissionsInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSourceId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSourceId = dataSourceId
    }
}

struct DescribeDataSourcePermissionsInputBody: Swift.Equatable {
}

extension DescribeDataSourcePermissionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDataSourcePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDataSourcePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDataSourcePermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDataSourcePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDataSourcePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSourceArn = output.dataSourceArn
            self.dataSourceId = output.dataSourceId
            self.permissions = output.permissions
            self.requestId = output.requestId
        } else {
            self.dataSourceArn = nil
            self.dataSourceId = nil
            self.permissions = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeDataSourcePermissionsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the data source.
    public var dataSourceArn: Swift.String?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSourceId: Swift.String?
    /// A list of resource permissions on the data source.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dataSourceArn: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSourceArn = dataSourceArn
        self.dataSourceId = dataSourceId
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeDataSourcePermissionsOutputResponseBody: Swift.Equatable {
    let dataSourceArn: Swift.String?
    let dataSourceId: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeDataSourcePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceArn = "DataSourceArn"
        case dataSourceId = "DataSourceId"
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceArn)
        dataSourceArn = dataSourceArnDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let folderId = folderId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())"
    }
}

public struct DescribeFolderInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
    }
}

struct DescribeFolderInputBody: Swift.Equatable {
}

extension DescribeFolderInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFolderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFolderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFolderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFolderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFolderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.folder = output.folder
            self.requestId = output.requestId
        } else {
            self.folder = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeFolderOutputResponse: Swift.Equatable {
    /// Information about the folder.
    public var folder: QuickSightClientTypes.Folder?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        folder: QuickSightClientTypes.Folder? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.folder = folder
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeFolderOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let folder: QuickSightClientTypes.Folder?
    let requestId: Swift.String?
}

extension DescribeFolderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case folder = "Folder"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let folderDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Folder.self, forKey: .folder)
        folder = folderDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeFolderPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let folderId = folderId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())/permissions"
    }
}

public struct DescribeFolderPermissionsInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
    }
}

struct DescribeFolderPermissionsInputBody: Swift.Equatable {
}

extension DescribeFolderPermissionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFolderPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFolderPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFolderPermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFolderPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFolderPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.folderId = output.folderId
            self.permissions = output.permissions
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.folderId = nil
            self.permissions = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeFolderPermissionsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the folder.
    public var arn: Swift.String?
    /// The ID of the folder.
    public var folderId: Swift.String?
    /// Information about the permissions on the folder.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        folderId: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.folderId = folderId
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeFolderPermissionsOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let folderId: Swift.String?
    let arn: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let requestId: Swift.String?
}

extension DescribeFolderPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case folderId = "FolderId"
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let folderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .folderId)
        folderId = folderIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeFolderResolvedPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let folderId = folderId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())/resolved-permissions"
    }
}

public struct DescribeFolderResolvedPermissionsInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
    }
}

struct DescribeFolderResolvedPermissionsInputBody: Swift.Equatable {
}

extension DescribeFolderResolvedPermissionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFolderResolvedPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFolderResolvedPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFolderResolvedPermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFolderResolvedPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFolderResolvedPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.folderId = output.folderId
            self.permissions = output.permissions
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.folderId = nil
            self.permissions = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeFolderResolvedPermissionsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the folder.
    public var arn: Swift.String?
    /// The ID of the folder.
    public var folderId: Swift.String?
    /// Information about the permissions for the folder.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        folderId: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.folderId = folderId
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeFolderResolvedPermissionsOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let folderId: Swift.String?
    let arn: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let requestId: Swift.String?
}

extension DescribeFolderResolvedPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case folderId = "FolderId"
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let folderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .folderId)
        folderId = folderIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let groupName = groupName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups/\(groupName.urlPercentEncoding())"
    }
}

public struct DescribeGroupInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The name of the group that you want to describe.
    /// This member is required.
    public var groupName: Swift.String?
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.groupName = groupName
        self.namespace = namespace
    }
}

struct DescribeGroupInputBody: Swift.Equatable {
}

extension DescribeGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.group = output.group
            self.requestId = output.requestId
        } else {
            self.group = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeGroupOutputResponse: Swift.Equatable {
    /// The name of the group.
    public var group: QuickSightClientTypes.Group?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        group: QuickSightClientTypes.Group? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.group = group
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeGroupOutputResponseBody: Swift.Equatable {
    let group: QuickSightClientTypes.Group?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group = "Group"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Group.self, forKey: .group)
        group = groupDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeIAMPolicyAssignmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let assignmentName = assignmentName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/iam-policy-assignments/\(assignmentName.urlPercentEncoding())"
    }
}

public struct DescribeIAMPolicyAssignmentInput: Swift.Equatable {
    /// The name of the assignment, also called a rule.
    /// This member is required.
    public var assignmentName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the assignment that you want to describe.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace that contains the assignment.
    /// This member is required.
    public var namespace: Swift.String?

    public init (
        assignmentName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.assignmentName = assignmentName
        self.awsAccountId = awsAccountId
        self.namespace = namespace
    }
}

struct DescribeIAMPolicyAssignmentInputBody: Swift.Equatable {
}

extension DescribeIAMPolicyAssignmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeIAMPolicyAssignmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIAMPolicyAssignmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIAMPolicyAssignmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIAMPolicyAssignmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeIAMPolicyAssignmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.iAMPolicyAssignment = output.iAMPolicyAssignment
            self.requestId = output.requestId
        } else {
            self.iAMPolicyAssignment = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeIAMPolicyAssignmentOutputResponse: Swift.Equatable {
    /// Information describing the IAM policy assignment.
    public var iAMPolicyAssignment: QuickSightClientTypes.IAMPolicyAssignment?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        iAMPolicyAssignment: QuickSightClientTypes.IAMPolicyAssignment? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.iAMPolicyAssignment = iAMPolicyAssignment
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeIAMPolicyAssignmentOutputResponseBody: Swift.Equatable {
    let iAMPolicyAssignment: QuickSightClientTypes.IAMPolicyAssignment?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeIAMPolicyAssignmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iAMPolicyAssignment = "IAMPolicyAssignment"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iAMPolicyAssignmentDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IAMPolicyAssignment.self, forKey: .iAMPolicyAssignment)
        iAMPolicyAssignment = iAMPolicyAssignmentDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeIngestionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSetId = dataSetId else {
            return nil
        }
        guard let ingestionId = ingestionId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/ingestions/\(ingestionId.urlPercentEncoding())"
    }
}

public struct DescribeIngestionInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dataset used in the ingestion.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// An ID for the ingestion.
    /// This member is required.
    public var ingestionId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        ingestionId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
        self.ingestionId = ingestionId
    }
}

struct DescribeIngestionInputBody: Swift.Equatable {
}

extension DescribeIngestionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeIngestionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIngestionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIngestionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIngestionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeIngestionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ingestion = output.ingestion
            self.requestId = output.requestId
        } else {
            self.ingestion = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeIngestionOutputResponse: Swift.Equatable {
    /// Information about the ingestion.
    public var ingestion: QuickSightClientTypes.Ingestion?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        ingestion: QuickSightClientTypes.Ingestion? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.ingestion = ingestion
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeIngestionOutputResponseBody: Swift.Equatable {
    let ingestion: QuickSightClientTypes.Ingestion?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeIngestionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingestion = "Ingestion"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ingestionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Ingestion.self, forKey: .ingestion)
        ingestion = ingestionDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeIpRestrictionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/ip-restriction"
    }
}

public struct DescribeIpRestrictionInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the IP rules.
    /// This member is required.
    public var awsAccountId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
    }
}

struct DescribeIpRestrictionInputBody: Swift.Equatable {
}

extension DescribeIpRestrictionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeIpRestrictionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIpRestrictionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIpRestrictionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIpRestrictionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeIpRestrictionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awsAccountId = output.awsAccountId
            self.enabled = output.enabled
            self.ipRestrictionRuleMap = output.ipRestrictionRuleMap
            self.requestId = output.requestId
        } else {
            self.awsAccountId = nil
            self.enabled = nil
            self.ipRestrictionRuleMap = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeIpRestrictionOutputResponse: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the IP rules.
    public var awsAccountId: Swift.String?
    /// A value that specifies whether IP rules are turned on.
    public var enabled: Swift.Bool?
    /// A map that describes the IP rules with CIDR range and description.
    public var ipRestrictionRuleMap: [Swift.String:Swift.String]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        awsAccountId: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        ipRestrictionRuleMap: [Swift.String:Swift.String]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.awsAccountId = awsAccountId
        self.enabled = enabled
        self.ipRestrictionRuleMap = ipRestrictionRuleMap
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeIpRestrictionOutputResponseBody: Swift.Equatable {
    let awsAccountId: Swift.String?
    let ipRestrictionRuleMap: [Swift.String:Swift.String]?
    let enabled: Swift.Bool?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeIpRestrictionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId = "AwsAccountId"
        case enabled = "Enabled"
        case ipRestrictionRuleMap = "IpRestrictionRuleMap"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let ipRestrictionRuleMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .ipRestrictionRuleMap)
        var ipRestrictionRuleMapDecoded0: [Swift.String:Swift.String]? = nil
        if let ipRestrictionRuleMapContainer = ipRestrictionRuleMapContainer {
            ipRestrictionRuleMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, iprestrictionruledescription0) in ipRestrictionRuleMapContainer {
                if let iprestrictionruledescription0 = iprestrictionruledescription0 {
                    ipRestrictionRuleMapDecoded0?[key0] = iprestrictionruledescription0
                }
            }
        }
        ipRestrictionRuleMap = ipRestrictionRuleMapDecoded0
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())"
    }
}

public struct DescribeNamespaceInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the Amazon QuickSight namespace that you want to describe.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace that you want to describe.
    /// This member is required.
    public var namespace: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
    }
}

struct DescribeNamespaceInputBody: Swift.Equatable {
}

extension DescribeNamespaceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeNamespaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.namespace = output.namespace
            self.requestId = output.requestId
        } else {
            self.namespace = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeNamespaceOutputResponse: Swift.Equatable {
    /// The information about the namespace that you're describing. The response includes the namespace ARN, name, Amazon Web Services Region, creation status, and identity store. DescribeNamespace also works for namespaces that are in the process of being created. For incomplete namespaces, this API operation lists the namespace error types and messages associated with the creation process.
    public var namespace: QuickSightClientTypes.NamespaceInfoV2?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        namespace: QuickSightClientTypes.NamespaceInfoV2? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.namespace = namespace
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeNamespaceOutputResponseBody: Swift.Equatable {
    let namespace: QuickSightClientTypes.NamespaceInfoV2?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespace = "Namespace"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NamespaceInfoV2.self, forKey: .namespace)
        namespace = namespaceDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeTemplateAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        guard let aliasName = aliasName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/aliases/\(aliasName.urlPercentEncoding())"
    }
}

public struct DescribeTemplateAliasInput: Swift.Equatable {
    /// The name of the template alias that you want to describe. If you name a specific alias, you describe the version that the alias points to. You can specify the latest version of the template by providing the keyword $LATEST in the AliasName parameter. The keyword $PUBLISHED doesn't apply to templates.
    /// This member is required.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the template alias that you're describing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init (
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.templateId = templateId
    }
}

struct DescribeTemplateAliasInputBody: Swift.Equatable {
}

extension DescribeTemplateAliasInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeTemplateAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTemplateAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTemplateAliasOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTemplateAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTemplateAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.templateAlias = output.templateAlias
        } else {
            self.requestId = nil
            self.templateAlias = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeTemplateAliasOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// Information about the template alias.
    public var templateAlias: QuickSightClientTypes.TemplateAlias?

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateAlias: QuickSightClientTypes.TemplateAlias? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.templateAlias = templateAlias
    }
}

struct DescribeTemplateAliasOutputResponseBody: Swift.Equatable {
    let templateAlias: QuickSightClientTypes.TemplateAlias?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension DescribeTemplateAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case templateAlias = "TemplateAlias"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateAliasDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TemplateAlias.self, forKey: .templateAlias)
        templateAlias = templateAliasDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeTemplateInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let aliasName = aliasName {
            let aliasNameQueryItem = ClientRuntime.URLQueryItem(name: "alias-name".urlPercentEncoding(), value: Swift.String(aliasName).urlPercentEncoding())
            items.append(aliasNameQueryItem)
        }
        if let versionNumber = versionNumber {
            let versionNumberQueryItem = ClientRuntime.URLQueryItem(name: "version-number".urlPercentEncoding(), value: Swift.String(versionNumber).urlPercentEncoding())
            items.append(versionNumberQueryItem)
        }
        return items
    }
}

extension DescribeTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())"
    }
}

public struct DescribeTemplateInput: Swift.Equatable {
    /// The alias of the template that you want to describe. If you name a specific alias, you describe the version that the alias points to. You can specify the latest version of the template by providing the keyword $LATEST in the AliasName parameter. The keyword $PUBLISHED doesn't apply to templates.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the template that you're describing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the template.
    /// This member is required.
    public var templateId: Swift.String?
    /// (Optional) The number for the version to describe. If a VersionNumber parameter value isn't provided, the latest version of the template is described.
    public var versionNumber: Swift.Int?

    public init (
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        templateId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.templateId = templateId
        self.versionNumber = versionNumber
    }
}

struct DescribeTemplateInputBody: Swift.Equatable {
}

extension DescribeTemplateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.template = output.template
        } else {
            self.requestId = nil
            self.template = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeTemplateOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The template structure for the object you want to describe.
    public var template: QuickSightClientTypes.Template?

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        template: QuickSightClientTypes.Template? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.template = template
    }
}

struct DescribeTemplateOutputResponseBody: Swift.Equatable {
    let template: QuickSightClientTypes.Template?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension DescribeTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case template = "Template"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Template.self, forKey: .template)
        template = templateDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeTemplatePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/permissions"
    }
}

public struct DescribeTemplatePermissionsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the template that you're describing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.templateId = templateId
    }
}

struct DescribeTemplatePermissionsInputBody: Swift.Equatable {
}

extension DescribeTemplatePermissionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeTemplatePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTemplatePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTemplatePermissionsOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTemplatePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTemplatePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.permissions = output.permissions
            self.requestId = output.requestId
            self.templateArn = output.templateArn
            self.templateId = output.templateId
        } else {
            self.permissions = nil
            self.requestId = nil
            self.templateArn = nil
            self.templateId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeTemplatePermissionsOutputResponse: Swift.Equatable {
    /// A list of resource permissions to be set on the template.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The Amazon Resource Name (ARN) of the template.
    public var templateArn: Swift.String?
    /// The ID for the template.
    public var templateId: Swift.String?

    public init (
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateArn: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
        self.templateArn = templateArn
        self.templateId = templateId
    }
}

struct DescribeTemplatePermissionsOutputResponseBody: Swift.Equatable {
    let templateId: Swift.String?
    let templateArn: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeTemplatePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
        case templateArn = "TemplateArn"
        case templateId = "TemplateId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeThemeAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let themeId = themeId else {
            return nil
        }
        guard let aliasName = aliasName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())/aliases/\(aliasName.urlPercentEncoding())"
    }
}

public struct DescribeThemeAliasInput: Swift.Equatable {
    /// The name of the theme alias that you want to describe.
    /// This member is required.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the theme alias that you're describing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the theme.
    /// This member is required.
    public var themeId: Swift.String?

    public init (
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        themeId: Swift.String? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.themeId = themeId
    }
}

struct DescribeThemeAliasInputBody: Swift.Equatable {
}

extension DescribeThemeAliasInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeThemeAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeThemeAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeThemeAliasOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeThemeAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeThemeAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.themeAlias = output.themeAlias
        } else {
            self.requestId = nil
            self.themeAlias = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeThemeAliasOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// Information about the theme alias.
    public var themeAlias: QuickSightClientTypes.ThemeAlias?

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeAlias: QuickSightClientTypes.ThemeAlias? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.themeAlias = themeAlias
    }
}

struct DescribeThemeAliasOutputResponseBody: Swift.Equatable {
    let themeAlias: QuickSightClientTypes.ThemeAlias?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension DescribeThemeAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case themeAlias = "ThemeAlias"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeAliasDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ThemeAlias.self, forKey: .themeAlias)
        themeAlias = themeAliasDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeThemeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let aliasName = aliasName {
            let aliasNameQueryItem = ClientRuntime.URLQueryItem(name: "alias-name".urlPercentEncoding(), value: Swift.String(aliasName).urlPercentEncoding())
            items.append(aliasNameQueryItem)
        }
        if let versionNumber = versionNumber {
            let versionNumberQueryItem = ClientRuntime.URLQueryItem(name: "version-number".urlPercentEncoding(), value: Swift.String(versionNumber).urlPercentEncoding())
            items.append(versionNumberQueryItem)
        }
        return items
    }
}

extension DescribeThemeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let themeId = themeId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())"
    }
}

public struct DescribeThemeInput: Swift.Equatable {
    /// The alias of the theme that you want to describe. If you name a specific alias, you describe the version that the alias points to. You can specify the latest version of the theme by providing the keyword $LATEST in the AliasName parameter. The keyword $PUBLISHED doesn't apply to themes.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the theme that you're describing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the theme.
    /// This member is required.
    public var themeId: Swift.String?
    /// The version number for the version to describe. If a VersionNumber parameter value isn't provided, the latest version of the theme is described.
    public var versionNumber: Swift.Int?

    public init (
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        themeId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.themeId = themeId
        self.versionNumber = versionNumber
    }
}

struct DescribeThemeInputBody: Swift.Equatable {
}

extension DescribeThemeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeThemeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeThemeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeThemeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeThemeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeThemeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.theme = output.theme
        } else {
            self.requestId = nil
            self.theme = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeThemeOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The information about the theme that you are describing.
    public var theme: QuickSightClientTypes.Theme?

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        theme: QuickSightClientTypes.Theme? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.theme = theme
    }
}

struct DescribeThemeOutputResponseBody: Swift.Equatable {
    let theme: QuickSightClientTypes.Theme?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension DescribeThemeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case theme = "Theme"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Theme.self, forKey: .theme)
        theme = themeDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeThemePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let themeId = themeId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())/permissions"
    }
}

public struct DescribeThemePermissionsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the theme that you're describing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the theme that you want to describe permissions for.
    /// This member is required.
    public var themeId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        themeId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.themeId = themeId
    }
}

struct DescribeThemePermissionsInputBody: Swift.Equatable {
}

extension DescribeThemePermissionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeThemePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeThemePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeThemePermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeThemePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeThemePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.permissions = output.permissions
            self.requestId = output.requestId
            self.themeArn = output.themeArn
            self.themeId = output.themeId
        } else {
            self.permissions = nil
            self.requestId = nil
            self.themeArn = nil
            self.themeId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeThemePermissionsOutputResponse: Swift.Equatable {
    /// A list of resource permissions set on the theme.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The Amazon Resource Name (ARN) of the theme.
    public var themeArn: Swift.String?
    /// The ID for the theme.
    public var themeId: Swift.String?

    public init (
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeArn: Swift.String? = nil,
        themeId: Swift.String? = nil
    )
    {
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
        self.themeArn = themeArn
        self.themeId = themeId
    }
}

struct DescribeThemePermissionsOutputResponseBody: Swift.Equatable {
    let themeId: Swift.String?
    let themeArn: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeThemePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
        case themeArn = "ThemeArn"
        case themeId = "ThemeId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeId)
        themeId = themeIdDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let userName = userName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/users/\(userName.urlPercentEncoding())"
    }
}

public struct DescribeUserInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// The name of the user that you want to describe.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.userName = userName
    }
}

struct DescribeUserInputBody: Swift.Equatable {
}

extension DescribeUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.user = output.user
        } else {
            self.requestId = nil
            self.user = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeUserOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The user name.
    public var user: QuickSightClientTypes.User?

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        user: QuickSightClientTypes.User? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.user = user
    }
}

struct DescribeUserOutputResponseBody: Swift.Equatable {
    let user: QuickSightClientTypes.User?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case user = "User"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.User.self, forKey: .user)
        user = userDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension DomainNotWhitelistedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DomainNotWhitelistedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The domain specified isn't on the allow list. All domains for embedded dashboards must be added to the approved list by an Amazon QuickSight admin.
public struct DomainNotWhitelistedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct DomainNotWhitelistedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension DomainNotWhitelistedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes {
    public enum Edition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enterprise
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [Edition] {
            return [
                .enterprise,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enterprise: return "ENTERPRISE"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Edition(rawValue: rawValue) ?? Edition.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum EmbeddingIdentityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case anonymous
        case iam
        case quicksight
        case sdkUnknown(Swift.String)

        public static var allCases: [EmbeddingIdentityType] {
            return [
                .anonymous,
                .iam,
                .quicksight,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .anonymous: return "ANONYMOUS"
            case .iam: return "IAM"
            case .quicksight: return "QUICKSIGHT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EmbeddingIdentityType(rawValue: rawValue) ?? EmbeddingIdentityType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.ErrorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IngestionErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QuickSightClientTypes {
    /// Error information for the SPICE ingestion of a dataset.
    public struct ErrorInfo: Swift.Equatable {
        /// Error message.
        public var message: Swift.String?
        /// Error type.
        public var type: QuickSightClientTypes.IngestionErrorType?

        public init (
            message: Swift.String? = nil,
            type: QuickSightClientTypes.IngestionErrorType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }

}

extension QuickSightClientTypes.ExasolParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension QuickSightClientTypes {
    /// The required parameters for connecting to an Exasol data source.
    public struct ExasolParameters: Swift.Equatable {
        /// The hostname or IP address of the Exasol data source.
        /// This member is required.
        public var host: Swift.String?
        /// The port for the Exasol data source.
        /// This member is required.
        public var port: Swift.Int

        public init (
            host: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.host = host
            self.port = port
        }
    }

}

extension QuickSightClientTypes {
    public enum ExceptionResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountSettings
        case dataSet
        case dataSource
        case group
        case iampolicyAssignment
        case ingestion
        case namespace
        case user
        case vpcConnection
        case sdkUnknown(Swift.String)

        public static var allCases: [ExceptionResourceType] {
            return [
                .accountSettings,
                .dataSet,
                .dataSource,
                .group,
                .iampolicyAssignment,
                .ingestion,
                .namespace,
                .user,
                .vpcConnection,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountSettings: return "ACCOUNT_SETTINGS"
            case .dataSet: return "DATA_SET"
            case .dataSource: return "DATA_SOURCE"
            case .group: return "GROUP"
            case .iampolicyAssignment: return "IAMPOLICY_ASSIGNMENT"
            case .ingestion: return "INGESTION"
            case .namespace: return "NAMESPACE"
            case .user: return "USER"
            case .vpcConnection: return "VPC_CONNECTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExceptionResourceType(rawValue: rawValue) ?? ExceptionResourceType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.ExportToCSVOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityStatus = "AvailabilityStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityStatus = availabilityStatus {
            try encodeContainer.encode(availabilityStatus.rawValue, forKey: .availabilityStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardBehavior.self, forKey: .availabilityStatus)
        availabilityStatus = availabilityStatusDecoded
    }
}

extension QuickSightClientTypes {
    /// Export to .csv option.
    public struct ExportToCSVOption: Swift.Equatable {
        /// Availability status.
        public var availabilityStatus: QuickSightClientTypes.DashboardBehavior?

        public init (
            availabilityStatus: QuickSightClientTypes.DashboardBehavior? = nil
        )
        {
            self.availabilityStatus = availabilityStatus
        }
    }

}

extension QuickSightClientTypes.FieldFolder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columns
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for foldercolumnlist0 in columns {
                try columnsContainer.encode(foldercolumnlist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let columnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .columns)
        var columnsDecoded0:[Swift.String]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [Swift.String]()
            for string0 in columnsContainer {
                if let string0 = string0 {
                    columnsDecoded0?.append(string0)
                }
            }
        }
        columns = columnsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A FieldFolder element is a folder that contains fields and nested subfolders.
    public struct FieldFolder: Swift.Equatable {
        /// A folder has a list of columns. A column can only be in one folder.
        public var columns: [Swift.String]?
        /// The description for a field folder.
        public var description: Swift.String?

        public init (
            columns: [Swift.String]? = nil,
            description: Swift.String? = nil
        )
        {
            self.columns = columns
            self.description = description
        }
    }

}

extension QuickSightClientTypes {
    public enum FileFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case clf
        case csv
        case elf
        case json
        case tsv
        case xlsx
        case sdkUnknown(Swift.String)

        public static var allCases: [FileFormat] {
            return [
                .clf,
                .csv,
                .elf,
                .json,
                .tsv,
                .xlsx,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clf: return "CLF"
            case .csv: return "CSV"
            case .elf: return "ELF"
            case .json: return "JSON"
            case .tsv: return "TSV"
            case .xlsx: return "XLSX"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FileFormat(rawValue: rawValue) ?? FileFormat.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.FilterOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conditionExpression = "ConditionExpression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conditionExpression = conditionExpression {
            try encodeContainer.encode(conditionExpression, forKey: .conditionExpression)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conditionExpression)
        conditionExpression = conditionExpressionDecoded
    }
}

extension QuickSightClientTypes {
    /// A transform operation that filters rows based on a condition.
    public struct FilterOperation: Swift.Equatable {
        /// An expression that must evaluate to a Boolean value. Rows for which the expression evaluates to true are kept in the dataset.
        /// This member is required.
        public var conditionExpression: Swift.String?

        public init (
            conditionExpression: Swift.String? = nil
        )
        {
            self.conditionExpression = conditionExpression
        }
    }

}

extension QuickSightClientTypes {
    public enum FilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case stringequals
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterOperator] {
            return [
                .stringequals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .stringequals: return "StringEquals"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterOperator(rawValue: rawValue) ?? FilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.Folder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case folderId = "FolderId"
        case folderPath = "FolderPath"
        case folderType = "FolderType"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let folderId = folderId {
            try encodeContainer.encode(folderId, forKey: .folderId)
        }
        if let folderPath = folderPath {
            var folderPathContainer = encodeContainer.nestedUnkeyedContainer(forKey: .folderPath)
            for path0 in folderPath {
                try folderPathContainer.encode(path0)
            }
        }
        if let folderType = folderType {
            try encodeContainer.encode(folderType.rawValue, forKey: .folderType)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let folderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .folderId)
        folderId = folderIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let folderTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FolderType.self, forKey: .folderType)
        folderType = folderTypeDecoded
        let folderPathContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .folderPath)
        var folderPathDecoded0:[Swift.String]? = nil
        if let folderPathContainer = folderPathContainer {
            folderPathDecoded0 = [Swift.String]()
            for string0 in folderPathContainer {
                if let string0 = string0 {
                    folderPathDecoded0?.append(string0)
                }
            }
        }
        folderPath = folderPathDecoded0
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension QuickSightClientTypes {
    /// A folder in Amazon QuickSight.
    public struct Folder: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the folder.
        public var arn: Swift.String?
        /// The time that the folder was created.
        public var createdTime: ClientRuntime.Date?
        /// The ID of the folder.
        public var folderId: Swift.String?
        /// An array of ancestor ARN strings for the folder.
        public var folderPath: [Swift.String]?
        /// The type of folder it is.
        public var folderType: QuickSightClientTypes.FolderType?
        /// The time that the folder was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// A display name for the folder.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            folderId: Swift.String? = nil,
            folderPath: [Swift.String]? = nil,
            folderType: QuickSightClientTypes.FolderType? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.folderId = folderId
            self.folderPath = folderPath
            self.folderType = folderType
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }
    }

}

extension QuickSightClientTypes {
    public enum FolderFilterAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case parentFolderArn
        case sdkUnknown(Swift.String)

        public static var allCases: [FolderFilterAttribute] {
            return [
                .parentFolderArn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .parentFolderArn: return "PARENT_FOLDER_ARN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FolderFilterAttribute(rawValue: rawValue) ?? FolderFilterAttribute.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.FolderMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberId = "MemberId"
        case memberType = "MemberType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberId = memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
        if let memberType = memberType {
            try encodeContainer.encode(memberType.rawValue, forKey: .memberType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberId)
        memberId = memberIdDecoded
        let memberTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.MemberType.self, forKey: .memberType)
        memberType = memberTypeDecoded
    }
}

extension QuickSightClientTypes {
    /// An asset in a Amazon QuickSight folder, such as a dashboard, analysis, or dataset.
    public struct FolderMember: Swift.Equatable {
        /// The ID of an asset in the folder.
        public var memberId: Swift.String?
        /// The type of asset that it is.
        public var memberType: QuickSightClientTypes.MemberType?

        public init (
            memberId: Swift.String? = nil,
            memberType: QuickSightClientTypes.MemberType? = nil
        )
        {
            self.memberId = memberId
            self.memberType = memberType
        }
    }

}

extension QuickSightClientTypes.FolderSearchFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case `operator` = "Operator"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let nameDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FolderFilterAttribute.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension QuickSightClientTypes {
    /// A filter to use to search a Amazon QuickSight folder.
    public struct FolderSearchFilter: Swift.Equatable {
        /// The name of a value that you want to use in the filter. For example, "Name": "PARENT_FOLDER_ARN".
        public var name: QuickSightClientTypes.FolderFilterAttribute?
        /// The comparison operator that you want to use in the filter. For example, "Operator": "StringEquals".
        public var `operator`: QuickSightClientTypes.FilterOperator?
        /// The value of the named item (in this example, PARENT_FOLDER_ARN), that you want to use as a filter. For example, "Value": "arn:aws:quicksight:us-east-1:1:folder/folderId".
        public var value: Swift.String?

        public init (
            name: QuickSightClientTypes.FolderFilterAttribute? = nil,
            `operator`: QuickSightClientTypes.FilterOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }
    }

}

extension QuickSightClientTypes.FolderSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case folderId = "FolderId"
        case folderType = "FolderType"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let folderId = folderId {
            try encodeContainer.encode(folderId, forKey: .folderId)
        }
        if let folderType = folderType {
            try encodeContainer.encode(folderType.rawValue, forKey: .folderType)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let folderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .folderId)
        folderId = folderIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let folderTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FolderType.self, forKey: .folderType)
        folderType = folderTypeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension QuickSightClientTypes {
    /// A summary of information about an existing Amazon QuickSight folder.
    public struct FolderSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the folder.
        public var arn: Swift.String?
        /// The time that the folder was created.
        public var createdTime: ClientRuntime.Date?
        /// The ID of the folder.
        public var folderId: Swift.String?
        /// The type of folder.
        public var folderType: QuickSightClientTypes.FolderType?
        /// The time that the folder was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The display name of the folder.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            folderId: Swift.String? = nil,
            folderType: QuickSightClientTypes.FolderType? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.folderId = folderId
            self.folderType = folderType
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }
    }

}

extension QuickSightClientTypes {
    public enum FolderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [FolderType] {
            return [
                .shared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FolderType(rawValue: rawValue) ?? FolderType.sdkUnknown(rawValue)
        }
    }
}

extension GenerateEmbedUrlForAnonymousUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizedResourceArns = "AuthorizedResourceArns"
        case experienceConfiguration = "ExperienceConfiguration"
        case namespace = "Namespace"
        case sessionLifetimeInMinutes = "SessionLifetimeInMinutes"
        case sessionTags = "SessionTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizedResourceArns = authorizedResourceArns {
            var authorizedResourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizedResourceArns)
            for arnlist0 in authorizedResourceArns {
                try authorizedResourceArnsContainer.encode(arnlist0)
            }
        }
        if let experienceConfiguration = experienceConfiguration {
            try encodeContainer.encode(experienceConfiguration, forKey: .experienceConfiguration)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let sessionLifetimeInMinutes = sessionLifetimeInMinutes {
            try encodeContainer.encode(sessionLifetimeInMinutes, forKey: .sessionLifetimeInMinutes)
        }
        if let sessionTags = sessionTags {
            var sessionTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sessionTags)
            for sessiontaglist0 in sessionTags {
                try sessionTagsContainer.encode(sessiontaglist0)
            }
        }
    }
}

extension GenerateEmbedUrlForAnonymousUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/embed-url/anonymous-user"
    }
}

public struct GenerateEmbedUrlForAnonymousUserInput: Swift.Equatable {
    /// The Amazon Resource Names for the Amazon QuickSight resources that the user is authorized to access during the lifetime of the session. If you choose Dashboard embedding experience, pass the list of dashboard ARNs in the account that you want the user to be able to view.
    /// This member is required.
    public var authorizedResourceArns: [Swift.String]?
    /// The ID for the Amazon Web Services account that contains the dashboard that you're embedding.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The configuration of the experience you are embedding.
    /// This member is required.
    public var experienceConfiguration: QuickSightClientTypes.AnonymousUserEmbeddingExperienceConfiguration?
    /// The Amazon QuickSight namespace that the anonymous user virtually belongs to. If you are not using an Amazon QuickSight custom namespace, set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// How many minutes the session is valid. The session lifetime must be in [15-600] minutes range.
    public var sessionLifetimeInMinutes: Swift.Int?
    /// The session tags used for row-level security. Before you use this parameter, make sure that you have configured the relevant datasets using the DataSet$RowLevelPermissionTagConfiguration parameter so that session tags can be used to provide row-level security. These are not the tags used for the Amazon Web Services resource tagging feature. For more information, see [Using Row-Level Security (RLS) with Tags](https://docs.aws.amazon.com/quicksight/latest/user/quicksight-dev-rls-tags.html).
    public var sessionTags: [QuickSightClientTypes.SessionTag]?

    public init (
        authorizedResourceArns: [Swift.String]? = nil,
        awsAccountId: Swift.String? = nil,
        experienceConfiguration: QuickSightClientTypes.AnonymousUserEmbeddingExperienceConfiguration? = nil,
        namespace: Swift.String? = nil,
        sessionLifetimeInMinutes: Swift.Int? = nil,
        sessionTags: [QuickSightClientTypes.SessionTag]? = nil
    )
    {
        self.authorizedResourceArns = authorizedResourceArns
        self.awsAccountId = awsAccountId
        self.experienceConfiguration = experienceConfiguration
        self.namespace = namespace
        self.sessionLifetimeInMinutes = sessionLifetimeInMinutes
        self.sessionTags = sessionTags
    }
}

struct GenerateEmbedUrlForAnonymousUserInputBody: Swift.Equatable {
    let sessionLifetimeInMinutes: Swift.Int?
    let namespace: Swift.String?
    let sessionTags: [QuickSightClientTypes.SessionTag]?
    let authorizedResourceArns: [Swift.String]?
    let experienceConfiguration: QuickSightClientTypes.AnonymousUserEmbeddingExperienceConfiguration?
}

extension GenerateEmbedUrlForAnonymousUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizedResourceArns = "AuthorizedResourceArns"
        case experienceConfiguration = "ExperienceConfiguration"
        case namespace = "Namespace"
        case sessionLifetimeInMinutes = "SessionLifetimeInMinutes"
        case sessionTags = "SessionTags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionLifetimeInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sessionLifetimeInMinutes)
        sessionLifetimeInMinutes = sessionLifetimeInMinutesDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let sessionTagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.SessionTag?].self, forKey: .sessionTags)
        var sessionTagsDecoded0:[QuickSightClientTypes.SessionTag]? = nil
        if let sessionTagsContainer = sessionTagsContainer {
            sessionTagsDecoded0 = [QuickSightClientTypes.SessionTag]()
            for structure0 in sessionTagsContainer {
                if let structure0 = structure0 {
                    sessionTagsDecoded0?.append(structure0)
                }
            }
        }
        sessionTags = sessionTagsDecoded0
        let authorizedResourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizedResourceArns)
        var authorizedResourceArnsDecoded0:[Swift.String]? = nil
        if let authorizedResourceArnsContainer = authorizedResourceArnsContainer {
            authorizedResourceArnsDecoded0 = [Swift.String]()
            for string0 in authorizedResourceArnsContainer {
                if let string0 = string0 {
                    authorizedResourceArnsDecoded0?.append(string0)
                }
            }
        }
        authorizedResourceArns = authorizedResourceArnsDecoded0
        let experienceConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AnonymousUserEmbeddingExperienceConfiguration.self, forKey: .experienceConfiguration)
        experienceConfiguration = experienceConfigurationDecoded
    }
}

extension GenerateEmbedUrlForAnonymousUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GenerateEmbedUrlForAnonymousUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SessionLifetimeInMinutesInvalidException" : self = .sessionLifetimeInMinutesInvalidException(try SessionLifetimeInMinutesInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedPricingPlanException" : self = .unsupportedPricingPlanException(try UnsupportedPricingPlanException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GenerateEmbedUrlForAnonymousUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case sessionLifetimeInMinutesInvalidException(SessionLifetimeInMinutesInvalidException)
    case throttlingException(ThrottlingException)
    case unsupportedPricingPlanException(UnsupportedPricingPlanException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GenerateEmbedUrlForAnonymousUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GenerateEmbedUrlForAnonymousUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.embedUrl = output.embedUrl
            self.requestId = output.requestId
        } else {
            self.embedUrl = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct GenerateEmbedUrlForAnonymousUserOutputResponse: Swift.Equatable {
    /// The embed URL for the dashboard.
    /// This member is required.
    public var embedUrl: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    /// This member is required.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    /// This member is required.
    public var status: Swift.Int

    public init (
        embedUrl: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.embedUrl = embedUrl
        self.requestId = requestId
        self.status = status
    }
}

struct GenerateEmbedUrlForAnonymousUserOutputResponseBody: Swift.Equatable {
    let embedUrl: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension GenerateEmbedUrlForAnonymousUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case embedUrl = "EmbedUrl"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let embedUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .embedUrl)
        embedUrl = embedUrlDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension GenerateEmbedUrlForRegisteredUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experienceConfiguration = "ExperienceConfiguration"
        case sessionLifetimeInMinutes = "SessionLifetimeInMinutes"
        case userArn = "UserArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let experienceConfiguration = experienceConfiguration {
            try encodeContainer.encode(experienceConfiguration, forKey: .experienceConfiguration)
        }
        if let sessionLifetimeInMinutes = sessionLifetimeInMinutes {
            try encodeContainer.encode(sessionLifetimeInMinutes, forKey: .sessionLifetimeInMinutes)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension GenerateEmbedUrlForRegisteredUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/embed-url/registered-user"
    }
}

public struct GenerateEmbedUrlForRegisteredUserInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the dashboard that you're embedding.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The experience you are embedding. For registered users, you can embed Amazon QuickSight dashboards or the entire Amazon QuickSight console.
    /// This member is required.
    public var experienceConfiguration: QuickSightClientTypes.RegisteredUserEmbeddingExperienceConfiguration?
    /// How many minutes the session is valid. The session lifetime must be in [15-600] minutes range.
    public var sessionLifetimeInMinutes: Swift.Int?
    /// The Amazon Resource Name for the registered user.
    /// This member is required.
    public var userArn: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        experienceConfiguration: QuickSightClientTypes.RegisteredUserEmbeddingExperienceConfiguration? = nil,
        sessionLifetimeInMinutes: Swift.Int? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.experienceConfiguration = experienceConfiguration
        self.sessionLifetimeInMinutes = sessionLifetimeInMinutes
        self.userArn = userArn
    }
}

struct GenerateEmbedUrlForRegisteredUserInputBody: Swift.Equatable {
    let sessionLifetimeInMinutes: Swift.Int?
    let userArn: Swift.String?
    let experienceConfiguration: QuickSightClientTypes.RegisteredUserEmbeddingExperienceConfiguration?
}

extension GenerateEmbedUrlForRegisteredUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experienceConfiguration = "ExperienceConfiguration"
        case sessionLifetimeInMinutes = "SessionLifetimeInMinutes"
        case userArn = "UserArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionLifetimeInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sessionLifetimeInMinutes)
        sessionLifetimeInMinutes = sessionLifetimeInMinutesDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let experienceConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RegisteredUserEmbeddingExperienceConfiguration.self, forKey: .experienceConfiguration)
        experienceConfiguration = experienceConfigurationDecoded
    }
}

extension GenerateEmbedUrlForRegisteredUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GenerateEmbedUrlForRegisteredUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QuickSightUserNotFoundException" : self = .quickSightUserNotFoundException(try QuickSightUserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SessionLifetimeInMinutesInvalidException" : self = .sessionLifetimeInMinutesInvalidException(try SessionLifetimeInMinutesInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedPricingPlanException" : self = .unsupportedPricingPlanException(try UnsupportedPricingPlanException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GenerateEmbedUrlForRegisteredUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case quickSightUserNotFoundException(QuickSightUserNotFoundException)
    case resourceNotFoundException(ResourceNotFoundException)
    case sessionLifetimeInMinutesInvalidException(SessionLifetimeInMinutesInvalidException)
    case throttlingException(ThrottlingException)
    case unsupportedPricingPlanException(UnsupportedPricingPlanException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GenerateEmbedUrlForRegisteredUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GenerateEmbedUrlForRegisteredUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.embedUrl = output.embedUrl
            self.requestId = output.requestId
        } else {
            self.embedUrl = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct GenerateEmbedUrlForRegisteredUserOutputResponse: Swift.Equatable {
    /// The embed URL for the Amazon QuickSight dashboard or console.
    /// This member is required.
    public var embedUrl: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    /// This member is required.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    /// This member is required.
    public var status: Swift.Int

    public init (
        embedUrl: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.embedUrl = embedUrl
        self.requestId = requestId
        self.status = status
    }
}

struct GenerateEmbedUrlForRegisteredUserOutputResponseBody: Swift.Equatable {
    let embedUrl: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension GenerateEmbedUrlForRegisteredUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case embedUrl = "EmbedUrl"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let embedUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .embedUrl)
        embedUrl = embedUrlDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.GeoSpatialColumnGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columns = "Columns"
        case countryCode = "CountryCode"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for columnlist0 in columns {
                try columnsContainer.encode(columnlist0)
            }
        }
        if let countryCode = countryCode {
            try encodeContainer.encode(countryCode.rawValue, forKey: .countryCode)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let countryCodeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GeoSpatialCountryCode.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let columnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .columns)
        var columnsDecoded0:[Swift.String]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [Swift.String]()
            for string0 in columnsContainer {
                if let string0 = string0 {
                    columnsDecoded0?.append(string0)
                }
            }
        }
        columns = columnsDecoded0
    }
}

extension QuickSightClientTypes {
    /// Geospatial column group that denotes a hierarchy.
    public struct GeoSpatialColumnGroup: Swift.Equatable {
        /// Columns in this hierarchy.
        /// This member is required.
        public var columns: [Swift.String]?
        /// Country code.
        /// This member is required.
        public var countryCode: QuickSightClientTypes.GeoSpatialCountryCode?
        /// A display name for the hierarchy.
        /// This member is required.
        public var name: Swift.String?

        public init (
            columns: [Swift.String]? = nil,
            countryCode: QuickSightClientTypes.GeoSpatialCountryCode? = nil,
            name: Swift.String? = nil
        )
        {
            self.columns = columns
            self.countryCode = countryCode
            self.name = name
        }
    }

}

extension QuickSightClientTypes {
    public enum GeoSpatialCountryCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case us
        case sdkUnknown(Swift.String)

        public static var allCases: [GeoSpatialCountryCode] {
            return [
                .us,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .us: return "US"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GeoSpatialCountryCode(rawValue: rawValue) ?? GeoSpatialCountryCode.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum GeoSpatialDataRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case city
        case country
        case county
        case latitude
        case longitude
        case postcode
        case state
        case sdkUnknown(Swift.String)

        public static var allCases: [GeoSpatialDataRole] {
            return [
                .city,
                .country,
                .county,
                .latitude,
                .longitude,
                .postcode,
                .state,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .city: return "CITY"
            case .country: return "COUNTRY"
            case .county: return "COUNTY"
            case .latitude: return "LATITUDE"
            case .longitude: return "LONGITUDE"
            case .postcode: return "POSTCODE"
            case .state: return "STATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GeoSpatialDataRole(rawValue: rawValue) ?? GeoSpatialDataRole.sdkUnknown(rawValue)
        }
    }
}

extension GetDashboardEmbedUrlInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let identityType = identityType {
            let identityTypeQueryItem = ClientRuntime.URLQueryItem(name: "creds-type".urlPercentEncoding(), value: Swift.String(identityType.rawValue).urlPercentEncoding())
            items.append(identityTypeQueryItem)
        }
        if statePersistenceEnabled != false {
            let statePersistenceEnabledQueryItem = ClientRuntime.URLQueryItem(name: "state-persistence-enabled".urlPercentEncoding(), value: Swift.String(statePersistenceEnabled).urlPercentEncoding())
            items.append(statePersistenceEnabledQueryItem)
        }
        if let userArn = userArn {
            let userArnQueryItem = ClientRuntime.URLQueryItem(name: "user-arn".urlPercentEncoding(), value: Swift.String(userArn).urlPercentEncoding())
            items.append(userArnQueryItem)
        }
        if undoRedoDisabled != false {
            let undoRedoDisabledQueryItem = ClientRuntime.URLQueryItem(name: "undo-redo-disabled".urlPercentEncoding(), value: Swift.String(undoRedoDisabled).urlPercentEncoding())
            items.append(undoRedoDisabledQueryItem)
        }
        if let additionalDashboardIds = additionalDashboardIds {
            additionalDashboardIds.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "additional-dashboard-ids".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let sessionLifetimeInMinutes = sessionLifetimeInMinutes {
            let sessionLifetimeInMinutesQueryItem = ClientRuntime.URLQueryItem(name: "session-lifetime".urlPercentEncoding(), value: Swift.String(sessionLifetimeInMinutes).urlPercentEncoding())
            items.append(sessionLifetimeInMinutesQueryItem)
        }
        if resetDisabled != false {
            let resetDisabledQueryItem = ClientRuntime.URLQueryItem(name: "reset-disabled".urlPercentEncoding(), value: Swift.String(resetDisabled).urlPercentEncoding())
            items.append(resetDisabledQueryItem)
        }
        if let namespace = namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        return items
    }
}

extension GetDashboardEmbedUrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dashboardId = dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())/embed-url"
    }
}

public struct GetDashboardEmbedUrlInput: Swift.Equatable {
    /// A list of one or more dashboard IDs that you want to add to a session that includes anonymous users. The IdentityType parameter must be set to ANONYMOUS for this to work, because other identity types authenticate as Amazon QuickSight or IAM users. For example, if you set "--dashboard-id dash_id1 --dashboard-id dash_id2 dash_id3 identity-type ANONYMOUS", the session can access all three dashboards.
    public var additionalDashboardIds: [Swift.String]?
    /// The ID for the Amazon Web Services account that contains the dashboard that you're embedding.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard, also added to the Identity and Access Management (IAM) policy.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// The authentication method that the user uses to sign in.
    /// This member is required.
    public var identityType: QuickSightClientTypes.EmbeddingIdentityType?
    /// The Amazon QuickSight namespace that contains the dashboard IDs in this request. If you're not using a custom namespace, set Namespace = default.
    public var namespace: Swift.String?
    /// Remove the reset button on the embedded dashboard. The default is FALSE, which enables the reset button.
    public var resetDisabled: Swift.Bool
    /// How many minutes the session is valid. The session lifetime must be 15-600 minutes.
    public var sessionLifetimeInMinutes: Swift.Int?
    /// Adds persistence of state for the user session in an embedded dashboard. Persistence applies to the sheet and the parameter settings. These are control settings that the dashboard subscriber (Amazon QuickSight reader) chooses while viewing the dashboard. If this is set to TRUE, the settings are the same when the subscriber reopens the same dashboard URL. The state is stored in Amazon QuickSight, not in a browser cookie. If this is set to FALSE, the state of the user session is not persisted. The default is FALSE.
    public var statePersistenceEnabled: Swift.Bool
    /// Remove the undo/redo button on the embedded dashboard. The default is FALSE, which enables the undo/redo button.
    public var undoRedoDisabled: Swift.Bool
    /// The Amazon QuickSight user's Amazon Resource Name (ARN), for use with QUICKSIGHT identity type. You can use this for any Amazon QuickSight users in your account (readers, authors, or admins) authenticated as one of the following:
    ///
    /// * Active Directory (AD) users or group members
    ///
    /// * Invited nonfederated users
    ///
    /// * IAM users and IAM role-based sessions authenticated through Federated Single Sign-On using SAML, OpenID Connect, or IAM federation.
    ///
    ///
    /// Omit this parameter for users in the third group  IAM users and IAM role-based sessions.
    public var userArn: Swift.String?

    public init (
        additionalDashboardIds: [Swift.String]? = nil,
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        identityType: QuickSightClientTypes.EmbeddingIdentityType? = nil,
        namespace: Swift.String? = nil,
        resetDisabled: Swift.Bool = false,
        sessionLifetimeInMinutes: Swift.Int? = nil,
        statePersistenceEnabled: Swift.Bool = false,
        undoRedoDisabled: Swift.Bool = false,
        userArn: Swift.String? = nil
    )
    {
        self.additionalDashboardIds = additionalDashboardIds
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.identityType = identityType
        self.namespace = namespace
        self.resetDisabled = resetDisabled
        self.sessionLifetimeInMinutes = sessionLifetimeInMinutes
        self.statePersistenceEnabled = statePersistenceEnabled
        self.undoRedoDisabled = undoRedoDisabled
        self.userArn = userArn
    }
}

struct GetDashboardEmbedUrlInputBody: Swift.Equatable {
}

extension GetDashboardEmbedUrlInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDashboardEmbedUrlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDashboardEmbedUrlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotWhitelistedException" : self = .domainNotWhitelistedException(try DomainNotWhitelistedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdentityTypeNotSupportedException" : self = .identityTypeNotSupportedException(try IdentityTypeNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QuickSightUserNotFoundException" : self = .quickSightUserNotFoundException(try QuickSightUserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SessionLifetimeInMinutesInvalidException" : self = .sessionLifetimeInMinutesInvalidException(try SessionLifetimeInMinutesInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedPricingPlanException" : self = .unsupportedPricingPlanException(try UnsupportedPricingPlanException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDashboardEmbedUrlOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case domainNotWhitelistedException(DomainNotWhitelistedException)
    case identityTypeNotSupportedException(IdentityTypeNotSupportedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case quickSightUserNotFoundException(QuickSightUserNotFoundException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case sessionLifetimeInMinutesInvalidException(SessionLifetimeInMinutesInvalidException)
    case throttlingException(ThrottlingException)
    case unsupportedPricingPlanException(UnsupportedPricingPlanException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDashboardEmbedUrlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDashboardEmbedUrlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.embedUrl = output.embedUrl
            self.requestId = output.requestId
        } else {
            self.embedUrl = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

/// Output returned from the GetDashboardEmbedUrl operation.
public struct GetDashboardEmbedUrlOutputResponse: Swift.Equatable {
    /// A single-use URL that you can put into your server-side webpage to embed your dashboard. This URL is valid for 5 minutes. The API operation provides the URL with an auth_code value that enables one (and only one) sign-on to a user session that is valid for 10 hours.
    public var embedUrl: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        embedUrl: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.embedUrl = embedUrl
        self.requestId = requestId
        self.status = status
    }
}

struct GetDashboardEmbedUrlOutputResponseBody: Swift.Equatable {
    let embedUrl: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension GetDashboardEmbedUrlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case embedUrl = "EmbedUrl"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let embedUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .embedUrl)
        embedUrl = embedUrlDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension GetSessionEmbedUrlInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let userArn = userArn {
            let userArnQueryItem = ClientRuntime.URLQueryItem(name: "user-arn".urlPercentEncoding(), value: Swift.String(userArn).urlPercentEncoding())
            items.append(userArnQueryItem)
        }
        if let entryPoint = entryPoint {
            let entryPointQueryItem = ClientRuntime.URLQueryItem(name: "entry-point".urlPercentEncoding(), value: Swift.String(entryPoint).urlPercentEncoding())
            items.append(entryPointQueryItem)
        }
        if let sessionLifetimeInMinutes = sessionLifetimeInMinutes {
            let sessionLifetimeInMinutesQueryItem = ClientRuntime.URLQueryItem(name: "session-lifetime".urlPercentEncoding(), value: Swift.String(sessionLifetimeInMinutes).urlPercentEncoding())
            items.append(sessionLifetimeInMinutesQueryItem)
        }
        return items
    }
}

extension GetSessionEmbedUrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/session-embed-url"
    }
}

public struct GetSessionEmbedUrlInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account associated with your Amazon QuickSight subscription.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The URL you use to access the embedded session. The entry point URL is constrained to the following paths:
    ///
    /// * /start
    ///
    /// * /start/analyses
    ///
    /// * /start/dashboards
    ///
    /// * /start/favorites
    ///
    /// * /dashboards/DashboardId  - where DashboardId is the actual ID key from the Amazon QuickSight console URL of the dashboard
    ///
    /// * /analyses/AnalysisId  - where AnalysisId is the actual ID key from the Amazon QuickSight console URL of the analysis
    public var entryPoint: Swift.String?
    /// How many minutes the session is valid. The session lifetime must be 15-600 minutes.
    public var sessionLifetimeInMinutes: Swift.Int?
    /// The Amazon QuickSight user's Amazon Resource Name (ARN), for use with QUICKSIGHT identity type. You can use this for any type of Amazon QuickSight users in your account (readers, authors, or admins). They need to be authenticated as one of the following:
    ///
    /// * Active Directory (AD) users or group members
    ///
    /// * Invited nonfederated users
    ///
    /// * Identity and Access Management (IAM) users and IAM role-based sessions authenticated through Federated Single Sign-On using SAML, OpenID Connect, or IAM federation
    ///
    ///
    /// Omit this parameter for users in the third group, IAM users and IAM role-based sessions.
    public var userArn: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        entryPoint: Swift.String? = nil,
        sessionLifetimeInMinutes: Swift.Int? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.entryPoint = entryPoint
        self.sessionLifetimeInMinutes = sessionLifetimeInMinutes
        self.userArn = userArn
    }
}

struct GetSessionEmbedUrlInputBody: Swift.Equatable {
}

extension GetSessionEmbedUrlInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSessionEmbedUrlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSessionEmbedUrlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QuickSightUserNotFoundException" : self = .quickSightUserNotFoundException(try QuickSightUserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SessionLifetimeInMinutesInvalidException" : self = .sessionLifetimeInMinutesInvalidException(try SessionLifetimeInMinutesInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSessionEmbedUrlOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case quickSightUserNotFoundException(QuickSightUserNotFoundException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case sessionLifetimeInMinutesInvalidException(SessionLifetimeInMinutesInvalidException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSessionEmbedUrlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSessionEmbedUrlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.embedUrl = output.embedUrl
            self.requestId = output.requestId
        } else {
            self.embedUrl = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct GetSessionEmbedUrlOutputResponse: Swift.Equatable {
    /// A single-use URL that you can put into your server-side web page to embed your Amazon QuickSight session. This URL is valid for 5 minutes. The API operation provides the URL with an auth_code value that enables one (and only one) sign-on to a user session that is valid for 10 hours.
    public var embedUrl: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        embedUrl: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.embedUrl = embedUrl
        self.requestId = requestId
        self.status = status
    }
}

struct GetSessionEmbedUrlOutputResponseBody: Swift.Equatable {
    let embedUrl: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension GetSessionEmbedUrlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case embedUrl = "EmbedUrl"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let embedUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .embedUrl)
        embedUrl = embedUrlDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.Group: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case groupName = "GroupName"
        case principalId = "PrincipalId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension QuickSightClientTypes {
    /// A group in Amazon QuickSight consists of a set of users. You can use groups to make it easier to manage access and security.
    public struct Group: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the group.
        public var arn: Swift.String?
        /// The group description.
        public var description: Swift.String?
        /// The name of the group.
        public var groupName: Swift.String?
        /// The principal ID of the group.
        public var principalId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            groupName: Swift.String? = nil,
            principalId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.groupName = groupName
            self.principalId = principalId
        }
    }

}

extension QuickSightClientTypes.GroupMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case memberName = "MemberName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let memberName = memberName {
            try encodeContainer.encode(memberName, forKey: .memberName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let memberNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberName)
        memberName = memberNameDecoded
    }
}

extension QuickSightClientTypes {
    /// A member of an Amazon QuickSight group. Currently, group members must be users. Groups can't be members of another group. .
    public struct GroupMember: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the group member (user).
        public var arn: Swift.String?
        /// The name of the group member (user).
        public var memberName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            memberName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.memberName = memberName
        }
    }

}

extension QuickSightClientTypes.GutterStyle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case show = "Show"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if show != false {
            try encodeContainer.encode(show, forKey: .show)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let showDecoded = try containerValues.decode(Swift.Bool.self, forKey: .show)
        show = showDecoded
    }
}

extension QuickSightClientTypes {
    /// The display options for gutter spacing between tiles on a sheet.
    public struct GutterStyle: Swift.Equatable {
        /// This Boolean value controls whether to display a gutter space between sheet tiles.
        public var show: Swift.Bool

        public init (
            show: Swift.Bool = false
        )
        {
            self.show = show
        }
    }

}

extension QuickSightClientTypes.IAMPolicyAssignment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentId = "AssignmentId"
        case assignmentName = "AssignmentName"
        case assignmentStatus = "AssignmentStatus"
        case awsAccountId = "AwsAccountId"
        case identities = "Identities"
        case policyArn = "PolicyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentId = assignmentId {
            try encodeContainer.encode(assignmentId, forKey: .assignmentId)
        }
        if let assignmentName = assignmentName {
            try encodeContainer.encode(assignmentName, forKey: .assignmentName)
        }
        if let assignmentStatus = assignmentStatus {
            try encodeContainer.encode(assignmentStatus.rawValue, forKey: .assignmentStatus)
        }
        if let awsAccountId = awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let identities = identities {
            var identitiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .identities)
            for (dictKey0, identitymap0) in identities {
                try identitiesContainer.encode(identitymap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let assignmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentId)
        assignmentId = assignmentIdDecoded
        let assignmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentName)
        assignmentName = assignmentNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let identitiesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .identities)
        var identitiesDecoded0: [Swift.String:[Swift.String]]? = nil
        if let identitiesContainer = identitiesContainer {
            identitiesDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, identitynamelist0) in identitiesContainer {
                var identitynamelist0Decoded0: [Swift.String]? = nil
                if let identitynamelist0 = identitynamelist0 {
                    identitynamelist0Decoded0 = [Swift.String]()
                    for string1 in identitynamelist0 {
                        if let string1 = string1 {
                            identitynamelist0Decoded0?.append(string1)
                        }
                    }
                }
                identitiesDecoded0?[key0] = identitynamelist0Decoded0
            }
        }
        identities = identitiesDecoded0
        let assignmentStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AssignmentStatus.self, forKey: .assignmentStatus)
        assignmentStatus = assignmentStatusDecoded
    }
}

extension QuickSightClientTypes {
    /// An Identity and Access Management (IAM) policy assignment.
    public struct IAMPolicyAssignment: Swift.Equatable {
        /// Assignment ID.
        public var assignmentId: Swift.String?
        /// Assignment name.
        public var assignmentName: Swift.String?
        /// Assignment status.
        public var assignmentStatus: QuickSightClientTypes.AssignmentStatus?
        /// The Amazon Web Services account ID.
        public var awsAccountId: Swift.String?
        /// Identities.
        public var identities: [Swift.String:[Swift.String]]?
        /// The Amazon Resource Name (ARN) for the IAM policy.
        public var policyArn: Swift.String?

        public init (
            assignmentId: Swift.String? = nil,
            assignmentName: Swift.String? = nil,
            assignmentStatus: QuickSightClientTypes.AssignmentStatus? = nil,
            awsAccountId: Swift.String? = nil,
            identities: [Swift.String:[Swift.String]]? = nil,
            policyArn: Swift.String? = nil
        )
        {
            self.assignmentId = assignmentId
            self.assignmentName = assignmentName
            self.assignmentStatus = assignmentStatus
            self.awsAccountId = awsAccountId
            self.identities = identities
            self.policyArn = policyArn
        }
    }

}

extension QuickSightClientTypes.IAMPolicyAssignmentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentName = "AssignmentName"
        case assignmentStatus = "AssignmentStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentName = assignmentName {
            try encodeContainer.encode(assignmentName, forKey: .assignmentName)
        }
        if let assignmentStatus = assignmentStatus {
            try encodeContainer.encode(assignmentStatus.rawValue, forKey: .assignmentStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentName)
        assignmentName = assignmentNameDecoded
        let assignmentStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AssignmentStatus.self, forKey: .assignmentStatus)
        assignmentStatus = assignmentStatusDecoded
    }
}

extension QuickSightClientTypes {
    /// IAM policy assignment summary.
    public struct IAMPolicyAssignmentSummary: Swift.Equatable {
        /// Assignment name.
        public var assignmentName: Swift.String?
        /// Assignment status.
        public var assignmentStatus: QuickSightClientTypes.AssignmentStatus?

        public init (
            assignmentName: Swift.String? = nil,
            assignmentStatus: QuickSightClientTypes.AssignmentStatus? = nil
        )
        {
            self.assignmentName = assignmentName
            self.assignmentStatus = assignmentStatus
        }
    }

}

extension QuickSightClientTypes {
    public enum IdentityStore: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case quicksight
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityStore] {
            return [
                .quicksight,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .quicksight: return "QUICKSIGHT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdentityStore(rawValue: rawValue) ?? IdentityStore.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum IdentityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iam
        case quicksight
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityType] {
            return [
                .iam,
                .quicksight,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iam: return "IAM"
            case .quicksight: return "QUICKSIGHT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdentityType(rawValue: rawValue) ?? IdentityType.sdkUnknown(rawValue)
        }
    }
}

extension IdentityTypeNotSupportedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IdentityTypeNotSupportedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The identity type specified isn't supported. Supported identity types include IAM and QUICKSIGHT.
public struct IdentityTypeNotSupportedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct IdentityTypeNotSupportedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension IdentityTypeNotSupportedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.Ingestion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case errorInfo = "ErrorInfo"
        case ingestionId = "IngestionId"
        case ingestionSizeInBytes = "IngestionSizeInBytes"
        case ingestionStatus = "IngestionStatus"
        case ingestionTimeInSeconds = "IngestionTimeInSeconds"
        case queueInfo = "QueueInfo"
        case requestSource = "RequestSource"
        case requestType = "RequestType"
        case rowInfo = "RowInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let errorInfo = errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
        if let ingestionId = ingestionId {
            try encodeContainer.encode(ingestionId, forKey: .ingestionId)
        }
        if ingestionSizeInBytes != 0 {
            try encodeContainer.encode(ingestionSizeInBytes, forKey: .ingestionSizeInBytes)
        }
        if let ingestionStatus = ingestionStatus {
            try encodeContainer.encode(ingestionStatus.rawValue, forKey: .ingestionStatus)
        }
        if ingestionTimeInSeconds != 0 {
            try encodeContainer.encode(ingestionTimeInSeconds, forKey: .ingestionTimeInSeconds)
        }
        if let queueInfo = queueInfo {
            try encodeContainer.encode(queueInfo, forKey: .queueInfo)
        }
        if let requestSource = requestSource {
            try encodeContainer.encode(requestSource.rawValue, forKey: .requestSource)
        }
        if let requestType = requestType {
            try encodeContainer.encode(requestType.rawValue, forKey: .requestType)
        }
        if let rowInfo = rowInfo {
            try encodeContainer.encode(rowInfo, forKey: .rowInfo)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ingestionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ingestionId)
        ingestionId = ingestionIdDecoded
        let ingestionStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IngestionStatus.self, forKey: .ingestionStatus)
        ingestionStatus = ingestionStatusDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let rowInfoDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RowInfo.self, forKey: .rowInfo)
        rowInfo = rowInfoDecoded
        let queueInfoDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.QueueInfo.self, forKey: .queueInfo)
        queueInfo = queueInfoDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let ingestionTimeInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .ingestionTimeInSeconds)
        ingestionTimeInSeconds = ingestionTimeInSecondsDecoded
        let ingestionSizeInBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .ingestionSizeInBytes)
        ingestionSizeInBytes = ingestionSizeInBytesDecoded
        let requestSourceDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IngestionRequestSource.self, forKey: .requestSource)
        requestSource = requestSourceDecoded
        let requestTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IngestionRequestType.self, forKey: .requestType)
        requestType = requestTypeDecoded
    }
}

extension QuickSightClientTypes {
    /// Information about the SPICE ingestion for a dataset.
    public struct Ingestion: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        /// This member is required.
        public var arn: Swift.String?
        /// The time that this ingestion started.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// Error information for this ingestion.
        public var errorInfo: QuickSightClientTypes.ErrorInfo?
        /// Ingestion ID.
        public var ingestionId: Swift.String?
        /// The size of the data ingested, in bytes.
        public var ingestionSizeInBytes: Swift.Int
        /// Ingestion status.
        /// This member is required.
        public var ingestionStatus: QuickSightClientTypes.IngestionStatus?
        /// The time that this ingestion took, measured in seconds.
        public var ingestionTimeInSeconds: Swift.Int
        /// Information about a queued dataset SPICE ingestion.
        public var queueInfo: QuickSightClientTypes.QueueInfo?
        /// Event source for this ingestion.
        public var requestSource: QuickSightClientTypes.IngestionRequestSource?
        /// Type of this ingestion.
        public var requestType: QuickSightClientTypes.IngestionRequestType?
        /// Information about rows for a data set SPICE ingestion.
        public var rowInfo: QuickSightClientTypes.RowInfo?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            errorInfo: QuickSightClientTypes.ErrorInfo? = nil,
            ingestionId: Swift.String? = nil,
            ingestionSizeInBytes: Swift.Int = 0,
            ingestionStatus: QuickSightClientTypes.IngestionStatus? = nil,
            ingestionTimeInSeconds: Swift.Int = 0,
            queueInfo: QuickSightClientTypes.QueueInfo? = nil,
            requestSource: QuickSightClientTypes.IngestionRequestSource? = nil,
            requestType: QuickSightClientTypes.IngestionRequestType? = nil,
            rowInfo: QuickSightClientTypes.RowInfo? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.errorInfo = errorInfo
            self.ingestionId = ingestionId
            self.ingestionSizeInBytes = ingestionSizeInBytes
            self.ingestionStatus = ingestionStatus
            self.ingestionTimeInSeconds = ingestionTimeInSeconds
            self.queueInfo = queueInfo
            self.requestSource = requestSource
            self.requestType = requestType
            self.rowInfo = rowInfo
        }
    }

}

extension QuickSightClientTypes {
    public enum IngestionErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountCapacityLimitExceeded
        case connectionFailure
        case cursorNotEnabled
        case customerError
        case dataSetDeleted
        case dataSetNotSpice
        case dataSetSizeLimitExceeded
        case dataSourceAuthFailed
        case dataSourceConnectionFailed
        case dataSourceNotFound
        case dataToleranceException
        case elasticsearchCursorNotEnabled
        case failureToAssumeRole
        case failureToProcessJsonFile
        case iamRoleNotAvailable
        case ingestionCanceled
        case ingestionSuperseded
        case internalServiceError
        case invalidDataprepSyntax
        case invalidDataSourceConfig
        case invalidDateFormat
        case iotDataSetFileEmpty
        case iotFileNotFound
        case oauthTokenFailure
        case passwordAuthenticationFailure
        case permissionDenied
        case permissionNotFound
        case queryTimeout
        case refreshSuppressedByEdit
        case rowSizeLimitExceeded
        case s3FileInaccessible
        case s3ManifestError
        case s3UploadedFileDeleted
        case sourceApiLimitExceededFailure
        case sourceResourceLimitExceeded
        case spiceTableNotFound
        case sqlException
        case sqlInvalidParameterValue
        case sqlNumericOverflow
        case sqlSchemaMismatchError
        case sqlTableNotFound
        case sslCertificateValidationFailure
        case unresolvableHost
        case unroutableHost
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionErrorType] {
            return [
                .accountCapacityLimitExceeded,
                .connectionFailure,
                .cursorNotEnabled,
                .customerError,
                .dataSetDeleted,
                .dataSetNotSpice,
                .dataSetSizeLimitExceeded,
                .dataSourceAuthFailed,
                .dataSourceConnectionFailed,
                .dataSourceNotFound,
                .dataToleranceException,
                .elasticsearchCursorNotEnabled,
                .failureToAssumeRole,
                .failureToProcessJsonFile,
                .iamRoleNotAvailable,
                .ingestionCanceled,
                .ingestionSuperseded,
                .internalServiceError,
                .invalidDataprepSyntax,
                .invalidDataSourceConfig,
                .invalidDateFormat,
                .iotDataSetFileEmpty,
                .iotFileNotFound,
                .oauthTokenFailure,
                .passwordAuthenticationFailure,
                .permissionDenied,
                .permissionNotFound,
                .queryTimeout,
                .refreshSuppressedByEdit,
                .rowSizeLimitExceeded,
                .s3FileInaccessible,
                .s3ManifestError,
                .s3UploadedFileDeleted,
                .sourceApiLimitExceededFailure,
                .sourceResourceLimitExceeded,
                .spiceTableNotFound,
                .sqlException,
                .sqlInvalidParameterValue,
                .sqlNumericOverflow,
                .sqlSchemaMismatchError,
                .sqlTableNotFound,
                .sslCertificateValidationFailure,
                .unresolvableHost,
                .unroutableHost,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountCapacityLimitExceeded: return "ACCOUNT_CAPACITY_LIMIT_EXCEEDED"
            case .connectionFailure: return "CONNECTION_FAILURE"
            case .cursorNotEnabled: return "CURSOR_NOT_ENABLED"
            case .customerError: return "CUSTOMER_ERROR"
            case .dataSetDeleted: return "DATA_SET_DELETED"
            case .dataSetNotSpice: return "DATA_SET_NOT_SPICE"
            case .dataSetSizeLimitExceeded: return "DATA_SET_SIZE_LIMIT_EXCEEDED"
            case .dataSourceAuthFailed: return "DATA_SOURCE_AUTH_FAILED"
            case .dataSourceConnectionFailed: return "DATA_SOURCE_CONNECTION_FAILED"
            case .dataSourceNotFound: return "DATA_SOURCE_NOT_FOUND"
            case .dataToleranceException: return "DATA_TOLERANCE_EXCEPTION"
            case .elasticsearchCursorNotEnabled: return "ELASTICSEARCH_CURSOR_NOT_ENABLED"
            case .failureToAssumeRole: return "FAILURE_TO_ASSUME_ROLE"
            case .failureToProcessJsonFile: return "FAILURE_TO_PROCESS_JSON_FILE"
            case .iamRoleNotAvailable: return "IAM_ROLE_NOT_AVAILABLE"
            case .ingestionCanceled: return "INGESTION_CANCELED"
            case .ingestionSuperseded: return "INGESTION_SUPERSEDED"
            case .internalServiceError: return "INTERNAL_SERVICE_ERROR"
            case .invalidDataprepSyntax: return "INVALID_DATAPREP_SYNTAX"
            case .invalidDataSourceConfig: return "INVALID_DATA_SOURCE_CONFIG"
            case .invalidDateFormat: return "INVALID_DATE_FORMAT"
            case .iotDataSetFileEmpty: return "IOT_DATA_SET_FILE_EMPTY"
            case .iotFileNotFound: return "IOT_FILE_NOT_FOUND"
            case .oauthTokenFailure: return "OAUTH_TOKEN_FAILURE"
            case .passwordAuthenticationFailure: return "PASSWORD_AUTHENTICATION_FAILURE"
            case .permissionDenied: return "PERMISSION_DENIED"
            case .permissionNotFound: return "PERMISSION_NOT_FOUND"
            case .queryTimeout: return "QUERY_TIMEOUT"
            case .refreshSuppressedByEdit: return "REFRESH_SUPPRESSED_BY_EDIT"
            case .rowSizeLimitExceeded: return "ROW_SIZE_LIMIT_EXCEEDED"
            case .s3FileInaccessible: return "S3_FILE_INACCESSIBLE"
            case .s3ManifestError: return "S3_MANIFEST_ERROR"
            case .s3UploadedFileDeleted: return "S3_UPLOADED_FILE_DELETED"
            case .sourceApiLimitExceededFailure: return "SOURCE_API_LIMIT_EXCEEDED_FAILURE"
            case .sourceResourceLimitExceeded: return "SOURCE_RESOURCE_LIMIT_EXCEEDED"
            case .spiceTableNotFound: return "SPICE_TABLE_NOT_FOUND"
            case .sqlException: return "SQL_EXCEPTION"
            case .sqlInvalidParameterValue: return "SQL_INVALID_PARAMETER_VALUE"
            case .sqlNumericOverflow: return "SQL_NUMERIC_OVERFLOW"
            case .sqlSchemaMismatchError: return "SQL_SCHEMA_MISMATCH_ERROR"
            case .sqlTableNotFound: return "SQL_TABLE_NOT_FOUND"
            case .sslCertificateValidationFailure: return "SSL_CERTIFICATE_VALIDATION_FAILURE"
            case .unresolvableHost: return "UNRESOLVABLE_HOST"
            case .unroutableHost: return "UNROUTABLE_HOST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionErrorType(rawValue: rawValue) ?? IngestionErrorType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum IngestionRequestSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case manual
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionRequestSource] {
            return [
                .manual,
                .scheduled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .manual: return "MANUAL"
            case .scheduled: return "SCHEDULED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionRequestSource(rawValue: rawValue) ?? IngestionRequestSource.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    /// This defines the type of ingestion request. This is returned as part of create ingestion response.
    public enum IngestionRequestType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case edit
        case fullRefresh
        case incrementalRefresh
        case initialIngestion
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionRequestType] {
            return [
                .edit,
                .fullRefresh,
                .incrementalRefresh,
                .initialIngestion,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .edit: return "EDIT"
            case .fullRefresh: return "FULL_REFRESH"
            case .incrementalRefresh: return "INCREMENTAL_REFRESH"
            case .initialIngestion: return "INITIAL_INGESTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionRequestType(rawValue: rawValue) ?? IngestionRequestType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum IngestionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case failed
        case initialized
        case queued
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionStatus] {
            return [
                .cancelled,
                .completed,
                .failed,
                .initialized,
                .queued,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .initialized: return "INITIALIZED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionStatus(rawValue: rawValue) ?? IngestionStatus.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    /// This defines the type of ingestion user wants to trigger. This is part of create ingestion request.
    public enum IngestionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullRefresh
        case incrementalRefresh
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionType] {
            return [
                .fullRefresh,
                .incrementalRefresh,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullRefresh: return "FULL_REFRESH"
            case .incrementalRefresh: return "INCREMENTAL_REFRESH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionType(rawValue: rawValue) ?? IngestionType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.InputColumn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.InputColumnDataType.self, forKey: .type)
        type = typeDecoded
    }
}

extension QuickSightClientTypes {
    /// Metadata for a column that is used as the input of a transform operation.
    public struct InputColumn: Swift.Equatable {
        /// The name of this column in the underlying data source.
        /// This member is required.
        public var name: Swift.String?
        /// The data type of the column.
        /// This member is required.
        public var type: QuickSightClientTypes.InputColumnDataType?

        public init (
            name: Swift.String? = nil,
            type: QuickSightClientTypes.InputColumnDataType? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension QuickSightClientTypes {
    public enum InputColumnDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bit
        case boolean
        case datetime
        case decimal
        case integer
        case json
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [InputColumnDataType] {
            return [
                .bit,
                .boolean,
                .datetime,
                .decimal,
                .integer,
                .json,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bit: return "BIT"
            case .boolean: return "BOOLEAN"
            case .datetime: return "DATETIME"
            case .decimal: return "DECIMAL"
            case .integer: return "INTEGER"
            case .json: return "JSON"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InputColumnDataType(rawValue: rawValue) ?? InputColumnDataType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.IntegerParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for longlist0 in values {
                try valuesContainer.encode(longlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .values)
        var valuesDecoded0:[Swift.Int]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.Int]()
            for long0 in valuesContainer {
                if let long0 = long0 {
                    valuesDecoded0?.append(long0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension QuickSightClientTypes {
    /// An integer parameter.
    public struct IntegerParameter: Swift.Equatable {
        /// The name of the integer parameter.
        /// This member is required.
        public var name: Swift.String?
        /// The values for the integer parameter.
        /// This member is required.
        public var values: [Swift.Int]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.Int]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension InternalFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal failure occurred.
public struct InternalFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The NextToken value isn't valid.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension InvalidParameterValueException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more parameters has a value that isn't valid.
public struct InvalidParameterValueException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct InvalidParameterValueExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension InvalidParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.JiraParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case siteBaseUrl = "SiteBaseUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let siteBaseUrl = siteBaseUrl {
            try encodeContainer.encode(siteBaseUrl, forKey: .siteBaseUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteBaseUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteBaseUrl)
        siteBaseUrl = siteBaseUrlDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for Jira.
    public struct JiraParameters: Swift.Equatable {
        /// The base URL of the Jira site.
        /// This member is required.
        public var siteBaseUrl: Swift.String?

        public init (
            siteBaseUrl: Swift.String? = nil
        )
        {
            self.siteBaseUrl = siteBaseUrl
        }
    }

}

extension QuickSightClientTypes.JoinInstruction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case leftJoinKeyProperties = "LeftJoinKeyProperties"
        case leftOperand = "LeftOperand"
        case onClause = "OnClause"
        case rightJoinKeyProperties = "RightJoinKeyProperties"
        case rightOperand = "RightOperand"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let leftJoinKeyProperties = leftJoinKeyProperties {
            try encodeContainer.encode(leftJoinKeyProperties, forKey: .leftJoinKeyProperties)
        }
        if let leftOperand = leftOperand {
            try encodeContainer.encode(leftOperand, forKey: .leftOperand)
        }
        if let onClause = onClause {
            try encodeContainer.encode(onClause, forKey: .onClause)
        }
        if let rightJoinKeyProperties = rightJoinKeyProperties {
            try encodeContainer.encode(rightJoinKeyProperties, forKey: .rightJoinKeyProperties)
        }
        if let rightOperand = rightOperand {
            try encodeContainer.encode(rightOperand, forKey: .rightOperand)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let leftOperandDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .leftOperand)
        leftOperand = leftOperandDecoded
        let rightOperandDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rightOperand)
        rightOperand = rightOperandDecoded
        let leftJoinKeyPropertiesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.JoinKeyProperties.self, forKey: .leftJoinKeyProperties)
        leftJoinKeyProperties = leftJoinKeyPropertiesDecoded
        let rightJoinKeyPropertiesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.JoinKeyProperties.self, forKey: .rightJoinKeyProperties)
        rightJoinKeyProperties = rightJoinKeyPropertiesDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.JoinType.self, forKey: .type)
        type = typeDecoded
        let onClauseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .onClause)
        onClause = onClauseDecoded
    }
}

extension QuickSightClientTypes {
    /// The instructions associated with a join.
    public struct JoinInstruction: Swift.Equatable {
        /// Join key properties of the left operand.
        public var leftJoinKeyProperties: QuickSightClientTypes.JoinKeyProperties?
        /// The operand on the left side of a join.
        /// This member is required.
        public var leftOperand: Swift.String?
        /// The join instructions provided in the ON clause of a join.
        /// This member is required.
        public var onClause: Swift.String?
        /// Join key properties of the right operand.
        public var rightJoinKeyProperties: QuickSightClientTypes.JoinKeyProperties?
        /// The operand on the right side of a join.
        /// This member is required.
        public var rightOperand: Swift.String?
        /// The type of join that it is.
        /// This member is required.
        public var type: QuickSightClientTypes.JoinType?

        public init (
            leftJoinKeyProperties: QuickSightClientTypes.JoinKeyProperties? = nil,
            leftOperand: Swift.String? = nil,
            onClause: Swift.String? = nil,
            rightJoinKeyProperties: QuickSightClientTypes.JoinKeyProperties? = nil,
            rightOperand: Swift.String? = nil,
            type: QuickSightClientTypes.JoinType? = nil
        )
        {
            self.leftJoinKeyProperties = leftJoinKeyProperties
            self.leftOperand = leftOperand
            self.onClause = onClause
            self.rightJoinKeyProperties = rightJoinKeyProperties
            self.rightOperand = rightOperand
            self.type = type
        }
    }

}

extension QuickSightClientTypes.JoinKeyProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uniqueKey = "UniqueKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if uniqueKey != false {
            try encodeContainer.encode(uniqueKey, forKey: .uniqueKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uniqueKeyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .uniqueKey)
        uniqueKey = uniqueKeyDecoded
    }
}

extension QuickSightClientTypes {
    /// Properties associated with the columns participating in a join.
    public struct JoinKeyProperties: Swift.Equatable {
        /// A value that indicates that a row in a table is uniquely identified by the columns in a join key. This is used by Amazon QuickSight to optimize query performance.
        public var uniqueKey: Swift.Bool

        public init (
            uniqueKey: Swift.Bool = false
        )
        {
            self.uniqueKey = uniqueKey
        }
    }

}

extension QuickSightClientTypes {
    public enum JoinType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case inner
        case `left`
        case outer
        case `right`
        case sdkUnknown(Swift.String)

        public static var allCases: [JoinType] {
            return [
                .inner,
                .left,
                .outer,
                .right,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .inner: return "INNER"
            case .left: return "LEFT"
            case .outer: return "OUTER"
            case .right: return "RIGHT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JoinType(rawValue: rawValue) ?? JoinType.sdkUnknown(rawValue)
        }
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.requestId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A limit is exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?
    /// Limit exceeded.
    public var resourceType: QuickSightClientTypes.ExceptionResourceType?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceType: QuickSightClientTypes.ExceptionResourceType? = nil
    )
    {
        self.message = message
        self.requestId = requestId
        self.resourceType = resourceType
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: QuickSightClientTypes.ExceptionResourceType?
    let requestId: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ExceptionResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.LinkSharingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissions = "Permissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for resourcepermissionlist0 in permissions {
                try permissionsContainer.encode(resourcepermissionlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A structure that contains the configuration of a shareable link to the dashboard.
    public struct LinkSharingConfiguration: Swift.Equatable {
        /// A structure that contains the permissions of a shareable link.
        public var permissions: [QuickSightClientTypes.ResourcePermission]?

        public init (
            permissions: [QuickSightClientTypes.ResourcePermission]? = nil
        )
        {
            self.permissions = permissions
        }
    }

}

extension ListAnalysesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAnalysesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/analyses"
    }
}

public struct ListAnalysesInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the analyses.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAnalysesInputBody: Swift.Equatable {
}

extension ListAnalysesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAnalysesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnalysesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAnalysesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnalysesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAnalysesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisSummaryList = output.analysisSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.analysisSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListAnalysesOutputResponse: Swift.Equatable {
    /// Metadata describing each of the analyses that are listed.
    public var analysisSummaryList: [QuickSightClientTypes.AnalysisSummary]?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        analysisSummaryList: [QuickSightClientTypes.AnalysisSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.analysisSummaryList = analysisSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListAnalysesOutputResponseBody: Swift.Equatable {
    let analysisSummaryList: [QuickSightClientTypes.AnalysisSummary]?
    let nextToken: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension ListAnalysesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisSummaryList = "AnalysisSummaryList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisSummaryListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.AnalysisSummary?].self, forKey: .analysisSummaryList)
        var analysisSummaryListDecoded0:[QuickSightClientTypes.AnalysisSummary]? = nil
        if let analysisSummaryListContainer = analysisSummaryListContainer {
            analysisSummaryListDecoded0 = [QuickSightClientTypes.AnalysisSummary]()
            for structure0 in analysisSummaryListContainer {
                if let structure0 = structure0 {
                    analysisSummaryListDecoded0?.append(structure0)
                }
            }
        }
        analysisSummaryList = analysisSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListDashboardVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDashboardVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dashboardId = dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())/versions"
    }
}

public struct ListDashboardVersionsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the dashboard that you're listing versions for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDashboardVersionsInputBody: Swift.Equatable {
}

extension ListDashboardVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDashboardVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDashboardVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDashboardVersionsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDashboardVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDashboardVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dashboardVersionSummaryList = output.dashboardVersionSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.dashboardVersionSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListDashboardVersionsOutputResponse: Swift.Equatable {
    /// A structure that contains information about each version of the dashboard.
    public var dashboardVersionSummaryList: [QuickSightClientTypes.DashboardVersionSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dashboardVersionSummaryList: [QuickSightClientTypes.DashboardVersionSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dashboardVersionSummaryList = dashboardVersionSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListDashboardVersionsOutputResponseBody: Swift.Equatable {
    let dashboardVersionSummaryList: [QuickSightClientTypes.DashboardVersionSummary]?
    let nextToken: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension ListDashboardVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardVersionSummaryList = "DashboardVersionSummaryList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardVersionSummaryListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DashboardVersionSummary?].self, forKey: .dashboardVersionSummaryList)
        var dashboardVersionSummaryListDecoded0:[QuickSightClientTypes.DashboardVersionSummary]? = nil
        if let dashboardVersionSummaryListContainer = dashboardVersionSummaryListContainer {
            dashboardVersionSummaryListDecoded0 = [QuickSightClientTypes.DashboardVersionSummary]()
            for structure0 in dashboardVersionSummaryListContainer {
                if let structure0 = structure0 {
                    dashboardVersionSummaryListDecoded0?.append(structure0)
                }
            }
        }
        dashboardVersionSummaryList = dashboardVersionSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListDashboardsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDashboardsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards"
    }
}

public struct ListDashboardsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the dashboards that you're listing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDashboardsInputBody: Swift.Equatable {
}

extension ListDashboardsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDashboardsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDashboardsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDashboardsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDashboardsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDashboardsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dashboardSummaryList = output.dashboardSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.dashboardSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListDashboardsOutputResponse: Swift.Equatable {
    /// A structure that contains all of the dashboards in your Amazon Web Services account. This structure provides basic information about the dashboards.
    public var dashboardSummaryList: [QuickSightClientTypes.DashboardSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dashboardSummaryList: [QuickSightClientTypes.DashboardSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dashboardSummaryList = dashboardSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListDashboardsOutputResponseBody: Swift.Equatable {
    let dashboardSummaryList: [QuickSightClientTypes.DashboardSummary]?
    let nextToken: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension ListDashboardsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardSummaryList = "DashboardSummaryList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardSummaryListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DashboardSummary?].self, forKey: .dashboardSummaryList)
        var dashboardSummaryListDecoded0:[QuickSightClientTypes.DashboardSummary]? = nil
        if let dashboardSummaryListContainer = dashboardSummaryListContainer {
            dashboardSummaryListDecoded0 = [QuickSightClientTypes.DashboardSummary]()
            for structure0 in dashboardSummaryListContainer {
                if let structure0 = structure0 {
                    dashboardSummaryListDecoded0?.append(structure0)
                }
            }
        }
        dashboardSummaryList = dashboardSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListDataSetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDataSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets"
    }
}

public struct ListDataSetsInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataSetsInputBody: Swift.Equatable {
}

extension ListDataSetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDataSetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataSetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDataSetsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataSetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDataSetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSetSummaries = output.dataSetSummaries
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.dataSetSummaries = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListDataSetsOutputResponse: Swift.Equatable {
    /// The list of dataset summaries.
    public var dataSetSummaries: [QuickSightClientTypes.DataSetSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dataSetSummaries: [QuickSightClientTypes.DataSetSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSetSummaries = dataSetSummaries
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListDataSetsOutputResponseBody: Swift.Equatable {
    let dataSetSummaries: [QuickSightClientTypes.DataSetSummary]?
    let nextToken: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension ListDataSetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetSummaries = "DataSetSummaries"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetSummariesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataSetSummary?].self, forKey: .dataSetSummaries)
        var dataSetSummariesDecoded0:[QuickSightClientTypes.DataSetSummary]? = nil
        if let dataSetSummariesContainer = dataSetSummariesContainer {
            dataSetSummariesDecoded0 = [QuickSightClientTypes.DataSetSummary]()
            for structure0 in dataSetSummariesContainer {
                if let structure0 = structure0 {
                    dataSetSummariesDecoded0?.append(structure0)
                }
            }
        }
        dataSetSummaries = dataSetSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListDataSourcesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDataSourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sources"
    }
}

public struct ListDataSourcesInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataSourcesInputBody: Swift.Equatable {
}

extension ListDataSourcesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDataSourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataSourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDataSourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataSourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDataSourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSources = output.dataSources
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.dataSources = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListDataSourcesOutputResponse: Swift.Equatable {
    /// A list of data sources.
    public var dataSources: [QuickSightClientTypes.DataSource]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dataSources: [QuickSightClientTypes.DataSource]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSources = dataSources
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListDataSourcesOutputResponseBody: Swift.Equatable {
    let dataSources: [QuickSightClientTypes.DataSource]?
    let nextToken: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension ListDataSourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSources = "DataSources"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourcesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[QuickSightClientTypes.DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [QuickSightClientTypes.DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListFolderMembersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListFolderMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let folderId = folderId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())/members"
    }
}

public struct ListFolderMembersInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFolderMembersInputBody: Swift.Equatable {
}

extension ListFolderMembersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFolderMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFolderMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFolderMembersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFolderMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFolderMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.folderMemberList = output.folderMemberList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.folderMemberList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListFolderMembersOutputResponse: Swift.Equatable {
    /// A structure that contains all of the folder members (dashboards, analyses, and datasets) in the folder.
    public var folderMemberList: [QuickSightClientTypes.MemberIdArnPair]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        folderMemberList: [QuickSightClientTypes.MemberIdArnPair]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.folderMemberList = folderMemberList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListFolderMembersOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let folderMemberList: [QuickSightClientTypes.MemberIdArnPair]?
    let nextToken: Swift.String?
    let requestId: Swift.String?
}

extension ListFolderMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case folderMemberList = "FolderMemberList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let folderMemberListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MemberIdArnPair?].self, forKey: .folderMemberList)
        var folderMemberListDecoded0:[QuickSightClientTypes.MemberIdArnPair]? = nil
        if let folderMemberListContainer = folderMemberListContainer {
            folderMemberListDecoded0 = [QuickSightClientTypes.MemberIdArnPair]()
            for structure0 in folderMemberListContainer {
                if let structure0 = structure0 {
                    folderMemberListDecoded0?.append(structure0)
                }
            }
        }
        folderMemberList = folderMemberListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListFoldersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListFoldersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders"
    }
}

public struct ListFoldersInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFoldersInputBody: Swift.Equatable {
}

extension ListFoldersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFoldersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFoldersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFoldersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFoldersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFoldersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.folderSummaryList = output.folderSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.folderSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListFoldersOutputResponse: Swift.Equatable {
    /// A structure that contains all of the folders in the Amazon Web Services account. This structure provides basic information about the folders.
    public var folderSummaryList: [QuickSightClientTypes.FolderSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        folderSummaryList: [QuickSightClientTypes.FolderSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.folderSummaryList = folderSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListFoldersOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let folderSummaryList: [QuickSightClientTypes.FolderSummary]?
    let nextToken: Swift.String?
    let requestId: Swift.String?
}

extension ListFoldersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case folderSummaryList = "FolderSummaryList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let folderSummaryListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FolderSummary?].self, forKey: .folderSummaryList)
        var folderSummaryListDecoded0:[QuickSightClientTypes.FolderSummary]? = nil
        if let folderSummaryListContainer = folderSummaryListContainer {
            folderSummaryListDecoded0 = [QuickSightClientTypes.FolderSummary]()
            for structure0 in folderSummaryListContainer {
                if let structure0 = structure0 {
                    folderSummaryListDecoded0?.append(structure0)
                }
            }
        }
        folderSummaryList = folderSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListGroupMembershipsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListGroupMembershipsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let groupName = groupName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups/\(groupName.urlPercentEncoding())/members"
    }
}

public struct ListGroupMembershipsInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The name of the group that you want to see a membership list of.
    /// This member is required.
    public var groupName: Swift.String?
    /// The maximum number of results to return from this request.
    public var maxResults: Swift.Int
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.groupName = groupName
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
    }
}

struct ListGroupMembershipsInputBody: Swift.Equatable {
}

extension ListGroupMembershipsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListGroupMembershipsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroupMembershipsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGroupMembershipsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupMembershipsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListGroupMembershipsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groupMemberList = output.groupMemberList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.groupMemberList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListGroupMembershipsOutputResponse: Swift.Equatable {
    /// The list of the members of the group.
    public var groupMemberList: [QuickSightClientTypes.GroupMember]?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        groupMemberList: [QuickSightClientTypes.GroupMember]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.groupMemberList = groupMemberList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListGroupMembershipsOutputResponseBody: Swift.Equatable {
    let groupMemberList: [QuickSightClientTypes.GroupMember]?
    let nextToken: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension ListGroupMembershipsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupMemberList = "GroupMemberList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupMemberListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.GroupMember?].self, forKey: .groupMemberList)
        var groupMemberListDecoded0:[QuickSightClientTypes.GroupMember]? = nil
        if let groupMemberListContainer = groupMemberListContainer {
            groupMemberListDecoded0 = [QuickSightClientTypes.GroupMember]()
            for structure0 in groupMemberListContainer {
                if let structure0 = structure0 {
                    groupMemberListDecoded0?.append(structure0)
                }
            }
        }
        groupMemberList = groupMemberListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups"
    }
}

public struct ListGroupsInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
    }
}

struct ListGroupsInputBody: Swift.Equatable {
}

extension ListGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGroupsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groupList = output.groupList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.groupList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListGroupsOutputResponse: Swift.Equatable {
    /// The list of the groups.
    public var groupList: [QuickSightClientTypes.Group]?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        groupList: [QuickSightClientTypes.Group]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.groupList = groupList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListGroupsOutputResponseBody: Swift.Equatable {
    let groupList: [QuickSightClientTypes.Group]?
    let nextToken: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension ListGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupList = "GroupList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Group?].self, forKey: .groupList)
        var groupListDecoded0:[QuickSightClientTypes.Group]? = nil
        if let groupListContainer = groupListContainer {
            groupListDecoded0 = [QuickSightClientTypes.Group]()
            for structure0 in groupListContainer {
                if let structure0 = structure0 {
                    groupListDecoded0?.append(structure0)
                }
            }
        }
        groupList = groupListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListIAMPolicyAssignmentsForUserInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListIAMPolicyAssignmentsForUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let userName = userName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/users/\(userName.urlPercentEncoding())/iam-policy-assignments"
    }
}

public struct ListIAMPolicyAssignmentsForUserInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the assignments.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int
    /// The namespace of the assignment.
    /// This member is required.
    public var namespace: Swift.String?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The name of the user.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
        self.userName = userName
    }
}

struct ListIAMPolicyAssignmentsForUserInputBody: Swift.Equatable {
}

extension ListIAMPolicyAssignmentsForUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListIAMPolicyAssignmentsForUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIAMPolicyAssignmentsForUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentUpdatingException" : self = .concurrentUpdatingException(try ConcurrentUpdatingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIAMPolicyAssignmentsForUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case concurrentUpdatingException(ConcurrentUpdatingException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIAMPolicyAssignmentsForUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListIAMPolicyAssignmentsForUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.activeAssignments = output.activeAssignments
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.activeAssignments = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListIAMPolicyAssignmentsForUserOutputResponse: Swift.Equatable {
    /// The active assignments for this user.
    public var activeAssignments: [QuickSightClientTypes.ActiveIAMPolicyAssignment]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        activeAssignments: [QuickSightClientTypes.ActiveIAMPolicyAssignment]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.activeAssignments = activeAssignments
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListIAMPolicyAssignmentsForUserOutputResponseBody: Swift.Equatable {
    let activeAssignments: [QuickSightClientTypes.ActiveIAMPolicyAssignment]?
    let requestId: Swift.String?
    let nextToken: Swift.String?
    let status: Swift.Int
}

extension ListIAMPolicyAssignmentsForUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeAssignments = "ActiveAssignments"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeAssignmentsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ActiveIAMPolicyAssignment?].self, forKey: .activeAssignments)
        var activeAssignmentsDecoded0:[QuickSightClientTypes.ActiveIAMPolicyAssignment]? = nil
        if let activeAssignmentsContainer = activeAssignmentsContainer {
            activeAssignmentsDecoded0 = [QuickSightClientTypes.ActiveIAMPolicyAssignment]()
            for structure0 in activeAssignmentsContainer {
                if let structure0 = structure0 {
                    activeAssignmentsDecoded0?.append(structure0)
                }
            }
        }
        activeAssignments = activeAssignmentsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListIAMPolicyAssignmentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentStatus = "AssignmentStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentStatus = assignmentStatus {
            try encodeContainer.encode(assignmentStatus.rawValue, forKey: .assignmentStatus)
        }
    }
}

extension ListIAMPolicyAssignmentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListIAMPolicyAssignmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/iam-policy-assignments"
    }
}

public struct ListIAMPolicyAssignmentsInput: Swift.Equatable {
    /// The status of the assignments.
    public var assignmentStatus: QuickSightClientTypes.AssignmentStatus?
    /// The ID of the Amazon Web Services account that contains these IAM policy assignments.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int
    /// The namespace for the assignments.
    /// This member is required.
    public var namespace: Swift.String?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        assignmentStatus: QuickSightClientTypes.AssignmentStatus? = nil,
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assignmentStatus = assignmentStatus
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
    }
}

struct ListIAMPolicyAssignmentsInputBody: Swift.Equatable {
    let assignmentStatus: QuickSightClientTypes.AssignmentStatus?
}

extension ListIAMPolicyAssignmentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentStatus = "AssignmentStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AssignmentStatus.self, forKey: .assignmentStatus)
        assignmentStatus = assignmentStatusDecoded
    }
}

extension ListIAMPolicyAssignmentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIAMPolicyAssignmentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIAMPolicyAssignmentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIAMPolicyAssignmentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListIAMPolicyAssignmentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.iAMPolicyAssignments = output.iAMPolicyAssignments
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.iAMPolicyAssignments = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListIAMPolicyAssignmentsOutputResponse: Swift.Equatable {
    /// Information describing the IAM policy assignments.
    public var iAMPolicyAssignments: [QuickSightClientTypes.IAMPolicyAssignmentSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        iAMPolicyAssignments: [QuickSightClientTypes.IAMPolicyAssignmentSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.iAMPolicyAssignments = iAMPolicyAssignments
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListIAMPolicyAssignmentsOutputResponseBody: Swift.Equatable {
    let iAMPolicyAssignments: [QuickSightClientTypes.IAMPolicyAssignmentSummary]?
    let nextToken: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension ListIAMPolicyAssignmentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iAMPolicyAssignments = "IAMPolicyAssignments"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iAMPolicyAssignmentsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.IAMPolicyAssignmentSummary?].self, forKey: .iAMPolicyAssignments)
        var iAMPolicyAssignmentsDecoded0:[QuickSightClientTypes.IAMPolicyAssignmentSummary]? = nil
        if let iAMPolicyAssignmentsContainer = iAMPolicyAssignmentsContainer {
            iAMPolicyAssignmentsDecoded0 = [QuickSightClientTypes.IAMPolicyAssignmentSummary]()
            for structure0 in iAMPolicyAssignmentsContainer {
                if let structure0 = structure0 {
                    iAMPolicyAssignmentsDecoded0?.append(structure0)
                }
            }
        }
        iAMPolicyAssignments = iAMPolicyAssignmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListIngestionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListIngestionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSetId = dataSetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/ingestions"
    }
}

public struct ListIngestionsInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dataset used in the ingestion.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIngestionsInputBody: Swift.Equatable {
}

extension ListIngestionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListIngestionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIngestionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIngestionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIngestionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListIngestionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ingestions = output.ingestions
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.ingestions = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListIngestionsOutputResponse: Swift.Equatable {
    /// A list of the ingestions.
    public var ingestions: [QuickSightClientTypes.Ingestion]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        ingestions: [QuickSightClientTypes.Ingestion]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.ingestions = ingestions
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListIngestionsOutputResponseBody: Swift.Equatable {
    let ingestions: [QuickSightClientTypes.Ingestion]?
    let nextToken: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension ListIngestionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingestions = "Ingestions"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ingestionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Ingestion?].self, forKey: .ingestions)
        var ingestionsDecoded0:[QuickSightClientTypes.Ingestion]? = nil
        if let ingestionsContainer = ingestionsContainer {
            ingestionsDecoded0 = [QuickSightClientTypes.Ingestion]()
            for structure0 in ingestionsContainer {
                if let structure0 = structure0 {
                    ingestionsDecoded0?.append(structure0)
                }
            }
        }
        ingestions = ingestionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListNamespacesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListNamespacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces"
    }
}

public struct ListNamespacesInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the Amazon QuickSight namespaces that you want to list.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListNamespacesInputBody: Swift.Equatable {
}

extension ListNamespacesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListNamespacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNamespacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListNamespacesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNamespacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListNamespacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.namespaces = output.namespaces
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.namespaces = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListNamespacesOutputResponse: Swift.Equatable {
    /// The information about the namespaces in this Amazon Web Services account. The response includes the namespace ARN, name, Amazon Web Services Region, notification email address, creation status, and identity store.
    public var namespaces: [QuickSightClientTypes.NamespaceInfoV2]?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        namespaces: [QuickSightClientTypes.NamespaceInfoV2]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.namespaces = namespaces
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListNamespacesOutputResponseBody: Swift.Equatable {
    let namespaces: [QuickSightClientTypes.NamespaceInfoV2]?
    let nextToken: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension ListNamespacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaces = "Namespaces"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespacesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.NamespaceInfoV2?].self, forKey: .namespaces)
        var namespacesDecoded0:[QuickSightClientTypes.NamespaceInfoV2]? = nil
        if let namespacesContainer = namespacesContainer {
            namespacesDecoded0 = [QuickSightClientTypes.NamespaceInfoV2]()
            for structure0 in namespacesContainer {
                if let structure0 = structure0 {
                    namespacesDecoded0?.append(structure0)
                }
            }
        }
        namespaces = namespacesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/resources/\(resourceArn.urlPercentEncoding())/tags"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want a list of tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.tags = output.tags
        } else {
            self.requestId = nil
            self.tags = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.
    public var tags: [QuickSightClientTypes.Tag]?

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        tags: [QuickSightClientTypes.Tag]? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [QuickSightClientTypes.Tag]?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QuickSightClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QuickSightClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListTemplateAliasesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-result".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTemplateAliasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/aliases"
    }
}

public struct ListTemplateAliasesInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the template aliases that you're listing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The ID for the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.templateId = templateId
    }
}

struct ListTemplateAliasesInputBody: Swift.Equatable {
}

extension ListTemplateAliasesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTemplateAliasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTemplateAliasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTemplateAliasesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTemplateAliasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTemplateAliasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.requestId = output.requestId
            self.templateAliasList = output.templateAliasList
        } else {
            self.nextToken = nil
            self.requestId = nil
            self.templateAliasList = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListTemplateAliasesOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// A structure containing the list of the template's aliases.
    public var templateAliasList: [QuickSightClientTypes.TemplateAlias]?

    public init (
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateAliasList: [QuickSightClientTypes.TemplateAlias]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.templateAliasList = templateAliasList
    }
}

struct ListTemplateAliasesOutputResponseBody: Swift.Equatable {
    let templateAliasList: [QuickSightClientTypes.TemplateAlias]?
    let status: Swift.Int
    let requestId: Swift.String?
    let nextToken: Swift.String?
}

extension ListTemplateAliasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
        case templateAliasList = "TemplateAliasList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateAliasListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.TemplateAlias?].self, forKey: .templateAliasList)
        var templateAliasListDecoded0:[QuickSightClientTypes.TemplateAlias]? = nil
        if let templateAliasListContainer = templateAliasListContainer {
            templateAliasListDecoded0 = [QuickSightClientTypes.TemplateAlias]()
            for structure0 in templateAliasListContainer {
                if let structure0 = structure0 {
                    templateAliasListDecoded0?.append(structure0)
                }
            }
        }
        templateAliasList = templateAliasListDecoded0
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTemplateVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTemplateVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/versions"
    }
}

public struct ListTemplateVersionsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the templates that you're listing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The ID for the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.templateId = templateId
    }
}

struct ListTemplateVersionsInputBody: Swift.Equatable {
}

extension ListTemplateVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTemplateVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTemplateVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTemplateVersionsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTemplateVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTemplateVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.requestId = output.requestId
            self.templateVersionSummaryList = output.templateVersionSummaryList
        } else {
            self.nextToken = nil
            self.requestId = nil
            self.templateVersionSummaryList = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListTemplateVersionsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// A structure containing a list of all the versions of the specified template.
    public var templateVersionSummaryList: [QuickSightClientTypes.TemplateVersionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateVersionSummaryList: [QuickSightClientTypes.TemplateVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.templateVersionSummaryList = templateVersionSummaryList
    }
}

struct ListTemplateVersionsOutputResponseBody: Swift.Equatable {
    let templateVersionSummaryList: [QuickSightClientTypes.TemplateVersionSummary]?
    let nextToken: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension ListTemplateVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
        case templateVersionSummaryList = "TemplateVersionSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateVersionSummaryListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.TemplateVersionSummary?].self, forKey: .templateVersionSummaryList)
        var templateVersionSummaryListDecoded0:[QuickSightClientTypes.TemplateVersionSummary]? = nil
        if let templateVersionSummaryListContainer = templateVersionSummaryListContainer {
            templateVersionSummaryListDecoded0 = [QuickSightClientTypes.TemplateVersionSummary]()
            for structure0 in templateVersionSummaryListContainer {
                if let structure0 = structure0 {
                    templateVersionSummaryListDecoded0?.append(structure0)
                }
            }
        }
        templateVersionSummaryList = templateVersionSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListTemplatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-result".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates"
    }
}

public struct ListTemplatesInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the templates that you're listing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTemplatesInputBody: Swift.Equatable {
}

extension ListTemplatesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTemplatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTemplatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTemplatesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTemplatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.requestId = output.requestId
            self.templateSummaryList = output.templateSummaryList
        } else {
            self.nextToken = nil
            self.requestId = nil
            self.templateSummaryList = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListTemplatesOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// A structure containing information about the templates in the list.
    public var templateSummaryList: [QuickSightClientTypes.TemplateSummary]?

    public init (
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateSummaryList: [QuickSightClientTypes.TemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.templateSummaryList = templateSummaryList
    }
}

struct ListTemplatesOutputResponseBody: Swift.Equatable {
    let templateSummaryList: [QuickSightClientTypes.TemplateSummary]?
    let nextToken: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension ListTemplatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
        case templateSummaryList = "TemplateSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateSummaryListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.TemplateSummary?].self, forKey: .templateSummaryList)
        var templateSummaryListDecoded0:[QuickSightClientTypes.TemplateSummary]? = nil
        if let templateSummaryListContainer = templateSummaryListContainer {
            templateSummaryListDecoded0 = [QuickSightClientTypes.TemplateSummary]()
            for structure0 in templateSummaryListContainer {
                if let structure0 = structure0 {
                    templateSummaryListDecoded0?.append(structure0)
                }
            }
        }
        templateSummaryList = templateSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListThemeAliasesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-result".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListThemeAliasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let themeId = themeId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())/aliases"
    }
}

public struct ListThemeAliasesInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the theme aliases that you're listing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The ID for the theme.
    /// This member is required.
    public var themeId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        themeId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.themeId = themeId
    }
}

struct ListThemeAliasesInputBody: Swift.Equatable {
}

extension ListThemeAliasesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListThemeAliasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThemeAliasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListThemeAliasesOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThemeAliasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListThemeAliasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.requestId = output.requestId
            self.themeAliasList = output.themeAliasList
        } else {
            self.nextToken = nil
            self.requestId = nil
            self.themeAliasList = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListThemeAliasesOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// A structure containing the list of the theme's aliases.
    public var themeAliasList: [QuickSightClientTypes.ThemeAlias]?

    public init (
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeAliasList: [QuickSightClientTypes.ThemeAlias]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.themeAliasList = themeAliasList
    }
}

struct ListThemeAliasesOutputResponseBody: Swift.Equatable {
    let themeAliasList: [QuickSightClientTypes.ThemeAlias]?
    let status: Swift.Int
    let requestId: Swift.String?
    let nextToken: Swift.String?
}

extension ListThemeAliasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
        case themeAliasList = "ThemeAliasList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeAliasListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ThemeAlias?].self, forKey: .themeAliasList)
        var themeAliasListDecoded0:[QuickSightClientTypes.ThemeAlias]? = nil
        if let themeAliasListContainer = themeAliasListContainer {
            themeAliasListDecoded0 = [QuickSightClientTypes.ThemeAlias]()
            for structure0 in themeAliasListContainer {
                if let structure0 = structure0 {
                    themeAliasListDecoded0?.append(structure0)
                }
            }
        }
        themeAliasList = themeAliasListDecoded0
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListThemeVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListThemeVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let themeId = themeId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())/versions"
    }
}

public struct ListThemeVersionsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the themes that you're listing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The ID for the theme.
    /// This member is required.
    public var themeId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        themeId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.themeId = themeId
    }
}

struct ListThemeVersionsInputBody: Swift.Equatable {
}

extension ListThemeVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListThemeVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThemeVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListThemeVersionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThemeVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListThemeVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.requestId = output.requestId
            self.themeVersionSummaryList = output.themeVersionSummaryList
        } else {
            self.nextToken = nil
            self.requestId = nil
            self.themeVersionSummaryList = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListThemeVersionsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// A structure containing a list of all the versions of the specified theme.
    public var themeVersionSummaryList: [QuickSightClientTypes.ThemeVersionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeVersionSummaryList: [QuickSightClientTypes.ThemeVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.themeVersionSummaryList = themeVersionSummaryList
    }
}

struct ListThemeVersionsOutputResponseBody: Swift.Equatable {
    let themeVersionSummaryList: [QuickSightClientTypes.ThemeVersionSummary]?
    let nextToken: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension ListThemeVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
        case themeVersionSummaryList = "ThemeVersionSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeVersionSummaryListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ThemeVersionSummary?].self, forKey: .themeVersionSummaryList)
        var themeVersionSummaryListDecoded0:[QuickSightClientTypes.ThemeVersionSummary]? = nil
        if let themeVersionSummaryListContainer = themeVersionSummaryListContainer {
            themeVersionSummaryListDecoded0 = [QuickSightClientTypes.ThemeVersionSummary]()
            for structure0 in themeVersionSummaryListContainer {
                if let structure0 = structure0 {
                    themeVersionSummaryListDecoded0?.append(structure0)
                }
            }
        }
        themeVersionSummaryList = themeVersionSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListThemesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let type = type {
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListThemesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes"
    }
}

public struct ListThemesInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the themes that you're listing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The type of themes that you want to list. Valid options include the following:
    ///
    /// * ALL (default)- Display all existing themes.
    ///
    /// * CUSTOM - Display only the themes created by people using Amazon QuickSight.
    ///
    /// * QUICKSIGHT - Display only the starting themes defined by Amazon QuickSight.
    public var type: QuickSightClientTypes.ThemeType?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        type: QuickSightClientTypes.ThemeType? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListThemesInputBody: Swift.Equatable {
}

extension ListThemesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListThemesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThemesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListThemesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThemesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListThemesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.requestId = output.requestId
            self.themeSummaryList = output.themeSummaryList
        } else {
            self.nextToken = nil
            self.requestId = nil
            self.themeSummaryList = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListThemesOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// Information about the themes in the list.
    public var themeSummaryList: [QuickSightClientTypes.ThemeSummary]?

    public init (
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeSummaryList: [QuickSightClientTypes.ThemeSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.themeSummaryList = themeSummaryList
    }
}

struct ListThemesOutputResponseBody: Swift.Equatable {
    let themeSummaryList: [QuickSightClientTypes.ThemeSummary]?
    let nextToken: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension ListThemesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
        case themeSummaryList = "ThemeSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeSummaryListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ThemeSummary?].self, forKey: .themeSummaryList)
        var themeSummaryListDecoded0:[QuickSightClientTypes.ThemeSummary]? = nil
        if let themeSummaryListContainer = themeSummaryListContainer {
            themeSummaryListDecoded0 = [QuickSightClientTypes.ThemeSummary]()
            for structure0 in themeSummaryListContainer {
                if let structure0 = structure0 {
                    themeSummaryListDecoded0?.append(structure0)
                }
            }
        }
        themeSummaryList = themeSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListUserGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListUserGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let userName = userName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/users/\(userName.urlPercentEncoding())/groups"
    }
}

public struct ListUserGroupsInput: Swift.Equatable {
    /// The Amazon Web Services account ID that the user is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to return from this request.
    public var maxResults: Swift.Int
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon QuickSight user name that you want to list group memberships for.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
        self.userName = userName
    }
}

struct ListUserGroupsInputBody: Swift.Equatable {
}

extension ListUserGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListUserGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUserGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUserGroupsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUserGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListUserGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groupList = output.groupList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.groupList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListUserGroupsOutputResponse: Swift.Equatable {
    /// The list of groups the user is a member of.
    public var groupList: [QuickSightClientTypes.Group]?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        groupList: [QuickSightClientTypes.Group]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.groupList = groupList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListUserGroupsOutputResponseBody: Swift.Equatable {
    let groupList: [QuickSightClientTypes.Group]?
    let nextToken: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension ListUserGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupList = "GroupList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Group?].self, forKey: .groupList)
        var groupListDecoded0:[QuickSightClientTypes.Group]? = nil
        if let groupListContainer = groupListContainer {
            groupListDecoded0 = [QuickSightClientTypes.Group]()
            for structure0 in groupListContainer {
                if let structure0 = structure0 {
                    groupListDecoded0?.append(structure0)
                }
            }
        }
        groupList = groupListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListUsersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/users"
    }
}

public struct ListUsersInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to return from this request.
    public var maxResults: Swift.Int
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
    }
}

struct ListUsersInputBody: Swift.Equatable {
}

extension ListUsersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListUsersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUsersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUsersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListUsersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.requestId = output.requestId
            self.userList = output.userList
        } else {
            self.nextToken = nil
            self.requestId = nil
            self.userList = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListUsersOutputResponse: Swift.Equatable {
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The list of users.
    public var userList: [QuickSightClientTypes.User]?

    public init (
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        userList: [QuickSightClientTypes.User]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.userList = userList
    }
}

struct ListUsersOutputResponseBody: Swift.Equatable {
    let userList: [QuickSightClientTypes.User]?
    let nextToken: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension ListUsersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
        case userList = "UserList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.User?].self, forKey: .userList)
        var userListDecoded0:[QuickSightClientTypes.User]? = nil
        if let userListContainer = userListContainer {
            userListDecoded0 = [QuickSightClientTypes.User]()
            for structure0 in userListContainer {
                if let structure0 = structure0 {
                    userListDecoded0?.append(structure0)
                }
            }
        }
        userList = userListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension QuickSightClientTypes.LogicalTable: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case dataTransforms = "DataTransforms"
        case source = "Source"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let dataTransforms = dataTransforms {
            var dataTransformsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataTransforms)
            for transformoperationlist0 in dataTransforms {
                try dataTransformsContainer.encode(transformoperationlist0)
            }
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let dataTransformsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.TransformOperation?].self, forKey: .dataTransforms)
        var dataTransformsDecoded0:[QuickSightClientTypes.TransformOperation]? = nil
        if let dataTransformsContainer = dataTransformsContainer {
            dataTransformsDecoded0 = [QuickSightClientTypes.TransformOperation]()
            for union0 in dataTransformsContainer {
                if let union0 = union0 {
                    dataTransformsDecoded0?.append(union0)
                }
            }
        }
        dataTransforms = dataTransformsDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LogicalTableSource.self, forKey: .source)
        source = sourceDecoded
    }
}

extension QuickSightClientTypes {
    /// A logical table is a unit that joins and that data transformations operate on. A logical table has a source, which can be either a physical table or result of a join. When a logical table points to a physical table, the logical table acts as a mutable copy of that physical table through transform operations.
    public struct LogicalTable: Swift.Equatable {
        /// A display name for the logical table.
        /// This member is required.
        public var alias: Swift.String?
        /// Transform operations that act on this logical table.
        public var dataTransforms: [QuickSightClientTypes.TransformOperation]?
        /// Source of this logical table.
        /// This member is required.
        public var source: QuickSightClientTypes.LogicalTableSource?

        public init (
            alias: Swift.String? = nil,
            dataTransforms: [QuickSightClientTypes.TransformOperation]? = nil,
            source: QuickSightClientTypes.LogicalTableSource? = nil
        )
        {
            self.alias = alias
            self.dataTransforms = dataTransforms
            self.source = source
        }
    }

}

extension QuickSightClientTypes.LogicalTableSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetArn = "DataSetArn"
        case joinInstruction = "JoinInstruction"
        case physicalTableId = "PhysicalTableId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSetArn = dataSetArn {
            try encodeContainer.encode(dataSetArn, forKey: .dataSetArn)
        }
        if let joinInstruction = joinInstruction {
            try encodeContainer.encode(joinInstruction, forKey: .joinInstruction)
        }
        if let physicalTableId = physicalTableId {
            try encodeContainer.encode(physicalTableId, forKey: .physicalTableId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let joinInstructionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.JoinInstruction.self, forKey: .joinInstruction)
        joinInstruction = joinInstructionDecoded
        let physicalTableIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .physicalTableId)
        physicalTableId = physicalTableIdDecoded
        let dataSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetArn)
        dataSetArn = dataSetArnDecoded
    }
}

extension QuickSightClientTypes {
    /// Information about the source of a logical table. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
    public struct LogicalTableSource: Swift.Equatable {
        /// The Amazon Resource Number (ARN) of the parent dataset.
        public var dataSetArn: Swift.String?
        /// Specifies the result of a join of two logical tables.
        public var joinInstruction: QuickSightClientTypes.JoinInstruction?
        /// Physical table ID.
        public var physicalTableId: Swift.String?

        public init (
            dataSetArn: Swift.String? = nil,
            joinInstruction: QuickSightClientTypes.JoinInstruction? = nil,
            physicalTableId: Swift.String? = nil
        )
        {
            self.dataSetArn = dataSetArn
            self.joinInstruction = joinInstruction
            self.physicalTableId = physicalTableId
        }
    }

}

extension QuickSightClientTypes.ManifestFileLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension QuickSightClientTypes {
    /// Amazon S3 manifest file location.
    public struct ManifestFileLocation: Swift.Equatable {
        /// Amazon S3 bucket.
        /// This member is required.
        public var bucket: Swift.String?
        /// Amazon S3 key that identifies an object.
        /// This member is required.
        public var key: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
        }
    }

}

extension QuickSightClientTypes.MarginStyle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case show = "Show"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if show != false {
            try encodeContainer.encode(show, forKey: .show)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let showDecoded = try containerValues.decode(Swift.Bool.self, forKey: .show)
        show = showDecoded
    }
}

extension QuickSightClientTypes {
    /// The display options for margins around the outside edge of sheets.
    public struct MarginStyle: Swift.Equatable {
        /// This Boolean value controls whether to display sheet margins.
        public var show: Swift.Bool

        public init (
            show: Swift.Bool = false
        )
        {
            self.show = show
        }
    }

}

extension QuickSightClientTypes.MariaDbParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for MariaDB.
    public struct MariaDbParameters: Swift.Equatable {
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int

        public init (
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.database = database
            self.host = host
            self.port = port
        }
    }

}

extension QuickSightClientTypes.MemberIdArnPair: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArn = "MemberArn"
        case memberId = "MemberId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberArn = memberArn {
            try encodeContainer.encode(memberArn, forKey: .memberArn)
        }
        if let memberId = memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberId)
        memberId = memberIdDecoded
        let memberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberArn)
        memberArn = memberArnDecoded
    }
}

extension QuickSightClientTypes {
    /// An object that consists of a member Amazon Resource Name (ARN) and a member ID.
    public struct MemberIdArnPair: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the member.
        public var memberArn: Swift.String?
        /// The ID of the member.
        public var memberId: Swift.String?

        public init (
            memberArn: Swift.String? = nil,
            memberId: Swift.String? = nil
        )
        {
            self.memberArn = memberArn
            self.memberId = memberId
        }
    }

}

extension QuickSightClientTypes {
    public enum MemberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case analysis
        case dashboard
        case dataset
        case sdkUnknown(Swift.String)

        public static var allCases: [MemberType] {
            return [
                .analysis,
                .dashboard,
                .dataset,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .analysis: return "ANALYSIS"
            case .dashboard: return "DASHBOARD"
            case .dataset: return "DATASET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MemberType(rawValue: rawValue) ?? MemberType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.MySqlParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for MySQL.
    public struct MySqlParameters: Swift.Equatable {
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int

        public init (
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.database = database
            self.host = host
            self.port = port
        }
    }

}

extension QuickSightClientTypes.NamespaceError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NamespaceErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QuickSightClientTypes {
    /// Errors that occur during namespace creation.
    public struct NamespaceError: Swift.Equatable {
        /// The message for the error.
        public var message: Swift.String?
        /// The error type.
        public var type: QuickSightClientTypes.NamespaceErrorType?

        public init (
            message: Swift.String? = nil,
            type: QuickSightClientTypes.NamespaceErrorType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }

}

extension QuickSightClientTypes {
    public enum NamespaceErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalServiceError
        case permissionDenied
        case sdkUnknown(Swift.String)

        public static var allCases: [NamespaceErrorType] {
            return [
                .internalServiceError,
                .permissionDenied,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalServiceError: return "INTERNAL_SERVICE_ERROR"
            case .permissionDenied: return "PERMISSION_DENIED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NamespaceErrorType(rawValue: rawValue) ?? NamespaceErrorType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.NamespaceInfoV2: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case capacityRegion = "CapacityRegion"
        case creationStatus = "CreationStatus"
        case identityStore = "IdentityStore"
        case name = "Name"
        case namespaceError = "NamespaceError"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let capacityRegion = capacityRegion {
            try encodeContainer.encode(capacityRegion, forKey: .capacityRegion)
        }
        if let creationStatus = creationStatus {
            try encodeContainer.encode(creationStatus.rawValue, forKey: .creationStatus)
        }
        if let identityStore = identityStore {
            try encodeContainer.encode(identityStore.rawValue, forKey: .identityStore)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespaceError = namespaceError {
            try encodeContainer.encode(namespaceError, forKey: .namespaceError)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let capacityRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacityRegion)
        capacityRegion = capacityRegionDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NamespaceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let identityStoreDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IdentityStore.self, forKey: .identityStore)
        identityStore = identityStoreDecoded
        let namespaceErrorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NamespaceError.self, forKey: .namespaceError)
        namespaceError = namespaceErrorDecoded
    }
}

extension QuickSightClientTypes {
    /// The error type.
    public struct NamespaceInfoV2: Swift.Equatable {
        /// The namespace ARN.
        public var arn: Swift.String?
        /// The namespace Amazon Web Services Region.
        public var capacityRegion: Swift.String?
        /// The creation status of a namespace that is not yet completely created.
        public var creationStatus: QuickSightClientTypes.NamespaceStatus?
        /// The identity store used for the namespace.
        public var identityStore: QuickSightClientTypes.IdentityStore?
        /// The name of the error.
        public var name: Swift.String?
        /// An error that occurred when the namespace was created.
        public var namespaceError: QuickSightClientTypes.NamespaceError?

        public init (
            arn: Swift.String? = nil,
            capacityRegion: Swift.String? = nil,
            creationStatus: QuickSightClientTypes.NamespaceStatus? = nil,
            identityStore: QuickSightClientTypes.IdentityStore? = nil,
            name: Swift.String? = nil,
            namespaceError: QuickSightClientTypes.NamespaceError? = nil
        )
        {
            self.arn = arn
            self.capacityRegion = capacityRegion
            self.creationStatus = creationStatus
            self.identityStore = identityStore
            self.name = name
            self.namespaceError = namespaceError
        }
    }

}

extension QuickSightClientTypes {
    public enum NamespaceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case creating
        case deleting
        case nonRetryableFailure
        case retryableFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [NamespaceStatus] {
            return [
                .created,
                .creating,
                .deleting,
                .nonRetryableFailure,
                .retryableFailure,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .nonRetryableFailure: return "NON_RETRYABLE_FAILURE"
            case .retryableFailure: return "RETRYABLE_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NamespaceStatus(rawValue: rawValue) ?? NamespaceStatus.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.OracleParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for Oracle.
    public struct OracleParameters: Swift.Equatable {
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// An Oracle host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int

        public init (
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.database = database
            self.host = host
            self.port = port
        }
    }

}

extension QuickSightClientTypes.OutputColumn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnDataType.self, forKey: .type)
        type = typeDecoded
    }
}

extension QuickSightClientTypes {
    /// Output column.
    public struct OutputColumn: Swift.Equatable {
        /// A description for a column.
        public var description: Swift.String?
        /// A display name for the dataset.
        public var name: Swift.String?
        /// Type.
        public var type: QuickSightClientTypes.ColumnDataType?

        public init (
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            type: QuickSightClientTypes.ColumnDataType? = nil
        )
        {
            self.description = description
            self.name = name
            self.type = type
        }
    }

}

extension QuickSightClientTypes.Parameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateTimeParameters = "DateTimeParameters"
        case decimalParameters = "DecimalParameters"
        case integerParameters = "IntegerParameters"
        case stringParameters = "StringParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateTimeParameters = dateTimeParameters {
            var dateTimeParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dateTimeParameters)
            for datetimeparameterlist0 in dateTimeParameters {
                try dateTimeParametersContainer.encode(datetimeparameterlist0)
            }
        }
        if let decimalParameters = decimalParameters {
            var decimalParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .decimalParameters)
            for decimalparameterlist0 in decimalParameters {
                try decimalParametersContainer.encode(decimalparameterlist0)
            }
        }
        if let integerParameters = integerParameters {
            var integerParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .integerParameters)
            for integerparameterlist0 in integerParameters {
                try integerParametersContainer.encode(integerparameterlist0)
            }
        }
        if let stringParameters = stringParameters {
            var stringParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stringParameters)
            for stringparameterlist0 in stringParameters {
                try stringParametersContainer.encode(stringparameterlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stringParametersContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.StringParameter?].self, forKey: .stringParameters)
        var stringParametersDecoded0:[QuickSightClientTypes.StringParameter]? = nil
        if let stringParametersContainer = stringParametersContainer {
            stringParametersDecoded0 = [QuickSightClientTypes.StringParameter]()
            for structure0 in stringParametersContainer {
                if let structure0 = structure0 {
                    stringParametersDecoded0?.append(structure0)
                }
            }
        }
        stringParameters = stringParametersDecoded0
        let integerParametersContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.IntegerParameter?].self, forKey: .integerParameters)
        var integerParametersDecoded0:[QuickSightClientTypes.IntegerParameter]? = nil
        if let integerParametersContainer = integerParametersContainer {
            integerParametersDecoded0 = [QuickSightClientTypes.IntegerParameter]()
            for structure0 in integerParametersContainer {
                if let structure0 = structure0 {
                    integerParametersDecoded0?.append(structure0)
                }
            }
        }
        integerParameters = integerParametersDecoded0
        let decimalParametersContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DecimalParameter?].self, forKey: .decimalParameters)
        var decimalParametersDecoded0:[QuickSightClientTypes.DecimalParameter]? = nil
        if let decimalParametersContainer = decimalParametersContainer {
            decimalParametersDecoded0 = [QuickSightClientTypes.DecimalParameter]()
            for structure0 in decimalParametersContainer {
                if let structure0 = structure0 {
                    decimalParametersDecoded0?.append(structure0)
                }
            }
        }
        decimalParameters = decimalParametersDecoded0
        let dateTimeParametersContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DateTimeParameter?].self, forKey: .dateTimeParameters)
        var dateTimeParametersDecoded0:[QuickSightClientTypes.DateTimeParameter]? = nil
        if let dateTimeParametersContainer = dateTimeParametersContainer {
            dateTimeParametersDecoded0 = [QuickSightClientTypes.DateTimeParameter]()
            for structure0 in dateTimeParametersContainer {
                if let structure0 = structure0 {
                    dateTimeParametersDecoded0?.append(structure0)
                }
            }
        }
        dateTimeParameters = dateTimeParametersDecoded0
    }
}

extension QuickSightClientTypes {
    /// A list of Amazon QuickSight parameters and the list's override values.
    public struct Parameters: Swift.Equatable {
        /// The parameters that have a data type of date-time.
        public var dateTimeParameters: [QuickSightClientTypes.DateTimeParameter]?
        /// The parameters that have a data type of decimal.
        public var decimalParameters: [QuickSightClientTypes.DecimalParameter]?
        /// The parameters that have a data type of integer.
        public var integerParameters: [QuickSightClientTypes.IntegerParameter]?
        /// The parameters that have a data type of string.
        public var stringParameters: [QuickSightClientTypes.StringParameter]?

        public init (
            dateTimeParameters: [QuickSightClientTypes.DateTimeParameter]? = nil,
            decimalParameters: [QuickSightClientTypes.DecimalParameter]? = nil,
            integerParameters: [QuickSightClientTypes.IntegerParameter]? = nil,
            stringParameters: [QuickSightClientTypes.StringParameter]? = nil
        )
        {
            self.dateTimeParameters = dateTimeParameters
            self.decimalParameters = decimalParameters
            self.integerParameters = integerParameters
            self.stringParameters = stringParameters
        }
    }

}

extension QuickSightClientTypes.PhysicalTable: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customsql = "CustomSql"
        case relationaltable = "RelationalTable"
        case s3source = "S3Source"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .customsql(customsql):
                try container.encode(customsql, forKey: .customsql)
            case let .relationaltable(relationaltable):
                try container.encode(relationaltable, forKey: .relationaltable)
            case let .s3source(s3source):
                try container.encode(s3source, forKey: .s3source)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let relationaltableDecoded = try values.decodeIfPresent(QuickSightClientTypes.RelationalTable.self, forKey: .relationaltable)
        if let relationaltable = relationaltableDecoded {
            self = .relationaltable(relationaltable)
            return
        }
        let customsqlDecoded = try values.decodeIfPresent(QuickSightClientTypes.CustomSql.self, forKey: .customsql)
        if let customsql = customsqlDecoded {
            self = .customsql(customsql)
            return
        }
        let s3sourceDecoded = try values.decodeIfPresent(QuickSightClientTypes.S3Source.self, forKey: .s3source)
        if let s3source = s3sourceDecoded {
            self = .s3source(s3source)
            return
        }
        self = .sdkUnknown("")
    }
}

extension QuickSightClientTypes {
    /// A view of a data source that contains information about the shape of the data in the underlying source. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
    public enum PhysicalTable: Swift.Equatable {
        /// A physical table type for relational data sources.
        case relationaltable(QuickSightClientTypes.RelationalTable)
        /// A physical table type built from the results of the custom SQL query.
        case customsql(QuickSightClientTypes.CustomSql)
        /// A physical table type for as S3 data source.
        case s3source(QuickSightClientTypes.S3Source)
        case sdkUnknown(Swift.String)
    }

}

extension QuickSightClientTypes.PostgreSqlParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for PostgreSQL.
    public struct PostgreSqlParameters: Swift.Equatable {
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int

        public init (
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.database = database
            self.host = host
            self.port = port
        }
    }

}

extension PreconditionNotMetException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PreconditionNotMetExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more preconditions aren't met.
public struct PreconditionNotMetException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct PreconditionNotMetExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension PreconditionNotMetExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.PrestoParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalog = "Catalog"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalog = catalog {
            try encodeContainer.encode(catalog, forKey: .catalog)
        }
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let catalogDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalog)
        catalog = catalogDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for Presto.
    public struct PrestoParameters: Swift.Equatable {
        /// Catalog.
        /// This member is required.
        public var catalog: Swift.String?
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int

        public init (
            catalog: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.catalog = catalog
            self.host = host
            self.port = port
        }
    }

}

extension QuickSightClientTypes.ProjectOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectedColumns = "ProjectedColumns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectedColumns = projectedColumns {
            var projectedColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .projectedColumns)
            for projectedcolumnlist0 in projectedColumns {
                try projectedColumnsContainer.encode(projectedcolumnlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectedColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .projectedColumns)
        var projectedColumnsDecoded0:[Swift.String]? = nil
        if let projectedColumnsContainer = projectedColumnsContainer {
            projectedColumnsDecoded0 = [Swift.String]()
            for string0 in projectedColumnsContainer {
                if let string0 = string0 {
                    projectedColumnsDecoded0?.append(string0)
                }
            }
        }
        projectedColumns = projectedColumnsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A transform operation that projects columns. Operations that come after a projection can only refer to projected columns.
    public struct ProjectOperation: Swift.Equatable {
        /// Projected columns.
        /// This member is required.
        public var projectedColumns: [Swift.String]?

        public init (
            projectedColumns: [Swift.String]? = nil
        )
        {
            self.projectedColumns = projectedColumns
        }
    }

}

extension QuickSightClientTypes.QueueInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queuedIngestion = "QueuedIngestion"
        case waitingOnIngestion = "WaitingOnIngestion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queuedIngestion = queuedIngestion {
            try encodeContainer.encode(queuedIngestion, forKey: .queuedIngestion)
        }
        if let waitingOnIngestion = waitingOnIngestion {
            try encodeContainer.encode(waitingOnIngestion, forKey: .waitingOnIngestion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waitingOnIngestionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waitingOnIngestion)
        waitingOnIngestion = waitingOnIngestionDecoded
        let queuedIngestionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queuedIngestion)
        queuedIngestion = queuedIngestionDecoded
    }
}

extension QuickSightClientTypes {
    /// Information about a queued dataset SPICE ingestion.
    public struct QueueInfo: Swift.Equatable {
        /// The ID of the ongoing ingestion. The queued ingestion is waiting for the ongoing ingestion to complete.
        /// This member is required.
        public var queuedIngestion: Swift.String?
        /// The ID of the queued ingestion.
        /// This member is required.
        public var waitingOnIngestion: Swift.String?

        public init (
            queuedIngestion: Swift.String? = nil,
            waitingOnIngestion: Swift.String? = nil
        )
        {
            self.queuedIngestion = queuedIngestion
            self.waitingOnIngestion = waitingOnIngestion
        }
    }

}

extension QuickSightUserNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: QuickSightUserNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user with the provided name isn't found. This error can happen in any operation that requires finding a user based on a provided user name, such as DeleteUser, DescribeUser, and so on.
public struct QuickSightUserNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct QuickSightUserNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension QuickSightUserNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.RdsParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for Amazon RDS.
    public struct RdsParameters: Swift.Equatable {
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Instance ID.
        /// This member is required.
        public var instanceId: Swift.String?

        public init (
            database: Swift.String? = nil,
            instanceId: Swift.String? = nil
        )
        {
            self.database = database
            self.instanceId = instanceId
        }
    }

}

extension QuickSightClientTypes.RedshiftParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for Amazon Redshift. The ClusterId field can be blank if Host and Port are both set. The Host and Port fields can be blank if the ClusterId field is set.
    public struct RedshiftParameters: Swift.Equatable {
        /// Cluster ID. This field can be blank if the Host and Port are provided.
        public var clusterId: Swift.String?
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Host. This field can be blank if ClusterId is provided.
        public var host: Swift.String?
        /// Port. This field can be blank if the ClusterId is provided.
        public var port: Swift.Int

        public init (
            clusterId: Swift.String? = nil,
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.clusterId = clusterId
            self.database = database
            self.host = host
            self.port = port
        }
    }

}

extension RegisterUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customFederationProviderUrl = "CustomFederationProviderUrl"
        case customPermissionsName = "CustomPermissionsName"
        case email = "Email"
        case externalLoginFederationProviderType = "ExternalLoginFederationProviderType"
        case externalLoginId = "ExternalLoginId"
        case iamArn = "IamArn"
        case identityType = "IdentityType"
        case sessionName = "SessionName"
        case userName = "UserName"
        case userRole = "UserRole"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customFederationProviderUrl = customFederationProviderUrl {
            try encodeContainer.encode(customFederationProviderUrl, forKey: .customFederationProviderUrl)
        }
        if let customPermissionsName = customPermissionsName {
            try encodeContainer.encode(customPermissionsName, forKey: .customPermissionsName)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let externalLoginFederationProviderType = externalLoginFederationProviderType {
            try encodeContainer.encode(externalLoginFederationProviderType, forKey: .externalLoginFederationProviderType)
        }
        if let externalLoginId = externalLoginId {
            try encodeContainer.encode(externalLoginId, forKey: .externalLoginId)
        }
        if let iamArn = iamArn {
            try encodeContainer.encode(iamArn, forKey: .iamArn)
        }
        if let identityType = identityType {
            try encodeContainer.encode(identityType.rawValue, forKey: .identityType)
        }
        if let sessionName = sessionName {
            try encodeContainer.encode(sessionName, forKey: .sessionName)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userRole = userRole {
            try encodeContainer.encode(userRole.rawValue, forKey: .userRole)
        }
    }
}

extension RegisterUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/users"
    }
}

public struct RegisterUserInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The URL of the custom OpenID Connect (OIDC) provider that provides identity to let a user federate into Amazon QuickSight with an associated Identity and Access Management(IAM) role. This parameter should only be used when ExternalLoginFederationProviderType parameter is set to CUSTOM_OIDC.
    public var customFederationProviderUrl: Swift.String?
    /// (Enterprise edition only) The name of the custom permissions profile that you want to assign to this user. Customized permissions allows you to control a user's access by restricting access the following operations:
    ///
    /// * Create and update data sources
    ///
    /// * Create and update datasets
    ///
    /// * Create and update email reports
    ///
    /// * Subscribe to email reports
    ///
    ///
    /// To add custom permissions to an existing user, use [UpdateUser](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_UpdateUser.html) instead. A set of custom permissions includes any combination of these restrictions. Currently, you need to create the profile names for custom permission sets by using the Amazon QuickSight console. Then, you use the RegisterUser API operation to assign the named set of permissions to a QuickSight user. Amazon QuickSight custom permissions are applied through IAM policies. Therefore, they override the permissions typically granted by assigning Amazon QuickSight users to one of the default security cohorts in Amazon QuickSight (admin, author, reader). This feature is available only to Amazon QuickSight Enterprise edition subscriptions.
    public var customPermissionsName: Swift.String?
    /// The email address of the user that you want to register.
    /// This member is required.
    public var email: Swift.String?
    /// The type of supported external login provider that provides identity to let a user federate into Amazon QuickSight with an associated Identity and Access Management(IAM) role. The type of supported external login provider can be one of the following.
    ///
    /// * COGNITO: Amazon Cognito. The provider URL is cognito-identity.amazonaws.com. When choosing the COGNITO provider type, dont use the "CustomFederationProviderUrl" parameter which is only needed when the external provider is custom.
    ///
    /// * CUSTOM_OIDC: Custom OpenID Connect (OIDC) provider. When choosing CUSTOM_OIDC type, use the CustomFederationProviderUrl parameter to provide the custom OIDC provider URL.
    public var externalLoginFederationProviderType: Swift.String?
    /// The identity ID for a user in the external login provider.
    public var externalLoginId: Swift.String?
    /// The ARN of the IAM user or role that you are registering with Amazon QuickSight.
    public var iamArn: Swift.String?
    /// Amazon QuickSight supports several ways of managing the identity of users. This parameter accepts two values:
    ///
    /// * IAM: A user whose identity maps to an existing IAM user or role.
    ///
    /// * QUICKSIGHT: A user whose identity is owned and managed internally by Amazon QuickSight.
    /// This member is required.
    public var identityType: QuickSightClientTypes.IdentityType?
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// You need to use this parameter only when you register one or more users using an assumed IAM role. You don't need to provide the session name for other scenarios, for example when you are registering an IAM user or an Amazon QuickSight user. You can register multiple users using the same IAM role if each user has a different session name. For more information on assuming IAM roles, see [assume-role](https://docs.aws.amazon.com/cli/latest/reference/sts/assume-role.html) in the CLI Reference.
    public var sessionName: Swift.String?
    /// The Amazon QuickSight user name that you want to create for the user you are registering.
    public var userName: Swift.String?
    /// The Amazon QuickSight role for the user. The user role can be one of the following:
    ///
    /// * READER: A user who has read-only access to dashboards.
    ///
    /// * AUTHOR: A user who can create data sources, datasets, analyses, and dashboards.
    ///
    /// * ADMIN: A user who is an author, who can also manage Amazon QuickSight settings.
    ///
    /// * RESTRICTED_READER: This role isn't currently available for use.
    ///
    /// * RESTRICTED_AUTHOR: This role isn't currently available for use.
    /// This member is required.
    public var userRole: QuickSightClientTypes.UserRole?

    public init (
        awsAccountId: Swift.String? = nil,
        customFederationProviderUrl: Swift.String? = nil,
        customPermissionsName: Swift.String? = nil,
        email: Swift.String? = nil,
        externalLoginFederationProviderType: Swift.String? = nil,
        externalLoginId: Swift.String? = nil,
        iamArn: Swift.String? = nil,
        identityType: QuickSightClientTypes.IdentityType? = nil,
        namespace: Swift.String? = nil,
        sessionName: Swift.String? = nil,
        userName: Swift.String? = nil,
        userRole: QuickSightClientTypes.UserRole? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.customFederationProviderUrl = customFederationProviderUrl
        self.customPermissionsName = customPermissionsName
        self.email = email
        self.externalLoginFederationProviderType = externalLoginFederationProviderType
        self.externalLoginId = externalLoginId
        self.iamArn = iamArn
        self.identityType = identityType
        self.namespace = namespace
        self.sessionName = sessionName
        self.userName = userName
        self.userRole = userRole
    }
}

struct RegisterUserInputBody: Swift.Equatable {
    let identityType: QuickSightClientTypes.IdentityType?
    let email: Swift.String?
    let userRole: QuickSightClientTypes.UserRole?
    let iamArn: Swift.String?
    let sessionName: Swift.String?
    let userName: Swift.String?
    let customPermissionsName: Swift.String?
    let externalLoginFederationProviderType: Swift.String?
    let customFederationProviderUrl: Swift.String?
    let externalLoginId: Swift.String?
}

extension RegisterUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customFederationProviderUrl = "CustomFederationProviderUrl"
        case customPermissionsName = "CustomPermissionsName"
        case email = "Email"
        case externalLoginFederationProviderType = "ExternalLoginFederationProviderType"
        case externalLoginId = "ExternalLoginId"
        case iamArn = "IamArn"
        case identityType = "IdentityType"
        case sessionName = "SessionName"
        case userName = "UserName"
        case userRole = "UserRole"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IdentityType.self, forKey: .identityType)
        identityType = identityTypeDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let userRoleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.UserRole.self, forKey: .userRole)
        userRole = userRoleDecoded
        let iamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamArn)
        iamArn = iamArnDecoded
        let sessionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionName)
        sessionName = sessionNameDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let customPermissionsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customPermissionsName)
        customPermissionsName = customPermissionsNameDecoded
        let externalLoginFederationProviderTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalLoginFederationProviderType)
        externalLoginFederationProviderType = externalLoginFederationProviderTypeDecoded
        let customFederationProviderUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customFederationProviderUrl)
        customFederationProviderUrl = customFederationProviderUrlDecoded
        let externalLoginIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalLoginId)
        externalLoginId = externalLoginIdDecoded
    }
}

extension RegisterUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.user = output.user
            self.userInvitationUrl = output.userInvitationUrl
        } else {
            self.requestId = nil
            self.user = nil
            self.userInvitationUrl = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct RegisterUserOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The user's user name.
    public var user: QuickSightClientTypes.User?
    /// The URL the user visits to complete registration and provide a password. This is returned only for users with an identity type of QUICKSIGHT.
    public var userInvitationUrl: Swift.String?

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        user: QuickSightClientTypes.User? = nil,
        userInvitationUrl: Swift.String? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.user = user
        self.userInvitationUrl = userInvitationUrl
    }
}

struct RegisterUserOutputResponseBody: Swift.Equatable {
    let user: QuickSightClientTypes.User?
    let userInvitationUrl: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension RegisterUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case user = "User"
        case userInvitationUrl = "UserInvitationUrl"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.User.self, forKey: .user)
        user = userDecoded
        let userInvitationUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userInvitationUrl)
        userInvitationUrl = userInvitationUrlDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension QuickSightClientTypes.RegisteredUserDashboardEmbeddingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialDashboardId = "InitialDashboardId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialDashboardId = initialDashboardId {
            try encodeContainer.encode(initialDashboardId, forKey: .initialDashboardId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialDashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialDashboardId)
        initialDashboardId = initialDashboardIdDecoded
    }
}

extension QuickSightClientTypes {
    /// Information about the dashboard you want to embed.
    public struct RegisteredUserDashboardEmbeddingConfiguration: Swift.Equatable {
        /// The dashboard ID for the dashboard that you want the user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this dashboard if the user has permissions to view it. If the user does not have permission to view this dashboard, they see a permissions error message.
        /// This member is required.
        public var initialDashboardId: Swift.String?

        public init (
            initialDashboardId: Swift.String? = nil
        )
        {
            self.initialDashboardId = initialDashboardId
        }
    }

}

extension QuickSightClientTypes.RegisteredUserEmbeddingExperienceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboard = "Dashboard"
        case qSearchBar = "QSearchBar"
        case quickSightConsole = "QuickSightConsole"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dashboard = dashboard {
            try encodeContainer.encode(dashboard, forKey: .dashboard)
        }
        if let qSearchBar = qSearchBar {
            try encodeContainer.encode(qSearchBar, forKey: .qSearchBar)
        }
        if let quickSightConsole = quickSightConsole {
            try encodeContainer.encode(quickSightConsole, forKey: .quickSightConsole)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RegisteredUserDashboardEmbeddingConfiguration.self, forKey: .dashboard)
        dashboard = dashboardDecoded
        let quickSightConsoleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RegisteredUserQuickSightConsoleEmbeddingConfiguration.self, forKey: .quickSightConsole)
        quickSightConsole = quickSightConsoleDecoded
        let qSearchBarDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RegisteredUserQSearchBarEmbeddingConfiguration.self, forKey: .qSearchBar)
        qSearchBar = qSearchBarDecoded
    }
}

extension QuickSightClientTypes {
    /// The type of experience you want to embed. For registered users, you can embed Amazon QuickSight dashboards or the Amazon QuickSight console. Exactly one of the experience configurations is required. You can choose Dashboard or QuickSightConsole. You cannot choose more than one experience configuration.
    public struct RegisteredUserEmbeddingExperienceConfiguration: Swift.Equatable {
        /// The configuration details for providing a dashboard embedding experience.
        public var dashboard: QuickSightClientTypes.RegisteredUserDashboardEmbeddingConfiguration?
        /// The configuration details for embedding the Q search bar. For more information about embedding the Q search bar, see [Embedding Overview](https://docs.aws.amazon.com/quicksight/latest/user/embedding-overview.html).
        public var qSearchBar: QuickSightClientTypes.RegisteredUserQSearchBarEmbeddingConfiguration?
        /// The configuration details for providing each Amazon QuickSight console embedding experience. This can be used along with custom permissions to restrict access to certain features. For more information, see [Customizing Access to the Amazon QuickSight Console](https://docs.aws.amazon.com/quicksight/latest/user/customizing-permissions-to-the-quicksight-console.html) in the Amazon QuickSight User Guide. Use [GenerateEmbedUrlForRegisteredUser](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_GenerateEmbedUrlForRegisteredUser.html) where you want to provide an authoring portal that allows users to create data sources, datasets, analyses, and dashboards. The users who accesses an embedded Amazon QuickSight console needs to belong to the author or admin security cohort. If you want to restrict permissions to some of these features, add a custom permissions profile to the user with the [UpdateUser](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_UpdateUser.html) API operation. Use the [RegisterUser](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_RegisterUser.html) API operation to add a new user with a custom permission profile attached. For more information, see the following sections in the Amazon QuickSight User Guide:
        ///
        /// * [Embedding the Full Functionality of the Amazon QuickSight Console for Authenticated Users](https://docs.aws.amazon.com/quicksight/latest/user/embedded-analytics-full-console-for-authenticated-users.html)
        ///
        /// * [Customizing Access to the Amazon QuickSight Console](https://docs.aws.amazon.com/quicksight/latest/user/customizing-permissions-to-the-quicksight-console.html)
        ///
        ///
        /// For more information about the high-level steps for embedding and for an interactive demo of the ways you can customize embedding, visit the [Amazon QuickSight Developer Portal](https://docs.aws.amazon.com/quicksight/latest/user/quicksight-dev-portal.html).
        public var quickSightConsole: QuickSightClientTypes.RegisteredUserQuickSightConsoleEmbeddingConfiguration?

        public init (
            dashboard: QuickSightClientTypes.RegisteredUserDashboardEmbeddingConfiguration? = nil,
            qSearchBar: QuickSightClientTypes.RegisteredUserQSearchBarEmbeddingConfiguration? = nil,
            quickSightConsole: QuickSightClientTypes.RegisteredUserQuickSightConsoleEmbeddingConfiguration? = nil
        )
        {
            self.dashboard = dashboard
            self.qSearchBar = qSearchBar
            self.quickSightConsole = quickSightConsole
        }
    }

}

extension QuickSightClientTypes.RegisteredUserQSearchBarEmbeddingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialTopicId = "InitialTopicId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialTopicId = initialTopicId {
            try encodeContainer.encode(initialTopicId, forKey: .initialTopicId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialTopicIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialTopicId)
        initialTopicId = initialTopicIdDecoded
    }
}

extension QuickSightClientTypes {
    /// Information about the Q search bar embedding experience.
    public struct RegisteredUserQSearchBarEmbeddingConfiguration: Swift.Equatable {
        /// The ID of the Q topic that you want to make the starting topic in the Q search bar. You can find a topic ID by navigating to the Topics pane in the Amazon QuickSight application and opening a topic. The ID is in the URL for the topic that you open. If you don't specify an initial topic, a list of all shared topics is shown in the Q bar for your readers. When you select an initial topic, you can specify whether or not readers are allowed to select other topics from the available ones in the list.
        public var initialTopicId: Swift.String?

        public init (
            initialTopicId: Swift.String? = nil
        )
        {
            self.initialTopicId = initialTopicId
        }
    }

}

extension QuickSightClientTypes.RegisteredUserQuickSightConsoleEmbeddingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialPath = "InitialPath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialPath = initialPath {
            try encodeContainer.encode(initialPath, forKey: .initialPath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialPath)
        initialPath = initialPathDecoded
    }
}

extension QuickSightClientTypes {
    /// Information about the Amazon QuickSight console that you want to embed.
    public struct RegisteredUserQuickSightConsoleEmbeddingConfiguration: Swift.Equatable {
        /// The initial URL path for the Amazon QuickSight console. InitialPath is required. The entry point URL is constrained to the following paths:
        ///
        /// * /start
        ///
        /// * /start/analyses
        ///
        /// * /start/dashboards
        ///
        /// * /start/favorites
        ///
        /// * /dashboards/DashboardId. DashboardId is the actual ID key from the Amazon QuickSight console URL of the dashboard.
        ///
        /// * /analyses/AnalysisId. AnalysisId is the actual ID key from the Amazon QuickSight console URL of the analysis.
        public var initialPath: Swift.String?

        public init (
            initialPath: Swift.String? = nil
        )
        {
            self.initialPath = initialPath
        }
    }

}

extension QuickSightClientTypes.RelationalTable: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalog = "Catalog"
        case dataSourceArn = "DataSourceArn"
        case inputColumns = "InputColumns"
        case name = "Name"
        case schema = "Schema"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalog = catalog {
            try encodeContainer.encode(catalog, forKey: .catalog)
        }
        if let dataSourceArn = dataSourceArn {
            try encodeContainer.encode(dataSourceArn, forKey: .dataSourceArn)
        }
        if let inputColumns = inputColumns {
            var inputColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputColumns)
            for inputcolumnlist0 in inputColumns {
                try inputColumnsContainer.encode(inputcolumnlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceArn)
        dataSourceArn = dataSourceArnDecoded
        let catalogDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalog)
        catalog = catalogDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let inputColumnsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.InputColumn?].self, forKey: .inputColumns)
        var inputColumnsDecoded0:[QuickSightClientTypes.InputColumn]? = nil
        if let inputColumnsContainer = inputColumnsContainer {
            inputColumnsDecoded0 = [QuickSightClientTypes.InputColumn]()
            for structure0 in inputColumnsContainer {
                if let structure0 = structure0 {
                    inputColumnsDecoded0?.append(structure0)
                }
            }
        }
        inputColumns = inputColumnsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A physical table type for relational data sources.
    public struct RelationalTable: Swift.Equatable {
        /// The catalog associated with a table.
        public var catalog: Swift.String?
        /// The Amazon Resource Name (ARN) for the data source.
        /// This member is required.
        public var dataSourceArn: Swift.String?
        /// The column schema of the table.
        /// This member is required.
        public var inputColumns: [QuickSightClientTypes.InputColumn]?
        /// The name of the relational table.
        /// This member is required.
        public var name: Swift.String?
        /// The schema name. This name applies to certain relational database engines.
        public var schema: Swift.String?

        public init (
            catalog: Swift.String? = nil,
            dataSourceArn: Swift.String? = nil,
            inputColumns: [QuickSightClientTypes.InputColumn]? = nil,
            name: Swift.String? = nil,
            schema: Swift.String? = nil
        )
        {
            self.catalog = catalog
            self.dataSourceArn = dataSourceArn
            self.inputColumns = inputColumns
            self.name = name
            self.schema = schema
        }
    }

}

extension QuickSightClientTypes.RenameColumnOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnName = "ColumnName"
        case newColumnName = "NewColumnName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnName = columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let newColumnName = newColumnName {
            try encodeContainer.encode(newColumnName, forKey: .newColumnName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let newColumnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newColumnName)
        newColumnName = newColumnNameDecoded
    }
}

extension QuickSightClientTypes {
    /// A transform operation that renames a column.
    public struct RenameColumnOperation: Swift.Equatable {
        /// The name of the column to be renamed.
        /// This member is required.
        public var columnName: Swift.String?
        /// The new name for the column.
        /// This member is required.
        public var newColumnName: Swift.String?

        public init (
            columnName: Swift.String? = nil,
            newColumnName: Swift.String? = nil
        )
        {
            self.columnName = columnName
            self.newColumnName = newColumnName
        }
    }

}

extension ResourceExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.requestId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource specified already exists.
public struct ResourceExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?
    /// The resource type for this request.
    public var resourceType: QuickSightClientTypes.ExceptionResourceType?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceType: QuickSightClientTypes.ExceptionResourceType? = nil
    )
    {
        self.message = message
        self.requestId = requestId
        self.resourceType = resourceType
    }
}

struct ResourceExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: QuickSightClientTypes.ExceptionResourceType?
    let requestId: Swift.String?
}

extension ResourceExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ExceptionResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.requestId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more resources can't be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?
    /// The resource type for this request.
    public var resourceType: QuickSightClientTypes.ExceptionResourceType?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceType: QuickSightClientTypes.ExceptionResourceType? = nil
    )
    {
        self.message = message
        self.requestId = requestId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: QuickSightClientTypes.ExceptionResourceType?
    let requestId: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ExceptionResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.ResourcePermission: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case principal = "Principal"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for actionlist0 in actions {
                try actionsContainer.encode(actionlist0)
            }
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .actions)
        var actionsDecoded0:[Swift.String]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension QuickSightClientTypes {
    /// Permission for the resource.
    public struct ResourcePermission: Swift.Equatable {
        /// The IAM action to grant or revoke permissions on.
        /// This member is required.
        public var actions: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the principal. This can be one of the following:
        ///
        /// * The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)
        ///
        /// * The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)
        ///
        /// * The ARN of an Amazon Web Services account root: This is an IAM ARN rather than a QuickSight ARN. Use this option only to share resources (templates) across Amazon Web Services accounts. (This is less common.)
        /// This member is required.
        public var principal: Swift.String?

        public init (
            actions: [Swift.String]? = nil,
            principal: Swift.String? = nil
        )
        {
            self.actions = actions
            self.principal = principal
        }
    }

}

extension QuickSightClientTypes {
    public enum ResourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creationFailed
        case creationInProgress
        case creationSuccessful
        case deleted
        case updateFailed
        case updateInProgress
        case updateSuccessful
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceStatus] {
            return [
                .creationFailed,
                .creationInProgress,
                .creationSuccessful,
                .deleted,
                .updateFailed,
                .updateInProgress,
                .updateSuccessful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creationFailed: return "CREATION_FAILED"
            case .creationInProgress: return "CREATION_IN_PROGRESS"
            case .creationSuccessful: return "CREATION_SUCCESSFUL"
            case .deleted: return "DELETED"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case .updateSuccessful: return "UPDATE_SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceStatus(rawValue: rawValue) ?? ResourceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResourceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.requestId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This resource is currently unavailable.
public struct ResourceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?
    /// The resource type for this request.
    public var resourceType: QuickSightClientTypes.ExceptionResourceType?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceType: QuickSightClientTypes.ExceptionResourceType? = nil
    )
    {
        self.message = message
        self.requestId = requestId
        self.resourceType = resourceType
    }
}

struct ResourceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: QuickSightClientTypes.ExceptionResourceType?
    let requestId: Swift.String?
}

extension ResourceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ExceptionResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension RestoreAnalysisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let analysisId = analysisId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/restore/analyses/\(analysisId.urlPercentEncoding())"
    }
}

public struct RestoreAnalysisInput: Swift.Equatable {
    /// The ID of the analysis that you're restoring.
    /// This member is required.
    public var analysisId: Swift.String?
    /// The ID of the Amazon Web Services account that contains the analysis.
    /// This member is required.
    public var awsAccountId: Swift.String?

    public init (
        analysisId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
    }
}

struct RestoreAnalysisInputBody: Swift.Equatable {
}

extension RestoreAnalysisInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RestoreAnalysisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestoreAnalysisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreAnalysisOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreAnalysisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RestoreAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisId = output.analysisId
            self.arn = output.arn
            self.requestId = output.requestId
        } else {
            self.analysisId = nil
            self.arn = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct RestoreAnalysisOutputResponse: Swift.Equatable {
    /// The ID of the analysis that you're restoring.
    public var analysisId: Swift.String?
    /// The Amazon Resource Name (ARN) of the analysis that you're restoring.
    public var arn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        analysisId: Swift.String? = nil,
        arn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.analysisId = analysisId
        self.arn = arn
        self.requestId = requestId
        self.status = status
    }
}

struct RestoreAnalysisOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let arn: Swift.String?
    let analysisId: Swift.String?
    let requestId: Swift.String?
}

extension RestoreAnalysisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisId = "AnalysisId"
        case arn = "Arn"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let analysisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.RowInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rowsDropped = "RowsDropped"
        case rowsIngested = "RowsIngested"
        case totalRowsInDataset = "TotalRowsInDataset"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if rowsDropped != 0 {
            try encodeContainer.encode(rowsDropped, forKey: .rowsDropped)
        }
        if rowsIngested != 0 {
            try encodeContainer.encode(rowsIngested, forKey: .rowsIngested)
        }
        if totalRowsInDataset != 0 {
            try encodeContainer.encode(totalRowsInDataset, forKey: .totalRowsInDataset)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowsIngestedDecoded = try containerValues.decode(Swift.Int.self, forKey: .rowsIngested)
        rowsIngested = rowsIngestedDecoded
        let rowsDroppedDecoded = try containerValues.decode(Swift.Int.self, forKey: .rowsDropped)
        rowsDropped = rowsDroppedDecoded
        let totalRowsInDatasetDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalRowsInDataset)
        totalRowsInDataset = totalRowsInDatasetDecoded
    }
}

extension QuickSightClientTypes {
    /// Information about rows for a data set SPICE ingestion.
    public struct RowInfo: Swift.Equatable {
        /// The number of rows that were not ingested.
        public var rowsDropped: Swift.Int
        /// The number of rows that were ingested.
        public var rowsIngested: Swift.Int
        /// The total number of rows in the dataset.
        public var totalRowsInDataset: Swift.Int

        public init (
            rowsDropped: Swift.Int = 0,
            rowsIngested: Swift.Int = 0,
            totalRowsInDataset: Swift.Int = 0
        )
        {
            self.rowsDropped = rowsDropped
            self.rowsIngested = rowsIngested
            self.totalRowsInDataset = totalRowsInDataset
        }
    }

}

extension QuickSightClientTypes.RowLevelPermissionDataSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case formatVersion = "FormatVersion"
        case namespace = "Namespace"
        case permissionPolicy = "PermissionPolicy"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let formatVersion = formatVersion {
            try encodeContainer.encode(formatVersion.rawValue, forKey: .formatVersion)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let permissionPolicy = permissionPolicy {
            try encodeContainer.encode(permissionPolicy.rawValue, forKey: .permissionPolicy)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let permissionPolicyDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RowLevelPermissionPolicy.self, forKey: .permissionPolicy)
        permissionPolicy = permissionPolicyDecoded
        let formatVersionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RowLevelPermissionFormatVersion.self, forKey: .formatVersion)
        formatVersion = formatVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

extension QuickSightClientTypes {
    /// Information about a dataset that contains permissions for row-level security (RLS). The permissions dataset maps fields to users or groups. For more information, see [Using Row-Level Security (RLS) to Restrict Access to a Dataset](https://docs.aws.amazon.com/quicksight/latest/user/restrict-access-to-a-data-set-using-row-level-security.html) in the Amazon QuickSight User Guide. The option to deny permissions by setting PermissionPolicy to DENY_ACCESS is not supported for new RLS datasets.
    public struct RowLevelPermissionDataSet: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the dataset that contains permissions for RLS.
        /// This member is required.
        public var arn: Swift.String?
        /// The user or group rules associated with the dataset that contains permissions for RLS. By default, FormatVersion is VERSION_1. When FormatVersion is VERSION_1, UserName and GroupName are required. When FormatVersion is VERSION_2, UserARN and GroupARN are required, and Namespace must not exist.
        public var formatVersion: QuickSightClientTypes.RowLevelPermissionFormatVersion?
        /// The namespace associated with the dataset that contains permissions for RLS.
        public var namespace: Swift.String?
        /// The type of permissions to use when interpreting the permissions for RLS. DENY_ACCESS is included for backward compatibility only.
        /// This member is required.
        public var permissionPolicy: QuickSightClientTypes.RowLevelPermissionPolicy?
        /// The status of the row-level security permission dataset. If enabled, the status is ENABLED. If disabled, the status is DISABLED.
        public var status: QuickSightClientTypes.Status?

        public init (
            arn: Swift.String? = nil,
            formatVersion: QuickSightClientTypes.RowLevelPermissionFormatVersion? = nil,
            namespace: Swift.String? = nil,
            permissionPolicy: QuickSightClientTypes.RowLevelPermissionPolicy? = nil,
            status: QuickSightClientTypes.Status? = nil
        )
        {
            self.arn = arn
            self.formatVersion = formatVersion
            self.namespace = namespace
            self.permissionPolicy = permissionPolicy
            self.status = status
        }
    }

}

extension QuickSightClientTypes {
    public enum RowLevelPermissionFormatVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case version1
        case version2
        case sdkUnknown(Swift.String)

        public static var allCases: [RowLevelPermissionFormatVersion] {
            return [
                .version1,
                .version2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .version1: return "VERSION_1"
            case .version2: return "VERSION_2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RowLevelPermissionFormatVersion(rawValue: rawValue) ?? RowLevelPermissionFormatVersion.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum RowLevelPermissionPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case denyAccess
        case grantAccess
        case sdkUnknown(Swift.String)

        public static var allCases: [RowLevelPermissionPolicy] {
            return [
                .denyAccess,
                .grantAccess,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .denyAccess: return "DENY_ACCESS"
            case .grantAccess: return "GRANT_ACCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RowLevelPermissionPolicy(rawValue: rawValue) ?? RowLevelPermissionPolicy.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.RowLevelPermissionTagConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case tagRules = "TagRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tagRules = tagRules {
            var tagRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagRules)
            for rowlevelpermissiontagrulelist0 in tagRules {
                try tagRulesContainer.encode(rowlevelpermissiontagrulelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let tagRulesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.RowLevelPermissionTagRule?].self, forKey: .tagRules)
        var tagRulesDecoded0:[QuickSightClientTypes.RowLevelPermissionTagRule]? = nil
        if let tagRulesContainer = tagRulesContainer {
            tagRulesDecoded0 = [QuickSightClientTypes.RowLevelPermissionTagRule]()
            for structure0 in tagRulesContainer {
                if let structure0 = structure0 {
                    tagRulesDecoded0?.append(structure0)
                }
            }
        }
        tagRules = tagRulesDecoded0
    }
}

extension QuickSightClientTypes {
    /// The configuration of tags on a dataset to set row-level security.
    public struct RowLevelPermissionTagConfiguration: Swift.Equatable {
        /// The status of row-level security tags. If enabled, the status is ENABLED. If disabled, the status is DISABLED.
        public var status: QuickSightClientTypes.Status?
        /// A set of rules associated with row-level security, such as the tag names and columns that they are assigned to.
        /// This member is required.
        public var tagRules: [QuickSightClientTypes.RowLevelPermissionTagRule]?

        public init (
            status: QuickSightClientTypes.Status? = nil,
            tagRules: [QuickSightClientTypes.RowLevelPermissionTagRule]? = nil
        )
        {
            self.status = status
            self.tagRules = tagRules
        }
    }

}

extension QuickSightClientTypes.RowLevelPermissionTagRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnName = "ColumnName"
        case matchAllValue = "MatchAllValue"
        case tagKey = "TagKey"
        case tagMultiValueDelimiter = "TagMultiValueDelimiter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnName = columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let matchAllValue = matchAllValue {
            try encodeContainer.encode(matchAllValue, forKey: .matchAllValue)
        }
        if let tagKey = tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let tagMultiValueDelimiter = tagMultiValueDelimiter {
            try encodeContainer.encode(tagMultiValueDelimiter, forKey: .tagMultiValueDelimiter)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let columnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let tagMultiValueDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagMultiValueDelimiter)
        tagMultiValueDelimiter = tagMultiValueDelimiterDecoded
        let matchAllValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .matchAllValue)
        matchAllValue = matchAllValueDecoded
    }
}

extension QuickSightClientTypes {
    /// A set of rules associated with a tag.
    public struct RowLevelPermissionTagRule: Swift.Equatable {
        /// The column name that a tag key is assigned to.
        /// This member is required.
        public var columnName: Swift.String?
        /// A string that you want to use to filter by all the values in a column in the dataset and dont want to list the values one by one. For example, you can use an asterisk as your match all value.
        public var matchAllValue: Swift.String?
        /// The unique key for a tag.
        /// This member is required.
        public var tagKey: Swift.String?
        /// A string that you want to use to delimit the values when you pass the values at run time. For example, you can delimit the values with a comma.
        public var tagMultiValueDelimiter: Swift.String?

        public init (
            columnName: Swift.String? = nil,
            matchAllValue: Swift.String? = nil,
            tagKey: Swift.String? = nil,
            tagMultiValueDelimiter: Swift.String? = nil
        )
        {
            self.columnName = columnName
            self.matchAllValue = matchAllValue
            self.tagKey = tagKey
            self.tagMultiValueDelimiter = tagMultiValueDelimiter
        }
    }

}

extension QuickSightClientTypes.S3Parameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case manifestFileLocation = "ManifestFileLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let manifestFileLocation = manifestFileLocation {
            try encodeContainer.encode(manifestFileLocation, forKey: .manifestFileLocation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestFileLocationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ManifestFileLocation.self, forKey: .manifestFileLocation)
        manifestFileLocation = manifestFileLocationDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for S3.
    public struct S3Parameters: Swift.Equatable {
        /// Location of the Amazon S3 manifest file. This is NULL if the manifest file was uploaded into Amazon QuickSight.
        /// This member is required.
        public var manifestFileLocation: QuickSightClientTypes.ManifestFileLocation?

        public init (
            manifestFileLocation: QuickSightClientTypes.ManifestFileLocation? = nil
        )
        {
            self.manifestFileLocation = manifestFileLocation
        }
    }

}

extension QuickSightClientTypes.S3Source: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceArn = "DataSourceArn"
        case inputColumns = "InputColumns"
        case uploadSettings = "UploadSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceArn = dataSourceArn {
            try encodeContainer.encode(dataSourceArn, forKey: .dataSourceArn)
        }
        if let inputColumns = inputColumns {
            var inputColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputColumns)
            for inputcolumnlist0 in inputColumns {
                try inputColumnsContainer.encode(inputcolumnlist0)
            }
        }
        if let uploadSettings = uploadSettings {
            try encodeContainer.encode(uploadSettings, forKey: .uploadSettings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceArn)
        dataSourceArn = dataSourceArnDecoded
        let uploadSettingsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.UploadSettings.self, forKey: .uploadSettings)
        uploadSettings = uploadSettingsDecoded
        let inputColumnsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.InputColumn?].self, forKey: .inputColumns)
        var inputColumnsDecoded0:[QuickSightClientTypes.InputColumn]? = nil
        if let inputColumnsContainer = inputColumnsContainer {
            inputColumnsDecoded0 = [QuickSightClientTypes.InputColumn]()
            for structure0 in inputColumnsContainer {
                if let structure0 = structure0 {
                    inputColumnsDecoded0?.append(structure0)
                }
            }
        }
        inputColumns = inputColumnsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A physical table type for an S3 data source.
    public struct S3Source: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the data source.
        /// This member is required.
        public var dataSourceArn: Swift.String?
        /// A physical table type for an S3 data source. For files that aren't JSON, only STRING data types are supported in input columns.
        /// This member is required.
        public var inputColumns: [QuickSightClientTypes.InputColumn]?
        /// Information about the format for the S3 source file or files.
        public var uploadSettings: QuickSightClientTypes.UploadSettings?

        public init (
            dataSourceArn: Swift.String? = nil,
            inputColumns: [QuickSightClientTypes.InputColumn]? = nil,
            uploadSettings: QuickSightClientTypes.UploadSettings? = nil
        )
        {
            self.dataSourceArn = dataSourceArn
            self.inputColumns = inputColumns
            self.uploadSettings = uploadSettings
        }
    }

}

extension SearchAnalysesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for analysissearchfilterlist0 in filters {
                try filtersContainer.encode(analysissearchfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchAnalysesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/search/analyses"
    }
}

public struct SearchAnalysesInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the analyses that you're searching for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The structure for the search filters that you want to apply to your search.
    /// This member is required.
    public var filters: [QuickSightClientTypes.AnalysisSearchFilter]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        filters: [QuickSightClientTypes.AnalysisSearchFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchAnalysesInputBody: Swift.Equatable {
    let filters: [QuickSightClientTypes.AnalysisSearchFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension SearchAnalysesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.AnalysisSearchFilter?].self, forKey: .filters)
        var filtersDecoded0:[QuickSightClientTypes.AnalysisSearchFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [QuickSightClientTypes.AnalysisSearchFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchAnalysesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchAnalysesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchAnalysesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchAnalysesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchAnalysesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisSummaryList = output.analysisSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.analysisSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct SearchAnalysesOutputResponse: Swift.Equatable {
    /// Metadata describing the analyses that you searched for.
    public var analysisSummaryList: [QuickSightClientTypes.AnalysisSummary]?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        analysisSummaryList: [QuickSightClientTypes.AnalysisSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.analysisSummaryList = analysisSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct SearchAnalysesOutputResponseBody: Swift.Equatable {
    let analysisSummaryList: [QuickSightClientTypes.AnalysisSummary]?
    let nextToken: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension SearchAnalysesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisSummaryList = "AnalysisSummaryList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisSummaryListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.AnalysisSummary?].self, forKey: .analysisSummaryList)
        var analysisSummaryListDecoded0:[QuickSightClientTypes.AnalysisSummary]? = nil
        if let analysisSummaryListContainer = analysisSummaryListContainer {
            analysisSummaryListDecoded0 = [QuickSightClientTypes.AnalysisSummary]()
            for structure0 in analysisSummaryListContainer {
                if let structure0 = structure0 {
                    analysisSummaryListDecoded0?.append(structure0)
                }
            }
        }
        analysisSummaryList = analysisSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension SearchDashboardsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for dashboardsearchfilterlist0 in filters {
                try filtersContainer.encode(dashboardsearchfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchDashboardsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/search/dashboards"
    }
}

public struct SearchDashboardsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the user whose dashboards you're searching for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The filters to apply to the search. Currently, you can search only by user name, for example, "Filters": [ { "Name": "QUICKSIGHT_USER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1" } ]
    /// This member is required.
    public var filters: [QuickSightClientTypes.DashboardSearchFilter]?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        filters: [QuickSightClientTypes.DashboardSearchFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchDashboardsInputBody: Swift.Equatable {
    let filters: [QuickSightClientTypes.DashboardSearchFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension SearchDashboardsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DashboardSearchFilter?].self, forKey: .filters)
        var filtersDecoded0:[QuickSightClientTypes.DashboardSearchFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [QuickSightClientTypes.DashboardSearchFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchDashboardsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchDashboardsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchDashboardsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchDashboardsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchDashboardsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dashboardSummaryList = output.dashboardSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.dashboardSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct SearchDashboardsOutputResponse: Swift.Equatable {
    /// The list of dashboards owned by the user specified in Filters in your request.
    public var dashboardSummaryList: [QuickSightClientTypes.DashboardSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dashboardSummaryList: [QuickSightClientTypes.DashboardSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dashboardSummaryList = dashboardSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct SearchDashboardsOutputResponseBody: Swift.Equatable {
    let dashboardSummaryList: [QuickSightClientTypes.DashboardSummary]?
    let nextToken: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension SearchDashboardsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardSummaryList = "DashboardSummaryList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardSummaryListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DashboardSummary?].self, forKey: .dashboardSummaryList)
        var dashboardSummaryListDecoded0:[QuickSightClientTypes.DashboardSummary]? = nil
        if let dashboardSummaryListContainer = dashboardSummaryListContainer {
            dashboardSummaryListDecoded0 = [QuickSightClientTypes.DashboardSummary]()
            for structure0 in dashboardSummaryListContainer {
                if let structure0 = structure0 {
                    dashboardSummaryListDecoded0?.append(structure0)
                }
            }
        }
        dashboardSummaryList = dashboardSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension SearchFoldersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for foldersearchfilterlist0 in filters {
                try filtersContainer.encode(foldersearchfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchFoldersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/search/folders"
    }
}

public struct SearchFoldersInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The filters to apply to the search. Currently, you can search only by the parent folder ARN. For example, "Filters": [ { "Name": "PARENT_FOLDER_ARN", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:folder/folderId" } ].
    /// This member is required.
    public var filters: [QuickSightClientTypes.FolderSearchFilter]?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        filters: [QuickSightClientTypes.FolderSearchFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchFoldersInputBody: Swift.Equatable {
    let filters: [QuickSightClientTypes.FolderSearchFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension SearchFoldersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FolderSearchFilter?].self, forKey: .filters)
        var filtersDecoded0:[QuickSightClientTypes.FolderSearchFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [QuickSightClientTypes.FolderSearchFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchFoldersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchFoldersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchFoldersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchFoldersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchFoldersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.folderSummaryList = output.folderSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.folderSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct SearchFoldersOutputResponse: Swift.Equatable {
    /// A structure that contains all of the folders in the Amazon Web Services account. This structure provides basic information about the folders.
    public var folderSummaryList: [QuickSightClientTypes.FolderSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        folderSummaryList: [QuickSightClientTypes.FolderSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.folderSummaryList = folderSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct SearchFoldersOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let folderSummaryList: [QuickSightClientTypes.FolderSummary]?
    let nextToken: Swift.String?
    let requestId: Swift.String?
}

extension SearchFoldersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case folderSummaryList = "FolderSummaryList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let folderSummaryListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FolderSummary?].self, forKey: .folderSummaryList)
        var folderSummaryListDecoded0:[QuickSightClientTypes.FolderSummary]? = nil
        if let folderSummaryListContainer = folderSummaryListContainer {
            folderSummaryListDecoded0 = [QuickSightClientTypes.FolderSummary]()
            for structure0 in folderSummaryListContainer {
                if let structure0 = structure0 {
                    folderSummaryListDecoded0?.append(structure0)
                }
            }
        }
        folderSummaryList = folderSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.ServiceNowParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case siteBaseUrl = "SiteBaseUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let siteBaseUrl = siteBaseUrl {
            try encodeContainer.encode(siteBaseUrl, forKey: .siteBaseUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteBaseUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteBaseUrl)
        siteBaseUrl = siteBaseUrlDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for ServiceNow.
    public struct ServiceNowParameters: Swift.Equatable {
        /// URL of the base site.
        /// This member is required.
        public var siteBaseUrl: Swift.String?

        public init (
            siteBaseUrl: Swift.String? = nil
        )
        {
            self.siteBaseUrl = siteBaseUrl
        }
    }

}

extension SessionLifetimeInMinutesInvalidException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SessionLifetimeInMinutesInvalidExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of minutes specified for the lifetime of a session isn't valid. The session lifetime must be 15-600 minutes.
public struct SessionLifetimeInMinutesInvalidException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct SessionLifetimeInMinutesInvalidExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension SessionLifetimeInMinutesInvalidExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.SessionTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension QuickSightClientTypes {
    /// The key-value pair used for the row-level security tags feature.
    public struct SessionTag: Swift.Equatable {
        /// The key for the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value that you want to assign the tag.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension QuickSightClientTypes.Sheet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case sheetId = "SheetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sheetId = sheetId {
            try encodeContainer.encode(sheetId, forKey: .sheetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sheetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sheetId)
        sheetId = sheetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension QuickSightClientTypes {
    /// A sheet, which is an object that contains a set of visuals that are viewed together on one page in Amazon QuickSight. Every analysis and dashboard contains at least one sheet. Each sheet contains at least one visualization widget, for example a chart, pivot table, or narrative insight. Sheets can be associated with other components, such as controls, filters, and so on.
    public struct Sheet: Swift.Equatable {
        /// The name of a sheet. This name is displayed on the sheet's tab in the Amazon QuickSight console.
        public var name: Swift.String?
        /// The unique identifier associated with a sheet.
        public var sheetId: Swift.String?

        public init (
            name: Swift.String? = nil,
            sheetId: Swift.String? = nil
        )
        {
            self.name = name
            self.sheetId = sheetId
        }
    }

}

extension QuickSightClientTypes.SheetControlsOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case visibilityState = "VisibilityState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let visibilityState = visibilityState {
            try encodeContainer.encode(visibilityState.rawValue, forKey: .visibilityState)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityStateDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardUIState.self, forKey: .visibilityState)
        visibilityState = visibilityStateDecoded
    }
}

extension QuickSightClientTypes {
    /// Sheet controls option.
    public struct SheetControlsOption: Swift.Equatable {
        /// Visibility state.
        public var visibilityState: QuickSightClientTypes.DashboardUIState?

        public init (
            visibilityState: QuickSightClientTypes.DashboardUIState? = nil
        )
        {
            self.visibilityState = visibilityState
        }
    }

}

extension QuickSightClientTypes.SheetStyle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tile = "Tile"
        case tileLayout = "TileLayout"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tile = tile {
            try encodeContainer.encode(tile, forKey: .tile)
        }
        if let tileLayout = tileLayout {
            try encodeContainer.encode(tileLayout, forKey: .tileLayout)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tileDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TileStyle.self, forKey: .tile)
        tile = tileDecoded
        let tileLayoutDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TileLayoutStyle.self, forKey: .tileLayout)
        tileLayout = tileLayoutDecoded
    }
}

extension QuickSightClientTypes {
    /// The theme display options for sheets.
    public struct SheetStyle: Swift.Equatable {
        /// The display options for tiles.
        public var tile: QuickSightClientTypes.TileStyle?
        /// The layout options for tiles.
        public var tileLayout: QuickSightClientTypes.TileLayoutStyle?

        public init (
            tile: QuickSightClientTypes.TileStyle? = nil,
            tileLayout: QuickSightClientTypes.TileLayoutStyle? = nil
        )
        {
            self.tile = tile
            self.tileLayout = tileLayout
        }
    }

}

extension QuickSightClientTypes.SnowflakeParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case host = "Host"
        case warehouse = "Warehouse"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if let warehouse = warehouse {
            try encodeContainer.encode(warehouse, forKey: .warehouse)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let warehouseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .warehouse)
        warehouse = warehouseDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for Snowflake.
    public struct SnowflakeParameters: Swift.Equatable {
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Warehouse.
        /// This member is required.
        public var warehouse: Swift.String?

        public init (
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            warehouse: Swift.String? = nil
        )
        {
            self.database = database
            self.host = host
            self.warehouse = warehouse
        }
    }

}

extension QuickSightClientTypes.SparkParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for Spark.
    public struct SparkParameters: Swift.Equatable {
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int

        public init (
            host: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.host = host
            self.port = port
        }
    }

}

extension QuickSightClientTypes.SqlServerParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for SQL Server.
    public struct SqlServerParameters: Swift.Equatable {
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int

        public init (
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.database = database
            self.host = host
            self.port = port
        }
    }

}

extension QuickSightClientTypes.SslProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disableSsl = "DisableSsl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if disableSsl != false {
            try encodeContainer.encode(disableSsl, forKey: .disableSsl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disableSslDecoded = try containerValues.decode(Swift.Bool.self, forKey: .disableSsl)
        disableSsl = disableSslDecoded
    }
}

extension QuickSightClientTypes {
    /// Secure Socket Layer (SSL) properties that apply when Amazon QuickSight connects to your underlying data source.
    public struct SslProperties: Swift.Equatable {
        /// A Boolean option to control whether SSL should be disabled.
        public var disableSsl: Swift.Bool

        public init (
            disableSsl: Swift.Bool = false
        )
        {
            self.disableSsl = disableSsl
        }
    }

}

extension QuickSightClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.StringParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for stringlist0 in values {
                try valuesContainer.encode(stringlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension QuickSightClientTypes {
    /// A string parameter.
    public struct StringParameter: Swift.Equatable {
        /// A display name for a string parameter.
        /// This member is required.
        public var name: Swift.String?
        /// The values of a string parameter.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension QuickSightClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension QuickSightClientTypes {
    /// The key or keys of the key-value pairs for the resource tag or tags assigned to the resource.
    public struct Tag: Swift.Equatable {
        /// Tag key.
        /// This member is required.
        public var key: Swift.String?
        /// Tag value.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension QuickSightClientTypes.TagColumnOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnName = "ColumnName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnName = columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for columntaglist0 in tags {
                try tagsContainer.encode(columntaglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnTag?].self, forKey: .tags)
        var tagsDecoded0:[QuickSightClientTypes.ColumnTag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QuickSightClientTypes.ColumnTag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A transform operation that tags a column with additional information.
    public struct TagColumnOperation: Swift.Equatable {
        /// The column that this operation acts on.
        /// This member is required.
        public var columnName: Swift.String?
        /// The dataset column tag, currently only used for geospatial type tagging. This is not tags for the Amazon Web Services tagging feature.
        /// This member is required.
        public var tags: [QuickSightClientTypes.ColumnTag]?

        public init (
            columnName: Swift.String? = nil,
            tags: [QuickSightClientTypes.ColumnTag]? = nil
        )
        {
            self.columnName = columnName
            self.tags = tags
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/resources/\(resourceArn.urlPercentEncoding())/tags"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.
    /// This member is required.
    public var tags: [QuickSightClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [QuickSightClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QuickSightClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QuickSightClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TagResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct TagResourceOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let status: Swift.Int
}

extension TagResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension QuickSightClientTypes.Template: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case templateId = "TemplateId"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let templateId = templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TemplateVersion.self, forKey: .version)
        version = versionDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension QuickSightClientTypes {
    /// A template object. A template is an entity in Amazon QuickSight that encapsulates the metadata required to create an analysis and that you can use to create a dashboard. A template adds a layer of abstraction by using placeholders to replace the dataset associated with an analysis. You can use templates to create dashboards by replacing dataset placeholders with datasets that follow the same schema that was used to create the source analysis and template. You can share templates across Amazon Web Services accounts by allowing users in other Amazon Web Services accounts to create a template or a dashboard from an existing template.
    public struct Template: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the template.
        public var arn: Swift.String?
        /// Time when this was created.
        public var createdTime: ClientRuntime.Date?
        /// Time when this was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The display name of the template.
        public var name: Swift.String?
        /// The ID for the template. This is unique per Amazon Web Services Region for each Amazon Web Services account.
        public var templateId: Swift.String?
        /// A structure describing the versions of the template.
        public var version: QuickSightClientTypes.TemplateVersion?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            templateId: Swift.String? = nil,
            version: QuickSightClientTypes.TemplateVersion? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.templateId = templateId
            self.version = version
        }
    }

}

extension QuickSightClientTypes.TemplateAlias: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasName = "AliasName"
        case arn = "Arn"
        case templateVersionNumber = "TemplateVersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasName = aliasName {
            try encodeContainer.encode(aliasName, forKey: .aliasName)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let templateVersionNumber = templateVersionNumber {
            try encodeContainer.encode(templateVersionNumber, forKey: .templateVersionNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasName)
        aliasName = aliasNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let templateVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .templateVersionNumber)
        templateVersionNumber = templateVersionNumberDecoded
    }
}

extension QuickSightClientTypes {
    /// The template alias.
    public struct TemplateAlias: Swift.Equatable {
        /// The display name of the template alias.
        public var aliasName: Swift.String?
        /// The Amazon Resource Name (ARN) of the template alias.
        public var arn: Swift.String?
        /// The version number of the template alias.
        public var templateVersionNumber: Swift.Int?

        public init (
            aliasName: Swift.String? = nil,
            arn: Swift.String? = nil,
            templateVersionNumber: Swift.Int? = nil
        )
        {
            self.aliasName = aliasName
            self.arn = arn
            self.templateVersionNumber = templateVersionNumber
        }
    }

}

extension QuickSightClientTypes.TemplateError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TemplateErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QuickSightClientTypes {
    /// List of errors that occurred when the template version creation failed.
    public struct TemplateError: Swift.Equatable {
        /// Description of the error type.
        public var message: Swift.String?
        /// Type of error.
        public var type: QuickSightClientTypes.TemplateErrorType?

        public init (
            message: Swift.String? = nil,
            type: QuickSightClientTypes.TemplateErrorType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }

}

extension QuickSightClientTypes {
    public enum TemplateErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case dataSetNotFound
        case internalFailure
        case sourceNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [TemplateErrorType] {
            return [
                .accessDenied,
                .dataSetNotFound,
                .internalFailure,
                .sourceNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .dataSetNotFound: return "DATA_SET_NOT_FOUND"
            case .internalFailure: return "INTERNAL_FAILURE"
            case .sourceNotFound: return "SOURCE_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TemplateErrorType(rawValue: rawValue) ?? TemplateErrorType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.TemplateSourceAnalysis: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case dataSetReferences = "DataSetReferences"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dataSetReferences = dataSetReferences {
            var dataSetReferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSetReferences)
            for datasetreferencelist0 in dataSetReferences {
                try dataSetReferencesContainer.encode(datasetreferencelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let dataSetReferencesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataSetReference?].self, forKey: .dataSetReferences)
        var dataSetReferencesDecoded0:[QuickSightClientTypes.DataSetReference]? = nil
        if let dataSetReferencesContainer = dataSetReferencesContainer {
            dataSetReferencesDecoded0 = [QuickSightClientTypes.DataSetReference]()
            for structure0 in dataSetReferencesContainer {
                if let structure0 = structure0 {
                    dataSetReferencesDecoded0?.append(structure0)
                }
            }
        }
        dataSetReferences = dataSetReferencesDecoded0
    }
}

extension QuickSightClientTypes {
    /// The source analysis of the template.
    public struct TemplateSourceAnalysis: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        /// This member is required.
        public var arn: Swift.String?
        /// A structure containing information about the dataset references used as placeholders in the template.
        /// This member is required.
        public var dataSetReferences: [QuickSightClientTypes.DataSetReference]?

        public init (
            arn: Swift.String? = nil,
            dataSetReferences: [QuickSightClientTypes.DataSetReference]? = nil
        )
        {
            self.arn = arn
            self.dataSetReferences = dataSetReferences
        }
    }

}

extension QuickSightClientTypes.TemplateSourceEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceAnalysis = "SourceAnalysis"
        case sourceTemplate = "SourceTemplate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceAnalysis = sourceAnalysis {
            try encodeContainer.encode(sourceAnalysis, forKey: .sourceAnalysis)
        }
        if let sourceTemplate = sourceTemplate {
            try encodeContainer.encode(sourceTemplate, forKey: .sourceTemplate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceAnalysisDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TemplateSourceAnalysis.self, forKey: .sourceAnalysis)
        sourceAnalysis = sourceAnalysisDecoded
        let sourceTemplateDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TemplateSourceTemplate.self, forKey: .sourceTemplate)
        sourceTemplate = sourceTemplateDecoded
    }
}

extension QuickSightClientTypes {
    /// The source entity of the template.
    public struct TemplateSourceEntity: Swift.Equatable {
        /// The source analysis, if it is based on an analysis.
        public var sourceAnalysis: QuickSightClientTypes.TemplateSourceAnalysis?
        /// The source template, if it is based on an template.
        public var sourceTemplate: QuickSightClientTypes.TemplateSourceTemplate?

        public init (
            sourceAnalysis: QuickSightClientTypes.TemplateSourceAnalysis? = nil,
            sourceTemplate: QuickSightClientTypes.TemplateSourceTemplate? = nil
        )
        {
            self.sourceAnalysis = sourceAnalysis
            self.sourceTemplate = sourceTemplate
        }
    }

}

extension QuickSightClientTypes.TemplateSourceTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension QuickSightClientTypes {
    /// The source template of the template.
    public struct TemplateSourceTemplate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        /// This member is required.
        public var arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension QuickSightClientTypes.TemplateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case latestVersionNumber = "LatestVersionNumber"
        case name = "Name"
        case templateId = "TemplateId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let latestVersionNumber = latestVersionNumber {
            try encodeContainer.encode(latestVersionNumber, forKey: .latestVersionNumber)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let templateId = templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let latestVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .latestVersionNumber)
        latestVersionNumber = latestVersionNumberDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension QuickSightClientTypes {
    /// The template summary.
    public struct TemplateSummary: Swift.Equatable {
        /// A summary of a template.
        public var arn: Swift.String?
        /// The last time that this template was created.
        public var createdTime: ClientRuntime.Date?
        /// The last time that this template was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// A structure containing a list of version numbers for the template summary.
        public var latestVersionNumber: Swift.Int?
        /// A display name for the template.
        public var name: Swift.String?
        /// The ID of the template. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public var templateId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            latestVersionNumber: Swift.Int? = nil,
            name: Swift.String? = nil,
            templateId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.latestVersionNumber = latestVersionNumber
            self.name = name
            self.templateId = templateId
        }
    }

}

extension QuickSightClientTypes.TemplateVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case dataSetConfigurations = "DataSetConfigurations"
        case description = "Description"
        case errors = "Errors"
        case sheets = "Sheets"
        case sourceEntityArn = "SourceEntityArn"
        case status = "Status"
        case themeArn = "ThemeArn"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let dataSetConfigurations = dataSetConfigurations {
            var dataSetConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSetConfigurations)
            for datasetconfigurationlist0 in dataSetConfigurations {
                try dataSetConfigurationsContainer.encode(datasetconfigurationlist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for templateerrorlist0 in errors {
                try errorsContainer.encode(templateerrorlist0)
            }
        }
        if let sheets = sheets {
            var sheetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sheets)
            for sheetlist0 in sheets {
                try sheetsContainer.encode(sheetlist0)
            }
        }
        if let sourceEntityArn = sourceEntityArn {
            try encodeContainer.encode(sourceEntityArn, forKey: .sourceEntityArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let themeArn = themeArn {
            try encodeContainer.encode(themeArn, forKey: .themeArn)
        }
        if let versionNumber = versionNumber {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let errorsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.TemplateError?].self, forKey: .errors)
        var errorsDecoded0:[QuickSightClientTypes.TemplateError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [QuickSightClientTypes.TemplateError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let dataSetConfigurationsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataSetConfiguration?].self, forKey: .dataSetConfigurations)
        var dataSetConfigurationsDecoded0:[QuickSightClientTypes.DataSetConfiguration]? = nil
        if let dataSetConfigurationsContainer = dataSetConfigurationsContainer {
            dataSetConfigurationsDecoded0 = [QuickSightClientTypes.DataSetConfiguration]()
            for structure0 in dataSetConfigurationsContainer {
                if let structure0 = structure0 {
                    dataSetConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        dataSetConfigurations = dataSetConfigurationsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceEntityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceEntityArn)
        sourceEntityArn = sourceEntityArnDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
        let sheetsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Sheet?].self, forKey: .sheets)
        var sheetsDecoded0:[QuickSightClientTypes.Sheet]? = nil
        if let sheetsContainer = sheetsContainer {
            sheetsDecoded0 = [QuickSightClientTypes.Sheet]()
            for structure0 in sheetsContainer {
                if let structure0 = structure0 {
                    sheetsDecoded0?.append(structure0)
                }
            }
        }
        sheets = sheetsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A version of a template.
    public struct TemplateVersion: Swift.Equatable {
        /// The time that this template version was created.
        public var createdTime: ClientRuntime.Date?
        /// Schema of the dataset identified by the placeholder. Any dashboard created from this template should be bound to new datasets matching the same schema described through this API operation.
        public var dataSetConfigurations: [QuickSightClientTypes.DataSetConfiguration]?
        /// The description of the template.
        public var description: Swift.String?
        /// Errors associated with this template version.
        public var errors: [QuickSightClientTypes.TemplateError]?
        /// A list of the associated sheets with the unique identifier and name of each sheet.
        public var sheets: [QuickSightClientTypes.Sheet]?
        /// The Amazon Resource Name (ARN) of an analysis or template that was used to create this template.
        public var sourceEntityArn: Swift.String?
        /// The HTTP status of the request.
        public var status: QuickSightClientTypes.ResourceStatus?
        /// The ARN of the theme associated with this version of the template.
        public var themeArn: Swift.String?
        /// The version number of the template version.
        public var versionNumber: Swift.Int?

        public init (
            createdTime: ClientRuntime.Date? = nil,
            dataSetConfigurations: [QuickSightClientTypes.DataSetConfiguration]? = nil,
            description: Swift.String? = nil,
            errors: [QuickSightClientTypes.TemplateError]? = nil,
            sheets: [QuickSightClientTypes.Sheet]? = nil,
            sourceEntityArn: Swift.String? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil,
            themeArn: Swift.String? = nil,
            versionNumber: Swift.Int? = nil
        )
        {
            self.createdTime = createdTime
            self.dataSetConfigurations = dataSetConfigurations
            self.description = description
            self.errors = errors
            self.sheets = sheets
            self.sourceEntityArn = sourceEntityArn
            self.status = status
            self.themeArn = themeArn
            self.versionNumber = versionNumber
        }
    }

}

extension QuickSightClientTypes.TemplateVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case status = "Status"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let versionNumber = versionNumber {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension QuickSightClientTypes {
    /// The template version.
    public struct TemplateVersionSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the template version.
        public var arn: Swift.String?
        /// The time that this template version was created.
        public var createdTime: ClientRuntime.Date?
        /// The description of the template version.
        public var description: Swift.String?
        /// The status of the template version.
        public var status: QuickSightClientTypes.ResourceStatus?
        /// The version number of the template version.
        public var versionNumber: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil,
            versionNumber: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.status = status
            self.versionNumber = versionNumber
        }
    }

}

extension QuickSightClientTypes.TeradataParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for Teradata.
    public struct TeradataParameters: Swift.Equatable {
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int

        public init (
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.database = database
            self.host = host
            self.port = port
        }
    }

}

extension QuickSightClientTypes {
    public enum TextQualifier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case doubleQuote
        case singleQuote
        case sdkUnknown(Swift.String)

        public static var allCases: [TextQualifier] {
            return [
                .doubleQuote,
                .singleQuote,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .doubleQuote: return "DOUBLE_QUOTE"
            case .singleQuote: return "SINGLE_QUOTE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TextQualifier(rawValue: rawValue) ?? TextQualifier.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.Theme: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case themeId = "ThemeId"
        case type = "Type"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let themeId = themeId {
            try encodeContainer.encode(themeId, forKey: .themeId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let themeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeId)
        themeId = themeIdDecoded
        let versionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ThemeVersion.self, forKey: .version)
        version = versionDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ThemeType.self, forKey: .type)
        type = typeDecoded
    }
}

extension QuickSightClientTypes {
    /// Summary information about a theme.
    public struct Theme: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the theme.
        public var arn: Swift.String?
        /// The date and time that the theme was created.
        public var createdTime: ClientRuntime.Date?
        /// The date and time that the theme was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name that the user gives to the theme.
        public var name: Swift.String?
        /// The identifier that the user gives to the theme.
        public var themeId: Swift.String?
        /// The type of theme, based on how it was created. Valid values include: QUICKSIGHT and CUSTOM.
        public var type: QuickSightClientTypes.ThemeType?
        /// A version of a theme.
        public var version: QuickSightClientTypes.ThemeVersion?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            themeId: Swift.String? = nil,
            type: QuickSightClientTypes.ThemeType? = nil,
            version: QuickSightClientTypes.ThemeVersion? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.themeId = themeId
            self.type = type
            self.version = version
        }
    }

}

extension QuickSightClientTypes.ThemeAlias: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasName = "AliasName"
        case arn = "Arn"
        case themeVersionNumber = "ThemeVersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasName = aliasName {
            try encodeContainer.encode(aliasName, forKey: .aliasName)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let themeVersionNumber = themeVersionNumber {
            try encodeContainer.encode(themeVersionNumber, forKey: .themeVersionNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let aliasNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasName)
        aliasName = aliasNameDecoded
        let themeVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .themeVersionNumber)
        themeVersionNumber = themeVersionNumberDecoded
    }
}

extension QuickSightClientTypes {
    /// An alias for a theme.
    public struct ThemeAlias: Swift.Equatable {
        /// The display name of the theme alias.
        public var aliasName: Swift.String?
        /// The Amazon Resource Name (ARN) of the theme alias.
        public var arn: Swift.String?
        /// The version number of the theme alias.
        public var themeVersionNumber: Swift.Int?

        public init (
            aliasName: Swift.String? = nil,
            arn: Swift.String? = nil,
            themeVersionNumber: Swift.Int? = nil
        )
        {
            self.aliasName = aliasName
            self.arn = arn
            self.themeVersionNumber = themeVersionNumber
        }
    }

}

extension QuickSightClientTypes.ThemeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataColorPalette = "DataColorPalette"
        case sheet = "Sheet"
        case uIColorPalette = "UIColorPalette"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataColorPalette = dataColorPalette {
            try encodeContainer.encode(dataColorPalette, forKey: .dataColorPalette)
        }
        if let sheet = sheet {
            try encodeContainer.encode(sheet, forKey: .sheet)
        }
        if let uIColorPalette = uIColorPalette {
            try encodeContainer.encode(uIColorPalette, forKey: .uIColorPalette)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataColorPaletteDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataColorPalette.self, forKey: .dataColorPalette)
        dataColorPalette = dataColorPaletteDecoded
        let uIColorPaletteDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.UIColorPalette.self, forKey: .uIColorPalette)
        uIColorPalette = uIColorPaletteDecoded
        let sheetDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SheetStyle.self, forKey: .sheet)
        sheet = sheetDecoded
    }
}

extension QuickSightClientTypes {
    /// The theme configuration. This configuration contains all of the display properties for a theme.
    public struct ThemeConfiguration: Swift.Equatable {
        /// Color properties that apply to chart data colors.
        public var dataColorPalette: QuickSightClientTypes.DataColorPalette?
        /// Display options related to sheets.
        public var sheet: QuickSightClientTypes.SheetStyle?
        /// Color properties that apply to the UI and to charts, excluding the colors that apply to data.
        public var uIColorPalette: QuickSightClientTypes.UIColorPalette?

        public init (
            dataColorPalette: QuickSightClientTypes.DataColorPalette? = nil,
            sheet: QuickSightClientTypes.SheetStyle? = nil,
            uIColorPalette: QuickSightClientTypes.UIColorPalette? = nil
        )
        {
            self.dataColorPalette = dataColorPalette
            self.sheet = sheet
            self.uIColorPalette = uIColorPalette
        }
    }

}

extension QuickSightClientTypes.ThemeError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ThemeErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QuickSightClientTypes {
    /// Theme error.
    public struct ThemeError: Swift.Equatable {
        /// The error message.
        public var message: Swift.String?
        /// The type of error.
        public var type: QuickSightClientTypes.ThemeErrorType?

        public init (
            message: Swift.String? = nil,
            type: QuickSightClientTypes.ThemeErrorType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }

}

extension QuickSightClientTypes {
    public enum ThemeErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [ThemeErrorType] {
            return [
                .internalFailure,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalFailure: return "INTERNAL_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThemeErrorType(rawValue: rawValue) ?? ThemeErrorType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.ThemeSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case latestVersionNumber = "LatestVersionNumber"
        case name = "Name"
        case themeId = "ThemeId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let latestVersionNumber = latestVersionNumber {
            try encodeContainer.encode(latestVersionNumber, forKey: .latestVersionNumber)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let themeId = themeId {
            try encodeContainer.encode(themeId, forKey: .themeId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let themeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeId)
        themeId = themeIdDecoded
        let latestVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .latestVersionNumber)
        latestVersionNumber = latestVersionNumberDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension QuickSightClientTypes {
    /// The theme summary.
    public struct ThemeSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// The date and time that this theme was created.
        public var createdTime: ClientRuntime.Date?
        /// The last date and time that this theme was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The latest version number for the theme.
        public var latestVersionNumber: Swift.Int?
        /// the display name for the theme.
        public var name: Swift.String?
        /// The ID of the theme. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public var themeId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            latestVersionNumber: Swift.Int? = nil,
            name: Swift.String? = nil,
            themeId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.latestVersionNumber = latestVersionNumber
            self.name = name
            self.themeId = themeId
        }
    }

}

extension QuickSightClientTypes {
    public enum ThemeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case custom
        case quicksight
        case sdkUnknown(Swift.String)

        public static var allCases: [ThemeType] {
            return [
                .all,
                .custom,
                .quicksight,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .custom: return "CUSTOM"
            case .quicksight: return "QUICKSIGHT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThemeType(rawValue: rawValue) ?? ThemeType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.ThemeVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case baseThemeId = "BaseThemeId"
        case configuration = "Configuration"
        case createdTime = "CreatedTime"
        case description = "Description"
        case errors = "Errors"
        case status = "Status"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let baseThemeId = baseThemeId {
            try encodeContainer.encode(baseThemeId, forKey: .baseThemeId)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for themeerrorlist0 in errors {
                try errorsContainer.encode(themeerrorlist0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let versionNumber = versionNumber {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let baseThemeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseThemeId)
        baseThemeId = baseThemeIdDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ThemeConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let errorsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ThemeError?].self, forKey: .errors)
        var errorsDecoded0:[QuickSightClientTypes.ThemeError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [QuickSightClientTypes.ThemeError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension QuickSightClientTypes {
    /// A version of a theme.
    public struct ThemeVersion: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// The Amazon QuickSight-defined ID of the theme that a custom theme inherits from. All themes initially inherit from a default Amazon QuickSight theme.
        public var baseThemeId: Swift.String?
        /// The theme configuration, which contains all the theme display properties.
        public var configuration: QuickSightClientTypes.ThemeConfiguration?
        /// The date and time that this theme version was created.
        public var createdTime: ClientRuntime.Date?
        /// The description of the theme.
        public var description: Swift.String?
        /// Errors associated with the theme.
        public var errors: [QuickSightClientTypes.ThemeError]?
        /// The status of the theme version.
        public var status: QuickSightClientTypes.ResourceStatus?
        /// The version number of the theme.
        public var versionNumber: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            baseThemeId: Swift.String? = nil,
            configuration: QuickSightClientTypes.ThemeConfiguration? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            errors: [QuickSightClientTypes.ThemeError]? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil,
            versionNumber: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.baseThemeId = baseThemeId
            self.configuration = configuration
            self.createdTime = createdTime
            self.description = description
            self.errors = errors
            self.status = status
            self.versionNumber = versionNumber
        }
    }

}

extension QuickSightClientTypes.ThemeVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case status = "Status"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let versionNumber = versionNumber {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension QuickSightClientTypes {
    /// The theme version.
    public struct ThemeVersionSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the theme version.
        public var arn: Swift.String?
        /// The date and time that this theme version was created.
        public var createdTime: ClientRuntime.Date?
        /// The description of the theme version.
        public var description: Swift.String?
        /// The status of the theme version.
        public var status: QuickSightClientTypes.ResourceStatus?
        /// The version number of the theme version.
        public var versionNumber: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil,
            versionNumber: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.status = status
            self.versionNumber = versionNumber
        }
    }

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Access is throttled.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.TileLayoutStyle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gutter = "Gutter"
        case margin = "Margin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gutter = gutter {
            try encodeContainer.encode(gutter, forKey: .gutter)
        }
        if let margin = margin {
            try encodeContainer.encode(margin, forKey: .margin)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gutterDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GutterStyle.self, forKey: .gutter)
        gutter = gutterDecoded
        let marginDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.MarginStyle.self, forKey: .margin)
        margin = marginDecoded
    }
}

extension QuickSightClientTypes {
    /// The display options for the layout of tiles on a sheet.
    public struct TileLayoutStyle: Swift.Equatable {
        /// The gutter settings that apply between tiles.
        public var gutter: QuickSightClientTypes.GutterStyle?
        /// The margin settings that apply around the outside edge of sheets.
        public var margin: QuickSightClientTypes.MarginStyle?

        public init (
            gutter: QuickSightClientTypes.GutterStyle? = nil,
            margin: QuickSightClientTypes.MarginStyle? = nil
        )
        {
            self.gutter = gutter
            self.margin = margin
        }
    }

}

extension QuickSightClientTypes.TileStyle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case border = "Border"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let border = border {
            try encodeContainer.encode(border, forKey: .border)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let borderDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.BorderStyle.self, forKey: .border)
        border = borderDecoded
    }
}

extension QuickSightClientTypes {
    /// Display options related to tiles on a sheet.
    public struct TileStyle: Swift.Equatable {
        /// The border around a tile.
        public var border: QuickSightClientTypes.BorderStyle?

        public init (
            border: QuickSightClientTypes.BorderStyle? = nil
        )
        {
            self.border = border
        }
    }

}

extension QuickSightClientTypes.TransformOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case castcolumntypeoperation = "CastColumnTypeOperation"
        case createcolumnsoperation = "CreateColumnsOperation"
        case filteroperation = "FilterOperation"
        case projectoperation = "ProjectOperation"
        case renamecolumnoperation = "RenameColumnOperation"
        case tagcolumnoperation = "TagColumnOperation"
        case untagcolumnoperation = "UntagColumnOperation"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .castcolumntypeoperation(castcolumntypeoperation):
                try container.encode(castcolumntypeoperation, forKey: .castcolumntypeoperation)
            case let .createcolumnsoperation(createcolumnsoperation):
                try container.encode(createcolumnsoperation, forKey: .createcolumnsoperation)
            case let .filteroperation(filteroperation):
                try container.encode(filteroperation, forKey: .filteroperation)
            case let .projectoperation(projectoperation):
                try container.encode(projectoperation, forKey: .projectoperation)
            case let .renamecolumnoperation(renamecolumnoperation):
                try container.encode(renamecolumnoperation, forKey: .renamecolumnoperation)
            case let .tagcolumnoperation(tagcolumnoperation):
                try container.encode(tagcolumnoperation, forKey: .tagcolumnoperation)
            case let .untagcolumnoperation(untagcolumnoperation):
                try container.encode(untagcolumnoperation, forKey: .untagcolumnoperation)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let projectoperationDecoded = try values.decodeIfPresent(QuickSightClientTypes.ProjectOperation.self, forKey: .projectoperation)
        if let projectoperation = projectoperationDecoded {
            self = .projectoperation(projectoperation)
            return
        }
        let filteroperationDecoded = try values.decodeIfPresent(QuickSightClientTypes.FilterOperation.self, forKey: .filteroperation)
        if let filteroperation = filteroperationDecoded {
            self = .filteroperation(filteroperation)
            return
        }
        let createcolumnsoperationDecoded = try values.decodeIfPresent(QuickSightClientTypes.CreateColumnsOperation.self, forKey: .createcolumnsoperation)
        if let createcolumnsoperation = createcolumnsoperationDecoded {
            self = .createcolumnsoperation(createcolumnsoperation)
            return
        }
        let renamecolumnoperationDecoded = try values.decodeIfPresent(QuickSightClientTypes.RenameColumnOperation.self, forKey: .renamecolumnoperation)
        if let renamecolumnoperation = renamecolumnoperationDecoded {
            self = .renamecolumnoperation(renamecolumnoperation)
            return
        }
        let castcolumntypeoperationDecoded = try values.decodeIfPresent(QuickSightClientTypes.CastColumnTypeOperation.self, forKey: .castcolumntypeoperation)
        if let castcolumntypeoperation = castcolumntypeoperationDecoded {
            self = .castcolumntypeoperation(castcolumntypeoperation)
            return
        }
        let tagcolumnoperationDecoded = try values.decodeIfPresent(QuickSightClientTypes.TagColumnOperation.self, forKey: .tagcolumnoperation)
        if let tagcolumnoperation = tagcolumnoperationDecoded {
            self = .tagcolumnoperation(tagcolumnoperation)
            return
        }
        let untagcolumnoperationDecoded = try values.decodeIfPresent(QuickSightClientTypes.UntagColumnOperation.self, forKey: .untagcolumnoperation)
        if let untagcolumnoperation = untagcolumnoperationDecoded {
            self = .untagcolumnoperation(untagcolumnoperation)
            return
        }
        self = .sdkUnknown("")
    }
}

extension QuickSightClientTypes {
    /// A data transformation on a logical table. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
    public enum TransformOperation: Swift.Equatable {
        /// An operation that projects columns. Operations that come after a projection can only refer to projected columns.
        case projectoperation(QuickSightClientTypes.ProjectOperation)
        /// An operation that filters rows based on some condition.
        case filteroperation(QuickSightClientTypes.FilterOperation)
        /// An operation that creates calculated columns. Columns created in one such operation form a lexical closure.
        case createcolumnsoperation(QuickSightClientTypes.CreateColumnsOperation)
        /// An operation that renames a column.
        case renamecolumnoperation(QuickSightClientTypes.RenameColumnOperation)
        /// A transform operation that casts a column to a different type.
        case castcolumntypeoperation(QuickSightClientTypes.CastColumnTypeOperation)
        /// An operation that tags a column with additional information.
        case tagcolumnoperation(QuickSightClientTypes.TagColumnOperation)
        /// A transform operation that removes tags associated with a column.
        case untagcolumnoperation(QuickSightClientTypes.UntagColumnOperation)
        case sdkUnknown(Swift.String)
    }

}

extension QuickSightClientTypes.TwitterParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxRows = "MaxRows"
        case query = "Query"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxRows != 0 {
            try encodeContainer.encode(maxRows, forKey: .maxRows)
        }
        if let query = query {
            try encodeContainer.encode(query, forKey: .query)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .query)
        query = queryDecoded
        let maxRowsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxRows)
        maxRows = maxRowsDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for Twitter.
    public struct TwitterParameters: Swift.Equatable {
        /// Maximum number of rows to query Twitter.
        /// This member is required.
        public var maxRows: Swift.Int
        /// Twitter query string.
        /// This member is required.
        public var query: Swift.String?

        public init (
            maxRows: Swift.Int = 0,
            query: Swift.String? = nil
        )
        {
            self.maxRows = maxRows
            self.query = query
        }
    }

}

extension QuickSightClientTypes.UIColorPalette: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accent = "Accent"
        case accentForeground = "AccentForeground"
        case danger = "Danger"
        case dangerForeground = "DangerForeground"
        case dimension = "Dimension"
        case dimensionForeground = "DimensionForeground"
        case measure = "Measure"
        case measureForeground = "MeasureForeground"
        case primaryBackground = "PrimaryBackground"
        case primaryForeground = "PrimaryForeground"
        case secondaryBackground = "SecondaryBackground"
        case secondaryForeground = "SecondaryForeground"
        case success = "Success"
        case successForeground = "SuccessForeground"
        case warning = "Warning"
        case warningForeground = "WarningForeground"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accent = accent {
            try encodeContainer.encode(accent, forKey: .accent)
        }
        if let accentForeground = accentForeground {
            try encodeContainer.encode(accentForeground, forKey: .accentForeground)
        }
        if let danger = danger {
            try encodeContainer.encode(danger, forKey: .danger)
        }
        if let dangerForeground = dangerForeground {
            try encodeContainer.encode(dangerForeground, forKey: .dangerForeground)
        }
        if let dimension = dimension {
            try encodeContainer.encode(dimension, forKey: .dimension)
        }
        if let dimensionForeground = dimensionForeground {
            try encodeContainer.encode(dimensionForeground, forKey: .dimensionForeground)
        }
        if let measure = measure {
            try encodeContainer.encode(measure, forKey: .measure)
        }
        if let measureForeground = measureForeground {
            try encodeContainer.encode(measureForeground, forKey: .measureForeground)
        }
        if let primaryBackground = primaryBackground {
            try encodeContainer.encode(primaryBackground, forKey: .primaryBackground)
        }
        if let primaryForeground = primaryForeground {
            try encodeContainer.encode(primaryForeground, forKey: .primaryForeground)
        }
        if let secondaryBackground = secondaryBackground {
            try encodeContainer.encode(secondaryBackground, forKey: .secondaryBackground)
        }
        if let secondaryForeground = secondaryForeground {
            try encodeContainer.encode(secondaryForeground, forKey: .secondaryForeground)
        }
        if let success = success {
            try encodeContainer.encode(success, forKey: .success)
        }
        if let successForeground = successForeground {
            try encodeContainer.encode(successForeground, forKey: .successForeground)
        }
        if let warning = warning {
            try encodeContainer.encode(warning, forKey: .warning)
        }
        if let warningForeground = warningForeground {
            try encodeContainer.encode(warningForeground, forKey: .warningForeground)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryForegroundDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryForeground)
        primaryForeground = primaryForegroundDecoded
        let primaryBackgroundDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryBackground)
        primaryBackground = primaryBackgroundDecoded
        let secondaryForegroundDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secondaryForeground)
        secondaryForeground = secondaryForegroundDecoded
        let secondaryBackgroundDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secondaryBackground)
        secondaryBackground = secondaryBackgroundDecoded
        let accentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accent)
        accent = accentDecoded
        let accentForegroundDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accentForeground)
        accentForeground = accentForegroundDecoded
        let dangerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .danger)
        danger = dangerDecoded
        let dangerForegroundDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dangerForeground)
        dangerForeground = dangerForegroundDecoded
        let warningDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .warning)
        warning = warningDecoded
        let warningForegroundDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .warningForeground)
        warningForeground = warningForegroundDecoded
        let successDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .success)
        success = successDecoded
        let successForegroundDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .successForeground)
        successForeground = successForegroundDecoded
        let dimensionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimension)
        dimension = dimensionDecoded
        let dimensionForegroundDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimensionForeground)
        dimensionForeground = dimensionForegroundDecoded
        let measureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .measure)
        measure = measureDecoded
        let measureForegroundDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .measureForeground)
        measureForeground = measureForegroundDecoded
    }
}

extension QuickSightClientTypes {
    /// The theme colors that apply to UI and to charts, excluding data colors. The colors description is a hexadecimal color code that consists of six alphanumerical characters, prefixed with #, for example #37BFF5. For more information, see [Using Themes in Amazon QuickSight](https://docs.aws.amazon.com/quicksight/latest/user/themes-in-quicksight.html) in the Amazon QuickSight User Guide.
    public struct UIColorPalette: Swift.Equatable {
        /// This color is that applies to selected states and buttons.
        public var accent: Swift.String?
        /// The foreground color that applies to any text or other elements that appear over the accent color.
        public var accentForeground: Swift.String?
        /// The color that applies to error messages.
        public var danger: Swift.String?
        /// The foreground color that applies to any text or other elements that appear over the error color.
        public var dangerForeground: Swift.String?
        /// The color that applies to the names of fields that are identified as dimensions.
        public var dimension: Swift.String?
        /// The foreground color that applies to any text or other elements that appear over the dimension color.
        public var dimensionForeground: Swift.String?
        /// The color that applies to the names of fields that are identified as measures.
        public var measure: Swift.String?
        /// The foreground color that applies to any text or other elements that appear over the measure color.
        public var measureForeground: Swift.String?
        /// The background color that applies to visuals and other high emphasis UI.
        public var primaryBackground: Swift.String?
        /// The color of text and other foreground elements that appear over the primary background regions, such as grid lines, borders, table banding, icons, and so on.
        public var primaryForeground: Swift.String?
        /// The background color that applies to the sheet background and sheet controls.
        public var secondaryBackground: Swift.String?
        /// The foreground color that applies to any sheet title, sheet control text, or UI that appears over the secondary background.
        public var secondaryForeground: Swift.String?
        /// The color that applies to success messages, for example the check mark for a successful download.
        public var success: Swift.String?
        /// The foreground color that applies to any text or other elements that appear over the success color.
        public var successForeground: Swift.String?
        /// This color that applies to warning and informational messages.
        public var warning: Swift.String?
        /// The foreground color that applies to any text or other elements that appear over the warning color.
        public var warningForeground: Swift.String?

        public init (
            accent: Swift.String? = nil,
            accentForeground: Swift.String? = nil,
            danger: Swift.String? = nil,
            dangerForeground: Swift.String? = nil,
            dimension: Swift.String? = nil,
            dimensionForeground: Swift.String? = nil,
            measure: Swift.String? = nil,
            measureForeground: Swift.String? = nil,
            primaryBackground: Swift.String? = nil,
            primaryForeground: Swift.String? = nil,
            secondaryBackground: Swift.String? = nil,
            secondaryForeground: Swift.String? = nil,
            success: Swift.String? = nil,
            successForeground: Swift.String? = nil,
            warning: Swift.String? = nil,
            warningForeground: Swift.String? = nil
        )
        {
            self.accent = accent
            self.accentForeground = accentForeground
            self.danger = danger
            self.dangerForeground = dangerForeground
            self.dimension = dimension
            self.dimensionForeground = dimensionForeground
            self.measure = measure
            self.measureForeground = measureForeground
            self.primaryBackground = primaryBackground
            self.primaryForeground = primaryForeground
            self.secondaryBackground = secondaryBackground
            self.secondaryForeground = secondaryForeground
            self.success = success
            self.successForeground = successForeground
            self.warning = warning
            self.warningForeground = warningForeground
        }
    }

}

extension UnsupportedPricingPlanException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedPricingPlanExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This error indicates that you are calling an embedding operation in Amazon QuickSight without the required pricing plan on your Amazon Web Services account. Before you can use embedding for anonymous users, a QuickSight administrator needs to add capacity pricing to Amazon QuickSight. You can do this on the Manage Amazon QuickSight page. After capacity pricing is added, you can use the [GetDashboardEmbedUrl](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_GetDashboardEmbedUrl.html) API operation with the --identity-type ANONYMOUS option.
public struct UnsupportedPricingPlanException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct UnsupportedPricingPlanExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension UnsupportedPricingPlanExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UnsupportedUserEditionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedUserEditionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This error indicates that you are calling an operation on an Amazon QuickSight subscription where the edition doesn't include support for that operation. Amazon Amazon QuickSight currently has Standard Edition and Enterprise Edition. Not every operation and capability is available in every edition.
public struct UnsupportedUserEditionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct UnsupportedUserEditionExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension UnsupportedUserEditionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.UntagColumnOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnName = "ColumnName"
        case tagNames = "TagNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnName = columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let tagNames = tagNames {
            var tagNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagNames)
            for columntagnames0 in tagNames {
                try tagNamesContainer.encode(columntagnames0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let tagNamesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnTagName?].self, forKey: .tagNames)
        var tagNamesDecoded0:[QuickSightClientTypes.ColumnTagName]? = nil
        if let tagNamesContainer = tagNamesContainer {
            tagNamesDecoded0 = [QuickSightClientTypes.ColumnTagName]()
            for string0 in tagNamesContainer {
                if let string0 = string0 {
                    tagNamesDecoded0?.append(string0)
                }
            }
        }
        tagNames = tagNamesDecoded0
    }
}

extension QuickSightClientTypes {
    /// A transform operation that removes tags associated with a column.
    public struct UntagColumnOperation: Swift.Equatable {
        /// The column that this operation acts on.
        /// This member is required.
        public var columnName: Swift.String?
        /// The column tags to remove from this column.
        /// This member is required.
        public var tagNames: [QuickSightClientTypes.ColumnTagName]?

        public init (
            columnName: Swift.String? = nil,
            tagNames: [QuickSightClientTypes.ColumnTagName]? = nil
        )
        {
            self.columnName = columnName
            self.tagNames = tagNames
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "keys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/resources/\(resourceArn.urlPercentEncoding())/tags"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the key-value pairs for the resource tag or tags assigned to the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UntagResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UntagResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateAccountCustomizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountCustomization = "AccountCustomization"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountCustomization = accountCustomization {
            try encodeContainer.encode(accountCustomization, forKey: .accountCustomization)
        }
    }
}

extension UpdateAccountCustomizationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let namespace = namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        return items
    }
}

extension UpdateAccountCustomizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/customizations"
    }
}

public struct UpdateAccountCustomizationInput: Swift.Equatable {
    /// The Amazon QuickSight customizations you're updating in the current Amazon Web Services Region.
    /// This member is required.
    public var accountCustomization: QuickSightClientTypes.AccountCustomization?
    /// The ID for the Amazon Web Services account that you want to update Amazon QuickSight customizations for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace that you want to update Amazon QuickSight customizations for.
    public var namespace: Swift.String?

    public init (
        accountCustomization: QuickSightClientTypes.AccountCustomization? = nil,
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.accountCustomization = accountCustomization
        self.awsAccountId = awsAccountId
        self.namespace = namespace
    }
}

struct UpdateAccountCustomizationInputBody: Swift.Equatable {
    let accountCustomization: QuickSightClientTypes.AccountCustomization?
}

extension UpdateAccountCustomizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountCustomization = "AccountCustomization"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountCustomizationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AccountCustomization.self, forKey: .accountCustomization)
        accountCustomization = accountCustomizationDecoded
    }
}

extension UpdateAccountCustomizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAccountCustomizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAccountCustomizationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccountCustomizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAccountCustomizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountCustomization = output.accountCustomization
            self.arn = output.arn
            self.awsAccountId = output.awsAccountId
            self.namespace = output.namespace
            self.requestId = output.requestId
        } else {
            self.accountCustomization = nil
            self.arn = nil
            self.awsAccountId = nil
            self.namespace = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateAccountCustomizationOutputResponse: Swift.Equatable {
    /// The Amazon QuickSight customizations you're updating in the current Amazon Web Services Region.
    public var accountCustomization: QuickSightClientTypes.AccountCustomization?
    /// The Amazon Resource Name (ARN) for the updated customization for this Amazon Web Services account.
    public var arn: Swift.String?
    /// The ID for the Amazon Web Services account that you want to update Amazon QuickSight customizations for.
    public var awsAccountId: Swift.String?
    /// The namespace associated with the customization that you're updating.
    public var namespace: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        accountCustomization: QuickSightClientTypes.AccountCustomization? = nil,
        arn: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.accountCustomization = accountCustomization
        self.arn = arn
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateAccountCustomizationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let awsAccountId: Swift.String?
    let namespace: Swift.String?
    let accountCustomization: QuickSightClientTypes.AccountCustomization?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateAccountCustomizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountCustomization = "AccountCustomization"
        case arn = "Arn"
        case awsAccountId = "AwsAccountId"
        case namespace = "Namespace"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let accountCustomizationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AccountCustomization.self, forKey: .accountCustomization)
        accountCustomization = accountCustomizationDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateAccountSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultNamespace = "DefaultNamespace"
        case notificationEmail = "NotificationEmail"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultNamespace = defaultNamespace {
            try encodeContainer.encode(defaultNamespace, forKey: .defaultNamespace)
        }
        if let notificationEmail = notificationEmail {
            try encodeContainer.encode(notificationEmail, forKey: .notificationEmail)
        }
    }
}

extension UpdateAccountSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/settings"
    }
}

public struct UpdateAccountSettingsInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the Amazon QuickSight settings that you want to list.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The default namespace for this Amazon Web Services account. Currently, the default is default. Identity and Access Management (IAM) users that register for the first time with Amazon QuickSight provide an email that becomes associated with the default namespace.
    /// This member is required.
    public var defaultNamespace: Swift.String?
    /// The email address that you want Amazon QuickSight to send notifications to regarding your Amazon Web Services account or Amazon QuickSight subscription.
    public var notificationEmail: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        defaultNamespace: Swift.String? = nil,
        notificationEmail: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.defaultNamespace = defaultNamespace
        self.notificationEmail = notificationEmail
    }
}

struct UpdateAccountSettingsInputBody: Swift.Equatable {
    let defaultNamespace: Swift.String?
    let notificationEmail: Swift.String?
}

extension UpdateAccountSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultNamespace = "DefaultNamespace"
        case notificationEmail = "NotificationEmail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultNamespace)
        defaultNamespace = defaultNamespaceDecoded
        let notificationEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationEmail)
        notificationEmail = notificationEmailDecoded
    }
}

extension UpdateAccountSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAccountSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAccountSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccountSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAccountSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateAccountSettingsOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateAccountSettingsOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateAccountSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateAnalysisInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case parameters = "Parameters"
        case sourceEntity = "SourceEntity"
        case themeArn = "ThemeArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let sourceEntity = sourceEntity {
            try encodeContainer.encode(sourceEntity, forKey: .sourceEntity)
        }
        if let themeArn = themeArn {
            try encodeContainer.encode(themeArn, forKey: .themeArn)
        }
    }
}

extension UpdateAnalysisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let analysisId = analysisId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/analyses/\(analysisId.urlPercentEncoding())"
    }
}

public struct UpdateAnalysisInput: Swift.Equatable {
    /// The ID for the analysis that you're updating. This ID displays in the URL of the analysis.
    /// This member is required.
    public var analysisId: Swift.String?
    /// The ID of the Amazon Web Services account that contains the analysis that you're updating.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A descriptive name for the analysis that you're updating. This name displays for the analysis in the Amazon QuickSight console.
    /// This member is required.
    public var name: Swift.String?
    /// The parameter names and override values that you want to use. An analysis can have any parameter type, and some parameters might accept multiple values.
    public var parameters: QuickSightClientTypes.Parameters?
    /// A source entity to use for the analysis that you're updating. This metadata structure contains details that describe a source template and one or more datasets.
    /// This member is required.
    public var sourceEntity: QuickSightClientTypes.AnalysisSourceEntity?
    /// The Amazon Resource Name (ARN) for the theme to apply to the analysis that you're creating. To see the theme in the Amazon QuickSight console, make sure that you have access to it.
    public var themeArn: Swift.String?

    public init (
        analysisId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        name: Swift.String? = nil,
        parameters: QuickSightClientTypes.Parameters? = nil,
        sourceEntity: QuickSightClientTypes.AnalysisSourceEntity? = nil,
        themeArn: Swift.String? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
        self.name = name
        self.parameters = parameters
        self.sourceEntity = sourceEntity
        self.themeArn = themeArn
    }
}

struct UpdateAnalysisInputBody: Swift.Equatable {
    let name: Swift.String?
    let parameters: QuickSightClientTypes.Parameters?
    let sourceEntity: QuickSightClientTypes.AnalysisSourceEntity?
    let themeArn: Swift.String?
}

extension UpdateAnalysisInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case parameters = "Parameters"
        case sourceEntity = "SourceEntity"
        case themeArn = "ThemeArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Parameters.self, forKey: .parameters)
        parameters = parametersDecoded
        let sourceEntityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AnalysisSourceEntity.self, forKey: .sourceEntity)
        sourceEntity = sourceEntityDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
    }
}

extension UpdateAnalysisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAnalysisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAnalysisOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAnalysisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisId = output.analysisId
            self.arn = output.arn
            self.requestId = output.requestId
            self.updateStatus = output.updateStatus
        } else {
            self.analysisId = nil
            self.arn = nil
            self.requestId = nil
            self.updateStatus = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateAnalysisOutputResponse: Swift.Equatable {
    /// The ID of the analysis.
    public var analysisId: Swift.String?
    /// The ARN of the analysis that you're updating.
    public var arn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The update status of the last update that was made to the analysis.
    public var updateStatus: QuickSightClientTypes.ResourceStatus?

    public init (
        analysisId: Swift.String? = nil,
        arn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        updateStatus: QuickSightClientTypes.ResourceStatus? = nil
    )
    {
        self.analysisId = analysisId
        self.arn = arn
        self.requestId = requestId
        self.status = status
        self.updateStatus = updateStatus
    }
}

struct UpdateAnalysisOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let analysisId: Swift.String?
    let updateStatus: QuickSightClientTypes.ResourceStatus?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension UpdateAnalysisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisId = "AnalysisId"
        case arn = "Arn"
        case requestId = "RequestId"
        case status = "Status"
        case updateStatus = "UpdateStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let analysisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
        let updateStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .updateStatus)
        updateStatus = updateStatusDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UpdateAnalysisPermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantPermissions = grantPermissions {
            var grantPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantPermissions)
            for updateresourcepermissionlist0 in grantPermissions {
                try grantPermissionsContainer.encode(updateresourcepermissionlist0)
            }
        }
        if let revokePermissions = revokePermissions {
            var revokePermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revokePermissions)
            for updateresourcepermissionlist0 in revokePermissions {
                try revokePermissionsContainer.encode(updateresourcepermissionlist0)
            }
        }
    }
}

extension UpdateAnalysisPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let analysisId = analysisId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/analyses/\(analysisId.urlPercentEncoding())/permissions"
    }
}

public struct UpdateAnalysisPermissionsInput: Swift.Equatable {
    /// The ID of the analysis whose permissions you're updating. The ID is part of the analysis URL.
    /// This member is required.
    public var analysisId: Swift.String?
    /// The ID of the Amazon Web Services account that contains the analysis whose permissions you're updating. You must be using the Amazon Web Services account that the analysis is in.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A structure that describes the permissions to add and the principal to add them to.
    public var grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// A structure that describes the permissions to remove and the principal to remove them from.
    public var revokePermissions: [QuickSightClientTypes.ResourcePermission]?

    public init (
        analysisId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        grantPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        revokePermissions: [QuickSightClientTypes.ResourcePermission]? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
        self.grantPermissions = grantPermissions
        self.revokePermissions = revokePermissions
    }
}

struct UpdateAnalysisPermissionsInputBody: Swift.Equatable {
    let grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    let revokePermissions: [QuickSightClientTypes.ResourcePermission]?
}

extension UpdateAnalysisPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantPermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .grantPermissions)
        var grantPermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let grantPermissionsContainer = grantPermissionsContainer {
            grantPermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in grantPermissionsContainer {
                if let structure0 = structure0 {
                    grantPermissionsDecoded0?.append(structure0)
                }
            }
        }
        grantPermissions = grantPermissionsDecoded0
        let revokePermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .revokePermissions)
        var revokePermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let revokePermissionsContainer = revokePermissionsContainer {
            revokePermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in revokePermissionsContainer {
                if let structure0 = structure0 {
                    revokePermissionsDecoded0?.append(structure0)
                }
            }
        }
        revokePermissions = revokePermissionsDecoded0
    }
}

extension UpdateAnalysisPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAnalysisPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAnalysisPermissionsOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAnalysisPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAnalysisPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisArn = output.analysisArn
            self.analysisId = output.analysisId
            self.permissions = output.permissions
            self.requestId = output.requestId
        } else {
            self.analysisArn = nil
            self.analysisId = nil
            self.permissions = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateAnalysisPermissionsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the analysis that you updated.
    public var analysisArn: Swift.String?
    /// The ID of the analysis that you updated permissions for.
    public var analysisId: Swift.String?
    /// A structure that describes the principals and the resource-level permissions on an analysis.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        analysisArn: Swift.String? = nil,
        analysisId: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.analysisArn = analysisArn
        self.analysisId = analysisId
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateAnalysisPermissionsOutputResponseBody: Swift.Equatable {
    let analysisArn: Swift.String?
    let analysisId: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateAnalysisPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisArn = "AnalysisArn"
        case analysisId = "AnalysisId"
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisArn)
        analysisArn = analysisArnDecoded
        let analysisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateDashboardInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardPublishOptions = "DashboardPublishOptions"
        case name = "Name"
        case parameters = "Parameters"
        case sourceEntity = "SourceEntity"
        case themeArn = "ThemeArn"
        case versionDescription = "VersionDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dashboardPublishOptions = dashboardPublishOptions {
            try encodeContainer.encode(dashboardPublishOptions, forKey: .dashboardPublishOptions)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let sourceEntity = sourceEntity {
            try encodeContainer.encode(sourceEntity, forKey: .sourceEntity)
        }
        if let themeArn = themeArn {
            try encodeContainer.encode(themeArn, forKey: .themeArn)
        }
        if let versionDescription = versionDescription {
            try encodeContainer.encode(versionDescription, forKey: .versionDescription)
        }
    }
}

extension UpdateDashboardInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dashboardId = dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())"
    }
}

public struct UpdateDashboardInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the dashboard that you're updating.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// Options for publishing the dashboard when you create it:
    ///
    /// * AvailabilityStatus for AdHocFilteringOption - This status can be either ENABLED or DISABLED. When this is set to DISABLED, Amazon QuickSight disables the left filter pane on the published dashboard, which can be used for ad hoc (one-time) filtering. This option is ENABLED by default.
    ///
    /// * AvailabilityStatus for ExportToCSVOption - This status can be either ENABLED or DISABLED. The visual option to export data to .CSV format isn't enabled when this is set to DISABLED. This option is ENABLED by default.
    ///
    /// * VisibilityState for SheetControlsOption - This visibility state can be either COLLAPSED or EXPANDED. This option is COLLAPSED by default.
    public var dashboardPublishOptions: QuickSightClientTypes.DashboardPublishOptions?
    /// The display name of the dashboard.
    /// This member is required.
    public var name: Swift.String?
    /// A structure that contains the parameters of the dashboard. These are parameter overrides for a dashboard. A dashboard can have any type of parameters, and some parameters might accept multiple values.
    public var parameters: QuickSightClientTypes.Parameters?
    /// The entity that you are using as a source when you update the dashboard. In SourceEntity, you specify the type of object you're using as source. You can only update a dashboard from a template, so you use a SourceTemplate entity. If you need to update a dashboard from an analysis, first convert the analysis to a template by using the [CreateTemplate](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_CreateTemplate.html) API operation. For SourceTemplate, specify the Amazon Resource Name (ARN) of the source template. The SourceTemplate ARN can contain any Amazon Web Services account and any Amazon QuickSight-supported Amazon Web Services Region. Use the DataSetReferences entity within SourceTemplate to list the replacement datasets for the placeholders listed in the original. The schema in each dataset must match its placeholder.
    /// This member is required.
    public var sourceEntity: QuickSightClientTypes.DashboardSourceEntity?
    /// The Amazon Resource Name (ARN) of the theme that is being used for this dashboard. If you add a value for this field, it overrides the value that was originally associated with the entity. The theme ARN must exist in the same Amazon Web Services account where you create the dashboard.
    public var themeArn: Swift.String?
    /// A description for the first version of the dashboard being created.
    public var versionDescription: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        dashboardPublishOptions: QuickSightClientTypes.DashboardPublishOptions? = nil,
        name: Swift.String? = nil,
        parameters: QuickSightClientTypes.Parameters? = nil,
        sourceEntity: QuickSightClientTypes.DashboardSourceEntity? = nil,
        themeArn: Swift.String? = nil,
        versionDescription: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.dashboardPublishOptions = dashboardPublishOptions
        self.name = name
        self.parameters = parameters
        self.sourceEntity = sourceEntity
        self.themeArn = themeArn
        self.versionDescription = versionDescription
    }
}

struct UpdateDashboardInputBody: Swift.Equatable {
    let name: Swift.String?
    let sourceEntity: QuickSightClientTypes.DashboardSourceEntity?
    let parameters: QuickSightClientTypes.Parameters?
    let versionDescription: Swift.String?
    let dashboardPublishOptions: QuickSightClientTypes.DashboardPublishOptions?
    let themeArn: Swift.String?
}

extension UpdateDashboardInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardPublishOptions = "DashboardPublishOptions"
        case name = "Name"
        case parameters = "Parameters"
        case sourceEntity = "SourceEntity"
        case themeArn = "ThemeArn"
        case versionDescription = "VersionDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceEntityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardSourceEntity.self, forKey: .sourceEntity)
        sourceEntity = sourceEntityDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Parameters.self, forKey: .parameters)
        parameters = parametersDecoded
        let versionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionDescription)
        versionDescription = versionDescriptionDecoded
        let dashboardPublishOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardPublishOptions.self, forKey: .dashboardPublishOptions)
        dashboardPublishOptions = dashboardPublishOptionsDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
    }
}

extension UpdateDashboardOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDashboardOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDashboardOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDashboardOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDashboardOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationStatus = output.creationStatus
            self.dashboardId = output.dashboardId
            self.requestId = output.requestId
            self.status = output.status
            self.versionArn = output.versionArn
        } else {
            self.arn = nil
            self.creationStatus = nil
            self.dashboardId = nil
            self.requestId = nil
            self.status = 0
            self.versionArn = nil
        }
    }
}

public struct UpdateDashboardOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    public var arn: Swift.String?
    /// The creation status of the request.
    public var creationStatus: QuickSightClientTypes.ResourceStatus?
    /// The ID for the dashboard.
    public var dashboardId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ARN of the dashboard, including the version number.
    public var versionArn: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.ResourceStatus? = nil,
        dashboardId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        versionArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.dashboardId = dashboardId
        self.requestId = requestId
        self.status = status
        self.versionArn = versionArn
    }
}

struct UpdateDashboardOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let versionArn: Swift.String?
    let dashboardId: Swift.String?
    let creationStatus: QuickSightClientTypes.ResourceStatus?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension UpdateDashboardOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationStatus = "CreationStatus"
        case dashboardId = "DashboardId"
        case requestId = "RequestId"
        case status = "Status"
        case versionArn = "VersionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionArn)
        versionArn = versionArnDecoded
        let dashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UpdateDashboardPermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantLinkPermissions = "GrantLinkPermissions"
        case grantPermissions = "GrantPermissions"
        case revokeLinkPermissions = "RevokeLinkPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantLinkPermissions = grantLinkPermissions {
            var grantLinkPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantLinkPermissions)
            for updatelinkpermissionlist0 in grantLinkPermissions {
                try grantLinkPermissionsContainer.encode(updatelinkpermissionlist0)
            }
        }
        if let grantPermissions = grantPermissions {
            var grantPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantPermissions)
            for updateresourcepermissionlist0 in grantPermissions {
                try grantPermissionsContainer.encode(updateresourcepermissionlist0)
            }
        }
        if let revokeLinkPermissions = revokeLinkPermissions {
            var revokeLinkPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revokeLinkPermissions)
            for updatelinkpermissionlist0 in revokeLinkPermissions {
                try revokeLinkPermissionsContainer.encode(updatelinkpermissionlist0)
            }
        }
        if let revokePermissions = revokePermissions {
            var revokePermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revokePermissions)
            for updateresourcepermissionlist0 in revokePermissions {
                try revokePermissionsContainer.encode(updateresourcepermissionlist0)
            }
        }
    }
}

extension UpdateDashboardPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dashboardId = dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())/permissions"
    }
}

public struct UpdateDashboardPermissionsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the dashboard whose permissions you're updating.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// Grants link permissions to all users in a defined namespace.
    public var grantLinkPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// The permissions that you want to grant on this resource.
    public var grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// Revokes link permissions from all users in a defined namespace.
    public var revokeLinkPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// The permissions that you want to revoke from this resource.
    public var revokePermissions: [QuickSightClientTypes.ResourcePermission]?

    public init (
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        grantLinkPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        grantPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        revokeLinkPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        revokePermissions: [QuickSightClientTypes.ResourcePermission]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.grantLinkPermissions = grantLinkPermissions
        self.grantPermissions = grantPermissions
        self.revokeLinkPermissions = revokeLinkPermissions
        self.revokePermissions = revokePermissions
    }
}

struct UpdateDashboardPermissionsInputBody: Swift.Equatable {
    let grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    let revokePermissions: [QuickSightClientTypes.ResourcePermission]?
    let grantLinkPermissions: [QuickSightClientTypes.ResourcePermission]?
    let revokeLinkPermissions: [QuickSightClientTypes.ResourcePermission]?
}

extension UpdateDashboardPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantLinkPermissions = "GrantLinkPermissions"
        case grantPermissions = "GrantPermissions"
        case revokeLinkPermissions = "RevokeLinkPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantPermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .grantPermissions)
        var grantPermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let grantPermissionsContainer = grantPermissionsContainer {
            grantPermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in grantPermissionsContainer {
                if let structure0 = structure0 {
                    grantPermissionsDecoded0?.append(structure0)
                }
            }
        }
        grantPermissions = grantPermissionsDecoded0
        let revokePermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .revokePermissions)
        var revokePermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let revokePermissionsContainer = revokePermissionsContainer {
            revokePermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in revokePermissionsContainer {
                if let structure0 = structure0 {
                    revokePermissionsDecoded0?.append(structure0)
                }
            }
        }
        revokePermissions = revokePermissionsDecoded0
        let grantLinkPermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .grantLinkPermissions)
        var grantLinkPermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let grantLinkPermissionsContainer = grantLinkPermissionsContainer {
            grantLinkPermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in grantLinkPermissionsContainer {
                if let structure0 = structure0 {
                    grantLinkPermissionsDecoded0?.append(structure0)
                }
            }
        }
        grantLinkPermissions = grantLinkPermissionsDecoded0
        let revokeLinkPermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .revokeLinkPermissions)
        var revokeLinkPermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let revokeLinkPermissionsContainer = revokeLinkPermissionsContainer {
            revokeLinkPermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in revokeLinkPermissionsContainer {
                if let structure0 = structure0 {
                    revokeLinkPermissionsDecoded0?.append(structure0)
                }
            }
        }
        revokeLinkPermissions = revokeLinkPermissionsDecoded0
    }
}

extension UpdateDashboardPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDashboardPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDashboardPermissionsOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDashboardPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDashboardPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dashboardArn = output.dashboardArn
            self.dashboardId = output.dashboardId
            self.linkSharingConfiguration = output.linkSharingConfiguration
            self.permissions = output.permissions
            self.requestId = output.requestId
        } else {
            self.dashboardArn = nil
            self.dashboardId = nil
            self.linkSharingConfiguration = nil
            self.permissions = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateDashboardPermissionsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dashboard.
    public var dashboardArn: Swift.String?
    /// The ID for the dashboard.
    public var dashboardId: Swift.String?
    /// Updates the permissions of a shared link to an Amazon QuickSight dashboard.
    public var linkSharingConfiguration: QuickSightClientTypes.LinkSharingConfiguration?
    /// Information about the permissions on the dashboard.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dashboardArn: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        linkSharingConfiguration: QuickSightClientTypes.LinkSharingConfiguration? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dashboardArn = dashboardArn
        self.dashboardId = dashboardId
        self.linkSharingConfiguration = linkSharingConfiguration
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateDashboardPermissionsOutputResponseBody: Swift.Equatable {
    let dashboardArn: Swift.String?
    let dashboardId: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let requestId: Swift.String?
    let status: Swift.Int
    let linkSharingConfiguration: QuickSightClientTypes.LinkSharingConfiguration?
}

extension UpdateDashboardPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardArn = "DashboardArn"
        case dashboardId = "DashboardId"
        case linkSharingConfiguration = "LinkSharingConfiguration"
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardArn)
        dashboardArn = dashboardArnDecoded
        let dashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let linkSharingConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LinkSharingConfiguration.self, forKey: .linkSharingConfiguration)
        linkSharingConfiguration = linkSharingConfigurationDecoded
    }
}

extension UpdateDashboardPublishedVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dashboardId = dashboardId else {
            return nil
        }
        guard let versionNumber = versionNumber else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())/versions/\(versionNumber)"
    }
}

public struct UpdateDashboardPublishedVersionInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the dashboard that you're updating.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// The version number of the dashboard.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init (
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.versionNumber = versionNumber
    }
}

struct UpdateDashboardPublishedVersionInputBody: Swift.Equatable {
}

extension UpdateDashboardPublishedVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UpdateDashboardPublishedVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDashboardPublishedVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDashboardPublishedVersionOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDashboardPublishedVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDashboardPublishedVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dashboardArn = output.dashboardArn
            self.dashboardId = output.dashboardId
            self.requestId = output.requestId
        } else {
            self.dashboardArn = nil
            self.dashboardId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateDashboardPublishedVersionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dashboard.
    public var dashboardArn: Swift.String?
    /// The ID for the dashboard.
    public var dashboardId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dashboardArn: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dashboardArn = dashboardArn
        self.dashboardId = dashboardId
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateDashboardPublishedVersionOutputResponseBody: Swift.Equatable {
    let dashboardId: Swift.String?
    let dashboardArn: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension UpdateDashboardPublishedVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardArn = "DashboardArn"
        case dashboardId = "DashboardId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let dashboardArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardArn)
        dashboardArn = dashboardArnDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UpdateDataSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnGroups = "ColumnGroups"
        case columnLevelPermissionRules = "ColumnLevelPermissionRules"
        case dataSetUsageConfiguration = "DataSetUsageConfiguration"
        case fieldFolders = "FieldFolders"
        case importMode = "ImportMode"
        case logicalTableMap = "LogicalTableMap"
        case name = "Name"
        case physicalTableMap = "PhysicalTableMap"
        case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
        case rowLevelPermissionTagConfiguration = "RowLevelPermissionTagConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnGroups = columnGroups {
            var columnGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnGroups)
            for columngrouplist0 in columnGroups {
                try columnGroupsContainer.encode(columngrouplist0)
            }
        }
        if let columnLevelPermissionRules = columnLevelPermissionRules {
            var columnLevelPermissionRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnLevelPermissionRules)
            for columnlevelpermissionrulelist0 in columnLevelPermissionRules {
                try columnLevelPermissionRulesContainer.encode(columnlevelpermissionrulelist0)
            }
        }
        if let dataSetUsageConfiguration = dataSetUsageConfiguration {
            try encodeContainer.encode(dataSetUsageConfiguration, forKey: .dataSetUsageConfiguration)
        }
        if let fieldFolders = fieldFolders {
            var fieldFoldersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .fieldFolders)
            for (dictKey0, fieldfoldermap0) in fieldFolders {
                try fieldFoldersContainer.encode(fieldfoldermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let importMode = importMode {
            try encodeContainer.encode(importMode.rawValue, forKey: .importMode)
        }
        if let logicalTableMap = logicalTableMap {
            var logicalTableMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .logicalTableMap)
            for (dictKey0, logicaltablemap0) in logicalTableMap {
                try logicalTableMapContainer.encode(logicaltablemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let physicalTableMap = physicalTableMap {
            var physicalTableMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .physicalTableMap)
            for (dictKey0, physicaltablemap0) in physicalTableMap {
                try physicalTableMapContainer.encode(physicaltablemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let rowLevelPermissionDataSet = rowLevelPermissionDataSet {
            try encodeContainer.encode(rowLevelPermissionDataSet, forKey: .rowLevelPermissionDataSet)
        }
        if let rowLevelPermissionTagConfiguration = rowLevelPermissionTagConfiguration {
            try encodeContainer.encode(rowLevelPermissionTagConfiguration, forKey: .rowLevelPermissionTagConfiguration)
        }
    }
}

extension UpdateDataSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSetId = dataSetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())"
    }
}

public struct UpdateDataSetInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// Groupings of columns that work together in certain Amazon QuickSight features. Currently, only geospatial hierarchy is supported.
    public var columnGroups: [QuickSightClientTypes.ColumnGroup]?
    /// A set of one or more definitions of a [ColumnLevelPermissionRule](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ColumnLevelPermissionRule.html).
    public var columnLevelPermissionRules: [QuickSightClientTypes.ColumnLevelPermissionRule]?
    /// The ID for the dataset that you want to update. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The usage configuration to apply to child datasets that reference this dataset as a source.
    public var dataSetUsageConfiguration: QuickSightClientTypes.DataSetUsageConfiguration?
    /// The folder that contains fields and nested subfolders for your dataset.
    public var fieldFolders: [Swift.String:QuickSightClientTypes.FieldFolder]?
    /// Indicates whether you want to import the data into SPICE.
    /// This member is required.
    public var importMode: QuickSightClientTypes.DataSetImportMode?
    /// Configures the combination and transformation of the data from the physical tables.
    public var logicalTableMap: [Swift.String:QuickSightClientTypes.LogicalTable]?
    /// The display name for the dataset.
    /// This member is required.
    public var name: Swift.String?
    /// Declares the physical tables that are available in the underlying data sources.
    /// This member is required.
    public var physicalTableMap: [Swift.String:QuickSightClientTypes.PhysicalTable]?
    /// The row-level security configuration for the data you want to create.
    public var rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet?
    /// The configuration of tags on a dataset to set row-level security. Row-level security tags are currently supported for anonymous embedding only.
    public var rowLevelPermissionTagConfiguration: QuickSightClientTypes.RowLevelPermissionTagConfiguration?

    public init (
        awsAccountId: Swift.String? = nil,
        columnGroups: [QuickSightClientTypes.ColumnGroup]? = nil,
        columnLevelPermissionRules: [QuickSightClientTypes.ColumnLevelPermissionRule]? = nil,
        dataSetId: Swift.String? = nil,
        dataSetUsageConfiguration: QuickSightClientTypes.DataSetUsageConfiguration? = nil,
        fieldFolders: [Swift.String:QuickSightClientTypes.FieldFolder]? = nil,
        importMode: QuickSightClientTypes.DataSetImportMode? = nil,
        logicalTableMap: [Swift.String:QuickSightClientTypes.LogicalTable]? = nil,
        name: Swift.String? = nil,
        physicalTableMap: [Swift.String:QuickSightClientTypes.PhysicalTable]? = nil,
        rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet? = nil,
        rowLevelPermissionTagConfiguration: QuickSightClientTypes.RowLevelPermissionTagConfiguration? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.columnGroups = columnGroups
        self.columnLevelPermissionRules = columnLevelPermissionRules
        self.dataSetId = dataSetId
        self.dataSetUsageConfiguration = dataSetUsageConfiguration
        self.fieldFolders = fieldFolders
        self.importMode = importMode
        self.logicalTableMap = logicalTableMap
        self.name = name
        self.physicalTableMap = physicalTableMap
        self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
        self.rowLevelPermissionTagConfiguration = rowLevelPermissionTagConfiguration
    }
}

struct UpdateDataSetInputBody: Swift.Equatable {
    let name: Swift.String?
    let physicalTableMap: [Swift.String:QuickSightClientTypes.PhysicalTable]?
    let logicalTableMap: [Swift.String:QuickSightClientTypes.LogicalTable]?
    let importMode: QuickSightClientTypes.DataSetImportMode?
    let columnGroups: [QuickSightClientTypes.ColumnGroup]?
    let fieldFolders: [Swift.String:QuickSightClientTypes.FieldFolder]?
    let rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet?
    let rowLevelPermissionTagConfiguration: QuickSightClientTypes.RowLevelPermissionTagConfiguration?
    let columnLevelPermissionRules: [QuickSightClientTypes.ColumnLevelPermissionRule]?
    let dataSetUsageConfiguration: QuickSightClientTypes.DataSetUsageConfiguration?
}

extension UpdateDataSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnGroups = "ColumnGroups"
        case columnLevelPermissionRules = "ColumnLevelPermissionRules"
        case dataSetUsageConfiguration = "DataSetUsageConfiguration"
        case fieldFolders = "FieldFolders"
        case importMode = "ImportMode"
        case logicalTableMap = "LogicalTableMap"
        case name = "Name"
        case physicalTableMap = "PhysicalTableMap"
        case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
        case rowLevelPermissionTagConfiguration = "RowLevelPermissionTagConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let physicalTableMapContainer = try containerValues.decodeIfPresent([Swift.String: QuickSightClientTypes.PhysicalTable?].self, forKey: .physicalTableMap)
        var physicalTableMapDecoded0: [Swift.String:QuickSightClientTypes.PhysicalTable]? = nil
        if let physicalTableMapContainer = physicalTableMapContainer {
            physicalTableMapDecoded0 = [Swift.String:QuickSightClientTypes.PhysicalTable]()
            for (key0, physicaltable0) in physicalTableMapContainer {
                if let physicaltable0 = physicaltable0 {
                    physicalTableMapDecoded0?[key0] = physicaltable0
                }
            }
        }
        physicalTableMap = physicalTableMapDecoded0
        let logicalTableMapContainer = try containerValues.decodeIfPresent([Swift.String: QuickSightClientTypes.LogicalTable?].self, forKey: .logicalTableMap)
        var logicalTableMapDecoded0: [Swift.String:QuickSightClientTypes.LogicalTable]? = nil
        if let logicalTableMapContainer = logicalTableMapContainer {
            logicalTableMapDecoded0 = [Swift.String:QuickSightClientTypes.LogicalTable]()
            for (key0, logicaltable0) in logicalTableMapContainer {
                if let logicaltable0 = logicaltable0 {
                    logicalTableMapDecoded0?[key0] = logicaltable0
                }
            }
        }
        logicalTableMap = logicalTableMapDecoded0
        let importModeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSetImportMode.self, forKey: .importMode)
        importMode = importModeDecoded
        let columnGroupsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnGroup?].self, forKey: .columnGroups)
        var columnGroupsDecoded0:[QuickSightClientTypes.ColumnGroup]? = nil
        if let columnGroupsContainer = columnGroupsContainer {
            columnGroupsDecoded0 = [QuickSightClientTypes.ColumnGroup]()
            for structure0 in columnGroupsContainer {
                if let structure0 = structure0 {
                    columnGroupsDecoded0?.append(structure0)
                }
            }
        }
        columnGroups = columnGroupsDecoded0
        let fieldFoldersContainer = try containerValues.decodeIfPresent([Swift.String: QuickSightClientTypes.FieldFolder?].self, forKey: .fieldFolders)
        var fieldFoldersDecoded0: [Swift.String:QuickSightClientTypes.FieldFolder]? = nil
        if let fieldFoldersContainer = fieldFoldersContainer {
            fieldFoldersDecoded0 = [Swift.String:QuickSightClientTypes.FieldFolder]()
            for (key0, fieldfolder0) in fieldFoldersContainer {
                if let fieldfolder0 = fieldfolder0 {
                    fieldFoldersDecoded0?[key0] = fieldfolder0
                }
            }
        }
        fieldFolders = fieldFoldersDecoded0
        let rowLevelPermissionDataSetDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RowLevelPermissionDataSet.self, forKey: .rowLevelPermissionDataSet)
        rowLevelPermissionDataSet = rowLevelPermissionDataSetDecoded
        let rowLevelPermissionTagConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RowLevelPermissionTagConfiguration.self, forKey: .rowLevelPermissionTagConfiguration)
        rowLevelPermissionTagConfiguration = rowLevelPermissionTagConfigurationDecoded
        let columnLevelPermissionRulesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnLevelPermissionRule?].self, forKey: .columnLevelPermissionRules)
        var columnLevelPermissionRulesDecoded0:[QuickSightClientTypes.ColumnLevelPermissionRule]? = nil
        if let columnLevelPermissionRulesContainer = columnLevelPermissionRulesContainer {
            columnLevelPermissionRulesDecoded0 = [QuickSightClientTypes.ColumnLevelPermissionRule]()
            for structure0 in columnLevelPermissionRulesContainer {
                if let structure0 = structure0 {
                    columnLevelPermissionRulesDecoded0?.append(structure0)
                }
            }
        }
        columnLevelPermissionRules = columnLevelPermissionRulesDecoded0
        let dataSetUsageConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSetUsageConfiguration.self, forKey: .dataSetUsageConfiguration)
        dataSetUsageConfiguration = dataSetUsageConfigurationDecoded
    }
}

extension UpdateDataSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDataSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDataSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDataSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDataSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.dataSetId = output.dataSetId
            self.ingestionArn = output.ingestionArn
            self.ingestionId = output.ingestionId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.dataSetId = nil
            self.ingestionArn = nil
            self.ingestionId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateDataSetOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset.
    public var arn: Swift.String?
    /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSetId: Swift.String?
    /// The ARN for the ingestion, which is triggered as a result of dataset creation if the import mode is SPICE.
    public var ingestionArn: Swift.String?
    /// The ID of the ingestion, which is triggered as a result of dataset creation if the import mode is SPICE.
    public var ingestionId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        ingestionArn: Swift.String? = nil,
        ingestionId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.dataSetId = dataSetId
        self.ingestionArn = ingestionArn
        self.ingestionId = ingestionId
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateDataSetOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let dataSetId: Swift.String?
    let ingestionArn: Swift.String?
    let ingestionId: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateDataSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case dataSetId = "DataSetId"
        case ingestionArn = "IngestionArn"
        case ingestionId = "IngestionId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let ingestionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ingestionArn)
        ingestionArn = ingestionArnDecoded
        let ingestionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ingestionId)
        ingestionId = ingestionIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateDataSetPermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantPermissions = grantPermissions {
            var grantPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantPermissions)
            for resourcepermissionlist0 in grantPermissions {
                try grantPermissionsContainer.encode(resourcepermissionlist0)
            }
        }
        if let revokePermissions = revokePermissions {
            var revokePermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revokePermissions)
            for resourcepermissionlist0 in revokePermissions {
                try revokePermissionsContainer.encode(resourcepermissionlist0)
            }
        }
    }
}

extension UpdateDataSetPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSetId = dataSetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/permissions"
    }
}

public struct UpdateDataSetPermissionsInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dataset whose permissions you want to update. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The resource permissions that you want to grant to the dataset.
    public var grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// The resource permissions that you want to revoke from the dataset.
    public var revokePermissions: [QuickSightClientTypes.ResourcePermission]?

    public init (
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        grantPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        revokePermissions: [QuickSightClientTypes.ResourcePermission]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
        self.grantPermissions = grantPermissions
        self.revokePermissions = revokePermissions
    }
}

struct UpdateDataSetPermissionsInputBody: Swift.Equatable {
    let grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    let revokePermissions: [QuickSightClientTypes.ResourcePermission]?
}

extension UpdateDataSetPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantPermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .grantPermissions)
        var grantPermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let grantPermissionsContainer = grantPermissionsContainer {
            grantPermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in grantPermissionsContainer {
                if let structure0 = structure0 {
                    grantPermissionsDecoded0?.append(structure0)
                }
            }
        }
        grantPermissions = grantPermissionsDecoded0
        let revokePermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .revokePermissions)
        var revokePermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let revokePermissionsContainer = revokePermissionsContainer {
            revokePermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in revokePermissionsContainer {
                if let structure0 = structure0 {
                    revokePermissionsDecoded0?.append(structure0)
                }
            }
        }
        revokePermissions = revokePermissionsDecoded0
    }
}

extension UpdateDataSetPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDataSetPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDataSetPermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDataSetPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDataSetPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSetArn = output.dataSetArn
            self.dataSetId = output.dataSetId
            self.requestId = output.requestId
        } else {
            self.dataSetArn = nil
            self.dataSetId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateDataSetPermissionsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset.
    public var dataSetArn: Swift.String?
    /// The ID for the dataset whose permissions you want to update. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSetId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dataSetArn: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSetArn = dataSetArn
        self.dataSetId = dataSetId
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateDataSetPermissionsOutputResponseBody: Swift.Equatable {
    let dataSetArn: Swift.String?
    let dataSetId: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateDataSetPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetArn = "DataSetArn"
        case dataSetId = "DataSetId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetArn)
        dataSetArn = dataSetArnDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateDataSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
        case dataSourceParameters = "DataSourceParameters"
        case name = "Name"
        case sslProperties = "SslProperties"
        case vpcConnectionProperties = "VpcConnectionProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credentials = credentials {
            try encodeContainer.encode(credentials, forKey: .credentials)
        }
        if let dataSourceParameters = dataSourceParameters {
            try encodeContainer.encode(dataSourceParameters, forKey: .dataSourceParameters)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sslProperties = sslProperties {
            try encodeContainer.encode(sslProperties, forKey: .sslProperties)
        }
        if let vpcConnectionProperties = vpcConnectionProperties {
            try encodeContainer.encode(vpcConnectionProperties, forKey: .vpcConnectionProperties)
        }
    }
}

extension UpdateDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSourceId = dataSourceId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sources/\(dataSourceId.urlPercentEncoding())"
    }
}

public struct UpdateDataSourceInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The credentials that Amazon QuickSight that uses to connect to your underlying source. Currently, only credentials based on user name and password are supported.
    public var credentials: QuickSightClientTypes.DataSourceCredentials?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The parameters that Amazon QuickSight uses to connect to your underlying source.
    public var dataSourceParameters: QuickSightClientTypes.DataSourceParameters?
    /// A display name for the data source.
    /// This member is required.
    public var name: Swift.String?
    /// Secure Socket Layer (SSL) properties that apply when Amazon QuickSight connects to your underlying source.
    public var sslProperties: QuickSightClientTypes.SslProperties?
    /// Use this parameter only when you want Amazon QuickSight to use a VPC connection when connecting to your underlying source.
    public var vpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties?

    public init (
        awsAccountId: Swift.String? = nil,
        credentials: QuickSightClientTypes.DataSourceCredentials? = nil,
        dataSourceId: Swift.String? = nil,
        dataSourceParameters: QuickSightClientTypes.DataSourceParameters? = nil,
        name: Swift.String? = nil,
        sslProperties: QuickSightClientTypes.SslProperties? = nil,
        vpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.credentials = credentials
        self.dataSourceId = dataSourceId
        self.dataSourceParameters = dataSourceParameters
        self.name = name
        self.sslProperties = sslProperties
        self.vpcConnectionProperties = vpcConnectionProperties
    }
}

struct UpdateDataSourceInputBody: Swift.Equatable {
    let name: Swift.String?
    let dataSourceParameters: QuickSightClientTypes.DataSourceParameters?
    let credentials: QuickSightClientTypes.DataSourceCredentials?
    let vpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties?
    let sslProperties: QuickSightClientTypes.SslProperties?
}

extension UpdateDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
        case dataSourceParameters = "DataSourceParameters"
        case name = "Name"
        case sslProperties = "SslProperties"
        case vpcConnectionProperties = "VpcConnectionProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataSourceParametersDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSourceParameters.self, forKey: .dataSourceParameters)
        dataSourceParameters = dataSourceParametersDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSourceCredentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let vpcConnectionPropertiesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VpcConnectionProperties.self, forKey: .vpcConnectionProperties)
        vpcConnectionProperties = vpcConnectionPropertiesDecoded
        let sslPropertiesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SslProperties.self, forKey: .sslProperties)
        sslProperties = sslPropertiesDecoded
    }
}

extension UpdateDataSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDataSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDataSourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDataSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.dataSourceId = output.dataSourceId
            self.requestId = output.requestId
            self.updateStatus = output.updateStatus
        } else {
            self.arn = nil
            self.dataSourceId = nil
            self.requestId = nil
            self.updateStatus = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateDataSourceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the data source.
    public var arn: Swift.String?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSourceId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The update status of the data source's last update.
    public var updateStatus: QuickSightClientTypes.ResourceStatus?

    public init (
        arn: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        updateStatus: QuickSightClientTypes.ResourceStatus? = nil
    )
    {
        self.arn = arn
        self.dataSourceId = dataSourceId
        self.requestId = requestId
        self.status = status
        self.updateStatus = updateStatus
    }
}

struct UpdateDataSourceOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let dataSourceId: Swift.String?
    let updateStatus: QuickSightClientTypes.ResourceStatus?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateDataSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case dataSourceId = "DataSourceId"
        case requestId = "RequestId"
        case status = "Status"
        case updateStatus = "UpdateStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let updateStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .updateStatus)
        updateStatus = updateStatusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateDataSourcePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantPermissions = grantPermissions {
            var grantPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantPermissions)
            for resourcepermissionlist0 in grantPermissions {
                try grantPermissionsContainer.encode(resourcepermissionlist0)
            }
        }
        if let revokePermissions = revokePermissions {
            var revokePermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revokePermissions)
            for resourcepermissionlist0 in revokePermissions {
                try revokePermissionsContainer.encode(resourcepermissionlist0)
            }
        }
    }
}

extension UpdateDataSourcePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSourceId = dataSourceId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sources/\(dataSourceId.urlPercentEncoding())/permissions"
    }
}

public struct UpdateDataSourcePermissionsInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// A list of resource permissions that you want to grant on the data source.
    public var grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// A list of resource permissions that you want to revoke on the data source.
    public var revokePermissions: [QuickSightClientTypes.ResourcePermission]?

    public init (
        awsAccountId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        grantPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        revokePermissions: [QuickSightClientTypes.ResourcePermission]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSourceId = dataSourceId
        self.grantPermissions = grantPermissions
        self.revokePermissions = revokePermissions
    }
}

struct UpdateDataSourcePermissionsInputBody: Swift.Equatable {
    let grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    let revokePermissions: [QuickSightClientTypes.ResourcePermission]?
}

extension UpdateDataSourcePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantPermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .grantPermissions)
        var grantPermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let grantPermissionsContainer = grantPermissionsContainer {
            grantPermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in grantPermissionsContainer {
                if let structure0 = structure0 {
                    grantPermissionsDecoded0?.append(structure0)
                }
            }
        }
        grantPermissions = grantPermissionsDecoded0
        let revokePermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .revokePermissions)
        var revokePermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let revokePermissionsContainer = revokePermissionsContainer {
            revokePermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in revokePermissionsContainer {
                if let structure0 = structure0 {
                    revokePermissionsDecoded0?.append(structure0)
                }
            }
        }
        revokePermissions = revokePermissionsDecoded0
    }
}

extension UpdateDataSourcePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDataSourcePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDataSourcePermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDataSourcePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDataSourcePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSourceArn = output.dataSourceArn
            self.dataSourceId = output.dataSourceId
            self.requestId = output.requestId
        } else {
            self.dataSourceArn = nil
            self.dataSourceId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateDataSourcePermissionsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the data source.
    public var dataSourceArn: Swift.String?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSourceId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dataSourceArn: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSourceArn = dataSourceArn
        self.dataSourceId = dataSourceId
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateDataSourcePermissionsOutputResponseBody: Swift.Equatable {
    let dataSourceArn: Swift.String?
    let dataSourceId: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateDataSourcePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceArn = "DataSourceArn"
        case dataSourceId = "DataSourceId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceArn)
        dataSourceArn = dataSourceArnDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateFolderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let folderId = folderId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())"
    }
}

public struct UpdateFolderInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the folder to update.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The name of the folder.
    /// This member is required.
    public var name: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
        self.name = name
    }
}

struct UpdateFolderInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateFolderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateFolderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFolderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFolderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFolderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFolderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.folderId = output.folderId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.folderId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateFolderOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the folder.
    public var arn: Swift.String?
    /// The ID of the folder.
    public var folderId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        folderId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.folderId = folderId
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateFolderOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let arn: Swift.String?
    let folderId: Swift.String?
    let requestId: Swift.String?
}

extension UpdateFolderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case folderId = "FolderId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let folderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .folderId)
        folderId = folderIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UpdateFolderPermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantPermissions = grantPermissions {
            var grantPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantPermissions)
            for resourcepermissionlist0 in grantPermissions {
                try grantPermissionsContainer.encode(resourcepermissionlist0)
            }
        }
        if let revokePermissions = revokePermissions {
            var revokePermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revokePermissions)
            for resourcepermissionlist0 in revokePermissions {
                try revokePermissionsContainer.encode(resourcepermissionlist0)
            }
        }
    }
}

extension UpdateFolderPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let folderId = folderId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())/permissions"
    }
}

public struct UpdateFolderPermissionsInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the folder to update.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The permissions that you want to grant on a resource.
    public var grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// The permissions that you want to revoke from a resource.
    public var revokePermissions: [QuickSightClientTypes.ResourcePermission]?

    public init (
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil,
        grantPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        revokePermissions: [QuickSightClientTypes.ResourcePermission]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
        self.grantPermissions = grantPermissions
        self.revokePermissions = revokePermissions
    }
}

struct UpdateFolderPermissionsInputBody: Swift.Equatable {
    let grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    let revokePermissions: [QuickSightClientTypes.ResourcePermission]?
}

extension UpdateFolderPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantPermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .grantPermissions)
        var grantPermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let grantPermissionsContainer = grantPermissionsContainer {
            grantPermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in grantPermissionsContainer {
                if let structure0 = structure0 {
                    grantPermissionsDecoded0?.append(structure0)
                }
            }
        }
        grantPermissions = grantPermissionsDecoded0
        let revokePermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .revokePermissions)
        var revokePermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let revokePermissionsContainer = revokePermissionsContainer {
            revokePermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in revokePermissionsContainer {
                if let structure0 = structure0 {
                    revokePermissionsDecoded0?.append(structure0)
                }
            }
        }
        revokePermissions = revokePermissionsDecoded0
    }
}

extension UpdateFolderPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFolderPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFolderPermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFolderPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFolderPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.folderId = output.folderId
            self.permissions = output.permissions
            self.requestId = output.requestId
            self.status = output.status
        } else {
            self.arn = nil
            self.folderId = nil
            self.permissions = nil
            self.requestId = nil
            self.status = 0
        }
    }
}

public struct UpdateFolderPermissionsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the folder.
    public var arn: Swift.String?
    /// The ID of the folder.
    public var folderId: Swift.String?
    /// Information about the permissions for the folder.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        folderId: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.folderId = folderId
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateFolderPermissionsOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let arn: Swift.String?
    let folderId: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let requestId: Swift.String?
}

extension UpdateFolderPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case folderId = "FolderId"
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let folderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .folderId)
        folderId = folderIdDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UpdateGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let groupName = groupName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups/\(groupName.urlPercentEncoding())"
    }
}

public struct UpdateGroupInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The description for the group that you want to update.
    public var description: Swift.String?
    /// The name of the group that you want to update.
    /// This member is required.
    public var groupName: Swift.String?
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        description: Swift.String? = nil,
        groupName: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.description = description
        self.groupName = groupName
        self.namespace = namespace
    }
}

struct UpdateGroupInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.group = output.group
            self.requestId = output.requestId
        } else {
            self.group = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateGroupOutputResponse: Swift.Equatable {
    /// The name of the group.
    public var group: QuickSightClientTypes.Group?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        group: QuickSightClientTypes.Group? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.group = group
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateGroupOutputResponseBody: Swift.Equatable {
    let group: QuickSightClientTypes.Group?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group = "Group"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Group.self, forKey: .group)
        group = groupDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateIAMPolicyAssignmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentStatus = "AssignmentStatus"
        case identities = "Identities"
        case policyArn = "PolicyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentStatus = assignmentStatus {
            try encodeContainer.encode(assignmentStatus.rawValue, forKey: .assignmentStatus)
        }
        if let identities = identities {
            var identitiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .identities)
            for (dictKey0, identitymap0) in identities {
                try identitiesContainer.encode(identitymap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
    }
}

extension UpdateIAMPolicyAssignmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let assignmentName = assignmentName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/iam-policy-assignments/\(assignmentName.urlPercentEncoding())"
    }
}

public struct UpdateIAMPolicyAssignmentInput: Swift.Equatable {
    /// The name of the assignment, also called a rule. This name must be unique within an Amazon Web Services account.
    /// This member is required.
    public var assignmentName: Swift.String?
    /// The status of the assignment. Possible values are as follows:
    ///
    /// * ENABLED - Anything specified in this assignment is used when creating the data source.
    ///
    /// * DISABLED - This assignment isn't used when creating the data source.
    ///
    /// * DRAFT - This assignment is an unfinished draft and isn't used when creating the data source.
    public var assignmentStatus: QuickSightClientTypes.AssignmentStatus?
    /// The ID of the Amazon Web Services account that contains the IAM policy assignment.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The Amazon QuickSight users, groups, or both that you want to assign the policy to.
    public var identities: [Swift.String:[Swift.String]]?
    /// The namespace of the assignment.
    /// This member is required.
    public var namespace: Swift.String?
    /// The ARN for the IAM policy to apply to the Amazon QuickSight users and groups specified in this assignment.
    public var policyArn: Swift.String?

    public init (
        assignmentName: Swift.String? = nil,
        assignmentStatus: QuickSightClientTypes.AssignmentStatus? = nil,
        awsAccountId: Swift.String? = nil,
        identities: [Swift.String:[Swift.String]]? = nil,
        namespace: Swift.String? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.assignmentName = assignmentName
        self.assignmentStatus = assignmentStatus
        self.awsAccountId = awsAccountId
        self.identities = identities
        self.namespace = namespace
        self.policyArn = policyArn
    }
}

struct UpdateIAMPolicyAssignmentInputBody: Swift.Equatable {
    let assignmentStatus: QuickSightClientTypes.AssignmentStatus?
    let policyArn: Swift.String?
    let identities: [Swift.String:[Swift.String]]?
}

extension UpdateIAMPolicyAssignmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentStatus = "AssignmentStatus"
        case identities = "Identities"
        case policyArn = "PolicyArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AssignmentStatus.self, forKey: .assignmentStatus)
        assignmentStatus = assignmentStatusDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let identitiesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .identities)
        var identitiesDecoded0: [Swift.String:[Swift.String]]? = nil
        if let identitiesContainer = identitiesContainer {
            identitiesDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, identitynamelist0) in identitiesContainer {
                var identitynamelist0Decoded0: [Swift.String]? = nil
                if let identitynamelist0 = identitynamelist0 {
                    identitynamelist0Decoded0 = [Swift.String]()
                    for string1 in identitynamelist0 {
                        if let string1 = string1 {
                            identitynamelist0Decoded0?.append(string1)
                        }
                    }
                }
                identitiesDecoded0?[key0] = identitynamelist0Decoded0
            }
        }
        identities = identitiesDecoded0
    }
}

extension UpdateIAMPolicyAssignmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIAMPolicyAssignmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentUpdatingException" : self = .concurrentUpdatingException(try ConcurrentUpdatingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIAMPolicyAssignmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case concurrentUpdatingException(ConcurrentUpdatingException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIAMPolicyAssignmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateIAMPolicyAssignmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assignmentId = output.assignmentId
            self.assignmentName = output.assignmentName
            self.assignmentStatus = output.assignmentStatus
            self.identities = output.identities
            self.policyArn = output.policyArn
            self.requestId = output.requestId
        } else {
            self.assignmentId = nil
            self.assignmentName = nil
            self.assignmentStatus = nil
            self.identities = nil
            self.policyArn = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateIAMPolicyAssignmentOutputResponse: Swift.Equatable {
    /// The ID of the assignment.
    public var assignmentId: Swift.String?
    /// The name of the assignment or rule.
    public var assignmentName: Swift.String?
    /// The status of the assignment. Possible values are as follows:
    ///
    /// * ENABLED - Anything specified in this assignment is used when creating the data source.
    ///
    /// * DISABLED - This assignment isn't used when creating the data source.
    ///
    /// * DRAFT - This assignment is an unfinished draft and isn't used when creating the data source.
    public var assignmentStatus: QuickSightClientTypes.AssignmentStatus?
    /// The Amazon QuickSight users, groups, or both that the IAM policy is assigned to.
    public var identities: [Swift.String:[Swift.String]]?
    /// The ARN for the IAM policy applied to the Amazon QuickSight users and groups specified in this assignment.
    public var policyArn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        assignmentId: Swift.String? = nil,
        assignmentName: Swift.String? = nil,
        assignmentStatus: QuickSightClientTypes.AssignmentStatus? = nil,
        identities: [Swift.String:[Swift.String]]? = nil,
        policyArn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.assignmentId = assignmentId
        self.assignmentName = assignmentName
        self.assignmentStatus = assignmentStatus
        self.identities = identities
        self.policyArn = policyArn
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateIAMPolicyAssignmentOutputResponseBody: Swift.Equatable {
    let assignmentName: Swift.String?
    let assignmentId: Swift.String?
    let policyArn: Swift.String?
    let identities: [Swift.String:[Swift.String]]?
    let assignmentStatus: QuickSightClientTypes.AssignmentStatus?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateIAMPolicyAssignmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentId = "AssignmentId"
        case assignmentName = "AssignmentName"
        case assignmentStatus = "AssignmentStatus"
        case identities = "Identities"
        case policyArn = "PolicyArn"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentName)
        assignmentName = assignmentNameDecoded
        let assignmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentId)
        assignmentId = assignmentIdDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let identitiesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .identities)
        var identitiesDecoded0: [Swift.String:[Swift.String]]? = nil
        if let identitiesContainer = identitiesContainer {
            identitiesDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, identitynamelist0) in identitiesContainer {
                var identitynamelist0Decoded0: [Swift.String]? = nil
                if let identitynamelist0 = identitynamelist0 {
                    identitynamelist0Decoded0 = [Swift.String]()
                    for string1 in identitynamelist0 {
                        if let string1 = string1 {
                            identitynamelist0Decoded0?.append(string1)
                        }
                    }
                }
                identitiesDecoded0?[key0] = identitynamelist0Decoded0
            }
        }
        identities = identitiesDecoded0
        let assignmentStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AssignmentStatus.self, forKey: .assignmentStatus)
        assignmentStatus = assignmentStatusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateIpRestrictionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case ipRestrictionRuleMap = "IpRestrictionRuleMap"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let ipRestrictionRuleMap = ipRestrictionRuleMap {
            var ipRestrictionRuleMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .ipRestrictionRuleMap)
            for (dictKey0, iprestrictionrulemap0) in ipRestrictionRuleMap {
                try ipRestrictionRuleMapContainer.encode(iprestrictionrulemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateIpRestrictionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/ip-restriction"
    }
}

public struct UpdateIpRestrictionInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the IP rules.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A value that specifies whether IP rules are turned on.
    public var enabled: Swift.Bool?
    /// A map that describes the updated IP rules with CIDR ranges and descriptions.
    public var ipRestrictionRuleMap: [Swift.String:Swift.String]?

    public init (
        awsAccountId: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        ipRestrictionRuleMap: [Swift.String:Swift.String]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.enabled = enabled
        self.ipRestrictionRuleMap = ipRestrictionRuleMap
    }
}

struct UpdateIpRestrictionInputBody: Swift.Equatable {
    let ipRestrictionRuleMap: [Swift.String:Swift.String]?
    let enabled: Swift.Bool?
}

extension UpdateIpRestrictionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case ipRestrictionRuleMap = "IpRestrictionRuleMap"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipRestrictionRuleMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .ipRestrictionRuleMap)
        var ipRestrictionRuleMapDecoded0: [Swift.String:Swift.String]? = nil
        if let ipRestrictionRuleMapContainer = ipRestrictionRuleMapContainer {
            ipRestrictionRuleMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, iprestrictionruledescription0) in ipRestrictionRuleMapContainer {
                if let iprestrictionruledescription0 = iprestrictionruledescription0 {
                    ipRestrictionRuleMapDecoded0?[key0] = iprestrictionruledescription0
                }
            }
        }
        ipRestrictionRuleMap = ipRestrictionRuleMapDecoded0
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension UpdateIpRestrictionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIpRestrictionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIpRestrictionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIpRestrictionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateIpRestrictionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awsAccountId = output.awsAccountId
            self.requestId = output.requestId
        } else {
            self.awsAccountId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateIpRestrictionOutputResponse: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the IP rules.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        awsAccountId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.awsAccountId = awsAccountId
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateIpRestrictionOutputResponseBody: Swift.Equatable {
    let awsAccountId: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateIpRestrictionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId = "AwsAccountId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateTemplateAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateVersionNumber = "TemplateVersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateVersionNumber = templateVersionNumber {
            try encodeContainer.encode(templateVersionNumber, forKey: .templateVersionNumber)
        }
    }
}

extension UpdateTemplateAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        guard let aliasName = aliasName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/aliases/\(aliasName.urlPercentEncoding())"
    }
}

public struct UpdateTemplateAliasInput: Swift.Equatable {
    /// The alias of the template that you want to update. If you name a specific alias, you update the version that the alias points to. You can specify the latest version of the template by providing the keyword $LATEST in the AliasName parameter. The keyword $PUBLISHED doesn't apply to templates.
    /// This member is required.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the template alias that you're updating.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the template.
    /// This member is required.
    public var templateId: Swift.String?
    /// The version number of the template.
    /// This member is required.
    public var templateVersionNumber: Swift.Int?

    public init (
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        templateId: Swift.String? = nil,
        templateVersionNumber: Swift.Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.templateId = templateId
        self.templateVersionNumber = templateVersionNumber
    }
}

struct UpdateTemplateAliasInputBody: Swift.Equatable {
    let templateVersionNumber: Swift.Int?
}

extension UpdateTemplateAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateVersionNumber = "TemplateVersionNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .templateVersionNumber)
        templateVersionNumber = templateVersionNumberDecoded
    }
}

extension UpdateTemplateAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTemplateAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTemplateAliasOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTemplateAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateTemplateAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.templateAlias = output.templateAlias
        } else {
            self.requestId = nil
            self.templateAlias = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateTemplateAliasOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The template alias.
    public var templateAlias: QuickSightClientTypes.TemplateAlias?

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateAlias: QuickSightClientTypes.TemplateAlias? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.templateAlias = templateAlias
    }
}

struct UpdateTemplateAliasOutputResponseBody: Swift.Equatable {
    let templateAlias: QuickSightClientTypes.TemplateAlias?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension UpdateTemplateAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case templateAlias = "TemplateAlias"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateAliasDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TemplateAlias.self, forKey: .templateAlias)
        templateAlias = templateAliasDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UpdateTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case sourceEntity = "SourceEntity"
        case versionDescription = "VersionDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceEntity = sourceEntity {
            try encodeContainer.encode(sourceEntity, forKey: .sourceEntity)
        }
        if let versionDescription = versionDescription {
            try encodeContainer.encode(versionDescription, forKey: .versionDescription)
        }
    }
}

extension UpdateTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())"
    }
}

public struct UpdateTemplateInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the template that you're updating.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The name for the template.
    public var name: Swift.String?
    /// The entity that you are using as a source when you update the template. In SourceEntity, you specify the type of object you're using as source: SourceTemplate for a template or SourceAnalysis for an analysis. Both of these require an Amazon Resource Name (ARN). For SourceTemplate, specify the ARN of the source template. For SourceAnalysis, specify the ARN of the source analysis. The SourceTemplate ARN can contain any Amazon Web Services account and any Amazon QuickSight-supported Amazon Web Services Region;. Use the DataSetReferences entity within SourceTemplate or SourceAnalysis to list the replacement datasets for the placeholders listed in the original. The schema in each dataset must match its placeholder.
    /// This member is required.
    public var sourceEntity: QuickSightClientTypes.TemplateSourceEntity?
    /// The ID for the template.
    /// This member is required.
    public var templateId: Swift.String?
    /// A description of the current template version that is being updated. Every time you call UpdateTemplate, you create a new version of the template. Each version of the template maintains a description of the version in the VersionDescription field.
    public var versionDescription: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        name: Swift.String? = nil,
        sourceEntity: QuickSightClientTypes.TemplateSourceEntity? = nil,
        templateId: Swift.String? = nil,
        versionDescription: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.name = name
        self.sourceEntity = sourceEntity
        self.templateId = templateId
        self.versionDescription = versionDescription
    }
}

struct UpdateTemplateInputBody: Swift.Equatable {
    let sourceEntity: QuickSightClientTypes.TemplateSourceEntity?
    let versionDescription: Swift.String?
    let name: Swift.String?
}

extension UpdateTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case sourceEntity = "SourceEntity"
        case versionDescription = "VersionDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceEntityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TemplateSourceEntity.self, forKey: .sourceEntity)
        sourceEntity = sourceEntityDecoded
        let versionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionDescription)
        versionDescription = versionDescriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTemplateOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationStatus = output.creationStatus
            self.requestId = output.requestId
            self.templateId = output.templateId
            self.versionArn = output.versionArn
        } else {
            self.arn = nil
            self.creationStatus = nil
            self.requestId = nil
            self.templateId = nil
            self.versionArn = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateTemplateOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the template.
    public var arn: Swift.String?
    /// The creation status of the template.
    public var creationStatus: QuickSightClientTypes.ResourceStatus?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ID for the template.
    public var templateId: Swift.String?
    /// The ARN for the template, including the version information of the first version.
    public var versionArn: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.ResourceStatus? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateId: Swift.String? = nil,
        versionArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.requestId = requestId
        self.status = status
        self.templateId = templateId
        self.versionArn = versionArn
    }
}

struct UpdateTemplateOutputResponseBody: Swift.Equatable {
    let templateId: Swift.String?
    let arn: Swift.String?
    let versionArn: Swift.String?
    let creationStatus: QuickSightClientTypes.ResourceStatus?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension UpdateTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationStatus = "CreationStatus"
        case requestId = "RequestId"
        case status = "Status"
        case templateId = "TemplateId"
        case versionArn = "VersionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionArn)
        versionArn = versionArnDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UpdateTemplatePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantPermissions = grantPermissions {
            var grantPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantPermissions)
            for updateresourcepermissionlist0 in grantPermissions {
                try grantPermissionsContainer.encode(updateresourcepermissionlist0)
            }
        }
        if let revokePermissions = revokePermissions {
            var revokePermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revokePermissions)
            for updateresourcepermissionlist0 in revokePermissions {
                try revokePermissionsContainer.encode(updateresourcepermissionlist0)
            }
        }
    }
}

extension UpdateTemplatePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/permissions"
    }
}

public struct UpdateTemplatePermissionsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the template.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A list of resource permissions to be granted on the template.
    public var grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// A list of resource permissions to be revoked from the template.
    public var revokePermissions: [QuickSightClientTypes.ResourcePermission]?
    /// The ID for the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        grantPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        revokePermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.grantPermissions = grantPermissions
        self.revokePermissions = revokePermissions
        self.templateId = templateId
    }
}

struct UpdateTemplatePermissionsInputBody: Swift.Equatable {
    let grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    let revokePermissions: [QuickSightClientTypes.ResourcePermission]?
}

extension UpdateTemplatePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantPermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .grantPermissions)
        var grantPermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let grantPermissionsContainer = grantPermissionsContainer {
            grantPermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in grantPermissionsContainer {
                if let structure0 = structure0 {
                    grantPermissionsDecoded0?.append(structure0)
                }
            }
        }
        grantPermissions = grantPermissionsDecoded0
        let revokePermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .revokePermissions)
        var revokePermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let revokePermissionsContainer = revokePermissionsContainer {
            revokePermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in revokePermissionsContainer {
                if let structure0 = structure0 {
                    revokePermissionsDecoded0?.append(structure0)
                }
            }
        }
        revokePermissions = revokePermissionsDecoded0
    }
}

extension UpdateTemplatePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTemplatePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTemplatePermissionsOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTemplatePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateTemplatePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.permissions = output.permissions
            self.requestId = output.requestId
            self.templateArn = output.templateArn
            self.templateId = output.templateId
        } else {
            self.permissions = nil
            self.requestId = nil
            self.templateArn = nil
            self.templateId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateTemplatePermissionsOutputResponse: Swift.Equatable {
    /// A list of resource permissions to be set on the template.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The Amazon Resource Name (ARN) of the template.
    public var templateArn: Swift.String?
    /// The ID for the template.
    public var templateId: Swift.String?

    public init (
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateArn: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
        self.templateArn = templateArn
        self.templateId = templateId
    }
}

struct UpdateTemplatePermissionsOutputResponseBody: Swift.Equatable {
    let templateId: Swift.String?
    let templateArn: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateTemplatePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
        case templateArn = "TemplateArn"
        case templateId = "TemplateId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateThemeAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case themeVersionNumber = "ThemeVersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let themeVersionNumber = themeVersionNumber {
            try encodeContainer.encode(themeVersionNumber, forKey: .themeVersionNumber)
        }
    }
}

extension UpdateThemeAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let themeId = themeId else {
            return nil
        }
        guard let aliasName = aliasName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())/aliases/\(aliasName.urlPercentEncoding())"
    }
}

public struct UpdateThemeAliasInput: Swift.Equatable {
    /// The name of the theme alias that you want to update.
    /// This member is required.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the theme alias that you're updating.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the theme.
    /// This member is required.
    public var themeId: Swift.String?
    /// The version number of the theme that the alias should reference.
    /// This member is required.
    public var themeVersionNumber: Swift.Int?

    public init (
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        themeId: Swift.String? = nil,
        themeVersionNumber: Swift.Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.themeId = themeId
        self.themeVersionNumber = themeVersionNumber
    }
}

struct UpdateThemeAliasInputBody: Swift.Equatable {
    let themeVersionNumber: Swift.Int?
}

extension UpdateThemeAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case themeVersionNumber = "ThemeVersionNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .themeVersionNumber)
        themeVersionNumber = themeVersionNumberDecoded
    }
}

extension UpdateThemeAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateThemeAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateThemeAliasOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateThemeAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateThemeAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.themeAlias = output.themeAlias
        } else {
            self.requestId = nil
            self.themeAlias = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateThemeAliasOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// Information about the theme alias.
    public var themeAlias: QuickSightClientTypes.ThemeAlias?

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeAlias: QuickSightClientTypes.ThemeAlias? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.themeAlias = themeAlias
    }
}

struct UpdateThemeAliasOutputResponseBody: Swift.Equatable {
    let themeAlias: QuickSightClientTypes.ThemeAlias?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension UpdateThemeAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case themeAlias = "ThemeAlias"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeAliasDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ThemeAlias.self, forKey: .themeAlias)
        themeAlias = themeAliasDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UpdateThemeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseThemeId = "BaseThemeId"
        case configuration = "Configuration"
        case name = "Name"
        case versionDescription = "VersionDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseThemeId = baseThemeId {
            try encodeContainer.encode(baseThemeId, forKey: .baseThemeId)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let versionDescription = versionDescription {
            try encodeContainer.encode(versionDescription, forKey: .versionDescription)
        }
    }
}

extension UpdateThemeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let themeId = themeId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())"
    }
}

public struct UpdateThemeInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the theme that you're updating.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The theme ID, defined by Amazon QuickSight, that a custom theme inherits from. All themes initially inherit from a default Amazon QuickSight theme.
    /// This member is required.
    public var baseThemeId: Swift.String?
    /// The theme configuration, which contains the theme display properties.
    public var configuration: QuickSightClientTypes.ThemeConfiguration?
    /// The name for the theme.
    public var name: Swift.String?
    /// The ID for the theme.
    /// This member is required.
    public var themeId: Swift.String?
    /// A description of the theme version that you're updating Every time that you call UpdateTheme, you create a new version of the theme. Each version of the theme maintains a description of the version in VersionDescription.
    public var versionDescription: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        baseThemeId: Swift.String? = nil,
        configuration: QuickSightClientTypes.ThemeConfiguration? = nil,
        name: Swift.String? = nil,
        themeId: Swift.String? = nil,
        versionDescription: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.baseThemeId = baseThemeId
        self.configuration = configuration
        self.name = name
        self.themeId = themeId
        self.versionDescription = versionDescription
    }
}

struct UpdateThemeInputBody: Swift.Equatable {
    let name: Swift.String?
    let baseThemeId: Swift.String?
    let versionDescription: Swift.String?
    let configuration: QuickSightClientTypes.ThemeConfiguration?
}

extension UpdateThemeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseThemeId = "BaseThemeId"
        case configuration = "Configuration"
        case name = "Name"
        case versionDescription = "VersionDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let baseThemeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseThemeId)
        baseThemeId = baseThemeIdDecoded
        let versionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionDescription)
        versionDescription = versionDescriptionDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ThemeConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension UpdateThemeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateThemeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateThemeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateThemeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateThemeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationStatus = output.creationStatus
            self.requestId = output.requestId
            self.themeId = output.themeId
            self.versionArn = output.versionArn
        } else {
            self.arn = nil
            self.creationStatus = nil
            self.requestId = nil
            self.themeId = nil
            self.versionArn = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateThemeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the theme.
    public var arn: Swift.String?
    /// The creation status of the theme.
    public var creationStatus: QuickSightClientTypes.ResourceStatus?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ID for the theme.
    public var themeId: Swift.String?
    /// The Amazon Resource Name (ARN) for the new version of the theme.
    public var versionArn: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.ResourceStatus? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeId: Swift.String? = nil,
        versionArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.requestId = requestId
        self.status = status
        self.themeId = themeId
        self.versionArn = versionArn
    }
}

struct UpdateThemeOutputResponseBody: Swift.Equatable {
    let themeId: Swift.String?
    let arn: Swift.String?
    let versionArn: Swift.String?
    let creationStatus: QuickSightClientTypes.ResourceStatus?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension UpdateThemeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationStatus = "CreationStatus"
        case requestId = "RequestId"
        case status = "Status"
        case themeId = "ThemeId"
        case versionArn = "VersionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeId)
        themeId = themeIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionArn)
        versionArn = versionArnDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UpdateThemePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantPermissions = grantPermissions {
            var grantPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantPermissions)
            for updateresourcepermissionlist0 in grantPermissions {
                try grantPermissionsContainer.encode(updateresourcepermissionlist0)
            }
        }
        if let revokePermissions = revokePermissions {
            var revokePermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revokePermissions)
            for updateresourcepermissionlist0 in revokePermissions {
                try revokePermissionsContainer.encode(updateresourcepermissionlist0)
            }
        }
    }
}

extension UpdateThemePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let themeId = themeId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())/permissions"
    }
}

public struct UpdateThemePermissionsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the theme.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A list of resource permissions to be granted for the theme.
    public var grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// A list of resource permissions to be revoked from the theme.
    public var revokePermissions: [QuickSightClientTypes.ResourcePermission]?
    /// The ID for the theme.
    /// This member is required.
    public var themeId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        grantPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        revokePermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        themeId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.grantPermissions = grantPermissions
        self.revokePermissions = revokePermissions
        self.themeId = themeId
    }
}

struct UpdateThemePermissionsInputBody: Swift.Equatable {
    let grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    let revokePermissions: [QuickSightClientTypes.ResourcePermission]?
}

extension UpdateThemePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantPermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .grantPermissions)
        var grantPermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let grantPermissionsContainer = grantPermissionsContainer {
            grantPermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in grantPermissionsContainer {
                if let structure0 = structure0 {
                    grantPermissionsDecoded0?.append(structure0)
                }
            }
        }
        grantPermissions = grantPermissionsDecoded0
        let revokePermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .revokePermissions)
        var revokePermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let revokePermissionsContainer = revokePermissionsContainer {
            revokePermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in revokePermissionsContainer {
                if let structure0 = structure0 {
                    revokePermissionsDecoded0?.append(structure0)
                }
            }
        }
        revokePermissions = revokePermissionsDecoded0
    }
}

extension UpdateThemePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateThemePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateThemePermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateThemePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateThemePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.permissions = output.permissions
            self.requestId = output.requestId
            self.themeArn = output.themeArn
            self.themeId = output.themeId
        } else {
            self.permissions = nil
            self.requestId = nil
            self.themeArn = nil
            self.themeId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateThemePermissionsOutputResponse: Swift.Equatable {
    /// The resulting list of resource permissions for the theme.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The Amazon Resource Name (ARN) of the theme.
    public var themeArn: Swift.String?
    /// The ID for the theme.
    public var themeId: Swift.String?

    public init (
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeArn: Swift.String? = nil,
        themeId: Swift.String? = nil
    )
    {
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
        self.themeArn = themeArn
        self.themeId = themeId
    }
}

struct UpdateThemePermissionsOutputResponseBody: Swift.Equatable {
    let themeId: Swift.String?
    let themeArn: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateThemePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
        case themeArn = "ThemeArn"
        case themeId = "ThemeId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeId)
        themeId = themeIdDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customFederationProviderUrl = "CustomFederationProviderUrl"
        case customPermissionsName = "CustomPermissionsName"
        case email = "Email"
        case externalLoginFederationProviderType = "ExternalLoginFederationProviderType"
        case externalLoginId = "ExternalLoginId"
        case role = "Role"
        case unapplyCustomPermissions = "UnapplyCustomPermissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customFederationProviderUrl = customFederationProviderUrl {
            try encodeContainer.encode(customFederationProviderUrl, forKey: .customFederationProviderUrl)
        }
        if let customPermissionsName = customPermissionsName {
            try encodeContainer.encode(customPermissionsName, forKey: .customPermissionsName)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let externalLoginFederationProviderType = externalLoginFederationProviderType {
            try encodeContainer.encode(externalLoginFederationProviderType, forKey: .externalLoginFederationProviderType)
        }
        if let externalLoginId = externalLoginId {
            try encodeContainer.encode(externalLoginId, forKey: .externalLoginId)
        }
        if let role = role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
        if unapplyCustomPermissions != false {
            try encodeContainer.encode(unapplyCustomPermissions, forKey: .unapplyCustomPermissions)
        }
    }
}

extension UpdateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let userName = userName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/users/\(userName.urlPercentEncoding())"
    }
}

public struct UpdateUserInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The URL of the custom OpenID Connect (OIDC) provider that provides identity to let a user federate into Amazon QuickSight with an associated Identity and Access Management(IAM) role. This parameter should only be used when ExternalLoginFederationProviderType parameter is set to CUSTOM_OIDC.
    public var customFederationProviderUrl: Swift.String?
    /// (Enterprise edition only) The name of the custom permissions profile that you want to assign to this user. Customized permissions allows you to control a user's access by restricting access the following operations:
    ///
    /// * Create and update data sources
    ///
    /// * Create and update datasets
    ///
    /// * Create and update email reports
    ///
    /// * Subscribe to email reports
    ///
    ///
    /// A set of custom permissions includes any combination of these restrictions. Currently, you need to create the profile names for custom permission sets by using the Amazon QuickSight console. Then, you use the RegisterUser API operation to assign the named set of permissions to a QuickSight user. Amazon QuickSight custom permissions are applied through IAM policies. Therefore, they override the permissions typically granted by assigning Amazon QuickSight users to one of the default security cohorts in Amazon QuickSight (admin, author, reader). This feature is available only to Amazon QuickSight Enterprise edition subscriptions.
    public var customPermissionsName: Swift.String?
    /// The email address of the user that you want to update.
    /// This member is required.
    public var email: Swift.String?
    /// The type of supported external login provider that provides identity to let a user federate into Amazon QuickSight with an associated Identity and Access Management(IAM) role. The type of supported external login provider can be one of the following.
    ///
    /// * COGNITO: Amazon Cognito. The provider URL is cognito-identity.amazonaws.com. When choosing the COGNITO provider type, dont use the "CustomFederationProviderUrl" parameter which is only needed when the external provider is custom.
    ///
    /// * CUSTOM_OIDC: Custom OpenID Connect (OIDC) provider. When choosing CUSTOM_OIDC type, use the CustomFederationProviderUrl parameter to provide the custom OIDC provider URL.
    ///
    /// * NONE: This clears all the previously saved external login information for a user. Use the [DescribeUser](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DescribeUser.html) API operation to check the external login information.
    public var externalLoginFederationProviderType: Swift.String?
    /// The identity ID for a user in the external login provider.
    public var externalLoginId: Swift.String?
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon QuickSight role of the user. The role can be one of the following default security cohorts:
    ///
    /// * READER: A user who has read-only access to dashboards.
    ///
    /// * AUTHOR: A user who can create data sources, datasets, analyses, and dashboards.
    ///
    /// * ADMIN: A user who is an author, who can also manage Amazon QuickSight settings.
    ///
    ///
    /// The name of the Amazon QuickSight role is invisible to the user except for the console screens dealing with permissions.
    /// This member is required.
    public var role: QuickSightClientTypes.UserRole?
    /// A flag that you use to indicate that you want to remove all custom permissions from this user. Using this parameter resets the user to the state it was in before a custom permissions profile was applied. This parameter defaults to NULL and it doesn't accept any other value.
    public var unapplyCustomPermissions: Swift.Bool
    /// The Amazon QuickSight user name that you want to update.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        customFederationProviderUrl: Swift.String? = nil,
        customPermissionsName: Swift.String? = nil,
        email: Swift.String? = nil,
        externalLoginFederationProviderType: Swift.String? = nil,
        externalLoginId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        role: QuickSightClientTypes.UserRole? = nil,
        unapplyCustomPermissions: Swift.Bool = false,
        userName: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.customFederationProviderUrl = customFederationProviderUrl
        self.customPermissionsName = customPermissionsName
        self.email = email
        self.externalLoginFederationProviderType = externalLoginFederationProviderType
        self.externalLoginId = externalLoginId
        self.namespace = namespace
        self.role = role
        self.unapplyCustomPermissions = unapplyCustomPermissions
        self.userName = userName
    }
}

struct UpdateUserInputBody: Swift.Equatable {
    let email: Swift.String?
    let role: QuickSightClientTypes.UserRole?
    let customPermissionsName: Swift.String?
    let unapplyCustomPermissions: Swift.Bool
    let externalLoginFederationProviderType: Swift.String?
    let customFederationProviderUrl: Swift.String?
    let externalLoginId: Swift.String?
}

extension UpdateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customFederationProviderUrl = "CustomFederationProviderUrl"
        case customPermissionsName = "CustomPermissionsName"
        case email = "Email"
        case externalLoginFederationProviderType = "ExternalLoginFederationProviderType"
        case externalLoginId = "ExternalLoginId"
        case role = "Role"
        case unapplyCustomPermissions = "UnapplyCustomPermissions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let roleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.UserRole.self, forKey: .role)
        role = roleDecoded
        let customPermissionsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customPermissionsName)
        customPermissionsName = customPermissionsNameDecoded
        let unapplyCustomPermissionsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .unapplyCustomPermissions)
        unapplyCustomPermissions = unapplyCustomPermissionsDecoded
        let externalLoginFederationProviderTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalLoginFederationProviderType)
        externalLoginFederationProviderType = externalLoginFederationProviderTypeDecoded
        let customFederationProviderUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customFederationProviderUrl)
        customFederationProviderUrl = customFederationProviderUrlDecoded
        let externalLoginIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalLoginId)
        externalLoginId = externalLoginIdDecoded
    }
}

extension UpdateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.user = output.user
        } else {
            self.requestId = nil
            self.user = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateUserOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The Amazon QuickSight user.
    public var user: QuickSightClientTypes.User?

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        user: QuickSightClientTypes.User? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.user = user
    }
}

struct UpdateUserOutputResponseBody: Swift.Equatable {
    let user: QuickSightClientTypes.User?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case user = "User"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.User.self, forKey: .user)
        user = userDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension QuickSightClientTypes.UploadSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containsHeader = "ContainsHeader"
        case delimiter = "Delimiter"
        case format = "Format"
        case startFromRow = "StartFromRow"
        case textQualifier = "TextQualifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if containsHeader != false {
            try encodeContainer.encode(containsHeader, forKey: .containsHeader)
        }
        if let delimiter = delimiter {
            try encodeContainer.encode(delimiter, forKey: .delimiter)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if startFromRow != 0 {
            try encodeContainer.encode(startFromRow, forKey: .startFromRow)
        }
        if let textQualifier = textQualifier {
            try encodeContainer.encode(textQualifier.rawValue, forKey: .textQualifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FileFormat.self, forKey: .format)
        format = formatDecoded
        let startFromRowDecoded = try containerValues.decode(Swift.Int.self, forKey: .startFromRow)
        startFromRow = startFromRowDecoded
        let containsHeaderDecoded = try containerValues.decode(Swift.Bool.self, forKey: .containsHeader)
        containsHeader = containsHeaderDecoded
        let textQualifierDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TextQualifier.self, forKey: .textQualifier)
        textQualifier = textQualifierDecoded
        let delimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
    }
}

extension QuickSightClientTypes {
    /// Information about the format for a source file or files.
    public struct UploadSettings: Swift.Equatable {
        /// Whether the file has a header row, or the files each have a header row.
        public var containsHeader: Swift.Bool
        /// The delimiter between values in the file.
        public var delimiter: Swift.String?
        /// File format.
        public var format: QuickSightClientTypes.FileFormat?
        /// A row number to start reading data from.
        public var startFromRow: Swift.Int
        /// Text qualifier.
        public var textQualifier: QuickSightClientTypes.TextQualifier?

        public init (
            containsHeader: Swift.Bool = false,
            delimiter: Swift.String? = nil,
            format: QuickSightClientTypes.FileFormat? = nil,
            startFromRow: Swift.Int = 0,
            textQualifier: QuickSightClientTypes.TextQualifier? = nil
        )
        {
            self.containsHeader = containsHeader
            self.delimiter = delimiter
            self.format = format
            self.startFromRow = startFromRow
            self.textQualifier = textQualifier
        }
    }

}

extension QuickSightClientTypes.User: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case active = "Active"
        case arn = "Arn"
        case customPermissionsName = "CustomPermissionsName"
        case email = "Email"
        case externalLoginFederationProviderType = "ExternalLoginFederationProviderType"
        case externalLoginFederationProviderUrl = "ExternalLoginFederationProviderUrl"
        case externalLoginId = "ExternalLoginId"
        case identityType = "IdentityType"
        case principalId = "PrincipalId"
        case role = "Role"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if active != false {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let customPermissionsName = customPermissionsName {
            try encodeContainer.encode(customPermissionsName, forKey: .customPermissionsName)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let externalLoginFederationProviderType = externalLoginFederationProviderType {
            try encodeContainer.encode(externalLoginFederationProviderType, forKey: .externalLoginFederationProviderType)
        }
        if let externalLoginFederationProviderUrl = externalLoginFederationProviderUrl {
            try encodeContainer.encode(externalLoginFederationProviderUrl, forKey: .externalLoginFederationProviderUrl)
        }
        if let externalLoginId = externalLoginId {
            try encodeContainer.encode(externalLoginId, forKey: .externalLoginId)
        }
        if let identityType = identityType {
            try encodeContainer.encode(identityType.rawValue, forKey: .identityType)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let role = role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let roleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.UserRole.self, forKey: .role)
        role = roleDecoded
        let identityTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IdentityType.self, forKey: .identityType)
        identityType = identityTypeDecoded
        let activeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let customPermissionsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customPermissionsName)
        customPermissionsName = customPermissionsNameDecoded
        let externalLoginFederationProviderTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalLoginFederationProviderType)
        externalLoginFederationProviderType = externalLoginFederationProviderTypeDecoded
        let externalLoginFederationProviderUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalLoginFederationProviderUrl)
        externalLoginFederationProviderUrl = externalLoginFederationProviderUrlDecoded
        let externalLoginIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalLoginId)
        externalLoginId = externalLoginIdDecoded
    }
}

extension QuickSightClientTypes {
    /// A registered user of Amazon QuickSight.
    public struct User: Swift.Equatable {
        /// The active status of user. When you create an Amazon QuickSight user thats not an IAM user or an Active Directory user, that user is inactive until they sign in and provide a password.
        public var active: Swift.Bool
        /// The Amazon Resource Name (ARN) for the user.
        public var arn: Swift.String?
        /// The custom permissions profile associated with this user.
        public var customPermissionsName: Swift.String?
        /// The user's email address.
        public var email: Swift.String?
        /// The type of supported external login provider that provides identity to let the user federate into Amazon QuickSight with an associated IAM role. The type can be one of the following.
        ///
        /// * COGNITO: Amazon Cognito. The provider URL is cognito-identity.amazonaws.com.
        ///
        /// * CUSTOM_OIDC: Custom OpenID Connect (OIDC) provider.
        public var externalLoginFederationProviderType: Swift.String?
        /// The URL of the external login provider.
        public var externalLoginFederationProviderUrl: Swift.String?
        /// The identity ID for the user in the external login provider.
        public var externalLoginId: Swift.String?
        /// The type of identity authentication used by the user.
        public var identityType: QuickSightClientTypes.IdentityType?
        /// The principal ID of the user.
        public var principalId: Swift.String?
        /// The Amazon QuickSight role for the user. The user role can be one of the following:.
        ///
        /// * READER: A user who has read-only access to dashboards.
        ///
        /// * AUTHOR: A user who can create data sources, datasets, analyses, and dashboards.
        ///
        /// * ADMIN: A user who is an author, who can also manage Amazon Amazon QuickSight settings.
        ///
        /// * RESTRICTED_READER: This role isn't currently available for use.
        ///
        /// * RESTRICTED_AUTHOR: This role isn't currently available for use.
        public var role: QuickSightClientTypes.UserRole?
        /// The user's user name. In the output, the value for UserName is N/A when the value for IdentityType is IAM and the corresponding IAM user is deleted.
        public var userName: Swift.String?

        public init (
            active: Swift.Bool = false,
            arn: Swift.String? = nil,
            customPermissionsName: Swift.String? = nil,
            email: Swift.String? = nil,
            externalLoginFederationProviderType: Swift.String? = nil,
            externalLoginFederationProviderUrl: Swift.String? = nil,
            externalLoginId: Swift.String? = nil,
            identityType: QuickSightClientTypes.IdentityType? = nil,
            principalId: Swift.String? = nil,
            role: QuickSightClientTypes.UserRole? = nil,
            userName: Swift.String? = nil
        )
        {
            self.active = active
            self.arn = arn
            self.customPermissionsName = customPermissionsName
            self.email = email
            self.externalLoginFederationProviderType = externalLoginFederationProviderType
            self.externalLoginFederationProviderUrl = externalLoginFederationProviderUrl
            self.externalLoginId = externalLoginId
            self.identityType = identityType
            self.principalId = principalId
            self.role = role
            self.userName = userName
        }
    }

}

extension QuickSightClientTypes {
    public enum UserRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case admin
        case author
        case reader
        case restrictedAuthor
        case restrictedReader
        case sdkUnknown(Swift.String)

        public static var allCases: [UserRole] {
            return [
                .admin,
                .author,
                .reader,
                .restrictedAuthor,
                .restrictedReader,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .admin: return "ADMIN"
            case .author: return "AUTHOR"
            case .reader: return "READER"
            case .restrictedAuthor: return "RESTRICTED_AUTHOR"
            case .restrictedReader: return "RESTRICTED_READER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserRole(rawValue: rawValue) ?? UserRole.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.VpcConnectionProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcConnectionArn = "VpcConnectionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vpcConnectionArn = vpcConnectionArn {
            try encodeContainer.encode(vpcConnectionArn, forKey: .vpcConnectionArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConnectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcConnectionArn)
        vpcConnectionArn = vpcConnectionArnDecoded
    }
}

extension QuickSightClientTypes {
    /// VPC connection properties.
    public struct VpcConnectionProperties: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the VPC connection.
        /// This member is required.
        public var vpcConnectionArn: Swift.String?

        public init (
            vpcConnectionArn: Swift.String? = nil
        )
        {
            self.vpcConnectionArn = vpcConnectionArn
        }
    }

}
