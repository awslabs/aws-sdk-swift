// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You don't have access to this item. The provided credentials couldn't be validated. You might not be authorized to carry out the request. Make sure that your account is authorized to use the Amazon QuickSight service, that your policies have the correct permissions, and that you are using the correct access keys.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.AccountCustomization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultEmailCustomizationTemplate = "DefaultEmailCustomizationTemplate"
        case defaultTheme = "DefaultTheme"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultEmailCustomizationTemplate = self.defaultEmailCustomizationTemplate {
            try encodeContainer.encode(defaultEmailCustomizationTemplate, forKey: .defaultEmailCustomizationTemplate)
        }
        if let defaultTheme = self.defaultTheme {
            try encodeContainer.encode(defaultTheme, forKey: .defaultTheme)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultThemeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultTheme)
        defaultTheme = defaultThemeDecoded
        let defaultEmailCustomizationTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultEmailCustomizationTemplate)
        defaultEmailCustomizationTemplate = defaultEmailCustomizationTemplateDecoded
    }
}

extension QuickSightClientTypes {
    /// The Amazon QuickSight customizations associated with your Amazon Web Services account or a QuickSight namespace in a specific Amazon Web Services Region.
    public struct AccountCustomization: Swift.Equatable {
        /// The default email customization template.
        public var defaultEmailCustomizationTemplate: Swift.String?
        /// The default theme for this Amazon QuickSight subscription.
        public var defaultTheme: Swift.String?

        public init (
            defaultEmailCustomizationTemplate: Swift.String? = nil,
            defaultTheme: Swift.String? = nil
        )
        {
            self.defaultEmailCustomizationTemplate = defaultEmailCustomizationTemplate
            self.defaultTheme = defaultTheme
        }
    }

}

extension QuickSightClientTypes.AccountInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountName = "AccountName"
        case accountSubscriptionStatus = "AccountSubscriptionStatus"
        case authenticationType = "AuthenticationType"
        case edition = "Edition"
        case notificationEmail = "NotificationEmail"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountName = self.accountName {
            try encodeContainer.encode(accountName, forKey: .accountName)
        }
        if let accountSubscriptionStatus = self.accountSubscriptionStatus {
            try encodeContainer.encode(accountSubscriptionStatus, forKey: .accountSubscriptionStatus)
        }
        if let authenticationType = self.authenticationType {
            try encodeContainer.encode(authenticationType, forKey: .authenticationType)
        }
        if let edition = self.edition {
            try encodeContainer.encode(edition.rawValue, forKey: .edition)
        }
        if let notificationEmail = self.notificationEmail {
            try encodeContainer.encode(notificationEmail, forKey: .notificationEmail)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountName)
        accountName = accountNameDecoded
        let editionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Edition.self, forKey: .edition)
        edition = editionDecoded
        let notificationEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationEmail)
        notificationEmail = notificationEmailDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let accountSubscriptionStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountSubscriptionStatus)
        accountSubscriptionStatus = accountSubscriptionStatusDecoded
    }
}

extension QuickSightClientTypes {
    /// A structure that contains the following account information elements:
    ///
    /// * Your Amazon QuickSight account name.
    ///
    /// * The edition of Amazon QuickSight that your account is using.
    ///
    /// * The notification email address that is associated with the Amazon QuickSight account.
    ///
    /// * The authentication type of the Amazon QuickSight account.
    ///
    /// * The status of the Amazon QuickSight account's subscription.
    public struct AccountInfo: Swift.Equatable {
        /// The account name that you provided for the Amazon QuickSight subscription in your Amazon Web Services account. You create this name when you sign up for Amazon QuickSight. It's unique over all of Amazon Web Services, and it appears only when users sign in.
        public var accountName: Swift.String?
        /// The status of your account subscription.
        public var accountSubscriptionStatus: Swift.String?
        /// The way that your Amazon QuickSight account is authenticated.
        public var authenticationType: Swift.String?
        /// The edition of your Amazon QuickSight account.
        public var edition: QuickSightClientTypes.Edition?
        /// The email address that will be used for Amazon QuickSight to send notifications regarding your Amazon Web Services account or Amazon QuickSight subscription.
        public var notificationEmail: Swift.String?

        public init (
            accountName: Swift.String? = nil,
            accountSubscriptionStatus: Swift.String? = nil,
            authenticationType: Swift.String? = nil,
            edition: QuickSightClientTypes.Edition? = nil,
            notificationEmail: Swift.String? = nil
        )
        {
            self.accountName = accountName
            self.accountSubscriptionStatus = accountSubscriptionStatus
            self.authenticationType = authenticationType
            self.edition = edition
            self.notificationEmail = notificationEmail
        }
    }

}

extension QuickSightClientTypes.AccountSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountName = "AccountName"
        case defaultNamespace = "DefaultNamespace"
        case edition = "Edition"
        case notificationEmail = "NotificationEmail"
        case publicSharingEnabled = "PublicSharingEnabled"
        case terminationProtectionEnabled = "TerminationProtectionEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountName = self.accountName {
            try encodeContainer.encode(accountName, forKey: .accountName)
        }
        if let defaultNamespace = self.defaultNamespace {
            try encodeContainer.encode(defaultNamespace, forKey: .defaultNamespace)
        }
        if let edition = self.edition {
            try encodeContainer.encode(edition.rawValue, forKey: .edition)
        }
        if let notificationEmail = self.notificationEmail {
            try encodeContainer.encode(notificationEmail, forKey: .notificationEmail)
        }
        if publicSharingEnabled != false {
            try encodeContainer.encode(publicSharingEnabled, forKey: .publicSharingEnabled)
        }
        if terminationProtectionEnabled != false {
            try encodeContainer.encode(terminationProtectionEnabled, forKey: .terminationProtectionEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountName)
        accountName = accountNameDecoded
        let editionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Edition.self, forKey: .edition)
        edition = editionDecoded
        let defaultNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultNamespace)
        defaultNamespace = defaultNamespaceDecoded
        let notificationEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationEmail)
        notificationEmail = notificationEmailDecoded
        let publicSharingEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicSharingEnabled) ?? false
        publicSharingEnabled = publicSharingEnabledDecoded
        let terminationProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminationProtectionEnabled) ?? false
        terminationProtectionEnabled = terminationProtectionEnabledDecoded
    }
}

extension QuickSightClientTypes {
    /// The Amazon QuickSight settings associated with your Amazon Web Services account.
    public struct AccountSettings: Swift.Equatable {
        /// The "account name" you provided for the Amazon QuickSight subscription in your Amazon Web Services account. You create this name when you sign up for Amazon QuickSight. It is unique in all of Amazon Web Services and it appears only when users sign in.
        public var accountName: Swift.String?
        /// The default Amazon QuickSight namespace for your Amazon Web Services account.
        public var defaultNamespace: Swift.String?
        /// The edition of Amazon QuickSight that you're currently subscribed to: Enterprise edition or Standard edition.
        public var edition: QuickSightClientTypes.Edition?
        /// The main notification email for your Amazon QuickSight subscription.
        public var notificationEmail: Swift.String?
        /// A Boolean value that indicates whether public sharing is turned on for an Amazon QuickSight account. For more information about turning on public sharing, see [UpdatePublicSharingSettings](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_UpdatePublicSharingSettings.html).
        public var publicSharingEnabled: Swift.Bool
        /// A boolean value that determines whether or not an Amazon QuickSight account can be deleted. A True value doesn't allow the account to be deleted and results in an error message if a user tries to make a DeleteAccountSubsctiption request. A False value will allow the ccount to be deleted.
        public var terminationProtectionEnabled: Swift.Bool

        public init (
            accountName: Swift.String? = nil,
            defaultNamespace: Swift.String? = nil,
            edition: QuickSightClientTypes.Edition? = nil,
            notificationEmail: Swift.String? = nil,
            publicSharingEnabled: Swift.Bool = false,
            terminationProtectionEnabled: Swift.Bool = false
        )
        {
            self.accountName = accountName
            self.defaultNamespace = defaultNamespace
            self.edition = edition
            self.notificationEmail = notificationEmail
            self.publicSharingEnabled = publicSharingEnabled
            self.terminationProtectionEnabled = terminationProtectionEnabled
        }
    }

}

extension QuickSightClientTypes.ActiveIAMPolicyAssignment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentName = "AssignmentName"
        case policyArn = "PolicyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentName = self.assignmentName {
            try encodeContainer.encode(assignmentName, forKey: .assignmentName)
        }
        if let policyArn = self.policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentName)
        assignmentName = assignmentNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension QuickSightClientTypes {
    /// The active Identity and Access Management (IAM) policy assignment.
    public struct ActiveIAMPolicyAssignment: Swift.Equatable {
        /// A name for the IAM policy assignment.
        public var assignmentName: Swift.String?
        /// The Amazon Resource Name (ARN) of the resource.
        public var policyArn: Swift.String?

        public init (
            assignmentName: Swift.String? = nil,
            policyArn: Swift.String? = nil
        )
        {
            self.assignmentName = assignmentName
            self.policyArn = policyArn
        }
    }

}

extension QuickSightClientTypes.AdHocFilteringOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityStatus = "AvailabilityStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityStatus = self.availabilityStatus {
            try encodeContainer.encode(availabilityStatus.rawValue, forKey: .availabilityStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardBehavior.self, forKey: .availabilityStatus)
        availabilityStatus = availabilityStatusDecoded
    }
}

extension QuickSightClientTypes {
    /// An ad hoc (one-time) filtering option.
    public struct AdHocFilteringOption: Swift.Equatable {
        /// Availability status.
        public var availabilityStatus: QuickSightClientTypes.DashboardBehavior?

        public init (
            availabilityStatus: QuickSightClientTypes.DashboardBehavior? = nil
        )
        {
            self.availabilityStatus = availabilityStatus
        }
    }

}

extension QuickSightClientTypes.AggregationFunction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoricalAggregationFunction = "CategoricalAggregationFunction"
        case dateAggregationFunction = "DateAggregationFunction"
        case numericalAggregationFunction = "NumericalAggregationFunction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoricalAggregationFunction = self.categoricalAggregationFunction {
            try encodeContainer.encode(categoricalAggregationFunction.rawValue, forKey: .categoricalAggregationFunction)
        }
        if let dateAggregationFunction = self.dateAggregationFunction {
            try encodeContainer.encode(dateAggregationFunction.rawValue, forKey: .dateAggregationFunction)
        }
        if let numericalAggregationFunction = self.numericalAggregationFunction {
            try encodeContainer.encode(numericalAggregationFunction, forKey: .numericalAggregationFunction)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numericalAggregationFunctionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumericalAggregationFunction.self, forKey: .numericalAggregationFunction)
        numericalAggregationFunction = numericalAggregationFunctionDecoded
        let categoricalAggregationFunctionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CategoricalAggregationFunction.self, forKey: .categoricalAggregationFunction)
        categoricalAggregationFunction = categoricalAggregationFunctionDecoded
        let dateAggregationFunctionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DateAggregationFunction.self, forKey: .dateAggregationFunction)
        dateAggregationFunction = dateAggregationFunctionDecoded
    }
}

extension QuickSightClientTypes {
    /// An aggregation function aggregates values from a dimension or measure. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct AggregationFunction: Swift.Equatable {
        /// Aggregation for categorical values.
        ///
        /// * COUNT: Aggregate by the total number of values, including duplicates.
        ///
        /// * DISTINCT_COUNT: Aggregate by the total number of distinct values.
        public var categoricalAggregationFunction: QuickSightClientTypes.CategoricalAggregationFunction?
        /// Aggregation for date values.
        ///
        /// * COUNT: Aggregate by the total number of values, including duplicates.
        ///
        /// * DISTINCT_COUNT: Aggregate by the total number of distinct values.
        ///
        /// * MIN: Select the smallest date value.
        ///
        /// * MAX: Select the largest date value.
        public var dateAggregationFunction: QuickSightClientTypes.DateAggregationFunction?
        /// Aggregation for numerical values.
        public var numericalAggregationFunction: QuickSightClientTypes.NumericalAggregationFunction?

        public init (
            categoricalAggregationFunction: QuickSightClientTypes.CategoricalAggregationFunction? = nil,
            dateAggregationFunction: QuickSightClientTypes.DateAggregationFunction? = nil,
            numericalAggregationFunction: QuickSightClientTypes.NumericalAggregationFunction? = nil
        )
        {
            self.categoricalAggregationFunction = categoricalAggregationFunction
            self.dateAggregationFunction = dateAggregationFunction
            self.numericalAggregationFunction = numericalAggregationFunction
        }
    }

}

extension QuickSightClientTypes.AggregationSortConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationFunction = "AggregationFunction"
        case column = "Column"
        case sortDirection = "SortDirection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationFunction = self.aggregationFunction {
            try encodeContainer.encode(aggregationFunction, forKey: .aggregationFunction)
        }
        if let column = self.column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let sortDirection = self.sortDirection {
            try encodeContainer.encode(sortDirection.rawValue, forKey: .sortDirection)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .column)
        column = columnDecoded
        let sortDirectionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SortDirection.self, forKey: .sortDirection)
        sortDirection = sortDirectionDecoded
        let aggregationFunctionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AggregationFunction.self, forKey: .aggregationFunction)
        aggregationFunction = aggregationFunctionDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration options to sort aggregated values.
    public struct AggregationSortConfiguration: Swift.Equatable {
        /// The function that aggregates the values in Column.
        /// This member is required.
        public var aggregationFunction: QuickSightClientTypes.AggregationFunction?
        /// The column that determines the sort order of aggregated values.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The sort direction of values.
        ///
        /// * ASC: Sort in ascending order.
        ///
        /// * DESC: Sort in descending order.
        /// This member is required.
        public var sortDirection: QuickSightClientTypes.SortDirection?

        public init (
            aggregationFunction: QuickSightClientTypes.AggregationFunction? = nil,
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            sortDirection: QuickSightClientTypes.SortDirection? = nil
        )
        {
            self.aggregationFunction = aggregationFunction
            self.column = column
            self.sortDirection = sortDirection
        }
    }

}

extension QuickSightClientTypes.AmazonElasticsearchParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for OpenSearch.
    public struct AmazonElasticsearchParameters: Swift.Equatable {
        /// The OpenSearch domain.
        /// This member is required.
        public var domain: Swift.String?

        public init (
            domain: Swift.String? = nil
        )
        {
            self.domain = domain
        }
    }

}

extension QuickSightClientTypes.AmazonOpenSearchParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for OpenSearch.
    public struct AmazonOpenSearchParameters: Swift.Equatable {
        /// The OpenSearch domain.
        /// This member is required.
        public var domain: Swift.String?

        public init (
            domain: Swift.String? = nil
        )
        {
            self.domain = domain
        }
    }

}

extension QuickSightClientTypes.Analysis: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisId = "AnalysisId"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case dataSetArns = "DataSetArns"
        case errors = "Errors"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case sheets = "Sheets"
        case status = "Status"
        case themeArn = "ThemeArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisId = self.analysisId {
            try encodeContainer.encode(analysisId, forKey: .analysisId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let dataSetArns = dataSetArns {
            var dataSetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSetArns)
            for arn0 in dataSetArns {
                try dataSetArnsContainer.encode(arn0)
            }
        }
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for analysiserror0 in errors {
                try errorsContainer.encode(analysiserror0)
            }
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sheets = sheets {
            var sheetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sheets)
            for sheet0 in sheets {
                try sheetsContainer.encode(sheet0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let themeArn = self.themeArn {
            try encodeContainer.encode(themeArn, forKey: .themeArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let errorsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.AnalysisError?].self, forKey: .errors)
        var errorsDecoded0:[QuickSightClientTypes.AnalysisError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [QuickSightClientTypes.AnalysisError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let dataSetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dataSetArns)
        var dataSetArnsDecoded0:[Swift.String]? = nil
        if let dataSetArnsContainer = dataSetArnsContainer {
            dataSetArnsDecoded0 = [Swift.String]()
            for string0 in dataSetArnsContainer {
                if let string0 = string0 {
                    dataSetArnsDecoded0?.append(string0)
                }
            }
        }
        dataSetArns = dataSetArnsDecoded0
        let themeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let sheetsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Sheet?].self, forKey: .sheets)
        var sheetsDecoded0:[QuickSightClientTypes.Sheet]? = nil
        if let sheetsContainer = sheetsContainer {
            sheetsDecoded0 = [QuickSightClientTypes.Sheet]()
            for structure0 in sheetsContainer {
                if let structure0 = structure0 {
                    sheetsDecoded0?.append(structure0)
                }
            }
        }
        sheets = sheetsDecoded0
    }
}

extension QuickSightClientTypes {
    /// Metadata structure for an analysis in Amazon QuickSight
    public struct Analysis: Swift.Equatable {
        /// The ID of the analysis.
        public var analysisId: Swift.String?
        /// The Amazon Resource Name (ARN) of the analysis.
        public var arn: Swift.String?
        /// The time that the analysis was created.
        public var createdTime: ClientRuntime.Date?
        /// The ARNs of the datasets of the analysis.
        public var dataSetArns: [Swift.String]?
        /// Errors associated with the analysis.
        public var errors: [QuickSightClientTypes.AnalysisError]?
        /// The time that the analysis was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The descriptive name of the analysis.
        public var name: Swift.String?
        /// A list of the associated sheets with the unique identifier and name of each sheet.
        public var sheets: [QuickSightClientTypes.Sheet]?
        /// Status associated with the analysis.
        public var status: QuickSightClientTypes.ResourceStatus?
        /// The ARN of the theme of the analysis.
        public var themeArn: Swift.String?

        public init (
            analysisId: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            dataSetArns: [Swift.String]? = nil,
            errors: [QuickSightClientTypes.AnalysisError]? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            sheets: [QuickSightClientTypes.Sheet]? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil,
            themeArn: Swift.String? = nil
        )
        {
            self.analysisId = analysisId
            self.arn = arn
            self.createdTime = createdTime
            self.dataSetArns = dataSetArns
            self.errors = errors
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.sheets = sheets
            self.status = status
            self.themeArn = themeArn
        }
    }

}

extension QuickSightClientTypes.AnalysisDefaults: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultNewSheetConfiguration = "DefaultNewSheetConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultNewSheetConfiguration = self.defaultNewSheetConfiguration {
            try encodeContainer.encode(defaultNewSheetConfiguration, forKey: .defaultNewSheetConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultNewSheetConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DefaultNewSheetConfiguration.self, forKey: .defaultNewSheetConfiguration)
        defaultNewSheetConfiguration = defaultNewSheetConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration for default analysis settings.
    public struct AnalysisDefaults: Swift.Equatable {
        /// The configuration for default new sheet settings.
        /// This member is required.
        public var defaultNewSheetConfiguration: QuickSightClientTypes.DefaultNewSheetConfiguration?

        public init (
            defaultNewSheetConfiguration: QuickSightClientTypes.DefaultNewSheetConfiguration? = nil
        )
        {
            self.defaultNewSheetConfiguration = defaultNewSheetConfiguration
        }
    }

}

extension QuickSightClientTypes.AnalysisDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisDefaults = "AnalysisDefaults"
        case calculatedFields = "CalculatedFields"
        case columnConfigurations = "ColumnConfigurations"
        case dataSetIdentifierDeclarations = "DataSetIdentifierDeclarations"
        case filterGroups = "FilterGroups"
        case parameterDeclarations = "ParameterDeclarations"
        case sheets = "Sheets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisDefaults = self.analysisDefaults {
            try encodeContainer.encode(analysisDefaults, forKey: .analysisDefaults)
        }
        if let calculatedFields = calculatedFields {
            var calculatedFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .calculatedFields)
            for calculatedfield0 in calculatedFields {
                try calculatedFieldsContainer.encode(calculatedfield0)
            }
        }
        if let columnConfigurations = columnConfigurations {
            var columnConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnConfigurations)
            for columnconfiguration0 in columnConfigurations {
                try columnConfigurationsContainer.encode(columnconfiguration0)
            }
        }
        if let dataSetIdentifierDeclarations = dataSetIdentifierDeclarations {
            var dataSetIdentifierDeclarationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSetIdentifierDeclarations)
            for datasetidentifierdeclaration0 in dataSetIdentifierDeclarations {
                try dataSetIdentifierDeclarationsContainer.encode(datasetidentifierdeclaration0)
            }
        }
        if let filterGroups = filterGroups {
            var filterGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterGroups)
            for filtergroup0 in filterGroups {
                try filterGroupsContainer.encode(filtergroup0)
            }
        }
        if let parameterDeclarations = parameterDeclarations {
            var parameterDeclarationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterDeclarations)
            for parameterdeclaration0 in parameterDeclarations {
                try parameterDeclarationsContainer.encode(parameterdeclaration0)
            }
        }
        if let sheets = sheets {
            var sheetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sheets)
            for sheetdefinition0 in sheets {
                try sheetsContainer.encode(sheetdefinition0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetIdentifierDeclarationsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataSetIdentifierDeclaration?].self, forKey: .dataSetIdentifierDeclarations)
        var dataSetIdentifierDeclarationsDecoded0:[QuickSightClientTypes.DataSetIdentifierDeclaration]? = nil
        if let dataSetIdentifierDeclarationsContainer = dataSetIdentifierDeclarationsContainer {
            dataSetIdentifierDeclarationsDecoded0 = [QuickSightClientTypes.DataSetIdentifierDeclaration]()
            for structure0 in dataSetIdentifierDeclarationsContainer {
                if let structure0 = structure0 {
                    dataSetIdentifierDeclarationsDecoded0?.append(structure0)
                }
            }
        }
        dataSetIdentifierDeclarations = dataSetIdentifierDeclarationsDecoded0
        let sheetsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.SheetDefinition?].self, forKey: .sheets)
        var sheetsDecoded0:[QuickSightClientTypes.SheetDefinition]? = nil
        if let sheetsContainer = sheetsContainer {
            sheetsDecoded0 = [QuickSightClientTypes.SheetDefinition]()
            for structure0 in sheetsContainer {
                if let structure0 = structure0 {
                    sheetsDecoded0?.append(structure0)
                }
            }
        }
        sheets = sheetsDecoded0
        let calculatedFieldsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.CalculatedField?].self, forKey: .calculatedFields)
        var calculatedFieldsDecoded0:[QuickSightClientTypes.CalculatedField]? = nil
        if let calculatedFieldsContainer = calculatedFieldsContainer {
            calculatedFieldsDecoded0 = [QuickSightClientTypes.CalculatedField]()
            for structure0 in calculatedFieldsContainer {
                if let structure0 = structure0 {
                    calculatedFieldsDecoded0?.append(structure0)
                }
            }
        }
        calculatedFields = calculatedFieldsDecoded0
        let parameterDeclarationsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ParameterDeclaration?].self, forKey: .parameterDeclarations)
        var parameterDeclarationsDecoded0:[QuickSightClientTypes.ParameterDeclaration]? = nil
        if let parameterDeclarationsContainer = parameterDeclarationsContainer {
            parameterDeclarationsDecoded0 = [QuickSightClientTypes.ParameterDeclaration]()
            for structure0 in parameterDeclarationsContainer {
                if let structure0 = structure0 {
                    parameterDeclarationsDecoded0?.append(structure0)
                }
            }
        }
        parameterDeclarations = parameterDeclarationsDecoded0
        let filterGroupsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FilterGroup?].self, forKey: .filterGroups)
        var filterGroupsDecoded0:[QuickSightClientTypes.FilterGroup]? = nil
        if let filterGroupsContainer = filterGroupsContainer {
            filterGroupsDecoded0 = [QuickSightClientTypes.FilterGroup]()
            for structure0 in filterGroupsContainer {
                if let structure0 = structure0 {
                    filterGroupsDecoded0?.append(structure0)
                }
            }
        }
        filterGroups = filterGroupsDecoded0
        let columnConfigurationsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnConfiguration?].self, forKey: .columnConfigurations)
        var columnConfigurationsDecoded0:[QuickSightClientTypes.ColumnConfiguration]? = nil
        if let columnConfigurationsContainer = columnConfigurationsContainer {
            columnConfigurationsDecoded0 = [QuickSightClientTypes.ColumnConfiguration]()
            for structure0 in columnConfigurationsContainer {
                if let structure0 = structure0 {
                    columnConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        columnConfigurations = columnConfigurationsDecoded0
        let analysisDefaultsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AnalysisDefaults.self, forKey: .analysisDefaults)
        analysisDefaults = analysisDefaultsDecoded
    }
}

extension QuickSightClientTypes {
    /// The definition of an analysis.
    public struct AnalysisDefinition: Swift.Equatable {
        /// The configuration for default analysis settings.
        public var analysisDefaults: QuickSightClientTypes.AnalysisDefaults?
        /// An array of calculated field definitions for the analysis.
        public var calculatedFields: [QuickSightClientTypes.CalculatedField]?
        /// An array of analysis-level column configurations. Column configurations can be used to set default formatting for a column to be used throughout an analysis.
        public var columnConfigurations: [QuickSightClientTypes.ColumnConfiguration]?
        /// An array of dataset identifier declarations. This mapping allows the usage of dataset identifiers instead of dataset ARNs throughout analysis sub-structures.
        /// This member is required.
        public var dataSetIdentifierDeclarations: [QuickSightClientTypes.DataSetIdentifierDeclaration]?
        /// Filter definitions for an analysis. For more information, see [Filtering Data in Amazon QuickSight](https://docs.aws.amazon.com/quicksight/latest/user/adding-a-filter.html) in the Amazon QuickSight User Guide.
        public var filterGroups: [QuickSightClientTypes.FilterGroup]?
        /// An array of parameter declarations for an analysis. Parameters are named variables that can transfer a value for use by an action or an object. For more information, see [Parameters in Amazon QuickSight](https://docs.aws.amazon.com/quicksight/latest/user/parameters-in-quicksight.html) in the Amazon QuickSight User Guide.
        public var parameterDeclarations: [QuickSightClientTypes.ParameterDeclaration]?
        /// An array of sheet definitions for an analysis. Each SheetDefinition provides detailed information about a sheet within this analysis.
        public var sheets: [QuickSightClientTypes.SheetDefinition]?

        public init (
            analysisDefaults: QuickSightClientTypes.AnalysisDefaults? = nil,
            calculatedFields: [QuickSightClientTypes.CalculatedField]? = nil,
            columnConfigurations: [QuickSightClientTypes.ColumnConfiguration]? = nil,
            dataSetIdentifierDeclarations: [QuickSightClientTypes.DataSetIdentifierDeclaration]? = nil,
            filterGroups: [QuickSightClientTypes.FilterGroup]? = nil,
            parameterDeclarations: [QuickSightClientTypes.ParameterDeclaration]? = nil,
            sheets: [QuickSightClientTypes.SheetDefinition]? = nil
        )
        {
            self.analysisDefaults = analysisDefaults
            self.calculatedFields = calculatedFields
            self.columnConfigurations = columnConfigurations
            self.dataSetIdentifierDeclarations = dataSetIdentifierDeclarations
            self.filterGroups = filterGroups
            self.parameterDeclarations = parameterDeclarations
            self.sheets = sheets
        }
    }

}

extension QuickSightClientTypes.AnalysisError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
        case violatedEntities = "ViolatedEntities"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let violatedEntities = violatedEntities {
            var violatedEntitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .violatedEntities)
            for entity0 in violatedEntities {
                try violatedEntitiesContainer.encode(entity0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AnalysisErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let violatedEntitiesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Entity?].self, forKey: .violatedEntities)
        var violatedEntitiesDecoded0:[QuickSightClientTypes.Entity]? = nil
        if let violatedEntitiesContainer = violatedEntitiesContainer {
            violatedEntitiesDecoded0 = [QuickSightClientTypes.Entity]()
            for structure0 in violatedEntitiesContainer {
                if let structure0 = structure0 {
                    violatedEntitiesDecoded0?.append(structure0)
                }
            }
        }
        violatedEntities = violatedEntitiesDecoded0
    }
}

extension QuickSightClientTypes {
    /// Analysis error.
    public struct AnalysisError: Swift.Equatable {
        /// The message associated with the analysis error.
        public var message: Swift.String?
        /// The type of the analysis error.
        public var type: QuickSightClientTypes.AnalysisErrorType?
        ///
        public var violatedEntities: [QuickSightClientTypes.Entity]?

        public init (
            message: Swift.String? = nil,
            type: QuickSightClientTypes.AnalysisErrorType? = nil,
            violatedEntities: [QuickSightClientTypes.Entity]? = nil
        )
        {
            self.message = message
            self.type = type
            self.violatedEntities = violatedEntities
        }
    }

}

extension QuickSightClientTypes {
    public enum AnalysisErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case columnGeographicRoleMismatch
        case columnReplacementMissing
        case columnTypeMismatch
        case dataSetNotFound
        case internalFailure
        case parameterNotFound
        case parameterTypeInvalid
        case parameterValueIncompatible
        case sourceNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisErrorType] {
            return [
                .accessDenied,
                .columnGeographicRoleMismatch,
                .columnReplacementMissing,
                .columnTypeMismatch,
                .dataSetNotFound,
                .internalFailure,
                .parameterNotFound,
                .parameterTypeInvalid,
                .parameterValueIncompatible,
                .sourceNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .columnGeographicRoleMismatch: return "COLUMN_GEOGRAPHIC_ROLE_MISMATCH"
            case .columnReplacementMissing: return "COLUMN_REPLACEMENT_MISSING"
            case .columnTypeMismatch: return "COLUMN_TYPE_MISMATCH"
            case .dataSetNotFound: return "DATA_SET_NOT_FOUND"
            case .internalFailure: return "INTERNAL_FAILURE"
            case .parameterNotFound: return "PARAMETER_NOT_FOUND"
            case .parameterTypeInvalid: return "PARAMETER_TYPE_INVALID"
            case .parameterValueIncompatible: return "PARAMETER_VALUE_INCOMPATIBLE"
            case .sourceNotFound: return "SOURCE_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalysisErrorType(rawValue: rawValue) ?? AnalysisErrorType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum AnalysisFilterAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case analysisName
        case directQuicksightOwner
        case directQuicksightSoleOwner
        case directQuicksightViewerOrOwner
        case quicksightOwner
        case quicksightUser
        case quicksightViewerOrOwner
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisFilterAttribute] {
            return [
                .analysisName,
                .directQuicksightOwner,
                .directQuicksightSoleOwner,
                .directQuicksightViewerOrOwner,
                .quicksightOwner,
                .quicksightUser,
                .quicksightViewerOrOwner,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .analysisName: return "ANALYSIS_NAME"
            case .directQuicksightOwner: return "DIRECT_QUICKSIGHT_OWNER"
            case .directQuicksightSoleOwner: return "DIRECT_QUICKSIGHT_SOLE_OWNER"
            case .directQuicksightViewerOrOwner: return "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
            case .quicksightOwner: return "QUICKSIGHT_OWNER"
            case .quicksightUser: return "QUICKSIGHT_USER"
            case .quicksightViewerOrOwner: return "QUICKSIGHT_VIEWER_OR_OWNER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalysisFilterAttribute(rawValue: rawValue) ?? AnalysisFilterAttribute.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.AnalysisSearchFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case `operator` = "Operator"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let nameDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AnalysisFilterAttribute.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension QuickSightClientTypes {
    /// A filter that you apply when searching for one or more analyses.
    public struct AnalysisSearchFilter: Swift.Equatable {
        /// The name of the value that you want to use as a filter, for example "Name": "QUICKSIGHT_OWNER". Valid values are defined as follows:
        ///
        /// * QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the analysis' owners or viewers are returned. Implicit permissions from folders or groups are considered.
        ///
        /// * QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the owners of the analyses are returned. Implicit permissions from folders or groups are considered.
        ///
        /// * DIRECT_QUICKSIGHT_SOLE_OWNER: Provide an ARN of a user or group, and any analyses with that ARN listed as the only owner of the analysis are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DIRECT_QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the owners of the analyses are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DIRECT_QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the owners or viewers of the analyses are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * ANALYSIS_NAME: Any analyses whose names have a substring match to this value will be returned.
        public var name: QuickSightClientTypes.AnalysisFilterAttribute?
        /// The comparison operator that you want to use as a filter, for example "Operator": "StringEquals". Valid values are "StringEquals" and "StringLike". If you set the operator value to "StringEquals", you need to provide an ownership related filter in the "NAME" field and the arn of the user or group whose folders you want to search in the "Value" field. For example, "Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1". If you set the value to "StringLike", you need to provide the name of the folders you are searching for. For example, "Name":"ANALYSIS_NAME", "Operator": "StringLike", "Value": "Test". The "StringLike" operator only supports the NAME value ANALYSIS_NAME.
        public var `operator`: QuickSightClientTypes.FilterOperator?
        /// The value of the named item, in this case QUICKSIGHT_USER, that you want to use as a filter, for example "Value". An example is "arn:aws:quicksight:us-east-1:1:user/default/UserName1".
        public var value: Swift.String?

        public init (
            name: QuickSightClientTypes.AnalysisFilterAttribute? = nil,
            `operator`: QuickSightClientTypes.FilterOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }
    }

}

extension QuickSightClientTypes.AnalysisSourceEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceTemplate = "SourceTemplate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceTemplate = self.sourceTemplate {
            try encodeContainer.encode(sourceTemplate, forKey: .sourceTemplate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTemplateDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AnalysisSourceTemplate.self, forKey: .sourceTemplate)
        sourceTemplate = sourceTemplateDecoded
    }
}

extension QuickSightClientTypes {
    /// The source entity of an analysis.
    public struct AnalysisSourceEntity: Swift.Equatable {
        /// The source template for the source entity of the analysis.
        public var sourceTemplate: QuickSightClientTypes.AnalysisSourceTemplate?

        public init (
            sourceTemplate: QuickSightClientTypes.AnalysisSourceTemplate? = nil
        )
        {
            self.sourceTemplate = sourceTemplate
        }
    }

}

extension QuickSightClientTypes.AnalysisSourceTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case dataSetReferences = "DataSetReferences"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dataSetReferences = dataSetReferences {
            var dataSetReferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSetReferences)
            for datasetreference0 in dataSetReferences {
                try dataSetReferencesContainer.encode(datasetreference0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetReferencesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataSetReference?].self, forKey: .dataSetReferences)
        var dataSetReferencesDecoded0:[QuickSightClientTypes.DataSetReference]? = nil
        if let dataSetReferencesContainer = dataSetReferencesContainer {
            dataSetReferencesDecoded0 = [QuickSightClientTypes.DataSetReference]()
            for structure0 in dataSetReferencesContainer {
                if let structure0 = structure0 {
                    dataSetReferencesDecoded0?.append(structure0)
                }
            }
        }
        dataSetReferences = dataSetReferencesDecoded0
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension QuickSightClientTypes {
    /// The source template of an analysis.
    public struct AnalysisSourceTemplate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the source template of an analysis.
        /// This member is required.
        public var arn: Swift.String?
        /// The dataset references of the source template of an analysis.
        /// This member is required.
        public var dataSetReferences: [QuickSightClientTypes.DataSetReference]?

        public init (
            arn: Swift.String? = nil,
            dataSetReferences: [QuickSightClientTypes.DataSetReference]? = nil
        )
        {
            self.arn = arn
            self.dataSetReferences = dataSetReferences
        }
    }

}

extension QuickSightClientTypes.AnalysisSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisId = "AnalysisId"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisId = self.analysisId {
            try encodeContainer.encode(analysisId, forKey: .analysisId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let analysisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension QuickSightClientTypes {
    /// The summary metadata that describes an analysis.
    public struct AnalysisSummary: Swift.Equatable {
        /// The ID of the analysis. This ID displays in the URL.
        public var analysisId: Swift.String?
        /// The Amazon Resource Name (ARN) for the analysis.
        public var arn: Swift.String?
        /// The time that the analysis was created.
        public var createdTime: ClientRuntime.Date?
        /// The time that the analysis was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the analysis. This name is displayed in the Amazon QuickSight console.
        public var name: Swift.String?
        /// The last known status for the analysis.
        public var status: QuickSightClientTypes.ResourceStatus?

        public init (
            analysisId: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil
        )
        {
            self.analysisId = analysisId
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.status = status
        }
    }

}

extension QuickSightClientTypes.AnchorDateConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anchorOption = "AnchorOption"
        case parameterName = "ParameterName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anchorOption = self.anchorOption {
            try encodeContainer.encode(anchorOption.rawValue, forKey: .anchorOption)
        }
        if let parameterName = self.parameterName {
            try encodeContainer.encode(parameterName, forKey: .parameterName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anchorOptionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AnchorOption.self, forKey: .anchorOption)
        anchorOption = anchorOptionDecoded
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
    }
}

extension QuickSightClientTypes {
    /// The date configuration of the filter.
    public struct AnchorDateConfiguration: Swift.Equatable {
        /// The options for the date configuration. Choose one of the options below:
        ///
        /// * NOW
        public var anchorOption: QuickSightClientTypes.AnchorOption?
        /// The name of the parameter that is used for the anchor date configuration.
        public var parameterName: Swift.String?

        public init (
            anchorOption: QuickSightClientTypes.AnchorOption? = nil,
            parameterName: Swift.String? = nil
        )
        {
            self.anchorOption = anchorOption
            self.parameterName = parameterName
        }
    }

}

extension QuickSightClientTypes {
    public enum AnchorOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case now
        case sdkUnknown(Swift.String)

        public static var allCases: [AnchorOption] {
            return [
                .now,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .now: return "NOW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnchorOption(rawValue: rawValue) ?? AnchorOption.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.AnonymousUserDashboardEmbeddingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialDashboardId = "InitialDashboardId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialDashboardId = self.initialDashboardId {
            try encodeContainer.encode(initialDashboardId, forKey: .initialDashboardId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialDashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialDashboardId)
        initialDashboardId = initialDashboardIdDecoded
    }
}

extension QuickSightClientTypes {
    /// Information about the dashboard that you want to embed.
    public struct AnonymousUserDashboardEmbeddingConfiguration: Swift.Equatable {
        /// The dashboard ID for the dashboard that you want the user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this dashboard. The Amazon Resource Name (ARN) of this dashboard must be included in the AuthorizedResourceArns parameter. Otherwise, the request will fail with InvalidParameterValueException.
        /// This member is required.
        public var initialDashboardId: Swift.String?

        public init (
            initialDashboardId: Swift.String? = nil
        )
        {
            self.initialDashboardId = initialDashboardId
        }
    }

}

extension QuickSightClientTypes.AnonymousUserDashboardVisualEmbeddingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialDashboardVisualId = "InitialDashboardVisualId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialDashboardVisualId = self.initialDashboardVisualId {
            try encodeContainer.encode(initialDashboardVisualId, forKey: .initialDashboardVisualId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialDashboardVisualIdDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardVisualId.self, forKey: .initialDashboardVisualId)
        initialDashboardVisualId = initialDashboardVisualIdDecoded
    }
}

extension QuickSightClientTypes {
    /// The experience that you are embedding. You can use this object to generate a url that embeds a visual into your application.
    public struct AnonymousUserDashboardVisualEmbeddingConfiguration: Swift.Equatable {
        /// The visual ID for the visual that you want the user to see. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this visual. The Amazon Resource Name (ARN) of the dashboard that the visual belongs to must be included in the AuthorizedResourceArns parameter. Otherwise, the request will fail with InvalidParameterValueException.
        /// This member is required.
        public var initialDashboardVisualId: QuickSightClientTypes.DashboardVisualId?

        public init (
            initialDashboardVisualId: QuickSightClientTypes.DashboardVisualId? = nil
        )
        {
            self.initialDashboardVisualId = initialDashboardVisualId
        }
    }

}

extension QuickSightClientTypes.AnonymousUserEmbeddingExperienceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboard = "Dashboard"
        case dashboardVisual = "DashboardVisual"
        case qSearchBar = "QSearchBar"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dashboard = self.dashboard {
            try encodeContainer.encode(dashboard, forKey: .dashboard)
        }
        if let dashboardVisual = self.dashboardVisual {
            try encodeContainer.encode(dashboardVisual, forKey: .dashboardVisual)
        }
        if let qSearchBar = self.qSearchBar {
            try encodeContainer.encode(qSearchBar, forKey: .qSearchBar)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AnonymousUserDashboardEmbeddingConfiguration.self, forKey: .dashboard)
        dashboard = dashboardDecoded
        let dashboardVisualDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AnonymousUserDashboardVisualEmbeddingConfiguration.self, forKey: .dashboardVisual)
        dashboardVisual = dashboardVisualDecoded
        let qSearchBarDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AnonymousUserQSearchBarEmbeddingConfiguration.self, forKey: .qSearchBar)
        qSearchBar = qSearchBarDecoded
    }
}

extension QuickSightClientTypes {
    /// The type of experience you want to embed. For anonymous users, you can embed Amazon QuickSight dashboards.
    public struct AnonymousUserEmbeddingExperienceConfiguration: Swift.Equatable {
        /// The type of embedding experience. In this case, Amazon QuickSight dashboards.
        public var dashboard: QuickSightClientTypes.AnonymousUserDashboardEmbeddingConfiguration?
        /// The type of embedding experience. In this case, Amazon QuickSight visuals.
        public var dashboardVisual: QuickSightClientTypes.AnonymousUserDashboardVisualEmbeddingConfiguration?
        /// The Q search bar that you want to use for anonymous user embedding.
        public var qSearchBar: QuickSightClientTypes.AnonymousUserQSearchBarEmbeddingConfiguration?

        public init (
            dashboard: QuickSightClientTypes.AnonymousUserDashboardEmbeddingConfiguration? = nil,
            dashboardVisual: QuickSightClientTypes.AnonymousUserDashboardVisualEmbeddingConfiguration? = nil,
            qSearchBar: QuickSightClientTypes.AnonymousUserQSearchBarEmbeddingConfiguration? = nil
        )
        {
            self.dashboard = dashboard
            self.dashboardVisual = dashboardVisual
            self.qSearchBar = qSearchBar
        }
    }

}

extension QuickSightClientTypes.AnonymousUserQSearchBarEmbeddingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialTopicId = "InitialTopicId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialTopicId = self.initialTopicId {
            try encodeContainer.encode(initialTopicId, forKey: .initialTopicId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialTopicIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialTopicId)
        initialTopicId = initialTopicIdDecoded
    }
}

extension QuickSightClientTypes {
    /// The settings that you want to use with the Q search bar.
    public struct AnonymousUserQSearchBarEmbeddingConfiguration: Swift.Equatable {
        /// The QuickSight Q topic ID of the topic that you want the anonymous user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders the Q search bar with this topic pre-selected. The Amazon Resource Name (ARN) of this Q topic must be included in the AuthorizedResourceArns parameter. Otherwise, the request will fail with InvalidParameterValueException.
        /// This member is required.
        public var initialTopicId: Swift.String?

        public init (
            initialTopicId: Swift.String? = nil
        )
        {
            self.initialTopicId = initialTopicId
        }
    }

}

extension QuickSightClientTypes.ArcAxisConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case range = "Range"
        case reserveRange = "ReserveRange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let range = self.range {
            try encodeContainer.encode(range, forKey: .range)
        }
        if reserveRange != 0 {
            try encodeContainer.encode(reserveRange, forKey: .reserveRange)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rangeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ArcAxisDisplayRange.self, forKey: .range)
        range = rangeDecoded
        let reserveRangeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .reserveRange) ?? 0
        reserveRange = reserveRangeDecoded
    }
}

extension QuickSightClientTypes {
    /// The arc axis configuration of a GaugeChartVisual.
    public struct ArcAxisConfiguration: Swift.Equatable {
        /// The arc axis range of a GaugeChartVisual.
        public var range: QuickSightClientTypes.ArcAxisDisplayRange?
        /// The reserved range of the arc axis.
        public var reserveRange: Swift.Int

        public init (
            range: QuickSightClientTypes.ArcAxisDisplayRange? = nil,
            reserveRange: Swift.Int = 0
        )
        {
            self.range = range
            self.reserveRange = reserveRange
        }
    }

}

extension QuickSightClientTypes.ArcAxisDisplayRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max = "Max"
        case min = "Min"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let max = self.max {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let min = self.min {
            try encodeContainer.encode(min, forKey: .min)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .min)
        min = minDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .max)
        max = maxDecoded
    }
}

extension QuickSightClientTypes {
    /// The arc axis range of a GaugeChartVisual.
    public struct ArcAxisDisplayRange: Swift.Equatable {
        /// The maximum value of the arc axis range.
        public var max: Swift.Double?
        /// The minimum value of the arc axis range.
        public var min: Swift.Double?

        public init (
            max: Swift.Double? = nil,
            min: Swift.Double? = nil
        )
        {
            self.max = max
            self.min = min
        }
    }

}

extension QuickSightClientTypes.ArcConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arcAngle = "ArcAngle"
        case arcThickness = "ArcThickness"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arcAngle = self.arcAngle {
            try encodeContainer.encode(arcAngle, forKey: .arcAngle)
        }
        if let arcThickness = self.arcThickness {
            try encodeContainer.encode(arcThickness.rawValue, forKey: .arcThickness)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arcAngleDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .arcAngle)
        arcAngle = arcAngleDecoded
        let arcThicknessDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ArcThicknessOptions.self, forKey: .arcThickness)
        arcThickness = arcThicknessDecoded
    }
}

extension QuickSightClientTypes {
    /// The arc configuration of a GaugeChartVisual.
    public struct ArcConfiguration: Swift.Equatable {
        /// The option that determines the arc angle of a GaugeChartVisual.
        public var arcAngle: Swift.Double?
        /// The options that determine the arc thickness of a GaugeChartVisual.
        public var arcThickness: QuickSightClientTypes.ArcThicknessOptions?

        public init (
            arcAngle: Swift.Double? = nil,
            arcThickness: QuickSightClientTypes.ArcThicknessOptions? = nil
        )
        {
            self.arcAngle = arcAngle
            self.arcThickness = arcThickness
        }
    }

}

extension QuickSightClientTypes.ArcOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arcThickness = "ArcThickness"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arcThickness = self.arcThickness {
            try encodeContainer.encode(arcThickness.rawValue, forKey: .arcThickness)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arcThicknessDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ArcThickness.self, forKey: .arcThickness)
        arcThickness = arcThicknessDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the arc thickness of a GaugeChartVisual.
    public struct ArcOptions: Swift.Equatable {
        /// The arc thickness of a GaugeChartVisual.
        public var arcThickness: QuickSightClientTypes.ArcThickness?

        public init (
            arcThickness: QuickSightClientTypes.ArcThickness? = nil
        )
        {
            self.arcThickness = arcThickness
        }
    }

}

extension QuickSightClientTypes {
    public enum ArcThickness: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case large
        case medium
        case small
        case whole
        case sdkUnknown(Swift.String)

        public static var allCases: [ArcThickness] {
            return [
                .large,
                .medium,
                .small,
                .whole,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .large: return "LARGE"
            case .medium: return "MEDIUM"
            case .small: return "SMALL"
            case .whole: return "WHOLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ArcThickness(rawValue: rawValue) ?? ArcThickness.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum ArcThicknessOptions: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case large
        case medium
        case small
        case sdkUnknown(Swift.String)

        public static var allCases: [ArcThicknessOptions] {
            return [
                .large,
                .medium,
                .small,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .large: return "LARGE"
            case .medium: return "MEDIUM"
            case .small: return "SMALL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ArcThicknessOptions(rawValue: rawValue) ?? ArcThicknessOptions.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum AssignmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case draft
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AssignmentStatus] {
            return [
                .disabled,
                .draft,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .draft: return "DRAFT"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssignmentStatus(rawValue: rawValue) ?? AssignmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.AthenaParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn = "RoleArn"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension QuickSightClientTypes {
    /// Parameters for Amazon Athena.
    public struct AthenaParameters: Swift.Equatable {
        /// Use the RoleArn structure to override an account-wide role for a specific Athena data source. For example, say an account administrator has turned off all Athena access with an account-wide role. The administrator can then use RoleArn to bypass the account-wide role and allow Athena access for the single Athena data source that is specified in the structure, even if the account-wide role forbidding Athena access is still active.
        public var roleArn: Swift.String?
        /// The workgroup that Amazon Athena uses.
        public var workGroup: Swift.String?

        public init (
            roleArn: Swift.String? = nil,
            workGroup: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.workGroup = workGroup
        }
    }

}

extension QuickSightClientTypes.AuroraParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension QuickSightClientTypes {
    /// Parameters for Amazon Aurora.
    public struct AuroraParameters: Swift.Equatable {
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int

        public init (
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.database = database
            self.host = host
            self.port = port
        }
    }

}

extension QuickSightClientTypes.AuroraPostgreSqlParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension QuickSightClientTypes {
    /// Parameters for Amazon Aurora PostgreSQL-Compatible Edition.
    public struct AuroraPostgreSqlParameters: Swift.Equatable {
        /// The Amazon Aurora PostgreSQL database to connect to.
        /// This member is required.
        public var database: Swift.String?
        /// The Amazon Aurora PostgreSQL-Compatible host to connect to.
        /// This member is required.
        public var host: Swift.String?
        /// The port that Amazon Aurora PostgreSQL is listening on.
        /// This member is required.
        public var port: Swift.Int

        public init (
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.database = database
            self.host = host
            self.port = port
        }
    }

}

extension QuickSightClientTypes {
    public enum AuthenticationMethodOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activeDirectory
        case iamAndQuicksight
        case iamOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationMethodOption] {
            return [
                .activeDirectory,
                .iamAndQuicksight,
                .iamOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activeDirectory: return "ACTIVE_DIRECTORY"
            case .iamAndQuicksight: return "IAM_AND_QUICKSIGHT"
            case .iamOnly: return "IAM_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticationMethodOption(rawValue: rawValue) ?? AuthenticationMethodOption.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.AwsIotAnalyticsParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetName = "DataSetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSetName = self.dataSetName {
            try encodeContainer.encode(dataSetName, forKey: .dataSetName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetName)
        dataSetName = dataSetNameDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for IoT Analytics.
    public struct AwsIotAnalyticsParameters: Swift.Equatable {
        /// Dataset name.
        /// This member is required.
        public var dataSetName: Swift.String?

        public init (
            dataSetName: Swift.String? = nil
        )
        {
            self.dataSetName = dataSetName
        }
    }

}

extension QuickSightClientTypes {
    public enum AxisBinding: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case primaryYaxis
        case secondaryYaxis
        case sdkUnknown(Swift.String)

        public static var allCases: [AxisBinding] {
            return [
                .primaryYaxis,
                .secondaryYaxis,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .primaryYaxis: return "PRIMARY_YAXIS"
            case .secondaryYaxis: return "SECONDARY_YAXIS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AxisBinding(rawValue: rawValue) ?? AxisBinding.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.AxisDataOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateAxisOptions = "DateAxisOptions"
        case numericAxisOptions = "NumericAxisOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateAxisOptions = self.dateAxisOptions {
            try encodeContainer.encode(dateAxisOptions, forKey: .dateAxisOptions)
        }
        if let numericAxisOptions = self.numericAxisOptions {
            try encodeContainer.encode(numericAxisOptions, forKey: .numericAxisOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numericAxisOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumericAxisOptions.self, forKey: .numericAxisOptions)
        numericAxisOptions = numericAxisOptionsDecoded
        let dateAxisOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DateAxisOptions.self, forKey: .dateAxisOptions)
        dateAxisOptions = dateAxisOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// The data options for an axis. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct AxisDataOptions: Swift.Equatable {
        /// The options for an axis with a date field.
        public var dateAxisOptions: QuickSightClientTypes.DateAxisOptions?
        /// The options for an axis with a numeric field.
        public var numericAxisOptions: QuickSightClientTypes.NumericAxisOptions?

        public init (
            dateAxisOptions: QuickSightClientTypes.DateAxisOptions? = nil,
            numericAxisOptions: QuickSightClientTypes.NumericAxisOptions? = nil
        )
        {
            self.dateAxisOptions = dateAxisOptions
            self.numericAxisOptions = numericAxisOptions
        }
    }

}

extension QuickSightClientTypes.AxisDisplayDataDrivenRange: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension QuickSightClientTypes {
    /// The options that are saved for future extension.
    public struct AxisDisplayDataDrivenRange: Swift.Equatable {

        public init () { }
    }

}

extension QuickSightClientTypes.AxisDisplayMinMaxRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximum = "Maximum"
        case minimum = "Minimum"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maximum = self.maximum {
            try encodeContainer.encode(maximum, forKey: .maximum)
        }
        if let minimum = self.minimum {
            try encodeContainer.encode(minimum, forKey: .minimum)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minimumDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minimum)
        minimum = minimumDecoded
        let maximumDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .maximum)
        maximum = maximumDecoded
    }
}

extension QuickSightClientTypes {
    /// The minimum and maximum setup for an axis display range.
    public struct AxisDisplayMinMaxRange: Swift.Equatable {
        /// The maximum setup for an axis display range.
        public var maximum: Swift.Double?
        /// The minimum setup for an axis display range.
        public var minimum: Swift.Double?

        public init (
            maximum: Swift.Double? = nil,
            minimum: Swift.Double? = nil
        )
        {
            self.maximum = maximum
            self.minimum = minimum
        }
    }

}

extension QuickSightClientTypes.AxisDisplayOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case axisLineVisibility = "AxisLineVisibility"
        case axisOffset = "AxisOffset"
        case dataOptions = "DataOptions"
        case gridLineVisibility = "GridLineVisibility"
        case scrollbarOptions = "ScrollbarOptions"
        case tickLabelOptions = "TickLabelOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let axisLineVisibility = self.axisLineVisibility {
            try encodeContainer.encode(axisLineVisibility.rawValue, forKey: .axisLineVisibility)
        }
        if let axisOffset = self.axisOffset {
            try encodeContainer.encode(axisOffset, forKey: .axisOffset)
        }
        if let dataOptions = self.dataOptions {
            try encodeContainer.encode(dataOptions, forKey: .dataOptions)
        }
        if let gridLineVisibility = self.gridLineVisibility {
            try encodeContainer.encode(gridLineVisibility.rawValue, forKey: .gridLineVisibility)
        }
        if let scrollbarOptions = self.scrollbarOptions {
            try encodeContainer.encode(scrollbarOptions, forKey: .scrollbarOptions)
        }
        if let tickLabelOptions = self.tickLabelOptions {
            try encodeContainer.encode(tickLabelOptions, forKey: .tickLabelOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tickLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisTickLabelOptions.self, forKey: .tickLabelOptions)
        tickLabelOptions = tickLabelOptionsDecoded
        let axisLineVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .axisLineVisibility)
        axisLineVisibility = axisLineVisibilityDecoded
        let gridLineVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .gridLineVisibility)
        gridLineVisibility = gridLineVisibilityDecoded
        let dataOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisDataOptions.self, forKey: .dataOptions)
        dataOptions = dataOptionsDecoded
        let scrollbarOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ScrollBarOptions.self, forKey: .scrollbarOptions)
        scrollbarOptions = scrollbarOptionsDecoded
        let axisOffsetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .axisOffset)
        axisOffset = axisOffsetDecoded
    }
}

extension QuickSightClientTypes {
    /// The display options for the axis label.
    public struct AxisDisplayOptions: Swift.Equatable {
        /// Determines whether or not the axis line is visible.
        public var axisLineVisibility: QuickSightClientTypes.Visibility?
        /// The offset value that determines the starting placement of the axis within a visual's bounds.
        public var axisOffset: Swift.String?
        /// The data options for an axis.
        public var dataOptions: QuickSightClientTypes.AxisDataOptions?
        /// Determines whether or not the grid line is visible.
        public var gridLineVisibility: QuickSightClientTypes.Visibility?
        /// The scroll bar options for an axis.
        public var scrollbarOptions: QuickSightClientTypes.ScrollBarOptions?
        /// The tick label options of an axis.
        public var tickLabelOptions: QuickSightClientTypes.AxisTickLabelOptions?

        public init (
            axisLineVisibility: QuickSightClientTypes.Visibility? = nil,
            axisOffset: Swift.String? = nil,
            dataOptions: QuickSightClientTypes.AxisDataOptions? = nil,
            gridLineVisibility: QuickSightClientTypes.Visibility? = nil,
            scrollbarOptions: QuickSightClientTypes.ScrollBarOptions? = nil,
            tickLabelOptions: QuickSightClientTypes.AxisTickLabelOptions? = nil
        )
        {
            self.axisLineVisibility = axisLineVisibility
            self.axisOffset = axisOffset
            self.dataOptions = dataOptions
            self.gridLineVisibility = gridLineVisibility
            self.scrollbarOptions = scrollbarOptions
            self.tickLabelOptions = tickLabelOptions
        }
    }

}

extension QuickSightClientTypes.AxisDisplayRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataDriven = "DataDriven"
        case minMax = "MinMax"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataDriven = self.dataDriven {
            try encodeContainer.encode(dataDriven, forKey: .dataDriven)
        }
        if let minMax = self.minMax {
            try encodeContainer.encode(minMax, forKey: .minMax)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minMaxDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisDisplayMinMaxRange.self, forKey: .minMax)
        minMax = minMaxDecoded
        let dataDrivenDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisDisplayDataDrivenRange.self, forKey: .dataDriven)
        dataDriven = dataDrivenDecoded
    }
}

extension QuickSightClientTypes {
    /// The range setup of a numeric axis display range. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct AxisDisplayRange: Swift.Equatable {
        /// The data-driven setup of an axis display range.
        public var dataDriven: QuickSightClientTypes.AxisDisplayDataDrivenRange?
        /// The minimum and maximum setup of an axis display range.
        public var minMax: QuickSightClientTypes.AxisDisplayMinMaxRange?

        public init (
            dataDriven: QuickSightClientTypes.AxisDisplayDataDrivenRange? = nil,
            minMax: QuickSightClientTypes.AxisDisplayMinMaxRange? = nil
        )
        {
            self.dataDriven = dataDriven
            self.minMax = minMax
        }
    }

}

extension QuickSightClientTypes.AxisLabelOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyTo = "ApplyTo"
        case customLabel = "CustomLabel"
        case fontConfiguration = "FontConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applyTo = self.applyTo {
            try encodeContainer.encode(applyTo, forKey: .applyTo)
        }
        if let customLabel = self.customLabel {
            try encodeContainer.encode(customLabel, forKey: .customLabel)
        }
        if let fontConfiguration = self.fontConfiguration {
            try encodeContainer.encode(fontConfiguration, forKey: .fontConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fontConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FontConfiguration.self, forKey: .fontConfiguration)
        fontConfiguration = fontConfigurationDecoded
        let customLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customLabel)
        customLabel = customLabelDecoded
        let applyToDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisLabelReferenceOptions.self, forKey: .applyTo)
        applyTo = applyToDecoded
    }
}

extension QuickSightClientTypes {
    /// The label options for a chart axis. You must specify the field that the label is targeted to.
    public struct AxisLabelOptions: Swift.Equatable {
        /// The options that indicate which field the label belongs to.
        public var applyTo: QuickSightClientTypes.AxisLabelReferenceOptions?
        /// The text for the axis label.
        public var customLabel: Swift.String?
        /// The font configuration of the axis label.
        public var fontConfiguration: QuickSightClientTypes.FontConfiguration?

        public init (
            applyTo: QuickSightClientTypes.AxisLabelReferenceOptions? = nil,
            customLabel: Swift.String? = nil,
            fontConfiguration: QuickSightClientTypes.FontConfiguration? = nil
        )
        {
            self.applyTo = applyTo
            self.customLabel = customLabel
            self.fontConfiguration = fontConfiguration
        }
    }

}

extension QuickSightClientTypes.AxisLabelReferenceOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case column = "Column"
        case fieldId = "FieldId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let column = self.column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let columnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .column)
        column = columnDecoded
    }
}

extension QuickSightClientTypes {
    /// The reference that specifies where the axis label is applied to.
    public struct AxisLabelReferenceOptions: Swift.Equatable {
        /// The column that the axis label is targeted to.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The field that the axis label is targeted to.
        /// This member is required.
        public var fieldId: Swift.String?

        public init (
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            fieldId: Swift.String? = nil
        )
        {
            self.column = column
            self.fieldId = fieldId
        }
    }

}

extension QuickSightClientTypes.AxisLinearScale: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stepCount = "StepCount"
        case stepSize = "StepSize"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stepCount = self.stepCount {
            try encodeContainer.encode(stepCount, forKey: .stepCount)
        }
        if let stepSize = self.stepSize {
            try encodeContainer.encode(stepSize, forKey: .stepSize)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stepCount)
        stepCount = stepCountDecoded
        let stepSizeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .stepSize)
        stepSize = stepSizeDecoded
    }
}

extension QuickSightClientTypes {
    /// The liner axis scale setup. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct AxisLinearScale: Swift.Equatable {
        /// The step count setup of a linear axis.
        public var stepCount: Swift.Int?
        /// The step size setup of a linear axis.
        public var stepSize: Swift.Double?

        public init (
            stepCount: Swift.Int? = nil,
            stepSize: Swift.Double? = nil
        )
        {
            self.stepCount = stepCount
            self.stepSize = stepSize
        }
    }

}

extension QuickSightClientTypes.AxisLogarithmicScale: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case base = "Base"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let base = self.base {
            try encodeContainer.encode(base, forKey: .base)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .base)
        base = baseDecoded
    }
}

extension QuickSightClientTypes {
    /// The logarithmic axis scale setup.
    public struct AxisLogarithmicScale: Swift.Equatable {
        /// The base setup of a logarithmic axis scale.
        public var base: Swift.Double?

        public init (
            base: Swift.Double? = nil
        )
        {
            self.base = base
        }
    }

}

extension QuickSightClientTypes.AxisScale: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linear = "Linear"
        case logarithmic = "Logarithmic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let linear = self.linear {
            try encodeContainer.encode(linear, forKey: .linear)
        }
        if let logarithmic = self.logarithmic {
            try encodeContainer.encode(logarithmic, forKey: .logarithmic)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linearDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisLinearScale.self, forKey: .linear)
        linear = linearDecoded
        let logarithmicDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisLogarithmicScale.self, forKey: .logarithmic)
        logarithmic = logarithmicDecoded
    }
}

extension QuickSightClientTypes {
    /// The scale setup options for a numeric axis display. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct AxisScale: Swift.Equatable {
        /// The linear axis scale setup.
        public var linear: QuickSightClientTypes.AxisLinearScale?
        /// The logarithmic axis scale setup.
        public var logarithmic: QuickSightClientTypes.AxisLogarithmicScale?

        public init (
            linear: QuickSightClientTypes.AxisLinearScale? = nil,
            logarithmic: QuickSightClientTypes.AxisLogarithmicScale? = nil
        )
        {
            self.linear = linear
            self.logarithmic = logarithmic
        }
    }

}

extension QuickSightClientTypes.AxisTickLabelOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case labelOptions = "LabelOptions"
        case rotationAngle = "RotationAngle"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let labelOptions = self.labelOptions {
            try encodeContainer.encode(labelOptions, forKey: .labelOptions)
        }
        if let rotationAngle = self.rotationAngle {
            try encodeContainer.encode(rotationAngle, forKey: .rotationAngle)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LabelOptions.self, forKey: .labelOptions)
        labelOptions = labelOptionsDecoded
        let rotationAngleDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .rotationAngle)
        rotationAngle = rotationAngleDecoded
    }
}

extension QuickSightClientTypes {
    /// The tick label options of an axis.
    public struct AxisTickLabelOptions: Swift.Equatable {
        /// Determines whether or not the axis ticks are visible.
        public var labelOptions: QuickSightClientTypes.LabelOptions?
        /// The rotation angle of the axis tick labels.
        public var rotationAngle: Swift.Double?

        public init (
            labelOptions: QuickSightClientTypes.LabelOptions? = nil,
            rotationAngle: Swift.Double? = nil
        )
        {
            self.labelOptions = labelOptions
            self.rotationAngle = rotationAngle
        }
    }

}

extension QuickSightClientTypes.BarChartAggregatedFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category = "Category"
        case colors = "Colors"
        case smallMultiples = "SmallMultiples"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            var categoryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .category)
            for dimensionfield0 in category {
                try categoryContainer.encode(dimensionfield0)
            }
        }
        if let colors = colors {
            var colorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .colors)
            for dimensionfield0 in colors {
                try colorsContainer.encode(dimensionfield0)
            }
        }
        if let smallMultiples = smallMultiples {
            var smallMultiplesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .smallMultiples)
            for dimensionfield0 in smallMultiples {
                try smallMultiplesContainer.encode(dimensionfield0)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for measurefield0 in values {
                try valuesContainer.encode(measurefield0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .category)
        var categoryDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let categoryContainer = categoryContainer {
            categoryDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in categoryContainer {
                if let structure0 = structure0 {
                    categoryDecoded0?.append(structure0)
                }
            }
        }
        category = categoryDecoded0
        let valuesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .values)
        var valuesDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
        let colorsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .colors)
        var colorsDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let colorsContainer = colorsContainer {
            colorsDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in colorsContainer {
                if let structure0 = structure0 {
                    colorsDecoded0?.append(structure0)
                }
            }
        }
        colors = colorsDecoded0
        let smallMultiplesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .smallMultiples)
        var smallMultiplesDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let smallMultiplesContainer = smallMultiplesContainer {
            smallMultiplesDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in smallMultiplesContainer {
                if let structure0 = structure0 {
                    smallMultiplesDecoded0?.append(structure0)
                }
            }
        }
        smallMultiples = smallMultiplesDecoded0
    }
}

extension QuickSightClientTypes {
    /// The aggregated field wells of a bar chart.
    public struct BarChartAggregatedFieldWells: Swift.Equatable {
        /// The category (y-axis) field well of a bar chart.
        public var category: [QuickSightClientTypes.DimensionField]?
        /// The color (group/color) field well of a bar chart.
        public var colors: [QuickSightClientTypes.DimensionField]?
        /// The small multiples field well of a bar chart.
        public var smallMultiples: [QuickSightClientTypes.DimensionField]?
        /// The value field wells of a bar chart. Values are aggregated by category.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init (
            category: [QuickSightClientTypes.DimensionField]? = nil,
            colors: [QuickSightClientTypes.DimensionField]? = nil,
            smallMultiples: [QuickSightClientTypes.DimensionField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.category = category
            self.colors = colors
            self.smallMultiples = smallMultiples
            self.values = values
        }
    }

}

extension QuickSightClientTypes.BarChartConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case barsArrangement = "BarsArrangement"
        case categoryAxis = "CategoryAxis"
        case categoryLabelOptions = "CategoryLabelOptions"
        case colorLabelOptions = "ColorLabelOptions"
        case contributionAnalysisDefaults = "ContributionAnalysisDefaults"
        case dataLabels = "DataLabels"
        case fieldWells = "FieldWells"
        case legend = "Legend"
        case orientation = "Orientation"
        case referenceLines = "ReferenceLines"
        case smallMultiplesOptions = "SmallMultiplesOptions"
        case sortConfiguration = "SortConfiguration"
        case tooltip = "Tooltip"
        case valueAxis = "ValueAxis"
        case valueLabelOptions = "ValueLabelOptions"
        case visualPalette = "VisualPalette"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let barsArrangement = self.barsArrangement {
            try encodeContainer.encode(barsArrangement.rawValue, forKey: .barsArrangement)
        }
        if let categoryAxis = self.categoryAxis {
            try encodeContainer.encode(categoryAxis, forKey: .categoryAxis)
        }
        if let categoryLabelOptions = self.categoryLabelOptions {
            try encodeContainer.encode(categoryLabelOptions, forKey: .categoryLabelOptions)
        }
        if let colorLabelOptions = self.colorLabelOptions {
            try encodeContainer.encode(colorLabelOptions, forKey: .colorLabelOptions)
        }
        if let contributionAnalysisDefaults = contributionAnalysisDefaults {
            var contributionAnalysisDefaultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contributionAnalysisDefaults)
            for contributionanalysisdefault0 in contributionAnalysisDefaults {
                try contributionAnalysisDefaultsContainer.encode(contributionanalysisdefault0)
            }
        }
        if let dataLabels = self.dataLabels {
            try encodeContainer.encode(dataLabels, forKey: .dataLabels)
        }
        if let fieldWells = self.fieldWells {
            try encodeContainer.encode(fieldWells, forKey: .fieldWells)
        }
        if let legend = self.legend {
            try encodeContainer.encode(legend, forKey: .legend)
        }
        if let orientation = self.orientation {
            try encodeContainer.encode(orientation.rawValue, forKey: .orientation)
        }
        if let referenceLines = referenceLines {
            var referenceLinesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceLines)
            for referenceline0 in referenceLines {
                try referenceLinesContainer.encode(referenceline0)
            }
        }
        if let smallMultiplesOptions = self.smallMultiplesOptions {
            try encodeContainer.encode(smallMultiplesOptions, forKey: .smallMultiplesOptions)
        }
        if let sortConfiguration = self.sortConfiguration {
            try encodeContainer.encode(sortConfiguration, forKey: .sortConfiguration)
        }
        if let tooltip = self.tooltip {
            try encodeContainer.encode(tooltip, forKey: .tooltip)
        }
        if let valueAxis = self.valueAxis {
            try encodeContainer.encode(valueAxis, forKey: .valueAxis)
        }
        if let valueLabelOptions = self.valueLabelOptions {
            try encodeContainer.encode(valueLabelOptions, forKey: .valueLabelOptions)
        }
        if let visualPalette = self.visualPalette {
            try encodeContainer.encode(visualPalette, forKey: .visualPalette)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.BarChartFieldWells.self, forKey: .fieldWells)
        fieldWells = fieldWellsDecoded
        let sortConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.BarChartSortConfiguration.self, forKey: .sortConfiguration)
        sortConfiguration = sortConfigurationDecoded
        let orientationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.BarChartOrientation.self, forKey: .orientation)
        orientation = orientationDecoded
        let barsArrangementDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.BarsArrangement.self, forKey: .barsArrangement)
        barsArrangement = barsArrangementDecoded
        let visualPaletteDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualPalette.self, forKey: .visualPalette)
        visualPalette = visualPaletteDecoded
        let smallMultiplesOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SmallMultiplesOptions.self, forKey: .smallMultiplesOptions)
        smallMultiplesOptions = smallMultiplesOptionsDecoded
        let categoryAxisDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisDisplayOptions.self, forKey: .categoryAxis)
        categoryAxis = categoryAxisDecoded
        let categoryLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .categoryLabelOptions)
        categoryLabelOptions = categoryLabelOptionsDecoded
        let valueAxisDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisDisplayOptions.self, forKey: .valueAxis)
        valueAxis = valueAxisDecoded
        let valueLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .valueLabelOptions)
        valueLabelOptions = valueLabelOptionsDecoded
        let colorLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .colorLabelOptions)
        colorLabelOptions = colorLabelOptionsDecoded
        let legendDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LegendOptions.self, forKey: .legend)
        legend = legendDecoded
        let dataLabelsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataLabelOptions.self, forKey: .dataLabels)
        dataLabels = dataLabelsDecoded
        let tooltipDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TooltipOptions.self, forKey: .tooltip)
        tooltip = tooltipDecoded
        let referenceLinesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ReferenceLine?].self, forKey: .referenceLines)
        var referenceLinesDecoded0:[QuickSightClientTypes.ReferenceLine]? = nil
        if let referenceLinesContainer = referenceLinesContainer {
            referenceLinesDecoded0 = [QuickSightClientTypes.ReferenceLine]()
            for structure0 in referenceLinesContainer {
                if let structure0 = structure0 {
                    referenceLinesDecoded0?.append(structure0)
                }
            }
        }
        referenceLines = referenceLinesDecoded0
        let contributionAnalysisDefaultsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ContributionAnalysisDefault?].self, forKey: .contributionAnalysisDefaults)
        var contributionAnalysisDefaultsDecoded0:[QuickSightClientTypes.ContributionAnalysisDefault]? = nil
        if let contributionAnalysisDefaultsContainer = contributionAnalysisDefaultsContainer {
            contributionAnalysisDefaultsDecoded0 = [QuickSightClientTypes.ContributionAnalysisDefault]()
            for structure0 in contributionAnalysisDefaultsContainer {
                if let structure0 = structure0 {
                    contributionAnalysisDefaultsDecoded0?.append(structure0)
                }
            }
        }
        contributionAnalysisDefaults = contributionAnalysisDefaultsDecoded0
    }
}

extension QuickSightClientTypes {
    /// The configuration of a BarChartVisual.
    public struct BarChartConfiguration: Swift.Equatable {
        /// Determines the arrangement of the bars. The orientation and arrangement of bars determine the type of bar that is used in the visual.
        public var barsArrangement: QuickSightClientTypes.BarsArrangement?
        /// The label display options (grid line, range, scale, axis step) for bar chart category.
        public var categoryAxis: QuickSightClientTypes.AxisDisplayOptions?
        /// The label options (label text, label visibility and sort icon visibility) for a bar chart.
        public var categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The label options (label text, label visibility and sort icon visibility) for a color that is used in a bar chart.
        public var colorLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The contribution analysis (anomaly configuration) setup of the visual.
        public var contributionAnalysisDefaults: [QuickSightClientTypes.ContributionAnalysisDefault]?
        /// The options that determine if visual data labels are displayed.
        public var dataLabels: QuickSightClientTypes.DataLabelOptions?
        /// The field wells of the visual.
        public var fieldWells: QuickSightClientTypes.BarChartFieldWells?
        /// The legend display setup of the visual.
        public var legend: QuickSightClientTypes.LegendOptions?
        /// The orientation of the bars in a bar chart visual. There are two valid values in this structure:
        ///
        /// * HORIZONTAL: Used for charts that have horizontal bars. Visuals that use this value are horizontal bar charts, horizontal stacked bar charts, and horizontal stacked 100% bar charts.
        ///
        /// * VERTICAL: Used for charts that have vertical bars. Visuals that use this value are vertical bar charts, vertical stacked bar charts, and vertical stacked 100% bar charts.
        public var orientation: QuickSightClientTypes.BarChartOrientation?
        /// The reference line setup of the visual.
        public var referenceLines: [QuickSightClientTypes.ReferenceLine]?
        /// The small multiples setup for the visual.
        public var smallMultiplesOptions: QuickSightClientTypes.SmallMultiplesOptions?
        /// The sort configuration of a BarChartVisual.
        public var sortConfiguration: QuickSightClientTypes.BarChartSortConfiguration?
        /// The tooltip display setup of the visual.
        public var tooltip: QuickSightClientTypes.TooltipOptions?
        /// The label display options (grid line, range, scale, axis step) for a bar chart value.
        public var valueAxis: QuickSightClientTypes.AxisDisplayOptions?
        /// The label options (label text, label visibility and sort icon visibility) for a bar chart value.
        public var valueLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The palette (chart color) display setup of the visual.
        public var visualPalette: QuickSightClientTypes.VisualPalette?

        public init (
            barsArrangement: QuickSightClientTypes.BarsArrangement? = nil,
            categoryAxis: QuickSightClientTypes.AxisDisplayOptions? = nil,
            categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            colorLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            contributionAnalysisDefaults: [QuickSightClientTypes.ContributionAnalysisDefault]? = nil,
            dataLabels: QuickSightClientTypes.DataLabelOptions? = nil,
            fieldWells: QuickSightClientTypes.BarChartFieldWells? = nil,
            legend: QuickSightClientTypes.LegendOptions? = nil,
            orientation: QuickSightClientTypes.BarChartOrientation? = nil,
            referenceLines: [QuickSightClientTypes.ReferenceLine]? = nil,
            smallMultiplesOptions: QuickSightClientTypes.SmallMultiplesOptions? = nil,
            sortConfiguration: QuickSightClientTypes.BarChartSortConfiguration? = nil,
            tooltip: QuickSightClientTypes.TooltipOptions? = nil,
            valueAxis: QuickSightClientTypes.AxisDisplayOptions? = nil,
            valueLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            visualPalette: QuickSightClientTypes.VisualPalette? = nil
        )
        {
            self.barsArrangement = barsArrangement
            self.categoryAxis = categoryAxis
            self.categoryLabelOptions = categoryLabelOptions
            self.colorLabelOptions = colorLabelOptions
            self.contributionAnalysisDefaults = contributionAnalysisDefaults
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.legend = legend
            self.orientation = orientation
            self.referenceLines = referenceLines
            self.smallMultiplesOptions = smallMultiplesOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.valueAxis = valueAxis
            self.valueLabelOptions = valueLabelOptions
            self.visualPalette = visualPalette
        }
    }

}

extension QuickSightClientTypes.BarChartFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case barChartAggregatedFieldWells = "BarChartAggregatedFieldWells"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let barChartAggregatedFieldWells = self.barChartAggregatedFieldWells {
            try encodeContainer.encode(barChartAggregatedFieldWells, forKey: .barChartAggregatedFieldWells)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let barChartAggregatedFieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.BarChartAggregatedFieldWells.self, forKey: .barChartAggregatedFieldWells)
        barChartAggregatedFieldWells = barChartAggregatedFieldWellsDecoded
    }
}

extension QuickSightClientTypes {
    /// The field wells of a BarChartVisual. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct BarChartFieldWells: Swift.Equatable {
        /// The aggregated field wells of a bar chart.
        public var barChartAggregatedFieldWells: QuickSightClientTypes.BarChartAggregatedFieldWells?

        public init (
            barChartAggregatedFieldWells: QuickSightClientTypes.BarChartAggregatedFieldWells? = nil
        )
        {
            self.barChartAggregatedFieldWells = barChartAggregatedFieldWells
        }
    }

}

extension QuickSightClientTypes {
    public enum BarChartOrientation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case horizontal
        case vertical
        case sdkUnknown(Swift.String)

        public static var allCases: [BarChartOrientation] {
            return [
                .horizontal,
                .vertical,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .horizontal: return "HORIZONTAL"
            case .vertical: return "VERTICAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BarChartOrientation(rawValue: rawValue) ?? BarChartOrientation.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.BarChartSortConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryItemsLimit = "CategoryItemsLimit"
        case categorySort = "CategorySort"
        case colorItemsLimit = "ColorItemsLimit"
        case colorSort = "ColorSort"
        case smallMultiplesLimitConfiguration = "SmallMultiplesLimitConfiguration"
        case smallMultiplesSort = "SmallMultiplesSort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryItemsLimit = self.categoryItemsLimit {
            try encodeContainer.encode(categoryItemsLimit, forKey: .categoryItemsLimit)
        }
        if let categorySort = categorySort {
            var categorySortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categorySort)
            for fieldsortoptions0 in categorySort {
                try categorySortContainer.encode(fieldsortoptions0)
            }
        }
        if let colorItemsLimit = self.colorItemsLimit {
            try encodeContainer.encode(colorItemsLimit, forKey: .colorItemsLimit)
        }
        if let colorSort = colorSort {
            var colorSortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .colorSort)
            for fieldsortoptions0 in colorSort {
                try colorSortContainer.encode(fieldsortoptions0)
            }
        }
        if let smallMultiplesLimitConfiguration = self.smallMultiplesLimitConfiguration {
            try encodeContainer.encode(smallMultiplesLimitConfiguration, forKey: .smallMultiplesLimitConfiguration)
        }
        if let smallMultiplesSort = smallMultiplesSort {
            var smallMultiplesSortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .smallMultiplesSort)
            for fieldsortoptions0 in smallMultiplesSort {
                try smallMultiplesSortContainer.encode(fieldsortoptions0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categorySortContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FieldSortOptions?].self, forKey: .categorySort)
        var categorySortDecoded0:[QuickSightClientTypes.FieldSortOptions]? = nil
        if let categorySortContainer = categorySortContainer {
            categorySortDecoded0 = [QuickSightClientTypes.FieldSortOptions]()
            for structure0 in categorySortContainer {
                if let structure0 = structure0 {
                    categorySortDecoded0?.append(structure0)
                }
            }
        }
        categorySort = categorySortDecoded0
        let categoryItemsLimitDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ItemsLimitConfiguration.self, forKey: .categoryItemsLimit)
        categoryItemsLimit = categoryItemsLimitDecoded
        let colorSortContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FieldSortOptions?].self, forKey: .colorSort)
        var colorSortDecoded0:[QuickSightClientTypes.FieldSortOptions]? = nil
        if let colorSortContainer = colorSortContainer {
            colorSortDecoded0 = [QuickSightClientTypes.FieldSortOptions]()
            for structure0 in colorSortContainer {
                if let structure0 = structure0 {
                    colorSortDecoded0?.append(structure0)
                }
            }
        }
        colorSort = colorSortDecoded0
        let colorItemsLimitDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ItemsLimitConfiguration.self, forKey: .colorItemsLimit)
        colorItemsLimit = colorItemsLimitDecoded
        let smallMultiplesSortContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FieldSortOptions?].self, forKey: .smallMultiplesSort)
        var smallMultiplesSortDecoded0:[QuickSightClientTypes.FieldSortOptions]? = nil
        if let smallMultiplesSortContainer = smallMultiplesSortContainer {
            smallMultiplesSortDecoded0 = [QuickSightClientTypes.FieldSortOptions]()
            for structure0 in smallMultiplesSortContainer {
                if let structure0 = structure0 {
                    smallMultiplesSortDecoded0?.append(structure0)
                }
            }
        }
        smallMultiplesSort = smallMultiplesSortDecoded0
        let smallMultiplesLimitConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ItemsLimitConfiguration.self, forKey: .smallMultiplesLimitConfiguration)
        smallMultiplesLimitConfiguration = smallMultiplesLimitConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// sort-configuration-description
    public struct BarChartSortConfiguration: Swift.Equatable {
        /// The limit on the number of categories displayed in a bar chart.
        public var categoryItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of category fields.
        public var categorySort: [QuickSightClientTypes.FieldSortOptions]?
        /// The limit on the number of values displayed in a bar chart.
        public var colorItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of color fields in a bar chart.
        public var colorSort: [QuickSightClientTypes.FieldSortOptions]?
        /// The limit on the number of small multiples panels that are displayed.
        public var smallMultiplesLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of the small multiples field.
        public var smallMultiplesSort: [QuickSightClientTypes.FieldSortOptions]?

        public init (
            categoryItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            categorySort: [QuickSightClientTypes.FieldSortOptions]? = nil,
            colorItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            colorSort: [QuickSightClientTypes.FieldSortOptions]? = nil,
            smallMultiplesLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            smallMultiplesSort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.categoryItemsLimit = categoryItemsLimit
            self.categorySort = categorySort
            self.colorItemsLimit = colorItemsLimit
            self.colorSort = colorSort
            self.smallMultiplesLimitConfiguration = smallMultiplesLimitConfiguration
            self.smallMultiplesSort = smallMultiplesSort
        }
    }

}

extension QuickSightClientTypes.BarChartVisual: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case chartConfiguration = "ChartConfiguration"
        case columnHierarchies = "ColumnHierarchies"
        case subtitle = "Subtitle"
        case title = "Title"
        case visualId = "VisualId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for visualcustomaction0 in actions {
                try actionsContainer.encode(visualcustomaction0)
            }
        }
        if let chartConfiguration = self.chartConfiguration {
            try encodeContainer.encode(chartConfiguration, forKey: .chartConfiguration)
        }
        if let columnHierarchies = columnHierarchies {
            var columnHierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnHierarchies)
            for columnhierarchy0 in columnHierarchies {
                try columnHierarchiesContainer.encode(columnhierarchy0)
            }
        }
        if let subtitle = self.subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let visualId = self.visualId {
            try encodeContainer.encode(visualId, forKey: .visualId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visualIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visualId)
        visualId = visualIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualTitleLabelOptions.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualSubtitleLabelOptions.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let chartConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.BarChartConfiguration.self, forKey: .chartConfiguration)
        chartConfiguration = chartConfigurationDecoded
        let actionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.VisualCustomAction?].self, forKey: .actions)
        var actionsDecoded0:[QuickSightClientTypes.VisualCustomAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [QuickSightClientTypes.VisualCustomAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let columnHierarchiesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnHierarchy?].self, forKey: .columnHierarchies)
        var columnHierarchiesDecoded0:[QuickSightClientTypes.ColumnHierarchy]? = nil
        if let columnHierarchiesContainer = columnHierarchiesContainer {
            columnHierarchiesDecoded0 = [QuickSightClientTypes.ColumnHierarchy]()
            for structure0 in columnHierarchiesContainer {
                if let structure0 = structure0 {
                    columnHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        columnHierarchies = columnHierarchiesDecoded0
    }
}

extension QuickSightClientTypes {
    /// A bar chart. The BarChartVisual structure describes a visual that is a member of the bar chart family. The following charts can be described using this structure:
    ///
    /// * Horizontal bar chart
    ///
    /// * Vertical bar chart
    ///
    /// * Horizontal stacked bar chart
    ///
    /// * Vertical stacked bar chart
    ///
    /// * Horizontal stacked 100% bar chart
    ///
    /// * Vertical stacked 100% bar chart
    ///
    ///
    /// For more information, see [Using bar charts](https://docs.aws.amazon.com/quicksight/latest/user/bar-charts.html) in the Amazon QuickSight User Guide.
    public struct BarChartVisual: Swift.Equatable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration settings of the visual.
        public var chartConfiguration: QuickSightClientTypes.BarChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init (
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.BarChartConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }

}

extension QuickSightClientTypes {
    public enum BarsArrangement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case clustered
        case stacked
        case stackedPercent
        case sdkUnknown(Swift.String)

        public static var allCases: [BarsArrangement] {
            return [
                .clustered,
                .stacked,
                .stackedPercent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clustered: return "CLUSTERED"
            case .stacked: return "STACKED"
            case .stackedPercent: return "STACKED_PERCENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BarsArrangement(rawValue: rawValue) ?? BarsArrangement.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum BaseMapStyleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case darkGray
        case imagery
        case lightGray
        case street
        case sdkUnknown(Swift.String)

        public static var allCases: [BaseMapStyleType] {
            return [
                .darkGray,
                .imagery,
                .lightGray,
                .street,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .darkGray: return "DARK_GRAY"
            case .imagery: return "IMAGERY"
            case .lightGray: return "LIGHT_GRAY"
            case .street: return "STREET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BaseMapStyleType(rawValue: rawValue) ?? BaseMapStyleType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.BinCountOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .value)
        value = valueDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the bin count of a histogram.
    public struct BinCountOptions: Swift.Equatable {
        /// The options that determine the bin count value.
        public var value: Swift.Int?

        public init (
            value: Swift.Int? = nil
        )
        {
            self.value = value
        }
    }

}

extension QuickSightClientTypes.BinWidthOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case binCountLimit = "BinCountLimit"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let binCountLimit = self.binCountLimit {
            try encodeContainer.encode(binCountLimit, forKey: .binCountLimit)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
        let binCountLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .binCountLimit)
        binCountLimit = binCountLimitDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the bin width of a histogram.
    public struct BinWidthOptions: Swift.Equatable {
        /// The options that determine the bin count limit.
        public var binCountLimit: Swift.Int?
        /// The options that determine the bin width value.
        public var value: Swift.Double?

        public init (
            binCountLimit: Swift.Int? = nil,
            value: Swift.Double? = nil
        )
        {
            self.binCountLimit = binCountLimit
            self.value = value
        }
    }

}

extension QuickSightClientTypes.BodySectionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case pageBreakConfiguration = "PageBreakConfiguration"
        case sectionId = "SectionId"
        case style = "Style"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let pageBreakConfiguration = self.pageBreakConfiguration {
            try encodeContainer.encode(pageBreakConfiguration, forKey: .pageBreakConfiguration)
        }
        if let sectionId = self.sectionId {
            try encodeContainer.encode(sectionId, forKey: .sectionId)
        }
        if let style = self.style {
            try encodeContainer.encode(style, forKey: .style)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sectionId)
        sectionId = sectionIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.BodySectionContent.self, forKey: .content)
        content = contentDecoded
        let styleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SectionStyle.self, forKey: .style)
        style = styleDecoded
        let pageBreakConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SectionPageBreakConfiguration.self, forKey: .pageBreakConfiguration)
        pageBreakConfiguration = pageBreakConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of a body section.
    public struct BodySectionConfiguration: Swift.Equatable {
        /// The configuration of content in a body section.
        /// This member is required.
        public var content: QuickSightClientTypes.BodySectionContent?
        /// The configuration of a page break for a section.
        public var pageBreakConfiguration: QuickSightClientTypes.SectionPageBreakConfiguration?
        /// The unique identifier of a body section.
        /// This member is required.
        public var sectionId: Swift.String?
        /// The style options of a body section.
        public var style: QuickSightClientTypes.SectionStyle?

        public init (
            content: QuickSightClientTypes.BodySectionContent? = nil,
            pageBreakConfiguration: QuickSightClientTypes.SectionPageBreakConfiguration? = nil,
            sectionId: Swift.String? = nil,
            style: QuickSightClientTypes.SectionStyle? = nil
        )
        {
            self.content = content
            self.pageBreakConfiguration = pageBreakConfiguration
            self.sectionId = sectionId
            self.style = style
        }
    }

}

extension QuickSightClientTypes.BodySectionContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layout = "Layout"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layout = self.layout {
            try encodeContainer.encode(layout, forKey: .layout)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layoutDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SectionLayoutConfiguration.self, forKey: .layout)
        layout = layoutDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of content in a body section.
    public struct BodySectionContent: Swift.Equatable {
        /// The layout configuration of a body section.
        public var layout: QuickSightClientTypes.SectionLayoutConfiguration?

        public init (
            layout: QuickSightClientTypes.SectionLayoutConfiguration? = nil
        )
        {
            self.layout = layout
        }
    }

}

extension QuickSightClientTypes.BorderStyle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case show = "Show"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let show = self.show {
            try encodeContainer.encode(show, forKey: .show)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let showDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .show)
        show = showDecoded
    }
}

extension QuickSightClientTypes {
    /// The display options for tile borders for visuals.
    public struct BorderStyle: Swift.Equatable {
        /// The option to enable display of borders for visuals.
        public var show: Swift.Bool?

        public init (
            show: Swift.Bool? = nil
        )
        {
            self.show = show
        }
    }

}

extension QuickSightClientTypes.BoxPlotAggregatedFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupBy = "GroupBy"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupBy = groupBy {
            var groupByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupBy)
            for dimensionfield0 in groupBy {
                try groupByContainer.encode(dimensionfield0)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for measurefield0 in values {
                try valuesContainer.encode(measurefield0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupByContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .groupBy)
        var groupByDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let groupByContainer = groupByContainer {
            groupByDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in groupByContainer {
                if let structure0 = structure0 {
                    groupByDecoded0?.append(structure0)
                }
            }
        }
        groupBy = groupByDecoded0
        let valuesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .values)
        var valuesDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension QuickSightClientTypes {
    /// The aggregated field well for a box plot.
    public struct BoxPlotAggregatedFieldWells: Swift.Equatable {
        /// The group by field well of a box plot chart. Values are grouped based on group by fields.
        public var groupBy: [QuickSightClientTypes.DimensionField]?
        /// The value field well of a box plot chart. Values are aggregated based on group by fields.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init (
            groupBy: [QuickSightClientTypes.DimensionField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.groupBy = groupBy
            self.values = values
        }
    }

}

extension QuickSightClientTypes.BoxPlotChartConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case boxPlotOptions = "BoxPlotOptions"
        case categoryAxis = "CategoryAxis"
        case categoryLabelOptions = "CategoryLabelOptions"
        case fieldWells = "FieldWells"
        case legend = "Legend"
        case primaryYAxisDisplayOptions = "PrimaryYAxisDisplayOptions"
        case primaryYAxisLabelOptions = "PrimaryYAxisLabelOptions"
        case referenceLines = "ReferenceLines"
        case sortConfiguration = "SortConfiguration"
        case tooltip = "Tooltip"
        case visualPalette = "VisualPalette"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let boxPlotOptions = self.boxPlotOptions {
            try encodeContainer.encode(boxPlotOptions, forKey: .boxPlotOptions)
        }
        if let categoryAxis = self.categoryAxis {
            try encodeContainer.encode(categoryAxis, forKey: .categoryAxis)
        }
        if let categoryLabelOptions = self.categoryLabelOptions {
            try encodeContainer.encode(categoryLabelOptions, forKey: .categoryLabelOptions)
        }
        if let fieldWells = self.fieldWells {
            try encodeContainer.encode(fieldWells, forKey: .fieldWells)
        }
        if let legend = self.legend {
            try encodeContainer.encode(legend, forKey: .legend)
        }
        if let primaryYAxisDisplayOptions = self.primaryYAxisDisplayOptions {
            try encodeContainer.encode(primaryYAxisDisplayOptions, forKey: .primaryYAxisDisplayOptions)
        }
        if let primaryYAxisLabelOptions = self.primaryYAxisLabelOptions {
            try encodeContainer.encode(primaryYAxisLabelOptions, forKey: .primaryYAxisLabelOptions)
        }
        if let referenceLines = referenceLines {
            var referenceLinesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceLines)
            for referenceline0 in referenceLines {
                try referenceLinesContainer.encode(referenceline0)
            }
        }
        if let sortConfiguration = self.sortConfiguration {
            try encodeContainer.encode(sortConfiguration, forKey: .sortConfiguration)
        }
        if let tooltip = self.tooltip {
            try encodeContainer.encode(tooltip, forKey: .tooltip)
        }
        if let visualPalette = self.visualPalette {
            try encodeContainer.encode(visualPalette, forKey: .visualPalette)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.BoxPlotFieldWells.self, forKey: .fieldWells)
        fieldWells = fieldWellsDecoded
        let sortConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.BoxPlotSortConfiguration.self, forKey: .sortConfiguration)
        sortConfiguration = sortConfigurationDecoded
        let boxPlotOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.BoxPlotOptions.self, forKey: .boxPlotOptions)
        boxPlotOptions = boxPlotOptionsDecoded
        let categoryAxisDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisDisplayOptions.self, forKey: .categoryAxis)
        categoryAxis = categoryAxisDecoded
        let categoryLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .categoryLabelOptions)
        categoryLabelOptions = categoryLabelOptionsDecoded
        let primaryYAxisDisplayOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisDisplayOptions.self, forKey: .primaryYAxisDisplayOptions)
        primaryYAxisDisplayOptions = primaryYAxisDisplayOptionsDecoded
        let primaryYAxisLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .primaryYAxisLabelOptions)
        primaryYAxisLabelOptions = primaryYAxisLabelOptionsDecoded
        let legendDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LegendOptions.self, forKey: .legend)
        legend = legendDecoded
        let tooltipDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TooltipOptions.self, forKey: .tooltip)
        tooltip = tooltipDecoded
        let referenceLinesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ReferenceLine?].self, forKey: .referenceLines)
        var referenceLinesDecoded0:[QuickSightClientTypes.ReferenceLine]? = nil
        if let referenceLinesContainer = referenceLinesContainer {
            referenceLinesDecoded0 = [QuickSightClientTypes.ReferenceLine]()
            for structure0 in referenceLinesContainer {
                if let structure0 = structure0 {
                    referenceLinesDecoded0?.append(structure0)
                }
            }
        }
        referenceLines = referenceLinesDecoded0
        let visualPaletteDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualPalette.self, forKey: .visualPalette)
        visualPalette = visualPaletteDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of a BoxPlotVisual.
    public struct BoxPlotChartConfiguration: Swift.Equatable {
        /// The box plot chart options for a box plot visual
        public var boxPlotOptions: QuickSightClientTypes.BoxPlotOptions?
        /// The label display options (grid line, range, scale, axis step) of a box plot category.
        public var categoryAxis: QuickSightClientTypes.AxisDisplayOptions?
        /// The label options (label text, label visibility and sort Icon visibility) of a box plot category.
        public var categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The field wells of the visual.
        public var fieldWells: QuickSightClientTypes.BoxPlotFieldWells?
        /// The options for the legend setup of a visual.
        public var legend: QuickSightClientTypes.LegendOptions?
        /// The label display options (grid line, range, scale, axis step) of a box plot category.
        public var primaryYAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions?
        /// The label options (label text, label visibility and sort icon visibility) of a box plot value.
        public var primaryYAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The reference line setup of the visual.
        public var referenceLines: [QuickSightClientTypes.ReferenceLine]?
        /// The sort configuration of a BoxPlotVisual.
        public var sortConfiguration: QuickSightClientTypes.BoxPlotSortConfiguration?
        /// The tooltip display setup of the visual.
        public var tooltip: QuickSightClientTypes.TooltipOptions?
        /// The palette (chart color) display setup of the visual.
        public var visualPalette: QuickSightClientTypes.VisualPalette?

        public init (
            boxPlotOptions: QuickSightClientTypes.BoxPlotOptions? = nil,
            categoryAxis: QuickSightClientTypes.AxisDisplayOptions? = nil,
            categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            fieldWells: QuickSightClientTypes.BoxPlotFieldWells? = nil,
            legend: QuickSightClientTypes.LegendOptions? = nil,
            primaryYAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions? = nil,
            primaryYAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            referenceLines: [QuickSightClientTypes.ReferenceLine]? = nil,
            sortConfiguration: QuickSightClientTypes.BoxPlotSortConfiguration? = nil,
            tooltip: QuickSightClientTypes.TooltipOptions? = nil,
            visualPalette: QuickSightClientTypes.VisualPalette? = nil
        )
        {
            self.boxPlotOptions = boxPlotOptions
            self.categoryAxis = categoryAxis
            self.categoryLabelOptions = categoryLabelOptions
            self.fieldWells = fieldWells
            self.legend = legend
            self.primaryYAxisDisplayOptions = primaryYAxisDisplayOptions
            self.primaryYAxisLabelOptions = primaryYAxisLabelOptions
            self.referenceLines = referenceLines
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.visualPalette = visualPalette
        }
    }

}

extension QuickSightClientTypes.BoxPlotFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case boxPlotAggregatedFieldWells = "BoxPlotAggregatedFieldWells"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let boxPlotAggregatedFieldWells = self.boxPlotAggregatedFieldWells {
            try encodeContainer.encode(boxPlotAggregatedFieldWells, forKey: .boxPlotAggregatedFieldWells)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let boxPlotAggregatedFieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.BoxPlotAggregatedFieldWells.self, forKey: .boxPlotAggregatedFieldWells)
        boxPlotAggregatedFieldWells = boxPlotAggregatedFieldWellsDecoded
    }
}

extension QuickSightClientTypes {
    /// The field wells of a BoxPlotVisual. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct BoxPlotFieldWells: Swift.Equatable {
        /// The aggregated field wells of a box plot.
        public var boxPlotAggregatedFieldWells: QuickSightClientTypes.BoxPlotAggregatedFieldWells?

        public init (
            boxPlotAggregatedFieldWells: QuickSightClientTypes.BoxPlotAggregatedFieldWells? = nil
        )
        {
            self.boxPlotAggregatedFieldWells = boxPlotAggregatedFieldWells
        }
    }

}

extension QuickSightClientTypes {
    public enum BoxPlotFillStyle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case solid
        case transparent
        case sdkUnknown(Swift.String)

        public static var allCases: [BoxPlotFillStyle] {
            return [
                .solid,
                .transparent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .solid: return "SOLID"
            case .transparent: return "TRANSPARENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BoxPlotFillStyle(rawValue: rawValue) ?? BoxPlotFillStyle.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.BoxPlotOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allDataPointsVisibility = "AllDataPointsVisibility"
        case outlierVisibility = "OutlierVisibility"
        case styleOptions = "StyleOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allDataPointsVisibility = self.allDataPointsVisibility {
            try encodeContainer.encode(allDataPointsVisibility.rawValue, forKey: .allDataPointsVisibility)
        }
        if let outlierVisibility = self.outlierVisibility {
            try encodeContainer.encode(outlierVisibility.rawValue, forKey: .outlierVisibility)
        }
        if let styleOptions = self.styleOptions {
            try encodeContainer.encode(styleOptions, forKey: .styleOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let styleOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.BoxPlotStyleOptions.self, forKey: .styleOptions)
        styleOptions = styleOptionsDecoded
        let outlierVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .outlierVisibility)
        outlierVisibility = outlierVisibilityDecoded
        let allDataPointsVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .allDataPointsVisibility)
        allDataPointsVisibility = allDataPointsVisibilityDecoded
    }
}

extension QuickSightClientTypes {
    /// The options of a box plot visual.
    public struct BoxPlotOptions: Swift.Equatable {
        /// Determines the visibility of all data points of the box plot.
        public var allDataPointsVisibility: QuickSightClientTypes.Visibility?
        /// Determines the visibility of the outlier in a box plot.
        public var outlierVisibility: QuickSightClientTypes.Visibility?
        /// The style options of the box plot.
        public var styleOptions: QuickSightClientTypes.BoxPlotStyleOptions?

        public init (
            allDataPointsVisibility: QuickSightClientTypes.Visibility? = nil,
            outlierVisibility: QuickSightClientTypes.Visibility? = nil,
            styleOptions: QuickSightClientTypes.BoxPlotStyleOptions? = nil
        )
        {
            self.allDataPointsVisibility = allDataPointsVisibility
            self.outlierVisibility = outlierVisibility
            self.styleOptions = styleOptions
        }
    }

}

extension QuickSightClientTypes.BoxPlotSortConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categorySort = "CategorySort"
        case paginationConfiguration = "PaginationConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categorySort = categorySort {
            var categorySortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categorySort)
            for fieldsortoptions0 in categorySort {
                try categorySortContainer.encode(fieldsortoptions0)
            }
        }
        if let paginationConfiguration = self.paginationConfiguration {
            try encodeContainer.encode(paginationConfiguration, forKey: .paginationConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categorySortContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FieldSortOptions?].self, forKey: .categorySort)
        var categorySortDecoded0:[QuickSightClientTypes.FieldSortOptions]? = nil
        if let categorySortContainer = categorySortContainer {
            categorySortDecoded0 = [QuickSightClientTypes.FieldSortOptions]()
            for structure0 in categorySortContainer {
                if let structure0 = structure0 {
                    categorySortDecoded0?.append(structure0)
                }
            }
        }
        categorySort = categorySortDecoded0
        let paginationConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PaginationConfiguration.self, forKey: .paginationConfiguration)
        paginationConfiguration = paginationConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The sort configuration of a BoxPlotVisual.
    public struct BoxPlotSortConfiguration: Swift.Equatable {
        /// The sort configuration of a group by fields.
        public var categorySort: [QuickSightClientTypes.FieldSortOptions]?
        /// The pagination configuration of a table visual or box plot.
        public var paginationConfiguration: QuickSightClientTypes.PaginationConfiguration?

        public init (
            categorySort: [QuickSightClientTypes.FieldSortOptions]? = nil,
            paginationConfiguration: QuickSightClientTypes.PaginationConfiguration? = nil
        )
        {
            self.categorySort = categorySort
            self.paginationConfiguration = paginationConfiguration
        }
    }

}

extension QuickSightClientTypes.BoxPlotStyleOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fillStyle = "FillStyle"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fillStyle = self.fillStyle {
            try encodeContainer.encode(fillStyle.rawValue, forKey: .fillStyle)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fillStyleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.BoxPlotFillStyle.self, forKey: .fillStyle)
        fillStyle = fillStyleDecoded
    }
}

extension QuickSightClientTypes {
    /// The style options of the box plot.
    public struct BoxPlotStyleOptions: Swift.Equatable {
        /// The fill styles (solid, transparent) of the box plot.
        public var fillStyle: QuickSightClientTypes.BoxPlotFillStyle?

        public init (
            fillStyle: QuickSightClientTypes.BoxPlotFillStyle? = nil
        )
        {
            self.fillStyle = fillStyle
        }
    }

}

extension QuickSightClientTypes.BoxPlotVisual: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case chartConfiguration = "ChartConfiguration"
        case columnHierarchies = "ColumnHierarchies"
        case subtitle = "Subtitle"
        case title = "Title"
        case visualId = "VisualId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for visualcustomaction0 in actions {
                try actionsContainer.encode(visualcustomaction0)
            }
        }
        if let chartConfiguration = self.chartConfiguration {
            try encodeContainer.encode(chartConfiguration, forKey: .chartConfiguration)
        }
        if let columnHierarchies = columnHierarchies {
            var columnHierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnHierarchies)
            for columnhierarchy0 in columnHierarchies {
                try columnHierarchiesContainer.encode(columnhierarchy0)
            }
        }
        if let subtitle = self.subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let visualId = self.visualId {
            try encodeContainer.encode(visualId, forKey: .visualId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visualIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visualId)
        visualId = visualIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualTitleLabelOptions.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualSubtitleLabelOptions.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let chartConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.BoxPlotChartConfiguration.self, forKey: .chartConfiguration)
        chartConfiguration = chartConfigurationDecoded
        let actionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.VisualCustomAction?].self, forKey: .actions)
        var actionsDecoded0:[QuickSightClientTypes.VisualCustomAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [QuickSightClientTypes.VisualCustomAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let columnHierarchiesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnHierarchy?].self, forKey: .columnHierarchies)
        var columnHierarchiesDecoded0:[QuickSightClientTypes.ColumnHierarchy]? = nil
        if let columnHierarchiesContainer = columnHierarchiesContainer {
            columnHierarchiesDecoded0 = [QuickSightClientTypes.ColumnHierarchy]()
            for structure0 in columnHierarchiesContainer {
                if let structure0 = structure0 {
                    columnHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        columnHierarchies = columnHierarchiesDecoded0
    }
}

extension QuickSightClientTypes {
    /// A box plot. For more information, see [Using box plots](https://docs.aws.amazon.com/quicksight/latest/user/box-plots.html) in the Amazon QuickSight User Guide.
    public struct BoxPlotVisual: Swift.Equatable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration settings of the visual.
        public var chartConfiguration: QuickSightClientTypes.BoxPlotChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        /// This member is required.
        public var visualId: Swift.String?

        public init (
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.BoxPlotChartConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }

}

extension QuickSightClientTypes.CalculatedColumn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnId = "ColumnId"
        case columnName = "ColumnName"
        case expression = "Expression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnId = self.columnId {
            try encodeContainer.encode(columnId, forKey: .columnId)
        }
        if let columnName = self.columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let columnIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnId)
        columnId = columnIdDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
    }
}

extension QuickSightClientTypes.CalculatedColumn: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculatedColumn(columnId: \(Swift.String(describing: columnId)), columnName: \(Swift.String(describing: columnName)), expression: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {
    /// A calculated column for a dataset.
    public struct CalculatedColumn: Swift.Equatable {
        /// A unique ID to identify a calculated column. During a dataset update, if the column ID of a calculated column matches that of an existing calculated column, Amazon QuickSight preserves the existing calculated column.
        /// This member is required.
        public var columnId: Swift.String?
        /// Column name.
        /// This member is required.
        public var columnName: Swift.String?
        /// An expression that defines the calculated column.
        /// This member is required.
        public var expression: Swift.String?

        public init (
            columnId: Swift.String? = nil,
            columnName: Swift.String? = nil,
            expression: Swift.String? = nil
        )
        {
            self.columnId = columnId
            self.columnName = columnName
            self.expression = expression
        }
    }

}

extension QuickSightClientTypes.CalculatedField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetIdentifier = "DataSetIdentifier"
        case expression = "Expression"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSetIdentifier = self.dataSetIdentifier {
            try encodeContainer.encode(dataSetIdentifier, forKey: .dataSetIdentifier)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetIdentifier)
        dataSetIdentifier = dataSetIdentifierDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
    }
}

extension QuickSightClientTypes.CalculatedField: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculatedField(dataSetIdentifier: \(Swift.String(describing: dataSetIdentifier)), name: \(Swift.String(describing: name)), expression: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {
    /// The calculated field of an analysis.
    public struct CalculatedField: Swift.Equatable {
        /// The data set that is used in this calculated field.
        /// This member is required.
        public var dataSetIdentifier: Swift.String?
        /// The expression of the calculated field.
        /// This member is required.
        public var expression: Swift.String?
        /// The name of the calculated field.
        /// This member is required.
        public var name: Swift.String?

        public init (
            dataSetIdentifier: Swift.String? = nil,
            expression: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.dataSetIdentifier = dataSetIdentifier
            self.expression = expression
            self.name = name
        }
    }

}

extension QuickSightClientTypes.CalculatedMeasureField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression = "Expression"
        case fieldId = "FieldId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
    }
}

extension QuickSightClientTypes.CalculatedMeasureField: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculatedMeasureField(fieldId: \(Swift.String(describing: fieldId)), expression: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {
    /// The table calculation measure field for pivot tables.
    public struct CalculatedMeasureField: Swift.Equatable {
        /// The expression in the table calculation.
        /// This member is required.
        public var expression: Swift.String?
        /// The custom field ID.
        /// This member is required.
        public var fieldId: Swift.String?

        public init (
            expression: Swift.String? = nil,
            fieldId: Swift.String? = nil
        )
        {
            self.expression = expression
            self.fieldId = fieldId
        }
    }

}

extension CancelIngestionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSetId = dataSetId else {
            return nil
        }
        guard let ingestionId = ingestionId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/ingestions/\(ingestionId.urlPercentEncoding())"
    }
}

public struct CancelIngestionInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dataset used in the ingestion.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// An ID for the ingestion.
    /// This member is required.
    public var ingestionId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        ingestionId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
        self.ingestionId = ingestionId
    }
}

struct CancelIngestionInputBody: Swift.Equatable {
}

extension CancelIngestionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelIngestionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelIngestionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelIngestionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelIngestionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CancelIngestionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.ingestionId = output.ingestionId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.ingestionId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CancelIngestionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the data ingestion.
    public var arn: Swift.String?
    /// An ID for the ingestion.
    public var ingestionId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        ingestionId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.ingestionId = ingestionId
        self.requestId = requestId
        self.status = status
    }
}

struct CancelIngestionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let ingestionId: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension CancelIngestionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case ingestionId = "IngestionId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ingestionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ingestionId)
        ingestionId = ingestionIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension QuickSightClientTypes.CascadingControlConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceControls = "SourceControls"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceControls = sourceControls {
            var sourceControlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceControls)
            for cascadingcontrolsource0 in sourceControls {
                try sourceControlsContainer.encode(cascadingcontrolsource0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceControlsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.CascadingControlSource?].self, forKey: .sourceControls)
        var sourceControlsDecoded0:[QuickSightClientTypes.CascadingControlSource]? = nil
        if let sourceControlsContainer = sourceControlsContainer {
            sourceControlsDecoded0 = [QuickSightClientTypes.CascadingControlSource]()
            for structure0 in sourceControlsContainer {
                if let structure0 = structure0 {
                    sourceControlsDecoded0?.append(structure0)
                }
            }
        }
        sourceControls = sourceControlsDecoded0
    }
}

extension QuickSightClientTypes {
    /// The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.
    public struct CascadingControlConfiguration: Swift.Equatable {
        /// A list of source controls that determine the values that are used in the current control.
        public var sourceControls: [QuickSightClientTypes.CascadingControlSource]?

        public init (
            sourceControls: [QuickSightClientTypes.CascadingControlSource]? = nil
        )
        {
            self.sourceControls = sourceControls
        }
    }

}

extension QuickSightClientTypes.CascadingControlSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnToMatch = "ColumnToMatch"
        case sourceSheetControlId = "SourceSheetControlId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnToMatch = self.columnToMatch {
            try encodeContainer.encode(columnToMatch, forKey: .columnToMatch)
        }
        if let sourceSheetControlId = self.sourceSheetControlId {
            try encodeContainer.encode(sourceSheetControlId, forKey: .sourceSheetControlId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceSheetControlIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceSheetControlId)
        sourceSheetControlId = sourceSheetControlIdDecoded
        let columnToMatchDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .columnToMatch)
        columnToMatch = columnToMatchDecoded
    }
}

extension QuickSightClientTypes {
    /// The source controls that are used in a CascadingControlConfiguration.
    public struct CascadingControlSource: Swift.Equatable {
        /// The column identifier that determines which column to look up for the source sheet control.
        public var columnToMatch: QuickSightClientTypes.ColumnIdentifier?
        /// The source sheet control ID of a CascadingControlSource.
        public var sourceSheetControlId: Swift.String?

        public init (
            columnToMatch: QuickSightClientTypes.ColumnIdentifier? = nil,
            sourceSheetControlId: Swift.String? = nil
        )
        {
            self.columnToMatch = columnToMatch
            self.sourceSheetControlId = sourceSheetControlId
        }
    }

}

extension QuickSightClientTypes.CastColumnTypeOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnName = "ColumnName"
        case format = "Format"
        case newColumnType = "NewColumnType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnName = self.columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let newColumnType = self.newColumnType {
            try encodeContainer.encode(newColumnType.rawValue, forKey: .newColumnType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let newColumnTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnDataType.self, forKey: .newColumnType)
        newColumnType = newColumnTypeDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
    }
}

extension QuickSightClientTypes {
    /// A transform operation that casts a column to a different type.
    public struct CastColumnTypeOperation: Swift.Equatable {
        /// Column name.
        /// This member is required.
        public var columnName: Swift.String?
        /// When casting a column from string to datetime type, you can supply a string in a format supported by Amazon QuickSight to denote the source data format.
        public var format: Swift.String?
        /// New column data type.
        /// This member is required.
        public var newColumnType: QuickSightClientTypes.ColumnDataType?

        public init (
            columnName: Swift.String? = nil,
            format: Swift.String? = nil,
            newColumnType: QuickSightClientTypes.ColumnDataType? = nil
        )
        {
            self.columnName = columnName
            self.format = format
            self.newColumnType = newColumnType
        }
    }

}

extension QuickSightClientTypes {
    public enum CategoricalAggregationFunction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case count
        case distinctCount
        case sdkUnknown(Swift.String)

        public static var allCases: [CategoricalAggregationFunction] {
            return [
                .count,
                .distinctCount,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .count: return "COUNT"
            case .distinctCount: return "DISTINCT_COUNT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CategoricalAggregationFunction(rawValue: rawValue) ?? CategoricalAggregationFunction.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.CategoricalDimensionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case column = "Column"
        case fieldId = "FieldId"
        case formatConfiguration = "FormatConfiguration"
        case hierarchyId = "HierarchyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let column = self.column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
        if let formatConfiguration = self.formatConfiguration {
            try encodeContainer.encode(formatConfiguration, forKey: .formatConfiguration)
        }
        if let hierarchyId = self.hierarchyId {
            try encodeContainer.encode(hierarchyId, forKey: .hierarchyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let columnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .column)
        column = columnDecoded
        let hierarchyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyId)
        hierarchyId = hierarchyIdDecoded
        let formatConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.StringFormatConfiguration.self, forKey: .formatConfiguration)
        formatConfiguration = formatConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The dimension type field with categorical type columns..
    public struct CategoricalDimensionField: Swift.Equatable {
        /// The column that is used in the CategoricalDimensionField.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The custom field ID.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The format configuration of the field.
        public var formatConfiguration: QuickSightClientTypes.StringFormatConfiguration?
        /// The custom hierarchy ID.
        public var hierarchyId: Swift.String?

        public init (
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            fieldId: Swift.String? = nil,
            formatConfiguration: QuickSightClientTypes.StringFormatConfiguration? = nil,
            hierarchyId: Swift.String? = nil
        )
        {
            self.column = column
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
            self.hierarchyId = hierarchyId
        }
    }

}

extension QuickSightClientTypes.CategoricalMeasureField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationFunction = "AggregationFunction"
        case column = "Column"
        case fieldId = "FieldId"
        case formatConfiguration = "FormatConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationFunction = self.aggregationFunction {
            try encodeContainer.encode(aggregationFunction.rawValue, forKey: .aggregationFunction)
        }
        if let column = self.column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
        if let formatConfiguration = self.formatConfiguration {
            try encodeContainer.encode(formatConfiguration, forKey: .formatConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let columnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .column)
        column = columnDecoded
        let aggregationFunctionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CategoricalAggregationFunction.self, forKey: .aggregationFunction)
        aggregationFunction = aggregationFunctionDecoded
        let formatConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.StringFormatConfiguration.self, forKey: .formatConfiguration)
        formatConfiguration = formatConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The measure type field with categorical type columns.
    public struct CategoricalMeasureField: Swift.Equatable {
        /// The aggregation function of the measure field.
        public var aggregationFunction: QuickSightClientTypes.CategoricalAggregationFunction?
        /// The column that is used in the CategoricalMeasureField.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The custom field ID.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The format configuration of the field.
        public var formatConfiguration: QuickSightClientTypes.StringFormatConfiguration?

        public init (
            aggregationFunction: QuickSightClientTypes.CategoricalAggregationFunction? = nil,
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            fieldId: Swift.String? = nil,
            formatConfiguration: QuickSightClientTypes.StringFormatConfiguration? = nil
        )
        {
            self.aggregationFunction = aggregationFunction
            self.column = column
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
        }
    }

}

extension QuickSightClientTypes.CategoryDrillDownFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryValues = "CategoryValues"
        case column = "Column"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryValues = categoryValues {
            var categoryValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categoryValues)
            for categoryvalue0 in categoryValues {
                try categoryValuesContainer.encode(categoryvalue0)
            }
        }
        if let column = self.column {
            try encodeContainer.encode(column, forKey: .column)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .column)
        column = columnDecoded
        let categoryValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .categoryValues)
        var categoryValuesDecoded0:[Swift.String]? = nil
        if let categoryValuesContainer = categoryValuesContainer {
            categoryValuesDecoded0 = [Swift.String]()
            for string0 in categoryValuesContainer {
                if let string0 = string0 {
                    categoryValuesDecoded0?.append(string0)
                }
            }
        }
        categoryValues = categoryValuesDecoded0
    }
}

extension QuickSightClientTypes {
    /// The numeric equality type drill down filter.
    public struct CategoryDrillDownFilter: Swift.Equatable {
        /// A list of the string inputs that are the values of the category drill down filter.
        /// This member is required.
        public var categoryValues: [Swift.String]?
        /// The column that the filter is applied to.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?

        public init (
            categoryValues: [Swift.String]? = nil,
            column: QuickSightClientTypes.ColumnIdentifier? = nil
        )
        {
            self.categoryValues = categoryValues
            self.column = column
        }
    }

}

extension QuickSightClientTypes.CategoryFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case column = "Column"
        case configuration = "Configuration"
        case filterId = "FilterId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let column = self.column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let filterId = self.filterId {
            try encodeContainer.encode(filterId, forKey: .filterId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterId)
        filterId = filterIdDecoded
        let columnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .column)
        column = columnDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CategoryFilterConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension QuickSightClientTypes {
    /// A CategoryFilter filters text values. For more information, see [Adding text filters](https://docs.aws.amazon.com/quicksight/latest/user/add-a-text-filter-data-prep.html) in the Amazon QuickSight User Guide.
    public struct CategoryFilter: Swift.Equatable {
        /// The column that the filter is applied to.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The configuration for a CategoryFilter.
        public var configuration: QuickSightClientTypes.CategoryFilterConfiguration?
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        /// This member is required.
        public var filterId: Swift.String?

        public init (
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            configuration: QuickSightClientTypes.CategoryFilterConfiguration? = nil,
            filterId: Swift.String? = nil
        )
        {
            self.column = column
            self.configuration = configuration
            self.filterId = filterId
        }
    }

}

extension QuickSightClientTypes.CategoryFilterConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customFilterConfiguration = "CustomFilterConfiguration"
        case customFilterListConfiguration = "CustomFilterListConfiguration"
        case filterListConfiguration = "FilterListConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customFilterConfiguration = self.customFilterConfiguration {
            try encodeContainer.encode(customFilterConfiguration, forKey: .customFilterConfiguration)
        }
        if let customFilterListConfiguration = self.customFilterListConfiguration {
            try encodeContainer.encode(customFilterListConfiguration, forKey: .customFilterListConfiguration)
        }
        if let filterListConfiguration = self.filterListConfiguration {
            try encodeContainer.encode(filterListConfiguration, forKey: .filterListConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterListConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterListConfiguration.self, forKey: .filterListConfiguration)
        filterListConfiguration = filterListConfigurationDecoded
        let customFilterListConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CustomFilterListConfiguration.self, forKey: .customFilterListConfiguration)
        customFilterListConfiguration = customFilterListConfigurationDecoded
        let customFilterConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CustomFilterConfiguration.self, forKey: .customFilterConfiguration)
        customFilterConfiguration = customFilterConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration for a CategoryFilter. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct CategoryFilterConfiguration: Swift.Equatable {
        /// A custom filter that filters based on a single value. This filter can be partially matched.
        public var customFilterConfiguration: QuickSightClientTypes.CustomFilterConfiguration?
        /// A list of custom filter values. In the Amazon QuickSight console, this filter type is called a custom filter list.
        public var customFilterListConfiguration: QuickSightClientTypes.CustomFilterListConfiguration?
        /// A list of filter configurations. In the Amazon QuickSight console, this filter type is called a filter list.
        public var filterListConfiguration: QuickSightClientTypes.FilterListConfiguration?

        public init (
            customFilterConfiguration: QuickSightClientTypes.CustomFilterConfiguration? = nil,
            customFilterListConfiguration: QuickSightClientTypes.CustomFilterListConfiguration? = nil,
            filterListConfiguration: QuickSightClientTypes.FilterListConfiguration? = nil
        )
        {
            self.customFilterConfiguration = customFilterConfiguration
            self.customFilterListConfiguration = customFilterListConfiguration
            self.filterListConfiguration = filterListConfiguration
        }
    }

}

extension QuickSightClientTypes {
    public enum CategoryFilterMatchOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contains
        case doesNotContain
        case doesNotEqual
        case endsWith
        case equals
        case startsWith
        case sdkUnknown(Swift.String)

        public static var allCases: [CategoryFilterMatchOperator] {
            return [
                .contains,
                .doesNotContain,
                .doesNotEqual,
                .endsWith,
                .equals,
                .startsWith,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .doesNotContain: return "DOES_NOT_CONTAIN"
            case .doesNotEqual: return "DOES_NOT_EQUAL"
            case .endsWith: return "ENDS_WITH"
            case .equals: return "EQUALS"
            case .startsWith: return "STARTS_WITH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CategoryFilterMatchOperator(rawValue: rawValue) ?? CategoryFilterMatchOperator.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum CategoryFilterSelectAllOptions: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case filterAllValues
        case sdkUnknown(Swift.String)

        public static var allCases: [CategoryFilterSelectAllOptions] {
            return [
                .filterAllValues,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .filterAllValues: return "FILTER_ALL_VALUES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CategoryFilterSelectAllOptions(rawValue: rawValue) ?? CategoryFilterSelectAllOptions.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.ChartAxisLabelOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case axisLabelOptions = "AxisLabelOptions"
        case sortIconVisibility = "SortIconVisibility"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let axisLabelOptions = axisLabelOptions {
            var axisLabelOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .axisLabelOptions)
            for axislabeloptions0 in axisLabelOptions {
                try axisLabelOptionsContainer.encode(axislabeloptions0)
            }
        }
        if let sortIconVisibility = self.sortIconVisibility {
            try encodeContainer.encode(sortIconVisibility.rawValue, forKey: .sortIconVisibility)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
        let sortIconVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .sortIconVisibility)
        sortIconVisibility = sortIconVisibilityDecoded
        let axisLabelOptionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.AxisLabelOptions?].self, forKey: .axisLabelOptions)
        var axisLabelOptionsDecoded0:[QuickSightClientTypes.AxisLabelOptions]? = nil
        if let axisLabelOptionsContainer = axisLabelOptionsContainer {
            axisLabelOptionsDecoded0 = [QuickSightClientTypes.AxisLabelOptions]()
            for structure0 in axisLabelOptionsContainer {
                if let structure0 = structure0 {
                    axisLabelOptionsDecoded0?.append(structure0)
                }
            }
        }
        axisLabelOptions = axisLabelOptionsDecoded0
    }
}

extension QuickSightClientTypes {
    /// The label options for an axis on a chart.
    public struct ChartAxisLabelOptions: Swift.Equatable {
        /// The label options for a chart axis.
        public var axisLabelOptions: [QuickSightClientTypes.AxisLabelOptions]?
        /// The visibility configuration of the sort icon on a chart's axis label.
        public var sortIconVisibility: QuickSightClientTypes.Visibility?
        /// The visibility of an axis label on a chart. Choose one of the following options:
        ///
        /// * VISIBLE: Shows the axis.
        ///
        /// * HIDDEN: Hides the axis.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            axisLabelOptions: [QuickSightClientTypes.AxisLabelOptions]? = nil,
            sortIconVisibility: QuickSightClientTypes.Visibility? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.axisLabelOptions = axisLabelOptions
            self.sortIconVisibility = sortIconVisibility
            self.visibility = visibility
        }
    }

}

extension QuickSightClientTypes.ClusterMarker: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case simpleClusterMarker = "SimpleClusterMarker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simpleClusterMarker = self.simpleClusterMarker {
            try encodeContainer.encode(simpleClusterMarker, forKey: .simpleClusterMarker)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simpleClusterMarkerDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SimpleClusterMarker.self, forKey: .simpleClusterMarker)
        simpleClusterMarker = simpleClusterMarkerDecoded
    }
}

extension QuickSightClientTypes {
    /// The cluster marker that is a part of the cluster marker configuration.
    public struct ClusterMarker: Swift.Equatable {
        /// The simple cluster marker of the cluster marker.
        public var simpleClusterMarker: QuickSightClientTypes.SimpleClusterMarker?

        public init (
            simpleClusterMarker: QuickSightClientTypes.SimpleClusterMarker? = nil
        )
        {
            self.simpleClusterMarker = simpleClusterMarker
        }
    }

}

extension QuickSightClientTypes.ClusterMarkerConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterMarker = "ClusterMarker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterMarker = self.clusterMarker {
            try encodeContainer.encode(clusterMarker, forKey: .clusterMarker)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterMarkerDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ClusterMarker.self, forKey: .clusterMarker)
        clusterMarker = clusterMarkerDecoded
    }
}

extension QuickSightClientTypes {
    /// The cluster marker configuration of the geospatial map selected point style.
    public struct ClusterMarkerConfiguration: Swift.Equatable {
        /// The cluster marker that is a part of the cluster marker configuration
        public var clusterMarker: QuickSightClientTypes.ClusterMarker?

        public init (
            clusterMarker: QuickSightClientTypes.ClusterMarker? = nil
        )
        {
            self.clusterMarker = clusterMarker
        }
    }

}

extension QuickSightClientTypes {
    public enum ColorFillType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case discrete
        case gradient
        case sdkUnknown(Swift.String)

        public static var allCases: [ColorFillType] {
            return [
                .discrete,
                .gradient,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .discrete: return "DISCRETE"
            case .gradient: return "GRADIENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ColorFillType(rawValue: rawValue) ?? ColorFillType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.ColorScale: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case colorFillType = "ColorFillType"
        case colors = "Colors"
        case nullValueColor = "NullValueColor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let colorFillType = self.colorFillType {
            try encodeContainer.encode(colorFillType.rawValue, forKey: .colorFillType)
        }
        if let colors = colors {
            var colorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .colors)
            for datacolor0 in colors {
                try colorsContainer.encode(datacolor0)
            }
        }
        if let nullValueColor = self.nullValueColor {
            try encodeContainer.encode(nullValueColor, forKey: .nullValueColor)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let colorsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataColor?].self, forKey: .colors)
        var colorsDecoded0:[QuickSightClientTypes.DataColor]? = nil
        if let colorsContainer = colorsContainer {
            colorsDecoded0 = [QuickSightClientTypes.DataColor]()
            for structure0 in colorsContainer {
                if let structure0 = structure0 {
                    colorsDecoded0?.append(structure0)
                }
            }
        }
        colors = colorsDecoded0
        let colorFillTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColorFillType.self, forKey: .colorFillType)
        colorFillType = colorFillTypeDecoded
        let nullValueColorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataColor.self, forKey: .nullValueColor)
        nullValueColor = nullValueColorDecoded
    }
}

extension QuickSightClientTypes {
    /// Determines the color scale that is applied to the visual.
    public struct ColorScale: Swift.Equatable {
        /// Determines the color fill type.
        /// This member is required.
        public var colorFillType: QuickSightClientTypes.ColorFillType?
        /// Determines the list of colors that are applied to the visual.
        /// This member is required.
        public var colors: [QuickSightClientTypes.DataColor]?
        /// Determines the color that is applied to null values.
        public var nullValueColor: QuickSightClientTypes.DataColor?

        public init (
            colorFillType: QuickSightClientTypes.ColorFillType? = nil,
            colors: [QuickSightClientTypes.DataColor]? = nil,
            nullValueColor: QuickSightClientTypes.DataColor? = nil
        )
        {
            self.colorFillType = colorFillType
            self.colors = colors
            self.nullValueColor = nullValueColor
        }
    }

}

extension QuickSightClientTypes.ColumnConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case column = "Column"
        case formatConfiguration = "FormatConfiguration"
        case role = "Role"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let column = self.column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let formatConfiguration = self.formatConfiguration {
            try encodeContainer.encode(formatConfiguration, forKey: .formatConfiguration)
        }
        if let role = self.role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .column)
        column = columnDecoded
        let formatConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FormatConfiguration.self, forKey: .formatConfiguration)
        formatConfiguration = formatConfigurationDecoded
        let roleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnRole.self, forKey: .role)
        role = roleDecoded
    }
}

extension QuickSightClientTypes {
    /// The general configuration of a column.
    public struct ColumnConfiguration: Swift.Equatable {
        /// The column.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The format configuration of a column.
        public var formatConfiguration: QuickSightClientTypes.FormatConfiguration?
        /// The role of the column.
        public var role: QuickSightClientTypes.ColumnRole?

        public init (
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            formatConfiguration: QuickSightClientTypes.FormatConfiguration? = nil,
            role: QuickSightClientTypes.ColumnRole? = nil
        )
        {
            self.column = column
            self.formatConfiguration = formatConfiguration
            self.role = role
        }
    }

}

extension QuickSightClientTypes {
    public enum ColumnDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case datetime
        case decimal
        case integer
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnDataType] {
            return [
                .datetime,
                .decimal,
                .integer,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .datetime: return "DATETIME"
            case .decimal: return "DECIMAL"
            case .integer: return "INTEGER"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ColumnDataType(rawValue: rawValue) ?? ColumnDataType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.ColumnDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension QuickSightClientTypes {
    /// Metadata that contains a description for a column.
    public struct ColumnDescription: Swift.Equatable {
        /// The text of a description for a column.
        public var text: Swift.String?

        public init (
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension QuickSightClientTypes.ColumnGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geoSpatialColumnGroup = "GeoSpatialColumnGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let geoSpatialColumnGroup = self.geoSpatialColumnGroup {
            try encodeContainer.encode(geoSpatialColumnGroup, forKey: .geoSpatialColumnGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geoSpatialColumnGroupDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GeoSpatialColumnGroup.self, forKey: .geoSpatialColumnGroup)
        geoSpatialColumnGroup = geoSpatialColumnGroupDecoded
    }
}

extension QuickSightClientTypes {
    /// Groupings of columns that work together in certain Amazon QuickSight features. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
    public struct ColumnGroup: Swift.Equatable {
        /// Geospatial column group that denotes a hierarchy.
        public var geoSpatialColumnGroup: QuickSightClientTypes.GeoSpatialColumnGroup?

        public init (
            geoSpatialColumnGroup: QuickSightClientTypes.GeoSpatialColumnGroup? = nil
        )
        {
            self.geoSpatialColumnGroup = geoSpatialColumnGroup
        }
    }

}

extension QuickSightClientTypes.ColumnGroupColumnSchema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension QuickSightClientTypes {
    /// A structure describing the name, data type, and geographic role of the columns.
    public struct ColumnGroupColumnSchema: Swift.Equatable {
        /// The name of the column group's column schema.
        public var name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension QuickSightClientTypes.ColumnGroupSchema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnGroupColumnSchemaList = "ColumnGroupColumnSchemaList"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnGroupColumnSchemaList = columnGroupColumnSchemaList {
            var columnGroupColumnSchemaListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnGroupColumnSchemaList)
            for columngroupcolumnschema0 in columnGroupColumnSchemaList {
                try columnGroupColumnSchemaListContainer.encode(columngroupcolumnschema0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let columnGroupColumnSchemaListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnGroupColumnSchema?].self, forKey: .columnGroupColumnSchemaList)
        var columnGroupColumnSchemaListDecoded0:[QuickSightClientTypes.ColumnGroupColumnSchema]? = nil
        if let columnGroupColumnSchemaListContainer = columnGroupColumnSchemaListContainer {
            columnGroupColumnSchemaListDecoded0 = [QuickSightClientTypes.ColumnGroupColumnSchema]()
            for structure0 in columnGroupColumnSchemaListContainer {
                if let structure0 = structure0 {
                    columnGroupColumnSchemaListDecoded0?.append(structure0)
                }
            }
        }
        columnGroupColumnSchemaList = columnGroupColumnSchemaListDecoded0
    }
}

extension QuickSightClientTypes {
    /// The column group schema.
    public struct ColumnGroupSchema: Swift.Equatable {
        /// A structure containing the list of schemas for column group columns.
        public var columnGroupColumnSchemaList: [QuickSightClientTypes.ColumnGroupColumnSchema]?
        /// The name of the column group schema.
        public var name: Swift.String?

        public init (
            columnGroupColumnSchemaList: [QuickSightClientTypes.ColumnGroupColumnSchema]? = nil,
            name: Swift.String? = nil
        )
        {
            self.columnGroupColumnSchemaList = columnGroupColumnSchemaList
            self.name = name
        }
    }

}

extension QuickSightClientTypes.ColumnHierarchy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateTimeHierarchy = "DateTimeHierarchy"
        case explicitHierarchy = "ExplicitHierarchy"
        case predefinedHierarchy = "PredefinedHierarchy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateTimeHierarchy = self.dateTimeHierarchy {
            try encodeContainer.encode(dateTimeHierarchy, forKey: .dateTimeHierarchy)
        }
        if let explicitHierarchy = self.explicitHierarchy {
            try encodeContainer.encode(explicitHierarchy, forKey: .explicitHierarchy)
        }
        if let predefinedHierarchy = self.predefinedHierarchy {
            try encodeContainer.encode(predefinedHierarchy, forKey: .predefinedHierarchy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let explicitHierarchyDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ExplicitHierarchy.self, forKey: .explicitHierarchy)
        explicitHierarchy = explicitHierarchyDecoded
        let dateTimeHierarchyDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DateTimeHierarchy.self, forKey: .dateTimeHierarchy)
        dateTimeHierarchy = dateTimeHierarchyDecoded
        let predefinedHierarchyDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PredefinedHierarchy.self, forKey: .predefinedHierarchy)
        predefinedHierarchy = predefinedHierarchyDecoded
    }
}

extension QuickSightClientTypes {
    /// The option that determines the hierarchy of the fields for a visual element.
    public struct ColumnHierarchy: Swift.Equatable {
        /// The option that determines the hierarchy of any DateTime fields.
        public var dateTimeHierarchy: QuickSightClientTypes.DateTimeHierarchy?
        /// The option that determines the hierarchy of the fields that are built within a visual's field wells. These fields can't be duplicated to other visuals.
        public var explicitHierarchy: QuickSightClientTypes.ExplicitHierarchy?
        /// The option that determines the hierarchy of the fields that are defined during data preparation. These fields are available to use in any analysis that uses the data source.
        public var predefinedHierarchy: QuickSightClientTypes.PredefinedHierarchy?

        public init (
            dateTimeHierarchy: QuickSightClientTypes.DateTimeHierarchy? = nil,
            explicitHierarchy: QuickSightClientTypes.ExplicitHierarchy? = nil,
            predefinedHierarchy: QuickSightClientTypes.PredefinedHierarchy? = nil
        )
        {
            self.dateTimeHierarchy = dateTimeHierarchy
            self.explicitHierarchy = explicitHierarchy
            self.predefinedHierarchy = predefinedHierarchy
        }
    }

}

extension QuickSightClientTypes.ColumnIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnName = "ColumnName"
        case dataSetIdentifier = "DataSetIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnName = self.columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let dataSetIdentifier = self.dataSetIdentifier {
            try encodeContainer.encode(dataSetIdentifier, forKey: .dataSetIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetIdentifier)
        dataSetIdentifier = dataSetIdentifierDecoded
        let columnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnName)
        columnName = columnNameDecoded
    }
}

extension QuickSightClientTypes {
    /// A column of a data set.
    public struct ColumnIdentifier: Swift.Equatable {
        /// The name of the column.
        /// This member is required.
        public var columnName: Swift.String?
        /// The data set that the column belongs to.
        /// This member is required.
        public var dataSetIdentifier: Swift.String?

        public init (
            columnName: Swift.String? = nil,
            dataSetIdentifier: Swift.String? = nil
        )
        {
            self.columnName = columnName
            self.dataSetIdentifier = dataSetIdentifier
        }
    }

}

extension QuickSightClientTypes.ColumnLevelPermissionRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnNames = "ColumnNames"
        case principals = "Principals"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnNames = columnNames {
            var columnNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnNames)
            for string0 in columnNames {
                try columnNamesContainer.encode(string0)
            }
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for string0 in principals {
                try principalsContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let columnNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .columnNames)
        var columnNamesDecoded0:[Swift.String]? = nil
        if let columnNamesContainer = columnNamesContainer {
            columnNamesDecoded0 = [Swift.String]()
            for string0 in columnNamesContainer {
                if let string0 = string0 {
                    columnNamesDecoded0?.append(string0)
                }
            }
        }
        columnNames = columnNamesDecoded0
    }
}

extension QuickSightClientTypes {
    /// A rule defined to grant access on one or more restricted columns. Each dataset can have multiple rules. To create a restricted column, you add it to one or more rules. Each rule must contain at least one column and at least one user or group. To be able to see a restricted column, a user or group needs to be added to a rule for that column.
    public struct ColumnLevelPermissionRule: Swift.Equatable {
        /// An array of column names.
        public var columnNames: [Swift.String]?
        /// An array of Amazon Resource Names (ARNs) for Amazon QuickSight users or groups.
        public var principals: [Swift.String]?

        public init (
            columnNames: [Swift.String]? = nil,
            principals: [Swift.String]? = nil
        )
        {
            self.columnNames = columnNames
            self.principals = principals
        }
    }

}

extension QuickSightClientTypes {
    public enum ColumnRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dimension
        case measure
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnRole] {
            return [
                .dimension,
                .measure,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dimension: return "DIMENSION"
            case .measure: return "MEASURE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ColumnRole(rawValue: rawValue) ?? ColumnRole.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.ColumnSchema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataType = "DataType"
        case geographicRole = "GeographicRole"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let geographicRole = self.geographicRole {
            try encodeContainer.encode(geographicRole, forKey: .geographicRole)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let geographicRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .geographicRole)
        geographicRole = geographicRoleDecoded
    }
}

extension QuickSightClientTypes {
    /// The column schema.
    public struct ColumnSchema: Swift.Equatable {
        /// The data type of the column schema.
        public var dataType: Swift.String?
        /// The geographic role of the column schema.
        public var geographicRole: Swift.String?
        /// The name of the column schema.
        public var name: Swift.String?

        public init (
            dataType: Swift.String? = nil,
            geographicRole: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.dataType = dataType
            self.geographicRole = geographicRole
            self.name = name
        }
    }

}

extension QuickSightClientTypes.ColumnSort: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationFunction = "AggregationFunction"
        case direction = "Direction"
        case sortBy = "SortBy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationFunction = self.aggregationFunction {
            try encodeContainer.encode(aggregationFunction, forKey: .aggregationFunction)
        }
        if let direction = self.direction {
            try encodeContainer.encode(direction.rawValue, forKey: .direction)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let directionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SortDirection.self, forKey: .direction)
        direction = directionDecoded
        let aggregationFunctionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AggregationFunction.self, forKey: .aggregationFunction)
        aggregationFunction = aggregationFunctionDecoded
    }
}

extension QuickSightClientTypes {
    /// The sort configuration for a column that is not used in a field well.
    public struct ColumnSort: Swift.Equatable {
        /// The aggregation function that is defined in the column sort.
        public var aggregationFunction: QuickSightClientTypes.AggregationFunction?
        /// The sort direction.
        /// This member is required.
        public var direction: QuickSightClientTypes.SortDirection?
        /// A column of a data set.
        /// This member is required.
        public var sortBy: QuickSightClientTypes.ColumnIdentifier?

        public init (
            aggregationFunction: QuickSightClientTypes.AggregationFunction? = nil,
            direction: QuickSightClientTypes.SortDirection? = nil,
            sortBy: QuickSightClientTypes.ColumnIdentifier? = nil
        )
        {
            self.aggregationFunction = aggregationFunction
            self.direction = direction
            self.sortBy = sortBy
        }
    }

}

extension QuickSightClientTypes.ColumnTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnDescription = "ColumnDescription"
        case columnGeographicRole = "ColumnGeographicRole"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnDescription = self.columnDescription {
            try encodeContainer.encode(columnDescription, forKey: .columnDescription)
        }
        if let columnGeographicRole = self.columnGeographicRole {
            try encodeContainer.encode(columnGeographicRole.rawValue, forKey: .columnGeographicRole)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnGeographicRoleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GeoSpatialDataRole.self, forKey: .columnGeographicRole)
        columnGeographicRole = columnGeographicRoleDecoded
        let columnDescriptionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnDescription.self, forKey: .columnDescription)
        columnDescription = columnDescriptionDecoded
    }
}

extension QuickSightClientTypes {
    /// A tag for a column in a [TagColumnOperation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_TagColumnOperation.html) structure. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
    public struct ColumnTag: Swift.Equatable {
        /// A description for a column.
        public var columnDescription: QuickSightClientTypes.ColumnDescription?
        /// A geospatial role for a column.
        public var columnGeographicRole: QuickSightClientTypes.GeoSpatialDataRole?

        public init (
            columnDescription: QuickSightClientTypes.ColumnDescription? = nil,
            columnGeographicRole: QuickSightClientTypes.GeoSpatialDataRole? = nil
        )
        {
            self.columnDescription = columnDescription
            self.columnGeographicRole = columnGeographicRole
        }
    }

}

extension QuickSightClientTypes {
    public enum ColumnTagName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case columnDescription
        case columnGeographicRole
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnTagName] {
            return [
                .columnDescription,
                .columnGeographicRole,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .columnDescription: return "COLUMN_DESCRIPTION"
            case .columnGeographicRole: return "COLUMN_GEOGRAPHIC_ROLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ColumnTagName(rawValue: rawValue) ?? ColumnTagName.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.ColumnTooltipItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregation = "Aggregation"
        case column = "Column"
        case label = "Label"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregation = self.aggregation {
            try encodeContainer.encode(aggregation, forKey: .aggregation)
        }
        if let column = self.column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let label = self.label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .column)
        column = columnDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
        let aggregationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AggregationFunction.self, forKey: .aggregation)
        aggregation = aggregationDecoded
    }
}

extension QuickSightClientTypes {
    /// The tooltip item for the columns that are not part of a field well.
    public struct ColumnTooltipItem: Swift.Equatable {
        /// The aggregation function of the column tooltip item.
        public var aggregation: QuickSightClientTypes.AggregationFunction?
        /// The target column of the tooltip item.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The label of the tooltip item.
        public var label: Swift.String?
        /// The visibility of the tooltip item.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            aggregation: QuickSightClientTypes.AggregationFunction? = nil,
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            label: Swift.String? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.aggregation = aggregation
            self.column = column
            self.label = label
            self.visibility = visibility
        }
    }

}

extension QuickSightClientTypes.ComboChartAggregatedFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case barValues = "BarValues"
        case category = "Category"
        case colors = "Colors"
        case lineValues = "LineValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let barValues = barValues {
            var barValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .barValues)
            for measurefield0 in barValues {
                try barValuesContainer.encode(measurefield0)
            }
        }
        if let category = category {
            var categoryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .category)
            for dimensionfield0 in category {
                try categoryContainer.encode(dimensionfield0)
            }
        }
        if let colors = colors {
            var colorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .colors)
            for dimensionfield0 in colors {
                try colorsContainer.encode(dimensionfield0)
            }
        }
        if let lineValues = lineValues {
            var lineValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lineValues)
            for measurefield0 in lineValues {
                try lineValuesContainer.encode(measurefield0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .category)
        var categoryDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let categoryContainer = categoryContainer {
            categoryDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in categoryContainer {
                if let structure0 = structure0 {
                    categoryDecoded0?.append(structure0)
                }
            }
        }
        category = categoryDecoded0
        let barValuesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .barValues)
        var barValuesDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let barValuesContainer = barValuesContainer {
            barValuesDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in barValuesContainer {
                if let structure0 = structure0 {
                    barValuesDecoded0?.append(structure0)
                }
            }
        }
        barValues = barValuesDecoded0
        let colorsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .colors)
        var colorsDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let colorsContainer = colorsContainer {
            colorsDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in colorsContainer {
                if let structure0 = structure0 {
                    colorsDecoded0?.append(structure0)
                }
            }
        }
        colors = colorsDecoded0
        let lineValuesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .lineValues)
        var lineValuesDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let lineValuesContainer = lineValuesContainer {
            lineValuesDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in lineValuesContainer {
                if let structure0 = structure0 {
                    lineValuesDecoded0?.append(structure0)
                }
            }
        }
        lineValues = lineValuesDecoded0
    }
}

extension QuickSightClientTypes {
    /// The aggregated field wells of a combo chart.
    public struct ComboChartAggregatedFieldWells: Swift.Equatable {
        /// The aggregated BarValues field well of a combo chart.
        public var barValues: [QuickSightClientTypes.MeasureField]?
        /// The aggregated category field wells of a combo chart.
        public var category: [QuickSightClientTypes.DimensionField]?
        /// The aggregated colors field well of a combo chart.
        public var colors: [QuickSightClientTypes.DimensionField]?
        /// The aggregated LineValues field well of a combo chart.
        public var lineValues: [QuickSightClientTypes.MeasureField]?

        public init (
            barValues: [QuickSightClientTypes.MeasureField]? = nil,
            category: [QuickSightClientTypes.DimensionField]? = nil,
            colors: [QuickSightClientTypes.DimensionField]? = nil,
            lineValues: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.barValues = barValues
            self.category = category
            self.colors = colors
            self.lineValues = lineValues
        }
    }

}

extension QuickSightClientTypes.ComboChartConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case barDataLabels = "BarDataLabels"
        case barsArrangement = "BarsArrangement"
        case categoryAxis = "CategoryAxis"
        case categoryLabelOptions = "CategoryLabelOptions"
        case colorLabelOptions = "ColorLabelOptions"
        case fieldWells = "FieldWells"
        case legend = "Legend"
        case lineDataLabels = "LineDataLabels"
        case primaryYAxisDisplayOptions = "PrimaryYAxisDisplayOptions"
        case primaryYAxisLabelOptions = "PrimaryYAxisLabelOptions"
        case referenceLines = "ReferenceLines"
        case secondaryYAxisDisplayOptions = "SecondaryYAxisDisplayOptions"
        case secondaryYAxisLabelOptions = "SecondaryYAxisLabelOptions"
        case sortConfiguration = "SortConfiguration"
        case tooltip = "Tooltip"
        case visualPalette = "VisualPalette"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let barDataLabels = self.barDataLabels {
            try encodeContainer.encode(barDataLabels, forKey: .barDataLabels)
        }
        if let barsArrangement = self.barsArrangement {
            try encodeContainer.encode(barsArrangement.rawValue, forKey: .barsArrangement)
        }
        if let categoryAxis = self.categoryAxis {
            try encodeContainer.encode(categoryAxis, forKey: .categoryAxis)
        }
        if let categoryLabelOptions = self.categoryLabelOptions {
            try encodeContainer.encode(categoryLabelOptions, forKey: .categoryLabelOptions)
        }
        if let colorLabelOptions = self.colorLabelOptions {
            try encodeContainer.encode(colorLabelOptions, forKey: .colorLabelOptions)
        }
        if let fieldWells = self.fieldWells {
            try encodeContainer.encode(fieldWells, forKey: .fieldWells)
        }
        if let legend = self.legend {
            try encodeContainer.encode(legend, forKey: .legend)
        }
        if let lineDataLabels = self.lineDataLabels {
            try encodeContainer.encode(lineDataLabels, forKey: .lineDataLabels)
        }
        if let primaryYAxisDisplayOptions = self.primaryYAxisDisplayOptions {
            try encodeContainer.encode(primaryYAxisDisplayOptions, forKey: .primaryYAxisDisplayOptions)
        }
        if let primaryYAxisLabelOptions = self.primaryYAxisLabelOptions {
            try encodeContainer.encode(primaryYAxisLabelOptions, forKey: .primaryYAxisLabelOptions)
        }
        if let referenceLines = referenceLines {
            var referenceLinesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceLines)
            for referenceline0 in referenceLines {
                try referenceLinesContainer.encode(referenceline0)
            }
        }
        if let secondaryYAxisDisplayOptions = self.secondaryYAxisDisplayOptions {
            try encodeContainer.encode(secondaryYAxisDisplayOptions, forKey: .secondaryYAxisDisplayOptions)
        }
        if let secondaryYAxisLabelOptions = self.secondaryYAxisLabelOptions {
            try encodeContainer.encode(secondaryYAxisLabelOptions, forKey: .secondaryYAxisLabelOptions)
        }
        if let sortConfiguration = self.sortConfiguration {
            try encodeContainer.encode(sortConfiguration, forKey: .sortConfiguration)
        }
        if let tooltip = self.tooltip {
            try encodeContainer.encode(tooltip, forKey: .tooltip)
        }
        if let visualPalette = self.visualPalette {
            try encodeContainer.encode(visualPalette, forKey: .visualPalette)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ComboChartFieldWells.self, forKey: .fieldWells)
        fieldWells = fieldWellsDecoded
        let sortConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ComboChartSortConfiguration.self, forKey: .sortConfiguration)
        sortConfiguration = sortConfigurationDecoded
        let barsArrangementDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.BarsArrangement.self, forKey: .barsArrangement)
        barsArrangement = barsArrangementDecoded
        let categoryAxisDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisDisplayOptions.self, forKey: .categoryAxis)
        categoryAxis = categoryAxisDecoded
        let categoryLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .categoryLabelOptions)
        categoryLabelOptions = categoryLabelOptionsDecoded
        let primaryYAxisDisplayOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisDisplayOptions.self, forKey: .primaryYAxisDisplayOptions)
        primaryYAxisDisplayOptions = primaryYAxisDisplayOptionsDecoded
        let primaryYAxisLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .primaryYAxisLabelOptions)
        primaryYAxisLabelOptions = primaryYAxisLabelOptionsDecoded
        let secondaryYAxisDisplayOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisDisplayOptions.self, forKey: .secondaryYAxisDisplayOptions)
        secondaryYAxisDisplayOptions = secondaryYAxisDisplayOptionsDecoded
        let secondaryYAxisLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .secondaryYAxisLabelOptions)
        secondaryYAxisLabelOptions = secondaryYAxisLabelOptionsDecoded
        let colorLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .colorLabelOptions)
        colorLabelOptions = colorLabelOptionsDecoded
        let legendDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LegendOptions.self, forKey: .legend)
        legend = legendDecoded
        let barDataLabelsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataLabelOptions.self, forKey: .barDataLabels)
        barDataLabels = barDataLabelsDecoded
        let lineDataLabelsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataLabelOptions.self, forKey: .lineDataLabels)
        lineDataLabels = lineDataLabelsDecoded
        let tooltipDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TooltipOptions.self, forKey: .tooltip)
        tooltip = tooltipDecoded
        let referenceLinesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ReferenceLine?].self, forKey: .referenceLines)
        var referenceLinesDecoded0:[QuickSightClientTypes.ReferenceLine]? = nil
        if let referenceLinesContainer = referenceLinesContainer {
            referenceLinesDecoded0 = [QuickSightClientTypes.ReferenceLine]()
            for structure0 in referenceLinesContainer {
                if let structure0 = structure0 {
                    referenceLinesDecoded0?.append(structure0)
                }
            }
        }
        referenceLines = referenceLinesDecoded0
        let visualPaletteDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualPalette.self, forKey: .visualPalette)
        visualPalette = visualPaletteDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of a ComboChartVisual.
    public struct ComboChartConfiguration: Swift.Equatable {
        /// The options that determine if visual data labels are displayed. The data label options for a bar in a combo chart.
        public var barDataLabels: QuickSightClientTypes.DataLabelOptions?
        /// Determines the bar arrangement in a combo chart. The following are valid values in this structure:
        ///
        /// * CLUSTERED: For clustered bar combo charts.
        ///
        /// * STACKED: For stacked bar combo charts.
        ///
        /// * STACKED_PERCENT: Do not use. If you use this value, the operation returns a validation error.
        public var barsArrangement: QuickSightClientTypes.BarsArrangement?
        /// The category axis of a combo chart.
        public var categoryAxis: QuickSightClientTypes.AxisDisplayOptions?
        /// The label options (label text, label visibility, and sort icon visibility) of a combo chart category (group/color) field well.
        public var categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The label options (label text, label visibility, and sort icon visibility) of a combo chart's color field well.
        public var colorLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The field wells of the visual.
        public var fieldWells: QuickSightClientTypes.ComboChartFieldWells?
        /// The legend display setup of the visual.
        public var legend: QuickSightClientTypes.LegendOptions?
        /// The options that determine if visual data labels are displayed. The data label options for a line in a combo chart.
        public var lineDataLabels: QuickSightClientTypes.DataLabelOptions?
        /// The label display options (grid line, range, scale, and axis step) of a combo chart's primary y-axis (bar) field well.
        public var primaryYAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions?
        /// The label options (label text, label visibility, and sort icon visibility) of a combo chart's primary y-axis (bar) field well.
        public var primaryYAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The reference line setup of the visual.
        public var referenceLines: [QuickSightClientTypes.ReferenceLine]?
        /// The label display options (grid line, range, scale, axis step) of a combo chart's secondary y-axis (line) field well.
        public var secondaryYAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions?
        /// The label options (label text, label visibility, and sort icon visibility) of a combo chart's secondary y-axis(line) field well.
        public var secondaryYAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The sort configuration of a ComboChartVisual.
        public var sortConfiguration: QuickSightClientTypes.ComboChartSortConfiguration?
        /// The legend display setup of the visual.
        public var tooltip: QuickSightClientTypes.TooltipOptions?
        /// The palette (chart color) display setup of the visual.
        public var visualPalette: QuickSightClientTypes.VisualPalette?

        public init (
            barDataLabels: QuickSightClientTypes.DataLabelOptions? = nil,
            barsArrangement: QuickSightClientTypes.BarsArrangement? = nil,
            categoryAxis: QuickSightClientTypes.AxisDisplayOptions? = nil,
            categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            colorLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            fieldWells: QuickSightClientTypes.ComboChartFieldWells? = nil,
            legend: QuickSightClientTypes.LegendOptions? = nil,
            lineDataLabels: QuickSightClientTypes.DataLabelOptions? = nil,
            primaryYAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions? = nil,
            primaryYAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            referenceLines: [QuickSightClientTypes.ReferenceLine]? = nil,
            secondaryYAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions? = nil,
            secondaryYAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            sortConfiguration: QuickSightClientTypes.ComboChartSortConfiguration? = nil,
            tooltip: QuickSightClientTypes.TooltipOptions? = nil,
            visualPalette: QuickSightClientTypes.VisualPalette? = nil
        )
        {
            self.barDataLabels = barDataLabels
            self.barsArrangement = barsArrangement
            self.categoryAxis = categoryAxis
            self.categoryLabelOptions = categoryLabelOptions
            self.colorLabelOptions = colorLabelOptions
            self.fieldWells = fieldWells
            self.legend = legend
            self.lineDataLabels = lineDataLabels
            self.primaryYAxisDisplayOptions = primaryYAxisDisplayOptions
            self.primaryYAxisLabelOptions = primaryYAxisLabelOptions
            self.referenceLines = referenceLines
            self.secondaryYAxisDisplayOptions = secondaryYAxisDisplayOptions
            self.secondaryYAxisLabelOptions = secondaryYAxisLabelOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.visualPalette = visualPalette
        }
    }

}

extension QuickSightClientTypes.ComboChartFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comboChartAggregatedFieldWells = "ComboChartAggregatedFieldWells"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comboChartAggregatedFieldWells = self.comboChartAggregatedFieldWells {
            try encodeContainer.encode(comboChartAggregatedFieldWells, forKey: .comboChartAggregatedFieldWells)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comboChartAggregatedFieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ComboChartAggregatedFieldWells.self, forKey: .comboChartAggregatedFieldWells)
        comboChartAggregatedFieldWells = comboChartAggregatedFieldWellsDecoded
    }
}

extension QuickSightClientTypes {
    /// The field wells of the visual. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct ComboChartFieldWells: Swift.Equatable {
        /// The aggregated field wells of a combo chart. Combo charts only have aggregated field wells. Columns in a combo chart are aggregated by category.
        public var comboChartAggregatedFieldWells: QuickSightClientTypes.ComboChartAggregatedFieldWells?

        public init (
            comboChartAggregatedFieldWells: QuickSightClientTypes.ComboChartAggregatedFieldWells? = nil
        )
        {
            self.comboChartAggregatedFieldWells = comboChartAggregatedFieldWells
        }
    }

}

extension QuickSightClientTypes.ComboChartSortConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryItemsLimit = "CategoryItemsLimit"
        case categorySort = "CategorySort"
        case colorItemsLimit = "ColorItemsLimit"
        case colorSort = "ColorSort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryItemsLimit = self.categoryItemsLimit {
            try encodeContainer.encode(categoryItemsLimit, forKey: .categoryItemsLimit)
        }
        if let categorySort = categorySort {
            var categorySortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categorySort)
            for fieldsortoptions0 in categorySort {
                try categorySortContainer.encode(fieldsortoptions0)
            }
        }
        if let colorItemsLimit = self.colorItemsLimit {
            try encodeContainer.encode(colorItemsLimit, forKey: .colorItemsLimit)
        }
        if let colorSort = colorSort {
            var colorSortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .colorSort)
            for fieldsortoptions0 in colorSort {
                try colorSortContainer.encode(fieldsortoptions0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categorySortContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FieldSortOptions?].self, forKey: .categorySort)
        var categorySortDecoded0:[QuickSightClientTypes.FieldSortOptions]? = nil
        if let categorySortContainer = categorySortContainer {
            categorySortDecoded0 = [QuickSightClientTypes.FieldSortOptions]()
            for structure0 in categorySortContainer {
                if let structure0 = structure0 {
                    categorySortDecoded0?.append(structure0)
                }
            }
        }
        categorySort = categorySortDecoded0
        let categoryItemsLimitDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ItemsLimitConfiguration.self, forKey: .categoryItemsLimit)
        categoryItemsLimit = categoryItemsLimitDecoded
        let colorSortContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FieldSortOptions?].self, forKey: .colorSort)
        var colorSortDecoded0:[QuickSightClientTypes.FieldSortOptions]? = nil
        if let colorSortContainer = colorSortContainer {
            colorSortDecoded0 = [QuickSightClientTypes.FieldSortOptions]()
            for structure0 in colorSortContainer {
                if let structure0 = structure0 {
                    colorSortDecoded0?.append(structure0)
                }
            }
        }
        colorSort = colorSortDecoded0
        let colorItemsLimitDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ItemsLimitConfiguration.self, forKey: .colorItemsLimit)
        colorItemsLimit = colorItemsLimitDecoded
    }
}

extension QuickSightClientTypes {
    /// The sort configuration of a ComboChartVisual.
    public struct ComboChartSortConfiguration: Swift.Equatable {
        /// The item limit configuration for the category field well of a combo chart.
        public var categoryItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of the category field well in a combo chart.
        public var categorySort: [QuickSightClientTypes.FieldSortOptions]?
        /// The item limit configuration of the color field well in a combo chart.
        public var colorItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of the color field well in a combo chart.
        public var colorSort: [QuickSightClientTypes.FieldSortOptions]?

        public init (
            categoryItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            categorySort: [QuickSightClientTypes.FieldSortOptions]? = nil,
            colorItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            colorSort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.categoryItemsLimit = categoryItemsLimit
            self.categorySort = categorySort
            self.colorItemsLimit = colorItemsLimit
            self.colorSort = colorSort
        }
    }

}

extension QuickSightClientTypes.ComboChartVisual: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case chartConfiguration = "ChartConfiguration"
        case columnHierarchies = "ColumnHierarchies"
        case subtitle = "Subtitle"
        case title = "Title"
        case visualId = "VisualId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for visualcustomaction0 in actions {
                try actionsContainer.encode(visualcustomaction0)
            }
        }
        if let chartConfiguration = self.chartConfiguration {
            try encodeContainer.encode(chartConfiguration, forKey: .chartConfiguration)
        }
        if let columnHierarchies = columnHierarchies {
            var columnHierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnHierarchies)
            for columnhierarchy0 in columnHierarchies {
                try columnHierarchiesContainer.encode(columnhierarchy0)
            }
        }
        if let subtitle = self.subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let visualId = self.visualId {
            try encodeContainer.encode(visualId, forKey: .visualId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visualIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visualId)
        visualId = visualIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualTitleLabelOptions.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualSubtitleLabelOptions.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let chartConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ComboChartConfiguration.self, forKey: .chartConfiguration)
        chartConfiguration = chartConfigurationDecoded
        let actionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.VisualCustomAction?].self, forKey: .actions)
        var actionsDecoded0:[QuickSightClientTypes.VisualCustomAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [QuickSightClientTypes.VisualCustomAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let columnHierarchiesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnHierarchy?].self, forKey: .columnHierarchies)
        var columnHierarchiesDecoded0:[QuickSightClientTypes.ColumnHierarchy]? = nil
        if let columnHierarchiesContainer = columnHierarchiesContainer {
            columnHierarchiesDecoded0 = [QuickSightClientTypes.ColumnHierarchy]()
            for structure0 in columnHierarchiesContainer {
                if let structure0 = structure0 {
                    columnHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        columnHierarchies = columnHierarchiesDecoded0
    }
}

extension QuickSightClientTypes {
    /// A combo chart. The ComboChartVisual includes stacked bar combo charts and clustered bar combo charts For more information, see [Using combo charts](https://docs.aws.amazon.com/quicksight/latest/user/combo-charts.html) in the Amazon QuickSight User Guide.
    public struct ComboChartVisual: Swift.Equatable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration settings of the visual.
        public var chartConfiguration: QuickSightClientTypes.ComboChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init (
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.ComboChartConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }

}

extension QuickSightClientTypes.ComparisonConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparisonFormat = "ComparisonFormat"
        case comparisonMethod = "ComparisonMethod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonFormat = self.comparisonFormat {
            try encodeContainer.encode(comparisonFormat, forKey: .comparisonFormat)
        }
        if let comparisonMethod = self.comparisonMethod {
            try encodeContainer.encode(comparisonMethod.rawValue, forKey: .comparisonMethod)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonMethodDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ComparisonMethod.self, forKey: .comparisonMethod)
        comparisonMethod = comparisonMethodDecoded
        let comparisonFormatDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ComparisonFormatConfiguration.self, forKey: .comparisonFormat)
        comparisonFormat = comparisonFormatDecoded
    }
}

extension QuickSightClientTypes {
    /// The comparison display configuration of a KPI or gauge chart.
    public struct ComparisonConfiguration: Swift.Equatable {
        /// The format of the comparison.
        public var comparisonFormat: QuickSightClientTypes.ComparisonFormatConfiguration?
        /// The method of the comparison. Choose from the following options:
        ///
        /// * DIFFERENCE
        ///
        /// * PERCENT_DIFFERENCE
        ///
        /// * PERCENT
        public var comparisonMethod: QuickSightClientTypes.ComparisonMethod?

        public init (
            comparisonFormat: QuickSightClientTypes.ComparisonFormatConfiguration? = nil,
            comparisonMethod: QuickSightClientTypes.ComparisonMethod? = nil
        )
        {
            self.comparisonFormat = comparisonFormat
            self.comparisonMethod = comparisonMethod
        }
    }

}

extension QuickSightClientTypes.ComparisonFormatConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numberDisplayFormatConfiguration = "NumberDisplayFormatConfiguration"
        case percentageDisplayFormatConfiguration = "PercentageDisplayFormatConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let numberDisplayFormatConfiguration = self.numberDisplayFormatConfiguration {
            try encodeContainer.encode(numberDisplayFormatConfiguration, forKey: .numberDisplayFormatConfiguration)
        }
        if let percentageDisplayFormatConfiguration = self.percentageDisplayFormatConfiguration {
            try encodeContainer.encode(percentageDisplayFormatConfiguration, forKey: .percentageDisplayFormatConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberDisplayFormatConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumberDisplayFormatConfiguration.self, forKey: .numberDisplayFormatConfiguration)
        numberDisplayFormatConfiguration = numberDisplayFormatConfigurationDecoded
        let percentageDisplayFormatConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PercentageDisplayFormatConfiguration.self, forKey: .percentageDisplayFormatConfiguration)
        percentageDisplayFormatConfiguration = percentageDisplayFormatConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The format of the comparison. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct ComparisonFormatConfiguration: Swift.Equatable {
        /// The number display format.
        public var numberDisplayFormatConfiguration: QuickSightClientTypes.NumberDisplayFormatConfiguration?
        /// The percentage display format.
        public var percentageDisplayFormatConfiguration: QuickSightClientTypes.PercentageDisplayFormatConfiguration?

        public init (
            numberDisplayFormatConfiguration: QuickSightClientTypes.NumberDisplayFormatConfiguration? = nil,
            percentageDisplayFormatConfiguration: QuickSightClientTypes.PercentageDisplayFormatConfiguration? = nil
        )
        {
            self.numberDisplayFormatConfiguration = numberDisplayFormatConfiguration
            self.percentageDisplayFormatConfiguration = percentageDisplayFormatConfiguration
        }
    }

}

extension QuickSightClientTypes {
    public enum ComparisonMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case difference
        case percent
        case percentDifference
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonMethod] {
            return [
                .difference,
                .percent,
                .percentDifference,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .difference: return "DIFFERENCE"
            case .percent: return "PERCENT"
            case .percentDifference: return "PERCENT_DIFFERENCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComparisonMethod(rawValue: rawValue) ?? ComparisonMethod.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.Computation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecast = "Forecast"
        case growthRate = "GrowthRate"
        case maximumMinimum = "MaximumMinimum"
        case metricComparison = "MetricComparison"
        case periodOverPeriod = "PeriodOverPeriod"
        case periodToDate = "PeriodToDate"
        case topBottomMovers = "TopBottomMovers"
        case topBottomRanked = "TopBottomRanked"
        case totalAggregation = "TotalAggregation"
        case uniqueValues = "UniqueValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecast = self.forecast {
            try encodeContainer.encode(forecast, forKey: .forecast)
        }
        if let growthRate = self.growthRate {
            try encodeContainer.encode(growthRate, forKey: .growthRate)
        }
        if let maximumMinimum = self.maximumMinimum {
            try encodeContainer.encode(maximumMinimum, forKey: .maximumMinimum)
        }
        if let metricComparison = self.metricComparison {
            try encodeContainer.encode(metricComparison, forKey: .metricComparison)
        }
        if let periodOverPeriod = self.periodOverPeriod {
            try encodeContainer.encode(periodOverPeriod, forKey: .periodOverPeriod)
        }
        if let periodToDate = self.periodToDate {
            try encodeContainer.encode(periodToDate, forKey: .periodToDate)
        }
        if let topBottomMovers = self.topBottomMovers {
            try encodeContainer.encode(topBottomMovers, forKey: .topBottomMovers)
        }
        if let topBottomRanked = self.topBottomRanked {
            try encodeContainer.encode(topBottomRanked, forKey: .topBottomRanked)
        }
        if let totalAggregation = self.totalAggregation {
            try encodeContainer.encode(totalAggregation, forKey: .totalAggregation)
        }
        if let uniqueValues = self.uniqueValues {
            try encodeContainer.encode(uniqueValues, forKey: .uniqueValues)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topBottomRankedDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TopBottomRankedComputation.self, forKey: .topBottomRanked)
        topBottomRanked = topBottomRankedDecoded
        let topBottomMoversDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TopBottomMoversComputation.self, forKey: .topBottomMovers)
        topBottomMovers = topBottomMoversDecoded
        let totalAggregationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TotalAggregationComputation.self, forKey: .totalAggregation)
        totalAggregation = totalAggregationDecoded
        let maximumMinimumDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.MaximumMinimumComputation.self, forKey: .maximumMinimum)
        maximumMinimum = maximumMinimumDecoded
        let metricComparisonDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.MetricComparisonComputation.self, forKey: .metricComparison)
        metricComparison = metricComparisonDecoded
        let periodOverPeriodDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PeriodOverPeriodComputation.self, forKey: .periodOverPeriod)
        periodOverPeriod = periodOverPeriodDecoded
        let periodToDateDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PeriodToDateComputation.self, forKey: .periodToDate)
        periodToDate = periodToDateDecoded
        let growthRateDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GrowthRateComputation.self, forKey: .growthRate)
        growthRate = growthRateDecoded
        let uniqueValuesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.UniqueValuesComputation.self, forKey: .uniqueValues)
        uniqueValues = uniqueValuesDecoded
        let forecastDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ForecastComputation.self, forKey: .forecast)
        forecast = forecastDecoded
    }
}

extension QuickSightClientTypes {
    /// The computation union that is used in an insight visual. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct Computation: Swift.Equatable {
        /// The forecast computation configuration.
        public var forecast: QuickSightClientTypes.ForecastComputation?
        /// The growth rate computation configuration.
        public var growthRate: QuickSightClientTypes.GrowthRateComputation?
        /// The maximum and minimum computation configuration.
        public var maximumMinimum: QuickSightClientTypes.MaximumMinimumComputation?
        /// The metric comparison computation configuration.
        public var metricComparison: QuickSightClientTypes.MetricComparisonComputation?
        /// The period over period computation configuration.
        public var periodOverPeriod: QuickSightClientTypes.PeriodOverPeriodComputation?
        /// The period to DataSetIdentifier computation configuration.
        public var periodToDate: QuickSightClientTypes.PeriodToDateComputation?
        /// The top movers and bottom movers computation configuration.
        public var topBottomMovers: QuickSightClientTypes.TopBottomMoversComputation?
        /// The top ranked and bottom ranked computation configuration.
        public var topBottomRanked: QuickSightClientTypes.TopBottomRankedComputation?
        /// The total aggregation computation configuration.
        public var totalAggregation: QuickSightClientTypes.TotalAggregationComputation?
        /// The unique values computation configuration.
        public var uniqueValues: QuickSightClientTypes.UniqueValuesComputation?

        public init (
            forecast: QuickSightClientTypes.ForecastComputation? = nil,
            growthRate: QuickSightClientTypes.GrowthRateComputation? = nil,
            maximumMinimum: QuickSightClientTypes.MaximumMinimumComputation? = nil,
            metricComparison: QuickSightClientTypes.MetricComparisonComputation? = nil,
            periodOverPeriod: QuickSightClientTypes.PeriodOverPeriodComputation? = nil,
            periodToDate: QuickSightClientTypes.PeriodToDateComputation? = nil,
            topBottomMovers: QuickSightClientTypes.TopBottomMoversComputation? = nil,
            topBottomRanked: QuickSightClientTypes.TopBottomRankedComputation? = nil,
            totalAggregation: QuickSightClientTypes.TotalAggregationComputation? = nil,
            uniqueValues: QuickSightClientTypes.UniqueValuesComputation? = nil
        )
        {
            self.forecast = forecast
            self.growthRate = growthRate
            self.maximumMinimum = maximumMinimum
            self.metricComparison = metricComparison
            self.periodOverPeriod = periodOverPeriod
            self.periodToDate = periodToDate
            self.topBottomMovers = topBottomMovers
            self.topBottomRanked = topBottomRanked
            self.totalAggregation = totalAggregation
            self.uniqueValues = uniqueValues
        }
    }

}

extension ConcurrentUpdatingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConcurrentUpdatingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A resource is already in a state that indicates an operation is happening that must complete before a new update can be applied.
public struct ConcurrentUpdatingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct ConcurrentUpdatingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ConcurrentUpdatingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.ConditionalFormattingColor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gradient = "Gradient"
        case solid = "Solid"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gradient = self.gradient {
            try encodeContainer.encode(gradient, forKey: .gradient)
        }
        if let solid = self.solid {
            try encodeContainer.encode(solid, forKey: .solid)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solidDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ConditionalFormattingSolidColor.self, forKey: .solid)
        solid = solidDecoded
        let gradientDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ConditionalFormattingGradientColor.self, forKey: .gradient)
        gradient = gradientDecoded
    }
}

extension QuickSightClientTypes {
    /// The formatting configuration for the color.
    public struct ConditionalFormattingColor: Swift.Equatable {
        /// Formatting configuration for gradient color.
        public var gradient: QuickSightClientTypes.ConditionalFormattingGradientColor?
        /// Formatting configuration for solid color.
        public var solid: QuickSightClientTypes.ConditionalFormattingSolidColor?

        public init (
            gradient: QuickSightClientTypes.ConditionalFormattingGradientColor? = nil,
            solid: QuickSightClientTypes.ConditionalFormattingSolidColor? = nil
        )
        {
            self.gradient = gradient
            self.solid = solid
        }
    }

}

extension QuickSightClientTypes.ConditionalFormattingCustomIconCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case color = "Color"
        case displayConfiguration = "DisplayConfiguration"
        case expression = "Expression"
        case iconOptions = "IconOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let color = self.color {
            try encodeContainer.encode(color, forKey: .color)
        }
        if let displayConfiguration = self.displayConfiguration {
            try encodeContainer.encode(displayConfiguration, forKey: .displayConfiguration)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let iconOptions = self.iconOptions {
            try encodeContainer.encode(iconOptions, forKey: .iconOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let iconOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ConditionalFormattingCustomIconOptions.self, forKey: .iconOptions)
        iconOptions = iconOptionsDecoded
        let colorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .color)
        color = colorDecoded
        let displayConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ConditionalFormattingIconDisplayConfiguration.self, forKey: .displayConfiguration)
        displayConfiguration = displayConfigurationDecoded
    }
}

extension QuickSightClientTypes.ConditionalFormattingCustomIconCondition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConditionalFormattingCustomIconCondition(color: \(Swift.String(describing: color)), displayConfiguration: \(Swift.String(describing: displayConfiguration)), iconOptions: \(Swift.String(describing: iconOptions)), expression: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {
    /// Determines the custom condition for an icon set.
    public struct ConditionalFormattingCustomIconCondition: Swift.Equatable {
        /// Determines the color of the icon.
        public var color: Swift.String?
        /// Determines the icon display configuration.
        public var displayConfiguration: QuickSightClientTypes.ConditionalFormattingIconDisplayConfiguration?
        /// The expression that determines the condition of the icon set.
        /// This member is required.
        public var expression: Swift.String?
        /// Custom icon options for an icon set.
        /// This member is required.
        public var iconOptions: QuickSightClientTypes.ConditionalFormattingCustomIconOptions?

        public init (
            color: Swift.String? = nil,
            displayConfiguration: QuickSightClientTypes.ConditionalFormattingIconDisplayConfiguration? = nil,
            expression: Swift.String? = nil,
            iconOptions: QuickSightClientTypes.ConditionalFormattingCustomIconOptions? = nil
        )
        {
            self.color = color
            self.displayConfiguration = displayConfiguration
            self.expression = expression
            self.iconOptions = iconOptions
        }
    }

}

extension QuickSightClientTypes.ConditionalFormattingCustomIconOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case icon = "Icon"
        case unicodeIcon = "UnicodeIcon"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let icon = self.icon {
            try encodeContainer.encode(icon.rawValue, forKey: .icon)
        }
        if let unicodeIcon = self.unicodeIcon {
            try encodeContainer.encode(unicodeIcon, forKey: .unicodeIcon)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iconDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Icon.self, forKey: .icon)
        icon = iconDecoded
        let unicodeIconDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unicodeIcon)
        unicodeIcon = unicodeIconDecoded
    }
}

extension QuickSightClientTypes {
    /// Custom icon options for an icon set.
    public struct ConditionalFormattingCustomIconOptions: Swift.Equatable {
        /// Determines the type of icon.
        public var icon: QuickSightClientTypes.Icon?
        /// Determines the Unicode icon type.
        public var unicodeIcon: Swift.String?

        public init (
            icon: QuickSightClientTypes.Icon? = nil,
            unicodeIcon: Swift.String? = nil
        )
        {
            self.icon = icon
            self.unicodeIcon = unicodeIcon
        }
    }

}

extension QuickSightClientTypes.ConditionalFormattingGradientColor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case color = "Color"
        case expression = "Expression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let color = self.color {
            try encodeContainer.encode(color, forKey: .color)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let colorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GradientColor.self, forKey: .color)
        color = colorDecoded
    }
}

extension QuickSightClientTypes.ConditionalFormattingGradientColor: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConditionalFormattingGradientColor(color: \(Swift.String(describing: color)), expression: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {
    /// Formatting configuration for gradient color.
    public struct ConditionalFormattingGradientColor: Swift.Equatable {
        /// Determines the color.
        /// This member is required.
        public var color: QuickSightClientTypes.GradientColor?
        /// The expression that determines the formatting configuration for gradient color.
        /// This member is required.
        public var expression: Swift.String?

        public init (
            color: QuickSightClientTypes.GradientColor? = nil,
            expression: Swift.String? = nil
        )
        {
            self.color = color
            self.expression = expression
        }
    }

}

extension QuickSightClientTypes.ConditionalFormattingIcon: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customCondition = "CustomCondition"
        case iconSet = "IconSet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customCondition = self.customCondition {
            try encodeContainer.encode(customCondition, forKey: .customCondition)
        }
        if let iconSet = self.iconSet {
            try encodeContainer.encode(iconSet, forKey: .iconSet)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iconSetDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ConditionalFormattingIconSet.self, forKey: .iconSet)
        iconSet = iconSetDecoded
        let customConditionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ConditionalFormattingCustomIconCondition.self, forKey: .customCondition)
        customCondition = customConditionDecoded
    }
}

extension QuickSightClientTypes {
    /// The formatting configuration for the icon.
    public struct ConditionalFormattingIcon: Swift.Equatable {
        /// Determines the custom condition for an icon set.
        public var customCondition: QuickSightClientTypes.ConditionalFormattingCustomIconCondition?
        /// Formatting configuration for icon set.
        public var iconSet: QuickSightClientTypes.ConditionalFormattingIconSet?

        public init (
            customCondition: QuickSightClientTypes.ConditionalFormattingCustomIconCondition? = nil,
            iconSet: QuickSightClientTypes.ConditionalFormattingIconSet? = nil
        )
        {
            self.customCondition = customCondition
            self.iconSet = iconSet
        }
    }

}

extension QuickSightClientTypes.ConditionalFormattingIconDisplayConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iconDisplayOption = "IconDisplayOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iconDisplayOption = self.iconDisplayOption {
            try encodeContainer.encode(iconDisplayOption.rawValue, forKey: .iconDisplayOption)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iconDisplayOptionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ConditionalFormattingIconDisplayOption.self, forKey: .iconDisplayOption)
        iconDisplayOption = iconDisplayOptionDecoded
    }
}

extension QuickSightClientTypes {
    /// Determines the icon display configuration.
    public struct ConditionalFormattingIconDisplayConfiguration: Swift.Equatable {
        /// Determines the icon display configuration.
        public var iconDisplayOption: QuickSightClientTypes.ConditionalFormattingIconDisplayOption?

        public init (
            iconDisplayOption: QuickSightClientTypes.ConditionalFormattingIconDisplayOption? = nil
        )
        {
            self.iconDisplayOption = iconDisplayOption
        }
    }

}

extension QuickSightClientTypes {
    public enum ConditionalFormattingIconDisplayOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iconOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [ConditionalFormattingIconDisplayOption] {
            return [
                .iconOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iconOnly: return "ICON_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConditionalFormattingIconDisplayOption(rawValue: rawValue) ?? ConditionalFormattingIconDisplayOption.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.ConditionalFormattingIconSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression = "Expression"
        case iconSetType = "IconSetType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let iconSetType = self.iconSetType {
            try encodeContainer.encode(iconSetType.rawValue, forKey: .iconSetType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let iconSetTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ConditionalFormattingIconSetType.self, forKey: .iconSetType)
        iconSetType = iconSetTypeDecoded
    }
}

extension QuickSightClientTypes.ConditionalFormattingIconSet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConditionalFormattingIconSet(iconSetType: \(Swift.String(describing: iconSetType)), expression: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {
    /// Formatting configuration for icon set.
    public struct ConditionalFormattingIconSet: Swift.Equatable {
        /// The expression that determines the formatting configuration for the icon set.
        /// This member is required.
        public var expression: Swift.String?
        /// Determines the icon set type.
        public var iconSetType: QuickSightClientTypes.ConditionalFormattingIconSetType?

        public init (
            expression: Swift.String? = nil,
            iconSetType: QuickSightClientTypes.ConditionalFormattingIconSetType? = nil
        )
        {
            self.expression = expression
            self.iconSetType = iconSetType
        }
    }

}

extension QuickSightClientTypes {
    public enum ConditionalFormattingIconSetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bars
        case caretUpMinusDown
        case checkX
        case flags
        case fourColorArrow
        case fourGrayArrow
        case plusMinus
        case threeCircle
        case threeColorArrow
        case threeGrayArrow
        case threeShape
        case sdkUnknown(Swift.String)

        public static var allCases: [ConditionalFormattingIconSetType] {
            return [
                .bars,
                .caretUpMinusDown,
                .checkX,
                .flags,
                .fourColorArrow,
                .fourGrayArrow,
                .plusMinus,
                .threeCircle,
                .threeColorArrow,
                .threeGrayArrow,
                .threeShape,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bars: return "BARS"
            case .caretUpMinusDown: return "CARET_UP_MINUS_DOWN"
            case .checkX: return "CHECK_X"
            case .flags: return "FLAGS"
            case .fourColorArrow: return "FOUR_COLOR_ARROW"
            case .fourGrayArrow: return "FOUR_GRAY_ARROW"
            case .plusMinus: return "PLUS_MINUS"
            case .threeCircle: return "THREE_CIRCLE"
            case .threeColorArrow: return "THREE_COLOR_ARROW"
            case .threeGrayArrow: return "THREE_GRAY_ARROW"
            case .threeShape: return "THREE_SHAPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConditionalFormattingIconSetType(rawValue: rawValue) ?? ConditionalFormattingIconSetType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.ConditionalFormattingSolidColor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case color = "Color"
        case expression = "Expression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let color = self.color {
            try encodeContainer.encode(color, forKey: .color)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let colorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .color)
        color = colorDecoded
    }
}

extension QuickSightClientTypes.ConditionalFormattingSolidColor: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConditionalFormattingSolidColor(color: \(Swift.String(describing: color)), expression: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {
    /// Formatting configuration for solid color.
    public struct ConditionalFormattingSolidColor: Swift.Equatable {
        /// Determines the color.
        public var color: Swift.String?
        /// The expression that determines the formatting configuration for solid color.
        /// This member is required.
        public var expression: Swift.String?

        public init (
            color: Swift.String? = nil,
            expression: Swift.String? = nil
        )
        {
            self.color = color
            self.expression = expression
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.ContributionAnalysisDefault: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contributorDimensions = "ContributorDimensions"
        case measureFieldId = "MeasureFieldId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contributorDimensions = contributorDimensions {
            var contributorDimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contributorDimensions)
            for columnidentifier0 in contributorDimensions {
                try contributorDimensionsContainer.encode(columnidentifier0)
            }
        }
        if let measureFieldId = self.measureFieldId {
            try encodeContainer.encode(measureFieldId, forKey: .measureFieldId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let measureFieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .measureFieldId)
        measureFieldId = measureFieldIdDecoded
        let contributorDimensionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnIdentifier?].self, forKey: .contributorDimensions)
        var contributorDimensionsDecoded0:[QuickSightClientTypes.ColumnIdentifier]? = nil
        if let contributorDimensionsContainer = contributorDimensionsContainer {
            contributorDimensionsDecoded0 = [QuickSightClientTypes.ColumnIdentifier]()
            for structure0 in contributorDimensionsContainer {
                if let structure0 = structure0 {
                    contributorDimensionsDecoded0?.append(structure0)
                }
            }
        }
        contributorDimensions = contributorDimensionsDecoded0
    }
}

extension QuickSightClientTypes {
    /// The contribution analysis visual display for a line, pie, or bar chart.
    public struct ContributionAnalysisDefault: Swift.Equatable {
        /// The dimensions columns that are used in the contribution analysis, usually a list of ColumnIdentifiers.
        /// This member is required.
        public var contributorDimensions: [QuickSightClientTypes.ColumnIdentifier]?
        /// The measure field that is used in the contribution analysis.
        /// This member is required.
        public var measureFieldId: Swift.String?

        public init (
            contributorDimensions: [QuickSightClientTypes.ColumnIdentifier]? = nil,
            measureFieldId: Swift.String? = nil
        )
        {
            self.contributorDimensions = contributorDimensions
            self.measureFieldId = measureFieldId
        }
    }

}

extension CreateAccountCustomizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountCustomization = "AccountCustomization"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountCustomization = self.accountCustomization {
            try encodeContainer.encode(accountCustomization, forKey: .accountCustomization)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateAccountCustomizationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let namespace = namespace {
                let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
                items.append(namespaceQueryItem)
            }
            return items
        }
    }
}

extension CreateAccountCustomizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/customizations"
    }
}

public struct CreateAccountCustomizationInput: Swift.Equatable {
    /// The Amazon QuickSight customizations you're adding in the current Amazon Web Services Region. You can add these to an Amazon Web Services account and a QuickSight namespace. For example, you can add a default theme by setting AccountCustomization to the midnight theme: "AccountCustomization": { "DefaultTheme": "arn:aws:quicksight::aws:theme/MIDNIGHT" }. Or, you can add a custom theme by specifying "AccountCustomization": { "DefaultTheme": "arn:aws:quicksight:us-west-2:111122223333:theme/bdb844d0-0fe9-4d9d-b520-0fe602d93639" }.
    /// This member is required.
    public var accountCustomization: QuickSightClientTypes.AccountCustomization?
    /// The ID for the Amazon Web Services account that you want to customize Amazon QuickSight for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The Amazon QuickSight namespace that you want to add customizations to.
    public var namespace: Swift.String?
    /// A list of the tags that you want to attach to this resource.
    public var tags: [QuickSightClientTypes.Tag]?

    public init (
        accountCustomization: QuickSightClientTypes.AccountCustomization? = nil,
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil
    )
    {
        self.accountCustomization = accountCustomization
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.tags = tags
    }
}

struct CreateAccountCustomizationInputBody: Swift.Equatable {
    let accountCustomization: QuickSightClientTypes.AccountCustomization?
    let tags: [QuickSightClientTypes.Tag]?
}

extension CreateAccountCustomizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountCustomization = "AccountCustomization"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountCustomizationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AccountCustomization.self, forKey: .accountCustomization)
        accountCustomization = accountCustomizationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QuickSightClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QuickSightClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAccountCustomizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAccountCustomizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAccountCustomizationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccountCustomizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAccountCustomizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountCustomization = output.accountCustomization
            self.arn = output.arn
            self.awsAccountId = output.awsAccountId
            self.namespace = output.namespace
            self.requestId = output.requestId
        } else {
            self.accountCustomization = nil
            self.arn = nil
            self.awsAccountId = nil
            self.namespace = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateAccountCustomizationOutputResponse: Swift.Equatable {
    /// The Amazon QuickSight customizations you're adding in the current Amazon Web Services Region.
    public var accountCustomization: QuickSightClientTypes.AccountCustomization?
    /// The Amazon Resource Name (ARN) for the customization that you created for this Amazon Web Services account.
    public var arn: Swift.String?
    /// The ID for the Amazon Web Services account that you want to customize Amazon QuickSight for.
    public var awsAccountId: Swift.String?
    /// The namespace associated with the customization you're creating.
    public var namespace: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        accountCustomization: QuickSightClientTypes.AccountCustomization? = nil,
        arn: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.accountCustomization = accountCustomization
        self.arn = arn
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.requestId = requestId
        self.status = status
    }
}

struct CreateAccountCustomizationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let awsAccountId: Swift.String?
    let namespace: Swift.String?
    let accountCustomization: QuickSightClientTypes.AccountCustomization?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension CreateAccountCustomizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountCustomization = "AccountCustomization"
        case arn = "Arn"
        case awsAccountId = "AwsAccountId"
        case namespace = "Namespace"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let accountCustomizationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AccountCustomization.self, forKey: .accountCustomization)
        accountCustomization = accountCustomizationDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension CreateAccountSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountName = "AccountName"
        case activeDirectoryName = "ActiveDirectoryName"
        case adminGroup = "AdminGroup"
        case authenticationMethod = "AuthenticationMethod"
        case authorGroup = "AuthorGroup"
        case contactNumber = "ContactNumber"
        case directoryId = "DirectoryId"
        case edition = "Edition"
        case emailAddress = "EmailAddress"
        case firstName = "FirstName"
        case lastName = "LastName"
        case notificationEmail = "NotificationEmail"
        case readerGroup = "ReaderGroup"
        case realm = "Realm"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountName = self.accountName {
            try encodeContainer.encode(accountName, forKey: .accountName)
        }
        if let activeDirectoryName = self.activeDirectoryName {
            try encodeContainer.encode(activeDirectoryName, forKey: .activeDirectoryName)
        }
        if let adminGroup = adminGroup {
            var adminGroupContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adminGroup)
            for string0 in adminGroup {
                try adminGroupContainer.encode(string0)
            }
        }
        if let authenticationMethod = self.authenticationMethod {
            try encodeContainer.encode(authenticationMethod.rawValue, forKey: .authenticationMethod)
        }
        if let authorGroup = authorGroup {
            var authorGroupContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorGroup)
            for string0 in authorGroup {
                try authorGroupContainer.encode(string0)
            }
        }
        if let contactNumber = self.contactNumber {
            try encodeContainer.encode(contactNumber, forKey: .contactNumber)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let edition = self.edition {
            try encodeContainer.encode(edition.rawValue, forKey: .edition)
        }
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let notificationEmail = self.notificationEmail {
            try encodeContainer.encode(notificationEmail, forKey: .notificationEmail)
        }
        if let readerGroup = readerGroup {
            var readerGroupContainer = encodeContainer.nestedUnkeyedContainer(forKey: .readerGroup)
            for string0 in readerGroup {
                try readerGroupContainer.encode(string0)
            }
        }
        if let realm = self.realm {
            try encodeContainer.encode(realm, forKey: .realm)
        }
    }
}

extension CreateAccountSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/account/\(awsAccountId.urlPercentEncoding())"
    }
}

public struct CreateAccountSubscriptionInput: Swift.Equatable {
    /// The name of your Amazon QuickSight account. This name is unique over all of Amazon Web Services, and it appears only when users sign in. You can't change AccountName value after the Amazon QuickSight account is created.
    /// This member is required.
    public var accountName: Swift.String?
    /// The name of your Active Directory. This field is required if ACTIVE_DIRECTORY is the selected authentication method of the new Amazon QuickSight account.
    public var activeDirectoryName: Swift.String?
    /// The admin group associated with your Active Directory. This field is required if ACTIVE_DIRECTORY is the selected authentication method of the new Amazon QuickSight account. For more information about using Active Directory in Amazon QuickSight, see [Using Active Directory with Amazon QuickSight Enterprise Edition](https://docs.aws.amazon.com/quicksight/latest/user/aws-directory-service.html) in the Amazon QuickSight User Guide.
    public var adminGroup: [Swift.String]?
    /// The method that you want to use to authenticate your Amazon QuickSight account. Currently, the valid values for this parameter are IAM_AND_QUICKSIGHT, IAM_ONLY, and ACTIVE_DIRECTORY. If you choose ACTIVE_DIRECTORY, provide an ActiveDirectoryName and an AdminGroup associated with your Active Directory.
    /// This member is required.
    public var authenticationMethod: QuickSightClientTypes.AuthenticationMethodOption?
    /// The author group associated with your Active Directory. For more information about using Active Directory in Amazon QuickSight, see [Using Active Directory with Amazon QuickSight Enterprise Edition](https://docs.aws.amazon.com/quicksight/latest/user/aws-directory-service.html) in the Amazon QuickSight User Guide.
    public var authorGroup: [Swift.String]?
    /// The Amazon Web Services account ID of the account that you're using to create your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A 10-digit phone number for the author of the Amazon QuickSight account to use for future communications. This field is required if ENTERPPRISE_AND_Q is the selected edition of the new Amazon QuickSight account.
    public var contactNumber: Swift.String?
    /// The ID of the Active Directory that is associated with your Amazon QuickSight account.
    public var directoryId: Swift.String?
    /// The edition of Amazon QuickSight that you want your account to have. Currently, you can choose from ENTERPRISE or ENTERPRISE_AND_Q. If you choose ENTERPRISE_AND_Q, the following parameters are required:
    ///
    /// * FirstName
    ///
    /// * LastName
    ///
    /// * EmailAddress
    ///
    /// * ContactNumber
    /// This member is required.
    public var edition: QuickSightClientTypes.Edition?
    /// The email address of the author of the Amazon QuickSight account to use for future communications. This field is required if ENTERPPRISE_AND_Q is the selected edition of the new Amazon QuickSight account.
    public var emailAddress: Swift.String?
    /// The first name of the author of the Amazon QuickSight account to use for future communications. This field is required if ENTERPPRISE_AND_Q is the selected edition of the new Amazon QuickSight account.
    public var firstName: Swift.String?
    /// The last name of the author of the Amazon QuickSight account to use for future communications. This field is required if ENTERPPRISE_AND_Q is the selected edition of the new Amazon QuickSight account.
    public var lastName: Swift.String?
    /// The email address that you want Amazon QuickSight to send notifications to regarding your Amazon QuickSight account or Amazon QuickSight subscription.
    /// This member is required.
    public var notificationEmail: Swift.String?
    /// The reader group associated with your Active Direcrtory. For more information about using Active Directory in Amazon QuickSight, see [Using Active Directory with Amazon QuickSight Enterprise Edition](https://docs.aws.amazon.com/quicksight/latest/user/aws-directory-service.html) in the Amazon QuickSight User Guide.
    public var readerGroup: [Swift.String]?
    /// The realm of the Active Directory that is associated with your Amazon QuickSight account. This field is required if ACTIVE_DIRECTORY is the selected authentication method of the new Amazon QuickSight account.
    public var realm: Swift.String?

    public init (
        accountName: Swift.String? = nil,
        activeDirectoryName: Swift.String? = nil,
        adminGroup: [Swift.String]? = nil,
        authenticationMethod: QuickSightClientTypes.AuthenticationMethodOption? = nil,
        authorGroup: [Swift.String]? = nil,
        awsAccountId: Swift.String? = nil,
        contactNumber: Swift.String? = nil,
        directoryId: Swift.String? = nil,
        edition: QuickSightClientTypes.Edition? = nil,
        emailAddress: Swift.String? = nil,
        firstName: Swift.String? = nil,
        lastName: Swift.String? = nil,
        notificationEmail: Swift.String? = nil,
        readerGroup: [Swift.String]? = nil,
        realm: Swift.String? = nil
    )
    {
        self.accountName = accountName
        self.activeDirectoryName = activeDirectoryName
        self.adminGroup = adminGroup
        self.authenticationMethod = authenticationMethod
        self.authorGroup = authorGroup
        self.awsAccountId = awsAccountId
        self.contactNumber = contactNumber
        self.directoryId = directoryId
        self.edition = edition
        self.emailAddress = emailAddress
        self.firstName = firstName
        self.lastName = lastName
        self.notificationEmail = notificationEmail
        self.readerGroup = readerGroup
        self.realm = realm
    }
}

struct CreateAccountSubscriptionInputBody: Swift.Equatable {
    let edition: QuickSightClientTypes.Edition?
    let authenticationMethod: QuickSightClientTypes.AuthenticationMethodOption?
    let accountName: Swift.String?
    let notificationEmail: Swift.String?
    let activeDirectoryName: Swift.String?
    let realm: Swift.String?
    let directoryId: Swift.String?
    let adminGroup: [Swift.String]?
    let authorGroup: [Swift.String]?
    let readerGroup: [Swift.String]?
    let firstName: Swift.String?
    let lastName: Swift.String?
    let emailAddress: Swift.String?
    let contactNumber: Swift.String?
}

extension CreateAccountSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountName = "AccountName"
        case activeDirectoryName = "ActiveDirectoryName"
        case adminGroup = "AdminGroup"
        case authenticationMethod = "AuthenticationMethod"
        case authorGroup = "AuthorGroup"
        case contactNumber = "ContactNumber"
        case directoryId = "DirectoryId"
        case edition = "Edition"
        case emailAddress = "EmailAddress"
        case firstName = "FirstName"
        case lastName = "LastName"
        case notificationEmail = "NotificationEmail"
        case readerGroup = "ReaderGroup"
        case realm = "Realm"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let editionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Edition.self, forKey: .edition)
        edition = editionDecoded
        let authenticationMethodDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AuthenticationMethodOption.self, forKey: .authenticationMethod)
        authenticationMethod = authenticationMethodDecoded
        let accountNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountName)
        accountName = accountNameDecoded
        let notificationEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationEmail)
        notificationEmail = notificationEmailDecoded
        let activeDirectoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activeDirectoryName)
        activeDirectoryName = activeDirectoryNameDecoded
        let realmDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .realm)
        realm = realmDecoded
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let adminGroupContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .adminGroup)
        var adminGroupDecoded0:[Swift.String]? = nil
        if let adminGroupContainer = adminGroupContainer {
            adminGroupDecoded0 = [Swift.String]()
            for string0 in adminGroupContainer {
                if let string0 = string0 {
                    adminGroupDecoded0?.append(string0)
                }
            }
        }
        adminGroup = adminGroupDecoded0
        let authorGroupContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorGroup)
        var authorGroupDecoded0:[Swift.String]? = nil
        if let authorGroupContainer = authorGroupContainer {
            authorGroupDecoded0 = [Swift.String]()
            for string0 in authorGroupContainer {
                if let string0 = string0 {
                    authorGroupDecoded0?.append(string0)
                }
            }
        }
        authorGroup = authorGroupDecoded0
        let readerGroupContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .readerGroup)
        var readerGroupDecoded0:[Swift.String]? = nil
        if let readerGroupContainer = readerGroupContainer {
            readerGroupDecoded0 = [Swift.String]()
            for string0 in readerGroupContainer {
                if let string0 = string0 {
                    readerGroupDecoded0?.append(string0)
                }
            }
        }
        readerGroup = readerGroupDecoded0
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let contactNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactNumber)
        contactNumber = contactNumberDecoded
    }
}

extension CreateAccountSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAccountSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAccountSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccountSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAccountSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.signupResponse = output.signupResponse
        } else {
            self.requestId = nil
            self.signupResponse = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateAccountSubscriptionOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// A SignupResponse object that returns information about a newly created Amazon QuickSight account.
    public var signupResponse: QuickSightClientTypes.SignupResponse?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        requestId: Swift.String? = nil,
        signupResponse: QuickSightClientTypes.SignupResponse? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.signupResponse = signupResponse
        self.status = status
    }
}

struct CreateAccountSubscriptionOutputResponseBody: Swift.Equatable {
    let signupResponse: QuickSightClientTypes.SignupResponse?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension CreateAccountSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case signupResponse = "SignupResponse"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signupResponseDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SignupResponse.self, forKey: .signupResponse)
        signupResponse = signupResponseDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension CreateAnalysisInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition = "Definition"
        case name = "Name"
        case parameters = "Parameters"
        case permissions = "Permissions"
        case sourceEntity = "SourceEntity"
        case tags = "Tags"
        case themeArn = "ThemeArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = self.parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for resourcepermission0 in permissions {
                try permissionsContainer.encode(resourcepermission0)
            }
        }
        if let sourceEntity = self.sourceEntity {
            try encodeContainer.encode(sourceEntity, forKey: .sourceEntity)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let themeArn = self.themeArn {
            try encodeContainer.encode(themeArn, forKey: .themeArn)
        }
    }
}

extension CreateAnalysisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let analysisId = analysisId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/analyses/\(analysisId.urlPercentEncoding())"
    }
}

public struct CreateAnalysisInput: Swift.Equatable {
    /// The ID for the analysis that you're creating. This ID displays in the URL of the analysis.
    /// This member is required.
    public var analysisId: Swift.String?
    /// The ID of the Amazon Web Services account where you are creating an analysis.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The definition of an analysis. A definition is the data model of all features in a Dashboard, Template, or Analysis.
    public var definition: QuickSightClientTypes.AnalysisDefinition?
    /// A descriptive name for the analysis that you're creating. This name displays for the analysis in the Amazon QuickSight console.
    /// This member is required.
    public var name: Swift.String?
    /// The parameter names and override values that you want to use. An analysis can have any parameter type, and some parameters might accept multiple values.
    public var parameters: QuickSightClientTypes.Parameters?
    /// A structure that describes the principals and the resource-level permissions on an analysis. You can use the Permissions structure to grant permissions by providing a list of Identity and Access Management (IAM) action information for each principal listed by Amazon Resource Name (ARN). To specify no permissions, omit Permissions.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// A source entity to use for the analysis that you're creating. This metadata structure contains details that describe a source template and one or more datasets.
    public var sourceEntity: QuickSightClientTypes.AnalysisSourceEntity?
    /// Contains a map of the key-value pairs for the resource tag or tags assigned to the analysis.
    public var tags: [QuickSightClientTypes.Tag]?
    /// The ARN for the theme to apply to the analysis that you're creating. To see the theme in the Amazon QuickSight console, make sure that you have access to it.
    public var themeArn: Swift.String?

    public init (
        analysisId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        definition: QuickSightClientTypes.AnalysisDefinition? = nil,
        name: Swift.String? = nil,
        parameters: QuickSightClientTypes.Parameters? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        sourceEntity: QuickSightClientTypes.AnalysisSourceEntity? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil,
        themeArn: Swift.String? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
        self.definition = definition
        self.name = name
        self.parameters = parameters
        self.permissions = permissions
        self.sourceEntity = sourceEntity
        self.tags = tags
        self.themeArn = themeArn
    }
}

struct CreateAnalysisInputBody: Swift.Equatable {
    let name: Swift.String?
    let parameters: QuickSightClientTypes.Parameters?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let sourceEntity: QuickSightClientTypes.AnalysisSourceEntity?
    let themeArn: Swift.String?
    let tags: [QuickSightClientTypes.Tag]?
    let definition: QuickSightClientTypes.AnalysisDefinition?
}

extension CreateAnalysisInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition = "Definition"
        case name = "Name"
        case parameters = "Parameters"
        case permissions = "Permissions"
        case sourceEntity = "SourceEntity"
        case tags = "Tags"
        case themeArn = "ThemeArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Parameters.self, forKey: .parameters)
        parameters = parametersDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let sourceEntityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AnalysisSourceEntity.self, forKey: .sourceEntity)
        sourceEntity = sourceEntityDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QuickSightClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QuickSightClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let definitionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AnalysisDefinition.self, forKey: .definition)
        definition = definitionDecoded
    }
}

extension CreateAnalysisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAnalysisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAnalysisOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAnalysisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisId = output.analysisId
            self.arn = output.arn
            self.creationStatus = output.creationStatus
            self.requestId = output.requestId
        } else {
            self.analysisId = nil
            self.arn = nil
            self.creationStatus = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateAnalysisOutputResponse: Swift.Equatable {
    /// The ID of the analysis.
    public var analysisId: Swift.String?
    /// The ARN for the analysis.
    public var arn: Swift.String?
    /// The status of the creation of the analysis.
    public var creationStatus: QuickSightClientTypes.ResourceStatus?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        analysisId: Swift.String? = nil,
        arn: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.ResourceStatus? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.analysisId = analysisId
        self.arn = arn
        self.creationStatus = creationStatus
        self.requestId = requestId
        self.status = status
    }
}

struct CreateAnalysisOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let analysisId: Swift.String?
    let creationStatus: QuickSightClientTypes.ResourceStatus?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension CreateAnalysisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisId = "AnalysisId"
        case arn = "Arn"
        case creationStatus = "CreationStatus"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let analysisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.CreateColumnsOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columns = "Columns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for calculatedcolumn0 in columns {
                try columnsContainer.encode(calculatedcolumn0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.CalculatedColumn?].self, forKey: .columns)
        var columnsDecoded0:[QuickSightClientTypes.CalculatedColumn]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [QuickSightClientTypes.CalculatedColumn]()
            for structure0 in columnsContainer {
                if let structure0 = structure0 {
                    columnsDecoded0?.append(structure0)
                }
            }
        }
        columns = columnsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A transform operation that creates calculated columns. Columns created in one such operation form a lexical closure.
    public struct CreateColumnsOperation: Swift.Equatable {
        /// Calculated columns to create.
        /// This member is required.
        public var columns: [QuickSightClientTypes.CalculatedColumn]?

        public init (
            columns: [QuickSightClientTypes.CalculatedColumn]? = nil
        )
        {
            self.columns = columns
        }
    }

}

extension CreateDashboardInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardPublishOptions = "DashboardPublishOptions"
        case definition = "Definition"
        case name = "Name"
        case parameters = "Parameters"
        case permissions = "Permissions"
        case sourceEntity = "SourceEntity"
        case tags = "Tags"
        case themeArn = "ThemeArn"
        case versionDescription = "VersionDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dashboardPublishOptions = self.dashboardPublishOptions {
            try encodeContainer.encode(dashboardPublishOptions, forKey: .dashboardPublishOptions)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = self.parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for resourcepermission0 in permissions {
                try permissionsContainer.encode(resourcepermission0)
            }
        }
        if let sourceEntity = self.sourceEntity {
            try encodeContainer.encode(sourceEntity, forKey: .sourceEntity)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let themeArn = self.themeArn {
            try encodeContainer.encode(themeArn, forKey: .themeArn)
        }
        if let versionDescription = self.versionDescription {
            try encodeContainer.encode(versionDescription, forKey: .versionDescription)
        }
    }
}

extension CreateDashboardInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dashboardId = dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())"
    }
}

public struct CreateDashboardInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account where you want to create the dashboard.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard, also added to the IAM policy.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// Options for publishing the dashboard when you create it:
    ///
    /// * AvailabilityStatus for AdHocFilteringOption - This status can be either ENABLED or DISABLED. When this is set to DISABLED, Amazon QuickSight disables the left filter pane on the published dashboard, which can be used for ad hoc (one-time) filtering. This option is ENABLED by default.
    ///
    /// * AvailabilityStatus for ExportToCSVOption - This status can be either ENABLED or DISABLED. The visual option to export data to .CSV format isn't enabled when this is set to DISABLED. This option is ENABLED by default.
    ///
    /// * VisibilityState for SheetControlsOption - This visibility state can be either COLLAPSED or EXPANDED. This option is COLLAPSED by default.
    public var dashboardPublishOptions: QuickSightClientTypes.DashboardPublishOptions?
    /// The definition of a dashboard. A definition is the data model of all features in a Dashboard, Template, or Analysis.
    public var definition: QuickSightClientTypes.DashboardVersionDefinition?
    /// The display name of the dashboard.
    /// This member is required.
    public var name: Swift.String?
    /// The parameters for the creation of the dashboard, which you want to use to override the default settings. A dashboard can have any type of parameters, and some parameters might accept multiple values.
    public var parameters: QuickSightClientTypes.Parameters?
    /// A structure that contains the permissions of the dashboard. You can use this structure for granting permissions by providing a list of IAM action information for each principal ARN. To specify no permissions, omit the permissions list.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The entity that you are using as a source when you create the dashboard. In SourceEntity, you specify the type of object you're using as source. You can only create a dashboard from a template, so you use a SourceTemplate entity. If you need to create a dashboard from an analysis, first convert the analysis to a template by using the [CreateTemplate](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_CreateTemplate.html) API operation. For SourceTemplate, specify the Amazon Resource Name (ARN) of the source template. The SourceTemplateARN can contain any Amazon Web Services account and any Amazon QuickSight-supported Amazon Web Services Region. Use the DataSetReferences entity within SourceTemplate to list the replacement datasets for the placeholders listed in the original. The schema in each dataset must match its placeholder.
    public var sourceEntity: QuickSightClientTypes.DashboardSourceEntity?
    /// Contains a map of the key-value pairs for the resource tag or tags assigned to the dashboard.
    public var tags: [QuickSightClientTypes.Tag]?
    /// The Amazon Resource Name (ARN) of the theme that is being used for this dashboard. If you add a value for this field, it overrides the value that is used in the source entity. The theme ARN must exist in the same Amazon Web Services account where you create the dashboard.
    public var themeArn: Swift.String?
    /// A description for the first version of the dashboard being created.
    public var versionDescription: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        dashboardPublishOptions: QuickSightClientTypes.DashboardPublishOptions? = nil,
        definition: QuickSightClientTypes.DashboardVersionDefinition? = nil,
        name: Swift.String? = nil,
        parameters: QuickSightClientTypes.Parameters? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        sourceEntity: QuickSightClientTypes.DashboardSourceEntity? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil,
        themeArn: Swift.String? = nil,
        versionDescription: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.dashboardPublishOptions = dashboardPublishOptions
        self.definition = definition
        self.name = name
        self.parameters = parameters
        self.permissions = permissions
        self.sourceEntity = sourceEntity
        self.tags = tags
        self.themeArn = themeArn
        self.versionDescription = versionDescription
    }
}

struct CreateDashboardInputBody: Swift.Equatable {
    let name: Swift.String?
    let parameters: QuickSightClientTypes.Parameters?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let sourceEntity: QuickSightClientTypes.DashboardSourceEntity?
    let tags: [QuickSightClientTypes.Tag]?
    let versionDescription: Swift.String?
    let dashboardPublishOptions: QuickSightClientTypes.DashboardPublishOptions?
    let themeArn: Swift.String?
    let definition: QuickSightClientTypes.DashboardVersionDefinition?
}

extension CreateDashboardInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardPublishOptions = "DashboardPublishOptions"
        case definition = "Definition"
        case name = "Name"
        case parameters = "Parameters"
        case permissions = "Permissions"
        case sourceEntity = "SourceEntity"
        case tags = "Tags"
        case themeArn = "ThemeArn"
        case versionDescription = "VersionDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Parameters.self, forKey: .parameters)
        parameters = parametersDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let sourceEntityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardSourceEntity.self, forKey: .sourceEntity)
        sourceEntity = sourceEntityDecoded
        let tagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QuickSightClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QuickSightClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let versionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionDescription)
        versionDescription = versionDescriptionDecoded
        let dashboardPublishOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardPublishOptions.self, forKey: .dashboardPublishOptions)
        dashboardPublishOptions = dashboardPublishOptionsDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardVersionDefinition.self, forKey: .definition)
        definition = definitionDecoded
    }
}

extension CreateDashboardOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDashboardOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDashboardOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDashboardOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDashboardOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationStatus = output.creationStatus
            self.dashboardId = output.dashboardId
            self.requestId = output.requestId
            self.versionArn = output.versionArn
        } else {
            self.arn = nil
            self.creationStatus = nil
            self.dashboardId = nil
            self.requestId = nil
            self.versionArn = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateDashboardOutputResponse: Swift.Equatable {
    /// The ARN of the dashboard.
    public var arn: Swift.String?
    /// The status of the dashboard creation request.
    public var creationStatus: QuickSightClientTypes.ResourceStatus?
    /// The ID for the dashboard.
    public var dashboardId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ARN of the dashboard, including the version number of the first version that is created.
    public var versionArn: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.ResourceStatus? = nil,
        dashboardId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        versionArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.dashboardId = dashboardId
        self.requestId = requestId
        self.status = status
        self.versionArn = versionArn
    }
}

struct CreateDashboardOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let versionArn: Swift.String?
    let dashboardId: Swift.String?
    let creationStatus: QuickSightClientTypes.ResourceStatus?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension CreateDashboardOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationStatus = "CreationStatus"
        case dashboardId = "DashboardId"
        case requestId = "RequestId"
        case status = "Status"
        case versionArn = "VersionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionArn)
        versionArn = versionArnDecoded
        let dashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension CreateDataSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnGroups = "ColumnGroups"
        case columnLevelPermissionRules = "ColumnLevelPermissionRules"
        case dataSetId = "DataSetId"
        case dataSetUsageConfiguration = "DataSetUsageConfiguration"
        case fieldFolders = "FieldFolders"
        case importMode = "ImportMode"
        case logicalTableMap = "LogicalTableMap"
        case name = "Name"
        case permissions = "Permissions"
        case physicalTableMap = "PhysicalTableMap"
        case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
        case rowLevelPermissionTagConfiguration = "RowLevelPermissionTagConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnGroups = columnGroups {
            var columnGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnGroups)
            for columngroup0 in columnGroups {
                try columnGroupsContainer.encode(columngroup0)
            }
        }
        if let columnLevelPermissionRules = columnLevelPermissionRules {
            var columnLevelPermissionRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnLevelPermissionRules)
            for columnlevelpermissionrule0 in columnLevelPermissionRules {
                try columnLevelPermissionRulesContainer.encode(columnlevelpermissionrule0)
            }
        }
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let dataSetUsageConfiguration = self.dataSetUsageConfiguration {
            try encodeContainer.encode(dataSetUsageConfiguration, forKey: .dataSetUsageConfiguration)
        }
        if let fieldFolders = fieldFolders {
            var fieldFoldersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .fieldFolders)
            for (dictKey0, fieldFolderMap0) in fieldFolders {
                try fieldFoldersContainer.encode(fieldFolderMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let importMode = self.importMode {
            try encodeContainer.encode(importMode.rawValue, forKey: .importMode)
        }
        if let logicalTableMap = logicalTableMap {
            var logicalTableMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .logicalTableMap)
            for (dictKey0, logicalTableMap0) in logicalTableMap {
                try logicalTableMapContainer.encode(logicalTableMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for resourcepermission0 in permissions {
                try permissionsContainer.encode(resourcepermission0)
            }
        }
        if let physicalTableMap = physicalTableMap {
            var physicalTableMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .physicalTableMap)
            for (dictKey0, physicalTableMap0) in physicalTableMap {
                try physicalTableMapContainer.encode(physicalTableMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let rowLevelPermissionDataSet = self.rowLevelPermissionDataSet {
            try encodeContainer.encode(rowLevelPermissionDataSet, forKey: .rowLevelPermissionDataSet)
        }
        if let rowLevelPermissionTagConfiguration = self.rowLevelPermissionTagConfiguration {
            try encodeContainer.encode(rowLevelPermissionTagConfiguration, forKey: .rowLevelPermissionTagConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDataSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets"
    }
}

public struct CreateDataSetInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// Groupings of columns that work together in certain Amazon QuickSight features. Currently, only geospatial hierarchy is supported.
    public var columnGroups: [QuickSightClientTypes.ColumnGroup]?
    /// A set of one or more definitions of a [ColumnLevelPermissionRule](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ColumnLevelPermissionRule.html).
    public var columnLevelPermissionRules: [QuickSightClientTypes.ColumnLevelPermissionRule]?
    /// An ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The usage configuration to apply to child datasets that reference this dataset as a source.
    public var dataSetUsageConfiguration: QuickSightClientTypes.DataSetUsageConfiguration?
    /// The folder that contains fields and nested subfolders for your dataset.
    public var fieldFolders: [Swift.String:QuickSightClientTypes.FieldFolder]?
    /// Indicates whether you want to import the data into SPICE.
    /// This member is required.
    public var importMode: QuickSightClientTypes.DataSetImportMode?
    /// Configures the combination and transformation of the data from the physical tables.
    public var logicalTableMap: [Swift.String:QuickSightClientTypes.LogicalTable]?
    /// The display name for the dataset.
    /// This member is required.
    public var name: Swift.String?
    /// A list of resource permissions on the dataset.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// Declares the physical tables that are available in the underlying data sources.
    /// This member is required.
    public var physicalTableMap: [Swift.String:QuickSightClientTypes.PhysicalTable]?
    /// The row-level security configuration for the data that you want to create.
    public var rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet?
    /// The configuration of tags on a dataset to set row-level security. Row-level security tags are currently supported for anonymous embedding only.
    public var rowLevelPermissionTagConfiguration: QuickSightClientTypes.RowLevelPermissionTagConfiguration?
    /// Contains a map of the key-value pairs for the resource tag or tags assigned to the dataset.
    public var tags: [QuickSightClientTypes.Tag]?

    public init (
        awsAccountId: Swift.String? = nil,
        columnGroups: [QuickSightClientTypes.ColumnGroup]? = nil,
        columnLevelPermissionRules: [QuickSightClientTypes.ColumnLevelPermissionRule]? = nil,
        dataSetId: Swift.String? = nil,
        dataSetUsageConfiguration: QuickSightClientTypes.DataSetUsageConfiguration? = nil,
        fieldFolders: [Swift.String:QuickSightClientTypes.FieldFolder]? = nil,
        importMode: QuickSightClientTypes.DataSetImportMode? = nil,
        logicalTableMap: [Swift.String:QuickSightClientTypes.LogicalTable]? = nil,
        name: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        physicalTableMap: [Swift.String:QuickSightClientTypes.PhysicalTable]? = nil,
        rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet? = nil,
        rowLevelPermissionTagConfiguration: QuickSightClientTypes.RowLevelPermissionTagConfiguration? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.columnGroups = columnGroups
        self.columnLevelPermissionRules = columnLevelPermissionRules
        self.dataSetId = dataSetId
        self.dataSetUsageConfiguration = dataSetUsageConfiguration
        self.fieldFolders = fieldFolders
        self.importMode = importMode
        self.logicalTableMap = logicalTableMap
        self.name = name
        self.permissions = permissions
        self.physicalTableMap = physicalTableMap
        self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
        self.rowLevelPermissionTagConfiguration = rowLevelPermissionTagConfiguration
        self.tags = tags
    }
}

struct CreateDataSetInputBody: Swift.Equatable {
    let dataSetId: Swift.String?
    let name: Swift.String?
    let physicalTableMap: [Swift.String:QuickSightClientTypes.PhysicalTable]?
    let logicalTableMap: [Swift.String:QuickSightClientTypes.LogicalTable]?
    let importMode: QuickSightClientTypes.DataSetImportMode?
    let columnGroups: [QuickSightClientTypes.ColumnGroup]?
    let fieldFolders: [Swift.String:QuickSightClientTypes.FieldFolder]?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet?
    let rowLevelPermissionTagConfiguration: QuickSightClientTypes.RowLevelPermissionTagConfiguration?
    let columnLevelPermissionRules: [QuickSightClientTypes.ColumnLevelPermissionRule]?
    let tags: [QuickSightClientTypes.Tag]?
    let dataSetUsageConfiguration: QuickSightClientTypes.DataSetUsageConfiguration?
}

extension CreateDataSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnGroups = "ColumnGroups"
        case columnLevelPermissionRules = "ColumnLevelPermissionRules"
        case dataSetId = "DataSetId"
        case dataSetUsageConfiguration = "DataSetUsageConfiguration"
        case fieldFolders = "FieldFolders"
        case importMode = "ImportMode"
        case logicalTableMap = "LogicalTableMap"
        case name = "Name"
        case permissions = "Permissions"
        case physicalTableMap = "PhysicalTableMap"
        case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
        case rowLevelPermissionTagConfiguration = "RowLevelPermissionTagConfiguration"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let physicalTableMapContainer = try containerValues.decodeIfPresent([Swift.String: QuickSightClientTypes.PhysicalTable?].self, forKey: .physicalTableMap)
        var physicalTableMapDecoded0: [Swift.String:QuickSightClientTypes.PhysicalTable]? = nil
        if let physicalTableMapContainer = physicalTableMapContainer {
            physicalTableMapDecoded0 = [Swift.String:QuickSightClientTypes.PhysicalTable]()
            for (key0, physicaltable0) in physicalTableMapContainer {
                if let physicaltable0 = physicaltable0 {
                    physicalTableMapDecoded0?[key0] = physicaltable0
                }
            }
        }
        physicalTableMap = physicalTableMapDecoded0
        let logicalTableMapContainer = try containerValues.decodeIfPresent([Swift.String: QuickSightClientTypes.LogicalTable?].self, forKey: .logicalTableMap)
        var logicalTableMapDecoded0: [Swift.String:QuickSightClientTypes.LogicalTable]? = nil
        if let logicalTableMapContainer = logicalTableMapContainer {
            logicalTableMapDecoded0 = [Swift.String:QuickSightClientTypes.LogicalTable]()
            for (key0, logicaltable0) in logicalTableMapContainer {
                if let logicaltable0 = logicaltable0 {
                    logicalTableMapDecoded0?[key0] = logicaltable0
                }
            }
        }
        logicalTableMap = logicalTableMapDecoded0
        let importModeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSetImportMode.self, forKey: .importMode)
        importMode = importModeDecoded
        let columnGroupsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnGroup?].self, forKey: .columnGroups)
        var columnGroupsDecoded0:[QuickSightClientTypes.ColumnGroup]? = nil
        if let columnGroupsContainer = columnGroupsContainer {
            columnGroupsDecoded0 = [QuickSightClientTypes.ColumnGroup]()
            for structure0 in columnGroupsContainer {
                if let structure0 = structure0 {
                    columnGroupsDecoded0?.append(structure0)
                }
            }
        }
        columnGroups = columnGroupsDecoded0
        let fieldFoldersContainer = try containerValues.decodeIfPresent([Swift.String: QuickSightClientTypes.FieldFolder?].self, forKey: .fieldFolders)
        var fieldFoldersDecoded0: [Swift.String:QuickSightClientTypes.FieldFolder]? = nil
        if let fieldFoldersContainer = fieldFoldersContainer {
            fieldFoldersDecoded0 = [Swift.String:QuickSightClientTypes.FieldFolder]()
            for (key0, fieldfolder0) in fieldFoldersContainer {
                if let fieldfolder0 = fieldfolder0 {
                    fieldFoldersDecoded0?[key0] = fieldfolder0
                }
            }
        }
        fieldFolders = fieldFoldersDecoded0
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let rowLevelPermissionDataSetDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RowLevelPermissionDataSet.self, forKey: .rowLevelPermissionDataSet)
        rowLevelPermissionDataSet = rowLevelPermissionDataSetDecoded
        let rowLevelPermissionTagConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RowLevelPermissionTagConfiguration.self, forKey: .rowLevelPermissionTagConfiguration)
        rowLevelPermissionTagConfiguration = rowLevelPermissionTagConfigurationDecoded
        let columnLevelPermissionRulesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnLevelPermissionRule?].self, forKey: .columnLevelPermissionRules)
        var columnLevelPermissionRulesDecoded0:[QuickSightClientTypes.ColumnLevelPermissionRule]? = nil
        if let columnLevelPermissionRulesContainer = columnLevelPermissionRulesContainer {
            columnLevelPermissionRulesDecoded0 = [QuickSightClientTypes.ColumnLevelPermissionRule]()
            for structure0 in columnLevelPermissionRulesContainer {
                if let structure0 = structure0 {
                    columnLevelPermissionRulesDecoded0?.append(structure0)
                }
            }
        }
        columnLevelPermissionRules = columnLevelPermissionRulesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QuickSightClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QuickSightClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let dataSetUsageConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSetUsageConfiguration.self, forKey: .dataSetUsageConfiguration)
        dataSetUsageConfiguration = dataSetUsageConfigurationDecoded
    }
}

extension CreateDataSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDataSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDataSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDataSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDataSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.dataSetId = output.dataSetId
            self.ingestionArn = output.ingestionArn
            self.ingestionId = output.ingestionId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.dataSetId = nil
            self.ingestionArn = nil
            self.ingestionId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateDataSetOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset.
    public var arn: Swift.String?
    /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSetId: Swift.String?
    /// The ARN for the ingestion, which is triggered as a result of dataset creation if the import mode is SPICE.
    public var ingestionArn: Swift.String?
    /// The ID of the ingestion, which is triggered as a result of dataset creation if the import mode is SPICE.
    public var ingestionId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        ingestionArn: Swift.String? = nil,
        ingestionId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.dataSetId = dataSetId
        self.ingestionArn = ingestionArn
        self.ingestionId = ingestionId
        self.requestId = requestId
        self.status = status
    }
}

struct CreateDataSetOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let dataSetId: Swift.String?
    let ingestionArn: Swift.String?
    let ingestionId: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension CreateDataSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case dataSetId = "DataSetId"
        case ingestionArn = "IngestionArn"
        case ingestionId = "IngestionId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let ingestionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ingestionArn)
        ingestionArn = ingestionArnDecoded
        let ingestionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ingestionId)
        ingestionId = ingestionIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension CreateDataSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataSourceInput(awsAccountId: \(Swift.String(describing: awsAccountId)), dataSourceId: \(Swift.String(describing: dataSourceId)), dataSourceParameters: \(Swift.String(describing: dataSourceParameters)), name: \(Swift.String(describing: name)), permissions: \(Swift.String(describing: permissions)), sslProperties: \(Swift.String(describing: sslProperties)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), vpcConnectionProperties: \(Swift.String(describing: vpcConnectionProperties)), credentials: \"CONTENT_REDACTED\")"}
}

extension CreateDataSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
        case dataSourceId = "DataSourceId"
        case dataSourceParameters = "DataSourceParameters"
        case name = "Name"
        case permissions = "Permissions"
        case sslProperties = "SslProperties"
        case tags = "Tags"
        case type = "Type"
        case vpcConnectionProperties = "VpcConnectionProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credentials = self.credentials {
            try encodeContainer.encode(credentials, forKey: .credentials)
        }
        if let dataSourceId = self.dataSourceId {
            try encodeContainer.encode(dataSourceId, forKey: .dataSourceId)
        }
        if let dataSourceParameters = self.dataSourceParameters {
            try encodeContainer.encode(dataSourceParameters, forKey: .dataSourceParameters)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for resourcepermission0 in permissions {
                try permissionsContainer.encode(resourcepermission0)
            }
        }
        if let sslProperties = self.sslProperties {
            try encodeContainer.encode(sslProperties, forKey: .sslProperties)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let vpcConnectionProperties = self.vpcConnectionProperties {
            try encodeContainer.encode(vpcConnectionProperties, forKey: .vpcConnectionProperties)
        }
    }
}

extension CreateDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sources"
    }
}

public struct CreateDataSourceInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The credentials Amazon QuickSight that uses to connect to your underlying source. Currently, only credentials based on user name and password are supported.
    public var credentials: QuickSightClientTypes.DataSourceCredentials?
    /// An ID for the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The parameters that Amazon QuickSight uses to connect to your underlying source.
    public var dataSourceParameters: QuickSightClientTypes.DataSourceParameters?
    /// A display name for the data source.
    /// This member is required.
    public var name: Swift.String?
    /// A list of resource permissions on the data source.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// Secure Socket Layer (SSL) properties that apply when Amazon QuickSight connects to your underlying source.
    public var sslProperties: QuickSightClientTypes.SslProperties?
    /// Contains a map of the key-value pairs for the resource tag or tags assigned to the data source.
    public var tags: [QuickSightClientTypes.Tag]?
    /// The type of the data source. To return a list of all data sources, use ListDataSources. Use AMAZON_ELASTICSEARCH for Amazon OpenSearch Service.
    /// This member is required.
    public var type: QuickSightClientTypes.DataSourceType?
    /// Use this parameter only when you want Amazon QuickSight to use a VPC connection when connecting to your underlying source.
    public var vpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties?

    public init (
        awsAccountId: Swift.String? = nil,
        credentials: QuickSightClientTypes.DataSourceCredentials? = nil,
        dataSourceId: Swift.String? = nil,
        dataSourceParameters: QuickSightClientTypes.DataSourceParameters? = nil,
        name: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        sslProperties: QuickSightClientTypes.SslProperties? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil,
        type: QuickSightClientTypes.DataSourceType? = nil,
        vpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.credentials = credentials
        self.dataSourceId = dataSourceId
        self.dataSourceParameters = dataSourceParameters
        self.name = name
        self.permissions = permissions
        self.sslProperties = sslProperties
        self.tags = tags
        self.type = type
        self.vpcConnectionProperties = vpcConnectionProperties
    }
}

struct CreateDataSourceInputBody: Swift.Equatable {
    let dataSourceId: Swift.String?
    let name: Swift.String?
    let type: QuickSightClientTypes.DataSourceType?
    let dataSourceParameters: QuickSightClientTypes.DataSourceParameters?
    let credentials: QuickSightClientTypes.DataSourceCredentials?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let vpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties?
    let sslProperties: QuickSightClientTypes.SslProperties?
    let tags: [QuickSightClientTypes.Tag]?
}

extension CreateDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
        case dataSourceId = "DataSourceId"
        case dataSourceParameters = "DataSourceParameters"
        case name = "Name"
        case permissions = "Permissions"
        case sslProperties = "SslProperties"
        case tags = "Tags"
        case type = "Type"
        case vpcConnectionProperties = "VpcConnectionProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSourceType.self, forKey: .type)
        type = typeDecoded
        let dataSourceParametersDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSourceParameters.self, forKey: .dataSourceParameters)
        dataSourceParameters = dataSourceParametersDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSourceCredentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let vpcConnectionPropertiesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VpcConnectionProperties.self, forKey: .vpcConnectionProperties)
        vpcConnectionProperties = vpcConnectionPropertiesDecoded
        let sslPropertiesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SslProperties.self, forKey: .sslProperties)
        sslProperties = sslPropertiesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QuickSightClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QuickSightClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDataSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDataSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDataSourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDataSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationStatus = output.creationStatus
            self.dataSourceId = output.dataSourceId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.creationStatus = nil
            self.dataSourceId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateDataSourceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the data source.
    public var arn: Swift.String?
    /// The status of creating the data source.
    public var creationStatus: QuickSightClientTypes.ResourceStatus?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSourceId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.ResourceStatus? = nil,
        dataSourceId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.dataSourceId = dataSourceId
        self.requestId = requestId
        self.status = status
    }
}

struct CreateDataSourceOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let dataSourceId: Swift.String?
    let creationStatus: QuickSightClientTypes.ResourceStatus?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension CreateDataSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationStatus = "CreationStatus"
        case dataSourceId = "DataSourceId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension CreateFolderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case folderType = "FolderType"
        case name = "Name"
        case parentFolderArn = "ParentFolderArn"
        case permissions = "Permissions"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let folderType = self.folderType {
            try encodeContainer.encode(folderType.rawValue, forKey: .folderType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentFolderArn = self.parentFolderArn {
            try encodeContainer.encode(parentFolderArn, forKey: .parentFolderArn)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for resourcepermission0 in permissions {
                try permissionsContainer.encode(resourcepermission0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let folderId = folderId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())"
    }
}

public struct CreateFolderInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account where you want to create the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The type of folder. By default, folderType is SHARED.
    public var folderType: QuickSightClientTypes.FolderType?
    /// The name of the folder.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) for the parent folder. ParentFolderArn can be null. An empty parentFolderArn creates a root-level folder.
    public var parentFolderArn: Swift.String?
    /// A structure that describes the principals and the resource-level permissions of a folder. To specify no permissions, omit Permissions.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// Tags for the folder.
    public var tags: [QuickSightClientTypes.Tag]?

    public init (
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil,
        folderType: QuickSightClientTypes.FolderType? = nil,
        name: Swift.String? = nil,
        parentFolderArn: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
        self.folderType = folderType
        self.name = name
        self.parentFolderArn = parentFolderArn
        self.permissions = permissions
        self.tags = tags
    }
}

struct CreateFolderInputBody: Swift.Equatable {
    let name: Swift.String?
    let folderType: QuickSightClientTypes.FolderType?
    let parentFolderArn: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let tags: [QuickSightClientTypes.Tag]?
}

extension CreateFolderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case folderType = "FolderType"
        case name = "Name"
        case parentFolderArn = "ParentFolderArn"
        case permissions = "Permissions"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let folderTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FolderType.self, forKey: .folderType)
        folderType = folderTypeDecoded
        let parentFolderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentFolderArn)
        parentFolderArn = parentFolderArnDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QuickSightClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QuickSightClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFolderMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let folderId = folderId else {
            return nil
        }
        guard let memberType = memberType else {
            return nil
        }
        guard let memberId = memberId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())/members/\(memberType.rawValue.urlPercentEncoding())/\(memberId.urlPercentEncoding())"
    }
}

public struct CreateFolderMembershipInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The ID of the asset (the dashboard, analysis, or dataset).
    /// This member is required.
    public var memberId: Swift.String?
    /// The type of the member, including DASHBOARD, ANALYSIS, and DATASET.
    /// This member is required.
    public var memberType: QuickSightClientTypes.MemberType?

    public init (
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil,
        memberId: Swift.String? = nil,
        memberType: QuickSightClientTypes.MemberType? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
        self.memberId = memberId
        self.memberType = memberType
    }
}

struct CreateFolderMembershipInputBody: Swift.Equatable {
}

extension CreateFolderMembershipInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CreateFolderMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFolderMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateFolderMembershipOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFolderMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateFolderMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.folderMember = output.folderMember
            self.requestId = output.requestId
            self.status = output.status
        } else {
            self.folderMember = nil
            self.requestId = nil
            self.status = 0
        }
    }
}

public struct CreateFolderMembershipOutputResponse: Swift.Equatable {
    /// Information about the member in the folder.
    public var folderMember: QuickSightClientTypes.FolderMember?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        folderMember: QuickSightClientTypes.FolderMember? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.folderMember = folderMember
        self.requestId = requestId
        self.status = status
    }
}

struct CreateFolderMembershipOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let folderMember: QuickSightClientTypes.FolderMember?
    let requestId: Swift.String?
}

extension CreateFolderMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case folderMember = "FolderMember"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let folderMemberDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FolderMember.self, forKey: .folderMember)
        folderMember = folderMemberDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension CreateFolderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFolderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateFolderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFolderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateFolderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.folderId = output.folderId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.folderId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateFolderOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the newly created folder.
    public var arn: Swift.String?
    /// The folder ID for the newly created folder.
    public var folderId: Swift.String?
    /// The request ID for the newly created folder.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        folderId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.folderId = folderId
        self.requestId = requestId
        self.status = status
    }
}

struct CreateFolderOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let arn: Swift.String?
    let folderId: Swift.String?
    let requestId: Swift.String?
}

extension CreateFolderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case folderId = "FolderId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let folderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .folderId)
        folderId = folderIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension CreateGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case groupName = "GroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }
}

extension CreateGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups"
    }
}

/// The request object for this operation.
public struct CreateGroupInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A description for the group that you want to create.
    public var description: Swift.String?
    /// A name for the group that you want to create.
    /// This member is required.
    public var groupName: Swift.String?
    /// The namespace that you want the group to be a part of.
    /// This member is required.
    public var namespace: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        description: Swift.String? = nil,
        groupName: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.description = description
        self.groupName = groupName
        self.namespace = namespace
    }
}

struct CreateGroupInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let description: Swift.String?
}

extension CreateGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case groupName = "GroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateGroupMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let groupName = groupName else {
            return nil
        }
        guard let memberName = memberName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups/\(groupName.urlPercentEncoding())/members/\(memberName.urlPercentEncoding())"
    }
}

public struct CreateGroupMembershipInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The name of the group that you want to add the user to.
    /// This member is required.
    public var groupName: Swift.String?
    /// The name of the user that you want to add to the group membership.
    /// This member is required.
    public var memberName: Swift.String?
    /// The namespace that you want the user to be a part of.
    /// This member is required.
    public var namespace: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        memberName: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.groupName = groupName
        self.memberName = memberName
        self.namespace = namespace
    }
}

struct CreateGroupMembershipInputBody: Swift.Equatable {
}

extension CreateGroupMembershipInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CreateGroupMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGroupMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateGroupMembershipOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGroupMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateGroupMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groupMember = output.groupMember
            self.requestId = output.requestId
        } else {
            self.groupMember = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateGroupMembershipOutputResponse: Swift.Equatable {
    /// The group member.
    public var groupMember: QuickSightClientTypes.GroupMember?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        groupMember: QuickSightClientTypes.GroupMember? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.groupMember = groupMember
        self.requestId = requestId
        self.status = status
    }
}

struct CreateGroupMembershipOutputResponseBody: Swift.Equatable {
    let groupMember: QuickSightClientTypes.GroupMember?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension CreateGroupMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupMember = "GroupMember"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupMemberDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GroupMember.self, forKey: .groupMember)
        groupMember = groupMemberDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension CreateGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.group = output.group
            self.requestId = output.requestId
        } else {
            self.group = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

/// The response object for this operation.
public struct CreateGroupOutputResponse: Swift.Equatable {
    /// The name of the group.
    public var group: QuickSightClientTypes.Group?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        group: QuickSightClientTypes.Group? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.group = group
        self.requestId = requestId
        self.status = status
    }
}

struct CreateGroupOutputResponseBody: Swift.Equatable {
    let group: QuickSightClientTypes.Group?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension CreateGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group = "Group"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Group.self, forKey: .group)
        group = groupDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension CreateIAMPolicyAssignmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentName = "AssignmentName"
        case assignmentStatus = "AssignmentStatus"
        case identities = "Identities"
        case policyArn = "PolicyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentName = self.assignmentName {
            try encodeContainer.encode(assignmentName, forKey: .assignmentName)
        }
        if let assignmentStatus = self.assignmentStatus {
            try encodeContainer.encode(assignmentStatus.rawValue, forKey: .assignmentStatus)
        }
        if let identities = identities {
            var identitiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .identities)
            for (dictKey0, identityMap0) in identities {
                var identityMap0Container = identitiesContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for identityname1 in identityMap0 {
                    try identityMap0Container.encode(identityname1)
                }
            }
        }
        if let policyArn = self.policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
    }
}

extension CreateIAMPolicyAssignmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/iam-policy-assignments"
    }
}

public struct CreateIAMPolicyAssignmentInput: Swift.Equatable {
    /// The name of the assignment, also called a rule. It must be unique within an Amazon Web Services account.
    /// This member is required.
    public var assignmentName: Swift.String?
    /// The status of the assignment. Possible values are as follows:
    ///
    /// * ENABLED - Anything specified in this assignment is used when creating the data source.
    ///
    /// * DISABLED - This assignment isn't used when creating the data source.
    ///
    /// * DRAFT - This assignment is an unfinished draft and isn't used when creating the data source.
    /// This member is required.
    public var assignmentStatus: QuickSightClientTypes.AssignmentStatus?
    /// The ID of the Amazon Web Services account where you want to assign an IAM policy to Amazon QuickSight users or groups.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The Amazon QuickSight users, groups, or both that you want to assign the policy to.
    public var identities: [Swift.String:[Swift.String]]?
    /// The namespace that contains the assignment.
    /// This member is required.
    public var namespace: Swift.String?
    /// The ARN for the IAM policy to apply to the Amazon QuickSight users and groups specified in this assignment.
    public var policyArn: Swift.String?

    public init (
        assignmentName: Swift.String? = nil,
        assignmentStatus: QuickSightClientTypes.AssignmentStatus? = nil,
        awsAccountId: Swift.String? = nil,
        identities: [Swift.String:[Swift.String]]? = nil,
        namespace: Swift.String? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.assignmentName = assignmentName
        self.assignmentStatus = assignmentStatus
        self.awsAccountId = awsAccountId
        self.identities = identities
        self.namespace = namespace
        self.policyArn = policyArn
    }
}

struct CreateIAMPolicyAssignmentInputBody: Swift.Equatable {
    let assignmentName: Swift.String?
    let assignmentStatus: QuickSightClientTypes.AssignmentStatus?
    let policyArn: Swift.String?
    let identities: [Swift.String:[Swift.String]]?
}

extension CreateIAMPolicyAssignmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentName = "AssignmentName"
        case assignmentStatus = "AssignmentStatus"
        case identities = "Identities"
        case policyArn = "PolicyArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentName)
        assignmentName = assignmentNameDecoded
        let assignmentStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AssignmentStatus.self, forKey: .assignmentStatus)
        assignmentStatus = assignmentStatusDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let identitiesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .identities)
        var identitiesDecoded0: [Swift.String:[Swift.String]]? = nil
        if let identitiesContainer = identitiesContainer {
            identitiesDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, identitynamelist0) in identitiesContainer {
                var identitynamelist0Decoded0: [Swift.String]? = nil
                if let identitynamelist0 = identitynamelist0 {
                    identitynamelist0Decoded0 = [Swift.String]()
                    for string1 in identitynamelist0 {
                        if let string1 = string1 {
                            identitynamelist0Decoded0?.append(string1)
                        }
                    }
                }
                identitiesDecoded0?[key0] = identitynamelist0Decoded0
            }
        }
        identities = identitiesDecoded0
    }
}

extension CreateIAMPolicyAssignmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIAMPolicyAssignmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentUpdatingException" : self = .concurrentUpdatingException(try ConcurrentUpdatingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateIAMPolicyAssignmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case concurrentUpdatingException(ConcurrentUpdatingException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIAMPolicyAssignmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateIAMPolicyAssignmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assignmentId = output.assignmentId
            self.assignmentName = output.assignmentName
            self.assignmentStatus = output.assignmentStatus
            self.identities = output.identities
            self.policyArn = output.policyArn
            self.requestId = output.requestId
        } else {
            self.assignmentId = nil
            self.assignmentName = nil
            self.assignmentStatus = nil
            self.identities = nil
            self.policyArn = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateIAMPolicyAssignmentOutputResponse: Swift.Equatable {
    /// The ID for the assignment.
    public var assignmentId: Swift.String?
    /// The name of the assignment. This name must be unique within the Amazon Web Services account.
    public var assignmentName: Swift.String?
    /// The status of the assignment. Possible values are as follows:
    ///
    /// * ENABLED - Anything specified in this assignment is used when creating the data source.
    ///
    /// * DISABLED - This assignment isn't used when creating the data source.
    ///
    /// * DRAFT - This assignment is an unfinished draft and isn't used when creating the data source.
    public var assignmentStatus: QuickSightClientTypes.AssignmentStatus?
    /// The Amazon QuickSight users, groups, or both that the IAM policy is assigned to.
    public var identities: [Swift.String:[Swift.String]]?
    /// The ARN for the IAM policy that is applied to the Amazon QuickSight users and groups specified in this assignment.
    public var policyArn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        assignmentId: Swift.String? = nil,
        assignmentName: Swift.String? = nil,
        assignmentStatus: QuickSightClientTypes.AssignmentStatus? = nil,
        identities: [Swift.String:[Swift.String]]? = nil,
        policyArn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.assignmentId = assignmentId
        self.assignmentName = assignmentName
        self.assignmentStatus = assignmentStatus
        self.identities = identities
        self.policyArn = policyArn
        self.requestId = requestId
        self.status = status
    }
}

struct CreateIAMPolicyAssignmentOutputResponseBody: Swift.Equatable {
    let assignmentName: Swift.String?
    let assignmentId: Swift.String?
    let assignmentStatus: QuickSightClientTypes.AssignmentStatus?
    let policyArn: Swift.String?
    let identities: [Swift.String:[Swift.String]]?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension CreateIAMPolicyAssignmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentId = "AssignmentId"
        case assignmentName = "AssignmentName"
        case assignmentStatus = "AssignmentStatus"
        case identities = "Identities"
        case policyArn = "PolicyArn"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentName)
        assignmentName = assignmentNameDecoded
        let assignmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentId)
        assignmentId = assignmentIdDecoded
        let assignmentStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AssignmentStatus.self, forKey: .assignmentStatus)
        assignmentStatus = assignmentStatusDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let identitiesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .identities)
        var identitiesDecoded0: [Swift.String:[Swift.String]]? = nil
        if let identitiesContainer = identitiesContainer {
            identitiesDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, identitynamelist0) in identitiesContainer {
                var identitynamelist0Decoded0: [Swift.String]? = nil
                if let identitynamelist0 = identitynamelist0 {
                    identitynamelist0Decoded0 = [Swift.String]()
                    for string1 in identitynamelist0 {
                        if let string1 = string1 {
                            identitynamelist0Decoded0?.append(string1)
                        }
                    }
                }
                identitiesDecoded0?[key0] = identitynamelist0Decoded0
            }
        }
        identities = identitiesDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension CreateIngestionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingestionType = "IngestionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ingestionType = self.ingestionType {
            try encodeContainer.encode(ingestionType.rawValue, forKey: .ingestionType)
        }
    }
}

extension CreateIngestionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSetId = dataSetId else {
            return nil
        }
        guard let ingestionId = ingestionId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/ingestions/\(ingestionId.urlPercentEncoding())"
    }
}

public struct CreateIngestionInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dataset used in the ingestion.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// An ID for the ingestion.
    /// This member is required.
    public var ingestionId: Swift.String?
    /// The type of ingestion that you want to create.
    public var ingestionType: QuickSightClientTypes.IngestionType?

    public init (
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        ingestionId: Swift.String? = nil,
        ingestionType: QuickSightClientTypes.IngestionType? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
        self.ingestionId = ingestionId
        self.ingestionType = ingestionType
    }
}

struct CreateIngestionInputBody: Swift.Equatable {
    let ingestionType: QuickSightClientTypes.IngestionType?
}

extension CreateIngestionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingestionType = "IngestionType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ingestionTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IngestionType.self, forKey: .ingestionType)
        ingestionType = ingestionTypeDecoded
    }
}

extension CreateIngestionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIngestionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateIngestionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIngestionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateIngestionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.ingestionId = output.ingestionId
            self.ingestionStatus = output.ingestionStatus
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.ingestionId = nil
            self.ingestionStatus = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateIngestionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the data ingestion.
    public var arn: Swift.String?
    /// An ID for the ingestion.
    public var ingestionId: Swift.String?
    /// The ingestion status.
    public var ingestionStatus: QuickSightClientTypes.IngestionStatus?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        ingestionId: Swift.String? = nil,
        ingestionStatus: QuickSightClientTypes.IngestionStatus? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.ingestionId = ingestionId
        self.ingestionStatus = ingestionStatus
        self.requestId = requestId
        self.status = status
    }
}

struct CreateIngestionOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let ingestionId: Swift.String?
    let ingestionStatus: QuickSightClientTypes.IngestionStatus?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension CreateIngestionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case ingestionId = "IngestionId"
        case ingestionStatus = "IngestionStatus"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ingestionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ingestionId)
        ingestionId = ingestionIdDecoded
        let ingestionStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IngestionStatus.self, forKey: .ingestionStatus)
        ingestionStatus = ingestionStatusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension CreateNamespaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStore = "IdentityStore"
        case namespace = "Namespace"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStore = self.identityStore {
            try encodeContainer.encode(identityStore.rawValue, forKey: .identityStore)
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())"
    }
}

public struct CreateNamespaceInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that you want to create the Amazon QuickSight namespace in.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// Specifies the type of your user identity directory. Currently, this supports users with an identity type of QUICKSIGHT.
    /// This member is required.
    public var identityStore: QuickSightClientTypes.IdentityStore?
    /// The name that you want to use to describe the new namespace.
    /// This member is required.
    public var namespace: Swift.String?
    /// The tags that you want to associate with the namespace that you're creating.
    public var tags: [QuickSightClientTypes.Tag]?

    public init (
        awsAccountId: Swift.String? = nil,
        identityStore: QuickSightClientTypes.IdentityStore? = nil,
        namespace: Swift.String? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.identityStore = identityStore
        self.namespace = namespace
        self.tags = tags
    }
}

struct CreateNamespaceInputBody: Swift.Equatable {
    let namespace: Swift.String?
    let identityStore: QuickSightClientTypes.IdentityStore?
    let tags: [QuickSightClientTypes.Tag]?
}

extension CreateNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStore = "IdentityStore"
        case namespace = "Namespace"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let identityStoreDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IdentityStore.self, forKey: .identityStore)
        identityStore = identityStoreDecoded
        let tagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QuickSightClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QuickSightClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateNamespaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.capacityRegion = output.capacityRegion
            self.creationStatus = output.creationStatus
            self.identityStore = output.identityStore
            self.name = output.name
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.capacityRegion = nil
            self.creationStatus = nil
            self.identityStore = nil
            self.name = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateNamespaceOutputResponse: Swift.Equatable {
    /// The ARN of the Amazon QuickSight namespace you created.
    public var arn: Swift.String?
    /// The Amazon Web Services Region; that you want to use for the free SPICE capacity for the new namespace. This is set to the region that you run CreateNamespace in.
    public var capacityRegion: Swift.String?
    /// The status of the creation of the namespace. This is an asynchronous process. A status of CREATED means that your namespace is ready to use. If an error occurs, it indicates if the process is retryable or non-retryable. In the case of a non-retryable error, refer to the error message for follow-up tasks.
    public var creationStatus: QuickSightClientTypes.NamespaceStatus?
    /// Specifies the type of your user identity directory. Currently, this supports users with an identity type of QUICKSIGHT.
    public var identityStore: QuickSightClientTypes.IdentityStore?
    /// The name of the new namespace that you created.
    public var name: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        capacityRegion: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.NamespaceStatus? = nil,
        identityStore: QuickSightClientTypes.IdentityStore? = nil,
        name: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.capacityRegion = capacityRegion
        self.creationStatus = creationStatus
        self.identityStore = identityStore
        self.name = name
        self.requestId = requestId
        self.status = status
    }
}

struct CreateNamespaceOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let capacityRegion: Swift.String?
    let creationStatus: QuickSightClientTypes.NamespaceStatus?
    let identityStore: QuickSightClientTypes.IdentityStore?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension CreateNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case capacityRegion = "CapacityRegion"
        case creationStatus = "CreationStatus"
        case identityStore = "IdentityStore"
        case name = "Name"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let capacityRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacityRegion)
        capacityRegion = capacityRegionDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NamespaceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let identityStoreDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IdentityStore.self, forKey: .identityStore)
        identityStore = identityStoreDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension CreateTemplateAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateVersionNumber = "TemplateVersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateVersionNumber = self.templateVersionNumber {
            try encodeContainer.encode(templateVersionNumber, forKey: .templateVersionNumber)
        }
    }
}

extension CreateTemplateAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        guard let aliasName = aliasName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/aliases/\(aliasName.urlPercentEncoding())"
    }
}

public struct CreateTemplateAliasInput: Swift.Equatable {
    /// The name that you want to give to the template alias that you're creating. Don't start the alias name with the $ character. Alias names that start with $ are reserved by Amazon QuickSight.
    /// This member is required.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the template that you creating an alias for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// An ID for the template.
    /// This member is required.
    public var templateId: Swift.String?
    /// The version number of the template.
    /// This member is required.
    public var templateVersionNumber: Swift.Int?

    public init (
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        templateId: Swift.String? = nil,
        templateVersionNumber: Swift.Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.templateId = templateId
        self.templateVersionNumber = templateVersionNumber
    }
}

struct CreateTemplateAliasInputBody: Swift.Equatable {
    let templateVersionNumber: Swift.Int?
}

extension CreateTemplateAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateVersionNumber = "TemplateVersionNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .templateVersionNumber)
        templateVersionNumber = templateVersionNumberDecoded
    }
}

extension CreateTemplateAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTemplateAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateTemplateAliasOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTemplateAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateTemplateAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.templateAlias = output.templateAlias
        } else {
            self.requestId = nil
            self.templateAlias = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateTemplateAliasOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// Information about the template alias.
    public var templateAlias: QuickSightClientTypes.TemplateAlias?

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateAlias: QuickSightClientTypes.TemplateAlias? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.templateAlias = templateAlias
    }
}

struct CreateTemplateAliasOutputResponseBody: Swift.Equatable {
    let templateAlias: QuickSightClientTypes.TemplateAlias?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension CreateTemplateAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case templateAlias = "TemplateAlias"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateAliasDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TemplateAlias.self, forKey: .templateAlias)
        templateAlias = templateAliasDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension CreateTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition = "Definition"
        case name = "Name"
        case permissions = "Permissions"
        case sourceEntity = "SourceEntity"
        case tags = "Tags"
        case versionDescription = "VersionDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for resourcepermission0 in permissions {
                try permissionsContainer.encode(resourcepermission0)
            }
        }
        if let sourceEntity = self.sourceEntity {
            try encodeContainer.encode(sourceEntity, forKey: .sourceEntity)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let versionDescription = self.versionDescription {
            try encodeContainer.encode(versionDescription, forKey: .versionDescription)
        }
    }
}

extension CreateTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())"
    }
}

public struct CreateTemplateInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the group is in. You use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The definition of a template. A definition is the data model of all features in a Dashboard, Template, or Analysis.
    public var definition: QuickSightClientTypes.TemplateVersionDefinition?
    /// A display name for the template.
    public var name: Swift.String?
    /// A list of resource permissions to be set on the template.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The entity that you are using as a source when you create the template. In SourceEntity, you specify the type of object you're using as source: SourceTemplate for a template or SourceAnalysis for an analysis. Both of these require an Amazon Resource Name (ARN). For SourceTemplate, specify the ARN of the source template. For SourceAnalysis, specify the ARN of the source analysis. The SourceTemplate ARN can contain any Amazon Web Services account and any Amazon QuickSight-supported Amazon Web Services Region. Use the DataSetReferences entity within SourceTemplate or SourceAnalysis to list the replacement datasets for the placeholders listed in the original. The schema in each dataset must match its placeholder.
    public var sourceEntity: QuickSightClientTypes.TemplateSourceEntity?
    /// Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.
    public var tags: [QuickSightClientTypes.Tag]?
    /// An ID for the template that you want to create. This template is unique per Amazon Web Services Region; in each Amazon Web Services account.
    /// This member is required.
    public var templateId: Swift.String?
    /// A description of the current template version being created. This API operation creates the first version of the template. Every time UpdateTemplate is called, a new version is created. Each version of the template maintains a description of the version in the VersionDescription field.
    public var versionDescription: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        definition: QuickSightClientTypes.TemplateVersionDefinition? = nil,
        name: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        sourceEntity: QuickSightClientTypes.TemplateSourceEntity? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil,
        templateId: Swift.String? = nil,
        versionDescription: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.definition = definition
        self.name = name
        self.permissions = permissions
        self.sourceEntity = sourceEntity
        self.tags = tags
        self.templateId = templateId
        self.versionDescription = versionDescription
    }
}

struct CreateTemplateInputBody: Swift.Equatable {
    let name: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let sourceEntity: QuickSightClientTypes.TemplateSourceEntity?
    let tags: [QuickSightClientTypes.Tag]?
    let versionDescription: Swift.String?
    let definition: QuickSightClientTypes.TemplateVersionDefinition?
}

extension CreateTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition = "Definition"
        case name = "Name"
        case permissions = "Permissions"
        case sourceEntity = "SourceEntity"
        case tags = "Tags"
        case versionDescription = "VersionDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let sourceEntityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TemplateSourceEntity.self, forKey: .sourceEntity)
        sourceEntity = sourceEntityDecoded
        let tagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QuickSightClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QuickSightClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let versionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionDescription)
        versionDescription = versionDescriptionDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TemplateVersionDefinition.self, forKey: .definition)
        definition = definitionDecoded
    }
}

extension CreateTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationStatus = output.creationStatus
            self.requestId = output.requestId
            self.templateId = output.templateId
            self.versionArn = output.versionArn
        } else {
            self.arn = nil
            self.creationStatus = nil
            self.requestId = nil
            self.templateId = nil
            self.versionArn = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateTemplateOutputResponse: Swift.Equatable {
    /// The ARN for the template.
    public var arn: Swift.String?
    /// The template creation status.
    public var creationStatus: QuickSightClientTypes.ResourceStatus?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ID of the template.
    public var templateId: Swift.String?
    /// The ARN for the template, including the version information of the first version.
    public var versionArn: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.ResourceStatus? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateId: Swift.String? = nil,
        versionArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.requestId = requestId
        self.status = status
        self.templateId = templateId
        self.versionArn = versionArn
    }
}

struct CreateTemplateOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let versionArn: Swift.String?
    let templateId: Swift.String?
    let creationStatus: QuickSightClientTypes.ResourceStatus?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension CreateTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationStatus = "CreationStatus"
        case requestId = "RequestId"
        case status = "Status"
        case templateId = "TemplateId"
        case versionArn = "VersionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionArn)
        versionArn = versionArnDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension CreateThemeAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case themeVersionNumber = "ThemeVersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let themeVersionNumber = self.themeVersionNumber {
            try encodeContainer.encode(themeVersionNumber, forKey: .themeVersionNumber)
        }
    }
}

extension CreateThemeAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let themeId = themeId else {
            return nil
        }
        guard let aliasName = aliasName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())/aliases/\(aliasName.urlPercentEncoding())"
    }
}

public struct CreateThemeAliasInput: Swift.Equatable {
    /// The name that you want to give to the theme alias that you are creating. The alias name can't begin with a $. Alias names that start with $ are reserved by Amazon QuickSight.
    /// This member is required.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the theme for the new theme alias.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// An ID for the theme alias.
    /// This member is required.
    public var themeId: Swift.String?
    /// The version number of the theme.
    /// This member is required.
    public var themeVersionNumber: Swift.Int?

    public init (
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        themeId: Swift.String? = nil,
        themeVersionNumber: Swift.Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.themeId = themeId
        self.themeVersionNumber = themeVersionNumber
    }
}

struct CreateThemeAliasInputBody: Swift.Equatable {
    let themeVersionNumber: Swift.Int?
}

extension CreateThemeAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case themeVersionNumber = "ThemeVersionNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .themeVersionNumber)
        themeVersionNumber = themeVersionNumberDecoded
    }
}

extension CreateThemeAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateThemeAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateThemeAliasOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateThemeAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateThemeAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.themeAlias = output.themeAlias
        } else {
            self.requestId = nil
            self.themeAlias = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateThemeAliasOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// Information about the theme alias.
    public var themeAlias: QuickSightClientTypes.ThemeAlias?

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeAlias: QuickSightClientTypes.ThemeAlias? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.themeAlias = themeAlias
    }
}

struct CreateThemeAliasOutputResponseBody: Swift.Equatable {
    let themeAlias: QuickSightClientTypes.ThemeAlias?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension CreateThemeAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case themeAlias = "ThemeAlias"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeAliasDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ThemeAlias.self, forKey: .themeAlias)
        themeAlias = themeAliasDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension CreateThemeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseThemeId = "BaseThemeId"
        case configuration = "Configuration"
        case name = "Name"
        case permissions = "Permissions"
        case tags = "Tags"
        case versionDescription = "VersionDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseThemeId = self.baseThemeId {
            try encodeContainer.encode(baseThemeId, forKey: .baseThemeId)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for resourcepermission0 in permissions {
                try permissionsContainer.encode(resourcepermission0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let versionDescription = self.versionDescription {
            try encodeContainer.encode(versionDescription, forKey: .versionDescription)
        }
    }
}

extension CreateThemeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let themeId = themeId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())"
    }
}

public struct CreateThemeInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account where you want to store the new theme.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the theme that a custom theme will inherit from. All themes inherit from one of the starting themes defined by Amazon QuickSight. For a list of the starting themes, use ListThemes or choose Themes from within an analysis.
    /// This member is required.
    public var baseThemeId: Swift.String?
    /// The theme configuration, which contains the theme display properties.
    /// This member is required.
    public var configuration: QuickSightClientTypes.ThemeConfiguration?
    /// A display name for the theme.
    /// This member is required.
    public var name: Swift.String?
    /// A valid grouping of resource permissions to apply to the new theme.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// A map of the key-value pairs for the resource tag or tags that you want to add to the resource.
    public var tags: [QuickSightClientTypes.Tag]?
    /// An ID for the theme that you want to create. The theme ID is unique per Amazon Web Services Region in each Amazon Web Services account.
    /// This member is required.
    public var themeId: Swift.String?
    /// A description of the first version of the theme that you're creating. Every time UpdateTheme is called, a new version is created. Each version of the theme has a description of the version in the VersionDescription field.
    public var versionDescription: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        baseThemeId: Swift.String? = nil,
        configuration: QuickSightClientTypes.ThemeConfiguration? = nil,
        name: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil,
        themeId: Swift.String? = nil,
        versionDescription: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.baseThemeId = baseThemeId
        self.configuration = configuration
        self.name = name
        self.permissions = permissions
        self.tags = tags
        self.themeId = themeId
        self.versionDescription = versionDescription
    }
}

struct CreateThemeInputBody: Swift.Equatable {
    let name: Swift.String?
    let baseThemeId: Swift.String?
    let versionDescription: Swift.String?
    let configuration: QuickSightClientTypes.ThemeConfiguration?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let tags: [QuickSightClientTypes.Tag]?
}

extension CreateThemeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseThemeId = "BaseThemeId"
        case configuration = "Configuration"
        case name = "Name"
        case permissions = "Permissions"
        case tags = "Tags"
        case versionDescription = "VersionDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let baseThemeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseThemeId)
        baseThemeId = baseThemeIdDecoded
        let versionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionDescription)
        versionDescription = versionDescriptionDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ThemeConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QuickSightClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QuickSightClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateThemeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateThemeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateThemeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateThemeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateThemeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationStatus = output.creationStatus
            self.requestId = output.requestId
            self.themeId = output.themeId
            self.versionArn = output.versionArn
        } else {
            self.arn = nil
            self.creationStatus = nil
            self.requestId = nil
            self.themeId = nil
            self.versionArn = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct CreateThemeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the theme.
    public var arn: Swift.String?
    /// The theme creation status.
    public var creationStatus: QuickSightClientTypes.ResourceStatus?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ID of the theme.
    public var themeId: Swift.String?
    /// The Amazon Resource Name (ARN) for the new theme.
    public var versionArn: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.ResourceStatus? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeId: Swift.String? = nil,
        versionArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.requestId = requestId
        self.status = status
        self.themeId = themeId
        self.versionArn = versionArn
    }
}

struct CreateThemeOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let versionArn: Swift.String?
    let themeId: Swift.String?
    let creationStatus: QuickSightClientTypes.ResourceStatus?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension CreateThemeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationStatus = "CreationStatus"
        case requestId = "RequestId"
        case status = "Status"
        case themeId = "ThemeId"
        case versionArn = "VersionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionArn)
        versionArn = versionArnDecoded
        let themeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeId)
        themeId = themeIdDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.CredentialPair: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alternateDataSourceParameters = "AlternateDataSourceParameters"
        case password = "Password"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alternateDataSourceParameters = alternateDataSourceParameters {
            var alternateDataSourceParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .alternateDataSourceParameters)
            for datasourceparameters0 in alternateDataSourceParameters {
                try alternateDataSourceParametersContainer.encode(datasourceparameters0)
            }
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let alternateDataSourceParametersContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataSourceParameters?].self, forKey: .alternateDataSourceParameters)
        var alternateDataSourceParametersDecoded0:[QuickSightClientTypes.DataSourceParameters]? = nil
        if let alternateDataSourceParametersContainer = alternateDataSourceParametersContainer {
            alternateDataSourceParametersDecoded0 = [QuickSightClientTypes.DataSourceParameters]()
            for union0 in alternateDataSourceParametersContainer {
                if let union0 = union0 {
                    alternateDataSourceParametersDecoded0?.append(union0)
                }
            }
        }
        alternateDataSourceParameters = alternateDataSourceParametersDecoded0
    }
}

extension QuickSightClientTypes {
    /// The combination of user name and password that are used as credentials.
    public struct CredentialPair: Swift.Equatable {
        /// A set of alternate data source parameters that you want to share for these credentials. The credentials are applied in tandem with the data source parameters when you copy a data source by using a create or update request. The API operation compares the DataSourceParameters structure that's in the request with the structures in the AlternateDataSourceParameters allow list. If the structures are an exact match, the request is allowed to use the new data source with the existing credentials. If the AlternateDataSourceParameters list is null, the DataSourceParameters originally used with these Credentials is automatically allowed.
        public var alternateDataSourceParameters: [QuickSightClientTypes.DataSourceParameters]?
        /// Password.
        /// This member is required.
        public var password: Swift.String?
        /// User name.
        /// This member is required.
        public var username: Swift.String?

        public init (
            alternateDataSourceParameters: [QuickSightClientTypes.DataSourceParameters]? = nil,
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.alternateDataSourceParameters = alternateDataSourceParameters
            self.password = password
            self.username = username
        }
    }

}

extension QuickSightClientTypes {
    public enum CrossDatasetTypes: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allDatasets
        case singleDataset
        case sdkUnknown(Swift.String)

        public static var allCases: [CrossDatasetTypes] {
            return [
                .allDatasets,
                .singleDataset,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allDatasets: return "ALL_DATASETS"
            case .singleDataset: return "SINGLE_DATASET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CrossDatasetTypes(rawValue: rawValue) ?? CrossDatasetTypes.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.CurrencyDisplayFormatConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decimalPlacesConfiguration = "DecimalPlacesConfiguration"
        case negativeValueConfiguration = "NegativeValueConfiguration"
        case nullValueFormatConfiguration = "NullValueFormatConfiguration"
        case numberScale = "NumberScale"
        case `prefix` = "Prefix"
        case separatorConfiguration = "SeparatorConfiguration"
        case suffix = "Suffix"
        case symbol = "Symbol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decimalPlacesConfiguration = self.decimalPlacesConfiguration {
            try encodeContainer.encode(decimalPlacesConfiguration, forKey: .decimalPlacesConfiguration)
        }
        if let negativeValueConfiguration = self.negativeValueConfiguration {
            try encodeContainer.encode(negativeValueConfiguration, forKey: .negativeValueConfiguration)
        }
        if let nullValueFormatConfiguration = self.nullValueFormatConfiguration {
            try encodeContainer.encode(nullValueFormatConfiguration, forKey: .nullValueFormatConfiguration)
        }
        if let numberScale = self.numberScale {
            try encodeContainer.encode(numberScale.rawValue, forKey: .numberScale)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
        if let separatorConfiguration = self.separatorConfiguration {
            try encodeContainer.encode(separatorConfiguration, forKey: .separatorConfiguration)
        }
        if let suffix = self.suffix {
            try encodeContainer.encode(suffix, forKey: .suffix)
        }
        if let symbol = self.symbol {
            try encodeContainer.encode(symbol, forKey: .symbol)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let suffixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suffix)
        suffix = suffixDecoded
        let separatorConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumericSeparatorConfiguration.self, forKey: .separatorConfiguration)
        separatorConfiguration = separatorConfigurationDecoded
        let symbolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .symbol)
        symbol = symbolDecoded
        let decimalPlacesConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DecimalPlacesConfiguration.self, forKey: .decimalPlacesConfiguration)
        decimalPlacesConfiguration = decimalPlacesConfigurationDecoded
        let numberScaleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumberScale.self, forKey: .numberScale)
        numberScale = numberScaleDecoded
        let negativeValueConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NegativeValueConfiguration.self, forKey: .negativeValueConfiguration)
        negativeValueConfiguration = negativeValueConfigurationDecoded
        let nullValueFormatConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NullValueFormatConfiguration.self, forKey: .nullValueFormatConfiguration)
        nullValueFormatConfiguration = nullValueFormatConfigurationDecoded
    }
}

extension QuickSightClientTypes.CurrencyDisplayFormatConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CurrencyDisplayFormatConfiguration(decimalPlacesConfiguration: \(Swift.String(describing: decimalPlacesConfiguration)), negativeValueConfiguration: \(Swift.String(describing: negativeValueConfiguration)), nullValueFormatConfiguration: \(Swift.String(describing: nullValueFormatConfiguration)), numberScale: \(Swift.String(describing: numberScale)), separatorConfiguration: \(Swift.String(describing: separatorConfiguration)), symbol: \(Swift.String(describing: symbol)), prefix: \"CONTENT_REDACTED\", suffix: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {
    /// The options that determine the currency display format configuration.
    public struct CurrencyDisplayFormatConfiguration: Swift.Equatable {
        /// The option that determines the decimal places configuration.
        public var decimalPlacesConfiguration: QuickSightClientTypes.DecimalPlacesConfiguration?
        /// The options that determine the negative value configuration.
        public var negativeValueConfiguration: QuickSightClientTypes.NegativeValueConfiguration?
        /// The options that determine the null value format configuration.
        public var nullValueFormatConfiguration: QuickSightClientTypes.NullValueFormatConfiguration?
        /// Determines the number scale value for the currency format.
        public var numberScale: QuickSightClientTypes.NumberScale?
        /// Determines the prefix value of the currency format.
        public var `prefix`: Swift.String?
        /// The options that determine the numeric separator configuration.
        public var separatorConfiguration: QuickSightClientTypes.NumericSeparatorConfiguration?
        /// Determines the suffix value of the currency format.
        public var suffix: Swift.String?
        /// Determines the symbol for the currency format.
        public var symbol: Swift.String?

        public init (
            decimalPlacesConfiguration: QuickSightClientTypes.DecimalPlacesConfiguration? = nil,
            negativeValueConfiguration: QuickSightClientTypes.NegativeValueConfiguration? = nil,
            nullValueFormatConfiguration: QuickSightClientTypes.NullValueFormatConfiguration? = nil,
            numberScale: QuickSightClientTypes.NumberScale? = nil,
            `prefix`: Swift.String? = nil,
            separatorConfiguration: QuickSightClientTypes.NumericSeparatorConfiguration? = nil,
            suffix: Swift.String? = nil,
            symbol: Swift.String? = nil
        )
        {
            self.decimalPlacesConfiguration = decimalPlacesConfiguration
            self.negativeValueConfiguration = negativeValueConfiguration
            self.nullValueFormatConfiguration = nullValueFormatConfiguration
            self.numberScale = numberScale
            self.`prefix` = `prefix`
            self.separatorConfiguration = separatorConfiguration
            self.suffix = suffix
            self.symbol = symbol
        }
    }

}

extension QuickSightClientTypes.CustomActionFilterOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case selectedFieldsConfiguration = "SelectedFieldsConfiguration"
        case targetVisualsConfiguration = "TargetVisualsConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let selectedFieldsConfiguration = self.selectedFieldsConfiguration {
            try encodeContainer.encode(selectedFieldsConfiguration, forKey: .selectedFieldsConfiguration)
        }
        if let targetVisualsConfiguration = self.targetVisualsConfiguration {
            try encodeContainer.encode(targetVisualsConfiguration, forKey: .targetVisualsConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectedFieldsConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterOperationSelectedFieldsConfiguration.self, forKey: .selectedFieldsConfiguration)
        selectedFieldsConfiguration = selectedFieldsConfigurationDecoded
        let targetVisualsConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterOperationTargetVisualsConfiguration.self, forKey: .targetVisualsConfiguration)
        targetVisualsConfiguration = targetVisualsConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The filter operation that filters data included in a visual or in an entire sheet.
    public struct CustomActionFilterOperation: Swift.Equatable {
        /// The configuration that chooses the fields to be filtered.
        /// This member is required.
        public var selectedFieldsConfiguration: QuickSightClientTypes.FilterOperationSelectedFieldsConfiguration?
        /// The configuration that chooses the target visuals to be filtered.
        /// This member is required.
        public var targetVisualsConfiguration: QuickSightClientTypes.FilterOperationTargetVisualsConfiguration?

        public init (
            selectedFieldsConfiguration: QuickSightClientTypes.FilterOperationSelectedFieldsConfiguration? = nil,
            targetVisualsConfiguration: QuickSightClientTypes.FilterOperationTargetVisualsConfiguration? = nil
        )
        {
            self.selectedFieldsConfiguration = selectedFieldsConfiguration
            self.targetVisualsConfiguration = targetVisualsConfiguration
        }
    }

}

extension QuickSightClientTypes.CustomActionNavigationOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case localNavigationConfiguration = "LocalNavigationConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let localNavigationConfiguration = self.localNavigationConfiguration {
            try encodeContainer.encode(localNavigationConfiguration, forKey: .localNavigationConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localNavigationConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LocalNavigationConfiguration.self, forKey: .localNavigationConfiguration)
        localNavigationConfiguration = localNavigationConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The navigation operation that navigates between different sheets in the same analysis. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct CustomActionNavigationOperation: Swift.Equatable {
        /// The configuration that chooses the navigation target.
        public var localNavigationConfiguration: QuickSightClientTypes.LocalNavigationConfiguration?

        public init (
            localNavigationConfiguration: QuickSightClientTypes.LocalNavigationConfiguration? = nil
        )
        {
            self.localNavigationConfiguration = localNavigationConfiguration
        }
    }

}

extension QuickSightClientTypes.CustomActionSetParametersOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterValueConfigurations = "ParameterValueConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterValueConfigurations = parameterValueConfigurations {
            var parameterValueConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterValueConfigurations)
            for setparametervalueconfiguration0 in parameterValueConfigurations {
                try parameterValueConfigurationsContainer.encode(setparametervalueconfiguration0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterValueConfigurationsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.SetParameterValueConfiguration?].self, forKey: .parameterValueConfigurations)
        var parameterValueConfigurationsDecoded0:[QuickSightClientTypes.SetParameterValueConfiguration]? = nil
        if let parameterValueConfigurationsContainer = parameterValueConfigurationsContainer {
            parameterValueConfigurationsDecoded0 = [QuickSightClientTypes.SetParameterValueConfiguration]()
            for structure0 in parameterValueConfigurationsContainer {
                if let structure0 = structure0 {
                    parameterValueConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        parameterValueConfigurations = parameterValueConfigurationsDecoded0
    }
}

extension QuickSightClientTypes {
    /// The set parameter operation that sets parameters in custom action.
    public struct CustomActionSetParametersOperation: Swift.Equatable {
        /// The parameter that determines the value configuration.
        /// This member is required.
        public var parameterValueConfigurations: [QuickSightClientTypes.SetParameterValueConfiguration]?

        public init (
            parameterValueConfigurations: [QuickSightClientTypes.SetParameterValueConfiguration]? = nil
        )
        {
            self.parameterValueConfigurations = parameterValueConfigurations
        }
    }

}

extension QuickSightClientTypes.CustomActionURLOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case urlTarget = "URLTarget"
        case urlTemplate = "URLTemplate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let urlTarget = self.urlTarget {
            try encodeContainer.encode(urlTarget.rawValue, forKey: .urlTarget)
        }
        if let urlTemplate = self.urlTemplate {
            try encodeContainer.encode(urlTemplate, forKey: .urlTemplate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .urlTemplate)
        urlTemplate = urlTemplateDecoded
        let urlTargetDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.URLTargetConfiguration.self, forKey: .urlTarget)
        urlTarget = urlTargetDecoded
    }
}

extension QuickSightClientTypes {
    /// The URL operation that opens a link to another webpage.
    public struct CustomActionURLOperation: Swift.Equatable {
        /// The target of the CustomActionURLOperation. Valid values are defined as follows:
        ///
        /// * NEW_TAB: Opens the target URL in a new browser tab.
        ///
        /// * NEW_WINDOW: Opens the target URL in a new browser window.
        ///
        /// * SAME_TAB: Opens the target URL in the same browser tab.
        /// This member is required.
        public var urlTarget: QuickSightClientTypes.URLTargetConfiguration?
        /// THe URL link of the CustomActionURLOperation.
        /// This member is required.
        public var urlTemplate: Swift.String?

        public init (
            urlTarget: QuickSightClientTypes.URLTargetConfiguration? = nil,
            urlTemplate: Swift.String? = nil
        )
        {
            self.urlTarget = urlTarget
            self.urlTemplate = urlTemplate
        }
    }

}

extension QuickSightClientTypes.CustomContentConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "ContentType"
        case contentUrl = "ContentUrl"
        case imageScaling = "ImageScaling"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType.rawValue, forKey: .contentType)
        }
        if let contentUrl = self.contentUrl {
            try encodeContainer.encode(contentUrl, forKey: .contentUrl)
        }
        if let imageScaling = self.imageScaling {
            try encodeContainer.encode(imageScaling.rawValue, forKey: .imageScaling)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentUrl)
        contentUrl = contentUrlDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CustomContentType.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let imageScalingDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CustomContentImageScalingConfiguration.self, forKey: .imageScaling)
        imageScaling = imageScalingDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of a CustomContentVisual.
    public struct CustomContentConfiguration: Swift.Equatable {
        /// The content type of the custom content visual. You can use this to have the visual render as an image.
        public var contentType: QuickSightClientTypes.CustomContentType?
        /// The input URL that links to the custom content that you want in the custom visual.
        public var contentUrl: Swift.String?
        /// The sizing options for the size of the custom content visual. This structure is required when the ContentType of the visual is 'IMAGE'.
        public var imageScaling: QuickSightClientTypes.CustomContentImageScalingConfiguration?

        public init (
            contentType: QuickSightClientTypes.CustomContentType? = nil,
            contentUrl: Swift.String? = nil,
            imageScaling: QuickSightClientTypes.CustomContentImageScalingConfiguration? = nil
        )
        {
            self.contentType = contentType
            self.contentUrl = contentUrl
            self.imageScaling = imageScaling
        }
    }

}

extension QuickSightClientTypes {
    public enum CustomContentImageScalingConfiguration: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case doNotScale
        case fitToHeight
        case fitToWidth
        case scaleToVisual
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomContentImageScalingConfiguration] {
            return [
                .doNotScale,
                .fitToHeight,
                .fitToWidth,
                .scaleToVisual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .doNotScale: return "DO_NOT_SCALE"
            case .fitToHeight: return "FIT_TO_HEIGHT"
            case .fitToWidth: return "FIT_TO_WIDTH"
            case .scaleToVisual: return "SCALE_TO_VISUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomContentImageScalingConfiguration(rawValue: rawValue) ?? CustomContentImageScalingConfiguration.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum CustomContentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case image
        case otherEmbeddedContent
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomContentType] {
            return [
                .image,
                .otherEmbeddedContent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .image: return "IMAGE"
            case .otherEmbeddedContent: return "OTHER_EMBEDDED_CONTENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomContentType(rawValue: rawValue) ?? CustomContentType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.CustomContentVisual: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case chartConfiguration = "ChartConfiguration"
        case dataSetIdentifier = "DataSetIdentifier"
        case subtitle = "Subtitle"
        case title = "Title"
        case visualId = "VisualId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for visualcustomaction0 in actions {
                try actionsContainer.encode(visualcustomaction0)
            }
        }
        if let chartConfiguration = self.chartConfiguration {
            try encodeContainer.encode(chartConfiguration, forKey: .chartConfiguration)
        }
        if let dataSetIdentifier = self.dataSetIdentifier {
            try encodeContainer.encode(dataSetIdentifier, forKey: .dataSetIdentifier)
        }
        if let subtitle = self.subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let visualId = self.visualId {
            try encodeContainer.encode(visualId, forKey: .visualId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visualIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visualId)
        visualId = visualIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualTitleLabelOptions.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualSubtitleLabelOptions.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let chartConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CustomContentConfiguration.self, forKey: .chartConfiguration)
        chartConfiguration = chartConfigurationDecoded
        let actionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.VisualCustomAction?].self, forKey: .actions)
        var actionsDecoded0:[QuickSightClientTypes.VisualCustomAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [QuickSightClientTypes.VisualCustomAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let dataSetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetIdentifier)
        dataSetIdentifier = dataSetIdentifierDecoded
    }
}

extension QuickSightClientTypes {
    /// A visual that contains custom content. For more information, see [Using custom visual content](https://docs.aws.amazon.com/quicksight/latest/user/custom-visual-content.html) in the Amazon QuickSight User Guide.
    public struct CustomContentVisual: Swift.Equatable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration of a CustomContentVisual.
        public var chartConfiguration: QuickSightClientTypes.CustomContentConfiguration?
        /// The dataset that is used to create the custom content visual. You can't create a visual without a dataset.
        /// This member is required.
        public var dataSetIdentifier: Swift.String?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init (
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.CustomContentConfiguration? = nil,
            dataSetIdentifier: Swift.String? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.dataSetIdentifier = dataSetIdentifier
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }

}

extension QuickSightClientTypes.CustomFilterConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryValue = "CategoryValue"
        case matchOperator = "MatchOperator"
        case nullOption = "NullOption"
        case parameterName = "ParameterName"
        case selectAllOptions = "SelectAllOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryValue = self.categoryValue {
            try encodeContainer.encode(categoryValue, forKey: .categoryValue)
        }
        if let matchOperator = self.matchOperator {
            try encodeContainer.encode(matchOperator.rawValue, forKey: .matchOperator)
        }
        if let nullOption = self.nullOption {
            try encodeContainer.encode(nullOption.rawValue, forKey: .nullOption)
        }
        if let parameterName = self.parameterName {
            try encodeContainer.encode(parameterName, forKey: .parameterName)
        }
        if let selectAllOptions = self.selectAllOptions {
            try encodeContainer.encode(selectAllOptions.rawValue, forKey: .selectAllOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchOperatorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CategoryFilterMatchOperator.self, forKey: .matchOperator)
        matchOperator = matchOperatorDecoded
        let categoryValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .categoryValue)
        categoryValue = categoryValueDecoded
        let selectAllOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CategoryFilterSelectAllOptions.self, forKey: .selectAllOptions)
        selectAllOptions = selectAllOptionsDecoded
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let nullOptionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterNullOption.self, forKey: .nullOption)
        nullOption = nullOptionDecoded
    }
}

extension QuickSightClientTypes {
    /// A custom filter that filters based on a single value. This filter can be partially matched.
    public struct CustomFilterConfiguration: Swift.Equatable {
        /// The category value for the filter. This field is mutually exclusive to ParameterName.
        public var categoryValue: Swift.String?
        /// The match operator that is used to determine if a filter should be applied.
        /// This member is required.
        public var matchOperator: QuickSightClientTypes.CategoryFilterMatchOperator?
        /// This option determines how null values should be treated when filtering data.
        ///
        /// * ALL_VALUES: Include null values in filtered results.
        ///
        /// * NULLS_ONLY: Only include null values in filtered results.
        ///
        /// * NON_NULLS_ONLY: Exclude null values from filtered results.
        /// This member is required.
        public var nullOption: QuickSightClientTypes.FilterNullOption?
        /// The parameter whose value should be used for the filter value. This field is mutually exclusive to CategoryValue.
        public var parameterName: Swift.String?
        /// Select all of the values. Null is not the assigned value of select all.
        ///
        /// * FILTER_ALL_VALUES
        public var selectAllOptions: QuickSightClientTypes.CategoryFilterSelectAllOptions?

        public init (
            categoryValue: Swift.String? = nil,
            matchOperator: QuickSightClientTypes.CategoryFilterMatchOperator? = nil,
            nullOption: QuickSightClientTypes.FilterNullOption? = nil,
            parameterName: Swift.String? = nil,
            selectAllOptions: QuickSightClientTypes.CategoryFilterSelectAllOptions? = nil
        )
        {
            self.categoryValue = categoryValue
            self.matchOperator = matchOperator
            self.nullOption = nullOption
            self.parameterName = parameterName
            self.selectAllOptions = selectAllOptions
        }
    }

}

extension QuickSightClientTypes.CustomFilterListConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryValues = "CategoryValues"
        case matchOperator = "MatchOperator"
        case nullOption = "NullOption"
        case selectAllOptions = "SelectAllOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryValues = categoryValues {
            var categoryValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categoryValues)
            for categoryvalue0 in categoryValues {
                try categoryValuesContainer.encode(categoryvalue0)
            }
        }
        if let matchOperator = self.matchOperator {
            try encodeContainer.encode(matchOperator.rawValue, forKey: .matchOperator)
        }
        if let nullOption = self.nullOption {
            try encodeContainer.encode(nullOption.rawValue, forKey: .nullOption)
        }
        if let selectAllOptions = self.selectAllOptions {
            try encodeContainer.encode(selectAllOptions.rawValue, forKey: .selectAllOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchOperatorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CategoryFilterMatchOperator.self, forKey: .matchOperator)
        matchOperator = matchOperatorDecoded
        let categoryValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .categoryValues)
        var categoryValuesDecoded0:[Swift.String]? = nil
        if let categoryValuesContainer = categoryValuesContainer {
            categoryValuesDecoded0 = [Swift.String]()
            for string0 in categoryValuesContainer {
                if let string0 = string0 {
                    categoryValuesDecoded0?.append(string0)
                }
            }
        }
        categoryValues = categoryValuesDecoded0
        let selectAllOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CategoryFilterSelectAllOptions.self, forKey: .selectAllOptions)
        selectAllOptions = selectAllOptionsDecoded
        let nullOptionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterNullOption.self, forKey: .nullOption)
        nullOption = nullOptionDecoded
    }
}

extension QuickSightClientTypes {
    /// A list of custom filter values.
    public struct CustomFilterListConfiguration: Swift.Equatable {
        /// The list of category values for the filter.
        public var categoryValues: [Swift.String]?
        /// The match operator that is used to determine if a filter should be applied.
        /// This member is required.
        public var matchOperator: QuickSightClientTypes.CategoryFilterMatchOperator?
        /// This option determines how null values should be treated when filtering data.
        ///
        /// * ALL_VALUES: Include null values in filtered results.
        ///
        /// * NULLS_ONLY: Only include null values in filtered results.
        ///
        /// * NON_NULLS_ONLY: Exclude null values from filtered results.
        /// This member is required.
        public var nullOption: QuickSightClientTypes.FilterNullOption?
        /// Select all of the values. Null is not the assigned value of select all.
        ///
        /// * FILTER_ALL_VALUES
        public var selectAllOptions: QuickSightClientTypes.CategoryFilterSelectAllOptions?

        public init (
            categoryValues: [Swift.String]? = nil,
            matchOperator: QuickSightClientTypes.CategoryFilterMatchOperator? = nil,
            nullOption: QuickSightClientTypes.FilterNullOption? = nil,
            selectAllOptions: QuickSightClientTypes.CategoryFilterSelectAllOptions? = nil
        )
        {
            self.categoryValues = categoryValues
            self.matchOperator = matchOperator
            self.nullOption = nullOption
            self.selectAllOptions = selectAllOptions
        }
    }

}

extension QuickSightClientTypes.CustomNarrativeOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case narrative = "Narrative"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let narrative = self.narrative {
            try encodeContainer.encode(narrative, forKey: .narrative)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let narrativeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .narrative)
        narrative = narrativeDecoded
    }
}

extension QuickSightClientTypes {
    /// The custom narrative options.
    public struct CustomNarrativeOptions: Swift.Equatable {
        /// The string input of custom narrative.
        /// This member is required.
        public var narrative: Swift.String?

        public init (
            narrative: Swift.String? = nil
        )
        {
            self.narrative = narrative
        }
    }

}

extension QuickSightClientTypes.CustomParameterValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateTimeValues = "DateTimeValues"
        case decimalValues = "DecimalValues"
        case integerValues = "IntegerValues"
        case stringValues = "StringValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateTimeValues = dateTimeValues {
            var dateTimeValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dateTimeValues)
            for sensitivetimestamp0 in dateTimeValues {
                try dateTimeValuesContainer.encodeTimestamp(sensitivetimestamp0, format: .epochSeconds)
            }
        }
        if let decimalValues = decimalValues {
            var decimalValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .decimalValues)
            for sensitivedoubleobject0 in decimalValues {
                try decimalValuesContainer.encode(sensitivedoubleobject0)
            }
        }
        if let integerValues = integerValues {
            var integerValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .integerValues)
            for sensitivelongobject0 in integerValues {
                try integerValuesContainer.encode(sensitivelongobject0)
            }
        }
        if let stringValues = stringValues {
            var stringValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stringValues)
            for sensitivestringobject0 in stringValues {
                try stringValuesContainer.encode(sensitivestringobject0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stringValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stringValues)
        var stringValuesDecoded0:[Swift.String]? = nil
        if let stringValuesContainer = stringValuesContainer {
            stringValuesDecoded0 = [Swift.String]()
            for string0 in stringValuesContainer {
                if let string0 = string0 {
                    stringValuesDecoded0?.append(string0)
                }
            }
        }
        stringValues = stringValuesDecoded0
        let integerValuesContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .integerValues)
        var integerValuesDecoded0:[Swift.Int]? = nil
        if let integerValuesContainer = integerValuesContainer {
            integerValuesDecoded0 = [Swift.Int]()
            for long0 in integerValuesContainer {
                if let long0 = long0 {
                    integerValuesDecoded0?.append(long0)
                }
            }
        }
        integerValues = integerValuesDecoded0
        let decimalValuesContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .decimalValues)
        var decimalValuesDecoded0:[Swift.Double]? = nil
        if let decimalValuesContainer = decimalValuesContainer {
            decimalValuesDecoded0 = [Swift.Double]()
            for double0 in decimalValuesContainer {
                if let double0 = double0 {
                    decimalValuesDecoded0?.append(double0)
                }
            }
        }
        decimalValues = decimalValuesDecoded0
        let dateTimeValuesContainer = try containerValues.decodeIfPresent([ClientRuntime.Date?].self, forKey: .dateTimeValues)
        var dateTimeValuesDecoded0:[ClientRuntime.Date]? = nil
        if let dateTimeValuesContainer = dateTimeValuesContainer {
            dateTimeValuesDecoded0 = [ClientRuntime.Date]()
            for timestamp0 in dateTimeValuesContainer {
                if let timestamp0 = timestamp0 {
                    dateTimeValuesDecoded0?.append(timestamp0)
                }
            }
        }
        dateTimeValues = dateTimeValuesDecoded0
    }
}

extension QuickSightClientTypes {
    /// The customized parameter values. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct CustomParameterValues: Swift.Equatable {
        /// A list of datetime-type parameter values.
        public var dateTimeValues: [ClientRuntime.Date]?
        /// A list of decimal-type parameter values.
        public var decimalValues: [Swift.Double]?
        /// A list of integer-type parameter values.
        public var integerValues: [Swift.Int]?
        /// A list of string-type parameter values.
        public var stringValues: [Swift.String]?

        public init (
            dateTimeValues: [ClientRuntime.Date]? = nil,
            decimalValues: [Swift.Double]? = nil,
            integerValues: [Swift.Int]? = nil,
            stringValues: [Swift.String]? = nil
        )
        {
            self.dateTimeValues = dateTimeValues
            self.decimalValues = decimalValues
            self.integerValues = integerValues
            self.stringValues = stringValues
        }
    }

}

extension QuickSightClientTypes.CustomSql: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columns = "Columns"
        case dataSourceArn = "DataSourceArn"
        case name = "Name"
        case sqlQuery = "SqlQuery"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for inputcolumn0 in columns {
                try columnsContainer.encode(inputcolumn0)
            }
        }
        if let dataSourceArn = self.dataSourceArn {
            try encodeContainer.encode(dataSourceArn, forKey: .dataSourceArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sqlQuery = self.sqlQuery {
            try encodeContainer.encode(sqlQuery, forKey: .sqlQuery)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceArn)
        dataSourceArn = dataSourceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sqlQueryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sqlQuery)
        sqlQuery = sqlQueryDecoded
        let columnsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.InputColumn?].self, forKey: .columns)
        var columnsDecoded0:[QuickSightClientTypes.InputColumn]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [QuickSightClientTypes.InputColumn]()
            for structure0 in columnsContainer {
                if let structure0 = structure0 {
                    columnsDecoded0?.append(structure0)
                }
            }
        }
        columns = columnsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A physical table type built from the results of the custom SQL query.
    public struct CustomSql: Swift.Equatable {
        /// The column schema from the SQL query result set.
        public var columns: [QuickSightClientTypes.InputColumn]?
        /// The Amazon Resource Name (ARN) of the data source.
        /// This member is required.
        public var dataSourceArn: Swift.String?
        /// A display name for the SQL query result.
        /// This member is required.
        public var name: Swift.String?
        /// The SQL query.
        /// This member is required.
        public var sqlQuery: Swift.String?

        public init (
            columns: [QuickSightClientTypes.InputColumn]? = nil,
            dataSourceArn: Swift.String? = nil,
            name: Swift.String? = nil,
            sqlQuery: Swift.String? = nil
        )
        {
            self.columns = columns
            self.dataSourceArn = dataSourceArn
            self.name = name
            self.sqlQuery = sqlQuery
        }
    }

}

extension QuickSightClientTypes.CustomValuesConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customValues = "CustomValues"
        case includeNullValue = "IncludeNullValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customValues = self.customValues {
            try encodeContainer.encode(customValues, forKey: .customValues)
        }
        if let includeNullValue = self.includeNullValue {
            try encodeContainer.encode(includeNullValue, forKey: .includeNullValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let includeNullValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeNullValue)
        includeNullValue = includeNullValueDecoded
        let customValuesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CustomParameterValues.self, forKey: .customValues)
        customValues = customValuesDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of custom values for the destination parameter in DestinationParameterValueConfiguration.
    public struct CustomValuesConfiguration: Swift.Equatable {
        /// The customized parameter values. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
        /// This member is required.
        public var customValues: QuickSightClientTypes.CustomParameterValues?
        /// Includes the null value in custom action parameter values.
        public var includeNullValue: Swift.Bool?

        public init (
            customValues: QuickSightClientTypes.CustomParameterValues? = nil,
            includeNullValue: Swift.Bool? = nil
        )
        {
            self.customValues = customValues
            self.includeNullValue = includeNullValue
        }
    }

}

extension QuickSightClientTypes.Dashboard: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case dashboardId = "DashboardId"
        case lastPublishedTime = "LastPublishedTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let dashboardId = self.dashboardId {
            try encodeContainer.encode(dashboardId, forKey: .dashboardId)
        }
        if let lastPublishedTime = self.lastPublishedTime {
            try encodeContainer.encodeTimestamp(lastPublishedTime, format: .epochSeconds, forKey: .lastPublishedTime)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardVersion.self, forKey: .version)
        version = versionDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastPublishedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastPublishedTime)
        lastPublishedTime = lastPublishedTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension QuickSightClientTypes {
    /// Dashboard.
    public struct Dashboard: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// The time that this dashboard was created.
        public var createdTime: ClientRuntime.Date?
        /// Dashboard ID.
        public var dashboardId: Swift.String?
        /// The last time that this dashboard was published.
        public var lastPublishedTime: ClientRuntime.Date?
        /// The last time that this dashboard was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// A display name for the dashboard.
        public var name: Swift.String?
        /// Version.
        public var version: QuickSightClientTypes.DashboardVersion?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            dashboardId: Swift.String? = nil,
            lastPublishedTime: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            version: QuickSightClientTypes.DashboardVersion? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.dashboardId = dashboardId
            self.lastPublishedTime = lastPublishedTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.version = version
        }
    }

}

extension QuickSightClientTypes {
    public enum DashboardBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DashboardBehavior] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DashboardBehavior(rawValue: rawValue) ?? DashboardBehavior.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.DashboardError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
        case violatedEntities = "ViolatedEntities"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let violatedEntities = violatedEntities {
            var violatedEntitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .violatedEntities)
            for entity0 in violatedEntities {
                try violatedEntitiesContainer.encode(entity0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let violatedEntitiesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Entity?].self, forKey: .violatedEntities)
        var violatedEntitiesDecoded0:[QuickSightClientTypes.Entity]? = nil
        if let violatedEntitiesContainer = violatedEntitiesContainer {
            violatedEntitiesDecoded0 = [QuickSightClientTypes.Entity]()
            for structure0 in violatedEntitiesContainer {
                if let structure0 = structure0 {
                    violatedEntitiesDecoded0?.append(structure0)
                }
            }
        }
        violatedEntities = violatedEntitiesDecoded0
    }
}

extension QuickSightClientTypes {
    /// Dashboard error.
    public struct DashboardError: Swift.Equatable {
        /// Message.
        public var message: Swift.String?
        /// Type.
        public var type: QuickSightClientTypes.DashboardErrorType?
        ///
        public var violatedEntities: [QuickSightClientTypes.Entity]?

        public init (
            message: Swift.String? = nil,
            type: QuickSightClientTypes.DashboardErrorType? = nil,
            violatedEntities: [QuickSightClientTypes.Entity]? = nil
        )
        {
            self.message = message
            self.type = type
            self.violatedEntities = violatedEntities
        }
    }

}

extension QuickSightClientTypes {
    public enum DashboardErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case columnGeographicRoleMismatch
        case columnReplacementMissing
        case columnTypeMismatch
        case dataSetNotFound
        case internalFailure
        case parameterNotFound
        case parameterTypeInvalid
        case parameterValueIncompatible
        case sourceNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [DashboardErrorType] {
            return [
                .accessDenied,
                .columnGeographicRoleMismatch,
                .columnReplacementMissing,
                .columnTypeMismatch,
                .dataSetNotFound,
                .internalFailure,
                .parameterNotFound,
                .parameterTypeInvalid,
                .parameterValueIncompatible,
                .sourceNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .columnGeographicRoleMismatch: return "COLUMN_GEOGRAPHIC_ROLE_MISMATCH"
            case .columnReplacementMissing: return "COLUMN_REPLACEMENT_MISSING"
            case .columnTypeMismatch: return "COLUMN_TYPE_MISMATCH"
            case .dataSetNotFound: return "DATA_SET_NOT_FOUND"
            case .internalFailure: return "INTERNAL_FAILURE"
            case .parameterNotFound: return "PARAMETER_NOT_FOUND"
            case .parameterTypeInvalid: return "PARAMETER_TYPE_INVALID"
            case .parameterValueIncompatible: return "PARAMETER_VALUE_INCOMPATIBLE"
            case .sourceNotFound: return "SOURCE_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DashboardErrorType(rawValue: rawValue) ?? DashboardErrorType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum DashboardFilterAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dashboardName
        case directQuicksightOwner
        case directQuicksightSoleOwner
        case directQuicksightViewerOrOwner
        case quicksightOwner
        case quicksightUser
        case quicksightViewerOrOwner
        case sdkUnknown(Swift.String)

        public static var allCases: [DashboardFilterAttribute] {
            return [
                .dashboardName,
                .directQuicksightOwner,
                .directQuicksightSoleOwner,
                .directQuicksightViewerOrOwner,
                .quicksightOwner,
                .quicksightUser,
                .quicksightViewerOrOwner,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dashboardName: return "DASHBOARD_NAME"
            case .directQuicksightOwner: return "DIRECT_QUICKSIGHT_OWNER"
            case .directQuicksightSoleOwner: return "DIRECT_QUICKSIGHT_SOLE_OWNER"
            case .directQuicksightViewerOrOwner: return "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
            case .quicksightOwner: return "QUICKSIGHT_OWNER"
            case .quicksightUser: return "QUICKSIGHT_USER"
            case .quicksightViewerOrOwner: return "QUICKSIGHT_VIEWER_OR_OWNER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DashboardFilterAttribute(rawValue: rawValue) ?? DashboardFilterAttribute.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.DashboardPublishOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adHocFilteringOption = "AdHocFilteringOption"
        case exportToCSVOption = "ExportToCSVOption"
        case sheetControlsOption = "SheetControlsOption"
        case visualPublishOptions = "VisualPublishOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adHocFilteringOption = self.adHocFilteringOption {
            try encodeContainer.encode(adHocFilteringOption, forKey: .adHocFilteringOption)
        }
        if let exportToCSVOption = self.exportToCSVOption {
            try encodeContainer.encode(exportToCSVOption, forKey: .exportToCSVOption)
        }
        if let sheetControlsOption = self.sheetControlsOption {
            try encodeContainer.encode(sheetControlsOption, forKey: .sheetControlsOption)
        }
        if let visualPublishOptions = self.visualPublishOptions {
            try encodeContainer.encode(visualPublishOptions, forKey: .visualPublishOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adHocFilteringOptionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AdHocFilteringOption.self, forKey: .adHocFilteringOption)
        adHocFilteringOption = adHocFilteringOptionDecoded
        let exportToCSVOptionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ExportToCSVOption.self, forKey: .exportToCSVOption)
        exportToCSVOption = exportToCSVOptionDecoded
        let sheetControlsOptionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SheetControlsOption.self, forKey: .sheetControlsOption)
        sheetControlsOption = sheetControlsOptionDecoded
        let visualPublishOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardVisualPublishOptions.self, forKey: .visualPublishOptions)
        visualPublishOptions = visualPublishOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// Dashboard publish options.
    public struct DashboardPublishOptions: Swift.Equatable {
        /// Ad hoc (one-time) filtering option.
        public var adHocFilteringOption: QuickSightClientTypes.AdHocFilteringOption?
        /// Export to .csv option.
        public var exportToCSVOption: QuickSightClientTypes.ExportToCSVOption?
        /// Sheet controls option.
        public var sheetControlsOption: QuickSightClientTypes.SheetControlsOption?
        ///
        public var visualPublishOptions: QuickSightClientTypes.DashboardVisualPublishOptions?

        public init (
            adHocFilteringOption: QuickSightClientTypes.AdHocFilteringOption? = nil,
            exportToCSVOption: QuickSightClientTypes.ExportToCSVOption? = nil,
            sheetControlsOption: QuickSightClientTypes.SheetControlsOption? = nil,
            visualPublishOptions: QuickSightClientTypes.DashboardVisualPublishOptions? = nil
        )
        {
            self.adHocFilteringOption = adHocFilteringOption
            self.exportToCSVOption = exportToCSVOption
            self.sheetControlsOption = sheetControlsOption
            self.visualPublishOptions = visualPublishOptions
        }
    }

}

extension QuickSightClientTypes.DashboardSearchFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case `operator` = "Operator"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let nameDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardFilterAttribute.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension QuickSightClientTypes {
    /// A filter that you apply when searching for dashboards.
    public struct DashboardSearchFilter: Swift.Equatable {
        /// The name of the value that you want to use as a filter, for example, "Name": "QUICKSIGHT_OWNER". Valid values are defined as follows:
        ///
        /// * QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the dashboards's owners or viewers are returned. Implicit permissions from folders or groups are considered.
        ///
        /// * QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the owners of the dashboards are returned. Implicit permissions from folders or groups are considered.
        ///
        /// * DIRECT_QUICKSIGHT_SOLE_OWNER: Provide an ARN of a user or group, and any dashboards with that ARN listed as the only owner of the dashboard are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DIRECT_QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the owners of the dashboards are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DIRECT_QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the owners or viewers of the dashboards are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DASHBOARD_NAME: Any dashboards whose names have a substring match to this value will be returned.
        public var name: QuickSightClientTypes.DashboardFilterAttribute?
        /// The comparison operator that you want to use as a filter, for example "Operator": "StringEquals". Valid values are "StringEquals" and "StringLike". If you set the operator value to "StringEquals", you need to provide an ownership related filter in the "NAME" field and the arn of the user or group whose folders you want to search in the "Value" field. For example, "Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1". If you set the value to "StringLike", you need to provide the name of the folders you are searching for. For example, "Name":"DASHBOARD_NAME", "Operator": "StringLike", "Value": "Test". The "StringLike" operator only supports the NAME value DASHBOARD_NAME.
        /// This member is required.
        public var `operator`: QuickSightClientTypes.FilterOperator?
        /// The value of the named item, in this case QUICKSIGHT_USER, that you want to use as a filter, for example, "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1".
        public var value: Swift.String?

        public init (
            name: QuickSightClientTypes.DashboardFilterAttribute? = nil,
            `operator`: QuickSightClientTypes.FilterOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }
    }

}

extension QuickSightClientTypes.DashboardSourceEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceTemplate = "SourceTemplate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceTemplate = self.sourceTemplate {
            try encodeContainer.encode(sourceTemplate, forKey: .sourceTemplate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTemplateDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardSourceTemplate.self, forKey: .sourceTemplate)
        sourceTemplate = sourceTemplateDecoded
    }
}

extension QuickSightClientTypes {
    /// Dashboard source entity.
    public struct DashboardSourceEntity: Swift.Equatable {
        /// Source template.
        public var sourceTemplate: QuickSightClientTypes.DashboardSourceTemplate?

        public init (
            sourceTemplate: QuickSightClientTypes.DashboardSourceTemplate? = nil
        )
        {
            self.sourceTemplate = sourceTemplate
        }
    }

}

extension QuickSightClientTypes.DashboardSourceTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case dataSetReferences = "DataSetReferences"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dataSetReferences = dataSetReferences {
            var dataSetReferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSetReferences)
            for datasetreference0 in dataSetReferences {
                try dataSetReferencesContainer.encode(datasetreference0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetReferencesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataSetReference?].self, forKey: .dataSetReferences)
        var dataSetReferencesDecoded0:[QuickSightClientTypes.DataSetReference]? = nil
        if let dataSetReferencesContainer = dataSetReferencesContainer {
            dataSetReferencesDecoded0 = [QuickSightClientTypes.DataSetReference]()
            for structure0 in dataSetReferencesContainer {
                if let structure0 = structure0 {
                    dataSetReferencesDecoded0?.append(structure0)
                }
            }
        }
        dataSetReferences = dataSetReferencesDecoded0
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension QuickSightClientTypes {
    /// Dashboard source template.
    public struct DashboardSourceTemplate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        /// This member is required.
        public var arn: Swift.String?
        /// Dataset references.
        /// This member is required.
        public var dataSetReferences: [QuickSightClientTypes.DataSetReference]?

        public init (
            arn: Swift.String? = nil,
            dataSetReferences: [QuickSightClientTypes.DataSetReference]? = nil
        )
        {
            self.arn = arn
            self.dataSetReferences = dataSetReferences
        }
    }

}

extension QuickSightClientTypes.DashboardSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case dashboardId = "DashboardId"
        case lastPublishedTime = "LastPublishedTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case publishedVersionNumber = "PublishedVersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let dashboardId = self.dashboardId {
            try encodeContainer.encode(dashboardId, forKey: .dashboardId)
        }
        if let lastPublishedTime = self.lastPublishedTime {
            try encodeContainer.encodeTimestamp(lastPublishedTime, format: .epochSeconds, forKey: .lastPublishedTime)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let publishedVersionNumber = self.publishedVersionNumber {
            try encodeContainer.encode(publishedVersionNumber, forKey: .publishedVersionNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let dashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let publishedVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .publishedVersionNumber)
        publishedVersionNumber = publishedVersionNumberDecoded
        let lastPublishedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastPublishedTime)
        lastPublishedTime = lastPublishedTimeDecoded
    }
}

extension QuickSightClientTypes {
    /// Dashboard summary.
    public struct DashboardSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// The time that this dashboard was created.
        public var createdTime: ClientRuntime.Date?
        /// Dashboard ID.
        public var dashboardId: Swift.String?
        /// The last time that this dashboard was published.
        public var lastPublishedTime: ClientRuntime.Date?
        /// The last time that this dashboard was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// A display name for the dashboard.
        public var name: Swift.String?
        /// Published version number.
        public var publishedVersionNumber: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            dashboardId: Swift.String? = nil,
            lastPublishedTime: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            publishedVersionNumber: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.dashboardId = dashboardId
            self.lastPublishedTime = lastPublishedTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.publishedVersionNumber = publishedVersionNumber
        }
    }

}

extension QuickSightClientTypes {
    public enum DashboardUIState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case collapsed
        case expanded
        case sdkUnknown(Swift.String)

        public static var allCases: [DashboardUIState] {
            return [
                .collapsed,
                .expanded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .collapsed: return "COLLAPSED"
            case .expanded: return "EXPANDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DashboardUIState(rawValue: rawValue) ?? DashboardUIState.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.DashboardVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case dataSetArns = "DataSetArns"
        case description = "Description"
        case errors = "Errors"
        case sheets = "Sheets"
        case sourceEntityArn = "SourceEntityArn"
        case status = "Status"
        case themeArn = "ThemeArn"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let dataSetArns = dataSetArns {
            var dataSetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSetArns)
            for arn0 in dataSetArns {
                try dataSetArnsContainer.encode(arn0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for dashboarderror0 in errors {
                try errorsContainer.encode(dashboarderror0)
            }
        }
        if let sheets = sheets {
            var sheetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sheets)
            for sheet0 in sheets {
                try sheetsContainer.encode(sheet0)
            }
        }
        if let sourceEntityArn = self.sourceEntityArn {
            try encodeContainer.encode(sourceEntityArn, forKey: .sourceEntityArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let themeArn = self.themeArn {
            try encodeContainer.encode(themeArn, forKey: .themeArn)
        }
        if let versionNumber = self.versionNumber {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let errorsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DashboardError?].self, forKey: .errors)
        var errorsDecoded0:[QuickSightClientTypes.DashboardError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [QuickSightClientTypes.DashboardError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let sourceEntityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceEntityArn)
        sourceEntityArn = sourceEntityArnDecoded
        let dataSetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dataSetArns)
        var dataSetArnsDecoded0:[Swift.String]? = nil
        if let dataSetArnsContainer = dataSetArnsContainer {
            dataSetArnsDecoded0 = [Swift.String]()
            for string0 in dataSetArnsContainer {
                if let string0 = string0 {
                    dataSetArnsDecoded0?.append(string0)
                }
            }
        }
        dataSetArns = dataSetArnsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
        let sheetsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Sheet?].self, forKey: .sheets)
        var sheetsDecoded0:[QuickSightClientTypes.Sheet]? = nil
        if let sheetsContainer = sheetsContainer {
            sheetsDecoded0 = [QuickSightClientTypes.Sheet]()
            for structure0 in sheetsContainer {
                if let structure0 = structure0 {
                    sheetsDecoded0?.append(structure0)
                }
            }
        }
        sheets = sheetsDecoded0
    }
}

extension QuickSightClientTypes {
    /// Dashboard version.
    public struct DashboardVersion: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// The time that this dashboard version was created.
        public var createdTime: ClientRuntime.Date?
        /// The Amazon Resource Numbers (ARNs) for the datasets that are associated with this version of the dashboard.
        public var dataSetArns: [Swift.String]?
        /// Description.
        public var description: Swift.String?
        /// Errors associated with this dashboard version.
        public var errors: [QuickSightClientTypes.DashboardError]?
        /// A list of the associated sheets with the unique identifier and name of each sheet.
        public var sheets: [QuickSightClientTypes.Sheet]?
        /// Source entity ARN.
        public var sourceEntityArn: Swift.String?
        /// The HTTP status of the request.
        public var status: QuickSightClientTypes.ResourceStatus?
        /// The ARN of the theme associated with a version of the dashboard.
        public var themeArn: Swift.String?
        /// Version number for this version of the dashboard.
        public var versionNumber: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            dataSetArns: [Swift.String]? = nil,
            description: Swift.String? = nil,
            errors: [QuickSightClientTypes.DashboardError]? = nil,
            sheets: [QuickSightClientTypes.Sheet]? = nil,
            sourceEntityArn: Swift.String? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil,
            themeArn: Swift.String? = nil,
            versionNumber: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.dataSetArns = dataSetArns
            self.description = description
            self.errors = errors
            self.sheets = sheets
            self.sourceEntityArn = sourceEntityArn
            self.status = status
            self.themeArn = themeArn
            self.versionNumber = versionNumber
        }
    }

}

extension QuickSightClientTypes.DashboardVersionDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisDefaults = "AnalysisDefaults"
        case calculatedFields = "CalculatedFields"
        case columnConfigurations = "ColumnConfigurations"
        case dataSetIdentifierDeclarations = "DataSetIdentifierDeclarations"
        case filterGroups = "FilterGroups"
        case parameterDeclarations = "ParameterDeclarations"
        case sheets = "Sheets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisDefaults = self.analysisDefaults {
            try encodeContainer.encode(analysisDefaults, forKey: .analysisDefaults)
        }
        if let calculatedFields = calculatedFields {
            var calculatedFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .calculatedFields)
            for calculatedfield0 in calculatedFields {
                try calculatedFieldsContainer.encode(calculatedfield0)
            }
        }
        if let columnConfigurations = columnConfigurations {
            var columnConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnConfigurations)
            for columnconfiguration0 in columnConfigurations {
                try columnConfigurationsContainer.encode(columnconfiguration0)
            }
        }
        if let dataSetIdentifierDeclarations = dataSetIdentifierDeclarations {
            var dataSetIdentifierDeclarationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSetIdentifierDeclarations)
            for datasetidentifierdeclaration0 in dataSetIdentifierDeclarations {
                try dataSetIdentifierDeclarationsContainer.encode(datasetidentifierdeclaration0)
            }
        }
        if let filterGroups = filterGroups {
            var filterGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterGroups)
            for filtergroup0 in filterGroups {
                try filterGroupsContainer.encode(filtergroup0)
            }
        }
        if let parameterDeclarations = parameterDeclarations {
            var parameterDeclarationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterDeclarations)
            for parameterdeclaration0 in parameterDeclarations {
                try parameterDeclarationsContainer.encode(parameterdeclaration0)
            }
        }
        if let sheets = sheets {
            var sheetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sheets)
            for sheetdefinition0 in sheets {
                try sheetsContainer.encode(sheetdefinition0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetIdentifierDeclarationsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataSetIdentifierDeclaration?].self, forKey: .dataSetIdentifierDeclarations)
        var dataSetIdentifierDeclarationsDecoded0:[QuickSightClientTypes.DataSetIdentifierDeclaration]? = nil
        if let dataSetIdentifierDeclarationsContainer = dataSetIdentifierDeclarationsContainer {
            dataSetIdentifierDeclarationsDecoded0 = [QuickSightClientTypes.DataSetIdentifierDeclaration]()
            for structure0 in dataSetIdentifierDeclarationsContainer {
                if let structure0 = structure0 {
                    dataSetIdentifierDeclarationsDecoded0?.append(structure0)
                }
            }
        }
        dataSetIdentifierDeclarations = dataSetIdentifierDeclarationsDecoded0
        let sheetsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.SheetDefinition?].self, forKey: .sheets)
        var sheetsDecoded0:[QuickSightClientTypes.SheetDefinition]? = nil
        if let sheetsContainer = sheetsContainer {
            sheetsDecoded0 = [QuickSightClientTypes.SheetDefinition]()
            for structure0 in sheetsContainer {
                if let structure0 = structure0 {
                    sheetsDecoded0?.append(structure0)
                }
            }
        }
        sheets = sheetsDecoded0
        let calculatedFieldsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.CalculatedField?].self, forKey: .calculatedFields)
        var calculatedFieldsDecoded0:[QuickSightClientTypes.CalculatedField]? = nil
        if let calculatedFieldsContainer = calculatedFieldsContainer {
            calculatedFieldsDecoded0 = [QuickSightClientTypes.CalculatedField]()
            for structure0 in calculatedFieldsContainer {
                if let structure0 = structure0 {
                    calculatedFieldsDecoded0?.append(structure0)
                }
            }
        }
        calculatedFields = calculatedFieldsDecoded0
        let parameterDeclarationsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ParameterDeclaration?].self, forKey: .parameterDeclarations)
        var parameterDeclarationsDecoded0:[QuickSightClientTypes.ParameterDeclaration]? = nil
        if let parameterDeclarationsContainer = parameterDeclarationsContainer {
            parameterDeclarationsDecoded0 = [QuickSightClientTypes.ParameterDeclaration]()
            for structure0 in parameterDeclarationsContainer {
                if let structure0 = structure0 {
                    parameterDeclarationsDecoded0?.append(structure0)
                }
            }
        }
        parameterDeclarations = parameterDeclarationsDecoded0
        let filterGroupsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FilterGroup?].self, forKey: .filterGroups)
        var filterGroupsDecoded0:[QuickSightClientTypes.FilterGroup]? = nil
        if let filterGroupsContainer = filterGroupsContainer {
            filterGroupsDecoded0 = [QuickSightClientTypes.FilterGroup]()
            for structure0 in filterGroupsContainer {
                if let structure0 = structure0 {
                    filterGroupsDecoded0?.append(structure0)
                }
            }
        }
        filterGroups = filterGroupsDecoded0
        let columnConfigurationsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnConfiguration?].self, forKey: .columnConfigurations)
        var columnConfigurationsDecoded0:[QuickSightClientTypes.ColumnConfiguration]? = nil
        if let columnConfigurationsContainer = columnConfigurationsContainer {
            columnConfigurationsDecoded0 = [QuickSightClientTypes.ColumnConfiguration]()
            for structure0 in columnConfigurationsContainer {
                if let structure0 = structure0 {
                    columnConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        columnConfigurations = columnConfigurationsDecoded0
        let analysisDefaultsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AnalysisDefaults.self, forKey: .analysisDefaults)
        analysisDefaults = analysisDefaultsDecoded
    }
}

extension QuickSightClientTypes {
    /// The contents of a dashboard.
    public struct DashboardVersionDefinition: Swift.Equatable {
        /// The configuration for default analysis settings.
        public var analysisDefaults: QuickSightClientTypes.AnalysisDefaults?
        /// An array of calculated field definitions for the dashboard.
        public var calculatedFields: [QuickSightClientTypes.CalculatedField]?
        /// An array of dashboard-level column configurations. Column configurations are used to set the default formatting for a column that is used throughout a dashboard.
        public var columnConfigurations: [QuickSightClientTypes.ColumnConfiguration]?
        /// An array of dataset identifier declarations. With this mapping,you can use dataset identifiers instead of dataset Amazon Resource Names (ARNs) throughout the dashboard's sub-structures.
        /// This member is required.
        public var dataSetIdentifierDeclarations: [QuickSightClientTypes.DataSetIdentifierDeclaration]?
        /// The filter definitions for a dashboard. For more information, see [Filtering Data in Amazon QuickSight](https://docs.aws.amazon.com/quicksight/latest/user/adding-a-filter.html) in the Amazon QuickSight User Guide.
        public var filterGroups: [QuickSightClientTypes.FilterGroup]?
        /// The parameter declarations for a dashboard. Parameters are named variables that can transfer a value for use by an action or an object. For more information, see [Parameters in Amazon QuickSight](https://docs.aws.amazon.com/quicksight/latest/user/parameters-in-quicksight.html) in the Amazon QuickSight User Guide.
        public var parameterDeclarations: [QuickSightClientTypes.ParameterDeclaration]?
        /// An array of sheet definitions for a dashboard.
        public var sheets: [QuickSightClientTypes.SheetDefinition]?

        public init (
            analysisDefaults: QuickSightClientTypes.AnalysisDefaults? = nil,
            calculatedFields: [QuickSightClientTypes.CalculatedField]? = nil,
            columnConfigurations: [QuickSightClientTypes.ColumnConfiguration]? = nil,
            dataSetIdentifierDeclarations: [QuickSightClientTypes.DataSetIdentifierDeclaration]? = nil,
            filterGroups: [QuickSightClientTypes.FilterGroup]? = nil,
            parameterDeclarations: [QuickSightClientTypes.ParameterDeclaration]? = nil,
            sheets: [QuickSightClientTypes.SheetDefinition]? = nil
        )
        {
            self.analysisDefaults = analysisDefaults
            self.calculatedFields = calculatedFields
            self.columnConfigurations = columnConfigurations
            self.dataSetIdentifierDeclarations = dataSetIdentifierDeclarations
            self.filterGroups = filterGroups
            self.parameterDeclarations = parameterDeclarations
            self.sheets = sheets
        }
    }

}

extension QuickSightClientTypes.DashboardVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case sourceEntityArn = "SourceEntityArn"
        case status = "Status"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let sourceEntityArn = self.sourceEntityArn {
            try encodeContainer.encode(sourceEntityArn, forKey: .sourceEntityArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let versionNumber = self.versionNumber {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let sourceEntityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceEntityArn)
        sourceEntityArn = sourceEntityArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension QuickSightClientTypes {
    /// Dashboard version summary.
    public struct DashboardVersionSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// The time that this dashboard version was created.
        public var createdTime: ClientRuntime.Date?
        /// Description.
        public var description: Swift.String?
        /// Source entity ARN.
        public var sourceEntityArn: Swift.String?
        /// The HTTP status of the request.
        public var status: QuickSightClientTypes.ResourceStatus?
        /// Version number.
        public var versionNumber: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            sourceEntityArn: Swift.String? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil,
            versionNumber: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.sourceEntityArn = sourceEntityArn
            self.status = status
            self.versionNumber = versionNumber
        }
    }

}

extension QuickSightClientTypes.DashboardVisualId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardId = "DashboardId"
        case sheetId = "SheetId"
        case visualId = "VisualId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dashboardId = self.dashboardId {
            try encodeContainer.encode(dashboardId, forKey: .dashboardId)
        }
        if let sheetId = self.sheetId {
            try encodeContainer.encode(sheetId, forKey: .sheetId)
        }
        if let visualId = self.visualId {
            try encodeContainer.encode(visualId, forKey: .visualId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let sheetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sheetId)
        sheetId = sheetIdDecoded
        let visualIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visualId)
        visualId = visualIdDecoded
    }
}

extension QuickSightClientTypes {
    /// A structure that contains the following elements:
    ///
    /// * The DashboardId of the dashboard that has the visual that you want to embed.
    ///
    /// * The SheetId of the sheet that has the visual that you want to embed.
    ///
    /// * The VisualId of the visual that you want to embed.
    ///
    ///
    /// The DashboardId, SheetId, and VisualId can be found in the IDs for developers section of the Embed visual pane of the visual's on-visual menu of the Amazon QuickSight console. You can also get the DashboardId with a ListDashboards API operation.
    public struct DashboardVisualId: Swift.Equatable {
        /// The ID of the dashboard that has the visual that you want to embed. The DashboardId can be found in the IDs for developers section of the Embed visual pane of the visual's on-visual menu of the Amazon QuickSight console. You can also get the DashboardId with a ListDashboards API operation.
        /// This member is required.
        public var dashboardId: Swift.String?
        /// The ID of the sheet that the has visual that you want to embed. The SheetId can be found in the IDs for developers section of the Embed visual pane of the visual's on-visual menu of the Amazon QuickSight console.
        /// This member is required.
        public var sheetId: Swift.String?
        /// The ID of the visual that you want to embed. The VisualID can be found in the IDs for developers section of the Embed visual pane of the visual's on-visual menu of the Amazon QuickSight console.
        /// This member is required.
        public var visualId: Swift.String?

        public init (
            dashboardId: Swift.String? = nil,
            sheetId: Swift.String? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.dashboardId = dashboardId
            self.sheetId = sheetId
            self.visualId = visualId
        }
    }

}

extension QuickSightClientTypes.DashboardVisualPublishOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportHiddenFieldsOption = "ExportHiddenFieldsOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportHiddenFieldsOption = self.exportHiddenFieldsOption {
            try encodeContainer.encode(exportHiddenFieldsOption, forKey: .exportHiddenFieldsOption)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportHiddenFieldsOptionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ExportHiddenFieldsOption.self, forKey: .exportHiddenFieldsOption)
        exportHiddenFieldsOption = exportHiddenFieldsOptionDecoded
    }
}

extension QuickSightClientTypes {
    ///
    public struct DashboardVisualPublishOptions: Swift.Equatable {
        ///
        public var exportHiddenFieldsOption: QuickSightClientTypes.ExportHiddenFieldsOption?

        public init (
            exportHiddenFieldsOption: QuickSightClientTypes.ExportHiddenFieldsOption? = nil
        )
        {
            self.exportHiddenFieldsOption = exportHiddenFieldsOption
        }
    }

}

extension QuickSightClientTypes.DataColor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case color = "Color"
        case dataValue = "DataValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let color = self.color {
            try encodeContainer.encode(color, forKey: .color)
        }
        if let dataValue = self.dataValue {
            try encodeContainer.encode(dataValue, forKey: .dataValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let colorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .color)
        color = colorDecoded
        let dataValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .dataValue)
        dataValue = dataValueDecoded
    }
}

extension QuickSightClientTypes {
    /// Determines the color that is applied to a particular data value.
    public struct DataColor: Swift.Equatable {
        /// The color that is applied to the data value.
        public var color: Swift.String?
        /// The data value that the color is applied to.
        public var dataValue: Swift.Double?

        public init (
            color: Swift.String? = nil,
            dataValue: Swift.Double? = nil
        )
        {
            self.color = color
            self.dataValue = dataValue
        }
    }

}

extension QuickSightClientTypes.DataColorPalette: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case colors = "Colors"
        case emptyFillColor = "EmptyFillColor"
        case minMaxGradient = "MinMaxGradient"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let colors = colors {
            var colorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .colors)
            for hexcolor0 in colors {
                try colorsContainer.encode(hexcolor0)
            }
        }
        if let emptyFillColor = self.emptyFillColor {
            try encodeContainer.encode(emptyFillColor, forKey: .emptyFillColor)
        }
        if let minMaxGradient = minMaxGradient {
            var minMaxGradientContainer = encodeContainer.nestedUnkeyedContainer(forKey: .minMaxGradient)
            for hexcolor0 in minMaxGradient {
                try minMaxGradientContainer.encode(hexcolor0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let colorsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .colors)
        var colorsDecoded0:[Swift.String]? = nil
        if let colorsContainer = colorsContainer {
            colorsDecoded0 = [Swift.String]()
            for string0 in colorsContainer {
                if let string0 = string0 {
                    colorsDecoded0?.append(string0)
                }
            }
        }
        colors = colorsDecoded0
        let minMaxGradientContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .minMaxGradient)
        var minMaxGradientDecoded0:[Swift.String]? = nil
        if let minMaxGradientContainer = minMaxGradientContainer {
            minMaxGradientDecoded0 = [Swift.String]()
            for string0 in minMaxGradientContainer {
                if let string0 = string0 {
                    minMaxGradientDecoded0?.append(string0)
                }
            }
        }
        minMaxGradient = minMaxGradientDecoded0
        let emptyFillColorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emptyFillColor)
        emptyFillColor = emptyFillColorDecoded
    }
}

extension QuickSightClientTypes {
    /// The theme colors that are used for data colors in charts. The colors description is a hexadecimal color code that consists of six alphanumerical characters, prefixed with #, for example #37BFF5.
    public struct DataColorPalette: Swift.Equatable {
        /// The hexadecimal codes for the colors.
        public var colors: [Swift.String]?
        /// The hexadecimal code of a color that applies to charts where a lack of data is highlighted.
        public var emptyFillColor: Swift.String?
        /// The minimum and maximum hexadecimal codes that describe a color gradient.
        public var minMaxGradient: [Swift.String]?

        public init (
            colors: [Swift.String]? = nil,
            emptyFillColor: Swift.String? = nil,
            minMaxGradient: [Swift.String]? = nil
        )
        {
            self.colors = colors
            self.emptyFillColor = emptyFillColor
            self.minMaxGradient = minMaxGradient
        }
    }

}

extension QuickSightClientTypes.DataFieldSeriesItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case axisBinding = "AxisBinding"
        case fieldId = "FieldId"
        case fieldValue = "FieldValue"
        case settings = "Settings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let axisBinding = self.axisBinding {
            try encodeContainer.encode(axisBinding.rawValue, forKey: .axisBinding)
        }
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
        if let fieldValue = self.fieldValue {
            try encodeContainer.encode(fieldValue, forKey: .fieldValue)
        }
        if let settings = self.settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let fieldValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldValue)
        fieldValue = fieldValueDecoded
        let axisBindingDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisBinding.self, forKey: .axisBinding)
        axisBinding = axisBindingDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LineChartSeriesSettings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

extension QuickSightClientTypes.DataFieldSeriesItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataFieldSeriesItem(axisBinding: \(Swift.String(describing: axisBinding)), fieldId: \(Swift.String(describing: fieldId)), settings: \(Swift.String(describing: settings)), fieldValue: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {
    /// The data field series item configuration of a line chart.
    public struct DataFieldSeriesItem: Swift.Equatable {
        /// The axis that you are binding the field to.
        /// This member is required.
        public var axisBinding: QuickSightClientTypes.AxisBinding?
        /// The field ID of the field that you are setting the axis binding to.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The field value of the field that you are setting the axis binding to.
        public var fieldValue: Swift.String?
        /// The options that determine the presentation of line series associated to the field.
        public var settings: QuickSightClientTypes.LineChartSeriesSettings?

        public init (
            axisBinding: QuickSightClientTypes.AxisBinding? = nil,
            fieldId: Swift.String? = nil,
            fieldValue: Swift.String? = nil,
            settings: QuickSightClientTypes.LineChartSeriesSettings? = nil
        )
        {
            self.axisBinding = axisBinding
            self.fieldId = fieldId
            self.fieldValue = fieldValue
            self.settings = settings
        }
    }

}

extension QuickSightClientTypes {
    public enum DataLabelContent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case percent
        case value
        case valueAndPercent
        case sdkUnknown(Swift.String)

        public static var allCases: [DataLabelContent] {
            return [
                .percent,
                .value,
                .valueAndPercent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .percent: return "PERCENT"
            case .value: return "VALUE"
            case .valueAndPercent: return "VALUE_AND_PERCENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataLabelContent(rawValue: rawValue) ?? DataLabelContent.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.DataLabelOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryLabelVisibility = "CategoryLabelVisibility"
        case dataLabelTypes = "DataLabelTypes"
        case labelColor = "LabelColor"
        case labelContent = "LabelContent"
        case labelFontConfiguration = "LabelFontConfiguration"
        case measureLabelVisibility = "MeasureLabelVisibility"
        case overlap = "Overlap"
        case position = "Position"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryLabelVisibility = self.categoryLabelVisibility {
            try encodeContainer.encode(categoryLabelVisibility.rawValue, forKey: .categoryLabelVisibility)
        }
        if let dataLabelTypes = dataLabelTypes {
            var dataLabelTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataLabelTypes)
            for datalabeltype0 in dataLabelTypes {
                try dataLabelTypesContainer.encode(datalabeltype0)
            }
        }
        if let labelColor = self.labelColor {
            try encodeContainer.encode(labelColor, forKey: .labelColor)
        }
        if let labelContent = self.labelContent {
            try encodeContainer.encode(labelContent.rawValue, forKey: .labelContent)
        }
        if let labelFontConfiguration = self.labelFontConfiguration {
            try encodeContainer.encode(labelFontConfiguration, forKey: .labelFontConfiguration)
        }
        if let measureLabelVisibility = self.measureLabelVisibility {
            try encodeContainer.encode(measureLabelVisibility.rawValue, forKey: .measureLabelVisibility)
        }
        if let overlap = self.overlap {
            try encodeContainer.encode(overlap.rawValue, forKey: .overlap)
        }
        if let position = self.position {
            try encodeContainer.encode(position.rawValue, forKey: .position)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
        let categoryLabelVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .categoryLabelVisibility)
        categoryLabelVisibility = categoryLabelVisibilityDecoded
        let measureLabelVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .measureLabelVisibility)
        measureLabelVisibility = measureLabelVisibilityDecoded
        let dataLabelTypesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataLabelType?].self, forKey: .dataLabelTypes)
        var dataLabelTypesDecoded0:[QuickSightClientTypes.DataLabelType]? = nil
        if let dataLabelTypesContainer = dataLabelTypesContainer {
            dataLabelTypesDecoded0 = [QuickSightClientTypes.DataLabelType]()
            for structure0 in dataLabelTypesContainer {
                if let structure0 = structure0 {
                    dataLabelTypesDecoded0?.append(structure0)
                }
            }
        }
        dataLabelTypes = dataLabelTypesDecoded0
        let positionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataLabelPosition.self, forKey: .position)
        position = positionDecoded
        let labelContentDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataLabelContent.self, forKey: .labelContent)
        labelContent = labelContentDecoded
        let labelFontConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FontConfiguration.self, forKey: .labelFontConfiguration)
        labelFontConfiguration = labelFontConfigurationDecoded
        let labelColorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .labelColor)
        labelColor = labelColorDecoded
        let overlapDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataLabelOverlap.self, forKey: .overlap)
        overlap = overlapDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the presentation of the data labels.
    public struct DataLabelOptions: Swift.Equatable {
        /// Determines the visibility of the category field labels.
        public var categoryLabelVisibility: QuickSightClientTypes.Visibility?
        /// The option that determines the data label type.
        public var dataLabelTypes: [QuickSightClientTypes.DataLabelType]?
        /// Determines the color of the data labels.
        public var labelColor: Swift.String?
        /// Determines the content of the data labels.
        public var labelContent: QuickSightClientTypes.DataLabelContent?
        /// Determines the font configuration of the data labels.
        public var labelFontConfiguration: QuickSightClientTypes.FontConfiguration?
        /// Determines the visibility of the measure field labels.
        public var measureLabelVisibility: QuickSightClientTypes.Visibility?
        /// Determines whether overlap is enabled or disabled for the data labels.
        public var overlap: QuickSightClientTypes.DataLabelOverlap?
        /// Determines the position of the data labels.
        public var position: QuickSightClientTypes.DataLabelPosition?
        /// Determines the visibility of the data labels.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            categoryLabelVisibility: QuickSightClientTypes.Visibility? = nil,
            dataLabelTypes: [QuickSightClientTypes.DataLabelType]? = nil,
            labelColor: Swift.String? = nil,
            labelContent: QuickSightClientTypes.DataLabelContent? = nil,
            labelFontConfiguration: QuickSightClientTypes.FontConfiguration? = nil,
            measureLabelVisibility: QuickSightClientTypes.Visibility? = nil,
            overlap: QuickSightClientTypes.DataLabelOverlap? = nil,
            position: QuickSightClientTypes.DataLabelPosition? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.categoryLabelVisibility = categoryLabelVisibility
            self.dataLabelTypes = dataLabelTypes
            self.labelColor = labelColor
            self.labelContent = labelContent
            self.labelFontConfiguration = labelFontConfiguration
            self.measureLabelVisibility = measureLabelVisibility
            self.overlap = overlap
            self.position = position
            self.visibility = visibility
        }
    }

}

extension QuickSightClientTypes {
    public enum DataLabelOverlap: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disableOverlap
        case enableOverlap
        case sdkUnknown(Swift.String)

        public static var allCases: [DataLabelOverlap] {
            return [
                .disableOverlap,
                .enableOverlap,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disableOverlap: return "DISABLE_OVERLAP"
            case .enableOverlap: return "ENABLE_OVERLAP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataLabelOverlap(rawValue: rawValue) ?? DataLabelOverlap.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum DataLabelPosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bottom
        case inside
        case `left`
        case outside
        case `right`
        case top
        case sdkUnknown(Swift.String)

        public static var allCases: [DataLabelPosition] {
            return [
                .bottom,
                .inside,
                .left,
                .outside,
                .right,
                .top,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bottom: return "BOTTOM"
            case .inside: return "INSIDE"
            case .left: return "LEFT"
            case .outside: return "OUTSIDE"
            case .right: return "RIGHT"
            case .top: return "TOP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataLabelPosition(rawValue: rawValue) ?? DataLabelPosition.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.DataLabelType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataPathLabelType = "DataPathLabelType"
        case fieldLabelType = "FieldLabelType"
        case maximumLabelType = "MaximumLabelType"
        case minimumLabelType = "MinimumLabelType"
        case rangeEndsLabelType = "RangeEndsLabelType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataPathLabelType = self.dataPathLabelType {
            try encodeContainer.encode(dataPathLabelType, forKey: .dataPathLabelType)
        }
        if let fieldLabelType = self.fieldLabelType {
            try encodeContainer.encode(fieldLabelType, forKey: .fieldLabelType)
        }
        if let maximumLabelType = self.maximumLabelType {
            try encodeContainer.encode(maximumLabelType, forKey: .maximumLabelType)
        }
        if let minimumLabelType = self.minimumLabelType {
            try encodeContainer.encode(minimumLabelType, forKey: .minimumLabelType)
        }
        if let rangeEndsLabelType = self.rangeEndsLabelType {
            try encodeContainer.encode(rangeEndsLabelType, forKey: .rangeEndsLabelType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLabelTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FieldLabelType.self, forKey: .fieldLabelType)
        fieldLabelType = fieldLabelTypeDecoded
        let dataPathLabelTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataPathLabelType.self, forKey: .dataPathLabelType)
        dataPathLabelType = dataPathLabelTypeDecoded
        let rangeEndsLabelTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RangeEndsLabelType.self, forKey: .rangeEndsLabelType)
        rangeEndsLabelType = rangeEndsLabelTypeDecoded
        let minimumLabelTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.MinimumLabelType.self, forKey: .minimumLabelType)
        minimumLabelType = minimumLabelTypeDecoded
        let maximumLabelTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.MaximumLabelType.self, forKey: .maximumLabelType)
        maximumLabelType = maximumLabelTypeDecoded
    }
}

extension QuickSightClientTypes {
    /// The option that determines the data label type. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct DataLabelType: Swift.Equatable {
        /// The option that specifies individual data values for labels.
        public var dataPathLabelType: QuickSightClientTypes.DataPathLabelType?
        /// Determines the label configuration for the entire field.
        public var fieldLabelType: QuickSightClientTypes.FieldLabelType?
        /// Determines the label configuration for the maximum value in a visual.
        public var maximumLabelType: QuickSightClientTypes.MaximumLabelType?
        /// Determines the label configuration for the minimum value in a visual.
        public var minimumLabelType: QuickSightClientTypes.MinimumLabelType?
        /// Determines the label configuration for range end value in a visual.
        public var rangeEndsLabelType: QuickSightClientTypes.RangeEndsLabelType?

        public init (
            dataPathLabelType: QuickSightClientTypes.DataPathLabelType? = nil,
            fieldLabelType: QuickSightClientTypes.FieldLabelType? = nil,
            maximumLabelType: QuickSightClientTypes.MaximumLabelType? = nil,
            minimumLabelType: QuickSightClientTypes.MinimumLabelType? = nil,
            rangeEndsLabelType: QuickSightClientTypes.RangeEndsLabelType? = nil
        )
        {
            self.dataPathLabelType = dataPathLabelType
            self.fieldLabelType = fieldLabelType
            self.maximumLabelType = maximumLabelType
            self.minimumLabelType = minimumLabelType
            self.rangeEndsLabelType = rangeEndsLabelType
        }
    }

}

extension QuickSightClientTypes.DataPathColor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case color = "Color"
        case element = "Element"
        case timeGranularity = "TimeGranularity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let color = self.color {
            try encodeContainer.encode(color, forKey: .color)
        }
        if let element = self.element {
            try encodeContainer.encode(element, forKey: .element)
        }
        if let timeGranularity = self.timeGranularity {
            try encodeContainer.encode(timeGranularity.rawValue, forKey: .timeGranularity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elementDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataPathValue.self, forKey: .element)
        element = elementDecoded
        let colorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .color)
        color = colorDecoded
        let timeGranularityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TimeGranularity.self, forKey: .timeGranularity)
        timeGranularity = timeGranularityDecoded
    }
}

extension QuickSightClientTypes {
    /// The color map that determines the color options for a particular element.
    public struct DataPathColor: Swift.Equatable {
        /// The color that needs to be applied to the element.
        /// This member is required.
        public var color: Swift.String?
        /// The element that the color needs to be applied to.
        /// This member is required.
        public var element: QuickSightClientTypes.DataPathValue?
        /// The time granularity of the field that the color needs to be applied to.
        public var timeGranularity: QuickSightClientTypes.TimeGranularity?

        public init (
            color: Swift.String? = nil,
            element: QuickSightClientTypes.DataPathValue? = nil,
            timeGranularity: QuickSightClientTypes.TimeGranularity? = nil
        )
        {
            self.color = color
            self.element = element
            self.timeGranularity = timeGranularity
        }
    }

}

extension QuickSightClientTypes.DataPathLabelType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldId = "FieldId"
        case fieldValue = "FieldValue"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
        if let fieldValue = self.fieldValue {
            try encodeContainer.encode(fieldValue, forKey: .fieldValue)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let fieldValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldValue)
        fieldValue = fieldValueDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension QuickSightClientTypes.DataPathLabelType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataPathLabelType(fieldId: \(Swift.String(describing: fieldId)), visibility: \(Swift.String(describing: visibility)), fieldValue: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {
    /// The option that specifies individual data values for labels.
    public struct DataPathLabelType: Swift.Equatable {
        /// The field ID of the field that the data label needs to be applied to.
        public var fieldId: Swift.String?
        /// The actual value of the field that is labeled.
        public var fieldValue: Swift.String?
        /// The visibility of the data label.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            fieldId: Swift.String? = nil,
            fieldValue: Swift.String? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.fieldId = fieldId
            self.fieldValue = fieldValue
            self.visibility = visibility
        }
    }

}

extension QuickSightClientTypes.DataPathSort: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case direction = "Direction"
        case sortPaths = "SortPaths"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let direction = self.direction {
            try encodeContainer.encode(direction.rawValue, forKey: .direction)
        }
        if let sortPaths = sortPaths {
            var sortPathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortPaths)
            for datapathvalue0 in sortPaths {
                try sortPathsContainer.encode(datapathvalue0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SortDirection.self, forKey: .direction)
        direction = directionDecoded
        let sortPathsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataPathValue?].self, forKey: .sortPaths)
        var sortPathsDecoded0:[QuickSightClientTypes.DataPathValue]? = nil
        if let sortPathsContainer = sortPathsContainer {
            sortPathsDecoded0 = [QuickSightClientTypes.DataPathValue]()
            for structure0 in sortPathsContainer {
                if let structure0 = structure0 {
                    sortPathsDecoded0?.append(structure0)
                }
            }
        }
        sortPaths = sortPathsDecoded0
    }
}

extension QuickSightClientTypes {
    /// Allows data paths to be sorted by a specific data value.
    public struct DataPathSort: Swift.Equatable {
        /// Determines the sort direction.
        /// This member is required.
        public var direction: QuickSightClientTypes.SortDirection?
        /// The list of data paths that need to be sorted.
        /// This member is required.
        public var sortPaths: [QuickSightClientTypes.DataPathValue]?

        public init (
            direction: QuickSightClientTypes.SortDirection? = nil,
            sortPaths: [QuickSightClientTypes.DataPathValue]? = nil
        )
        {
            self.direction = direction
            self.sortPaths = sortPaths
        }
    }

}

extension QuickSightClientTypes.DataPathValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldId = "FieldId"
        case fieldValue = "FieldValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
        if let fieldValue = self.fieldValue {
            try encodeContainer.encode(fieldValue, forKey: .fieldValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let fieldValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldValue)
        fieldValue = fieldValueDecoded
    }
}

extension QuickSightClientTypes.DataPathValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataPathValue(fieldId: \(Swift.String(describing: fieldId)), fieldValue: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {
    /// The data path that needs to be sorted.
    public struct DataPathValue: Swift.Equatable {
        /// The field ID of the field that needs to be sorted.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The actual value of the field that needs to be sorted.
        /// This member is required.
        public var fieldValue: Swift.String?

        public init (
            fieldId: Swift.String? = nil,
            fieldValue: Swift.String? = nil
        )
        {
            self.fieldId = fieldId
            self.fieldValue = fieldValue
        }
    }

}

extension QuickSightClientTypes.DataSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case columnGroups = "ColumnGroups"
        case columnLevelPermissionRules = "ColumnLevelPermissionRules"
        case consumedSpiceCapacityInBytes = "ConsumedSpiceCapacityInBytes"
        case createdTime = "CreatedTime"
        case dataSetId = "DataSetId"
        case dataSetUsageConfiguration = "DataSetUsageConfiguration"
        case fieldFolders = "FieldFolders"
        case importMode = "ImportMode"
        case lastUpdatedTime = "LastUpdatedTime"
        case logicalTableMap = "LogicalTableMap"
        case name = "Name"
        case outputColumns = "OutputColumns"
        case physicalTableMap = "PhysicalTableMap"
        case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
        case rowLevelPermissionTagConfiguration = "RowLevelPermissionTagConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let columnGroups = columnGroups {
            var columnGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnGroups)
            for columngroup0 in columnGroups {
                try columnGroupsContainer.encode(columngroup0)
            }
        }
        if let columnLevelPermissionRules = columnLevelPermissionRules {
            var columnLevelPermissionRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnLevelPermissionRules)
            for columnlevelpermissionrule0 in columnLevelPermissionRules {
                try columnLevelPermissionRulesContainer.encode(columnlevelpermissionrule0)
            }
        }
        if consumedSpiceCapacityInBytes != 0 {
            try encodeContainer.encode(consumedSpiceCapacityInBytes, forKey: .consumedSpiceCapacityInBytes)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let dataSetUsageConfiguration = self.dataSetUsageConfiguration {
            try encodeContainer.encode(dataSetUsageConfiguration, forKey: .dataSetUsageConfiguration)
        }
        if let fieldFolders = fieldFolders {
            var fieldFoldersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .fieldFolders)
            for (dictKey0, fieldFolderMap0) in fieldFolders {
                try fieldFoldersContainer.encode(fieldFolderMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let importMode = self.importMode {
            try encodeContainer.encode(importMode.rawValue, forKey: .importMode)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let logicalTableMap = logicalTableMap {
            var logicalTableMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .logicalTableMap)
            for (dictKey0, logicalTableMap0) in logicalTableMap {
                try logicalTableMapContainer.encode(logicalTableMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputColumns = outputColumns {
            var outputColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputColumns)
            for outputcolumn0 in outputColumns {
                try outputColumnsContainer.encode(outputcolumn0)
            }
        }
        if let physicalTableMap = physicalTableMap {
            var physicalTableMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .physicalTableMap)
            for (dictKey0, physicalTableMap0) in physicalTableMap {
                try physicalTableMapContainer.encode(physicalTableMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let rowLevelPermissionDataSet = self.rowLevelPermissionDataSet {
            try encodeContainer.encode(rowLevelPermissionDataSet, forKey: .rowLevelPermissionDataSet)
        }
        if let rowLevelPermissionTagConfiguration = self.rowLevelPermissionTagConfiguration {
            try encodeContainer.encode(rowLevelPermissionTagConfiguration, forKey: .rowLevelPermissionTagConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let physicalTableMapContainer = try containerValues.decodeIfPresent([Swift.String: QuickSightClientTypes.PhysicalTable?].self, forKey: .physicalTableMap)
        var physicalTableMapDecoded0: [Swift.String:QuickSightClientTypes.PhysicalTable]? = nil
        if let physicalTableMapContainer = physicalTableMapContainer {
            physicalTableMapDecoded0 = [Swift.String:QuickSightClientTypes.PhysicalTable]()
            for (key0, physicaltable0) in physicalTableMapContainer {
                if let physicaltable0 = physicaltable0 {
                    physicalTableMapDecoded0?[key0] = physicaltable0
                }
            }
        }
        physicalTableMap = physicalTableMapDecoded0
        let logicalTableMapContainer = try containerValues.decodeIfPresent([Swift.String: QuickSightClientTypes.LogicalTable?].self, forKey: .logicalTableMap)
        var logicalTableMapDecoded0: [Swift.String:QuickSightClientTypes.LogicalTable]? = nil
        if let logicalTableMapContainer = logicalTableMapContainer {
            logicalTableMapDecoded0 = [Swift.String:QuickSightClientTypes.LogicalTable]()
            for (key0, logicaltable0) in logicalTableMapContainer {
                if let logicaltable0 = logicaltable0 {
                    logicalTableMapDecoded0?[key0] = logicaltable0
                }
            }
        }
        logicalTableMap = logicalTableMapDecoded0
        let outputColumnsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.OutputColumn?].self, forKey: .outputColumns)
        var outputColumnsDecoded0:[QuickSightClientTypes.OutputColumn]? = nil
        if let outputColumnsContainer = outputColumnsContainer {
            outputColumnsDecoded0 = [QuickSightClientTypes.OutputColumn]()
            for structure0 in outputColumnsContainer {
                if let structure0 = structure0 {
                    outputColumnsDecoded0?.append(structure0)
                }
            }
        }
        outputColumns = outputColumnsDecoded0
        let importModeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSetImportMode.self, forKey: .importMode)
        importMode = importModeDecoded
        let consumedSpiceCapacityInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .consumedSpiceCapacityInBytes) ?? 0
        consumedSpiceCapacityInBytes = consumedSpiceCapacityInBytesDecoded
        let columnGroupsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnGroup?].self, forKey: .columnGroups)
        var columnGroupsDecoded0:[QuickSightClientTypes.ColumnGroup]? = nil
        if let columnGroupsContainer = columnGroupsContainer {
            columnGroupsDecoded0 = [QuickSightClientTypes.ColumnGroup]()
            for structure0 in columnGroupsContainer {
                if let structure0 = structure0 {
                    columnGroupsDecoded0?.append(structure0)
                }
            }
        }
        columnGroups = columnGroupsDecoded0
        let fieldFoldersContainer = try containerValues.decodeIfPresent([Swift.String: QuickSightClientTypes.FieldFolder?].self, forKey: .fieldFolders)
        var fieldFoldersDecoded0: [Swift.String:QuickSightClientTypes.FieldFolder]? = nil
        if let fieldFoldersContainer = fieldFoldersContainer {
            fieldFoldersDecoded0 = [Swift.String:QuickSightClientTypes.FieldFolder]()
            for (key0, fieldfolder0) in fieldFoldersContainer {
                if let fieldfolder0 = fieldfolder0 {
                    fieldFoldersDecoded0?[key0] = fieldfolder0
                }
            }
        }
        fieldFolders = fieldFoldersDecoded0
        let rowLevelPermissionDataSetDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RowLevelPermissionDataSet.self, forKey: .rowLevelPermissionDataSet)
        rowLevelPermissionDataSet = rowLevelPermissionDataSetDecoded
        let rowLevelPermissionTagConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RowLevelPermissionTagConfiguration.self, forKey: .rowLevelPermissionTagConfiguration)
        rowLevelPermissionTagConfiguration = rowLevelPermissionTagConfigurationDecoded
        let columnLevelPermissionRulesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnLevelPermissionRule?].self, forKey: .columnLevelPermissionRules)
        var columnLevelPermissionRulesDecoded0:[QuickSightClientTypes.ColumnLevelPermissionRule]? = nil
        if let columnLevelPermissionRulesContainer = columnLevelPermissionRulesContainer {
            columnLevelPermissionRulesDecoded0 = [QuickSightClientTypes.ColumnLevelPermissionRule]()
            for structure0 in columnLevelPermissionRulesContainer {
                if let structure0 = structure0 {
                    columnLevelPermissionRulesDecoded0?.append(structure0)
                }
            }
        }
        columnLevelPermissionRules = columnLevelPermissionRulesDecoded0
        let dataSetUsageConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSetUsageConfiguration.self, forKey: .dataSetUsageConfiguration)
        dataSetUsageConfiguration = dataSetUsageConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// Dataset.
    public struct DataSet: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// Groupings of columns that work together in certain Amazon QuickSight features. Currently, only geospatial hierarchy is supported.
        public var columnGroups: [QuickSightClientTypes.ColumnGroup]?
        /// A set of one or more definitions of a [ColumnLevelPermissionRule](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ColumnLevelPermissionRule.html).
        public var columnLevelPermissionRules: [QuickSightClientTypes.ColumnLevelPermissionRule]?
        /// The amount of SPICE capacity used by this dataset. This is 0 if the dataset isn't imported into SPICE.
        public var consumedSpiceCapacityInBytes: Swift.Int
        /// The time that this dataset was created.
        public var createdTime: ClientRuntime.Date?
        /// The ID of the dataset.
        public var dataSetId: Swift.String?
        /// The usage configuration to apply to child datasets that reference this dataset as a source.
        public var dataSetUsageConfiguration: QuickSightClientTypes.DataSetUsageConfiguration?
        /// The folder that contains fields and nested subfolders for your dataset.
        public var fieldFolders: [Swift.String:QuickSightClientTypes.FieldFolder]?
        /// A value that indicates whether you want to import the data into SPICE.
        public var importMode: QuickSightClientTypes.DataSetImportMode?
        /// The last time that this dataset was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// Configures the combination and transformation of the data from the physical tables.
        public var logicalTableMap: [Swift.String:QuickSightClientTypes.LogicalTable]?
        /// A display name for the dataset.
        public var name: Swift.String?
        /// The list of columns after all transforms. These columns are available in templates, analyses, and dashboards.
        public var outputColumns: [QuickSightClientTypes.OutputColumn]?
        /// Declares the physical tables that are available in the underlying data sources.
        public var physicalTableMap: [Swift.String:QuickSightClientTypes.PhysicalTable]?
        /// The row-level security configuration for the dataset.
        public var rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet?
        /// The element you can use to define tags for row-level security.
        public var rowLevelPermissionTagConfiguration: QuickSightClientTypes.RowLevelPermissionTagConfiguration?

        public init (
            arn: Swift.String? = nil,
            columnGroups: [QuickSightClientTypes.ColumnGroup]? = nil,
            columnLevelPermissionRules: [QuickSightClientTypes.ColumnLevelPermissionRule]? = nil,
            consumedSpiceCapacityInBytes: Swift.Int = 0,
            createdTime: ClientRuntime.Date? = nil,
            dataSetId: Swift.String? = nil,
            dataSetUsageConfiguration: QuickSightClientTypes.DataSetUsageConfiguration? = nil,
            fieldFolders: [Swift.String:QuickSightClientTypes.FieldFolder]? = nil,
            importMode: QuickSightClientTypes.DataSetImportMode? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            logicalTableMap: [Swift.String:QuickSightClientTypes.LogicalTable]? = nil,
            name: Swift.String? = nil,
            outputColumns: [QuickSightClientTypes.OutputColumn]? = nil,
            physicalTableMap: [Swift.String:QuickSightClientTypes.PhysicalTable]? = nil,
            rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet? = nil,
            rowLevelPermissionTagConfiguration: QuickSightClientTypes.RowLevelPermissionTagConfiguration? = nil
        )
        {
            self.arn = arn
            self.columnGroups = columnGroups
            self.columnLevelPermissionRules = columnLevelPermissionRules
            self.consumedSpiceCapacityInBytes = consumedSpiceCapacityInBytes
            self.createdTime = createdTime
            self.dataSetId = dataSetId
            self.dataSetUsageConfiguration = dataSetUsageConfiguration
            self.fieldFolders = fieldFolders
            self.importMode = importMode
            self.lastUpdatedTime = lastUpdatedTime
            self.logicalTableMap = logicalTableMap
            self.name = name
            self.outputColumns = outputColumns
            self.physicalTableMap = physicalTableMap
            self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
            self.rowLevelPermissionTagConfiguration = rowLevelPermissionTagConfiguration
        }
    }

}

extension QuickSightClientTypes.DataSetConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnGroupSchemaList = "ColumnGroupSchemaList"
        case dataSetSchema = "DataSetSchema"
        case placeholder = "Placeholder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnGroupSchemaList = columnGroupSchemaList {
            var columnGroupSchemaListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnGroupSchemaList)
            for columngroupschema0 in columnGroupSchemaList {
                try columnGroupSchemaListContainer.encode(columngroupschema0)
            }
        }
        if let dataSetSchema = self.dataSetSchema {
            try encodeContainer.encode(dataSetSchema, forKey: .dataSetSchema)
        }
        if let placeholder = self.placeholder {
            try encodeContainer.encode(placeholder, forKey: .placeholder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let placeholderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .placeholder)
        placeholder = placeholderDecoded
        let dataSetSchemaDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSetSchema.self, forKey: .dataSetSchema)
        dataSetSchema = dataSetSchemaDecoded
        let columnGroupSchemaListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnGroupSchema?].self, forKey: .columnGroupSchemaList)
        var columnGroupSchemaListDecoded0:[QuickSightClientTypes.ColumnGroupSchema]? = nil
        if let columnGroupSchemaListContainer = columnGroupSchemaListContainer {
            columnGroupSchemaListDecoded0 = [QuickSightClientTypes.ColumnGroupSchema]()
            for structure0 in columnGroupSchemaListContainer {
                if let structure0 = structure0 {
                    columnGroupSchemaListDecoded0?.append(structure0)
                }
            }
        }
        columnGroupSchemaList = columnGroupSchemaListDecoded0
    }
}

extension QuickSightClientTypes {
    /// Dataset configuration.
    public struct DataSetConfiguration: Swift.Equatable {
        /// A structure containing the list of column group schemas.
        public var columnGroupSchemaList: [QuickSightClientTypes.ColumnGroupSchema]?
        /// Dataset schema.
        public var dataSetSchema: QuickSightClientTypes.DataSetSchema?
        /// Placeholder.
        public var placeholder: Swift.String?

        public init (
            columnGroupSchemaList: [QuickSightClientTypes.ColumnGroupSchema]? = nil,
            dataSetSchema: QuickSightClientTypes.DataSetSchema? = nil,
            placeholder: Swift.String? = nil
        )
        {
            self.columnGroupSchemaList = columnGroupSchemaList
            self.dataSetSchema = dataSetSchema
            self.placeholder = placeholder
        }
    }

}

extension QuickSightClientTypes {
    public enum DataSetFilterAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case datasetName
        case directQuicksightOwner
        case directQuicksightSoleOwner
        case directQuicksightViewerOrOwner
        case quicksightOwner
        case quicksightViewerOrOwner
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSetFilterAttribute] {
            return [
                .datasetName,
                .directQuicksightOwner,
                .directQuicksightSoleOwner,
                .directQuicksightViewerOrOwner,
                .quicksightOwner,
                .quicksightViewerOrOwner,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .datasetName: return "DATASET_NAME"
            case .directQuicksightOwner: return "DIRECT_QUICKSIGHT_OWNER"
            case .directQuicksightSoleOwner: return "DIRECT_QUICKSIGHT_SOLE_OWNER"
            case .directQuicksightViewerOrOwner: return "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
            case .quicksightOwner: return "QUICKSIGHT_OWNER"
            case .quicksightViewerOrOwner: return "QUICKSIGHT_VIEWER_OR_OWNER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSetFilterAttribute(rawValue: rawValue) ?? DataSetFilterAttribute.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.DataSetIdentifierDeclaration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetArn = "DataSetArn"
        case identifier = "Identifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSetArn = self.dataSetArn {
            try encodeContainer.encode(dataSetArn, forKey: .dataSetArn)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let dataSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetArn)
        dataSetArn = dataSetArnDecoded
    }
}

extension QuickSightClientTypes {
    /// A data set.
    public struct DataSetIdentifierDeclaration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the data set.
        /// This member is required.
        public var dataSetArn: Swift.String?
        /// The identifier of the data set, typically the data set's name.
        /// This member is required.
        public var identifier: Swift.String?

        public init (
            dataSetArn: Swift.String? = nil,
            identifier: Swift.String? = nil
        )
        {
            self.dataSetArn = dataSetArn
            self.identifier = identifier
        }
    }

}

extension QuickSightClientTypes {
    public enum DataSetImportMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case directQuery
        case spice
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSetImportMode] {
            return [
                .directQuery,
                .spice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .directQuery: return "DIRECT_QUERY"
            case .spice: return "SPICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSetImportMode(rawValue: rawValue) ?? DataSetImportMode.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.DataSetReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetArn = "DataSetArn"
        case dataSetPlaceholder = "DataSetPlaceholder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSetArn = self.dataSetArn {
            try encodeContainer.encode(dataSetArn, forKey: .dataSetArn)
        }
        if let dataSetPlaceholder = self.dataSetPlaceholder {
            try encodeContainer.encode(dataSetPlaceholder, forKey: .dataSetPlaceholder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetPlaceholderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetPlaceholder)
        dataSetPlaceholder = dataSetPlaceholderDecoded
        let dataSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetArn)
        dataSetArn = dataSetArnDecoded
    }
}

extension QuickSightClientTypes {
    /// Dataset reference.
    public struct DataSetReference: Swift.Equatable {
        /// Dataset Amazon Resource Name (ARN).
        /// This member is required.
        public var dataSetArn: Swift.String?
        /// Dataset placeholder.
        /// This member is required.
        public var dataSetPlaceholder: Swift.String?

        public init (
            dataSetArn: Swift.String? = nil,
            dataSetPlaceholder: Swift.String? = nil
        )
        {
            self.dataSetArn = dataSetArn
            self.dataSetPlaceholder = dataSetPlaceholder
        }
    }

}

extension QuickSightClientTypes.DataSetSchema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnSchemaList = "ColumnSchemaList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnSchemaList = columnSchemaList {
            var columnSchemaListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnSchemaList)
            for columnschema0 in columnSchemaList {
                try columnSchemaListContainer.encode(columnschema0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnSchemaListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnSchema?].self, forKey: .columnSchemaList)
        var columnSchemaListDecoded0:[QuickSightClientTypes.ColumnSchema]? = nil
        if let columnSchemaListContainer = columnSchemaListContainer {
            columnSchemaListDecoded0 = [QuickSightClientTypes.ColumnSchema]()
            for structure0 in columnSchemaListContainer {
                if let structure0 = structure0 {
                    columnSchemaListDecoded0?.append(structure0)
                }
            }
        }
        columnSchemaList = columnSchemaListDecoded0
    }
}

extension QuickSightClientTypes {
    /// Dataset schema.
    public struct DataSetSchema: Swift.Equatable {
        /// A structure containing the list of column schemas.
        public var columnSchemaList: [QuickSightClientTypes.ColumnSchema]?

        public init (
            columnSchemaList: [QuickSightClientTypes.ColumnSchema]? = nil
        )
        {
            self.columnSchemaList = columnSchemaList
        }
    }

}

extension QuickSightClientTypes.DataSetSearchFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case `operator` = "Operator"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let nameDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSetFilterAttribute.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension QuickSightClientTypes {
    /// A filter that you apply when searching for datasets.
    public struct DataSetSearchFilter: Swift.Equatable {
        /// The name of the value that you want to use as a filter, for example, "Name": "QUICKSIGHT_OWNER". Valid values are defined as follows:
        ///
        /// * QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the dataset owners or viewers are returned. Implicit permissions from folders or groups are considered.
        ///
        /// * QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the owners of the dataset are returned. Implicit permissions from folders or groups are considered.
        ///
        /// * DIRECT_QUICKSIGHT_SOLE_OWNER: Provide an ARN of a user or group, and any datasets with that ARN listed as the only owner of the dataset are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DIRECT_QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the owners if the dataset are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DIRECT_QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the owners or viewers of the dataset are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DATASET_NAME: Any datasets whose names have a substring match to this value will be returned.
        /// This member is required.
        public var name: QuickSightClientTypes.DataSetFilterAttribute?
        /// The comparison operator that you want to use as a filter, for example "Operator": "StringEquals". Valid values are "StringEquals" and "StringLike". If you set the operator value to "StringEquals", you need to provide an ownership related filter in the "NAME" field and the arn of the user or group whose datasets you want to search in the "Value" field. For example, "Name":"QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east- 1:1:user/default/UserName1". If you set the value to "StringLike", you need to provide the name of the datasets you are searching for. For example, "Name":"DATASET_NAME", "Operator": "StringLike", "Value": "Test". The "StringLike" operator only supports the NAME value DATASET_NAME.
        /// This member is required.
        public var `operator`: QuickSightClientTypes.FilterOperator?
        /// The value of the named item, in this case QUICKSIGHT_OWNER, that you want to use as a filter, for example, "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1".
        /// This member is required.
        public var value: Swift.String?

        public init (
            name: QuickSightClientTypes.DataSetFilterAttribute? = nil,
            `operator`: QuickSightClientTypes.FilterOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }
    }

}

extension QuickSightClientTypes.DataSetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case columnLevelPermissionRulesApplied = "ColumnLevelPermissionRulesApplied"
        case createdTime = "CreatedTime"
        case dataSetId = "DataSetId"
        case importMode = "ImportMode"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
        case rowLevelPermissionTagConfigurationApplied = "RowLevelPermissionTagConfigurationApplied"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if columnLevelPermissionRulesApplied != false {
            try encodeContainer.encode(columnLevelPermissionRulesApplied, forKey: .columnLevelPermissionRulesApplied)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let importMode = self.importMode {
            try encodeContainer.encode(importMode.rawValue, forKey: .importMode)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rowLevelPermissionDataSet = self.rowLevelPermissionDataSet {
            try encodeContainer.encode(rowLevelPermissionDataSet, forKey: .rowLevelPermissionDataSet)
        }
        if rowLevelPermissionTagConfigurationApplied != false {
            try encodeContainer.encode(rowLevelPermissionTagConfigurationApplied, forKey: .rowLevelPermissionTagConfigurationApplied)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let importModeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSetImportMode.self, forKey: .importMode)
        importMode = importModeDecoded
        let rowLevelPermissionDataSetDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RowLevelPermissionDataSet.self, forKey: .rowLevelPermissionDataSet)
        rowLevelPermissionDataSet = rowLevelPermissionDataSetDecoded
        let rowLevelPermissionTagConfigurationAppliedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .rowLevelPermissionTagConfigurationApplied) ?? false
        rowLevelPermissionTagConfigurationApplied = rowLevelPermissionTagConfigurationAppliedDecoded
        let columnLevelPermissionRulesAppliedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .columnLevelPermissionRulesApplied) ?? false
        columnLevelPermissionRulesApplied = columnLevelPermissionRulesAppliedDecoded
    }
}

extension QuickSightClientTypes {
    /// Dataset summary.
    public struct DataSetSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the dataset.
        public var arn: Swift.String?
        /// A value that indicates if the dataset has column level permission configured.
        public var columnLevelPermissionRulesApplied: Swift.Bool
        /// The time that this dataset was created.
        public var createdTime: ClientRuntime.Date?
        /// The ID of the dataset.
        public var dataSetId: Swift.String?
        /// A value that indicates whether you want to import the data into SPICE.
        public var importMode: QuickSightClientTypes.DataSetImportMode?
        /// The last time that this dataset was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// A display name for the dataset.
        public var name: Swift.String?
        /// The row-level security configuration for the dataset.
        public var rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet?
        /// Whether or not the row level permission tags are applied.
        public var rowLevelPermissionTagConfigurationApplied: Swift.Bool

        public init (
            arn: Swift.String? = nil,
            columnLevelPermissionRulesApplied: Swift.Bool = false,
            createdTime: ClientRuntime.Date? = nil,
            dataSetId: Swift.String? = nil,
            importMode: QuickSightClientTypes.DataSetImportMode? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet? = nil,
            rowLevelPermissionTagConfigurationApplied: Swift.Bool = false
        )
        {
            self.arn = arn
            self.columnLevelPermissionRulesApplied = columnLevelPermissionRulesApplied
            self.createdTime = createdTime
            self.dataSetId = dataSetId
            self.importMode = importMode
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
            self.rowLevelPermissionTagConfigurationApplied = rowLevelPermissionTagConfigurationApplied
        }
    }

}

extension QuickSightClientTypes.DataSetUsageConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disableUseAsDirectQuerySource = "DisableUseAsDirectQuerySource"
        case disableUseAsImportedSource = "DisableUseAsImportedSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if disableUseAsDirectQuerySource != false {
            try encodeContainer.encode(disableUseAsDirectQuerySource, forKey: .disableUseAsDirectQuerySource)
        }
        if disableUseAsImportedSource != false {
            try encodeContainer.encode(disableUseAsImportedSource, forKey: .disableUseAsImportedSource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disableUseAsDirectQuerySourceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableUseAsDirectQuerySource) ?? false
        disableUseAsDirectQuerySource = disableUseAsDirectQuerySourceDecoded
        let disableUseAsImportedSourceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableUseAsImportedSource) ?? false
        disableUseAsImportedSource = disableUseAsImportedSourceDecoded
    }
}

extension QuickSightClientTypes {
    /// The usage configuration to apply to child datasets that reference this dataset as a source.
    public struct DataSetUsageConfiguration: Swift.Equatable {
        /// An option that controls whether a child dataset of a direct query can use this dataset as a source.
        public var disableUseAsDirectQuerySource: Swift.Bool
        /// An option that controls whether a child dataset that's stored in QuickSight can use this dataset as a source.
        public var disableUseAsImportedSource: Swift.Bool

        public init (
            disableUseAsDirectQuerySource: Swift.Bool = false,
            disableUseAsImportedSource: Swift.Bool = false
        )
        {
            self.disableUseAsDirectQuerySource = disableUseAsDirectQuerySource
            self.disableUseAsImportedSource = disableUseAsImportedSource
        }
    }

}

extension QuickSightClientTypes.DataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alternateDataSourceParameters = "AlternateDataSourceParameters"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case dataSourceId = "DataSourceId"
        case dataSourceParameters = "DataSourceParameters"
        case errorInfo = "ErrorInfo"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case secretArn = "SecretArn"
        case sslProperties = "SslProperties"
        case status = "Status"
        case type = "Type"
        case vpcConnectionProperties = "VpcConnectionProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alternateDataSourceParameters = alternateDataSourceParameters {
            var alternateDataSourceParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .alternateDataSourceParameters)
            for datasourceparameters0 in alternateDataSourceParameters {
                try alternateDataSourceParametersContainer.encode(datasourceparameters0)
            }
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let dataSourceId = self.dataSourceId {
            try encodeContainer.encode(dataSourceId, forKey: .dataSourceId)
        }
        if let dataSourceParameters = self.dataSourceParameters {
            try encodeContainer.encode(dataSourceParameters, forKey: .dataSourceParameters)
        }
        if let errorInfo = self.errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let secretArn = self.secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let sslProperties = self.sslProperties {
            try encodeContainer.encode(sslProperties, forKey: .sslProperties)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let vpcConnectionProperties = self.vpcConnectionProperties {
            try encodeContainer.encode(vpcConnectionProperties, forKey: .vpcConnectionProperties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSourceType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let dataSourceParametersDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSourceParameters.self, forKey: .dataSourceParameters)
        dataSourceParameters = dataSourceParametersDecoded
        let alternateDataSourceParametersContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataSourceParameters?].self, forKey: .alternateDataSourceParameters)
        var alternateDataSourceParametersDecoded0:[QuickSightClientTypes.DataSourceParameters]? = nil
        if let alternateDataSourceParametersContainer = alternateDataSourceParametersContainer {
            alternateDataSourceParametersDecoded0 = [QuickSightClientTypes.DataSourceParameters]()
            for union0 in alternateDataSourceParametersContainer {
                if let union0 = union0 {
                    alternateDataSourceParametersDecoded0?.append(union0)
                }
            }
        }
        alternateDataSourceParameters = alternateDataSourceParametersDecoded0
        let vpcConnectionPropertiesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VpcConnectionProperties.self, forKey: .vpcConnectionProperties)
        vpcConnectionProperties = vpcConnectionPropertiesDecoded
        let sslPropertiesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SslProperties.self, forKey: .sslProperties)
        sslProperties = sslPropertiesDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSourceErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
    }
}

extension QuickSightClientTypes {
    /// The structure of a data source.
    public struct DataSource: Swift.Equatable {
        /// A set of alternate data source parameters that you want to share for the credentials stored with this data source. The credentials are applied in tandem with the data source parameters when you copy a data source by using a create or update request. The API operation compares the DataSourceParameters structure that's in the request with the structures in the AlternateDataSourceParameters allow list. If the structures are an exact match, the request is allowed to use the credentials from this existing data source. If the AlternateDataSourceParameters list is null, the Credentials originally used with this DataSourceParameters are automatically allowed.
        public var alternateDataSourceParameters: [QuickSightClientTypes.DataSourceParameters]?
        /// The Amazon Resource Name (ARN) of the data source.
        public var arn: Swift.String?
        /// The time that this data source was created.
        public var createdTime: ClientRuntime.Date?
        /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public var dataSourceId: Swift.String?
        /// The parameters that Amazon QuickSight uses to connect to your underlying source. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
        public var dataSourceParameters: QuickSightClientTypes.DataSourceParameters?
        /// Error information from the last update or the creation of the data source.
        public var errorInfo: QuickSightClientTypes.DataSourceErrorInfo?
        /// The last time that this data source was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// A display name for the data source.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the secret associated with the data source in Amazon Secrets Manager.
        public var secretArn: Swift.String?
        /// Secure Socket Layer (SSL) properties that apply when Amazon QuickSight connects to your underlying source.
        public var sslProperties: QuickSightClientTypes.SslProperties?
        /// The HTTP status of the request.
        public var status: QuickSightClientTypes.ResourceStatus?
        /// The type of the data source. This type indicates which database engine the data source connects to.
        public var type: QuickSightClientTypes.DataSourceType?
        /// The VPC connection information. You need to use this parameter only when you want Amazon QuickSight to use a VPC connection when connecting to your underlying source.
        public var vpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties?

        public init (
            alternateDataSourceParameters: [QuickSightClientTypes.DataSourceParameters]? = nil,
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            dataSourceId: Swift.String? = nil,
            dataSourceParameters: QuickSightClientTypes.DataSourceParameters? = nil,
            errorInfo: QuickSightClientTypes.DataSourceErrorInfo? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            secretArn: Swift.String? = nil,
            sslProperties: QuickSightClientTypes.SslProperties? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil,
            type: QuickSightClientTypes.DataSourceType? = nil,
            vpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties? = nil
        )
        {
            self.alternateDataSourceParameters = alternateDataSourceParameters
            self.arn = arn
            self.createdTime = createdTime
            self.dataSourceId = dataSourceId
            self.dataSourceParameters = dataSourceParameters
            self.errorInfo = errorInfo
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.secretArn = secretArn
            self.sslProperties = sslProperties
            self.status = status
            self.type = type
            self.vpcConnectionProperties = vpcConnectionProperties
        }
    }

}

extension QuickSightClientTypes.DataSourceCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copySourceArn = "CopySourceArn"
        case credentialPair = "CredentialPair"
        case secretArn = "SecretArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let copySourceArn = self.copySourceArn {
            try encodeContainer.encode(copySourceArn, forKey: .copySourceArn)
        }
        if let credentialPair = self.credentialPair {
            try encodeContainer.encode(credentialPair, forKey: .credentialPair)
        }
        if let secretArn = self.secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialPairDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CredentialPair.self, forKey: .credentialPair)
        credentialPair = credentialPairDecoded
        let copySourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .copySourceArn)
        copySourceArn = copySourceArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
    }
}

extension QuickSightClientTypes.DataSourceCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension QuickSightClientTypes {
    /// Data source credentials. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
    public struct DataSourceCredentials: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of a data source that has the credential pair that you want to use. When CopySourceArn is not null, the credential pair from the data source in the ARN is used as the credentials for the DataSourceCredentials structure.
        public var copySourceArn: Swift.String?
        /// Credential pair. For more information, see [CredentialPair](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_CredentialPair.html).
        public var credentialPair: QuickSightClientTypes.CredentialPair?
        /// The Amazon Resource Name (ARN) of the secret associated with the data source in Amazon Secrets Manager.
        public var secretArn: Swift.String?

        public init (
            copySourceArn: Swift.String? = nil,
            credentialPair: QuickSightClientTypes.CredentialPair? = nil,
            secretArn: Swift.String? = nil
        )
        {
            self.copySourceArn = copySourceArn
            self.credentialPair = credentialPair
            self.secretArn = secretArn
        }
    }

}

extension QuickSightClientTypes.DataSourceErrorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSourceErrorInfoType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QuickSightClientTypes {
    /// Error information for the data source creation or update.
    public struct DataSourceErrorInfo: Swift.Equatable {
        /// Error message.
        public var message: Swift.String?
        /// Error type.
        public var type: QuickSightClientTypes.DataSourceErrorInfoType?

        public init (
            message: Swift.String? = nil,
            type: QuickSightClientTypes.DataSourceErrorInfoType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }

}

extension QuickSightClientTypes {
    public enum DataSourceErrorInfoType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case conflict
        case copySourceNotFound
        case engineVersionNotSupported
        case genericSqlFailure
        case timeout
        case unknown
        case unknownHost
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceErrorInfoType] {
            return [
                .accessDenied,
                .conflict,
                .copySourceNotFound,
                .engineVersionNotSupported,
                .genericSqlFailure,
                .timeout,
                .unknown,
                .unknownHost,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .conflict: return "CONFLICT"
            case .copySourceNotFound: return "COPY_SOURCE_NOT_FOUND"
            case .engineVersionNotSupported: return "ENGINE_VERSION_NOT_SUPPORTED"
            case .genericSqlFailure: return "GENERIC_SQL_FAILURE"
            case .timeout: return "TIMEOUT"
            case .unknown: return "UNKNOWN"
            case .unknownHost: return "UNKNOWN_HOST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceErrorInfoType(rawValue: rawValue) ?? DataSourceErrorInfoType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum DataSourceFilterAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case datasourceName
        case directQuicksightOwner
        case directQuicksightSoleOwner
        case directQuicksightViewerOrOwner
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceFilterAttribute] {
            return [
                .datasourceName,
                .directQuicksightOwner,
                .directQuicksightSoleOwner,
                .directQuicksightViewerOrOwner,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .datasourceName: return "DATASOURCE_NAME"
            case .directQuicksightOwner: return "DIRECT_QUICKSIGHT_OWNER"
            case .directQuicksightSoleOwner: return "DIRECT_QUICKSIGHT_SOLE_OWNER"
            case .directQuicksightViewerOrOwner: return "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceFilterAttribute(rawValue: rawValue) ?? DataSourceFilterAttribute.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.DataSourceParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonelasticsearchparameters = "AmazonElasticsearchParameters"
        case amazonopensearchparameters = "AmazonOpenSearchParameters"
        case athenaparameters = "AthenaParameters"
        case auroraparameters = "AuroraParameters"
        case aurorapostgresqlparameters = "AuroraPostgreSqlParameters"
        case awsiotanalyticsparameters = "AwsIotAnalyticsParameters"
        case databricksparameters = "DatabricksParameters"
        case exasolparameters = "ExasolParameters"
        case jiraparameters = "JiraParameters"
        case mariadbparameters = "MariaDbParameters"
        case mysqlparameters = "MySqlParameters"
        case oracleparameters = "OracleParameters"
        case postgresqlparameters = "PostgreSqlParameters"
        case prestoparameters = "PrestoParameters"
        case rdsparameters = "RdsParameters"
        case redshiftparameters = "RedshiftParameters"
        case s3parameters = "S3Parameters"
        case servicenowparameters = "ServiceNowParameters"
        case snowflakeparameters = "SnowflakeParameters"
        case sparkparameters = "SparkParameters"
        case sqlserverparameters = "SqlServerParameters"
        case teradataparameters = "TeradataParameters"
        case twitterparameters = "TwitterParameters"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .amazonelasticsearchparameters(amazonelasticsearchparameters):
                try container.encode(amazonelasticsearchparameters, forKey: .amazonelasticsearchparameters)
            case let .amazonopensearchparameters(amazonopensearchparameters):
                try container.encode(amazonopensearchparameters, forKey: .amazonopensearchparameters)
            case let .athenaparameters(athenaparameters):
                try container.encode(athenaparameters, forKey: .athenaparameters)
            case let .auroraparameters(auroraparameters):
                try container.encode(auroraparameters, forKey: .auroraparameters)
            case let .aurorapostgresqlparameters(aurorapostgresqlparameters):
                try container.encode(aurorapostgresqlparameters, forKey: .aurorapostgresqlparameters)
            case let .awsiotanalyticsparameters(awsiotanalyticsparameters):
                try container.encode(awsiotanalyticsparameters, forKey: .awsiotanalyticsparameters)
            case let .databricksparameters(databricksparameters):
                try container.encode(databricksparameters, forKey: .databricksparameters)
            case let .exasolparameters(exasolparameters):
                try container.encode(exasolparameters, forKey: .exasolparameters)
            case let .jiraparameters(jiraparameters):
                try container.encode(jiraparameters, forKey: .jiraparameters)
            case let .mariadbparameters(mariadbparameters):
                try container.encode(mariadbparameters, forKey: .mariadbparameters)
            case let .mysqlparameters(mysqlparameters):
                try container.encode(mysqlparameters, forKey: .mysqlparameters)
            case let .oracleparameters(oracleparameters):
                try container.encode(oracleparameters, forKey: .oracleparameters)
            case let .postgresqlparameters(postgresqlparameters):
                try container.encode(postgresqlparameters, forKey: .postgresqlparameters)
            case let .prestoparameters(prestoparameters):
                try container.encode(prestoparameters, forKey: .prestoparameters)
            case let .rdsparameters(rdsparameters):
                try container.encode(rdsparameters, forKey: .rdsparameters)
            case let .redshiftparameters(redshiftparameters):
                try container.encode(redshiftparameters, forKey: .redshiftparameters)
            case let .s3parameters(s3parameters):
                try container.encode(s3parameters, forKey: .s3parameters)
            case let .servicenowparameters(servicenowparameters):
                try container.encode(servicenowparameters, forKey: .servicenowparameters)
            case let .snowflakeparameters(snowflakeparameters):
                try container.encode(snowflakeparameters, forKey: .snowflakeparameters)
            case let .sparkparameters(sparkparameters):
                try container.encode(sparkparameters, forKey: .sparkparameters)
            case let .sqlserverparameters(sqlserverparameters):
                try container.encode(sqlserverparameters, forKey: .sqlserverparameters)
            case let .teradataparameters(teradataparameters):
                try container.encode(teradataparameters, forKey: .teradataparameters)
            case let .twitterparameters(twitterparameters):
                try container.encode(twitterparameters, forKey: .twitterparameters)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let amazonelasticsearchparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.AmazonElasticsearchParameters.self, forKey: .amazonelasticsearchparameters)
        if let amazonelasticsearchparameters = amazonelasticsearchparametersDecoded {
            self = .amazonelasticsearchparameters(amazonelasticsearchparameters)
            return
        }
        let athenaparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.AthenaParameters.self, forKey: .athenaparameters)
        if let athenaparameters = athenaparametersDecoded {
            self = .athenaparameters(athenaparameters)
            return
        }
        let auroraparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.AuroraParameters.self, forKey: .auroraparameters)
        if let auroraparameters = auroraparametersDecoded {
            self = .auroraparameters(auroraparameters)
            return
        }
        let aurorapostgresqlparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.AuroraPostgreSqlParameters.self, forKey: .aurorapostgresqlparameters)
        if let aurorapostgresqlparameters = aurorapostgresqlparametersDecoded {
            self = .aurorapostgresqlparameters(aurorapostgresqlparameters)
            return
        }
        let awsiotanalyticsparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.AwsIotAnalyticsParameters.self, forKey: .awsiotanalyticsparameters)
        if let awsiotanalyticsparameters = awsiotanalyticsparametersDecoded {
            self = .awsiotanalyticsparameters(awsiotanalyticsparameters)
            return
        }
        let jiraparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.JiraParameters.self, forKey: .jiraparameters)
        if let jiraparameters = jiraparametersDecoded {
            self = .jiraparameters(jiraparameters)
            return
        }
        let mariadbparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.MariaDbParameters.self, forKey: .mariadbparameters)
        if let mariadbparameters = mariadbparametersDecoded {
            self = .mariadbparameters(mariadbparameters)
            return
        }
        let mysqlparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.MySqlParameters.self, forKey: .mysqlparameters)
        if let mysqlparameters = mysqlparametersDecoded {
            self = .mysqlparameters(mysqlparameters)
            return
        }
        let oracleparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.OracleParameters.self, forKey: .oracleparameters)
        if let oracleparameters = oracleparametersDecoded {
            self = .oracleparameters(oracleparameters)
            return
        }
        let postgresqlparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.PostgreSqlParameters.self, forKey: .postgresqlparameters)
        if let postgresqlparameters = postgresqlparametersDecoded {
            self = .postgresqlparameters(postgresqlparameters)
            return
        }
        let prestoparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.PrestoParameters.self, forKey: .prestoparameters)
        if let prestoparameters = prestoparametersDecoded {
            self = .prestoparameters(prestoparameters)
            return
        }
        let rdsparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.RdsParameters.self, forKey: .rdsparameters)
        if let rdsparameters = rdsparametersDecoded {
            self = .rdsparameters(rdsparameters)
            return
        }
        let redshiftparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.RedshiftParameters.self, forKey: .redshiftparameters)
        if let redshiftparameters = redshiftparametersDecoded {
            self = .redshiftparameters(redshiftparameters)
            return
        }
        let s3parametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.S3Parameters.self, forKey: .s3parameters)
        if let s3parameters = s3parametersDecoded {
            self = .s3parameters(s3parameters)
            return
        }
        let servicenowparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.ServiceNowParameters.self, forKey: .servicenowparameters)
        if let servicenowparameters = servicenowparametersDecoded {
            self = .servicenowparameters(servicenowparameters)
            return
        }
        let snowflakeparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.SnowflakeParameters.self, forKey: .snowflakeparameters)
        if let snowflakeparameters = snowflakeparametersDecoded {
            self = .snowflakeparameters(snowflakeparameters)
            return
        }
        let sparkparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.SparkParameters.self, forKey: .sparkparameters)
        if let sparkparameters = sparkparametersDecoded {
            self = .sparkparameters(sparkparameters)
            return
        }
        let sqlserverparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.SqlServerParameters.self, forKey: .sqlserverparameters)
        if let sqlserverparameters = sqlserverparametersDecoded {
            self = .sqlserverparameters(sqlserverparameters)
            return
        }
        let teradataparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.TeradataParameters.self, forKey: .teradataparameters)
        if let teradataparameters = teradataparametersDecoded {
            self = .teradataparameters(teradataparameters)
            return
        }
        let twitterparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.TwitterParameters.self, forKey: .twitterparameters)
        if let twitterparameters = twitterparametersDecoded {
            self = .twitterparameters(twitterparameters)
            return
        }
        let amazonopensearchparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.AmazonOpenSearchParameters.self, forKey: .amazonopensearchparameters)
        if let amazonopensearchparameters = amazonopensearchparametersDecoded {
            self = .amazonopensearchparameters(amazonopensearchparameters)
            return
        }
        let exasolparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.ExasolParameters.self, forKey: .exasolparameters)
        if let exasolparameters = exasolparametersDecoded {
            self = .exasolparameters(exasolparameters)
            return
        }
        let databricksparametersDecoded = try values.decodeIfPresent(QuickSightClientTypes.DatabricksParameters.self, forKey: .databricksparameters)
        if let databricksparameters = databricksparametersDecoded {
            self = .databricksparameters(databricksparameters)
            return
        }
        self = .sdkUnknown("")
    }
}

extension QuickSightClientTypes {
    /// The parameters that Amazon QuickSight uses to connect to your underlying data source. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
    public enum DataSourceParameters: Swift.Equatable {
        /// The parameters for OpenSearch.
        case amazonelasticsearchparameters(QuickSightClientTypes.AmazonElasticsearchParameters)
        /// The parameters for Amazon Athena.
        case athenaparameters(QuickSightClientTypes.AthenaParameters)
        /// The parameters for Amazon Aurora MySQL.
        case auroraparameters(QuickSightClientTypes.AuroraParameters)
        /// The parameters for Amazon Aurora.
        case aurorapostgresqlparameters(QuickSightClientTypes.AuroraPostgreSqlParameters)
        /// The parameters for IoT Analytics.
        case awsiotanalyticsparameters(QuickSightClientTypes.AwsIotAnalyticsParameters)
        /// The parameters for Jira.
        case jiraparameters(QuickSightClientTypes.JiraParameters)
        /// The parameters for MariaDB.
        case mariadbparameters(QuickSightClientTypes.MariaDbParameters)
        /// The parameters for MySQL.
        case mysqlparameters(QuickSightClientTypes.MySqlParameters)
        /// The parameters for Oracle.
        case oracleparameters(QuickSightClientTypes.OracleParameters)
        /// The parameters for PostgreSQL.
        case postgresqlparameters(QuickSightClientTypes.PostgreSqlParameters)
        /// The parameters for Presto.
        case prestoparameters(QuickSightClientTypes.PrestoParameters)
        /// The parameters for Amazon RDS.
        case rdsparameters(QuickSightClientTypes.RdsParameters)
        /// The parameters for Amazon Redshift.
        case redshiftparameters(QuickSightClientTypes.RedshiftParameters)
        /// The parameters for S3.
        case s3parameters(QuickSightClientTypes.S3Parameters)
        /// The parameters for ServiceNow.
        case servicenowparameters(QuickSightClientTypes.ServiceNowParameters)
        /// The parameters for Snowflake.
        case snowflakeparameters(QuickSightClientTypes.SnowflakeParameters)
        /// The parameters for Spark.
        case sparkparameters(QuickSightClientTypes.SparkParameters)
        /// The parameters for SQL Server.
        case sqlserverparameters(QuickSightClientTypes.SqlServerParameters)
        /// The parameters for Teradata.
        case teradataparameters(QuickSightClientTypes.TeradataParameters)
        /// The parameters for Twitter.
        case twitterparameters(QuickSightClientTypes.TwitterParameters)
        /// The parameters for OpenSearch.
        case amazonopensearchparameters(QuickSightClientTypes.AmazonOpenSearchParameters)
        /// The parameters for Exasol.
        case exasolparameters(QuickSightClientTypes.ExasolParameters)
        /// The required parameters that are needed to connect to a Databricks data source.
        case databricksparameters(QuickSightClientTypes.DatabricksParameters)
        case sdkUnknown(Swift.String)
    }

}

extension QuickSightClientTypes.DataSourceSearchFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case `operator` = "Operator"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let nameDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSourceFilterAttribute.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension QuickSightClientTypes {
    /// A filter that you apply when searching for data sources.
    public struct DataSourceSearchFilter: Swift.Equatable {
        /// The name of the value that you want to use as a filter, for example, "Name": "DIRECT_QUICKSIGHT_OWNER". Valid values are defined as follows:
        ///
        /// * DIRECT_QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any data sources with that ARN listed as one of the owners or viewers of the data sources are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DIRECT_QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any data sources with that ARN listed as one of the owners if the data source are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DIRECT_QUICKSIGHT_SOLE_OWNER: Provide an ARN of a user or group, and any data sources with that ARN listed as the only owner of the data source are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DATASOURCE_NAME: Any data sources whose names have a substring match to the provided value are returned.
        /// This member is required.
        public var name: QuickSightClientTypes.DataSourceFilterAttribute?
        /// The comparison operator that you want to use as a filter, for example "Operator": "StringEquals". Valid values are "StringEquals" and "StringLike". If you set the operator value to "StringEquals", you need to provide an ownership related filter in the "NAME" field and the arn of the user or group whose data sources you want to search in the "Value" field. For example, "Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1". If you set the value to "StringLike", you need to provide the name of the data sources you are searching for. For example, "Name":"DATASOURCE_NAME", "Operator": "StringLike", "Value": "Test". The "StringLike" operator only supports the NAME value DATASOURCE_NAME.
        /// This member is required.
        public var `operator`: QuickSightClientTypes.FilterOperator?
        /// The value of the named item, for example DIRECT_QUICKSIGHT_OWNER, that you want to use as a filter, for example, "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1".
        /// This member is required.
        public var value: Swift.String?

        public init (
            name: QuickSightClientTypes.DataSourceFilterAttribute? = nil,
            `operator`: QuickSightClientTypes.FilterOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }
    }

}

extension QuickSightClientTypes.DataSourceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case dataSourceId = "DataSourceId"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let dataSourceId = self.dataSourceId {
            try encodeContainer.encode(dataSourceId, forKey: .dataSourceId)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSourceType.self, forKey: .type)
        type = typeDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension QuickSightClientTypes {
    /// A DataSourceSummary object that returns a summary of a data source.
    public struct DataSourceSummary: Swift.Equatable {
        /// The arn of the datasource.
        public var arn: Swift.String?
        /// The date and time that the data source was created. This value is expressed in MM-DD-YYYY HH:MM:SS format.
        public var createdTime: ClientRuntime.Date?
        /// The unique ID of the data source.
        public var dataSourceId: Swift.String?
        /// The date and time the data source was last updated. This value is expressed in MM-DD-YYYY HH:MM:SS format.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the data source.
        public var name: Swift.String?
        /// The type of the data source.
        public var type: QuickSightClientTypes.DataSourceType?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            dataSourceId: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            type: QuickSightClientTypes.DataSourceType? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.dataSourceId = dataSourceId
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.type = type
        }
    }

}

extension QuickSightClientTypes {
    public enum DataSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case adobeAnalytics
        case amazonElasticsearch
        case amazonOpensearch
        case athena
        case aurora
        case auroraPostgresql
        case awsIotAnalytics
        case databricks
        case exasol
        case github
        case jira
        case mariadb
        case mysql
        case oracle
        case postgresql
        case presto
        case redshift
        case s3
        case salesforce
        case servicenow
        case snowflake
        case spark
        case sqlserver
        case teradata
        case timestream
        case twitter
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceType] {
            return [
                .adobeAnalytics,
                .amazonElasticsearch,
                .amazonOpensearch,
                .athena,
                .aurora,
                .auroraPostgresql,
                .awsIotAnalytics,
                .databricks,
                .exasol,
                .github,
                .jira,
                .mariadb,
                .mysql,
                .oracle,
                .postgresql,
                .presto,
                .redshift,
                .s3,
                .salesforce,
                .servicenow,
                .snowflake,
                .spark,
                .sqlserver,
                .teradata,
                .timestream,
                .twitter,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .adobeAnalytics: return "ADOBE_ANALYTICS"
            case .amazonElasticsearch: return "AMAZON_ELASTICSEARCH"
            case .amazonOpensearch: return "AMAZON_OPENSEARCH"
            case .athena: return "ATHENA"
            case .aurora: return "AURORA"
            case .auroraPostgresql: return "AURORA_POSTGRESQL"
            case .awsIotAnalytics: return "AWS_IOT_ANALYTICS"
            case .databricks: return "DATABRICKS"
            case .exasol: return "EXASOL"
            case .github: return "GITHUB"
            case .jira: return "JIRA"
            case .mariadb: return "MARIADB"
            case .mysql: return "MYSQL"
            case .oracle: return "ORACLE"
            case .postgresql: return "POSTGRESQL"
            case .presto: return "PRESTO"
            case .redshift: return "REDSHIFT"
            case .s3: return "S3"
            case .salesforce: return "SALESFORCE"
            case .servicenow: return "SERVICENOW"
            case .snowflake: return "SNOWFLAKE"
            case .spark: return "SPARK"
            case .sqlserver: return "SQLSERVER"
            case .teradata: return "TERADATA"
            case .timestream: return "TIMESTREAM"
            case .twitter: return "TWITTER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceType(rawValue: rawValue) ?? DataSourceType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.DatabricksParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case host = "Host"
        case port = "Port"
        case sqlEndpointPath = "SqlEndpointPath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let sqlEndpointPath = self.sqlEndpointPath {
            try encodeContainer.encode(sqlEndpointPath, forKey: .sqlEndpointPath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let sqlEndpointPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sqlEndpointPath)
        sqlEndpointPath = sqlEndpointPathDecoded
    }
}

extension QuickSightClientTypes {
    /// The required parameters that are needed to connect to a Databricks data source.
    public struct DatabricksParameters: Swift.Equatable {
        /// The host name of the Databricks data source.
        /// This member is required.
        public var host: Swift.String?
        /// The port for the Databricks data source.
        /// This member is required.
        public var port: Swift.Int
        /// The HTTP path of the Databricks data source.
        /// This member is required.
        public var sqlEndpointPath: Swift.String?

        public init (
            host: Swift.String? = nil,
            port: Swift.Int = 0,
            sqlEndpointPath: Swift.String? = nil
        )
        {
            self.host = host
            self.port = port
            self.sqlEndpointPath = sqlEndpointPath
        }
    }

}

extension QuickSightClientTypes {
    public enum DateAggregationFunction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case count
        case distinctCount
        case max
        case min
        case sdkUnknown(Swift.String)

        public static var allCases: [DateAggregationFunction] {
            return [
                .count,
                .distinctCount,
                .max,
                .min,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .count: return "COUNT"
            case .distinctCount: return "DISTINCT_COUNT"
            case .max: return "MAX"
            case .min: return "MIN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DateAggregationFunction(rawValue: rawValue) ?? DateAggregationFunction.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.DateAxisOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case missingDateVisibility = "MissingDateVisibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let missingDateVisibility = self.missingDateVisibility {
            try encodeContainer.encode(missingDateVisibility.rawValue, forKey: .missingDateVisibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missingDateVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .missingDateVisibility)
        missingDateVisibility = missingDateVisibilityDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine how a date axis is displayed.
    public struct DateAxisOptions: Swift.Equatable {
        /// Determines whether or not missing dates are displayed.
        public var missingDateVisibility: QuickSightClientTypes.Visibility?

        public init (
            missingDateVisibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.missingDateVisibility = missingDateVisibility
        }
    }

}

extension QuickSightClientTypes.DateDimensionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case column = "Column"
        case dateGranularity = "DateGranularity"
        case fieldId = "FieldId"
        case formatConfiguration = "FormatConfiguration"
        case hierarchyId = "HierarchyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let column = self.column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let dateGranularity = self.dateGranularity {
            try encodeContainer.encode(dateGranularity.rawValue, forKey: .dateGranularity)
        }
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
        if let formatConfiguration = self.formatConfiguration {
            try encodeContainer.encode(formatConfiguration, forKey: .formatConfiguration)
        }
        if let hierarchyId = self.hierarchyId {
            try encodeContainer.encode(hierarchyId, forKey: .hierarchyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let columnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .column)
        column = columnDecoded
        let dateGranularityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TimeGranularity.self, forKey: .dateGranularity)
        dateGranularity = dateGranularityDecoded
        let hierarchyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyId)
        hierarchyId = hierarchyIdDecoded
        let formatConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DateTimeFormatConfiguration.self, forKey: .formatConfiguration)
        formatConfiguration = formatConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The dimension type field with date type columns.
    public struct DateDimensionField: Swift.Equatable {
        /// The column that is used in the DateDimensionField.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The date granularity of the DateDimensionField. Choose one of the following options:
        ///
        /// * YEAR
        ///
        /// * QUARTER
        ///
        /// * MONTH
        ///
        /// * WEEK
        ///
        /// * DAY
        ///
        /// * HOUR
        ///
        /// * MINUTE
        ///
        /// * SECOND
        ///
        /// * MILLISECOND
        public var dateGranularity: QuickSightClientTypes.TimeGranularity?
        /// The custom field ID.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The format configuration of the field.
        public var formatConfiguration: QuickSightClientTypes.DateTimeFormatConfiguration?
        /// The custom hierarchy ID.
        public var hierarchyId: Swift.String?

        public init (
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            dateGranularity: QuickSightClientTypes.TimeGranularity? = nil,
            fieldId: Swift.String? = nil,
            formatConfiguration: QuickSightClientTypes.DateTimeFormatConfiguration? = nil,
            hierarchyId: Swift.String? = nil
        )
        {
            self.column = column
            self.dateGranularity = dateGranularity
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
            self.hierarchyId = hierarchyId
        }
    }

}

extension QuickSightClientTypes.DateMeasureField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationFunction = "AggregationFunction"
        case column = "Column"
        case fieldId = "FieldId"
        case formatConfiguration = "FormatConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationFunction = self.aggregationFunction {
            try encodeContainer.encode(aggregationFunction.rawValue, forKey: .aggregationFunction)
        }
        if let column = self.column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
        if let formatConfiguration = self.formatConfiguration {
            try encodeContainer.encode(formatConfiguration, forKey: .formatConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let columnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .column)
        column = columnDecoded
        let aggregationFunctionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DateAggregationFunction.self, forKey: .aggregationFunction)
        aggregationFunction = aggregationFunctionDecoded
        let formatConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DateTimeFormatConfiguration.self, forKey: .formatConfiguration)
        formatConfiguration = formatConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The measure type field with date type columns.
    public struct DateMeasureField: Swift.Equatable {
        /// The aggregation function of the measure field.
        public var aggregationFunction: QuickSightClientTypes.DateAggregationFunction?
        /// The column that is used in the DateMeasureField.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The custom field ID.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The format configuration of the field.
        public var formatConfiguration: QuickSightClientTypes.DateTimeFormatConfiguration?

        public init (
            aggregationFunction: QuickSightClientTypes.DateAggregationFunction? = nil,
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            fieldId: Swift.String? = nil,
            formatConfiguration: QuickSightClientTypes.DateTimeFormatConfiguration? = nil
        )
        {
            self.aggregationFunction = aggregationFunction
            self.column = column
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
        }
    }

}

extension QuickSightClientTypes.DateTimeDefaultValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dynamicValue = "DynamicValue"
        case rollingDate = "RollingDate"
        case staticValues = "StaticValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dynamicValue = self.dynamicValue {
            try encodeContainer.encode(dynamicValue, forKey: .dynamicValue)
        }
        if let rollingDate = self.rollingDate {
            try encodeContainer.encode(rollingDate, forKey: .rollingDate)
        }
        if let staticValues = staticValues {
            var staticValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .staticValues)
            for sensitivetimestamp0 in staticValues {
                try staticValuesContainer.encodeTimestamp(sensitivetimestamp0, format: .epochSeconds)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dynamicValueDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DynamicDefaultValue.self, forKey: .dynamicValue)
        dynamicValue = dynamicValueDecoded
        let staticValuesContainer = try containerValues.decodeIfPresent([ClientRuntime.Date?].self, forKey: .staticValues)
        var staticValuesDecoded0:[ClientRuntime.Date]? = nil
        if let staticValuesContainer = staticValuesContainer {
            staticValuesDecoded0 = [ClientRuntime.Date]()
            for timestamp0 in staticValuesContainer {
                if let timestamp0 = timestamp0 {
                    staticValuesDecoded0?.append(timestamp0)
                }
            }
        }
        staticValues = staticValuesDecoded0
        let rollingDateDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RollingDateConfiguration.self, forKey: .rollingDate)
        rollingDate = rollingDateDecoded
    }
}

extension QuickSightClientTypes {
    /// The default values of the DateTimeParameterDeclaration.
    public struct DateTimeDefaultValues: Swift.Equatable {
        /// The dynamic value of the DataTimeDefaultValues. Different defaults are displayed according to users, groups, and values mapping.
        public var dynamicValue: QuickSightClientTypes.DynamicDefaultValue?
        /// The rolling date of the DataTimeDefaultValues. The date is determined from the dataset based on input expression.
        public var rollingDate: QuickSightClientTypes.RollingDateConfiguration?
        /// The static values of the DataTimeDefaultValues.
        public var staticValues: [ClientRuntime.Date]?

        public init (
            dynamicValue: QuickSightClientTypes.DynamicDefaultValue? = nil,
            rollingDate: QuickSightClientTypes.RollingDateConfiguration? = nil,
            staticValues: [ClientRuntime.Date]? = nil
        )
        {
            self.dynamicValue = dynamicValue
            self.rollingDate = rollingDate
            self.staticValues = staticValues
        }
    }

}

extension QuickSightClientTypes.DateTimeFormatConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateTimeFormat = "DateTimeFormat"
        case nullValueFormatConfiguration = "NullValueFormatConfiguration"
        case numericFormatConfiguration = "NumericFormatConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateTimeFormat = self.dateTimeFormat {
            try encodeContainer.encode(dateTimeFormat, forKey: .dateTimeFormat)
        }
        if let nullValueFormatConfiguration = self.nullValueFormatConfiguration {
            try encodeContainer.encode(nullValueFormatConfiguration, forKey: .nullValueFormatConfiguration)
        }
        if let numericFormatConfiguration = self.numericFormatConfiguration {
            try encodeContainer.encode(numericFormatConfiguration, forKey: .numericFormatConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateTimeFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateTimeFormat)
        dateTimeFormat = dateTimeFormatDecoded
        let nullValueFormatConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NullValueFormatConfiguration.self, forKey: .nullValueFormatConfiguration)
        nullValueFormatConfiguration = nullValueFormatConfigurationDecoded
        let numericFormatConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumericFormatConfiguration.self, forKey: .numericFormatConfiguration)
        numericFormatConfiguration = numericFormatConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// Formatting configuration for DateTime fields.
    public struct DateTimeFormatConfiguration: Swift.Equatable {
        /// Determines the DateTime format.
        public var dateTimeFormat: Swift.String?
        /// The options that determine the null value format configuration.
        public var nullValueFormatConfiguration: QuickSightClientTypes.NullValueFormatConfiguration?
        /// The formatting configuration for numeric DateTime fields.
        public var numericFormatConfiguration: QuickSightClientTypes.NumericFormatConfiguration?

        public init (
            dateTimeFormat: Swift.String? = nil,
            nullValueFormatConfiguration: QuickSightClientTypes.NullValueFormatConfiguration? = nil,
            numericFormatConfiguration: QuickSightClientTypes.NumericFormatConfiguration? = nil
        )
        {
            self.dateTimeFormat = dateTimeFormat
            self.nullValueFormatConfiguration = nullValueFormatConfiguration
            self.numericFormatConfiguration = numericFormatConfiguration
        }
    }

}

extension QuickSightClientTypes.DateTimeHierarchy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case drillDownFilters = "DrillDownFilters"
        case hierarchyId = "HierarchyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let drillDownFilters = drillDownFilters {
            var drillDownFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .drillDownFilters)
            for drilldownfilter0 in drillDownFilters {
                try drillDownFiltersContainer.encode(drilldownfilter0)
            }
        }
        if let hierarchyId = self.hierarchyId {
            try encodeContainer.encode(hierarchyId, forKey: .hierarchyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyId)
        hierarchyId = hierarchyIdDecoded
        let drillDownFiltersContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DrillDownFilter?].self, forKey: .drillDownFilters)
        var drillDownFiltersDecoded0:[QuickSightClientTypes.DrillDownFilter]? = nil
        if let drillDownFiltersContainer = drillDownFiltersContainer {
            drillDownFiltersDecoded0 = [QuickSightClientTypes.DrillDownFilter]()
            for structure0 in drillDownFiltersContainer {
                if let structure0 = structure0 {
                    drillDownFiltersDecoded0?.append(structure0)
                }
            }
        }
        drillDownFilters = drillDownFiltersDecoded0
    }
}

extension QuickSightClientTypes {
    /// The option that determines the hierarchy of any DateTime fields.
    public struct DateTimeHierarchy: Swift.Equatable {
        /// The option that determines the drill down filters for the DateTime hierarchy.
        public var drillDownFilters: [QuickSightClientTypes.DrillDownFilter]?
        /// The hierarchy ID of the DateTime hierarchy.
        /// This member is required.
        public var hierarchyId: Swift.String?

        public init (
            drillDownFilters: [QuickSightClientTypes.DrillDownFilter]? = nil,
            hierarchyId: Swift.String? = nil
        )
        {
            self.drillDownFilters = drillDownFilters
            self.hierarchyId = hierarchyId
        }
    }

}

extension QuickSightClientTypes.DateTimeParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for sensitivetimestamp0 in values {
                try valuesContainer.encodeTimestamp(sensitivetimestamp0, format: .epochSeconds)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([ClientRuntime.Date?].self, forKey: .values)
        var valuesDecoded0:[ClientRuntime.Date]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [ClientRuntime.Date]()
            for timestamp0 in valuesContainer {
                if let timestamp0 = timestamp0 {
                    valuesDecoded0?.append(timestamp0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension QuickSightClientTypes {
    /// A date-time parameter.
    public struct DateTimeParameter: Swift.Equatable {
        /// A display name for the date-time parameter.
        /// This member is required.
        public var name: Swift.String?
        /// The values for the date-time parameter.
        /// This member is required.
        public var values: [ClientRuntime.Date]?

        public init (
            name: Swift.String? = nil,
            values: [ClientRuntime.Date]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension QuickSightClientTypes.DateTimeParameterDeclaration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValues = "DefaultValues"
        case name = "Name"
        case timeGranularity = "TimeGranularity"
        case valueWhenUnset = "ValueWhenUnset"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValues = self.defaultValues {
            try encodeContainer.encode(defaultValues, forKey: .defaultValues)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let timeGranularity = self.timeGranularity {
            try encodeContainer.encode(timeGranularity.rawValue, forKey: .timeGranularity)
        }
        if let valueWhenUnset = self.valueWhenUnset {
            try encodeContainer.encode(valueWhenUnset, forKey: .valueWhenUnset)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let defaultValuesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DateTimeDefaultValues.self, forKey: .defaultValues)
        defaultValues = defaultValuesDecoded
        let timeGranularityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TimeGranularity.self, forKey: .timeGranularity)
        timeGranularity = timeGranularityDecoded
        let valueWhenUnsetDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DateTimeValueWhenUnsetConfiguration.self, forKey: .valueWhenUnset)
        valueWhenUnset = valueWhenUnsetDecoded
    }
}

extension QuickSightClientTypes {
    /// A parameter declaration for the DateTime data type.
    public struct DateTimeParameterDeclaration: Swift.Equatable {
        /// The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.
        public var defaultValues: QuickSightClientTypes.DateTimeDefaultValues?
        /// The name of the parameter that is being declared.
        /// This member is required.
        public var name: Swift.String?
        /// The level of time precision that is used to aggregate DateTime values.
        public var timeGranularity: QuickSightClientTypes.TimeGranularity?
        /// The configuration that defines the default value of a DateTime parameter when a value has not been set.
        public var valueWhenUnset: QuickSightClientTypes.DateTimeValueWhenUnsetConfiguration?

        public init (
            defaultValues: QuickSightClientTypes.DateTimeDefaultValues? = nil,
            name: Swift.String? = nil,
            timeGranularity: QuickSightClientTypes.TimeGranularity? = nil,
            valueWhenUnset: QuickSightClientTypes.DateTimeValueWhenUnsetConfiguration? = nil
        )
        {
            self.defaultValues = defaultValues
            self.name = name
            self.timeGranularity = timeGranularity
            self.valueWhenUnset = valueWhenUnset
        }
    }

}

extension QuickSightClientTypes.DateTimePickerControlDisplayOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateTimeFormat = "DateTimeFormat"
        case titleOptions = "TitleOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateTimeFormat = self.dateTimeFormat {
            try encodeContainer.encode(dateTimeFormat, forKey: .dateTimeFormat)
        }
        if let titleOptions = self.titleOptions {
            try encodeContainer.encode(titleOptions, forKey: .titleOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LabelOptions.self, forKey: .titleOptions)
        titleOptions = titleOptionsDecoded
        let dateTimeFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateTimeFormat)
        dateTimeFormat = dateTimeFormatDecoded
    }
}

extension QuickSightClientTypes {
    /// The display options of a control.
    public struct DateTimePickerControlDisplayOptions: Swift.Equatable {
        /// Customize how dates are formatted in controls.
        public var dateTimeFormat: Swift.String?
        /// The options to configure the title visibility, name, and font size.
        public var titleOptions: QuickSightClientTypes.LabelOptions?

        public init (
            dateTimeFormat: Swift.String? = nil,
            titleOptions: QuickSightClientTypes.LabelOptions? = nil
        )
        {
            self.dateTimeFormat = dateTimeFormat
            self.titleOptions = titleOptions
        }
    }

}

extension QuickSightClientTypes.DateTimeValueWhenUnsetConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customValue = "CustomValue"
        case valueWhenUnsetOption = "ValueWhenUnsetOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customValue = self.customValue {
            try encodeContainer.encodeTimestamp(customValue, format: .epochSeconds, forKey: .customValue)
        }
        if let valueWhenUnsetOption = self.valueWhenUnsetOption {
            try encodeContainer.encode(valueWhenUnsetOption.rawValue, forKey: .valueWhenUnsetOption)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueWhenUnsetOptionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ValueWhenUnsetOption.self, forKey: .valueWhenUnsetOption)
        valueWhenUnsetOption = valueWhenUnsetOptionDecoded
        let customValueDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .customValue)
        customValue = customValueDecoded
    }
}

extension QuickSightClientTypes.DateTimeValueWhenUnsetConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DateTimeValueWhenUnsetConfiguration(valueWhenUnsetOption: \(Swift.String(describing: valueWhenUnsetOption)), customValue: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {
    /// The configuration that defines the default value of a DateTime parameter when a value has not been set.
    public struct DateTimeValueWhenUnsetConfiguration: Swift.Equatable {
        /// A custom value that's used when the value of a parameter isn't set.
        public var customValue: ClientRuntime.Date?
        /// The built-in options for default values. The value can be one of the following:
        ///
        /// * RECOMMENDED: The recommended value.
        ///
        /// * NULL: The NULL value.
        public var valueWhenUnsetOption: QuickSightClientTypes.ValueWhenUnsetOption?

        public init (
            customValue: ClientRuntime.Date? = nil,
            valueWhenUnsetOption: QuickSightClientTypes.ValueWhenUnsetOption? = nil
        )
        {
            self.customValue = customValue
            self.valueWhenUnsetOption = valueWhenUnsetOption
        }
    }

}

extension QuickSightClientTypes.DecimalDefaultValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dynamicValue = "DynamicValue"
        case staticValues = "StaticValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dynamicValue = self.dynamicValue {
            try encodeContainer.encode(dynamicValue, forKey: .dynamicValue)
        }
        if let staticValues = staticValues {
            var staticValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .staticValues)
            for sensitivedoubleobject0 in staticValues {
                try staticValuesContainer.encode(sensitivedoubleobject0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dynamicValueDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DynamicDefaultValue.self, forKey: .dynamicValue)
        dynamicValue = dynamicValueDecoded
        let staticValuesContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .staticValues)
        var staticValuesDecoded0:[Swift.Double]? = nil
        if let staticValuesContainer = staticValuesContainer {
            staticValuesDecoded0 = [Swift.Double]()
            for double0 in staticValuesContainer {
                if let double0 = double0 {
                    staticValuesDecoded0?.append(double0)
                }
            }
        }
        staticValues = staticValuesDecoded0
    }
}

extension QuickSightClientTypes {
    /// The default values of the DecimalParameterDeclaration.
    public struct DecimalDefaultValues: Swift.Equatable {
        /// The dynamic value of the DecimalDefaultValues. Different defaults are displayed according to users, groups, and values mapping.
        public var dynamicValue: QuickSightClientTypes.DynamicDefaultValue?
        /// The static values of the DecimalDefaultValues.
        public var staticValues: [Swift.Double]?

        public init (
            dynamicValue: QuickSightClientTypes.DynamicDefaultValue? = nil,
            staticValues: [Swift.Double]? = nil
        )
        {
            self.dynamicValue = dynamicValue
            self.staticValues = staticValues
        }
    }

}

extension QuickSightClientTypes.DecimalParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for sensitivedouble0 in values {
                try valuesContainer.encode(sensitivedouble0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .values)
        var valuesDecoded0:[Swift.Double]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.Double]()
            for double0 in valuesContainer {
                if let double0 = double0 {
                    valuesDecoded0?.append(double0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension QuickSightClientTypes {
    /// A decimal parameter.
    public struct DecimalParameter: Swift.Equatable {
        /// A display name for the decimal parameter.
        /// This member is required.
        public var name: Swift.String?
        /// The values for the decimal parameter.
        /// This member is required.
        public var values: [Swift.Double]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.Double]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension QuickSightClientTypes.DecimalParameterDeclaration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValues = "DefaultValues"
        case name = "Name"
        case parameterValueType = "ParameterValueType"
        case valueWhenUnset = "ValueWhenUnset"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValues = self.defaultValues {
            try encodeContainer.encode(defaultValues, forKey: .defaultValues)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameterValueType = self.parameterValueType {
            try encodeContainer.encode(parameterValueType.rawValue, forKey: .parameterValueType)
        }
        if let valueWhenUnset = self.valueWhenUnset {
            try encodeContainer.encode(valueWhenUnset, forKey: .valueWhenUnset)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterValueTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ParameterValueType.self, forKey: .parameterValueType)
        parameterValueType = parameterValueTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let defaultValuesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DecimalDefaultValues.self, forKey: .defaultValues)
        defaultValues = defaultValuesDecoded
        let valueWhenUnsetDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DecimalValueWhenUnsetConfiguration.self, forKey: .valueWhenUnset)
        valueWhenUnset = valueWhenUnsetDecoded
    }
}

extension QuickSightClientTypes {
    /// A parameter declaration for the Decimal data type.
    public struct DecimalParameterDeclaration: Swift.Equatable {
        /// The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.
        public var defaultValues: QuickSightClientTypes.DecimalDefaultValues?
        /// The name of the parameter that is being declared.
        /// This member is required.
        public var name: Swift.String?
        /// The value type determines whether the parameter is a single-value or multi-value parameter.
        /// This member is required.
        public var parameterValueType: QuickSightClientTypes.ParameterValueType?
        /// The configuration that defines the default value of a Decimal parameter when a value has not been set.
        public var valueWhenUnset: QuickSightClientTypes.DecimalValueWhenUnsetConfiguration?

        public init (
            defaultValues: QuickSightClientTypes.DecimalDefaultValues? = nil,
            name: Swift.String? = nil,
            parameterValueType: QuickSightClientTypes.ParameterValueType? = nil,
            valueWhenUnset: QuickSightClientTypes.DecimalValueWhenUnsetConfiguration? = nil
        )
        {
            self.defaultValues = defaultValues
            self.name = name
            self.parameterValueType = parameterValueType
            self.valueWhenUnset = valueWhenUnset
        }
    }

}

extension QuickSightClientTypes.DecimalPlacesConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decimalPlaces = "DecimalPlaces"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decimalPlaces = self.decimalPlaces {
            try encodeContainer.encode(decimalPlaces, forKey: .decimalPlaces)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let decimalPlacesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .decimalPlaces)
        decimalPlaces = decimalPlacesDecoded
    }
}

extension QuickSightClientTypes {
    /// The option that determines the decimal places configuration.
    public struct DecimalPlacesConfiguration: Swift.Equatable {
        /// The values of the decimal places.
        /// This member is required.
        public var decimalPlaces: Swift.Int?

        public init (
            decimalPlaces: Swift.Int? = nil
        )
        {
            self.decimalPlaces = decimalPlaces
        }
    }

}

extension QuickSightClientTypes.DecimalValueWhenUnsetConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customValue = "CustomValue"
        case valueWhenUnsetOption = "ValueWhenUnsetOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customValue = self.customValue {
            try encodeContainer.encode(customValue, forKey: .customValue)
        }
        if let valueWhenUnsetOption = self.valueWhenUnsetOption {
            try encodeContainer.encode(valueWhenUnsetOption.rawValue, forKey: .valueWhenUnsetOption)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueWhenUnsetOptionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ValueWhenUnsetOption.self, forKey: .valueWhenUnsetOption)
        valueWhenUnsetOption = valueWhenUnsetOptionDecoded
        let customValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .customValue)
        customValue = customValueDecoded
    }
}

extension QuickSightClientTypes.DecimalValueWhenUnsetConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DecimalValueWhenUnsetConfiguration(valueWhenUnsetOption: \(Swift.String(describing: valueWhenUnsetOption)), customValue: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {
    /// The configuration that defines the default value of a Decimal parameter when a value has not been set.
    public struct DecimalValueWhenUnsetConfiguration: Swift.Equatable {
        /// A custom value that's used when the value of a parameter isn't set.
        public var customValue: Swift.Double?
        /// The built-in options for default values. The value can be one of the following:
        ///
        /// * RECOMMENDED: The recommended value.
        ///
        /// * NULL: The NULL value.
        public var valueWhenUnsetOption: QuickSightClientTypes.ValueWhenUnsetOption?

        public init (
            customValue: Swift.Double? = nil,
            valueWhenUnsetOption: QuickSightClientTypes.ValueWhenUnsetOption? = nil
        )
        {
            self.customValue = customValue
            self.valueWhenUnsetOption = valueWhenUnsetOption
        }
    }

}

extension QuickSightClientTypes.DefaultFreeFormLayoutConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canvasSizeOptions = "CanvasSizeOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let canvasSizeOptions = self.canvasSizeOptions {
            try encodeContainer.encode(canvasSizeOptions, forKey: .canvasSizeOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let canvasSizeOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FreeFormLayoutCanvasSizeOptions.self, forKey: .canvasSizeOptions)
        canvasSizeOptions = canvasSizeOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the default settings of a free-form layout configuration.
    public struct DefaultFreeFormLayoutConfiguration: Swift.Equatable {
        /// Determines the screen canvas size options for a free-form layout.
        /// This member is required.
        public var canvasSizeOptions: QuickSightClientTypes.FreeFormLayoutCanvasSizeOptions?

        public init (
            canvasSizeOptions: QuickSightClientTypes.FreeFormLayoutCanvasSizeOptions? = nil
        )
        {
            self.canvasSizeOptions = canvasSizeOptions
        }
    }

}

extension QuickSightClientTypes.DefaultGridLayoutConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canvasSizeOptions = "CanvasSizeOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let canvasSizeOptions = self.canvasSizeOptions {
            try encodeContainer.encode(canvasSizeOptions, forKey: .canvasSizeOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let canvasSizeOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GridLayoutCanvasSizeOptions.self, forKey: .canvasSizeOptions)
        canvasSizeOptions = canvasSizeOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the default settings for a grid layout configuration.
    public struct DefaultGridLayoutConfiguration: Swift.Equatable {
        /// Determines the screen canvas size options for a grid layout.
        /// This member is required.
        public var canvasSizeOptions: QuickSightClientTypes.GridLayoutCanvasSizeOptions?

        public init (
            canvasSizeOptions: QuickSightClientTypes.GridLayoutCanvasSizeOptions? = nil
        )
        {
            self.canvasSizeOptions = canvasSizeOptions
        }
    }

}

extension QuickSightClientTypes.DefaultInteractiveLayoutConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case freeForm = "FreeForm"
        case grid = "Grid"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let freeForm = self.freeForm {
            try encodeContainer.encode(freeForm, forKey: .freeForm)
        }
        if let grid = self.grid {
            try encodeContainer.encode(grid, forKey: .grid)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gridDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DefaultGridLayoutConfiguration.self, forKey: .grid)
        grid = gridDecoded
        let freeFormDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DefaultFreeFormLayoutConfiguration.self, forKey: .freeForm)
        freeForm = freeFormDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the default settings for interactive layout configuration.
    public struct DefaultInteractiveLayoutConfiguration: Swift.Equatable {
        /// The options that determine the default settings of a free-form layout configuration.
        public var freeForm: QuickSightClientTypes.DefaultFreeFormLayoutConfiguration?
        /// The options that determine the default settings for a grid layout configuration.
        public var grid: QuickSightClientTypes.DefaultGridLayoutConfiguration?

        public init (
            freeForm: QuickSightClientTypes.DefaultFreeFormLayoutConfiguration? = nil,
            grid: QuickSightClientTypes.DefaultGridLayoutConfiguration? = nil
        )
        {
            self.freeForm = freeForm
            self.grid = grid
        }
    }

}

extension QuickSightClientTypes.DefaultNewSheetConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interactiveLayoutConfiguration = "InteractiveLayoutConfiguration"
        case paginatedLayoutConfiguration = "PaginatedLayoutConfiguration"
        case sheetContentType = "SheetContentType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interactiveLayoutConfiguration = self.interactiveLayoutConfiguration {
            try encodeContainer.encode(interactiveLayoutConfiguration, forKey: .interactiveLayoutConfiguration)
        }
        if let paginatedLayoutConfiguration = self.paginatedLayoutConfiguration {
            try encodeContainer.encode(paginatedLayoutConfiguration, forKey: .paginatedLayoutConfiguration)
        }
        if let sheetContentType = self.sheetContentType {
            try encodeContainer.encode(sheetContentType.rawValue, forKey: .sheetContentType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interactiveLayoutConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DefaultInteractiveLayoutConfiguration.self, forKey: .interactiveLayoutConfiguration)
        interactiveLayoutConfiguration = interactiveLayoutConfigurationDecoded
        let paginatedLayoutConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DefaultPaginatedLayoutConfiguration.self, forKey: .paginatedLayoutConfiguration)
        paginatedLayoutConfiguration = paginatedLayoutConfigurationDecoded
        let sheetContentTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SheetContentType.self, forKey: .sheetContentType)
        sheetContentType = sheetContentTypeDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration for default new sheet settings.
    public struct DefaultNewSheetConfiguration: Swift.Equatable {
        /// The options that determine the default settings for interactive layout configuration.
        public var interactiveLayoutConfiguration: QuickSightClientTypes.DefaultInteractiveLayoutConfiguration?
        /// The options that determine the default settings for a paginated layout configuration.
        public var paginatedLayoutConfiguration: QuickSightClientTypes.DefaultPaginatedLayoutConfiguration?
        /// The option that determines the sheet content type.
        public var sheetContentType: QuickSightClientTypes.SheetContentType?

        public init (
            interactiveLayoutConfiguration: QuickSightClientTypes.DefaultInteractiveLayoutConfiguration? = nil,
            paginatedLayoutConfiguration: QuickSightClientTypes.DefaultPaginatedLayoutConfiguration? = nil,
            sheetContentType: QuickSightClientTypes.SheetContentType? = nil
        )
        {
            self.interactiveLayoutConfiguration = interactiveLayoutConfiguration
            self.paginatedLayoutConfiguration = paginatedLayoutConfiguration
            self.sheetContentType = sheetContentType
        }
    }

}

extension QuickSightClientTypes.DefaultPaginatedLayoutConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sectionBased = "SectionBased"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sectionBased = self.sectionBased {
            try encodeContainer.encode(sectionBased, forKey: .sectionBased)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sectionBasedDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DefaultSectionBasedLayoutConfiguration.self, forKey: .sectionBased)
        sectionBased = sectionBasedDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the default settings for a paginated layout configuration.
    public struct DefaultPaginatedLayoutConfiguration: Swift.Equatable {
        /// The options that determine the default settings for a section-based layout configuration.
        public var sectionBased: QuickSightClientTypes.DefaultSectionBasedLayoutConfiguration?

        public init (
            sectionBased: QuickSightClientTypes.DefaultSectionBasedLayoutConfiguration? = nil
        )
        {
            self.sectionBased = sectionBased
        }
    }

}

extension QuickSightClientTypes.DefaultSectionBasedLayoutConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canvasSizeOptions = "CanvasSizeOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let canvasSizeOptions = self.canvasSizeOptions {
            try encodeContainer.encode(canvasSizeOptions, forKey: .canvasSizeOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let canvasSizeOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SectionBasedLayoutCanvasSizeOptions.self, forKey: .canvasSizeOptions)
        canvasSizeOptions = canvasSizeOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the default settings for a section-based layout configuration.
    public struct DefaultSectionBasedLayoutConfiguration: Swift.Equatable {
        /// Determines the screen canvas size options for a section-based layout.
        /// This member is required.
        public var canvasSizeOptions: QuickSightClientTypes.SectionBasedLayoutCanvasSizeOptions?

        public init (
            canvasSizeOptions: QuickSightClientTypes.SectionBasedLayoutCanvasSizeOptions? = nil
        )
        {
            self.canvasSizeOptions = canvasSizeOptions
        }
    }

}

extension DeleteAccountCustomizationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let namespace = namespace {
                let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
                items.append(namespaceQueryItem)
            }
            return items
        }
    }
}

extension DeleteAccountCustomizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/customizations"
    }
}

public struct DeleteAccountCustomizationInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that you want to delete Amazon QuickSight customizations from in this Amazon Web Services Region.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The Amazon QuickSight namespace that you're deleting the customizations from.
    public var namespace: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
    }
}

struct DeleteAccountCustomizationInputBody: Swift.Equatable {
}

extension DeleteAccountCustomizationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAccountCustomizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccountCustomizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAccountCustomizationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccountCustomizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteAccountCustomizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteAccountCustomizationOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteAccountCustomizationOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DeleteAccountCustomizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension DeleteAccountSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/account/\(awsAccountId.urlPercentEncoding())"
    }
}

public struct DeleteAccountSubscriptionInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the account that you want to delete.
    /// This member is required.
    public var awsAccountId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
    }
}

struct DeleteAccountSubscriptionInputBody: Swift.Equatable {
}

extension DeleteAccountSubscriptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAccountSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccountSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAccountSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccountSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteAccountSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteAccountSubscriptionOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteAccountSubscriptionOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DeleteAccountSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension DeleteAnalysisInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let recoveryWindowInDays = recoveryWindowInDays {
                let recoveryWindowInDaysQueryItem = ClientRuntime.URLQueryItem(name: "recovery-window-in-days".urlPercentEncoding(), value: Swift.String(recoveryWindowInDays).urlPercentEncoding())
                items.append(recoveryWindowInDaysQueryItem)
            }
            if forceDeleteWithoutRecovery != false {
                let forceDeleteWithoutRecoveryQueryItem = ClientRuntime.URLQueryItem(name: "force-delete-without-recovery".urlPercentEncoding(), value: Swift.String(forceDeleteWithoutRecovery).urlPercentEncoding())
                items.append(forceDeleteWithoutRecoveryQueryItem)
            }
            return items
        }
    }
}

extension DeleteAnalysisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let analysisId = analysisId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/analyses/\(analysisId.urlPercentEncoding())"
    }
}

public struct DeleteAnalysisInput: Swift.Equatable {
    /// The ID of the analysis that you're deleting.
    /// This member is required.
    public var analysisId: Swift.String?
    /// The ID of the Amazon Web Services account where you want to delete an analysis.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// This option defaults to the value NoForceDeleteWithoutRecovery. To immediately delete the analysis, add the ForceDeleteWithoutRecovery option. You can't restore an analysis after it's deleted.
    public var forceDeleteWithoutRecovery: Swift.Bool
    /// A value that specifies the number of days that Amazon QuickSight waits before it deletes the analysis. You can't use this parameter with the ForceDeleteWithoutRecovery option in the same API call. The default value is 30.
    public var recoveryWindowInDays: Swift.Int?

    public init (
        analysisId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        forceDeleteWithoutRecovery: Swift.Bool = false,
        recoveryWindowInDays: Swift.Int? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
        self.forceDeleteWithoutRecovery = forceDeleteWithoutRecovery
        self.recoveryWindowInDays = recoveryWindowInDays
    }
}

struct DeleteAnalysisInputBody: Swift.Equatable {
}

extension DeleteAnalysisInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAnalysisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAnalysisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAnalysisOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAnalysisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisId = output.analysisId
            self.arn = output.arn
            self.deletionTime = output.deletionTime
            self.requestId = output.requestId
        } else {
            self.analysisId = nil
            self.arn = nil
            self.deletionTime = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteAnalysisOutputResponse: Swift.Equatable {
    /// The ID of the deleted analysis.
    public var analysisId: Swift.String?
    /// The Amazon Resource Name (ARN) of the deleted analysis.
    public var arn: Swift.String?
    /// The date and time that the analysis is scheduled to be deleted.
    public var deletionTime: ClientRuntime.Date?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        analysisId: Swift.String? = nil,
        arn: Swift.String? = nil,
        deletionTime: ClientRuntime.Date? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.analysisId = analysisId
        self.arn = arn
        self.deletionTime = deletionTime
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteAnalysisOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let arn: Swift.String?
    let analysisId: Swift.String?
    let deletionTime: ClientRuntime.Date?
    let requestId: Swift.String?
}

extension DeleteAnalysisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisId = "AnalysisId"
        case arn = "Arn"
        case deletionTime = "DeletionTime"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let analysisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
        let deletionTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deletionTime)
        deletionTime = deletionTimeDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DeleteDashboardInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let versionNumber = versionNumber {
                let versionNumberQueryItem = ClientRuntime.URLQueryItem(name: "version-number".urlPercentEncoding(), value: Swift.String(versionNumber).urlPercentEncoding())
                items.append(versionNumberQueryItem)
            }
            return items
        }
    }
}

extension DeleteDashboardInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dashboardId = dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())"
    }
}

public struct DeleteDashboardInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the dashboard that you're deleting.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// The version number of the dashboard. If the version number property is provided, only the specified version of the dashboard is deleted.
    public var versionNumber: Swift.Int?

    public init (
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.versionNumber = versionNumber
    }
}

struct DeleteDashboardInputBody: Swift.Equatable {
}

extension DeleteDashboardInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDashboardOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDashboardOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDashboardOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDashboardOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteDashboardOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.dashboardId = output.dashboardId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.dashboardId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteDashboardOutputResponse: Swift.Equatable {
    /// The Secure Socket Layer (SSL) properties that apply for the resource.
    public var arn: Swift.String?
    /// The ID of the dashboard.
    public var dashboardId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.dashboardId = dashboardId
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteDashboardOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let arn: Swift.String?
    let dashboardId: Swift.String?
    let requestId: Swift.String?
}

extension DeleteDashboardOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case dashboardId = "DashboardId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let dashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DeleteDataSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSetId = dataSetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())"
    }
}

public struct DeleteDataSetInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSetId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
    }
}

struct DeleteDataSetInputBody: Swift.Equatable {
}

extension DeleteDataSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDataSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDataSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDataSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDataSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteDataSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.dataSetId = output.dataSetId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.dataSetId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteDataSetOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset.
    public var arn: Swift.String?
    /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSetId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.dataSetId = dataSetId
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteDataSetOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let dataSetId: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DeleteDataSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case dataSetId = "DataSetId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension DeleteDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSourceId = dataSourceId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sources/\(dataSourceId.urlPercentEncoding())"
    }
}

public struct DeleteDataSourceInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSourceId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSourceId = dataSourceId
    }
}

struct DeleteDataSourceInputBody: Swift.Equatable {
}

extension DeleteDataSourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDataSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDataSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDataSourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDataSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.dataSourceId = output.dataSourceId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.dataSourceId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteDataSourceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the data source that you deleted.
    public var arn: Swift.String?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSourceId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.dataSourceId = dataSourceId
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteDataSourceOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let dataSourceId: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DeleteDataSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case dataSourceId = "DataSourceId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension DeleteFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let folderId = folderId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())"
    }
}

public struct DeleteFolderInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
    }
}

struct DeleteFolderInputBody: Swift.Equatable {
}

extension DeleteFolderInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFolderMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let folderId = folderId else {
            return nil
        }
        guard let memberType = memberType else {
            return nil
        }
        guard let memberId = memberId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())/members/\(memberType.rawValue.urlPercentEncoding())/\(memberId.urlPercentEncoding())"
    }
}

public struct DeleteFolderMembershipInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The Folder ID.
    /// This member is required.
    public var folderId: Swift.String?
    /// The ID of the asset (the dashboard, analysis, or dataset) that you want to delete.
    /// This member is required.
    public var memberId: Swift.String?
    /// The type of the member, including DASHBOARD, ANALYSIS, and DATASET
    /// This member is required.
    public var memberType: QuickSightClientTypes.MemberType?

    public init (
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil,
        memberId: Swift.String? = nil,
        memberType: QuickSightClientTypes.MemberType? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
        self.memberId = memberId
        self.memberType = memberType
    }
}

struct DeleteFolderMembershipInputBody: Swift.Equatable {
}

extension DeleteFolderMembershipInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFolderMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFolderMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteFolderMembershipOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFolderMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteFolderMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.status = output.status
        } else {
            self.requestId = nil
            self.status = 0
        }
    }
}

public struct DeleteFolderMembershipOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteFolderMembershipOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let requestId: Swift.String?
}

extension DeleteFolderMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DeleteFolderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFolderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteFolderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFolderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteFolderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.folderId = output.folderId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.folderId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteFolderOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name of the deleted folder.
    public var arn: Swift.String?
    /// The ID of the folder.
    public var folderId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        folderId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.folderId = folderId
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteFolderOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let arn: Swift.String?
    let folderId: Swift.String?
    let requestId: Swift.String?
}

extension DeleteFolderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case folderId = "FolderId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let folderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .folderId)
        folderId = folderIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DeleteGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let groupName = groupName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups/\(groupName.urlPercentEncoding())"
    }
}

public struct DeleteGroupInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The name of the group that you want to delete.
    /// This member is required.
    public var groupName: Swift.String?
    /// The namespace of the group that you want to delete.
    /// This member is required.
    public var namespace: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.groupName = groupName
        self.namespace = namespace
    }
}

struct DeleteGroupInputBody: Swift.Equatable {
}

extension DeleteGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGroupMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let groupName = groupName else {
            return nil
        }
        guard let memberName = memberName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups/\(groupName.urlPercentEncoding())/members/\(memberName.urlPercentEncoding())"
    }
}

public struct DeleteGroupMembershipInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The name of the group that you want to delete the user from.
    /// This member is required.
    public var groupName: Swift.String?
    /// The name of the user that you want to delete from the group membership.
    /// This member is required.
    public var memberName: Swift.String?
    /// The namespace of the group that you want to remove a user from.
    /// This member is required.
    public var namespace: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        memberName: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.groupName = groupName
        self.memberName = memberName
        self.namespace = namespace
    }
}

struct DeleteGroupMembershipInputBody: Swift.Equatable {
}

extension DeleteGroupMembershipInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGroupMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGroupMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteGroupMembershipOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGroupMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteGroupMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteGroupMembershipOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteGroupMembershipOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DeleteGroupMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension DeleteGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteGroupOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteGroupOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DeleteGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension DeleteIAMPolicyAssignmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let assignmentName = assignmentName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespace/\(namespace.urlPercentEncoding())/iam-policy-assignments/\(assignmentName.urlPercentEncoding())"
    }
}

public struct DeleteIAMPolicyAssignmentInput: Swift.Equatable {
    /// The name of the assignment.
    /// This member is required.
    public var assignmentName: Swift.String?
    /// The Amazon Web Services account ID where you want to delete the IAM policy assignment.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace that contains the assignment.
    /// This member is required.
    public var namespace: Swift.String?

    public init (
        assignmentName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.assignmentName = assignmentName
        self.awsAccountId = awsAccountId
        self.namespace = namespace
    }
}

struct DeleteIAMPolicyAssignmentInputBody: Swift.Equatable {
}

extension DeleteIAMPolicyAssignmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIAMPolicyAssignmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIAMPolicyAssignmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentUpdatingException" : self = .concurrentUpdatingException(try ConcurrentUpdatingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteIAMPolicyAssignmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case concurrentUpdatingException(ConcurrentUpdatingException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIAMPolicyAssignmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteIAMPolicyAssignmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assignmentName = output.assignmentName
            self.requestId = output.requestId
        } else {
            self.assignmentName = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteIAMPolicyAssignmentOutputResponse: Swift.Equatable {
    /// The name of the assignment.
    public var assignmentName: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        assignmentName: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.assignmentName = assignmentName
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteIAMPolicyAssignmentOutputResponseBody: Swift.Equatable {
    let assignmentName: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DeleteIAMPolicyAssignmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentName = "AssignmentName"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentName)
        assignmentName = assignmentNameDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension DeleteNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())"
    }
}

public struct DeleteNamespaceInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that you want to delete the Amazon QuickSight namespace from.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace that you want to delete.
    /// This member is required.
    public var namespace: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
    }
}

struct DeleteNamespaceInputBody: Swift.Equatable {
}

extension DeleteNamespaceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteNamespaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteNamespaceOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteNamespaceOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DeleteNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension DeleteTemplateAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        guard let aliasName = aliasName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/aliases/\(aliasName.urlPercentEncoding())"
    }
}

public struct DeleteTemplateAliasInput: Swift.Equatable {
    /// The name for the template alias. To delete a specific alias, you delete the version that the alias points to. You can specify the alias name, or specify the latest version of the template by providing the keyword $LATEST in the AliasName parameter.
    /// This member is required.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the item to delete.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the template that the specified alias is for.
    /// This member is required.
    public var templateId: Swift.String?

    public init (
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.templateId = templateId
    }
}

struct DeleteTemplateAliasInputBody: Swift.Equatable {
}

extension DeleteTemplateAliasInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTemplateAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTemplateAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteTemplateAliasOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTemplateAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteTemplateAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aliasName = output.aliasName
            self.arn = output.arn
            self.requestId = output.requestId
            self.templateId = output.templateId
        } else {
            self.aliasName = nil
            self.arn = nil
            self.requestId = nil
            self.templateId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteTemplateAliasOutputResponse: Swift.Equatable {
    /// The name for the template alias.
    public var aliasName: Swift.String?
    /// The Amazon Resource Name (ARN) of the template you want to delete.
    public var arn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// An ID for the template associated with the deletion.
    public var templateId: Swift.String?

    public init (
        aliasName: Swift.String? = nil,
        arn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateId: Swift.String? = nil
    )
    {
        self.aliasName = aliasName
        self.arn = arn
        self.requestId = requestId
        self.status = status
        self.templateId = templateId
    }
}

struct DeleteTemplateAliasOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let templateId: Swift.String?
    let aliasName: Swift.String?
    let arn: Swift.String?
    let requestId: Swift.String?
}

extension DeleteTemplateAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasName = "AliasName"
        case arn = "Arn"
        case requestId = "RequestId"
        case status = "Status"
        case templateId = "TemplateId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let aliasNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasName)
        aliasName = aliasNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DeleteTemplateInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let versionNumber = versionNumber {
                let versionNumberQueryItem = ClientRuntime.URLQueryItem(name: "version-number".urlPercentEncoding(), value: Swift.String(versionNumber).urlPercentEncoding())
                items.append(versionNumberQueryItem)
            }
            return items
        }
    }
}

extension DeleteTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())"
    }
}

public struct DeleteTemplateInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the template that you're deleting.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// An ID for the template you want to delete.
    /// This member is required.
    public var templateId: Swift.String?
    /// Specifies the version of the template that you want to delete. If you don't provide a version number, DeleteTemplate deletes all versions of the template.
    public var versionNumber: Swift.Int?

    public init (
        awsAccountId: Swift.String? = nil,
        templateId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.templateId = templateId
        self.versionNumber = versionNumber
    }
}

struct DeleteTemplateInputBody: Swift.Equatable {
}

extension DeleteTemplateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteTemplateOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.requestId = output.requestId
            self.templateId = output.templateId
        } else {
            self.arn = nil
            self.requestId = nil
            self.templateId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteTemplateOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    public var arn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// An ID for the template.
    public var templateId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.requestId = requestId
        self.status = status
        self.templateId = templateId
    }
}

struct DeleteTemplateOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let arn: Swift.String?
    let templateId: Swift.String?
    let status: Swift.Int
}

extension DeleteTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case requestId = "RequestId"
        case status = "Status"
        case templateId = "TemplateId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension DeleteThemeAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let themeId = themeId else {
            return nil
        }
        guard let aliasName = aliasName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())/aliases/\(aliasName.urlPercentEncoding())"
    }
}

public struct DeleteThemeAliasInput: Swift.Equatable {
    /// The unique name for the theme alias to delete.
    /// This member is required.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the theme alias to delete.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the theme that the specified alias is for.
    /// This member is required.
    public var themeId: Swift.String?

    public init (
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        themeId: Swift.String? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.themeId = themeId
    }
}

struct DeleteThemeAliasInputBody: Swift.Equatable {
}

extension DeleteThemeAliasInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteThemeAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteThemeAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteThemeAliasOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteThemeAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteThemeAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aliasName = output.aliasName
            self.arn = output.arn
            self.requestId = output.requestId
            self.themeId = output.themeId
        } else {
            self.aliasName = nil
            self.arn = nil
            self.requestId = nil
            self.themeId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteThemeAliasOutputResponse: Swift.Equatable {
    /// The name for the theme alias.
    public var aliasName: Swift.String?
    /// The Amazon Resource Name (ARN) of the theme resource using the deleted alias.
    public var arn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// An ID for the theme associated with the deletion.
    public var themeId: Swift.String?

    public init (
        aliasName: Swift.String? = nil,
        arn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeId: Swift.String? = nil
    )
    {
        self.aliasName = aliasName
        self.arn = arn
        self.requestId = requestId
        self.status = status
        self.themeId = themeId
    }
}

struct DeleteThemeAliasOutputResponseBody: Swift.Equatable {
    let aliasName: Swift.String?
    let arn: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
    let themeId: Swift.String?
}

extension DeleteThemeAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasName = "AliasName"
        case arn = "Arn"
        case requestId = "RequestId"
        case status = "Status"
        case themeId = "ThemeId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasName)
        aliasName = aliasNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let themeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeId)
        themeId = themeIdDecoded
    }
}

extension DeleteThemeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let versionNumber = versionNumber {
                let versionNumberQueryItem = ClientRuntime.URLQueryItem(name: "version-number".urlPercentEncoding(), value: Swift.String(versionNumber).urlPercentEncoding())
                items.append(versionNumberQueryItem)
            }
            return items
        }
    }
}

extension DeleteThemeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let themeId = themeId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())"
    }
}

public struct DeleteThemeInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the theme that you're deleting.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// An ID for the theme that you want to delete.
    /// This member is required.
    public var themeId: Swift.String?
    /// The version of the theme that you want to delete. Note: If you don't provide a version number, you're using this call to DeleteTheme to delete all versions of the theme.
    public var versionNumber: Swift.Int?

    public init (
        awsAccountId: Swift.String? = nil,
        themeId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.themeId = themeId
        self.versionNumber = versionNumber
    }
}

struct DeleteThemeInputBody: Swift.Equatable {
}

extension DeleteThemeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteThemeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteThemeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteThemeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteThemeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteThemeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.requestId = output.requestId
            self.themeId = output.themeId
        } else {
            self.arn = nil
            self.requestId = nil
            self.themeId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteThemeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    public var arn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// An ID for the theme.
    public var themeId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.requestId = requestId
        self.status = status
        self.themeId = themeId
    }
}

struct DeleteThemeOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
    let themeId: Swift.String?
}

extension DeleteThemeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case requestId = "RequestId"
        case status = "Status"
        case themeId = "ThemeId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let themeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeId)
        themeId = themeIdDecoded
    }
}

extension DeleteUserByPrincipalIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let principalId = principalId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/user-principals/\(principalId.urlPercentEncoding())"
    }
}

///
public struct DeleteUserByPrincipalIdInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// The principal ID of the user.
    /// This member is required.
    public var principalId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        principalId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.principalId = principalId
    }
}

struct DeleteUserByPrincipalIdInputBody: Swift.Equatable {
}

extension DeleteUserByPrincipalIdInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUserByPrincipalIdOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserByPrincipalIdOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteUserByPrincipalIdOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserByPrincipalIdOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteUserByPrincipalIdOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteUserByPrincipalIdOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteUserByPrincipalIdOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DeleteUserByPrincipalIdOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension DeleteUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let userName = userName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/users/\(userName.urlPercentEncoding())"
    }
}

public struct DeleteUserInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// The name of the user that you want to delete.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.userName = userName
    }
}

struct DeleteUserInputBody: Swift.Equatable {
}

extension DeleteUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DeleteUserOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct DeleteUserOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DeleteUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension DescribeAccountCustomizationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if resolved != false {
                let resolvedQueryItem = ClientRuntime.URLQueryItem(name: "resolved".urlPercentEncoding(), value: Swift.String(resolved).urlPercentEncoding())
                items.append(resolvedQueryItem)
            }
            if let namespace = namespace {
                let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
                items.append(namespaceQueryItem)
            }
            return items
        }
    }
}

extension DescribeAccountCustomizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/customizations"
    }
}

public struct DescribeAccountCustomizationInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that you want to describe Amazon QuickSight customizations for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The Amazon QuickSight namespace that you want to describe Amazon QuickSight customizations for.
    public var namespace: Swift.String?
    /// The Resolved flag works with the other parameters to determine which view of Amazon QuickSight customizations is returned. You can add this flag to your command to use the same view that Amazon QuickSight uses to identify which customizations to apply to the console. Omit this flag, or set it to no-resolved, to reveal customizations that are configured at different levels.
    public var resolved: Swift.Bool

    public init (
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        resolved: Swift.Bool = false
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.resolved = resolved
    }
}

struct DescribeAccountCustomizationInputBody: Swift.Equatable {
}

extension DescribeAccountCustomizationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAccountCustomizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountCustomizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAccountCustomizationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountCustomizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAccountCustomizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountCustomization = output.accountCustomization
            self.arn = output.arn
            self.awsAccountId = output.awsAccountId
            self.namespace = output.namespace
            self.requestId = output.requestId
        } else {
            self.accountCustomization = nil
            self.arn = nil
            self.awsAccountId = nil
            self.namespace = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeAccountCustomizationOutputResponse: Swift.Equatable {
    /// The Amazon QuickSight customizations that exist in the current Amazon Web Services Region.
    public var accountCustomization: QuickSightClientTypes.AccountCustomization?
    /// The Amazon Resource Name (ARN) of the customization that's associated with this Amazon Web Services account.
    public var arn: Swift.String?
    /// The ID for the Amazon Web Services account that you're describing.
    public var awsAccountId: Swift.String?
    /// The Amazon QuickSight namespace that you're describing.
    public var namespace: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        accountCustomization: QuickSightClientTypes.AccountCustomization? = nil,
        arn: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.accountCustomization = accountCustomization
        self.arn = arn
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeAccountCustomizationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let awsAccountId: Swift.String?
    let namespace: Swift.String?
    let accountCustomization: QuickSightClientTypes.AccountCustomization?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeAccountCustomizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountCustomization = "AccountCustomization"
        case arn = "Arn"
        case awsAccountId = "AwsAccountId"
        case namespace = "Namespace"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let accountCustomizationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AccountCustomization.self, forKey: .accountCustomization)
        accountCustomization = accountCustomizationDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension DescribeAccountSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/settings"
    }
}

public struct DescribeAccountSettingsInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the settings that you want to list.
    /// This member is required.
    public var awsAccountId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
    }
}

struct DescribeAccountSettingsInputBody: Swift.Equatable {
}

extension DescribeAccountSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAccountSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAccountSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAccountSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountSettings = output.accountSettings
            self.requestId = output.requestId
        } else {
            self.accountSettings = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeAccountSettingsOutputResponse: Swift.Equatable {
    /// The Amazon QuickSight settings for this Amazon Web Services account. This information includes the edition of Amazon Amazon QuickSight that you subscribed to (Standard or Enterprise) and the notification email for the Amazon QuickSight subscription. In the QuickSight console, the Amazon QuickSight subscription is sometimes referred to as a QuickSight "account" even though it's technically not an account by itself. Instead, it's a subscription to the Amazon QuickSight service for your Amazon Web Services account. The edition that you subscribe to applies to Amazon QuickSight in every Amazon Web Services Region where you use it.
    public var accountSettings: QuickSightClientTypes.AccountSettings?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        accountSettings: QuickSightClientTypes.AccountSettings? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.accountSettings = accountSettings
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeAccountSettingsOutputResponseBody: Swift.Equatable {
    let accountSettings: QuickSightClientTypes.AccountSettings?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeAccountSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountSettings = "AccountSettings"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountSettingsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AccountSettings.self, forKey: .accountSettings)
        accountSettings = accountSettingsDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension DescribeAccountSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/account/\(awsAccountId.urlPercentEncoding())"
    }
}

public struct DescribeAccountSubscriptionInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
    }
}

struct DescribeAccountSubscriptionInputBody: Swift.Equatable {
}

extension DescribeAccountSubscriptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAccountSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAccountSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAccountSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountInfo = output.accountInfo
            self.requestId = output.requestId
        } else {
            self.accountInfo = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeAccountSubscriptionOutputResponse: Swift.Equatable {
    /// A structure that contains the following elements:
    ///
    /// * Your Amazon QuickSight account name.
    ///
    /// * The edition of Amazon QuickSight that your account is using.
    ///
    /// * The notification email address that is associated with the Amazon QuickSight account.
    ///
    /// * The authentication type of the Amazon QuickSight account.
    ///
    /// * The status of the Amazon QuickSight account's subscription.
    public var accountInfo: QuickSightClientTypes.AccountInfo?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        accountInfo: QuickSightClientTypes.AccountInfo? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.accountInfo = accountInfo
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeAccountSubscriptionOutputResponseBody: Swift.Equatable {
    let accountInfo: QuickSightClientTypes.AccountInfo?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension DescribeAccountSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountInfo = "AccountInfo"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountInfoDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AccountInfo.self, forKey: .accountInfo)
        accountInfo = accountInfoDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeAnalysisDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let analysisId = analysisId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/analyses/\(analysisId.urlPercentEncoding())/definition"
    }
}

public struct DescribeAnalysisDefinitionInput: Swift.Equatable {
    /// The ID of the analysis that you're describing. The ID is part of the URL of the analysis.
    /// This member is required.
    public var analysisId: Swift.String?
    /// The ID of the Amazon Web Services account that contains the analysis. You must be using the Amazon Web Services account that the analysis is in.
    /// This member is required.
    public var awsAccountId: Swift.String?

    public init (
        analysisId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
    }
}

struct DescribeAnalysisDefinitionInputBody: Swift.Equatable {
}

extension DescribeAnalysisDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAnalysisDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAnalysisDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAnalysisDefinitionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAnalysisDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAnalysisDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisId = output.analysisId
            self.definition = output.definition
            self.errors = output.errors
            self.name = output.name
            self.requestId = output.requestId
            self.resourceStatus = output.resourceStatus
            self.themeArn = output.themeArn
        } else {
            self.analysisId = nil
            self.definition = nil
            self.errors = nil
            self.name = nil
            self.requestId = nil
            self.resourceStatus = nil
            self.themeArn = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeAnalysisDefinitionOutputResponse: Swift.Equatable {
    /// The ID of the analysis described.
    public var analysisId: Swift.String?
    /// The definition of an analysis. A definition is the data model of all features in a Dashboard, Template, or Analysis.
    public var definition: QuickSightClientTypes.AnalysisDefinition?
    /// Errors associated with the analysis.
    public var errors: [QuickSightClientTypes.AnalysisError]?
    /// The descriptive name of the analysis.
    public var name: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// Status associated with the analysis.
    ///
    /// * CREATION_IN_PROGRESS
    ///
    /// * CREATION_SUCCESSFUL
    ///
    /// * CREATION_FAILED
    ///
    /// * UPDATE_IN_PROGRESS
    ///
    /// * UPDATE_SUCCESSFUL
    ///
    /// * UPDATE_FAILED
    ///
    /// * DELETED
    public var resourceStatus: QuickSightClientTypes.ResourceStatus?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ARN of the theme of the analysis.
    public var themeArn: Swift.String?

    public init (
        analysisId: Swift.String? = nil,
        definition: QuickSightClientTypes.AnalysisDefinition? = nil,
        errors: [QuickSightClientTypes.AnalysisError]? = nil,
        name: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceStatus: QuickSightClientTypes.ResourceStatus? = nil,
        status: Swift.Int = 0,
        themeArn: Swift.String? = nil
    )
    {
        self.analysisId = analysisId
        self.definition = definition
        self.errors = errors
        self.name = name
        self.requestId = requestId
        self.resourceStatus = resourceStatus
        self.status = status
        self.themeArn = themeArn
    }
}

struct DescribeAnalysisDefinitionOutputResponseBody: Swift.Equatable {
    let analysisId: Swift.String?
    let name: Swift.String?
    let errors: [QuickSightClientTypes.AnalysisError]?
    let resourceStatus: QuickSightClientTypes.ResourceStatus?
    let themeArn: Swift.String?
    let definition: QuickSightClientTypes.AnalysisDefinition?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension DescribeAnalysisDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisId = "AnalysisId"
        case definition = "Definition"
        case errors = "Errors"
        case name = "Name"
        case requestId = "RequestId"
        case resourceStatus = "ResourceStatus"
        case status = "Status"
        case themeArn = "ThemeArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let errorsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.AnalysisError?].self, forKey: .errors)
        var errorsDecoded0:[QuickSightClientTypes.AnalysisError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [QuickSightClientTypes.AnalysisError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let resourceStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .resourceStatus)
        resourceStatus = resourceStatusDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AnalysisDefinition.self, forKey: .definition)
        definition = definitionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeAnalysisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let analysisId = analysisId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/analyses/\(analysisId.urlPercentEncoding())"
    }
}

public struct DescribeAnalysisInput: Swift.Equatable {
    /// The ID of the analysis that you're describing. The ID is part of the URL of the analysis.
    /// This member is required.
    public var analysisId: Swift.String?
    /// The ID of the Amazon Web Services account that contains the analysis. You must be using the Amazon Web Services account that the analysis is in.
    /// This member is required.
    public var awsAccountId: Swift.String?

    public init (
        analysisId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
    }
}

struct DescribeAnalysisInputBody: Swift.Equatable {
}

extension DescribeAnalysisInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAnalysisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAnalysisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAnalysisOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAnalysisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysis = output.analysis
            self.requestId = output.requestId
        } else {
            self.analysis = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeAnalysisOutputResponse: Swift.Equatable {
    /// A metadata structure that contains summary information for the analysis that you're describing.
    public var analysis: QuickSightClientTypes.Analysis?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        analysis: QuickSightClientTypes.Analysis? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.analysis = analysis
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeAnalysisOutputResponseBody: Swift.Equatable {
    let analysis: QuickSightClientTypes.Analysis?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension DescribeAnalysisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysis = "Analysis"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Analysis.self, forKey: .analysis)
        analysis = analysisDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeAnalysisPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let analysisId = analysisId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/analyses/\(analysisId.urlPercentEncoding())/permissions"
    }
}

public struct DescribeAnalysisPermissionsInput: Swift.Equatable {
    /// The ID of the analysis whose permissions you're describing. The ID is part of the analysis URL.
    /// This member is required.
    public var analysisId: Swift.String?
    /// The ID of the Amazon Web Services account that contains the analysis whose permissions you're describing. You must be using the Amazon Web Services account that the analysis is in.
    /// This member is required.
    public var awsAccountId: Swift.String?

    public init (
        analysisId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
    }
}

struct DescribeAnalysisPermissionsInputBody: Swift.Equatable {
}

extension DescribeAnalysisPermissionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAnalysisPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAnalysisPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAnalysisPermissionsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAnalysisPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAnalysisPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisArn = output.analysisArn
            self.analysisId = output.analysisId
            self.permissions = output.permissions
            self.requestId = output.requestId
        } else {
            self.analysisArn = nil
            self.analysisId = nil
            self.permissions = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeAnalysisPermissionsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the analysis whose permissions you're describing.
    public var analysisArn: Swift.String?
    /// The ID of the analysis whose permissions you're describing.
    public var analysisId: Swift.String?
    /// A structure that describes the principals and the resource-level permissions on an analysis.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        analysisArn: Swift.String? = nil,
        analysisId: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.analysisArn = analysisArn
        self.analysisId = analysisId
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeAnalysisPermissionsOutputResponseBody: Swift.Equatable {
    let analysisId: Swift.String?
    let analysisArn: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension DescribeAnalysisPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisArn = "AnalysisArn"
        case analysisId = "AnalysisId"
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
        let analysisArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisArn)
        analysisArn = analysisArnDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeDashboardDefinitionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let aliasName = aliasName {
                let aliasNameQueryItem = ClientRuntime.URLQueryItem(name: "alias-name".urlPercentEncoding(), value: Swift.String(aliasName).urlPercentEncoding())
                items.append(aliasNameQueryItem)
            }
            if let versionNumber = versionNumber {
                let versionNumberQueryItem = ClientRuntime.URLQueryItem(name: "version-number".urlPercentEncoding(), value: Swift.String(versionNumber).urlPercentEncoding())
                items.append(versionNumberQueryItem)
            }
            return items
        }
    }
}

extension DescribeDashboardDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dashboardId = dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())/definition"
    }
}

public struct DescribeDashboardDefinitionInput: Swift.Equatable {
    /// The alias name.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the dashboard that you're describing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// The version number for the dashboard. If a version number isn't passed, the latest published dashboard version is described.
    public var versionNumber: Swift.Int?

    public init (
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.versionNumber = versionNumber
    }
}

struct DescribeDashboardDefinitionInputBody: Swift.Equatable {
}

extension DescribeDashboardDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDashboardDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDashboardDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDashboardDefinitionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDashboardDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDashboardDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dashboardId = output.dashboardId
            self.definition = output.definition
            self.errors = output.errors
            self.name = output.name
            self.requestId = output.requestId
            self.resourceStatus = output.resourceStatus
            self.themeArn = output.themeArn
        } else {
            self.dashboardId = nil
            self.definition = nil
            self.errors = nil
            self.name = nil
            self.requestId = nil
            self.resourceStatus = nil
            self.themeArn = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeDashboardDefinitionOutputResponse: Swift.Equatable {
    /// The ID of the dashboard described.
    public var dashboardId: Swift.String?
    /// The definition of a dashboard. A definition is the data model of all features in a Dashboard, Template, or Analysis.
    public var definition: QuickSightClientTypes.DashboardVersionDefinition?
    /// Errors associated with this dashboard version.
    public var errors: [QuickSightClientTypes.DashboardError]?
    /// The display name of the dashboard.
    public var name: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// Status associated with the dashboard version.
    ///
    /// * CREATION_IN_PROGRESS
    ///
    /// * CREATION_SUCCESSFUL
    ///
    /// * CREATION_FAILED
    ///
    /// * UPDATE_IN_PROGRESS
    ///
    /// * UPDATE_SUCCESSFUL
    ///
    /// * UPDATE_FAILED
    ///
    /// * DELETED
    public var resourceStatus: QuickSightClientTypes.ResourceStatus?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ARN of the theme of the dashboard.
    public var themeArn: Swift.String?

    public init (
        dashboardId: Swift.String? = nil,
        definition: QuickSightClientTypes.DashboardVersionDefinition? = nil,
        errors: [QuickSightClientTypes.DashboardError]? = nil,
        name: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceStatus: QuickSightClientTypes.ResourceStatus? = nil,
        status: Swift.Int = 0,
        themeArn: Swift.String? = nil
    )
    {
        self.dashboardId = dashboardId
        self.definition = definition
        self.errors = errors
        self.name = name
        self.requestId = requestId
        self.resourceStatus = resourceStatus
        self.status = status
        self.themeArn = themeArn
    }
}

struct DescribeDashboardDefinitionOutputResponseBody: Swift.Equatable {
    let dashboardId: Swift.String?
    let errors: [QuickSightClientTypes.DashboardError]?
    let name: Swift.String?
    let resourceStatus: QuickSightClientTypes.ResourceStatus?
    let themeArn: Swift.String?
    let definition: QuickSightClientTypes.DashboardVersionDefinition?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension DescribeDashboardDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardId = "DashboardId"
        case definition = "Definition"
        case errors = "Errors"
        case name = "Name"
        case requestId = "RequestId"
        case resourceStatus = "ResourceStatus"
        case status = "Status"
        case themeArn = "ThemeArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let errorsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DashboardError?].self, forKey: .errors)
        var errorsDecoded0:[QuickSightClientTypes.DashboardError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [QuickSightClientTypes.DashboardError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourceStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .resourceStatus)
        resourceStatus = resourceStatusDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardVersionDefinition.self, forKey: .definition)
        definition = definitionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeDashboardInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let aliasName = aliasName {
                let aliasNameQueryItem = ClientRuntime.URLQueryItem(name: "alias-name".urlPercentEncoding(), value: Swift.String(aliasName).urlPercentEncoding())
                items.append(aliasNameQueryItem)
            }
            if let versionNumber = versionNumber {
                let versionNumberQueryItem = ClientRuntime.URLQueryItem(name: "version-number".urlPercentEncoding(), value: Swift.String(versionNumber).urlPercentEncoding())
                items.append(versionNumberQueryItem)
            }
            return items
        }
    }
}

extension DescribeDashboardInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dashboardId = dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())"
    }
}

public struct DescribeDashboardInput: Swift.Equatable {
    /// The alias name.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the dashboard that you're describing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// The version number for the dashboard. If a version number isn't passed, the latest published dashboard version is described.
    public var versionNumber: Swift.Int?

    public init (
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.versionNumber = versionNumber
    }
}

struct DescribeDashboardInputBody: Swift.Equatable {
}

extension DescribeDashboardInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDashboardOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDashboardOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDashboardOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDashboardOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDashboardOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dashboard = output.dashboard
            self.requestId = output.requestId
        } else {
            self.dashboard = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeDashboardOutputResponse: Swift.Equatable {
    /// Information about the dashboard.
    public var dashboard: QuickSightClientTypes.Dashboard?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of this request.
    public var status: Swift.Int

    public init (
        dashboard: QuickSightClientTypes.Dashboard? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dashboard = dashboard
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeDashboardOutputResponseBody: Swift.Equatable {
    let dashboard: QuickSightClientTypes.Dashboard?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension DescribeDashboardOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboard = "Dashboard"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Dashboard.self, forKey: .dashboard)
        dashboard = dashboardDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeDashboardPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dashboardId = dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())/permissions"
    }
}

public struct DescribeDashboardPermissionsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the dashboard that you're describing permissions for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard, also added to the IAM policy.
    /// This member is required.
    public var dashboardId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
    }
}

struct DescribeDashboardPermissionsInputBody: Swift.Equatable {
}

extension DescribeDashboardPermissionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDashboardPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDashboardPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDashboardPermissionsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDashboardPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDashboardPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dashboardArn = output.dashboardArn
            self.dashboardId = output.dashboardId
            self.linkSharingConfiguration = output.linkSharingConfiguration
            self.permissions = output.permissions
            self.requestId = output.requestId
        } else {
            self.dashboardArn = nil
            self.dashboardId = nil
            self.linkSharingConfiguration = nil
            self.permissions = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeDashboardPermissionsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dashboard.
    public var dashboardArn: Swift.String?
    /// The ID for the dashboard.
    public var dashboardId: Swift.String?
    /// A structure that contains the configuration of a shareable link that grants access to the dashboard. Your users can use the link to view and interact with the dashboard, if the dashboard has been shared with them. For more information about sharing dashboards, see [Sharing Dashboards](https://docs.aws.amazon.com/quicksight/latest/user/sharing-a-dashboard.html).
    public var linkSharingConfiguration: QuickSightClientTypes.LinkSharingConfiguration?
    /// A structure that contains the permissions for the dashboard.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dashboardArn: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        linkSharingConfiguration: QuickSightClientTypes.LinkSharingConfiguration? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dashboardArn = dashboardArn
        self.dashboardId = dashboardId
        self.linkSharingConfiguration = linkSharingConfiguration
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeDashboardPermissionsOutputResponseBody: Swift.Equatable {
    let dashboardId: Swift.String?
    let dashboardArn: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let status: Swift.Int
    let requestId: Swift.String?
    let linkSharingConfiguration: QuickSightClientTypes.LinkSharingConfiguration?
}

extension DescribeDashboardPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardArn = "DashboardArn"
        case dashboardId = "DashboardId"
        case linkSharingConfiguration = "LinkSharingConfiguration"
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let dashboardArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardArn)
        dashboardArn = dashboardArnDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let linkSharingConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LinkSharingConfiguration.self, forKey: .linkSharingConfiguration)
        linkSharingConfiguration = linkSharingConfigurationDecoded
    }
}

extension DescribeDataSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSetId = dataSetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())"
    }
}

public struct DescribeDataSetInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSetId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
    }
}

struct DescribeDataSetInputBody: Swift.Equatable {
}

extension DescribeDataSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDataSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDataSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDataSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDataSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDataSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSet = output.dataSet
            self.requestId = output.requestId
        } else {
            self.dataSet = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeDataSetOutputResponse: Swift.Equatable {
    /// Information on the dataset.
    public var dataSet: QuickSightClientTypes.DataSet?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dataSet: QuickSightClientTypes.DataSet? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSet = dataSet
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeDataSetOutputResponseBody: Swift.Equatable {
    let dataSet: QuickSightClientTypes.DataSet?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeDataSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSet = "DataSet"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSet.self, forKey: .dataSet)
        dataSet = dataSetDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension DescribeDataSetPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSetId = dataSetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/permissions"
    }
}

public struct DescribeDataSetPermissionsInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSetId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
    }
}

struct DescribeDataSetPermissionsInputBody: Swift.Equatable {
}

extension DescribeDataSetPermissionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDataSetPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDataSetPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDataSetPermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDataSetPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDataSetPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSetArn = output.dataSetArn
            self.dataSetId = output.dataSetId
            self.permissions = output.permissions
            self.requestId = output.requestId
        } else {
            self.dataSetArn = nil
            self.dataSetId = nil
            self.permissions = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeDataSetPermissionsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset.
    public var dataSetArn: Swift.String?
    /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSetId: Swift.String?
    /// A list of resource permissions on the dataset.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dataSetArn: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSetArn = dataSetArn
        self.dataSetId = dataSetId
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeDataSetPermissionsOutputResponseBody: Swift.Equatable {
    let dataSetArn: Swift.String?
    let dataSetId: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeDataSetPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetArn = "DataSetArn"
        case dataSetId = "DataSetId"
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetArn)
        dataSetArn = dataSetArnDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension DescribeDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSourceId = dataSourceId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sources/\(dataSourceId.urlPercentEncoding())"
    }
}

public struct DescribeDataSourceInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSourceId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSourceId = dataSourceId
    }
}

struct DescribeDataSourceInputBody: Swift.Equatable {
}

extension DescribeDataSourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDataSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDataSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDataSourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDataSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSource = output.dataSource
            self.requestId = output.requestId
        } else {
            self.dataSource = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeDataSourceOutputResponse: Swift.Equatable {
    /// The information on the data source.
    public var dataSource: QuickSightClientTypes.DataSource?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dataSource: QuickSightClientTypes.DataSource? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSource = dataSource
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeDataSourceOutputResponseBody: Swift.Equatable {
    let dataSource: QuickSightClientTypes.DataSource?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeDataSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension DescribeDataSourcePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSourceId = dataSourceId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sources/\(dataSourceId.urlPercentEncoding())/permissions"
    }
}

public struct DescribeDataSourcePermissionsInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSourceId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSourceId = dataSourceId
    }
}

struct DescribeDataSourcePermissionsInputBody: Swift.Equatable {
}

extension DescribeDataSourcePermissionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDataSourcePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDataSourcePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDataSourcePermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDataSourcePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDataSourcePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSourceArn = output.dataSourceArn
            self.dataSourceId = output.dataSourceId
            self.permissions = output.permissions
            self.requestId = output.requestId
        } else {
            self.dataSourceArn = nil
            self.dataSourceId = nil
            self.permissions = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeDataSourcePermissionsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the data source.
    public var dataSourceArn: Swift.String?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSourceId: Swift.String?
    /// A list of resource permissions on the data source.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dataSourceArn: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSourceArn = dataSourceArn
        self.dataSourceId = dataSourceId
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeDataSourcePermissionsOutputResponseBody: Swift.Equatable {
    let dataSourceArn: Swift.String?
    let dataSourceId: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeDataSourcePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceArn = "DataSourceArn"
        case dataSourceId = "DataSourceId"
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceArn)
        dataSourceArn = dataSourceArnDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension DescribeFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let folderId = folderId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())"
    }
}

public struct DescribeFolderInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
    }
}

struct DescribeFolderInputBody: Swift.Equatable {
}

extension DescribeFolderInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFolderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFolderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeFolderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFolderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeFolderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.folder = output.folder
            self.requestId = output.requestId
        } else {
            self.folder = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeFolderOutputResponse: Swift.Equatable {
    /// Information about the folder.
    public var folder: QuickSightClientTypes.Folder?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        folder: QuickSightClientTypes.Folder? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.folder = folder
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeFolderOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let folder: QuickSightClientTypes.Folder?
    let requestId: Swift.String?
}

extension DescribeFolderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case folder = "Folder"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let folderDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Folder.self, forKey: .folder)
        folder = folderDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeFolderPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let folderId = folderId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())/permissions"
    }
}

public struct DescribeFolderPermissionsInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
    }
}

struct DescribeFolderPermissionsInputBody: Swift.Equatable {
}

extension DescribeFolderPermissionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFolderPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFolderPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeFolderPermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFolderPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeFolderPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.folderId = output.folderId
            self.permissions = output.permissions
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.folderId = nil
            self.permissions = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeFolderPermissionsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the folder.
    public var arn: Swift.String?
    /// The ID of the folder.
    public var folderId: Swift.String?
    /// Information about the permissions on the folder.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        folderId: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.folderId = folderId
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeFolderPermissionsOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let folderId: Swift.String?
    let arn: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let requestId: Swift.String?
}

extension DescribeFolderPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case folderId = "FolderId"
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let folderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .folderId)
        folderId = folderIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeFolderResolvedPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let folderId = folderId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())/resolved-permissions"
    }
}

public struct DescribeFolderResolvedPermissionsInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
    }
}

struct DescribeFolderResolvedPermissionsInputBody: Swift.Equatable {
}

extension DescribeFolderResolvedPermissionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFolderResolvedPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFolderResolvedPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeFolderResolvedPermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFolderResolvedPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeFolderResolvedPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.folderId = output.folderId
            self.permissions = output.permissions
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.folderId = nil
            self.permissions = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeFolderResolvedPermissionsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the folder.
    public var arn: Swift.String?
    /// The ID of the folder.
    public var folderId: Swift.String?
    /// Information about the permissions for the folder.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        folderId: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.folderId = folderId
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeFolderResolvedPermissionsOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let folderId: Swift.String?
    let arn: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let requestId: Swift.String?
}

extension DescribeFolderResolvedPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case folderId = "FolderId"
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let folderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .folderId)
        folderId = folderIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let groupName = groupName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups/\(groupName.urlPercentEncoding())"
    }
}

public struct DescribeGroupInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The name of the group that you want to describe.
    /// This member is required.
    public var groupName: Swift.String?
    /// The namespace of the group that you want described.
    /// This member is required.
    public var namespace: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.groupName = groupName
        self.namespace = namespace
    }
}

struct DescribeGroupInputBody: Swift.Equatable {
}

extension DescribeGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeGroupMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let groupName = groupName else {
            return nil
        }
        guard let memberName = memberName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups/\(groupName.urlPercentEncoding())/members/\(memberName.urlPercentEncoding())"
    }
}

public struct DescribeGroupMembershipInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The name of the group that you want to search.
    /// This member is required.
    public var groupName: Swift.String?
    /// The user name of the user that you want to search for.
    /// This member is required.
    public var memberName: Swift.String?
    /// The namespace that includes the group you are searching within.
    /// This member is required.
    public var namespace: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        memberName: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.groupName = groupName
        self.memberName = memberName
        self.namespace = namespace
    }
}

struct DescribeGroupMembershipInputBody: Swift.Equatable {
}

extension DescribeGroupMembershipInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeGroupMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGroupMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeGroupMembershipOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGroupMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeGroupMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groupMember = output.groupMember
            self.requestId = output.requestId
        } else {
            self.groupMember = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeGroupMembershipOutputResponse: Swift.Equatable {
    /// A member of an Amazon QuickSight group. Currently, group members must be users. Groups can't be members of another group. .
    public var groupMember: QuickSightClientTypes.GroupMember?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        groupMember: QuickSightClientTypes.GroupMember? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.groupMember = groupMember
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeGroupMembershipOutputResponseBody: Swift.Equatable {
    let groupMember: QuickSightClientTypes.GroupMember?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeGroupMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupMember = "GroupMember"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupMemberDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GroupMember.self, forKey: .groupMember)
        groupMember = groupMemberDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension DescribeGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.group = output.group
            self.requestId = output.requestId
        } else {
            self.group = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeGroupOutputResponse: Swift.Equatable {
    /// The name of the group.
    public var group: QuickSightClientTypes.Group?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        group: QuickSightClientTypes.Group? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.group = group
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeGroupOutputResponseBody: Swift.Equatable {
    let group: QuickSightClientTypes.Group?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group = "Group"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Group.self, forKey: .group)
        group = groupDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension DescribeIAMPolicyAssignmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let assignmentName = assignmentName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/iam-policy-assignments/\(assignmentName.urlPercentEncoding())"
    }
}

public struct DescribeIAMPolicyAssignmentInput: Swift.Equatable {
    /// The name of the assignment, also called a rule.
    /// This member is required.
    public var assignmentName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the assignment that you want to describe.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace that contains the assignment.
    /// This member is required.
    public var namespace: Swift.String?

    public init (
        assignmentName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.assignmentName = assignmentName
        self.awsAccountId = awsAccountId
        self.namespace = namespace
    }
}

struct DescribeIAMPolicyAssignmentInputBody: Swift.Equatable {
}

extension DescribeIAMPolicyAssignmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeIAMPolicyAssignmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIAMPolicyAssignmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeIAMPolicyAssignmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIAMPolicyAssignmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeIAMPolicyAssignmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.iamPolicyAssignment = output.iamPolicyAssignment
            self.requestId = output.requestId
        } else {
            self.iamPolicyAssignment = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeIAMPolicyAssignmentOutputResponse: Swift.Equatable {
    /// Information describing the IAM policy assignment.
    public var iamPolicyAssignment: QuickSightClientTypes.IAMPolicyAssignment?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        iamPolicyAssignment: QuickSightClientTypes.IAMPolicyAssignment? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.iamPolicyAssignment = iamPolicyAssignment
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeIAMPolicyAssignmentOutputResponseBody: Swift.Equatable {
    let iamPolicyAssignment: QuickSightClientTypes.IAMPolicyAssignment?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeIAMPolicyAssignmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamPolicyAssignment = "IAMPolicyAssignment"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamPolicyAssignmentDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IAMPolicyAssignment.self, forKey: .iamPolicyAssignment)
        iamPolicyAssignment = iamPolicyAssignmentDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension DescribeIngestionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSetId = dataSetId else {
            return nil
        }
        guard let ingestionId = ingestionId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/ingestions/\(ingestionId.urlPercentEncoding())"
    }
}

public struct DescribeIngestionInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dataset used in the ingestion.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// An ID for the ingestion.
    /// This member is required.
    public var ingestionId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        ingestionId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
        self.ingestionId = ingestionId
    }
}

struct DescribeIngestionInputBody: Swift.Equatable {
}

extension DescribeIngestionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeIngestionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIngestionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeIngestionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIngestionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeIngestionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ingestion = output.ingestion
            self.requestId = output.requestId
        } else {
            self.ingestion = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeIngestionOutputResponse: Swift.Equatable {
    /// Information about the ingestion.
    public var ingestion: QuickSightClientTypes.Ingestion?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        ingestion: QuickSightClientTypes.Ingestion? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.ingestion = ingestion
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeIngestionOutputResponseBody: Swift.Equatable {
    let ingestion: QuickSightClientTypes.Ingestion?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeIngestionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingestion = "Ingestion"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ingestionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Ingestion.self, forKey: .ingestion)
        ingestion = ingestionDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension DescribeIpRestrictionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/ip-restriction"
    }
}

public struct DescribeIpRestrictionInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the IP rules.
    /// This member is required.
    public var awsAccountId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
    }
}

struct DescribeIpRestrictionInputBody: Swift.Equatable {
}

extension DescribeIpRestrictionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeIpRestrictionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIpRestrictionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeIpRestrictionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIpRestrictionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeIpRestrictionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awsAccountId = output.awsAccountId
            self.enabled = output.enabled
            self.ipRestrictionRuleMap = output.ipRestrictionRuleMap
            self.requestId = output.requestId
        } else {
            self.awsAccountId = nil
            self.enabled = nil
            self.ipRestrictionRuleMap = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeIpRestrictionOutputResponse: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the IP rules.
    public var awsAccountId: Swift.String?
    /// A value that specifies whether IP rules are turned on.
    public var enabled: Swift.Bool?
    /// A map that describes the IP rules with CIDR range and description.
    public var ipRestrictionRuleMap: [Swift.String:Swift.String]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        awsAccountId: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        ipRestrictionRuleMap: [Swift.String:Swift.String]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.awsAccountId = awsAccountId
        self.enabled = enabled
        self.ipRestrictionRuleMap = ipRestrictionRuleMap
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeIpRestrictionOutputResponseBody: Swift.Equatable {
    let awsAccountId: Swift.String?
    let ipRestrictionRuleMap: [Swift.String:Swift.String]?
    let enabled: Swift.Bool?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeIpRestrictionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId = "AwsAccountId"
        case enabled = "Enabled"
        case ipRestrictionRuleMap = "IpRestrictionRuleMap"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let ipRestrictionRuleMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .ipRestrictionRuleMap)
        var ipRestrictionRuleMapDecoded0: [Swift.String:Swift.String]? = nil
        if let ipRestrictionRuleMapContainer = ipRestrictionRuleMapContainer {
            ipRestrictionRuleMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, iprestrictionruledescription0) in ipRestrictionRuleMapContainer {
                if let iprestrictionruledescription0 = iprestrictionruledescription0 {
                    ipRestrictionRuleMapDecoded0?[key0] = iprestrictionruledescription0
                }
            }
        }
        ipRestrictionRuleMap = ipRestrictionRuleMapDecoded0
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension DescribeNamespaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())"
    }
}

public struct DescribeNamespaceInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the Amazon QuickSight namespace that you want to describe.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace that you want to describe.
    /// This member is required.
    public var namespace: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
    }
}

struct DescribeNamespaceInputBody: Swift.Equatable {
}

extension DescribeNamespaceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeNamespaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.namespace = output.namespace
            self.requestId = output.requestId
        } else {
            self.namespace = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeNamespaceOutputResponse: Swift.Equatable {
    /// The information about the namespace that you're describing. The response includes the namespace ARN, name, Amazon Web Services Region, creation status, and identity store. DescribeNamespace also works for namespaces that are in the process of being created. For incomplete namespaces, this API operation lists the namespace error types and messages associated with the creation process.
    public var namespace: QuickSightClientTypes.NamespaceInfoV2?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        namespace: QuickSightClientTypes.NamespaceInfoV2? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.namespace = namespace
        self.requestId = requestId
        self.status = status
    }
}

struct DescribeNamespaceOutputResponseBody: Swift.Equatable {
    let namespace: QuickSightClientTypes.NamespaceInfoV2?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespace = "Namespace"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NamespaceInfoV2.self, forKey: .namespace)
        namespace = namespaceDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension DescribeTemplateAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        guard let aliasName = aliasName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/aliases/\(aliasName.urlPercentEncoding())"
    }
}

public struct DescribeTemplateAliasInput: Swift.Equatable {
    /// The name of the template alias that you want to describe. If you name a specific alias, you describe the version that the alias points to. You can specify the latest version of the template by providing the keyword $LATEST in the AliasName parameter. The keyword $PUBLISHED doesn't apply to templates.
    /// This member is required.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the template alias that you're describing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init (
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.templateId = templateId
    }
}

struct DescribeTemplateAliasInputBody: Swift.Equatable {
}

extension DescribeTemplateAliasInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeTemplateAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTemplateAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeTemplateAliasOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTemplateAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeTemplateAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.templateAlias = output.templateAlias
        } else {
            self.requestId = nil
            self.templateAlias = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeTemplateAliasOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// Information about the template alias.
    public var templateAlias: QuickSightClientTypes.TemplateAlias?

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateAlias: QuickSightClientTypes.TemplateAlias? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.templateAlias = templateAlias
    }
}

struct DescribeTemplateAliasOutputResponseBody: Swift.Equatable {
    let templateAlias: QuickSightClientTypes.TemplateAlias?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension DescribeTemplateAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case templateAlias = "TemplateAlias"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateAliasDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TemplateAlias.self, forKey: .templateAlias)
        templateAlias = templateAliasDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeTemplateDefinitionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let aliasName = aliasName {
                let aliasNameQueryItem = ClientRuntime.URLQueryItem(name: "alias-name".urlPercentEncoding(), value: Swift.String(aliasName).urlPercentEncoding())
                items.append(aliasNameQueryItem)
            }
            if let versionNumber = versionNumber {
                let versionNumberQueryItem = ClientRuntime.URLQueryItem(name: "version-number".urlPercentEncoding(), value: Swift.String(versionNumber).urlPercentEncoding())
                items.append(versionNumberQueryItem)
            }
            return items
        }
    }
}

extension DescribeTemplateDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/definition"
    }
}

public struct DescribeTemplateDefinitionInput: Swift.Equatable {
    /// The alias of the template that you want to describe. If you name a specific alias, you describe the version that the alias points to. You can specify the latest version of the template by providing the keyword $LATEST in the AliasName parameter. The keyword $PUBLISHED doesn't apply to templates.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the template. You must be using the Amazon Web Services account that the template is in.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the template that you're describing.
    /// This member is required.
    public var templateId: Swift.String?
    /// The version number of the template.
    public var versionNumber: Swift.Int?

    public init (
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        templateId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.templateId = templateId
        self.versionNumber = versionNumber
    }
}

struct DescribeTemplateDefinitionInputBody: Swift.Equatable {
}

extension DescribeTemplateDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeTemplateDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTemplateDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeTemplateDefinitionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTemplateDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeTemplateDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.definition = output.definition
            self.errors = output.errors
            self.name = output.name
            self.requestId = output.requestId
            self.resourceStatus = output.resourceStatus
            self.templateId = output.templateId
            self.themeArn = output.themeArn
        } else {
            self.definition = nil
            self.errors = nil
            self.name = nil
            self.requestId = nil
            self.resourceStatus = nil
            self.templateId = nil
            self.themeArn = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeTemplateDefinitionOutputResponse: Swift.Equatable {
    /// The definition of the template. A definition is the data model of all features in a Dashboard, Template, or Analysis.
    public var definition: QuickSightClientTypes.TemplateVersionDefinition?
    /// Errors associated with the template version.
    public var errors: [QuickSightClientTypes.TemplateError]?
    /// The descriptive name of the template.
    public var name: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// Status associated with the template.
    ///
    /// * CREATION_IN_PROGRESS
    ///
    /// * CREATION_SUCCESSFUL
    ///
    /// * CREATION_FAILED
    ///
    /// * UPDATE_IN_PROGRESS
    ///
    /// * UPDATE_SUCCESSFUL
    ///
    /// * UPDATE_FAILED
    ///
    /// * DELETED
    public var resourceStatus: QuickSightClientTypes.ResourceStatus?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ID of the template described.
    public var templateId: Swift.String?
    /// The ARN of the theme of the template.
    public var themeArn: Swift.String?

    public init (
        definition: QuickSightClientTypes.TemplateVersionDefinition? = nil,
        errors: [QuickSightClientTypes.TemplateError]? = nil,
        name: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceStatus: QuickSightClientTypes.ResourceStatus? = nil,
        status: Swift.Int = 0,
        templateId: Swift.String? = nil,
        themeArn: Swift.String? = nil
    )
    {
        self.definition = definition
        self.errors = errors
        self.name = name
        self.requestId = requestId
        self.resourceStatus = resourceStatus
        self.status = status
        self.templateId = templateId
        self.themeArn = themeArn
    }
}

struct DescribeTemplateDefinitionOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let templateId: Swift.String?
    let errors: [QuickSightClientTypes.TemplateError]?
    let resourceStatus: QuickSightClientTypes.ResourceStatus?
    let themeArn: Swift.String?
    let definition: QuickSightClientTypes.TemplateVersionDefinition?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension DescribeTemplateDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition = "Definition"
        case errors = "Errors"
        case name = "Name"
        case requestId = "RequestId"
        case resourceStatus = "ResourceStatus"
        case status = "Status"
        case templateId = "TemplateId"
        case themeArn = "ThemeArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let errorsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.TemplateError?].self, forKey: .errors)
        var errorsDecoded0:[QuickSightClientTypes.TemplateError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [QuickSightClientTypes.TemplateError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let resourceStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .resourceStatus)
        resourceStatus = resourceStatusDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TemplateVersionDefinition.self, forKey: .definition)
        definition = definitionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeTemplateInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let aliasName = aliasName {
                let aliasNameQueryItem = ClientRuntime.URLQueryItem(name: "alias-name".urlPercentEncoding(), value: Swift.String(aliasName).urlPercentEncoding())
                items.append(aliasNameQueryItem)
            }
            if let versionNumber = versionNumber {
                let versionNumberQueryItem = ClientRuntime.URLQueryItem(name: "version-number".urlPercentEncoding(), value: Swift.String(versionNumber).urlPercentEncoding())
                items.append(versionNumberQueryItem)
            }
            return items
        }
    }
}

extension DescribeTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())"
    }
}

public struct DescribeTemplateInput: Swift.Equatable {
    /// The alias of the template that you want to describe. If you name a specific alias, you describe the version that the alias points to. You can specify the latest version of the template by providing the keyword $LATEST in the AliasName parameter. The keyword $PUBLISHED doesn't apply to templates.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the template that you're describing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the template.
    /// This member is required.
    public var templateId: Swift.String?
    /// (Optional) The number for the version to describe. If a VersionNumber parameter value isn't provided, the latest version of the template is described.
    public var versionNumber: Swift.Int?

    public init (
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        templateId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.templateId = templateId
        self.versionNumber = versionNumber
    }
}

struct DescribeTemplateInputBody: Swift.Equatable {
}

extension DescribeTemplateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.template = output.template
        } else {
            self.requestId = nil
            self.template = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeTemplateOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The template structure for the object you want to describe.
    public var template: QuickSightClientTypes.Template?

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        template: QuickSightClientTypes.Template? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.template = template
    }
}

struct DescribeTemplateOutputResponseBody: Swift.Equatable {
    let template: QuickSightClientTypes.Template?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension DescribeTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case template = "Template"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Template.self, forKey: .template)
        template = templateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeTemplatePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/permissions"
    }
}

public struct DescribeTemplatePermissionsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the template that you're describing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.templateId = templateId
    }
}

struct DescribeTemplatePermissionsInputBody: Swift.Equatable {
}

extension DescribeTemplatePermissionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeTemplatePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTemplatePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeTemplatePermissionsOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTemplatePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeTemplatePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.permissions = output.permissions
            self.requestId = output.requestId
            self.templateArn = output.templateArn
            self.templateId = output.templateId
        } else {
            self.permissions = nil
            self.requestId = nil
            self.templateArn = nil
            self.templateId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeTemplatePermissionsOutputResponse: Swift.Equatable {
    /// A list of resource permissions to be set on the template.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The Amazon Resource Name (ARN) of the template.
    public var templateArn: Swift.String?
    /// The ID for the template.
    public var templateId: Swift.String?

    public init (
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateArn: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
        self.templateArn = templateArn
        self.templateId = templateId
    }
}

struct DescribeTemplatePermissionsOutputResponseBody: Swift.Equatable {
    let templateId: Swift.String?
    let templateArn: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeTemplatePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
        case templateArn = "TemplateArn"
        case templateId = "TemplateId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension DescribeThemeAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let themeId = themeId else {
            return nil
        }
        guard let aliasName = aliasName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())/aliases/\(aliasName.urlPercentEncoding())"
    }
}

public struct DescribeThemeAliasInput: Swift.Equatable {
    /// The name of the theme alias that you want to describe.
    /// This member is required.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the theme alias that you're describing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the theme.
    /// This member is required.
    public var themeId: Swift.String?

    public init (
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        themeId: Swift.String? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.themeId = themeId
    }
}

struct DescribeThemeAliasInputBody: Swift.Equatable {
}

extension DescribeThemeAliasInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeThemeAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeThemeAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeThemeAliasOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeThemeAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeThemeAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.themeAlias = output.themeAlias
        } else {
            self.requestId = nil
            self.themeAlias = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeThemeAliasOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// Information about the theme alias.
    public var themeAlias: QuickSightClientTypes.ThemeAlias?

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeAlias: QuickSightClientTypes.ThemeAlias? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.themeAlias = themeAlias
    }
}

struct DescribeThemeAliasOutputResponseBody: Swift.Equatable {
    let themeAlias: QuickSightClientTypes.ThemeAlias?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension DescribeThemeAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case themeAlias = "ThemeAlias"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeAliasDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ThemeAlias.self, forKey: .themeAlias)
        themeAlias = themeAliasDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeThemeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let aliasName = aliasName {
                let aliasNameQueryItem = ClientRuntime.URLQueryItem(name: "alias-name".urlPercentEncoding(), value: Swift.String(aliasName).urlPercentEncoding())
                items.append(aliasNameQueryItem)
            }
            if let versionNumber = versionNumber {
                let versionNumberQueryItem = ClientRuntime.URLQueryItem(name: "version-number".urlPercentEncoding(), value: Swift.String(versionNumber).urlPercentEncoding())
                items.append(versionNumberQueryItem)
            }
            return items
        }
    }
}

extension DescribeThemeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let themeId = themeId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())"
    }
}

public struct DescribeThemeInput: Swift.Equatable {
    /// The alias of the theme that you want to describe. If you name a specific alias, you describe the version that the alias points to. You can specify the latest version of the theme by providing the keyword $LATEST in the AliasName parameter. The keyword $PUBLISHED doesn't apply to themes.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the theme that you're describing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the theme.
    /// This member is required.
    public var themeId: Swift.String?
    /// The version number for the version to describe. If a VersionNumber parameter value isn't provided, the latest version of the theme is described.
    public var versionNumber: Swift.Int?

    public init (
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        themeId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.themeId = themeId
        self.versionNumber = versionNumber
    }
}

struct DescribeThemeInputBody: Swift.Equatable {
}

extension DescribeThemeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeThemeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeThemeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeThemeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeThemeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeThemeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.theme = output.theme
        } else {
            self.requestId = nil
            self.theme = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeThemeOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The information about the theme that you are describing.
    public var theme: QuickSightClientTypes.Theme?

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        theme: QuickSightClientTypes.Theme? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.theme = theme
    }
}

struct DescribeThemeOutputResponseBody: Swift.Equatable {
    let theme: QuickSightClientTypes.Theme?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension DescribeThemeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case theme = "Theme"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Theme.self, forKey: .theme)
        theme = themeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension DescribeThemePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let themeId = themeId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())/permissions"
    }
}

public struct DescribeThemePermissionsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the theme that you're describing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the theme that you want to describe permissions for.
    /// This member is required.
    public var themeId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        themeId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.themeId = themeId
    }
}

struct DescribeThemePermissionsInputBody: Swift.Equatable {
}

extension DescribeThemePermissionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeThemePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeThemePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeThemePermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeThemePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeThemePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.permissions = output.permissions
            self.requestId = output.requestId
            self.themeArn = output.themeArn
            self.themeId = output.themeId
        } else {
            self.permissions = nil
            self.requestId = nil
            self.themeArn = nil
            self.themeId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeThemePermissionsOutputResponse: Swift.Equatable {
    /// A list of resource permissions set on the theme.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The Amazon Resource Name (ARN) of the theme.
    public var themeArn: Swift.String?
    /// The ID for the theme.
    public var themeId: Swift.String?

    public init (
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeArn: Swift.String? = nil,
        themeId: Swift.String? = nil
    )
    {
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
        self.themeArn = themeArn
        self.themeId = themeId
    }
}

struct DescribeThemePermissionsOutputResponseBody: Swift.Equatable {
    let themeId: Swift.String?
    let themeArn: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeThemePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
        case themeArn = "ThemeArn"
        case themeId = "ThemeId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeId)
        themeId = themeIdDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension DescribeUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let userName = userName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/users/\(userName.urlPercentEncoding())"
    }
}

public struct DescribeUserInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// The name of the user that you want to describe.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.userName = userName
    }
}

struct DescribeUserInputBody: Swift.Equatable {
}

extension DescribeUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.user = output.user
        } else {
            self.requestId = nil
            self.user = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct DescribeUserOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The user name.
    public var user: QuickSightClientTypes.User?

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        user: QuickSightClientTypes.User? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.user = user
    }
}

struct DescribeUserOutputResponseBody: Swift.Equatable {
    let user: QuickSightClientTypes.User?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension DescribeUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case user = "User"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.User.self, forKey: .user)
        user = userDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension QuickSightClientTypes.DestinationParameterValueConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customValuesConfiguration = "CustomValuesConfiguration"
        case selectAllValueOptions = "SelectAllValueOptions"
        case sourceField = "SourceField"
        case sourceParameterName = "SourceParameterName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customValuesConfiguration = self.customValuesConfiguration {
            try encodeContainer.encode(customValuesConfiguration, forKey: .customValuesConfiguration)
        }
        if let selectAllValueOptions = self.selectAllValueOptions {
            try encodeContainer.encode(selectAllValueOptions.rawValue, forKey: .selectAllValueOptions)
        }
        if let sourceField = self.sourceField {
            try encodeContainer.encode(sourceField, forKey: .sourceField)
        }
        if let sourceParameterName = self.sourceParameterName {
            try encodeContainer.encode(sourceParameterName, forKey: .sourceParameterName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customValuesConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CustomValuesConfiguration.self, forKey: .customValuesConfiguration)
        customValuesConfiguration = customValuesConfigurationDecoded
        let selectAllValueOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SelectAllValueOptions.self, forKey: .selectAllValueOptions)
        selectAllValueOptions = selectAllValueOptionsDecoded
        let sourceParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceParameterName)
        sourceParameterName = sourceParameterNameDecoded
        let sourceFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceField)
        sourceField = sourceFieldDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of destination parameter values. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct DestinationParameterValueConfiguration: Swift.Equatable {
        /// The configuration of custom values for destination parameter in DestinationParameterValueConfiguration.
        public var customValuesConfiguration: QuickSightClientTypes.CustomValuesConfiguration?
        /// The configuration that selects all options.
        public var selectAllValueOptions: QuickSightClientTypes.SelectAllValueOptions?
        /// The source field ID of the destination parameter.
        public var sourceField: Swift.String?
        /// The source parameter name of the destination parameter.
        public var sourceParameterName: Swift.String?

        public init (
            customValuesConfiguration: QuickSightClientTypes.CustomValuesConfiguration? = nil,
            selectAllValueOptions: QuickSightClientTypes.SelectAllValueOptions? = nil,
            sourceField: Swift.String? = nil,
            sourceParameterName: Swift.String? = nil
        )
        {
            self.customValuesConfiguration = customValuesConfiguration
            self.selectAllValueOptions = selectAllValueOptions
            self.sourceField = sourceField
            self.sourceParameterName = sourceParameterName
        }
    }

}

extension QuickSightClientTypes.DimensionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoricalDimensionField = "CategoricalDimensionField"
        case dateDimensionField = "DateDimensionField"
        case numericalDimensionField = "NumericalDimensionField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoricalDimensionField = self.categoricalDimensionField {
            try encodeContainer.encode(categoricalDimensionField, forKey: .categoricalDimensionField)
        }
        if let dateDimensionField = self.dateDimensionField {
            try encodeContainer.encode(dateDimensionField, forKey: .dateDimensionField)
        }
        if let numericalDimensionField = self.numericalDimensionField {
            try encodeContainer.encode(numericalDimensionField, forKey: .numericalDimensionField)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numericalDimensionFieldDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumericalDimensionField.self, forKey: .numericalDimensionField)
        numericalDimensionField = numericalDimensionFieldDecoded
        let categoricalDimensionFieldDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CategoricalDimensionField.self, forKey: .categoricalDimensionField)
        categoricalDimensionField = categoricalDimensionFieldDecoded
        let dateDimensionFieldDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DateDimensionField.self, forKey: .dateDimensionField)
        dateDimensionField = dateDimensionFieldDecoded
    }
}

extension QuickSightClientTypes {
    /// The dimension type field.
    public struct DimensionField: Swift.Equatable {
        /// The dimension type field with categorical type columns.
        public var categoricalDimensionField: QuickSightClientTypes.CategoricalDimensionField?
        /// The dimension type field with date type columns.
        public var dateDimensionField: QuickSightClientTypes.DateDimensionField?
        /// The dimension type field with numerical type columns.
        public var numericalDimensionField: QuickSightClientTypes.NumericalDimensionField?

        public init (
            categoricalDimensionField: QuickSightClientTypes.CategoricalDimensionField? = nil,
            dateDimensionField: QuickSightClientTypes.DateDimensionField? = nil,
            numericalDimensionField: QuickSightClientTypes.NumericalDimensionField? = nil
        )
        {
            self.categoricalDimensionField = categoricalDimensionField
            self.dateDimensionField = dateDimensionField
            self.numericalDimensionField = numericalDimensionField
        }
    }

}

extension DomainNotWhitelistedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DomainNotWhitelistedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The domain specified isn't on the allow list. All domains for embedded dashboards must be added to the approved list by an Amazon QuickSight admin.
public struct DomainNotWhitelistedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct DomainNotWhitelistedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension DomainNotWhitelistedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.DonutCenterOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case labelVisibility = "LabelVisibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let labelVisibility = self.labelVisibility {
            try encodeContainer.encode(labelVisibility.rawValue, forKey: .labelVisibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .labelVisibility)
        labelVisibility = labelVisibilityDecoded
    }
}

extension QuickSightClientTypes {
    /// The label options of the label that is displayed in the center of a donut chart. This option isn't available for pie charts.
    public struct DonutCenterOptions: Swift.Equatable {
        /// Determines the visibility of the label in a donut chart. In the Amazon QuickSight console, this option is called 'Show total'.
        public var labelVisibility: QuickSightClientTypes.Visibility?

        public init (
            labelVisibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.labelVisibility = labelVisibility
        }
    }

}

extension QuickSightClientTypes.DonutOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arcOptions = "ArcOptions"
        case donutCenterOptions = "DonutCenterOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arcOptions = self.arcOptions {
            try encodeContainer.encode(arcOptions, forKey: .arcOptions)
        }
        if let donutCenterOptions = self.donutCenterOptions {
            try encodeContainer.encode(donutCenterOptions, forKey: .donutCenterOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arcOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ArcOptions.self, forKey: .arcOptions)
        arcOptions = arcOptionsDecoded
        let donutCenterOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DonutCenterOptions.self, forKey: .donutCenterOptions)
        donutCenterOptions = donutCenterOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// The options for configuring a donut chart or pie chart.
    public struct DonutOptions: Swift.Equatable {
        /// The option for define the arc of the chart shape. Valid values are as follows:
        ///
        /// * WHOLE - A pie chart
        ///
        /// * SMALL- A small-sized donut chart
        ///
        /// * MEDIUM- A medium-sized donut chart
        ///
        /// * LARGE- A large-sized donut chart
        public var arcOptions: QuickSightClientTypes.ArcOptions?
        /// The label options of the label that is displayed in the center of a donut chart. This option isn't available for pie charts.
        public var donutCenterOptions: QuickSightClientTypes.DonutCenterOptions?

        public init (
            arcOptions: QuickSightClientTypes.ArcOptions? = nil,
            donutCenterOptions: QuickSightClientTypes.DonutCenterOptions? = nil
        )
        {
            self.arcOptions = arcOptions
            self.donutCenterOptions = donutCenterOptions
        }
    }

}

extension QuickSightClientTypes.DrillDownFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryFilter = "CategoryFilter"
        case numericEqualityFilter = "NumericEqualityFilter"
        case timeRangeFilter = "TimeRangeFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryFilter = self.categoryFilter {
            try encodeContainer.encode(categoryFilter, forKey: .categoryFilter)
        }
        if let numericEqualityFilter = self.numericEqualityFilter {
            try encodeContainer.encode(numericEqualityFilter, forKey: .numericEqualityFilter)
        }
        if let timeRangeFilter = self.timeRangeFilter {
            try encodeContainer.encode(timeRangeFilter, forKey: .timeRangeFilter)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numericEqualityFilterDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumericEqualityDrillDownFilter.self, forKey: .numericEqualityFilter)
        numericEqualityFilter = numericEqualityFilterDecoded
        let categoryFilterDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CategoryDrillDownFilter.self, forKey: .categoryFilter)
        categoryFilter = categoryFilterDecoded
        let timeRangeFilterDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TimeRangeDrillDownFilter.self, forKey: .timeRangeFilter)
        timeRangeFilter = timeRangeFilterDecoded
    }
}

extension QuickSightClientTypes {
    /// The drill down filter for the column hierarchies. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct DrillDownFilter: Swift.Equatable {
        /// The category type drill down filter. This filter is used for string type columns.
        public var categoryFilter: QuickSightClientTypes.CategoryDrillDownFilter?
        /// The numeric equality type drill down filter. This filter is used for number type columns.
        public var numericEqualityFilter: QuickSightClientTypes.NumericEqualityDrillDownFilter?
        /// The time range drill down filter. This filter is used for date time columns.
        public var timeRangeFilter: QuickSightClientTypes.TimeRangeDrillDownFilter?

        public init (
            categoryFilter: QuickSightClientTypes.CategoryDrillDownFilter? = nil,
            numericEqualityFilter: QuickSightClientTypes.NumericEqualityDrillDownFilter? = nil,
            timeRangeFilter: QuickSightClientTypes.TimeRangeDrillDownFilter? = nil
        )
        {
            self.categoryFilter = categoryFilter
            self.numericEqualityFilter = numericEqualityFilter
            self.timeRangeFilter = timeRangeFilter
        }
    }

}

extension QuickSightClientTypes.DropDownControlDisplayOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case selectAllOptions = "SelectAllOptions"
        case titleOptions = "TitleOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let selectAllOptions = self.selectAllOptions {
            try encodeContainer.encode(selectAllOptions, forKey: .selectAllOptions)
        }
        if let titleOptions = self.titleOptions {
            try encodeContainer.encode(titleOptions, forKey: .titleOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectAllOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ListControlSelectAllOptions.self, forKey: .selectAllOptions)
        selectAllOptions = selectAllOptionsDecoded
        let titleOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LabelOptions.self, forKey: .titleOptions)
        titleOptions = titleOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// The display options of a control.
    public struct DropDownControlDisplayOptions: Swift.Equatable {
        /// The configuration of the Select all options in a dropdown control.
        public var selectAllOptions: QuickSightClientTypes.ListControlSelectAllOptions?
        /// The options to configure the title visibility, name, and font size.
        public var titleOptions: QuickSightClientTypes.LabelOptions?

        public init (
            selectAllOptions: QuickSightClientTypes.ListControlSelectAllOptions? = nil,
            titleOptions: QuickSightClientTypes.LabelOptions? = nil
        )
        {
            self.selectAllOptions = selectAllOptions
            self.titleOptions = titleOptions
        }
    }

}

extension QuickSightClientTypes.DynamicDefaultValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValueColumn = "DefaultValueColumn"
        case groupNameColumn = "GroupNameColumn"
        case userNameColumn = "UserNameColumn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValueColumn = self.defaultValueColumn {
            try encodeContainer.encode(defaultValueColumn, forKey: .defaultValueColumn)
        }
        if let groupNameColumn = self.groupNameColumn {
            try encodeContainer.encode(groupNameColumn, forKey: .groupNameColumn)
        }
        if let userNameColumn = self.userNameColumn {
            try encodeContainer.encode(userNameColumn, forKey: .userNameColumn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameColumnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .userNameColumn)
        userNameColumn = userNameColumnDecoded
        let groupNameColumnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .groupNameColumn)
        groupNameColumn = groupNameColumnDecoded
        let defaultValueColumnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .defaultValueColumn)
        defaultValueColumn = defaultValueColumnDecoded
    }
}

extension QuickSightClientTypes {
    /// Defines different defaults to the users or groups based on mapping.
    public struct DynamicDefaultValue: Swift.Equatable {
        /// The column that contains the default value of each user or group.
        /// This member is required.
        public var defaultValueColumn: QuickSightClientTypes.ColumnIdentifier?
        /// The column that contains the group name.
        public var groupNameColumn: QuickSightClientTypes.ColumnIdentifier?
        /// The column that contains the username.
        public var userNameColumn: QuickSightClientTypes.ColumnIdentifier?

        public init (
            defaultValueColumn: QuickSightClientTypes.ColumnIdentifier? = nil,
            groupNameColumn: QuickSightClientTypes.ColumnIdentifier? = nil,
            userNameColumn: QuickSightClientTypes.ColumnIdentifier? = nil
        )
        {
            self.defaultValueColumn = defaultValueColumn
            self.groupNameColumn = groupNameColumn
            self.userNameColumn = userNameColumn
        }
    }

}

extension QuickSightClientTypes {
    public enum Edition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enterprise
        case enterpriseAndQ
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [Edition] {
            return [
                .enterprise,
                .enterpriseAndQ,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enterprise: return "ENTERPRISE"
            case .enterpriseAndQ: return "ENTERPRISE_AND_Q"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Edition(rawValue: rawValue) ?? Edition.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum EmbeddingIdentityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case anonymous
        case iam
        case quicksight
        case sdkUnknown(Swift.String)

        public static var allCases: [EmbeddingIdentityType] {
            return [
                .anonymous,
                .iam,
                .quicksight,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .anonymous: return "ANONYMOUS"
            case .iam: return "IAM"
            case .quicksight: return "QUICKSIGHT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EmbeddingIdentityType(rawValue: rawValue) ?? EmbeddingIdentityType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.EmptyVisual: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case dataSetIdentifier = "DataSetIdentifier"
        case visualId = "VisualId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for visualcustomaction0 in actions {
                try actionsContainer.encode(visualcustomaction0)
            }
        }
        if let dataSetIdentifier = self.dataSetIdentifier {
            try encodeContainer.encode(dataSetIdentifier, forKey: .dataSetIdentifier)
        }
        if let visualId = self.visualId {
            try encodeContainer.encode(visualId, forKey: .visualId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visualIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visualId)
        visualId = visualIdDecoded
        let dataSetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetIdentifier)
        dataSetIdentifier = dataSetIdentifierDecoded
        let actionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.VisualCustomAction?].self, forKey: .actions)
        var actionsDecoded0:[QuickSightClientTypes.VisualCustomAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [QuickSightClientTypes.VisualCustomAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension QuickSightClientTypes {
    /// An empty visual. Empty visuals are used in layouts but have not been configured to show any data. A new visual created in the Amazon QuickSight console is considered an EmptyVisual until a visual type is selected.
    public struct EmptyVisual: Swift.Equatable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The data set that is used in the empty visual. Every visual requires a dataset to render.
        /// This member is required.
        public var dataSetIdentifier: Swift.String?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init (
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            dataSetIdentifier: Swift.String? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.dataSetIdentifier = dataSetIdentifier
            self.visualId = visualId
        }
    }

}

extension QuickSightClientTypes.Entity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path = "Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
    }
}

extension QuickSightClientTypes {
    /// An object, structure, or sub-structure of an analysis, template, or dashboard.
    public struct Entity: Swift.Equatable {
        /// The hierarchical path of the entity within the analysis, template, or dashboard definition tree.
        public var path: Swift.String?

        public init (
            path: Swift.String? = nil
        )
        {
            self.path = path
        }
    }

}

extension QuickSightClientTypes.ErrorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IngestionErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QuickSightClientTypes {
    /// Error information for the SPICE ingestion of a dataset.
    public struct ErrorInfo: Swift.Equatable {
        /// Error message.
        public var message: Swift.String?
        /// Error type.
        public var type: QuickSightClientTypes.IngestionErrorType?

        public init (
            message: Swift.String? = nil,
            type: QuickSightClientTypes.IngestionErrorType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }

}

extension QuickSightClientTypes.ExasolParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
    }
}

extension QuickSightClientTypes {
    /// The required parameters for connecting to an Exasol data source.
    public struct ExasolParameters: Swift.Equatable {
        /// The hostname or IP address of the Exasol data source.
        /// This member is required.
        public var host: Swift.String?
        /// The port for the Exasol data source.
        /// This member is required.
        public var port: Swift.Int

        public init (
            host: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.host = host
            self.port = port
        }
    }

}

extension QuickSightClientTypes {
    public enum ExceptionResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountSettings
        case dataSet
        case dataSource
        case group
        case iampolicyAssignment
        case ingestion
        case namespace
        case user
        case vpcConnection
        case sdkUnknown(Swift.String)

        public static var allCases: [ExceptionResourceType] {
            return [
                .accountSettings,
                .dataSet,
                .dataSource,
                .group,
                .iampolicyAssignment,
                .ingestion,
                .namespace,
                .user,
                .vpcConnection,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountSettings: return "ACCOUNT_SETTINGS"
            case .dataSet: return "DATA_SET"
            case .dataSource: return "DATA_SOURCE"
            case .group: return "GROUP"
            case .iampolicyAssignment: return "IAMPOLICY_ASSIGNMENT"
            case .ingestion: return "INGESTION"
            case .namespace: return "NAMESPACE"
            case .user: return "USER"
            case .vpcConnection: return "VPC_CONNECTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExceptionResourceType(rawValue: rawValue) ?? ExceptionResourceType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.ExcludePeriodConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount = "Amount"
        case granularity = "Granularity"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amount = self.amount {
            try encodeContainer.encode(amount, forKey: .amount)
        }
        if let granularity = self.granularity {
            try encodeContainer.encode(granularity.rawValue, forKey: .granularity)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .amount)
        amount = amountDecoded
        let granularityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TimeGranularity.self, forKey: .granularity)
        granularity = granularityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.WidgetStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension QuickSightClientTypes {
    /// The exclude period of TimeRangeFilter or RelativeDatesFilter.
    public struct ExcludePeriodConfiguration: Swift.Equatable {
        /// The amount or number of the exclude period.
        /// This member is required.
        public var amount: Swift.Int?
        /// The granularity or unit (day, month, year) of the exclude period.
        /// This member is required.
        public var granularity: QuickSightClientTypes.TimeGranularity?
        /// The status of the exclude period. Choose from the following options:
        ///
        /// * ENABLED
        ///
        /// * DISABLED
        public var status: QuickSightClientTypes.WidgetStatus?

        public init (
            amount: Swift.Int? = nil,
            granularity: QuickSightClientTypes.TimeGranularity? = nil,
            status: QuickSightClientTypes.WidgetStatus? = nil
        )
        {
            self.amount = amount
            self.granularity = granularity
            self.status = status
        }
    }

}

extension QuickSightClientTypes.ExplicitHierarchy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columns = "Columns"
        case drillDownFilters = "DrillDownFilters"
        case hierarchyId = "HierarchyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for columnidentifier0 in columns {
                try columnsContainer.encode(columnidentifier0)
            }
        }
        if let drillDownFilters = drillDownFilters {
            var drillDownFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .drillDownFilters)
            for drilldownfilter0 in drillDownFilters {
                try drillDownFiltersContainer.encode(drilldownfilter0)
            }
        }
        if let hierarchyId = self.hierarchyId {
            try encodeContainer.encode(hierarchyId, forKey: .hierarchyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyId)
        hierarchyId = hierarchyIdDecoded
        let columnsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnIdentifier?].self, forKey: .columns)
        var columnsDecoded0:[QuickSightClientTypes.ColumnIdentifier]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [QuickSightClientTypes.ColumnIdentifier]()
            for structure0 in columnsContainer {
                if let structure0 = structure0 {
                    columnsDecoded0?.append(structure0)
                }
            }
        }
        columns = columnsDecoded0
        let drillDownFiltersContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DrillDownFilter?].self, forKey: .drillDownFilters)
        var drillDownFiltersDecoded0:[QuickSightClientTypes.DrillDownFilter]? = nil
        if let drillDownFiltersContainer = drillDownFiltersContainer {
            drillDownFiltersDecoded0 = [QuickSightClientTypes.DrillDownFilter]()
            for structure0 in drillDownFiltersContainer {
                if let structure0 = structure0 {
                    drillDownFiltersDecoded0?.append(structure0)
                }
            }
        }
        drillDownFilters = drillDownFiltersDecoded0
    }
}

extension QuickSightClientTypes {
    /// The option that determines the hierarchy of the fields that are built within a visual's field wells. These fields can't be duplicated to other visuals.
    public struct ExplicitHierarchy: Swift.Equatable {
        /// The list of columns that define the explicit hierarchy.
        /// This member is required.
        public var columns: [QuickSightClientTypes.ColumnIdentifier]?
        /// The option that determines the drill down filters for the explicit hierarchy.
        public var drillDownFilters: [QuickSightClientTypes.DrillDownFilter]?
        /// The hierarchy ID of the explicit hierarchy.
        /// This member is required.
        public var hierarchyId: Swift.String?

        public init (
            columns: [QuickSightClientTypes.ColumnIdentifier]? = nil,
            drillDownFilters: [QuickSightClientTypes.DrillDownFilter]? = nil,
            hierarchyId: Swift.String? = nil
        )
        {
            self.columns = columns
            self.drillDownFilters = drillDownFilters
            self.hierarchyId = hierarchyId
        }
    }

}

extension QuickSightClientTypes.ExportHiddenFieldsOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityStatus = "AvailabilityStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityStatus = self.availabilityStatus {
            try encodeContainer.encode(availabilityStatus.rawValue, forKey: .availabilityStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardBehavior.self, forKey: .availabilityStatus)
        availabilityStatus = availabilityStatusDecoded
    }
}

extension QuickSightClientTypes {
    ///
    public struct ExportHiddenFieldsOption: Swift.Equatable {
        ///
        public var availabilityStatus: QuickSightClientTypes.DashboardBehavior?

        public init (
            availabilityStatus: QuickSightClientTypes.DashboardBehavior? = nil
        )
        {
            self.availabilityStatus = availabilityStatus
        }
    }

}

extension QuickSightClientTypes.ExportToCSVOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityStatus = "AvailabilityStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityStatus = self.availabilityStatus {
            try encodeContainer.encode(availabilityStatus.rawValue, forKey: .availabilityStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardBehavior.self, forKey: .availabilityStatus)
        availabilityStatus = availabilityStatusDecoded
    }
}

extension QuickSightClientTypes {
    /// Export to .csv option.
    public struct ExportToCSVOption: Swift.Equatable {
        /// Availability status.
        public var availabilityStatus: QuickSightClientTypes.DashboardBehavior?

        public init (
            availabilityStatus: QuickSightClientTypes.DashboardBehavior? = nil
        )
        {
            self.availabilityStatus = availabilityStatus
        }
    }

}

extension QuickSightClientTypes.FieldBasedTooltip: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationVisibility = "AggregationVisibility"
        case tooltipFields = "TooltipFields"
        case tooltipTitleType = "TooltipTitleType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationVisibility = self.aggregationVisibility {
            try encodeContainer.encode(aggregationVisibility.rawValue, forKey: .aggregationVisibility)
        }
        if let tooltipFields = tooltipFields {
            var tooltipFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tooltipFields)
            for tooltipitem0 in tooltipFields {
                try tooltipFieldsContainer.encode(tooltipitem0)
            }
        }
        if let tooltipTitleType = self.tooltipTitleType {
            try encodeContainer.encode(tooltipTitleType.rawValue, forKey: .tooltipTitleType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregationVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .aggregationVisibility)
        aggregationVisibility = aggregationVisibilityDecoded
        let tooltipTitleTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TooltipTitleType.self, forKey: .tooltipTitleType)
        tooltipTitleType = tooltipTitleTypeDecoded
        let tooltipFieldsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.TooltipItem?].self, forKey: .tooltipFields)
        var tooltipFieldsDecoded0:[QuickSightClientTypes.TooltipItem]? = nil
        if let tooltipFieldsContainer = tooltipFieldsContainer {
            tooltipFieldsDecoded0 = [QuickSightClientTypes.TooltipItem]()
            for structure0 in tooltipFieldsContainer {
                if let structure0 = structure0 {
                    tooltipFieldsDecoded0?.append(structure0)
                }
            }
        }
        tooltipFields = tooltipFieldsDecoded0
    }
}

extension QuickSightClientTypes {
    /// The setup for the detailed tooltip.
    public struct FieldBasedTooltip: Swift.Equatable {
        /// The visibility of Show aggregations.
        public var aggregationVisibility: QuickSightClientTypes.Visibility?
        /// The fields configuration in the tooltip.
        public var tooltipFields: [QuickSightClientTypes.TooltipItem]?
        /// The type for the >tooltip title. Choose one of the following options:
        ///
        /// * NONE: Doesn't use the primary value as the title.
        ///
        /// * PRIMARY_VALUE: Uses primary value as the title.
        public var tooltipTitleType: QuickSightClientTypes.TooltipTitleType?

        public init (
            aggregationVisibility: QuickSightClientTypes.Visibility? = nil,
            tooltipFields: [QuickSightClientTypes.TooltipItem]? = nil,
            tooltipTitleType: QuickSightClientTypes.TooltipTitleType? = nil
        )
        {
            self.aggregationVisibility = aggregationVisibility
            self.tooltipFields = tooltipFields
            self.tooltipTitleType = tooltipTitleType
        }
    }

}

extension QuickSightClientTypes.FieldFolder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columns
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for string0 in columns {
                try columnsContainer.encode(string0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let columnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .columns)
        var columnsDecoded0:[Swift.String]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [Swift.String]()
            for string0 in columnsContainer {
                if let string0 = string0 {
                    columnsDecoded0?.append(string0)
                }
            }
        }
        columns = columnsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A FieldFolder element is a folder that contains fields and nested subfolders.
    public struct FieldFolder: Swift.Equatable {
        /// A folder has a list of columns. A column can only be in one folder.
        public var columns: [Swift.String]?
        /// The description for a field folder.
        public var description: Swift.String?

        public init (
            columns: [Swift.String]? = nil,
            description: Swift.String? = nil
        )
        {
            self.columns = columns
            self.description = description
        }
    }

}

extension QuickSightClientTypes.FieldLabelType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldId = "FieldId"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension QuickSightClientTypes {
    /// The field label type.
    public struct FieldLabelType: Swift.Equatable {
        /// Indicates the field that is targeted by the field label.
        public var fieldId: Swift.String?
        /// The visibility of the field label.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            fieldId: Swift.String? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.fieldId = fieldId
            self.visibility = visibility
        }
    }

}

extension QuickSightClientTypes.FieldSeriesItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case axisBinding = "AxisBinding"
        case fieldId = "FieldId"
        case settings = "Settings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let axisBinding = self.axisBinding {
            try encodeContainer.encode(axisBinding.rawValue, forKey: .axisBinding)
        }
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
        if let settings = self.settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let axisBindingDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisBinding.self, forKey: .axisBinding)
        axisBinding = axisBindingDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LineChartSeriesSettings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

extension QuickSightClientTypes {
    /// The field series item configuration of a line chart.
    public struct FieldSeriesItem: Swift.Equatable {
        /// The axis that you are binding the field to.
        /// This member is required.
        public var axisBinding: QuickSightClientTypes.AxisBinding?
        /// The field ID of the field for which you are setting the axis binding.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The options that determine the presentation of line series associated to the field.
        public var settings: QuickSightClientTypes.LineChartSeriesSettings?

        public init (
            axisBinding: QuickSightClientTypes.AxisBinding? = nil,
            fieldId: Swift.String? = nil,
            settings: QuickSightClientTypes.LineChartSeriesSettings? = nil
        )
        {
            self.axisBinding = axisBinding
            self.fieldId = fieldId
            self.settings = settings
        }
    }

}

extension QuickSightClientTypes.FieldSort: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case direction = "Direction"
        case fieldId = "FieldId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let direction = self.direction {
            try encodeContainer.encode(direction.rawValue, forKey: .direction)
        }
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let directionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SortDirection.self, forKey: .direction)
        direction = directionDecoded
    }
}

extension QuickSightClientTypes {
    /// The sort configuration for a field in a field well.
    public struct FieldSort: Swift.Equatable {
        /// The sort direction. Choose one of the following options:
        ///
        /// * ASC: Ascending
        ///
        /// * DESC: Descending
        /// This member is required.
        public var direction: QuickSightClientTypes.SortDirection?
        /// The sort configuration target field.
        /// This member is required.
        public var fieldId: Swift.String?

        public init (
            direction: QuickSightClientTypes.SortDirection? = nil,
            fieldId: Swift.String? = nil
        )
        {
            self.direction = direction
            self.fieldId = fieldId
        }
    }

}

extension QuickSightClientTypes.FieldSortOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnSort = "ColumnSort"
        case fieldSort = "FieldSort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnSort = self.columnSort {
            try encodeContainer.encode(columnSort, forKey: .columnSort)
        }
        if let fieldSort = self.fieldSort {
            try encodeContainer.encode(fieldSort, forKey: .fieldSort)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldSortDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FieldSort.self, forKey: .fieldSort)
        fieldSort = fieldSortDecoded
        let columnSortDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnSort.self, forKey: .columnSort)
        columnSort = columnSortDecoded
    }
}

extension QuickSightClientTypes {
    /// The field sort options in a chart configuration.
    public struct FieldSortOptions: Swift.Equatable {
        /// The sort configuration for a column that is not used in a field well.
        public var columnSort: QuickSightClientTypes.ColumnSort?
        /// The sort configuration for a field in a field well.
        public var fieldSort: QuickSightClientTypes.FieldSort?

        public init (
            columnSort: QuickSightClientTypes.ColumnSort? = nil,
            fieldSort: QuickSightClientTypes.FieldSort? = nil
        )
        {
            self.columnSort = columnSort
            self.fieldSort = fieldSort
        }
    }

}

extension QuickSightClientTypes.FieldTooltipItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldId = "FieldId"
        case label = "Label"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
        if let label = self.label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension QuickSightClientTypes {
    /// The tooltip item for the fields.
    public struct FieldTooltipItem: Swift.Equatable {
        /// The unique ID of the field that is targeted by the tooltip.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The label of the tooltip item.
        public var label: Swift.String?
        /// The visibility of the tooltip item.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            fieldId: Swift.String? = nil,
            label: Swift.String? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.fieldId = fieldId
            self.label = label
            self.visibility = visibility
        }
    }

}

extension QuickSightClientTypes {
    public enum FileFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case clf
        case csv
        case elf
        case json
        case tsv
        case xlsx
        case sdkUnknown(Swift.String)

        public static var allCases: [FileFormat] {
            return [
                .clf,
                .csv,
                .elf,
                .json,
                .tsv,
                .xlsx,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clf: return "CLF"
            case .csv: return "CSV"
            case .elf: return "ELF"
            case .json: return "JSON"
            case .tsv: return "TSV"
            case .xlsx: return "XLSX"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FileFormat(rawValue: rawValue) ?? FileFormat.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.FilledMapAggregatedFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geospatial = "Geospatial"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let geospatial = geospatial {
            var geospatialContainer = encodeContainer.nestedUnkeyedContainer(forKey: .geospatial)
            for dimensionfield0 in geospatial {
                try geospatialContainer.encode(dimensionfield0)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for measurefield0 in values {
                try valuesContainer.encode(measurefield0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geospatialContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .geospatial)
        var geospatialDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let geospatialContainer = geospatialContainer {
            geospatialDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in geospatialContainer {
                if let structure0 = structure0 {
                    geospatialDecoded0?.append(structure0)
                }
            }
        }
        geospatial = geospatialDecoded0
        let valuesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .values)
        var valuesDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension QuickSightClientTypes {
    /// The aggregated field well of the filled map.
    public struct FilledMapAggregatedFieldWells: Swift.Equatable {
        /// The aggregated location field well of the filled map. Values are grouped by location fields.
        public var geospatial: [QuickSightClientTypes.DimensionField]?
        /// The aggregated color field well of a filled map. Values are aggregated based on location fields.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init (
            geospatial: [QuickSightClientTypes.DimensionField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.geospatial = geospatial
            self.values = values
        }
    }

}

extension QuickSightClientTypes.FilledMapConditionalFormatting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conditionalFormattingOptions = "ConditionalFormattingOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conditionalFormattingOptions = conditionalFormattingOptions {
            var conditionalFormattingOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conditionalFormattingOptions)
            for filledmapconditionalformattingoption0 in conditionalFormattingOptions {
                try conditionalFormattingOptionsContainer.encode(filledmapconditionalformattingoption0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionalFormattingOptionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FilledMapConditionalFormattingOption?].self, forKey: .conditionalFormattingOptions)
        var conditionalFormattingOptionsDecoded0:[QuickSightClientTypes.FilledMapConditionalFormattingOption]? = nil
        if let conditionalFormattingOptionsContainer = conditionalFormattingOptionsContainer {
            conditionalFormattingOptionsDecoded0 = [QuickSightClientTypes.FilledMapConditionalFormattingOption]()
            for structure0 in conditionalFormattingOptionsContainer {
                if let structure0 = structure0 {
                    conditionalFormattingOptionsDecoded0?.append(structure0)
                }
            }
        }
        conditionalFormattingOptions = conditionalFormattingOptionsDecoded0
    }
}

extension QuickSightClientTypes {
    /// The conditional formatting of a FilledMapVisual.
    public struct FilledMapConditionalFormatting: Swift.Equatable {
        /// Conditional formatting options of a FilledMapVisual.
        /// This member is required.
        public var conditionalFormattingOptions: [QuickSightClientTypes.FilledMapConditionalFormattingOption]?

        public init (
            conditionalFormattingOptions: [QuickSightClientTypes.FilledMapConditionalFormattingOption]? = nil
        )
        {
            self.conditionalFormattingOptions = conditionalFormattingOptions
        }
    }

}

extension QuickSightClientTypes.FilledMapConditionalFormattingOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shape = "Shape"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shape = self.shape {
            try encodeContainer.encode(shape, forKey: .shape)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shapeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilledMapShapeConditionalFormatting.self, forKey: .shape)
        shape = shapeDecoded
    }
}

extension QuickSightClientTypes {
    /// Conditional formatting options of a FilledMapVisual.
    public struct FilledMapConditionalFormattingOption: Swift.Equatable {
        /// The conditional formatting that determines the shape of the filled map.
        /// This member is required.
        public var shape: QuickSightClientTypes.FilledMapShapeConditionalFormatting?

        public init (
            shape: QuickSightClientTypes.FilledMapShapeConditionalFormatting? = nil
        )
        {
            self.shape = shape
        }
    }

}

extension QuickSightClientTypes.FilledMapConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldWells = "FieldWells"
        case legend = "Legend"
        case mapStyleOptions = "MapStyleOptions"
        case sortConfiguration = "SortConfiguration"
        case tooltip = "Tooltip"
        case windowOptions = "WindowOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldWells = self.fieldWells {
            try encodeContainer.encode(fieldWells, forKey: .fieldWells)
        }
        if let legend = self.legend {
            try encodeContainer.encode(legend, forKey: .legend)
        }
        if let mapStyleOptions = self.mapStyleOptions {
            try encodeContainer.encode(mapStyleOptions, forKey: .mapStyleOptions)
        }
        if let sortConfiguration = self.sortConfiguration {
            try encodeContainer.encode(sortConfiguration, forKey: .sortConfiguration)
        }
        if let tooltip = self.tooltip {
            try encodeContainer.encode(tooltip, forKey: .tooltip)
        }
        if let windowOptions = self.windowOptions {
            try encodeContainer.encode(windowOptions, forKey: .windowOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilledMapFieldWells.self, forKey: .fieldWells)
        fieldWells = fieldWellsDecoded
        let sortConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilledMapSortConfiguration.self, forKey: .sortConfiguration)
        sortConfiguration = sortConfigurationDecoded
        let legendDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LegendOptions.self, forKey: .legend)
        legend = legendDecoded
        let tooltipDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TooltipOptions.self, forKey: .tooltip)
        tooltip = tooltipDecoded
        let windowOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GeospatialWindowOptions.self, forKey: .windowOptions)
        windowOptions = windowOptionsDecoded
        let mapStyleOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GeospatialMapStyleOptions.self, forKey: .mapStyleOptions)
        mapStyleOptions = mapStyleOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration for a FilledMapVisual.
    public struct FilledMapConfiguration: Swift.Equatable {
        /// The field wells of the visual.
        public var fieldWells: QuickSightClientTypes.FilledMapFieldWells?
        /// The legend display setup of the visual.
        public var legend: QuickSightClientTypes.LegendOptions?
        /// The map style options of the filled map visual.
        public var mapStyleOptions: QuickSightClientTypes.GeospatialMapStyleOptions?
        /// The sort configuration of a FilledMapVisual.
        public var sortConfiguration: QuickSightClientTypes.FilledMapSortConfiguration?
        /// The tooltip display setup of the visual.
        public var tooltip: QuickSightClientTypes.TooltipOptions?
        /// The window options of the filled map visual.
        public var windowOptions: QuickSightClientTypes.GeospatialWindowOptions?

        public init (
            fieldWells: QuickSightClientTypes.FilledMapFieldWells? = nil,
            legend: QuickSightClientTypes.LegendOptions? = nil,
            mapStyleOptions: QuickSightClientTypes.GeospatialMapStyleOptions? = nil,
            sortConfiguration: QuickSightClientTypes.FilledMapSortConfiguration? = nil,
            tooltip: QuickSightClientTypes.TooltipOptions? = nil,
            windowOptions: QuickSightClientTypes.GeospatialWindowOptions? = nil
        )
        {
            self.fieldWells = fieldWells
            self.legend = legend
            self.mapStyleOptions = mapStyleOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.windowOptions = windowOptions
        }
    }

}

extension QuickSightClientTypes.FilledMapFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filledMapAggregatedFieldWells = "FilledMapAggregatedFieldWells"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filledMapAggregatedFieldWells = self.filledMapAggregatedFieldWells {
            try encodeContainer.encode(filledMapAggregatedFieldWells, forKey: .filledMapAggregatedFieldWells)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filledMapAggregatedFieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilledMapAggregatedFieldWells.self, forKey: .filledMapAggregatedFieldWells)
        filledMapAggregatedFieldWells = filledMapAggregatedFieldWellsDecoded
    }
}

extension QuickSightClientTypes {
    /// The field wells of a FilledMapVisual. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct FilledMapFieldWells: Swift.Equatable {
        /// The aggregated field well of the filled map.
        public var filledMapAggregatedFieldWells: QuickSightClientTypes.FilledMapAggregatedFieldWells?

        public init (
            filledMapAggregatedFieldWells: QuickSightClientTypes.FilledMapAggregatedFieldWells? = nil
        )
        {
            self.filledMapAggregatedFieldWells = filledMapAggregatedFieldWells
        }
    }

}

extension QuickSightClientTypes.FilledMapShapeConditionalFormatting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldId = "FieldId"
        case format = "Format"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let formatDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ShapeConditionalFormat.self, forKey: .format)
        format = formatDecoded
    }
}

extension QuickSightClientTypes {
    /// The conditional formatting that determines the shape of the filled map.
    public struct FilledMapShapeConditionalFormatting: Swift.Equatable {
        /// The field ID of the filled map shape.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The conditional formatting that determines the background color of a filled map's shape.
        public var format: QuickSightClientTypes.ShapeConditionalFormat?

        public init (
            fieldId: Swift.String? = nil,
            format: QuickSightClientTypes.ShapeConditionalFormat? = nil
        )
        {
            self.fieldId = fieldId
            self.format = format
        }
    }

}

extension QuickSightClientTypes.FilledMapSortConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categorySort = "CategorySort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categorySort = categorySort {
            var categorySortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categorySort)
            for fieldsortoptions0 in categorySort {
                try categorySortContainer.encode(fieldsortoptions0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categorySortContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FieldSortOptions?].self, forKey: .categorySort)
        var categorySortDecoded0:[QuickSightClientTypes.FieldSortOptions]? = nil
        if let categorySortContainer = categorySortContainer {
            categorySortDecoded0 = [QuickSightClientTypes.FieldSortOptions]()
            for structure0 in categorySortContainer {
                if let structure0 = structure0 {
                    categorySortDecoded0?.append(structure0)
                }
            }
        }
        categorySort = categorySortDecoded0
    }
}

extension QuickSightClientTypes {
    /// The sort configuration of a FilledMapVisual.
    public struct FilledMapSortConfiguration: Swift.Equatable {
        /// The sort configuration of the location fields.
        public var categorySort: [QuickSightClientTypes.FieldSortOptions]?

        public init (
            categorySort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.categorySort = categorySort
        }
    }

}

extension QuickSightClientTypes.FilledMapVisual: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case chartConfiguration = "ChartConfiguration"
        case columnHierarchies = "ColumnHierarchies"
        case conditionalFormatting = "ConditionalFormatting"
        case subtitle = "Subtitle"
        case title = "Title"
        case visualId = "VisualId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for visualcustomaction0 in actions {
                try actionsContainer.encode(visualcustomaction0)
            }
        }
        if let chartConfiguration = self.chartConfiguration {
            try encodeContainer.encode(chartConfiguration, forKey: .chartConfiguration)
        }
        if let columnHierarchies = columnHierarchies {
            var columnHierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnHierarchies)
            for columnhierarchy0 in columnHierarchies {
                try columnHierarchiesContainer.encode(columnhierarchy0)
            }
        }
        if let conditionalFormatting = self.conditionalFormatting {
            try encodeContainer.encode(conditionalFormatting, forKey: .conditionalFormatting)
        }
        if let subtitle = self.subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let visualId = self.visualId {
            try encodeContainer.encode(visualId, forKey: .visualId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visualIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visualId)
        visualId = visualIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualTitleLabelOptions.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualSubtitleLabelOptions.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let chartConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilledMapConfiguration.self, forKey: .chartConfiguration)
        chartConfiguration = chartConfigurationDecoded
        let conditionalFormattingDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilledMapConditionalFormatting.self, forKey: .conditionalFormatting)
        conditionalFormatting = conditionalFormattingDecoded
        let columnHierarchiesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnHierarchy?].self, forKey: .columnHierarchies)
        var columnHierarchiesDecoded0:[QuickSightClientTypes.ColumnHierarchy]? = nil
        if let columnHierarchiesContainer = columnHierarchiesContainer {
            columnHierarchiesDecoded0 = [QuickSightClientTypes.ColumnHierarchy]()
            for structure0 in columnHierarchiesContainer {
                if let structure0 = structure0 {
                    columnHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        columnHierarchies = columnHierarchiesDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.VisualCustomAction?].self, forKey: .actions)
        var actionsDecoded0:[QuickSightClientTypes.VisualCustomAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [QuickSightClientTypes.VisualCustomAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A filled map. For more information, see [Creating filled maps](https://docs.aws.amazon.com/quicksight/latest/user/filled-maps.html) in the Amazon QuickSight User Guide.
    public struct FilledMapVisual: Swift.Equatable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration settings of the visual.
        public var chartConfiguration: QuickSightClientTypes.FilledMapConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The conditional formatting of a FilledMapVisual.
        public var conditionalFormatting: QuickSightClientTypes.FilledMapConditionalFormatting?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        /// This member is required.
        public var visualId: Swift.String?

        public init (
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.FilledMapConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            conditionalFormatting: QuickSightClientTypes.FilledMapConditionalFormatting? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.conditionalFormatting = conditionalFormatting
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }

}

extension QuickSightClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryFilter = "CategoryFilter"
        case numericEqualityFilter = "NumericEqualityFilter"
        case numericRangeFilter = "NumericRangeFilter"
        case relativeDatesFilter = "RelativeDatesFilter"
        case timeEqualityFilter = "TimeEqualityFilter"
        case timeRangeFilter = "TimeRangeFilter"
        case topBottomFilter = "TopBottomFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryFilter = self.categoryFilter {
            try encodeContainer.encode(categoryFilter, forKey: .categoryFilter)
        }
        if let numericEqualityFilter = self.numericEqualityFilter {
            try encodeContainer.encode(numericEqualityFilter, forKey: .numericEqualityFilter)
        }
        if let numericRangeFilter = self.numericRangeFilter {
            try encodeContainer.encode(numericRangeFilter, forKey: .numericRangeFilter)
        }
        if let relativeDatesFilter = self.relativeDatesFilter {
            try encodeContainer.encode(relativeDatesFilter, forKey: .relativeDatesFilter)
        }
        if let timeEqualityFilter = self.timeEqualityFilter {
            try encodeContainer.encode(timeEqualityFilter, forKey: .timeEqualityFilter)
        }
        if let timeRangeFilter = self.timeRangeFilter {
            try encodeContainer.encode(timeRangeFilter, forKey: .timeRangeFilter)
        }
        if let topBottomFilter = self.topBottomFilter {
            try encodeContainer.encode(topBottomFilter, forKey: .topBottomFilter)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryFilterDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CategoryFilter.self, forKey: .categoryFilter)
        categoryFilter = categoryFilterDecoded
        let numericRangeFilterDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumericRangeFilter.self, forKey: .numericRangeFilter)
        numericRangeFilter = numericRangeFilterDecoded
        let numericEqualityFilterDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumericEqualityFilter.self, forKey: .numericEqualityFilter)
        numericEqualityFilter = numericEqualityFilterDecoded
        let timeEqualityFilterDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TimeEqualityFilter.self, forKey: .timeEqualityFilter)
        timeEqualityFilter = timeEqualityFilterDecoded
        let timeRangeFilterDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TimeRangeFilter.self, forKey: .timeRangeFilter)
        timeRangeFilter = timeRangeFilterDecoded
        let relativeDatesFilterDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RelativeDatesFilter.self, forKey: .relativeDatesFilter)
        relativeDatesFilter = relativeDatesFilterDecoded
        let topBottomFilterDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TopBottomFilter.self, forKey: .topBottomFilter)
        topBottomFilter = topBottomFilterDecoded
    }
}

extension QuickSightClientTypes {
    /// With a Filter, you can remove portions of data from a particular visual or view. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct Filter: Swift.Equatable {
        /// A CategoryFilter filters text values. For more information, see [Adding text filters](https://docs.aws.amazon.com/quicksight/latest/user/add-a-text-filter-data-prep.html) in the Amazon QuickSight User Guide.
        public var categoryFilter: QuickSightClientTypes.CategoryFilter?
        /// A NumericEqualityFilter filters numeric values that equal or do not equal a given numeric value.
        public var numericEqualityFilter: QuickSightClientTypes.NumericEqualityFilter?
        /// A NumericRangeFilter filters numeric values that are either inside or outside a given numeric range.
        public var numericRangeFilter: QuickSightClientTypes.NumericRangeFilter?
        /// A RelativeDatesFilter filters date values that are relative to a given date.
        public var relativeDatesFilter: QuickSightClientTypes.RelativeDatesFilter?
        /// A TimeEqualityFilter filters date-time values that equal or do not equal a given date/time value.
        public var timeEqualityFilter: QuickSightClientTypes.TimeEqualityFilter?
        /// A TimeRangeFilter filters date-time values that are either inside or outside a given date/time range.
        public var timeRangeFilter: QuickSightClientTypes.TimeRangeFilter?
        /// A TopBottomFilter filters data to the top or bottom values for a given column.
        public var topBottomFilter: QuickSightClientTypes.TopBottomFilter?

        public init (
            categoryFilter: QuickSightClientTypes.CategoryFilter? = nil,
            numericEqualityFilter: QuickSightClientTypes.NumericEqualityFilter? = nil,
            numericRangeFilter: QuickSightClientTypes.NumericRangeFilter? = nil,
            relativeDatesFilter: QuickSightClientTypes.RelativeDatesFilter? = nil,
            timeEqualityFilter: QuickSightClientTypes.TimeEqualityFilter? = nil,
            timeRangeFilter: QuickSightClientTypes.TimeRangeFilter? = nil,
            topBottomFilter: QuickSightClientTypes.TopBottomFilter? = nil
        )
        {
            self.categoryFilter = categoryFilter
            self.numericEqualityFilter = numericEqualityFilter
            self.numericRangeFilter = numericRangeFilter
            self.relativeDatesFilter = relativeDatesFilter
            self.timeEqualityFilter = timeEqualityFilter
            self.timeRangeFilter = timeRangeFilter
            self.topBottomFilter = topBottomFilter
        }
    }

}

extension QuickSightClientTypes.FilterControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateTimePicker = "DateTimePicker"
        case dropdown = "Dropdown"
        case list = "List"
        case relativeDateTime = "RelativeDateTime"
        case slider = "Slider"
        case textArea = "TextArea"
        case textField = "TextField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateTimePicker = self.dateTimePicker {
            try encodeContainer.encode(dateTimePicker, forKey: .dateTimePicker)
        }
        if let dropdown = self.dropdown {
            try encodeContainer.encode(dropdown, forKey: .dropdown)
        }
        if let list = self.list {
            try encodeContainer.encode(list, forKey: .list)
        }
        if let relativeDateTime = self.relativeDateTime {
            try encodeContainer.encode(relativeDateTime, forKey: .relativeDateTime)
        }
        if let slider = self.slider {
            try encodeContainer.encode(slider, forKey: .slider)
        }
        if let textArea = self.textArea {
            try encodeContainer.encode(textArea, forKey: .textArea)
        }
        if let textField = self.textField {
            try encodeContainer.encode(textField, forKey: .textField)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateTimePickerDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterDateTimePickerControl.self, forKey: .dateTimePicker)
        dateTimePicker = dateTimePickerDecoded
        let listDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterListControl.self, forKey: .list)
        list = listDecoded
        let dropdownDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterDropDownControl.self, forKey: .dropdown)
        dropdown = dropdownDecoded
        let textFieldDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterTextFieldControl.self, forKey: .textField)
        textField = textFieldDecoded
        let textAreaDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterTextAreaControl.self, forKey: .textArea)
        textArea = textAreaDecoded
        let sliderDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterSliderControl.self, forKey: .slider)
        slider = sliderDecoded
        let relativeDateTimeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterRelativeDateTimeControl.self, forKey: .relativeDateTime)
        relativeDateTime = relativeDateTimeDecoded
    }
}

extension QuickSightClientTypes {
    /// The control of a filter that is used to interact with a dashboard or an analysis. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct FilterControl: Swift.Equatable {
        /// A control from a date filter that is used to specify date and time.
        public var dateTimePicker: QuickSightClientTypes.FilterDateTimePickerControl?
        /// A control to display a dropdown list with buttons that are used to select a single value.
        public var dropdown: QuickSightClientTypes.FilterDropDownControl?
        /// A control to display a list of buttons or boxes. This is used to select either a single value or multiple values.
        public var list: QuickSightClientTypes.FilterListControl?
        /// A control from a date filter that is used to specify the relative date.
        public var relativeDateTime: QuickSightClientTypes.FilterRelativeDateTimeControl?
        /// A control to display a horizontal toggle bar. This is used to change a value by sliding the toggle.
        public var slider: QuickSightClientTypes.FilterSliderControl?
        /// A control to display a text box that is used to enter multiple entries.
        public var textArea: QuickSightClientTypes.FilterTextAreaControl?
        /// A control to display a text box that is used to enter a single entry.
        public var textField: QuickSightClientTypes.FilterTextFieldControl?

        public init (
            dateTimePicker: QuickSightClientTypes.FilterDateTimePickerControl? = nil,
            dropdown: QuickSightClientTypes.FilterDropDownControl? = nil,
            list: QuickSightClientTypes.FilterListControl? = nil,
            relativeDateTime: QuickSightClientTypes.FilterRelativeDateTimeControl? = nil,
            slider: QuickSightClientTypes.FilterSliderControl? = nil,
            textArea: QuickSightClientTypes.FilterTextAreaControl? = nil,
            textField: QuickSightClientTypes.FilterTextFieldControl? = nil
        )
        {
            self.dateTimePicker = dateTimePicker
            self.dropdown = dropdown
            self.list = list
            self.relativeDateTime = relativeDateTime
            self.slider = slider
            self.textArea = textArea
            self.textField = textField
        }
    }

}

extension QuickSightClientTypes.FilterDateTimePickerControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayOptions = "DisplayOptions"
        case filterControlId = "FilterControlId"
        case sourceFilterId = "SourceFilterId"
        case title = "Title"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayOptions = self.displayOptions {
            try encodeContainer.encode(displayOptions, forKey: .displayOptions)
        }
        if let filterControlId = self.filterControlId {
            try encodeContainer.encode(filterControlId, forKey: .filterControlId)
        }
        if let sourceFilterId = self.sourceFilterId {
            try encodeContainer.encode(sourceFilterId, forKey: .sourceFilterId)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterControlIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterControlId)
        filterControlId = filterControlIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let sourceFilterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFilterId)
        sourceFilterId = sourceFilterIdDecoded
        let displayOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DateTimePickerControlDisplayOptions.self, forKey: .displayOptions)
        displayOptions = displayOptionsDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SheetControlDateTimePickerType.self, forKey: .type)
        type = typeDecoded
    }
}

extension QuickSightClientTypes {
    /// A control from a date filter that is used to specify date and time.
    public struct FilterDateTimePickerControl: Swift.Equatable {
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.DateTimePickerControlDisplayOptions?
        /// The ID of the FilterDateTimePickerControl.
        /// This member is required.
        public var filterControlId: Swift.String?
        /// The source filter ID of the FilterDateTimePickerControl.
        /// This member is required.
        public var sourceFilterId: Swift.String?
        /// The title of the FilterDateTimePickerControl.
        /// This member is required.
        public var title: Swift.String?
        /// The date time picker type of a FilterDateTimePickerControl. Choose one of the following options:
        ///
        /// * SINGLE_VALUED: The filter condition is a fixed date.
        ///
        /// * DATE_RANGE: The filter condition is a date time range.
        public var type: QuickSightClientTypes.SheetControlDateTimePickerType?

        public init (
            displayOptions: QuickSightClientTypes.DateTimePickerControlDisplayOptions? = nil,
            filterControlId: Swift.String? = nil,
            sourceFilterId: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QuickSightClientTypes.SheetControlDateTimePickerType? = nil
        )
        {
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.sourceFilterId = sourceFilterId
            self.title = title
            self.type = type
        }
    }

}

extension QuickSightClientTypes.FilterDropDownControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cascadingControlConfiguration = "CascadingControlConfiguration"
        case displayOptions = "DisplayOptions"
        case filterControlId = "FilterControlId"
        case selectableValues = "SelectableValues"
        case sourceFilterId = "SourceFilterId"
        case title = "Title"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cascadingControlConfiguration = self.cascadingControlConfiguration {
            try encodeContainer.encode(cascadingControlConfiguration, forKey: .cascadingControlConfiguration)
        }
        if let displayOptions = self.displayOptions {
            try encodeContainer.encode(displayOptions, forKey: .displayOptions)
        }
        if let filterControlId = self.filterControlId {
            try encodeContainer.encode(filterControlId, forKey: .filterControlId)
        }
        if let selectableValues = self.selectableValues {
            try encodeContainer.encode(selectableValues, forKey: .selectableValues)
        }
        if let sourceFilterId = self.sourceFilterId {
            try encodeContainer.encode(sourceFilterId, forKey: .sourceFilterId)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterControlIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterControlId)
        filterControlId = filterControlIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let sourceFilterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFilterId)
        sourceFilterId = sourceFilterIdDecoded
        let displayOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DropDownControlDisplayOptions.self, forKey: .displayOptions)
        displayOptions = displayOptionsDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SheetControlListType.self, forKey: .type)
        type = typeDecoded
        let selectableValuesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterSelectableValues.self, forKey: .selectableValues)
        selectableValues = selectableValuesDecoded
        let cascadingControlConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CascadingControlConfiguration.self, forKey: .cascadingControlConfiguration)
        cascadingControlConfiguration = cascadingControlConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// A control to display a dropdown list with buttons that are used to select a single value.
    public struct FilterDropDownControl: Swift.Equatable {
        /// The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.
        public var cascadingControlConfiguration: QuickSightClientTypes.CascadingControlConfiguration?
        /// The display options of the FilterDropDownControl.
        public var displayOptions: QuickSightClientTypes.DropDownControlDisplayOptions?
        /// The ID of the FilterDropDownControl.
        /// This member is required.
        public var filterControlId: Swift.String?
        /// A list of selectable values that are used in a control.
        public var selectableValues: QuickSightClientTypes.FilterSelectableValues?
        /// The source filter ID of the FilterDropDownControl.
        /// This member is required.
        public var sourceFilterId: Swift.String?
        /// The title of the FilterDropDownControl.
        /// This member is required.
        public var title: Swift.String?
        /// The type of the FilterDropDownControl. Choose one of the following options:
        ///
        /// * MULTI_SELECT: The user can select multiple entries from a dropdown menu.
        ///
        /// * SINGLE_SELECT: The user can select a single entry from a dropdown menu.
        public var type: QuickSightClientTypes.SheetControlListType?

        public init (
            cascadingControlConfiguration: QuickSightClientTypes.CascadingControlConfiguration? = nil,
            displayOptions: QuickSightClientTypes.DropDownControlDisplayOptions? = nil,
            filterControlId: Swift.String? = nil,
            selectableValues: QuickSightClientTypes.FilterSelectableValues? = nil,
            sourceFilterId: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QuickSightClientTypes.SheetControlListType? = nil
        )
        {
            self.cascadingControlConfiguration = cascadingControlConfiguration
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.selectableValues = selectableValues
            self.sourceFilterId = sourceFilterId
            self.title = title
            self.type = type
        }
    }

}

extension QuickSightClientTypes.FilterGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossDataset = "CrossDataset"
        case filterGroupId = "FilterGroupId"
        case filters = "Filters"
        case scopeConfiguration = "ScopeConfiguration"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crossDataset = self.crossDataset {
            try encodeContainer.encode(crossDataset.rawValue, forKey: .crossDataset)
        }
        if let filterGroupId = self.filterGroupId {
            try encodeContainer.encode(filterGroupId, forKey: .filterGroupId)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let scopeConfiguration = self.scopeConfiguration {
            try encodeContainer.encode(scopeConfiguration, forKey: .scopeConfiguration)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterGroupId)
        filterGroupId = filterGroupIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[QuickSightClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [QuickSightClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let scopeConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterScopeConfiguration.self, forKey: .scopeConfiguration)
        scopeConfiguration = scopeConfigurationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.WidgetStatus.self, forKey: .status)
        status = statusDecoded
        let crossDatasetDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CrossDatasetTypes.self, forKey: .crossDataset)
        crossDataset = crossDatasetDecoded
    }
}

extension QuickSightClientTypes {
    /// A grouping of individual filters. Filter groups are applied to the same group of visuals. For more information, see [Adding filter conditions (group filters) with AND and OR operators](https://docs.aws.amazon.com/quicksight/latest/user/add-a-compound-filter.html) in the Amazon QuickSight User Guide.
    public struct FilterGroup: Swift.Equatable {
        /// The filter new feature which can apply filter group to all data sets. Choose one of the following options:
        ///
        /// * ALL_DATASETS
        ///
        /// * SINGLE_DATASET
        /// This member is required.
        public var crossDataset: QuickSightClientTypes.CrossDatasetTypes?
        /// The value that uniquely identifies a FilterGroup within a dashboard, template, or analysis.
        /// This member is required.
        public var filterGroupId: Swift.String?
        /// The list of filters that are present in a FilterGroup.
        /// This member is required.
        public var filters: [QuickSightClientTypes.Filter]?
        /// The configuration that specifies what scope to apply to a FilterGroup. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
        /// This member is required.
        public var scopeConfiguration: QuickSightClientTypes.FilterScopeConfiguration?
        /// The status of the FilterGroup.
        public var status: QuickSightClientTypes.WidgetStatus?

        public init (
            crossDataset: QuickSightClientTypes.CrossDatasetTypes? = nil,
            filterGroupId: Swift.String? = nil,
            filters: [QuickSightClientTypes.Filter]? = nil,
            scopeConfiguration: QuickSightClientTypes.FilterScopeConfiguration? = nil,
            status: QuickSightClientTypes.WidgetStatus? = nil
        )
        {
            self.crossDataset = crossDataset
            self.filterGroupId = filterGroupId
            self.filters = filters
            self.scopeConfiguration = scopeConfiguration
            self.status = status
        }
    }

}

extension QuickSightClientTypes.FilterListConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryValues = "CategoryValues"
        case matchOperator = "MatchOperator"
        case selectAllOptions = "SelectAllOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryValues = categoryValues {
            var categoryValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categoryValues)
            for categoryvalue0 in categoryValues {
                try categoryValuesContainer.encode(categoryvalue0)
            }
        }
        if let matchOperator = self.matchOperator {
            try encodeContainer.encode(matchOperator.rawValue, forKey: .matchOperator)
        }
        if let selectAllOptions = self.selectAllOptions {
            try encodeContainer.encode(selectAllOptions.rawValue, forKey: .selectAllOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchOperatorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CategoryFilterMatchOperator.self, forKey: .matchOperator)
        matchOperator = matchOperatorDecoded
        let categoryValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .categoryValues)
        var categoryValuesDecoded0:[Swift.String]? = nil
        if let categoryValuesContainer = categoryValuesContainer {
            categoryValuesDecoded0 = [Swift.String]()
            for string0 in categoryValuesContainer {
                if let string0 = string0 {
                    categoryValuesDecoded0?.append(string0)
                }
            }
        }
        categoryValues = categoryValuesDecoded0
        let selectAllOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CategoryFilterSelectAllOptions.self, forKey: .selectAllOptions)
        selectAllOptions = selectAllOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// A list of filter configurations.
    public struct FilterListConfiguration: Swift.Equatable {
        /// The list of category values for the filter.
        public var categoryValues: [Swift.String]?
        /// The match operator that is used to determine if a filter should be applied.
        /// This member is required.
        public var matchOperator: QuickSightClientTypes.CategoryFilterMatchOperator?
        /// Select all of the values. Null is not the assigned value of select all.
        ///
        /// * FILTER_ALL_VALUES
        public var selectAllOptions: QuickSightClientTypes.CategoryFilterSelectAllOptions?

        public init (
            categoryValues: [Swift.String]? = nil,
            matchOperator: QuickSightClientTypes.CategoryFilterMatchOperator? = nil,
            selectAllOptions: QuickSightClientTypes.CategoryFilterSelectAllOptions? = nil
        )
        {
            self.categoryValues = categoryValues
            self.matchOperator = matchOperator
            self.selectAllOptions = selectAllOptions
        }
    }

}

extension QuickSightClientTypes.FilterListControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cascadingControlConfiguration = "CascadingControlConfiguration"
        case displayOptions = "DisplayOptions"
        case filterControlId = "FilterControlId"
        case selectableValues = "SelectableValues"
        case sourceFilterId = "SourceFilterId"
        case title = "Title"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cascadingControlConfiguration = self.cascadingControlConfiguration {
            try encodeContainer.encode(cascadingControlConfiguration, forKey: .cascadingControlConfiguration)
        }
        if let displayOptions = self.displayOptions {
            try encodeContainer.encode(displayOptions, forKey: .displayOptions)
        }
        if let filterControlId = self.filterControlId {
            try encodeContainer.encode(filterControlId, forKey: .filterControlId)
        }
        if let selectableValues = self.selectableValues {
            try encodeContainer.encode(selectableValues, forKey: .selectableValues)
        }
        if let sourceFilterId = self.sourceFilterId {
            try encodeContainer.encode(sourceFilterId, forKey: .sourceFilterId)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterControlIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterControlId)
        filterControlId = filterControlIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let sourceFilterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFilterId)
        sourceFilterId = sourceFilterIdDecoded
        let displayOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ListControlDisplayOptions.self, forKey: .displayOptions)
        displayOptions = displayOptionsDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SheetControlListType.self, forKey: .type)
        type = typeDecoded
        let selectableValuesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterSelectableValues.self, forKey: .selectableValues)
        selectableValues = selectableValuesDecoded
        let cascadingControlConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CascadingControlConfiguration.self, forKey: .cascadingControlConfiguration)
        cascadingControlConfiguration = cascadingControlConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// A control to display a list of buttons or boxes. This is used to select either a single value or multiple values.
    public struct FilterListControl: Swift.Equatable {
        /// The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.
        public var cascadingControlConfiguration: QuickSightClientTypes.CascadingControlConfiguration?
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.ListControlDisplayOptions?
        /// The ID of the FilterListControl.
        /// This member is required.
        public var filterControlId: Swift.String?
        /// A list of selectable values that are used in a control.
        public var selectableValues: QuickSightClientTypes.FilterSelectableValues?
        /// The source filter ID of the FilterListControl.
        /// This member is required.
        public var sourceFilterId: Swift.String?
        /// The title of the FilterListControl.
        /// This member is required.
        public var title: Swift.String?
        /// The type of FilterListControl. Choose one of the following options:
        ///
        /// * MULTI_SELECT: The user can select multiple entries from the list.
        ///
        /// * SINGLE_SELECT: The user can select a single entry from the list.
        public var type: QuickSightClientTypes.SheetControlListType?

        public init (
            cascadingControlConfiguration: QuickSightClientTypes.CascadingControlConfiguration? = nil,
            displayOptions: QuickSightClientTypes.ListControlDisplayOptions? = nil,
            filterControlId: Swift.String? = nil,
            selectableValues: QuickSightClientTypes.FilterSelectableValues? = nil,
            sourceFilterId: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QuickSightClientTypes.SheetControlListType? = nil
        )
        {
            self.cascadingControlConfiguration = cascadingControlConfiguration
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.selectableValues = selectableValues
            self.sourceFilterId = sourceFilterId
            self.title = title
            self.type = type
        }
    }

}

extension QuickSightClientTypes {
    public enum FilterNullOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allValues
        case nonNullsOnly
        case nullsOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterNullOption] {
            return [
                .allValues,
                .nonNullsOnly,
                .nullsOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allValues: return "ALL_VALUES"
            case .nonNullsOnly: return "NON_NULLS_ONLY"
            case .nullsOnly: return "NULLS_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterNullOption(rawValue: rawValue) ?? FilterNullOption.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.FilterOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conditionExpression = "ConditionExpression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conditionExpression = self.conditionExpression {
            try encodeContainer.encode(conditionExpression, forKey: .conditionExpression)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conditionExpression)
        conditionExpression = conditionExpressionDecoded
    }
}

extension QuickSightClientTypes.FilterOperation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FilterOperation(conditionExpression: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {
    /// A transform operation that filters rows based on a condition.
    public struct FilterOperation: Swift.Equatable {
        /// An expression that must evaluate to a Boolean value. Rows for which the expression evaluates to true are kept in the dataset.
        /// This member is required.
        public var conditionExpression: Swift.String?

        public init (
            conditionExpression: Swift.String? = nil
        )
        {
            self.conditionExpression = conditionExpression
        }
    }

}

extension QuickSightClientTypes.FilterOperationSelectedFieldsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case selectedFieldOptions = "SelectedFieldOptions"
        case selectedFields = "SelectedFields"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let selectedFieldOptions = self.selectedFieldOptions {
            try encodeContainer.encode(selectedFieldOptions.rawValue, forKey: .selectedFieldOptions)
        }
        if let selectedFields = selectedFields {
            var selectedFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedFields)
            for fieldid0 in selectedFields {
                try selectedFieldsContainer.encode(fieldid0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectedFieldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedFields)
        var selectedFieldsDecoded0:[Swift.String]? = nil
        if let selectedFieldsContainer = selectedFieldsContainer {
            selectedFieldsDecoded0 = [Swift.String]()
            for string0 in selectedFieldsContainer {
                if let string0 = string0 {
                    selectedFieldsDecoded0?.append(string0)
                }
            }
        }
        selectedFields = selectedFieldsDecoded0
        let selectedFieldOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SelectedFieldOptions.self, forKey: .selectedFieldOptions)
        selectedFieldOptions = selectedFieldOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of selected fields in theCustomActionFilterOperation. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct FilterOperationSelectedFieldsConfiguration: Swift.Equatable {
        /// A structure that contains the options that choose which fields are filtered in the CustomActionFilterOperation. Valid values are defined as follows:
        ///
        /// * ALL_FIELDS: Applies the filter operation to all fields.
        public var selectedFieldOptions: QuickSightClientTypes.SelectedFieldOptions?
        /// Chooses the fields that are filtered in CustomActionFilterOperation.
        public var selectedFields: [Swift.String]?

        public init (
            selectedFieldOptions: QuickSightClientTypes.SelectedFieldOptions? = nil,
            selectedFields: [Swift.String]? = nil
        )
        {
            self.selectedFieldOptions = selectedFieldOptions
            self.selectedFields = selectedFields
        }
    }

}

extension QuickSightClientTypes.FilterOperationTargetVisualsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sameSheetTargetVisualConfiguration = "SameSheetTargetVisualConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sameSheetTargetVisualConfiguration = self.sameSheetTargetVisualConfiguration {
            try encodeContainer.encode(sameSheetTargetVisualConfiguration, forKey: .sameSheetTargetVisualConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sameSheetTargetVisualConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SameSheetTargetVisualConfiguration.self, forKey: .sameSheetTargetVisualConfiguration)
        sameSheetTargetVisualConfiguration = sameSheetTargetVisualConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of target visuals that you want to be filtered. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct FilterOperationTargetVisualsConfiguration: Swift.Equatable {
        /// The configuration of the same-sheet target visuals that you want to be filtered.
        public var sameSheetTargetVisualConfiguration: QuickSightClientTypes.SameSheetTargetVisualConfiguration?

        public init (
            sameSheetTargetVisualConfiguration: QuickSightClientTypes.SameSheetTargetVisualConfiguration? = nil
        )
        {
            self.sameSheetTargetVisualConfiguration = sameSheetTargetVisualConfiguration
        }
    }

}

extension QuickSightClientTypes {
    public enum FilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case stringequals
        case stringlike
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterOperator] {
            return [
                .stringequals,
                .stringlike,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .stringequals: return "StringEquals"
            case .stringlike: return "StringLike"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterOperator(rawValue: rawValue) ?? FilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.FilterRelativeDateTimeControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayOptions = "DisplayOptions"
        case filterControlId = "FilterControlId"
        case sourceFilterId = "SourceFilterId"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayOptions = self.displayOptions {
            try encodeContainer.encode(displayOptions, forKey: .displayOptions)
        }
        if let filterControlId = self.filterControlId {
            try encodeContainer.encode(filterControlId, forKey: .filterControlId)
        }
        if let sourceFilterId = self.sourceFilterId {
            try encodeContainer.encode(sourceFilterId, forKey: .sourceFilterId)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterControlIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterControlId)
        filterControlId = filterControlIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let sourceFilterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFilterId)
        sourceFilterId = sourceFilterIdDecoded
        let displayOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RelativeDateTimeControlDisplayOptions.self, forKey: .displayOptions)
        displayOptions = displayOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// A control from a date filter that is used to specify the relative date.
    public struct FilterRelativeDateTimeControl: Swift.Equatable {
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.RelativeDateTimeControlDisplayOptions?
        /// The ID of the FilterTextAreaControl.
        /// This member is required.
        public var filterControlId: Swift.String?
        /// The source filter ID of the FilterTextAreaControl.
        /// This member is required.
        public var sourceFilterId: Swift.String?
        /// The title of the FilterTextAreaControl.
        /// This member is required.
        public var title: Swift.String?

        public init (
            displayOptions: QuickSightClientTypes.RelativeDateTimeControlDisplayOptions? = nil,
            filterControlId: Swift.String? = nil,
            sourceFilterId: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.sourceFilterId = sourceFilterId
            self.title = title
        }
    }

}

extension QuickSightClientTypes.FilterScopeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case selectedSheets = "SelectedSheets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let selectedSheets = self.selectedSheets {
            try encodeContainer.encode(selectedSheets, forKey: .selectedSheets)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectedSheetsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SelectedSheetsFilterScopeConfiguration.self, forKey: .selectedSheets)
        selectedSheets = selectedSheetsDecoded
    }
}

extension QuickSightClientTypes {
    /// The scope configuration for a FilterGroup. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct FilterScopeConfiguration: Swift.Equatable {
        /// The configuration for applying a filter to specific sheets.
        public var selectedSheets: QuickSightClientTypes.SelectedSheetsFilterScopeConfiguration?

        public init (
            selectedSheets: QuickSightClientTypes.SelectedSheetsFilterScopeConfiguration? = nil
        )
        {
            self.selectedSheets = selectedSheets
        }
    }

}

extension QuickSightClientTypes.FilterSelectableValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string0 in values {
                try valuesContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension QuickSightClientTypes {
    /// A list of selectable values that are used in a control.
    public struct FilterSelectableValues: Swift.Equatable {
        /// The values that are used in the FilterSelectableValues.
        public var values: [Swift.String]?

        public init (
            values: [Swift.String]? = nil
        )
        {
            self.values = values
        }
    }

}

extension QuickSightClientTypes.FilterSliderControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayOptions = "DisplayOptions"
        case filterControlId = "FilterControlId"
        case maximumValue = "MaximumValue"
        case minimumValue = "MinimumValue"
        case sourceFilterId = "SourceFilterId"
        case stepSize = "StepSize"
        case title = "Title"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayOptions = self.displayOptions {
            try encodeContainer.encode(displayOptions, forKey: .displayOptions)
        }
        if let filterControlId = self.filterControlId {
            try encodeContainer.encode(filterControlId, forKey: .filterControlId)
        }
        if maximumValue != 0.0 {
            try encodeContainer.encode(maximumValue, forKey: .maximumValue)
        }
        if minimumValue != 0.0 {
            try encodeContainer.encode(minimumValue, forKey: .minimumValue)
        }
        if let sourceFilterId = self.sourceFilterId {
            try encodeContainer.encode(sourceFilterId, forKey: .sourceFilterId)
        }
        if stepSize != 0.0 {
            try encodeContainer.encode(stepSize, forKey: .stepSize)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterControlIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterControlId)
        filterControlId = filterControlIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let sourceFilterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFilterId)
        sourceFilterId = sourceFilterIdDecoded
        let displayOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SliderControlDisplayOptions.self, forKey: .displayOptions)
        displayOptions = displayOptionsDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SheetControlSliderType.self, forKey: .type)
        type = typeDecoded
        let maximumValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .maximumValue) ?? 0.0
        maximumValue = maximumValueDecoded
        let minimumValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minimumValue) ?? 0.0
        minimumValue = minimumValueDecoded
        let stepSizeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .stepSize) ?? 0.0
        stepSize = stepSizeDecoded
    }
}

extension QuickSightClientTypes {
    /// A control to display a horizontal toggle bar. This is used to change a value by sliding the toggle.
    public struct FilterSliderControl: Swift.Equatable {
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.SliderControlDisplayOptions?
        /// The ID of the FilterSliderControl.
        /// This member is required.
        public var filterControlId: Swift.String?
        /// The smaller value that is displayed at the left of the slider.
        /// This member is required.
        public var maximumValue: Swift.Double
        /// The larger value that is displayed at the right of the slider.
        /// This member is required.
        public var minimumValue: Swift.Double
        /// The source filter ID of the FilterSliderControl.
        /// This member is required.
        public var sourceFilterId: Swift.String?
        /// The number of increments that the slider bar is divided into.
        /// This member is required.
        public var stepSize: Swift.Double
        /// The title of the FilterSliderControl.
        /// This member is required.
        public var title: Swift.String?
        /// The type of FilterSliderControl. Choose one of the following options:
        ///
        /// * SINGLE_POINT: Filter against(equals) a single data point.
        ///
        /// * RANGE: Filter data that is in a specified range.
        public var type: QuickSightClientTypes.SheetControlSliderType?

        public init (
            displayOptions: QuickSightClientTypes.SliderControlDisplayOptions? = nil,
            filterControlId: Swift.String? = nil,
            maximumValue: Swift.Double = 0.0,
            minimumValue: Swift.Double = 0.0,
            sourceFilterId: Swift.String? = nil,
            stepSize: Swift.Double = 0.0,
            title: Swift.String? = nil,
            type: QuickSightClientTypes.SheetControlSliderType? = nil
        )
        {
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.maximumValue = maximumValue
            self.minimumValue = minimumValue
            self.sourceFilterId = sourceFilterId
            self.stepSize = stepSize
            self.title = title
            self.type = type
        }
    }

}

extension QuickSightClientTypes.FilterTextAreaControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delimiter = "Delimiter"
        case displayOptions = "DisplayOptions"
        case filterControlId = "FilterControlId"
        case sourceFilterId = "SourceFilterId"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let delimiter = self.delimiter {
            try encodeContainer.encode(delimiter, forKey: .delimiter)
        }
        if let displayOptions = self.displayOptions {
            try encodeContainer.encode(displayOptions, forKey: .displayOptions)
        }
        if let filterControlId = self.filterControlId {
            try encodeContainer.encode(filterControlId, forKey: .filterControlId)
        }
        if let sourceFilterId = self.sourceFilterId {
            try encodeContainer.encode(sourceFilterId, forKey: .sourceFilterId)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterControlIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterControlId)
        filterControlId = filterControlIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let sourceFilterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFilterId)
        sourceFilterId = sourceFilterIdDecoded
        let delimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let displayOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TextAreaControlDisplayOptions.self, forKey: .displayOptions)
        displayOptions = displayOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// A control to display a text box that is used to enter multiple entries.
    public struct FilterTextAreaControl: Swift.Equatable {
        /// The delimiter that is used to separate the lines in text.
        public var delimiter: Swift.String?
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.TextAreaControlDisplayOptions?
        /// The ID of the FilterTextAreaControl.
        /// This member is required.
        public var filterControlId: Swift.String?
        /// The source filter ID of the FilterTextAreaControl.
        /// This member is required.
        public var sourceFilterId: Swift.String?
        /// The title of the FilterTextAreaControl.
        /// This member is required.
        public var title: Swift.String?

        public init (
            delimiter: Swift.String? = nil,
            displayOptions: QuickSightClientTypes.TextAreaControlDisplayOptions? = nil,
            filterControlId: Swift.String? = nil,
            sourceFilterId: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.delimiter = delimiter
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.sourceFilterId = sourceFilterId
            self.title = title
        }
    }

}

extension QuickSightClientTypes.FilterTextFieldControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayOptions = "DisplayOptions"
        case filterControlId = "FilterControlId"
        case sourceFilterId = "SourceFilterId"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayOptions = self.displayOptions {
            try encodeContainer.encode(displayOptions, forKey: .displayOptions)
        }
        if let filterControlId = self.filterControlId {
            try encodeContainer.encode(filterControlId, forKey: .filterControlId)
        }
        if let sourceFilterId = self.sourceFilterId {
            try encodeContainer.encode(sourceFilterId, forKey: .sourceFilterId)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterControlIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterControlId)
        filterControlId = filterControlIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let sourceFilterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFilterId)
        sourceFilterId = sourceFilterIdDecoded
        let displayOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TextFieldControlDisplayOptions.self, forKey: .displayOptions)
        displayOptions = displayOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// A control to display a text box that is used to enter a single entry.
    public struct FilterTextFieldControl: Swift.Equatable {
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.TextFieldControlDisplayOptions?
        /// The ID of the FilterTextFieldControl.
        /// This member is required.
        public var filterControlId: Swift.String?
        /// The source filter ID of the FilterTextFieldControl.
        /// This member is required.
        public var sourceFilterId: Swift.String?
        /// The title of the FilterTextFieldControl.
        /// This member is required.
        public var title: Swift.String?

        public init (
            displayOptions: QuickSightClientTypes.TextFieldControlDisplayOptions? = nil,
            filterControlId: Swift.String? = nil,
            sourceFilterId: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.sourceFilterId = sourceFilterId
            self.title = title
        }
    }

}

extension QuickSightClientTypes {
    public enum FilterVisualScope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allVisuals
        case selectedVisuals
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterVisualScope] {
            return [
                .allVisuals,
                .selectedVisuals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allVisuals: return "ALL_VISUALS"
            case .selectedVisuals: return "SELECTED_VISUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterVisualScope(rawValue: rawValue) ?? FilterVisualScope.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.Folder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case folderId = "FolderId"
        case folderPath = "FolderPath"
        case folderType = "FolderType"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let folderId = self.folderId {
            try encodeContainer.encode(folderId, forKey: .folderId)
        }
        if let folderPath = folderPath {
            var folderPathContainer = encodeContainer.nestedUnkeyedContainer(forKey: .folderPath)
            for arn0 in folderPath {
                try folderPathContainer.encode(arn0)
            }
        }
        if let folderType = self.folderType {
            try encodeContainer.encode(folderType.rawValue, forKey: .folderType)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let folderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .folderId)
        folderId = folderIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let folderTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FolderType.self, forKey: .folderType)
        folderType = folderTypeDecoded
        let folderPathContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .folderPath)
        var folderPathDecoded0:[Swift.String]? = nil
        if let folderPathContainer = folderPathContainer {
            folderPathDecoded0 = [Swift.String]()
            for string0 in folderPathContainer {
                if let string0 = string0 {
                    folderPathDecoded0?.append(string0)
                }
            }
        }
        folderPath = folderPathDecoded0
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension QuickSightClientTypes {
    /// A folder in Amazon QuickSight.
    public struct Folder: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the folder.
        public var arn: Swift.String?
        /// The time that the folder was created.
        public var createdTime: ClientRuntime.Date?
        /// The ID of the folder.
        public var folderId: Swift.String?
        /// An array of ancestor ARN strings for the folder.
        public var folderPath: [Swift.String]?
        /// The type of folder it is.
        public var folderType: QuickSightClientTypes.FolderType?
        /// The time that the folder was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// A display name for the folder.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            folderId: Swift.String? = nil,
            folderPath: [Swift.String]? = nil,
            folderType: QuickSightClientTypes.FolderType? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.folderId = folderId
            self.folderPath = folderPath
            self.folderType = folderType
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }
    }

}

extension QuickSightClientTypes {
    public enum FolderFilterAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case directQuicksightOwner
        case directQuicksightSoleOwner
        case directQuicksightViewerOrOwner
        case folderName
        case parentFolderArn
        case quicksightOwner
        case quicksightViewerOrOwner
        case sdkUnknown(Swift.String)

        public static var allCases: [FolderFilterAttribute] {
            return [
                .directQuicksightOwner,
                .directQuicksightSoleOwner,
                .directQuicksightViewerOrOwner,
                .folderName,
                .parentFolderArn,
                .quicksightOwner,
                .quicksightViewerOrOwner,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .directQuicksightOwner: return "DIRECT_QUICKSIGHT_OWNER"
            case .directQuicksightSoleOwner: return "DIRECT_QUICKSIGHT_SOLE_OWNER"
            case .directQuicksightViewerOrOwner: return "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
            case .folderName: return "FOLDER_NAME"
            case .parentFolderArn: return "PARENT_FOLDER_ARN"
            case .quicksightOwner: return "QUICKSIGHT_OWNER"
            case .quicksightViewerOrOwner: return "QUICKSIGHT_VIEWER_OR_OWNER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FolderFilterAttribute(rawValue: rawValue) ?? FolderFilterAttribute.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.FolderMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberId = "MemberId"
        case memberType = "MemberType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberId = self.memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
        if let memberType = self.memberType {
            try encodeContainer.encode(memberType.rawValue, forKey: .memberType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberId)
        memberId = memberIdDecoded
        let memberTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.MemberType.self, forKey: .memberType)
        memberType = memberTypeDecoded
    }
}

extension QuickSightClientTypes {
    /// An asset in a Amazon QuickSight folder, such as a dashboard, analysis, or dataset.
    public struct FolderMember: Swift.Equatable {
        /// The ID of an asset in the folder.
        public var memberId: Swift.String?
        /// The type of asset that it is.
        public var memberType: QuickSightClientTypes.MemberType?

        public init (
            memberId: Swift.String? = nil,
            memberType: QuickSightClientTypes.MemberType? = nil
        )
        {
            self.memberId = memberId
            self.memberType = memberType
        }
    }

}

extension QuickSightClientTypes.FolderSearchFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case `operator` = "Operator"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let nameDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FolderFilterAttribute.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension QuickSightClientTypes {
    /// A filter to use to search an Amazon QuickSight folder.
    public struct FolderSearchFilter: Swift.Equatable {
        /// The name of a value that you want to use in the filter. For example, "Name": "QUICKSIGHT_OWNER". Valid values are defined as follows:
        ///
        /// * QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any folders with that ARN listed as one of the folder's owners or viewers are returned. Implicit permissions from folders or groups are considered.
        ///
        /// * QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any folders with that ARN listed as one of the owners of the folders are returned. Implicit permissions from folders or groups are considered.
        ///
        /// * DIRECT_QUICKSIGHT_SOLE_OWNER: Provide an ARN of a user or group, and any folders with that ARN listed as the only owner of the folder are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DIRECT_QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any folders with that ARN listed as one of the owners of the folders are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DIRECT_QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any folders with that ARN listed as one of the owners or viewers of the folders are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * FOLDER_NAME: Any folders whose names have a substring match to this value will be returned.
        ///
        /// * PARENT_FOLDER_ARN: Provide an ARN of a folder, and any folders that are directly under that parent folder are returned. If you choose to use this option and leave the value blank, all root-level folders in the account are returned.
        public var name: QuickSightClientTypes.FolderFilterAttribute?
        /// The comparison operator that you want to use as a filter, for example "Operator": "StringEquals". Valid values are "StringEquals" and "StringLike". If you set the operator value to "StringEquals", you need to provide an ownership related filter in the "NAME" field and the arn of the user or group whose folders you want to search in the "Value" field. For example, "Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1". If you set the value to "StringLike", you need to provide the name of the folders you are searching for. For example, "Name":"FOLDER_NAME", "Operator": "StringLike", "Value": "Test". The "StringLike" operator only supports the NAME value FOLDER_NAME.
        public var `operator`: QuickSightClientTypes.FilterOperator?
        /// The value of the named item (in this example, PARENT_FOLDER_ARN), that you want to use as a filter. For example, "Value": "arn:aws:quicksight:us-east-1:1:folder/folderId".
        public var value: Swift.String?

        public init (
            name: QuickSightClientTypes.FolderFilterAttribute? = nil,
            `operator`: QuickSightClientTypes.FilterOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }
    }

}

extension QuickSightClientTypes.FolderSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case folderId = "FolderId"
        case folderType = "FolderType"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let folderId = self.folderId {
            try encodeContainer.encode(folderId, forKey: .folderId)
        }
        if let folderType = self.folderType {
            try encodeContainer.encode(folderType.rawValue, forKey: .folderType)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let folderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .folderId)
        folderId = folderIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let folderTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FolderType.self, forKey: .folderType)
        folderType = folderTypeDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension QuickSightClientTypes {
    /// A summary of information about an existing Amazon QuickSight folder.
    public struct FolderSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the folder.
        public var arn: Swift.String?
        /// The time that the folder was created.
        public var createdTime: ClientRuntime.Date?
        /// The ID of the folder.
        public var folderId: Swift.String?
        /// The type of folder.
        public var folderType: QuickSightClientTypes.FolderType?
        /// The time that the folder was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The display name of the folder.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            folderId: Swift.String? = nil,
            folderType: QuickSightClientTypes.FolderType? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.folderId = folderId
            self.folderType = folderType
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }
    }

}

extension QuickSightClientTypes {
    public enum FolderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [FolderType] {
            return [
                .shared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FolderType(rawValue: rawValue) ?? FolderType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.Font: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fontFamily = "FontFamily"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fontFamily = self.fontFamily {
            try encodeContainer.encode(fontFamily, forKey: .fontFamily)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fontFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fontFamily)
        fontFamily = fontFamilyDecoded
    }
}

extension QuickSightClientTypes {
    /// Determines the font settings.
    public struct Font: Swift.Equatable {
        /// Determines the font family settings.
        public var fontFamily: Swift.String?

        public init (
            fontFamily: Swift.String? = nil
        )
        {
            self.fontFamily = fontFamily
        }
    }

}

extension QuickSightClientTypes.FontConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fontColor = "FontColor"
        case fontDecoration = "FontDecoration"
        case fontSize = "FontSize"
        case fontStyle = "FontStyle"
        case fontWeight = "FontWeight"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fontColor = self.fontColor {
            try encodeContainer.encode(fontColor, forKey: .fontColor)
        }
        if let fontDecoration = self.fontDecoration {
            try encodeContainer.encode(fontDecoration.rawValue, forKey: .fontDecoration)
        }
        if let fontSize = self.fontSize {
            try encodeContainer.encode(fontSize, forKey: .fontSize)
        }
        if let fontStyle = self.fontStyle {
            try encodeContainer.encode(fontStyle.rawValue, forKey: .fontStyle)
        }
        if let fontWeight = self.fontWeight {
            try encodeContainer.encode(fontWeight, forKey: .fontWeight)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fontSizeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FontSize.self, forKey: .fontSize)
        fontSize = fontSizeDecoded
        let fontDecorationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FontDecoration.self, forKey: .fontDecoration)
        fontDecoration = fontDecorationDecoded
        let fontColorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fontColor)
        fontColor = fontColorDecoded
        let fontWeightDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FontWeight.self, forKey: .fontWeight)
        fontWeight = fontWeightDecoded
        let fontStyleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FontStyle.self, forKey: .fontStyle)
        fontStyle = fontStyleDecoded
    }
}

extension QuickSightClientTypes {
    /// Configures the display properties of the given text.
    public struct FontConfiguration: Swift.Equatable {
        /// Determines the color of the text.
        public var fontColor: Swift.String?
        /// Determines the appearance of decorative lines on the text.
        public var fontDecoration: QuickSightClientTypes.FontDecoration?
        /// The option that determines the text display size.
        public var fontSize: QuickSightClientTypes.FontSize?
        /// Determines the text display face that is inherited by the given font family.
        public var fontStyle: QuickSightClientTypes.FontStyle?
        /// The option that determines the text display weight, or boldness.
        public var fontWeight: QuickSightClientTypes.FontWeight?

        public init (
            fontColor: Swift.String? = nil,
            fontDecoration: QuickSightClientTypes.FontDecoration? = nil,
            fontSize: QuickSightClientTypes.FontSize? = nil,
            fontStyle: QuickSightClientTypes.FontStyle? = nil,
            fontWeight: QuickSightClientTypes.FontWeight? = nil
        )
        {
            self.fontColor = fontColor
            self.fontDecoration = fontDecoration
            self.fontSize = fontSize
            self.fontStyle = fontStyle
            self.fontWeight = fontWeight
        }
    }

}

extension QuickSightClientTypes {
    public enum FontDecoration: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case underline
        case sdkUnknown(Swift.String)

        public static var allCases: [FontDecoration] {
            return [
                .none,
                .underline,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .underline: return "UNDERLINE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FontDecoration(rawValue: rawValue) ?? FontDecoration.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.FontSize: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case relative = "Relative"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let relative = self.relative {
            try encodeContainer.encode(relative.rawValue, forKey: .relative)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relativeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RelativeFontSize.self, forKey: .relative)
        relative = relativeDecoded
    }
}

extension QuickSightClientTypes {
    /// The option that determines the text display size.
    public struct FontSize: Swift.Equatable {
        /// The lexical name for the text size, proportional to its surrounding context.
        public var relative: QuickSightClientTypes.RelativeFontSize?

        public init (
            relative: QuickSightClientTypes.RelativeFontSize? = nil
        )
        {
            self.relative = relative
        }
    }

}

extension QuickSightClientTypes {
    public enum FontStyle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case italic
        case normal
        case sdkUnknown(Swift.String)

        public static var allCases: [FontStyle] {
            return [
                .italic,
                .normal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .italic: return "ITALIC"
            case .normal: return "NORMAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FontStyle(rawValue: rawValue) ?? FontStyle.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.FontWeight: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FontWeightName.self, forKey: .name)
        name = nameDecoded
    }
}

extension QuickSightClientTypes {
    /// The option that determines the text display weight, or boldness.
    public struct FontWeight: Swift.Equatable {
        /// The lexical name for the level of boldness of the text display.
        public var name: QuickSightClientTypes.FontWeightName?

        public init (
            name: QuickSightClientTypes.FontWeightName? = nil
        )
        {
            self.name = name
        }
    }

}

extension QuickSightClientTypes {
    public enum FontWeightName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bold
        case normal
        case sdkUnknown(Swift.String)

        public static var allCases: [FontWeightName] {
            return [
                .bold,
                .normal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bold: return "BOLD"
            case .normal: return "NORMAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FontWeightName(rawValue: rawValue) ?? FontWeightName.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.ForecastComputation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computationId = "ComputationId"
        case customSeasonalityValue = "CustomSeasonalityValue"
        case lowerBoundary = "LowerBoundary"
        case name = "Name"
        case periodsBackward = "PeriodsBackward"
        case periodsForward = "PeriodsForward"
        case predictionInterval = "PredictionInterval"
        case seasonality = "Seasonality"
        case time = "Time"
        case upperBoundary = "UpperBoundary"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computationId = self.computationId {
            try encodeContainer.encode(computationId, forKey: .computationId)
        }
        if let customSeasonalityValue = self.customSeasonalityValue {
            try encodeContainer.encode(customSeasonalityValue, forKey: .customSeasonalityValue)
        }
        if let lowerBoundary = self.lowerBoundary {
            try encodeContainer.encode(lowerBoundary, forKey: .lowerBoundary)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let periodsBackward = self.periodsBackward {
            try encodeContainer.encode(periodsBackward, forKey: .periodsBackward)
        }
        if let periodsForward = self.periodsForward {
            try encodeContainer.encode(periodsForward, forKey: .periodsForward)
        }
        if let predictionInterval = self.predictionInterval {
            try encodeContainer.encode(predictionInterval, forKey: .predictionInterval)
        }
        if let seasonality = self.seasonality {
            try encodeContainer.encode(seasonality.rawValue, forKey: .seasonality)
        }
        if let time = self.time {
            try encodeContainer.encode(time, forKey: .time)
        }
        if let upperBoundary = self.upperBoundary {
            try encodeContainer.encode(upperBoundary, forKey: .upperBoundary)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .computationId)
        computationId = computationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let timeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DimensionField.self, forKey: .time)
        time = timeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.MeasureField.self, forKey: .value)
        value = valueDecoded
        let periodsForwardDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .periodsForward)
        periodsForward = periodsForwardDecoded
        let periodsBackwardDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .periodsBackward)
        periodsBackward = periodsBackwardDecoded
        let upperBoundaryDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .upperBoundary)
        upperBoundary = upperBoundaryDecoded
        let lowerBoundaryDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .lowerBoundary)
        lowerBoundary = lowerBoundaryDecoded
        let predictionIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .predictionInterval)
        predictionInterval = predictionIntervalDecoded
        let seasonalityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ForecastComputationSeasonality.self, forKey: .seasonality)
        seasonality = seasonalityDecoded
        let customSeasonalityValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .customSeasonalityValue)
        customSeasonalityValue = customSeasonalityValueDecoded
    }
}

extension QuickSightClientTypes {
    /// The forecast computation configuration.
    public struct ForecastComputation: Swift.Equatable {
        /// The ID for a computation.
        /// This member is required.
        public var computationId: Swift.String?
        /// The custom seasonality value setup of a forecast computation.
        public var customSeasonalityValue: Swift.Int?
        /// The lower boundary setup of a forecast computation.
        public var lowerBoundary: Swift.Double?
        /// The name of a computation.
        public var name: Swift.String?
        /// The periods backward setup of a forecast computation.
        public var periodsBackward: Swift.Int?
        /// The periods forward setup of a forecast computation.
        public var periodsForward: Swift.Int?
        /// The prediction interval setup of a forecast computation.
        public var predictionInterval: Swift.Int?
        /// The seasonality setup of a forecast computation. Choose one of the following options:
        ///
        /// * AUTOMATIC
        ///
        /// * CUSTOM: Checks the custom seasonality value.
        public var seasonality: QuickSightClientTypes.ForecastComputationSeasonality?
        /// The time field that is used in a computation.
        /// This member is required.
        public var time: QuickSightClientTypes.DimensionField?
        /// The upper boundary setup of a forecast computation.
        public var upperBoundary: Swift.Double?
        /// The value field that is used in a computation.
        public var value: QuickSightClientTypes.MeasureField?

        public init (
            computationId: Swift.String? = nil,
            customSeasonalityValue: Swift.Int? = nil,
            lowerBoundary: Swift.Double? = nil,
            name: Swift.String? = nil,
            periodsBackward: Swift.Int? = nil,
            periodsForward: Swift.Int? = nil,
            predictionInterval: Swift.Int? = nil,
            seasonality: QuickSightClientTypes.ForecastComputationSeasonality? = nil,
            time: QuickSightClientTypes.DimensionField? = nil,
            upperBoundary: Swift.Double? = nil,
            value: QuickSightClientTypes.MeasureField? = nil
        )
        {
            self.computationId = computationId
            self.customSeasonalityValue = customSeasonalityValue
            self.lowerBoundary = lowerBoundary
            self.name = name
            self.periodsBackward = periodsBackward
            self.periodsForward = periodsForward
            self.predictionInterval = predictionInterval
            self.seasonality = seasonality
            self.time = time
            self.upperBoundary = upperBoundary
            self.value = value
        }
    }

}

extension QuickSightClientTypes {
    public enum ForecastComputationSeasonality: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automatic
        case custom
        case sdkUnknown(Swift.String)

        public static var allCases: [ForecastComputationSeasonality] {
            return [
                .automatic,
                .custom,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automatic: return "AUTOMATIC"
            case .custom: return "CUSTOM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ForecastComputationSeasonality(rawValue: rawValue) ?? ForecastComputationSeasonality.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.ForecastConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastProperties = "ForecastProperties"
        case scenario = "Scenario"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastProperties = self.forecastProperties {
            try encodeContainer.encode(forecastProperties, forKey: .forecastProperties)
        }
        if let scenario = self.scenario {
            try encodeContainer.encode(scenario, forKey: .scenario)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastPropertiesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TimeBasedForecastProperties.self, forKey: .forecastProperties)
        forecastProperties = forecastPropertiesDecoded
        let scenarioDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ForecastScenario.self, forKey: .scenario)
        scenario = scenarioDecoded
    }
}

extension QuickSightClientTypes {
    /// The forecast configuration that is used in a line chart's display properties.
    public struct ForecastConfiguration: Swift.Equatable {
        /// The forecast properties setup of a forecast in the line chart.
        public var forecastProperties: QuickSightClientTypes.TimeBasedForecastProperties?
        /// The forecast scenario of a forecast in the line chart.
        public var scenario: QuickSightClientTypes.ForecastScenario?

        public init (
            forecastProperties: QuickSightClientTypes.TimeBasedForecastProperties? = nil,
            scenario: QuickSightClientTypes.ForecastScenario? = nil
        )
        {
            self.forecastProperties = forecastProperties
            self.scenario = scenario
        }
    }

}

extension QuickSightClientTypes.ForecastScenario: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case whatIfPointScenario = "WhatIfPointScenario"
        case whatIfRangeScenario = "WhatIfRangeScenario"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let whatIfPointScenario = self.whatIfPointScenario {
            try encodeContainer.encode(whatIfPointScenario, forKey: .whatIfPointScenario)
        }
        if let whatIfRangeScenario = self.whatIfRangeScenario {
            try encodeContainer.encode(whatIfRangeScenario, forKey: .whatIfRangeScenario)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let whatIfPointScenarioDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.WhatIfPointScenario.self, forKey: .whatIfPointScenario)
        whatIfPointScenario = whatIfPointScenarioDecoded
        let whatIfRangeScenarioDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.WhatIfRangeScenario.self, forKey: .whatIfRangeScenario)
        whatIfRangeScenario = whatIfRangeScenarioDecoded
    }
}

extension QuickSightClientTypes {
    /// The forecast scenario of a forecast in the line chart.
    public struct ForecastScenario: Swift.Equatable {
        /// The what-if analysis forecast setup with the target date.
        public var whatIfPointScenario: QuickSightClientTypes.WhatIfPointScenario?
        /// The what-if analysis forecast setup with the date range.
        public var whatIfRangeScenario: QuickSightClientTypes.WhatIfRangeScenario?

        public init (
            whatIfPointScenario: QuickSightClientTypes.WhatIfPointScenario? = nil,
            whatIfRangeScenario: QuickSightClientTypes.WhatIfRangeScenario? = nil
        )
        {
            self.whatIfPointScenario = whatIfPointScenario
            self.whatIfRangeScenario = whatIfRangeScenario
        }
    }

}

extension QuickSightClientTypes.FormatConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateTimeFormatConfiguration = "DateTimeFormatConfiguration"
        case numberFormatConfiguration = "NumberFormatConfiguration"
        case stringFormatConfiguration = "StringFormatConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateTimeFormatConfiguration = self.dateTimeFormatConfiguration {
            try encodeContainer.encode(dateTimeFormatConfiguration, forKey: .dateTimeFormatConfiguration)
        }
        if let numberFormatConfiguration = self.numberFormatConfiguration {
            try encodeContainer.encode(numberFormatConfiguration, forKey: .numberFormatConfiguration)
        }
        if let stringFormatConfiguration = self.stringFormatConfiguration {
            try encodeContainer.encode(stringFormatConfiguration, forKey: .stringFormatConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stringFormatConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.StringFormatConfiguration.self, forKey: .stringFormatConfiguration)
        stringFormatConfiguration = stringFormatConfigurationDecoded
        let numberFormatConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumberFormatConfiguration.self, forKey: .numberFormatConfiguration)
        numberFormatConfiguration = numberFormatConfigurationDecoded
        let dateTimeFormatConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DateTimeFormatConfiguration.self, forKey: .dateTimeFormatConfiguration)
        dateTimeFormatConfiguration = dateTimeFormatConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The formatting configuration for all types of field.
    public struct FormatConfiguration: Swift.Equatable {
        /// Formatting configuration for DateTime fields.
        public var dateTimeFormatConfiguration: QuickSightClientTypes.DateTimeFormatConfiguration?
        /// Formatting configuration for number fields.
        public var numberFormatConfiguration: QuickSightClientTypes.NumberFormatConfiguration?
        /// Formatting configuration for string fields.
        public var stringFormatConfiguration: QuickSightClientTypes.StringFormatConfiguration?

        public init (
            dateTimeFormatConfiguration: QuickSightClientTypes.DateTimeFormatConfiguration? = nil,
            numberFormatConfiguration: QuickSightClientTypes.NumberFormatConfiguration? = nil,
            stringFormatConfiguration: QuickSightClientTypes.StringFormatConfiguration? = nil
        )
        {
            self.dateTimeFormatConfiguration = dateTimeFormatConfiguration
            self.numberFormatConfiguration = numberFormatConfiguration
            self.stringFormatConfiguration = stringFormatConfiguration
        }
    }

}

extension QuickSightClientTypes.FreeFormLayoutCanvasSizeOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case screenCanvasSizeOptions = "ScreenCanvasSizeOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let screenCanvasSizeOptions = self.screenCanvasSizeOptions {
            try encodeContainer.encode(screenCanvasSizeOptions, forKey: .screenCanvasSizeOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let screenCanvasSizeOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FreeFormLayoutScreenCanvasSizeOptions.self, forKey: .screenCanvasSizeOptions)
        screenCanvasSizeOptions = screenCanvasSizeOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// Configuration options for the canvas of a free-form layout.
    public struct FreeFormLayoutCanvasSizeOptions: Swift.Equatable {
        /// The options that determine the sizing of the canvas used in a free-form layout.
        public var screenCanvasSizeOptions: QuickSightClientTypes.FreeFormLayoutScreenCanvasSizeOptions?

        public init (
            screenCanvasSizeOptions: QuickSightClientTypes.FreeFormLayoutScreenCanvasSizeOptions? = nil
        )
        {
            self.screenCanvasSizeOptions = screenCanvasSizeOptions
        }
    }

}

extension QuickSightClientTypes.FreeFormLayoutConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canvasSizeOptions = "CanvasSizeOptions"
        case elements = "Elements"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let canvasSizeOptions = self.canvasSizeOptions {
            try encodeContainer.encode(canvasSizeOptions, forKey: .canvasSizeOptions)
        }
        if let elements = elements {
            var elementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .elements)
            for freeformlayoutelement0 in elements {
                try elementsContainer.encode(freeformlayoutelement0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elementsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FreeFormLayoutElement?].self, forKey: .elements)
        var elementsDecoded0:[QuickSightClientTypes.FreeFormLayoutElement]? = nil
        if let elementsContainer = elementsContainer {
            elementsDecoded0 = [QuickSightClientTypes.FreeFormLayoutElement]()
            for structure0 in elementsContainer {
                if let structure0 = structure0 {
                    elementsDecoded0?.append(structure0)
                }
            }
        }
        elements = elementsDecoded0
        let canvasSizeOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FreeFormLayoutCanvasSizeOptions.self, forKey: .canvasSizeOptions)
        canvasSizeOptions = canvasSizeOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of a free-form layout.
    public struct FreeFormLayoutConfiguration: Swift.Equatable {
        /// Configuration options for the canvas of a free-form layout.
        public var canvasSizeOptions: QuickSightClientTypes.FreeFormLayoutCanvasSizeOptions?
        /// The elements that are included in a free-form layout.
        /// This member is required.
        public var elements: [QuickSightClientTypes.FreeFormLayoutElement]?

        public init (
            canvasSizeOptions: QuickSightClientTypes.FreeFormLayoutCanvasSizeOptions? = nil,
            elements: [QuickSightClientTypes.FreeFormLayoutElement]? = nil
        )
        {
            self.canvasSizeOptions = canvasSizeOptions
            self.elements = elements
        }
    }

}

extension QuickSightClientTypes.FreeFormLayoutElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backgroundStyle = "BackgroundStyle"
        case borderStyle = "BorderStyle"
        case elementId = "ElementId"
        case elementType = "ElementType"
        case height = "Height"
        case loadingAnimation = "LoadingAnimation"
        case renderingRules = "RenderingRules"
        case selectedBorderStyle = "SelectedBorderStyle"
        case visibility = "Visibility"
        case width = "Width"
        case xAxisLocation = "XAxisLocation"
        case yAxisLocation = "YAxisLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backgroundStyle = self.backgroundStyle {
            try encodeContainer.encode(backgroundStyle, forKey: .backgroundStyle)
        }
        if let borderStyle = self.borderStyle {
            try encodeContainer.encode(borderStyle, forKey: .borderStyle)
        }
        if let elementId = self.elementId {
            try encodeContainer.encode(elementId, forKey: .elementId)
        }
        if let elementType = self.elementType {
            try encodeContainer.encode(elementType.rawValue, forKey: .elementType)
        }
        if let height = self.height {
            try encodeContainer.encode(height, forKey: .height)
        }
        if let loadingAnimation = self.loadingAnimation {
            try encodeContainer.encode(loadingAnimation, forKey: .loadingAnimation)
        }
        if let renderingRules = renderingRules {
            var renderingRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .renderingRules)
            for sheetelementrenderingrule0 in renderingRules {
                try renderingRulesContainer.encode(sheetelementrenderingrule0)
            }
        }
        if let selectedBorderStyle = self.selectedBorderStyle {
            try encodeContainer.encode(selectedBorderStyle, forKey: .selectedBorderStyle)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
        if let width = self.width {
            try encodeContainer.encode(width, forKey: .width)
        }
        if let xAxisLocation = self.xAxisLocation {
            try encodeContainer.encode(xAxisLocation, forKey: .xAxisLocation)
        }
        if let yAxisLocation = self.yAxisLocation {
            try encodeContainer.encode(yAxisLocation, forKey: .yAxisLocation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elementId)
        elementId = elementIdDecoded
        let elementTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LayoutElementType.self, forKey: .elementType)
        elementType = elementTypeDecoded
        let xAxisLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .xAxisLocation)
        xAxisLocation = xAxisLocationDecoded
        let yAxisLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .yAxisLocation)
        yAxisLocation = yAxisLocationDecoded
        let widthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .width)
        width = widthDecoded
        let heightDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .height)
        height = heightDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
        let renderingRulesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.SheetElementRenderingRule?].self, forKey: .renderingRules)
        var renderingRulesDecoded0:[QuickSightClientTypes.SheetElementRenderingRule]? = nil
        if let renderingRulesContainer = renderingRulesContainer {
            renderingRulesDecoded0 = [QuickSightClientTypes.SheetElementRenderingRule]()
            for structure0 in renderingRulesContainer {
                if let structure0 = structure0 {
                    renderingRulesDecoded0?.append(structure0)
                }
            }
        }
        renderingRules = renderingRulesDecoded0
        let borderStyleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FreeFormLayoutElementBorderStyle.self, forKey: .borderStyle)
        borderStyle = borderStyleDecoded
        let selectedBorderStyleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FreeFormLayoutElementBorderStyle.self, forKey: .selectedBorderStyle)
        selectedBorderStyle = selectedBorderStyleDecoded
        let backgroundStyleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FreeFormLayoutElementBackgroundStyle.self, forKey: .backgroundStyle)
        backgroundStyle = backgroundStyleDecoded
        let loadingAnimationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LoadingAnimation.self, forKey: .loadingAnimation)
        loadingAnimation = loadingAnimationDecoded
    }
}

extension QuickSightClientTypes {
    /// An element within a free-form layout.
    public struct FreeFormLayoutElement: Swift.Equatable {
        /// The background style configuration of a free-form layout element.
        public var backgroundStyle: QuickSightClientTypes.FreeFormLayoutElementBackgroundStyle?
        /// The border style configuration of a free-form layout element.
        public var borderStyle: QuickSightClientTypes.FreeFormLayoutElementBorderStyle?
        /// A unique identifier for an element within a free-form layout.
        /// This member is required.
        public var elementId: Swift.String?
        /// The type of element.
        /// This member is required.
        public var elementType: QuickSightClientTypes.LayoutElementType?
        /// The height of an element within a free-form layout.
        /// This member is required.
        public var height: Swift.String?
        /// The loading animation configuration of a free-form layout element.
        public var loadingAnimation: QuickSightClientTypes.LoadingAnimation?
        /// The rendering rules that determine when an element should be displayed within a free-form layout.
        public var renderingRules: [QuickSightClientTypes.SheetElementRenderingRule]?
        /// The border style configuration of a free-form layout element. This border style is used when the element is selected.
        public var selectedBorderStyle: QuickSightClientTypes.FreeFormLayoutElementBorderStyle?
        /// The visibility of an element within a free-form layout.
        public var visibility: QuickSightClientTypes.Visibility?
        /// The width of an element within a free-form layout.
        /// This member is required.
        public var width: Swift.String?
        /// The x-axis coordinate of the element.
        /// This member is required.
        public var xAxisLocation: Swift.String?
        /// The y-axis coordinate of the element.
        /// This member is required.
        public var yAxisLocation: Swift.String?

        public init (
            backgroundStyle: QuickSightClientTypes.FreeFormLayoutElementBackgroundStyle? = nil,
            borderStyle: QuickSightClientTypes.FreeFormLayoutElementBorderStyle? = nil,
            elementId: Swift.String? = nil,
            elementType: QuickSightClientTypes.LayoutElementType? = nil,
            height: Swift.String? = nil,
            loadingAnimation: QuickSightClientTypes.LoadingAnimation? = nil,
            renderingRules: [QuickSightClientTypes.SheetElementRenderingRule]? = nil,
            selectedBorderStyle: QuickSightClientTypes.FreeFormLayoutElementBorderStyle? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil,
            width: Swift.String? = nil,
            xAxisLocation: Swift.String? = nil,
            yAxisLocation: Swift.String? = nil
        )
        {
            self.backgroundStyle = backgroundStyle
            self.borderStyle = borderStyle
            self.elementId = elementId
            self.elementType = elementType
            self.height = height
            self.loadingAnimation = loadingAnimation
            self.renderingRules = renderingRules
            self.selectedBorderStyle = selectedBorderStyle
            self.visibility = visibility
            self.width = width
            self.xAxisLocation = xAxisLocation
            self.yAxisLocation = yAxisLocation
        }
    }

}

extension QuickSightClientTypes.FreeFormLayoutElementBackgroundStyle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case color = "Color"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let color = self.color {
            try encodeContainer.encode(color, forKey: .color)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
        let colorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .color)
        color = colorDecoded
    }
}

extension QuickSightClientTypes {
    /// The background style configuration of a free-form layout element.
    public struct FreeFormLayoutElementBackgroundStyle: Swift.Equatable {
        /// The background color of a free-form layout element.
        public var color: Swift.String?
        /// The background visibility of a free-form layout element.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            color: Swift.String? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.color = color
            self.visibility = visibility
        }
    }

}

extension QuickSightClientTypes.FreeFormLayoutElementBorderStyle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case color = "Color"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let color = self.color {
            try encodeContainer.encode(color, forKey: .color)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
        let colorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .color)
        color = colorDecoded
    }
}

extension QuickSightClientTypes {
    /// The background style configuration of a free-form layout element.
    public struct FreeFormLayoutElementBorderStyle: Swift.Equatable {
        /// The border color of a free-form layout element.
        public var color: Swift.String?
        /// The border visibility of a free-form layout element.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            color: Swift.String? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.color = color
            self.visibility = visibility
        }
    }

}

extension QuickSightClientTypes.FreeFormLayoutScreenCanvasSizeOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optimizedViewPortWidth = "OptimizedViewPortWidth"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let optimizedViewPortWidth = self.optimizedViewPortWidth {
            try encodeContainer.encode(optimizedViewPortWidth, forKey: .optimizedViewPortWidth)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optimizedViewPortWidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optimizedViewPortWidth)
        optimizedViewPortWidth = optimizedViewPortWidthDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the sizing of the canvas used in a free-form layout.
    public struct FreeFormLayoutScreenCanvasSizeOptions: Swift.Equatable {
        /// The width that the view port will be optimized for when the layout renders.
        /// This member is required.
        public var optimizedViewPortWidth: Swift.String?

        public init (
            optimizedViewPortWidth: Swift.String? = nil
        )
        {
            self.optimizedViewPortWidth = optimizedViewPortWidth
        }
    }

}

extension QuickSightClientTypes.FreeFormSectionLayoutConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elements = "Elements"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elements = elements {
            var elementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .elements)
            for freeformlayoutelement0 in elements {
                try elementsContainer.encode(freeformlayoutelement0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elementsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FreeFormLayoutElement?].self, forKey: .elements)
        var elementsDecoded0:[QuickSightClientTypes.FreeFormLayoutElement]? = nil
        if let elementsContainer = elementsContainer {
            elementsDecoded0 = [QuickSightClientTypes.FreeFormLayoutElement]()
            for structure0 in elementsContainer {
                if let structure0 = structure0 {
                    elementsDecoded0?.append(structure0)
                }
            }
        }
        elements = elementsDecoded0
    }
}

extension QuickSightClientTypes {
    /// The free-form layout configuration of a section.
    public struct FreeFormSectionLayoutConfiguration: Swift.Equatable {
        /// The elements that are included in the free-form layout.
        /// This member is required.
        public var elements: [QuickSightClientTypes.FreeFormLayoutElement]?

        public init (
            elements: [QuickSightClientTypes.FreeFormLayoutElement]? = nil
        )
        {
            self.elements = elements
        }
    }

}

extension QuickSightClientTypes.FunnelChartAggregatedFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category = "Category"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            var categoryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .category)
            for dimensionfield0 in category {
                try categoryContainer.encode(dimensionfield0)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for measurefield0 in values {
                try valuesContainer.encode(measurefield0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .category)
        var categoryDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let categoryContainer = categoryContainer {
            categoryDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in categoryContainer {
                if let structure0 = structure0 {
                    categoryDecoded0?.append(structure0)
                }
            }
        }
        category = categoryDecoded0
        let valuesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .values)
        var valuesDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension QuickSightClientTypes {
    /// The field well configuration of a FunnelChartVisual.
    public struct FunnelChartAggregatedFieldWells: Swift.Equatable {
        /// The category field wells of a funnel chart. Values are grouped by category fields.
        public var category: [QuickSightClientTypes.DimensionField]?
        /// The value field wells of a funnel chart. Values are aggregated based on categories.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init (
            category: [QuickSightClientTypes.DimensionField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.category = category
            self.values = values
        }
    }

}

extension QuickSightClientTypes.FunnelChartConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryLabelOptions = "CategoryLabelOptions"
        case dataLabelOptions = "DataLabelOptions"
        case fieldWells = "FieldWells"
        case sortConfiguration = "SortConfiguration"
        case tooltip = "Tooltip"
        case valueLabelOptions = "ValueLabelOptions"
        case visualPalette = "VisualPalette"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryLabelOptions = self.categoryLabelOptions {
            try encodeContainer.encode(categoryLabelOptions, forKey: .categoryLabelOptions)
        }
        if let dataLabelOptions = self.dataLabelOptions {
            try encodeContainer.encode(dataLabelOptions, forKey: .dataLabelOptions)
        }
        if let fieldWells = self.fieldWells {
            try encodeContainer.encode(fieldWells, forKey: .fieldWells)
        }
        if let sortConfiguration = self.sortConfiguration {
            try encodeContainer.encode(sortConfiguration, forKey: .sortConfiguration)
        }
        if let tooltip = self.tooltip {
            try encodeContainer.encode(tooltip, forKey: .tooltip)
        }
        if let valueLabelOptions = self.valueLabelOptions {
            try encodeContainer.encode(valueLabelOptions, forKey: .valueLabelOptions)
        }
        if let visualPalette = self.visualPalette {
            try encodeContainer.encode(visualPalette, forKey: .visualPalette)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FunnelChartFieldWells.self, forKey: .fieldWells)
        fieldWells = fieldWellsDecoded
        let sortConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FunnelChartSortConfiguration.self, forKey: .sortConfiguration)
        sortConfiguration = sortConfigurationDecoded
        let categoryLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .categoryLabelOptions)
        categoryLabelOptions = categoryLabelOptionsDecoded
        let valueLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .valueLabelOptions)
        valueLabelOptions = valueLabelOptionsDecoded
        let tooltipDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TooltipOptions.self, forKey: .tooltip)
        tooltip = tooltipDecoded
        let dataLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FunnelChartDataLabelOptions.self, forKey: .dataLabelOptions)
        dataLabelOptions = dataLabelOptionsDecoded
        let visualPaletteDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualPalette.self, forKey: .visualPalette)
        visualPalette = visualPaletteDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of a FunnelChartVisual.
    public struct FunnelChartConfiguration: Swift.Equatable {
        /// The label options of the categories that are displayed in a FunnelChartVisual.
        public var categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The options that determine the presentation of the data labels.
        public var dataLabelOptions: QuickSightClientTypes.FunnelChartDataLabelOptions?
        /// The field well configuration of a FunnelChartVisual.
        public var fieldWells: QuickSightClientTypes.FunnelChartFieldWells?
        /// The sort configuration of a FunnelChartVisual.
        public var sortConfiguration: QuickSightClientTypes.FunnelChartSortConfiguration?
        /// The tooltip configuration of a FunnelChartVisual.
        public var tooltip: QuickSightClientTypes.TooltipOptions?
        /// The label options for the values that are displayed in a FunnelChartVisual.
        public var valueLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The visual palette configuration of a FunnelChartVisual.
        public var visualPalette: QuickSightClientTypes.VisualPalette?

        public init (
            categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            dataLabelOptions: QuickSightClientTypes.FunnelChartDataLabelOptions? = nil,
            fieldWells: QuickSightClientTypes.FunnelChartFieldWells? = nil,
            sortConfiguration: QuickSightClientTypes.FunnelChartSortConfiguration? = nil,
            tooltip: QuickSightClientTypes.TooltipOptions? = nil,
            valueLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            visualPalette: QuickSightClientTypes.VisualPalette? = nil
        )
        {
            self.categoryLabelOptions = categoryLabelOptions
            self.dataLabelOptions = dataLabelOptions
            self.fieldWells = fieldWells
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.valueLabelOptions = valueLabelOptions
            self.visualPalette = visualPalette
        }
    }

}

extension QuickSightClientTypes.FunnelChartDataLabelOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryLabelVisibility = "CategoryLabelVisibility"
        case labelColor = "LabelColor"
        case labelFontConfiguration = "LabelFontConfiguration"
        case measureDataLabelStyle = "MeasureDataLabelStyle"
        case measureLabelVisibility = "MeasureLabelVisibility"
        case position = "Position"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryLabelVisibility = self.categoryLabelVisibility {
            try encodeContainer.encode(categoryLabelVisibility.rawValue, forKey: .categoryLabelVisibility)
        }
        if let labelColor = self.labelColor {
            try encodeContainer.encode(labelColor, forKey: .labelColor)
        }
        if let labelFontConfiguration = self.labelFontConfiguration {
            try encodeContainer.encode(labelFontConfiguration, forKey: .labelFontConfiguration)
        }
        if let measureDataLabelStyle = self.measureDataLabelStyle {
            try encodeContainer.encode(measureDataLabelStyle.rawValue, forKey: .measureDataLabelStyle)
        }
        if let measureLabelVisibility = self.measureLabelVisibility {
            try encodeContainer.encode(measureLabelVisibility.rawValue, forKey: .measureLabelVisibility)
        }
        if let position = self.position {
            try encodeContainer.encode(position.rawValue, forKey: .position)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
        let categoryLabelVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .categoryLabelVisibility)
        categoryLabelVisibility = categoryLabelVisibilityDecoded
        let measureLabelVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .measureLabelVisibility)
        measureLabelVisibility = measureLabelVisibilityDecoded
        let positionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataLabelPosition.self, forKey: .position)
        position = positionDecoded
        let labelFontConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FontConfiguration.self, forKey: .labelFontConfiguration)
        labelFontConfiguration = labelFontConfigurationDecoded
        let labelColorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .labelColor)
        labelColor = labelColorDecoded
        let measureDataLabelStyleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FunnelChartMeasureDataLabelStyle.self, forKey: .measureDataLabelStyle)
        measureDataLabelStyle = measureDataLabelStyleDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the presentation of the data labels.
    public struct FunnelChartDataLabelOptions: Swift.Equatable {
        /// The visibility of the category labels within the data labels.
        public var categoryLabelVisibility: QuickSightClientTypes.Visibility?
        /// The color of the data label text.
        public var labelColor: Swift.String?
        /// The font configuration for the data labels. Only the FontSize attribute of the font configuration is used for data labels.
        public var labelFontConfiguration: QuickSightClientTypes.FontConfiguration?
        /// Determines the style of the metric labels.
        public var measureDataLabelStyle: QuickSightClientTypes.FunnelChartMeasureDataLabelStyle?
        /// The visibility of the measure labels within the data labels.
        public var measureLabelVisibility: QuickSightClientTypes.Visibility?
        /// Determines the positioning of the data label relative to a section of the funnel.
        public var position: QuickSightClientTypes.DataLabelPosition?
        /// The visibility option that determines if data labels are displayed.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            categoryLabelVisibility: QuickSightClientTypes.Visibility? = nil,
            labelColor: Swift.String? = nil,
            labelFontConfiguration: QuickSightClientTypes.FontConfiguration? = nil,
            measureDataLabelStyle: QuickSightClientTypes.FunnelChartMeasureDataLabelStyle? = nil,
            measureLabelVisibility: QuickSightClientTypes.Visibility? = nil,
            position: QuickSightClientTypes.DataLabelPosition? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.categoryLabelVisibility = categoryLabelVisibility
            self.labelColor = labelColor
            self.labelFontConfiguration = labelFontConfiguration
            self.measureDataLabelStyle = measureDataLabelStyle
            self.measureLabelVisibility = measureLabelVisibility
            self.position = position
            self.visibility = visibility
        }
    }

}

extension QuickSightClientTypes.FunnelChartFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case funnelChartAggregatedFieldWells = "FunnelChartAggregatedFieldWells"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let funnelChartAggregatedFieldWells = self.funnelChartAggregatedFieldWells {
            try encodeContainer.encode(funnelChartAggregatedFieldWells, forKey: .funnelChartAggregatedFieldWells)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let funnelChartAggregatedFieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FunnelChartAggregatedFieldWells.self, forKey: .funnelChartAggregatedFieldWells)
        funnelChartAggregatedFieldWells = funnelChartAggregatedFieldWellsDecoded
    }
}

extension QuickSightClientTypes {
    /// The field well configuration of a FunnelChartVisual. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct FunnelChartFieldWells: Swift.Equatable {
        /// The field well configuration of a FunnelChartVisual.
        public var funnelChartAggregatedFieldWells: QuickSightClientTypes.FunnelChartAggregatedFieldWells?

        public init (
            funnelChartAggregatedFieldWells: QuickSightClientTypes.FunnelChartAggregatedFieldWells? = nil
        )
        {
            self.funnelChartAggregatedFieldWells = funnelChartAggregatedFieldWells
        }
    }

}

extension QuickSightClientTypes {
    public enum FunnelChartMeasureDataLabelStyle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case percentageByFirstStage
        case percentageByPreviousStage
        case valueAndPercentageByFirstStage
        case valueAndPercentageByPreviousStage
        case valueOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [FunnelChartMeasureDataLabelStyle] {
            return [
                .percentageByFirstStage,
                .percentageByPreviousStage,
                .valueAndPercentageByFirstStage,
                .valueAndPercentageByPreviousStage,
                .valueOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .percentageByFirstStage: return "PERCENTAGE_BY_FIRST_STAGE"
            case .percentageByPreviousStage: return "PERCENTAGE_BY_PREVIOUS_STAGE"
            case .valueAndPercentageByFirstStage: return "VALUE_AND_PERCENTAGE_BY_FIRST_STAGE"
            case .valueAndPercentageByPreviousStage: return "VALUE_AND_PERCENTAGE_BY_PREVIOUS_STAGE"
            case .valueOnly: return "VALUE_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FunnelChartMeasureDataLabelStyle(rawValue: rawValue) ?? FunnelChartMeasureDataLabelStyle.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.FunnelChartSortConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryItemsLimit = "CategoryItemsLimit"
        case categorySort = "CategorySort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryItemsLimit = self.categoryItemsLimit {
            try encodeContainer.encode(categoryItemsLimit, forKey: .categoryItemsLimit)
        }
        if let categorySort = categorySort {
            var categorySortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categorySort)
            for fieldsortoptions0 in categorySort {
                try categorySortContainer.encode(fieldsortoptions0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categorySortContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FieldSortOptions?].self, forKey: .categorySort)
        var categorySortDecoded0:[QuickSightClientTypes.FieldSortOptions]? = nil
        if let categorySortContainer = categorySortContainer {
            categorySortDecoded0 = [QuickSightClientTypes.FieldSortOptions]()
            for structure0 in categorySortContainer {
                if let structure0 = structure0 {
                    categorySortDecoded0?.append(structure0)
                }
            }
        }
        categorySort = categorySortDecoded0
        let categoryItemsLimitDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ItemsLimitConfiguration.self, forKey: .categoryItemsLimit)
        categoryItemsLimit = categoryItemsLimitDecoded
    }
}

extension QuickSightClientTypes {
    /// The sort configuration of a FunnelChartVisual.
    public struct FunnelChartSortConfiguration: Swift.Equatable {
        /// The limit on the number of categories displayed.
        public var categoryItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of the category fields.
        public var categorySort: [QuickSightClientTypes.FieldSortOptions]?

        public init (
            categoryItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            categorySort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.categoryItemsLimit = categoryItemsLimit
            self.categorySort = categorySort
        }
    }

}

extension QuickSightClientTypes.FunnelChartVisual: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case chartConfiguration = "ChartConfiguration"
        case columnHierarchies = "ColumnHierarchies"
        case subtitle = "Subtitle"
        case title = "Title"
        case visualId = "VisualId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for visualcustomaction0 in actions {
                try actionsContainer.encode(visualcustomaction0)
            }
        }
        if let chartConfiguration = self.chartConfiguration {
            try encodeContainer.encode(chartConfiguration, forKey: .chartConfiguration)
        }
        if let columnHierarchies = columnHierarchies {
            var columnHierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnHierarchies)
            for columnhierarchy0 in columnHierarchies {
                try columnHierarchiesContainer.encode(columnhierarchy0)
            }
        }
        if let subtitle = self.subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let visualId = self.visualId {
            try encodeContainer.encode(visualId, forKey: .visualId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visualIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visualId)
        visualId = visualIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualTitleLabelOptions.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualSubtitleLabelOptions.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let chartConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FunnelChartConfiguration.self, forKey: .chartConfiguration)
        chartConfiguration = chartConfigurationDecoded
        let actionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.VisualCustomAction?].self, forKey: .actions)
        var actionsDecoded0:[QuickSightClientTypes.VisualCustomAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [QuickSightClientTypes.VisualCustomAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let columnHierarchiesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnHierarchy?].self, forKey: .columnHierarchies)
        var columnHierarchiesDecoded0:[QuickSightClientTypes.ColumnHierarchy]? = nil
        if let columnHierarchiesContainer = columnHierarchiesContainer {
            columnHierarchiesDecoded0 = [QuickSightClientTypes.ColumnHierarchy]()
            for structure0 in columnHierarchiesContainer {
                if let structure0 = structure0 {
                    columnHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        columnHierarchies = columnHierarchiesDecoded0
    }
}

extension QuickSightClientTypes {
    /// A funnel chart. For more information, see [Using funnel charts](https://docs.aws.amazon.com/quicksight/latest/user/funnel-visual-content.html) in the Amazon QuickSight User Guide.
    public struct FunnelChartVisual: Swift.Equatable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration of a FunnelChartVisual.
        public var chartConfiguration: QuickSightClientTypes.FunnelChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        /// This member is required.
        public var visualId: Swift.String?

        public init (
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.FunnelChartConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }

}

extension QuickSightClientTypes.GaugeChartArcConditionalFormatting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case foregroundColor = "ForegroundColor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let foregroundColor = self.foregroundColor {
            try encodeContainer.encode(foregroundColor, forKey: .foregroundColor)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let foregroundColorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ConditionalFormattingColor.self, forKey: .foregroundColor)
        foregroundColor = foregroundColorDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the presentation of the arc of a GaugeChartVisual.
    public struct GaugeChartArcConditionalFormatting: Swift.Equatable {
        /// The conditional formatting of the arc foreground color.
        public var foregroundColor: QuickSightClientTypes.ConditionalFormattingColor?

        public init (
            foregroundColor: QuickSightClientTypes.ConditionalFormattingColor? = nil
        )
        {
            self.foregroundColor = foregroundColor
        }
    }

}

extension QuickSightClientTypes.GaugeChartConditionalFormatting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conditionalFormattingOptions = "ConditionalFormattingOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conditionalFormattingOptions = conditionalFormattingOptions {
            var conditionalFormattingOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conditionalFormattingOptions)
            for gaugechartconditionalformattingoption0 in conditionalFormattingOptions {
                try conditionalFormattingOptionsContainer.encode(gaugechartconditionalformattingoption0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionalFormattingOptionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.GaugeChartConditionalFormattingOption?].self, forKey: .conditionalFormattingOptions)
        var conditionalFormattingOptionsDecoded0:[QuickSightClientTypes.GaugeChartConditionalFormattingOption]? = nil
        if let conditionalFormattingOptionsContainer = conditionalFormattingOptionsContainer {
            conditionalFormattingOptionsDecoded0 = [QuickSightClientTypes.GaugeChartConditionalFormattingOption]()
            for structure0 in conditionalFormattingOptionsContainer {
                if let structure0 = structure0 {
                    conditionalFormattingOptionsDecoded0?.append(structure0)
                }
            }
        }
        conditionalFormattingOptions = conditionalFormattingOptionsDecoded0
    }
}

extension QuickSightClientTypes {
    /// The conditional formatting of a GaugeChartVisual.
    public struct GaugeChartConditionalFormatting: Swift.Equatable {
        /// Conditional formatting options of a GaugeChartVisual.
        public var conditionalFormattingOptions: [QuickSightClientTypes.GaugeChartConditionalFormattingOption]?

        public init (
            conditionalFormattingOptions: [QuickSightClientTypes.GaugeChartConditionalFormattingOption]? = nil
        )
        {
            self.conditionalFormattingOptions = conditionalFormattingOptions
        }
    }

}

extension QuickSightClientTypes.GaugeChartConditionalFormattingOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arc = "Arc"
        case primaryValue = "PrimaryValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arc = self.arc {
            try encodeContainer.encode(arc, forKey: .arc)
        }
        if let primaryValue = self.primaryValue {
            try encodeContainer.encode(primaryValue, forKey: .primaryValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryValueDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GaugeChartPrimaryValueConditionalFormatting.self, forKey: .primaryValue)
        primaryValue = primaryValueDecoded
        let arcDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GaugeChartArcConditionalFormatting.self, forKey: .arc)
        arc = arcDecoded
    }
}

extension QuickSightClientTypes {
    /// Conditional formatting options of a GaugeChartVisual.
    public struct GaugeChartConditionalFormattingOption: Swift.Equatable {
        /// The options that determine the presentation of the arc of a GaugeChartVisual.
        public var arc: QuickSightClientTypes.GaugeChartArcConditionalFormatting?
        /// The conditional formatting for the primary value of a GaugeChartVisual.
        public var primaryValue: QuickSightClientTypes.GaugeChartPrimaryValueConditionalFormatting?

        public init (
            arc: QuickSightClientTypes.GaugeChartArcConditionalFormatting? = nil,
            primaryValue: QuickSightClientTypes.GaugeChartPrimaryValueConditionalFormatting? = nil
        )
        {
            self.arc = arc
            self.primaryValue = primaryValue
        }
    }

}

extension QuickSightClientTypes.GaugeChartConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataLabels = "DataLabels"
        case fieldWells = "FieldWells"
        case gaugeChartOptions = "GaugeChartOptions"
        case tooltipOptions = "TooltipOptions"
        case visualPalette = "VisualPalette"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataLabels = self.dataLabels {
            try encodeContainer.encode(dataLabels, forKey: .dataLabels)
        }
        if let fieldWells = self.fieldWells {
            try encodeContainer.encode(fieldWells, forKey: .fieldWells)
        }
        if let gaugeChartOptions = self.gaugeChartOptions {
            try encodeContainer.encode(gaugeChartOptions, forKey: .gaugeChartOptions)
        }
        if let tooltipOptions = self.tooltipOptions {
            try encodeContainer.encode(tooltipOptions, forKey: .tooltipOptions)
        }
        if let visualPalette = self.visualPalette {
            try encodeContainer.encode(visualPalette, forKey: .visualPalette)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GaugeChartFieldWells.self, forKey: .fieldWells)
        fieldWells = fieldWellsDecoded
        let gaugeChartOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GaugeChartOptions.self, forKey: .gaugeChartOptions)
        gaugeChartOptions = gaugeChartOptionsDecoded
        let dataLabelsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataLabelOptions.self, forKey: .dataLabels)
        dataLabels = dataLabelsDecoded
        let tooltipOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TooltipOptions.self, forKey: .tooltipOptions)
        tooltipOptions = tooltipOptionsDecoded
        let visualPaletteDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualPalette.self, forKey: .visualPalette)
        visualPalette = visualPaletteDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of a GaugeChartVisual.
    public struct GaugeChartConfiguration: Swift.Equatable {
        /// The data label configuration of a GaugeChartVisual.
        public var dataLabels: QuickSightClientTypes.DataLabelOptions?
        /// The field well configuration of a GaugeChartVisual.
        public var fieldWells: QuickSightClientTypes.GaugeChartFieldWells?
        /// The options that determine the presentation of the GaugeChartVisual.
        public var gaugeChartOptions: QuickSightClientTypes.GaugeChartOptions?
        /// The tooltip configuration of a GaugeChartVisual.
        public var tooltipOptions: QuickSightClientTypes.TooltipOptions?
        /// The visual palette configuration of a GaugeChartVisual.
        public var visualPalette: QuickSightClientTypes.VisualPalette?

        public init (
            dataLabels: QuickSightClientTypes.DataLabelOptions? = nil,
            fieldWells: QuickSightClientTypes.GaugeChartFieldWells? = nil,
            gaugeChartOptions: QuickSightClientTypes.GaugeChartOptions? = nil,
            tooltipOptions: QuickSightClientTypes.TooltipOptions? = nil,
            visualPalette: QuickSightClientTypes.VisualPalette? = nil
        )
        {
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.gaugeChartOptions = gaugeChartOptions
            self.tooltipOptions = tooltipOptions
            self.visualPalette = visualPalette
        }
    }

}

extension QuickSightClientTypes.GaugeChartFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetValues = "TargetValues"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetValues = targetValues {
            var targetValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetValues)
            for measurefield0 in targetValues {
                try targetValuesContainer.encode(measurefield0)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for measurefield0 in values {
                try valuesContainer.encode(measurefield0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .values)
        var valuesDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
        let targetValuesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .targetValues)
        var targetValuesDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let targetValuesContainer = targetValuesContainer {
            targetValuesDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in targetValuesContainer {
                if let structure0 = structure0 {
                    targetValuesDecoded0?.append(structure0)
                }
            }
        }
        targetValues = targetValuesDecoded0
    }
}

extension QuickSightClientTypes {
    /// The field well configuration of a GaugeChartVisual.
    public struct GaugeChartFieldWells: Swift.Equatable {
        /// The target value field wells of a GaugeChartVisual.
        public var targetValues: [QuickSightClientTypes.MeasureField]?
        /// The value field wells of a GaugeChartVisual.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init (
            targetValues: [QuickSightClientTypes.MeasureField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.targetValues = targetValues
            self.values = values
        }
    }

}

extension QuickSightClientTypes.GaugeChartOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arc = "Arc"
        case arcAxis = "ArcAxis"
        case comparison = "Comparison"
        case primaryValueDisplayType = "PrimaryValueDisplayType"
        case primaryValueFontConfiguration = "PrimaryValueFontConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arc = self.arc {
            try encodeContainer.encode(arc, forKey: .arc)
        }
        if let arcAxis = self.arcAxis {
            try encodeContainer.encode(arcAxis, forKey: .arcAxis)
        }
        if let comparison = self.comparison {
            try encodeContainer.encode(comparison, forKey: .comparison)
        }
        if let primaryValueDisplayType = self.primaryValueDisplayType {
            try encodeContainer.encode(primaryValueDisplayType.rawValue, forKey: .primaryValueDisplayType)
        }
        if let primaryValueFontConfiguration = self.primaryValueFontConfiguration {
            try encodeContainer.encode(primaryValueFontConfiguration, forKey: .primaryValueFontConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryValueDisplayTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PrimaryValueDisplayType.self, forKey: .primaryValueDisplayType)
        primaryValueDisplayType = primaryValueDisplayTypeDecoded
        let comparisonDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ComparisonConfiguration.self, forKey: .comparison)
        comparison = comparisonDecoded
        let arcAxisDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ArcAxisConfiguration.self, forKey: .arcAxis)
        arcAxis = arcAxisDecoded
        let arcDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ArcConfiguration.self, forKey: .arc)
        arc = arcDecoded
        let primaryValueFontConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FontConfiguration.self, forKey: .primaryValueFontConfiguration)
        primaryValueFontConfiguration = primaryValueFontConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the presentation of the GaugeChartVisual.
    public struct GaugeChartOptions: Swift.Equatable {
        /// The arc configuration of a GaugeChartVisual.
        public var arc: QuickSightClientTypes.ArcConfiguration?
        /// The arc axis configuration of a GaugeChartVisual.
        public var arcAxis: QuickSightClientTypes.ArcAxisConfiguration?
        /// The comparison configuration of a GaugeChartVisual.
        public var comparison: QuickSightClientTypes.ComparisonConfiguration?
        /// The options that determine the primary value display type.
        public var primaryValueDisplayType: QuickSightClientTypes.PrimaryValueDisplayType?
        /// The options that determine the primary value font configuration.
        public var primaryValueFontConfiguration: QuickSightClientTypes.FontConfiguration?

        public init (
            arc: QuickSightClientTypes.ArcConfiguration? = nil,
            arcAxis: QuickSightClientTypes.ArcAxisConfiguration? = nil,
            comparison: QuickSightClientTypes.ComparisonConfiguration? = nil,
            primaryValueDisplayType: QuickSightClientTypes.PrimaryValueDisplayType? = nil,
            primaryValueFontConfiguration: QuickSightClientTypes.FontConfiguration? = nil
        )
        {
            self.arc = arc
            self.arcAxis = arcAxis
            self.comparison = comparison
            self.primaryValueDisplayType = primaryValueDisplayType
            self.primaryValueFontConfiguration = primaryValueFontConfiguration
        }
    }

}

extension QuickSightClientTypes.GaugeChartPrimaryValueConditionalFormatting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case icon = "Icon"
        case textColor = "TextColor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let icon = self.icon {
            try encodeContainer.encode(icon, forKey: .icon)
        }
        if let textColor = self.textColor {
            try encodeContainer.encode(textColor, forKey: .textColor)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textColorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ConditionalFormattingColor.self, forKey: .textColor)
        textColor = textColorDecoded
        let iconDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ConditionalFormattingIcon.self, forKey: .icon)
        icon = iconDecoded
    }
}

extension QuickSightClientTypes {
    /// The conditional formatting for the primary value of a GaugeChartVisual.
    public struct GaugeChartPrimaryValueConditionalFormatting: Swift.Equatable {
        /// The conditional formatting of the primary value icon.
        public var icon: QuickSightClientTypes.ConditionalFormattingIcon?
        /// The conditional formatting of the primary value text color.
        public var textColor: QuickSightClientTypes.ConditionalFormattingColor?

        public init (
            icon: QuickSightClientTypes.ConditionalFormattingIcon? = nil,
            textColor: QuickSightClientTypes.ConditionalFormattingColor? = nil
        )
        {
            self.icon = icon
            self.textColor = textColor
        }
    }

}

extension QuickSightClientTypes.GaugeChartVisual: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case chartConfiguration = "ChartConfiguration"
        case conditionalFormatting = "ConditionalFormatting"
        case subtitle = "Subtitle"
        case title = "Title"
        case visualId = "VisualId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for visualcustomaction0 in actions {
                try actionsContainer.encode(visualcustomaction0)
            }
        }
        if let chartConfiguration = self.chartConfiguration {
            try encodeContainer.encode(chartConfiguration, forKey: .chartConfiguration)
        }
        if let conditionalFormatting = self.conditionalFormatting {
            try encodeContainer.encode(conditionalFormatting, forKey: .conditionalFormatting)
        }
        if let subtitle = self.subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let visualId = self.visualId {
            try encodeContainer.encode(visualId, forKey: .visualId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visualIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visualId)
        visualId = visualIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualTitleLabelOptions.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualSubtitleLabelOptions.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let chartConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GaugeChartConfiguration.self, forKey: .chartConfiguration)
        chartConfiguration = chartConfigurationDecoded
        let conditionalFormattingDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GaugeChartConditionalFormatting.self, forKey: .conditionalFormatting)
        conditionalFormatting = conditionalFormattingDecoded
        let actionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.VisualCustomAction?].self, forKey: .actions)
        var actionsDecoded0:[QuickSightClientTypes.VisualCustomAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [QuickSightClientTypes.VisualCustomAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A gauge chart. For more information, see [Using gauge charts](https://docs.aws.amazon.com/quicksight/latest/user/gauge-chart.html) in the Amazon QuickSight User Guide.
    public struct GaugeChartVisual: Swift.Equatable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration of a GaugeChartVisual.
        public var chartConfiguration: QuickSightClientTypes.GaugeChartConfiguration?
        /// The conditional formatting of a GaugeChartVisual.
        public var conditionalFormatting: QuickSightClientTypes.GaugeChartConditionalFormatting?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init (
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.GaugeChartConfiguration? = nil,
            conditionalFormatting: QuickSightClientTypes.GaugeChartConditionalFormatting? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.conditionalFormatting = conditionalFormatting
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }

}

extension GenerateEmbedUrlForAnonymousUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedDomains = "AllowedDomains"
        case authorizedResourceArns = "AuthorizedResourceArns"
        case experienceConfiguration = "ExperienceConfiguration"
        case namespace = "Namespace"
        case sessionLifetimeInMinutes = "SessionLifetimeInMinutes"
        case sessionTags = "SessionTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedDomains = allowedDomains {
            var allowedDomainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedDomains)
            for string0 in allowedDomains {
                try allowedDomainsContainer.encode(string0)
            }
        }
        if let authorizedResourceArns = authorizedResourceArns {
            var authorizedResourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizedResourceArns)
            for arn0 in authorizedResourceArns {
                try authorizedResourceArnsContainer.encode(arn0)
            }
        }
        if let experienceConfiguration = self.experienceConfiguration {
            try encodeContainer.encode(experienceConfiguration, forKey: .experienceConfiguration)
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let sessionLifetimeInMinutes = self.sessionLifetimeInMinutes {
            try encodeContainer.encode(sessionLifetimeInMinutes, forKey: .sessionLifetimeInMinutes)
        }
        if let sessionTags = sessionTags {
            var sessionTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sessionTags)
            for sessiontag0 in sessionTags {
                try sessionTagsContainer.encode(sessiontag0)
            }
        }
    }
}

extension GenerateEmbedUrlForAnonymousUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/embed-url/anonymous-user"
    }
}

public struct GenerateEmbedUrlForAnonymousUserInput: Swift.Equatable {
    /// The domains that you want to add to the allow list for access to the generated URL that is then embedded. This optional parameter overrides the static domains that are configured in the Manage QuickSight menu in the Amazon QuickSight console. Instead, it allows only the domains that you include in this parameter. You can list up to three domains or subdomains in each API call. To include all subdomains under a specific domain to the allow list, use *. For example, https://*.sapp.amazon.com includes all subdomains under https://sapp.amazon.com.
    public var allowedDomains: [Swift.String]?
    /// The Amazon Resource Names (ARNs) for the Amazon QuickSight resources that the user is authorized to access during the lifetime of the session. If you choose Dashboard embedding experience, pass the list of dashboard ARNs in the account that you want the user to be able to view. Currently, you can pass up to 25 dashboard ARNs in each API call.
    /// This member is required.
    public var authorizedResourceArns: [Swift.String]?
    /// The ID for the Amazon Web Services account that contains the dashboard that you're embedding.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The configuration of the experience that you are embedding.
    /// This member is required.
    public var experienceConfiguration: QuickSightClientTypes.AnonymousUserEmbeddingExperienceConfiguration?
    /// The Amazon QuickSight namespace that the anonymous user virtually belongs to. If you are not using an Amazon QuickSight custom namespace, set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// How many minutes the session is valid. The session lifetime must be in [15-600] minutes range.
    public var sessionLifetimeInMinutes: Swift.Int?
    /// The session tags used for row-level security. Before you use this parameter, make sure that you have configured the relevant datasets using the DataSet$RowLevelPermissionTagConfiguration parameter so that session tags can be used to provide row-level security. These are not the tags used for the Amazon Web Services resource tagging feature. For more information, see [Using Row-Level Security (RLS) with Tags](https://docs.aws.amazon.com/quicksight/latest/user/quicksight-dev-rls-tags.html)in the Amazon QuickSight User Guide.
    public var sessionTags: [QuickSightClientTypes.SessionTag]?

    public init (
        allowedDomains: [Swift.String]? = nil,
        authorizedResourceArns: [Swift.String]? = nil,
        awsAccountId: Swift.String? = nil,
        experienceConfiguration: QuickSightClientTypes.AnonymousUserEmbeddingExperienceConfiguration? = nil,
        namespace: Swift.String? = nil,
        sessionLifetimeInMinutes: Swift.Int? = nil,
        sessionTags: [QuickSightClientTypes.SessionTag]? = nil
    )
    {
        self.allowedDomains = allowedDomains
        self.authorizedResourceArns = authorizedResourceArns
        self.awsAccountId = awsAccountId
        self.experienceConfiguration = experienceConfiguration
        self.namespace = namespace
        self.sessionLifetimeInMinutes = sessionLifetimeInMinutes
        self.sessionTags = sessionTags
    }
}

struct GenerateEmbedUrlForAnonymousUserInputBody: Swift.Equatable {
    let sessionLifetimeInMinutes: Swift.Int?
    let namespace: Swift.String?
    let sessionTags: [QuickSightClientTypes.SessionTag]?
    let authorizedResourceArns: [Swift.String]?
    let experienceConfiguration: QuickSightClientTypes.AnonymousUserEmbeddingExperienceConfiguration?
    let allowedDomains: [Swift.String]?
}

extension GenerateEmbedUrlForAnonymousUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedDomains = "AllowedDomains"
        case authorizedResourceArns = "AuthorizedResourceArns"
        case experienceConfiguration = "ExperienceConfiguration"
        case namespace = "Namespace"
        case sessionLifetimeInMinutes = "SessionLifetimeInMinutes"
        case sessionTags = "SessionTags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionLifetimeInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sessionLifetimeInMinutes)
        sessionLifetimeInMinutes = sessionLifetimeInMinutesDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let sessionTagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.SessionTag?].self, forKey: .sessionTags)
        var sessionTagsDecoded0:[QuickSightClientTypes.SessionTag]? = nil
        if let sessionTagsContainer = sessionTagsContainer {
            sessionTagsDecoded0 = [QuickSightClientTypes.SessionTag]()
            for structure0 in sessionTagsContainer {
                if let structure0 = structure0 {
                    sessionTagsDecoded0?.append(structure0)
                }
            }
        }
        sessionTags = sessionTagsDecoded0
        let authorizedResourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizedResourceArns)
        var authorizedResourceArnsDecoded0:[Swift.String]? = nil
        if let authorizedResourceArnsContainer = authorizedResourceArnsContainer {
            authorizedResourceArnsDecoded0 = [Swift.String]()
            for string0 in authorizedResourceArnsContainer {
                if let string0 = string0 {
                    authorizedResourceArnsDecoded0?.append(string0)
                }
            }
        }
        authorizedResourceArns = authorizedResourceArnsDecoded0
        let experienceConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AnonymousUserEmbeddingExperienceConfiguration.self, forKey: .experienceConfiguration)
        experienceConfiguration = experienceConfigurationDecoded
        let allowedDomainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedDomains)
        var allowedDomainsDecoded0:[Swift.String]? = nil
        if let allowedDomainsContainer = allowedDomainsContainer {
            allowedDomainsDecoded0 = [Swift.String]()
            for string0 in allowedDomainsContainer {
                if let string0 = string0 {
                    allowedDomainsDecoded0?.append(string0)
                }
            }
        }
        allowedDomains = allowedDomainsDecoded0
    }
}

extension GenerateEmbedUrlForAnonymousUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GenerateEmbedUrlForAnonymousUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SessionLifetimeInMinutesInvalidException" : self = .sessionLifetimeInMinutesInvalidException(try SessionLifetimeInMinutesInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedPricingPlanException" : self = .unsupportedPricingPlanException(try UnsupportedPricingPlanException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GenerateEmbedUrlForAnonymousUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case sessionLifetimeInMinutesInvalidException(SessionLifetimeInMinutesInvalidException)
    case throttlingException(ThrottlingException)
    case unsupportedPricingPlanException(UnsupportedPricingPlanException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GenerateEmbedUrlForAnonymousUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GenerateEmbedUrlForAnonymousUserOutputResponse(anonymousUserArn: \(Swift.String(describing: anonymousUserArn)), requestId: \(Swift.String(describing: requestId)), status: \(Swift.String(describing: status)), embedUrl: \"CONTENT_REDACTED\")"}
}

extension GenerateEmbedUrlForAnonymousUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GenerateEmbedUrlForAnonymousUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.anonymousUserArn = output.anonymousUserArn
            self.embedUrl = output.embedUrl
            self.requestId = output.requestId
        } else {
            self.anonymousUserArn = nil
            self.embedUrl = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct GenerateEmbedUrlForAnonymousUserOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) to use for the anonymous Amazon QuickSight user.
    /// This member is required.
    public var anonymousUserArn: Swift.String?
    /// The embed URL for the dashboard.
    /// This member is required.
    public var embedUrl: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    /// This member is required.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    /// This member is required.
    public var status: Swift.Int

    public init (
        anonymousUserArn: Swift.String? = nil,
        embedUrl: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.anonymousUserArn = anonymousUserArn
        self.embedUrl = embedUrl
        self.requestId = requestId
        self.status = status
    }
}

struct GenerateEmbedUrlForAnonymousUserOutputResponseBody: Swift.Equatable {
    let embedUrl: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
    let anonymousUserArn: Swift.String?
}

extension GenerateEmbedUrlForAnonymousUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anonymousUserArn = "AnonymousUserArn"
        case embedUrl = "EmbedUrl"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let embedUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .embedUrl)
        embedUrl = embedUrlDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let anonymousUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anonymousUserArn)
        anonymousUserArn = anonymousUserArnDecoded
    }
}

extension GenerateEmbedUrlForRegisteredUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedDomains = "AllowedDomains"
        case experienceConfiguration = "ExperienceConfiguration"
        case sessionLifetimeInMinutes = "SessionLifetimeInMinutes"
        case userArn = "UserArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedDomains = allowedDomains {
            var allowedDomainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedDomains)
            for string0 in allowedDomains {
                try allowedDomainsContainer.encode(string0)
            }
        }
        if let experienceConfiguration = self.experienceConfiguration {
            try encodeContainer.encode(experienceConfiguration, forKey: .experienceConfiguration)
        }
        if let sessionLifetimeInMinutes = self.sessionLifetimeInMinutes {
            try encodeContainer.encode(sessionLifetimeInMinutes, forKey: .sessionLifetimeInMinutes)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension GenerateEmbedUrlForRegisteredUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/embed-url/registered-user"
    }
}

public struct GenerateEmbedUrlForRegisteredUserInput: Swift.Equatable {
    /// The domains that you want to add to the allow list for access to the generated URL that is then embedded. This optional parameter overrides the static domains that are configured in the Manage QuickSight menu in the Amazon QuickSight console. Instead, it allows only the domains that you include in this parameter. You can list up to three domains or subdomains in each API call. To include all subdomains under a specific domain to the allow list, use *. For example, https://*.sapp.amazon.com includes all subdomains under https://sapp.amazon.com.
    public var allowedDomains: [Swift.String]?
    /// The ID for the Amazon Web Services account that contains the dashboard that you're embedding.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The experience you are embedding. For registered users, you can embed Amazon QuickSight dashboards, Amazon QuickSight visuals, the Amazon QuickSight Q search bar, or the entire Amazon QuickSight console.
    /// This member is required.
    public var experienceConfiguration: QuickSightClientTypes.RegisteredUserEmbeddingExperienceConfiguration?
    /// How many minutes the session is valid. The session lifetime must be in [15-600] minutes range.
    public var sessionLifetimeInMinutes: Swift.Int?
    /// The Amazon Resource Name for the registered user.
    /// This member is required.
    public var userArn: Swift.String?

    public init (
        allowedDomains: [Swift.String]? = nil,
        awsAccountId: Swift.String? = nil,
        experienceConfiguration: QuickSightClientTypes.RegisteredUserEmbeddingExperienceConfiguration? = nil,
        sessionLifetimeInMinutes: Swift.Int? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.allowedDomains = allowedDomains
        self.awsAccountId = awsAccountId
        self.experienceConfiguration = experienceConfiguration
        self.sessionLifetimeInMinutes = sessionLifetimeInMinutes
        self.userArn = userArn
    }
}

struct GenerateEmbedUrlForRegisteredUserInputBody: Swift.Equatable {
    let sessionLifetimeInMinutes: Swift.Int?
    let userArn: Swift.String?
    let experienceConfiguration: QuickSightClientTypes.RegisteredUserEmbeddingExperienceConfiguration?
    let allowedDomains: [Swift.String]?
}

extension GenerateEmbedUrlForRegisteredUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedDomains = "AllowedDomains"
        case experienceConfiguration = "ExperienceConfiguration"
        case sessionLifetimeInMinutes = "SessionLifetimeInMinutes"
        case userArn = "UserArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionLifetimeInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sessionLifetimeInMinutes)
        sessionLifetimeInMinutes = sessionLifetimeInMinutesDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let experienceConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RegisteredUserEmbeddingExperienceConfiguration.self, forKey: .experienceConfiguration)
        experienceConfiguration = experienceConfigurationDecoded
        let allowedDomainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedDomains)
        var allowedDomainsDecoded0:[Swift.String]? = nil
        if let allowedDomainsContainer = allowedDomainsContainer {
            allowedDomainsDecoded0 = [Swift.String]()
            for string0 in allowedDomainsContainer {
                if let string0 = string0 {
                    allowedDomainsDecoded0?.append(string0)
                }
            }
        }
        allowedDomains = allowedDomainsDecoded0
    }
}

extension GenerateEmbedUrlForRegisteredUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GenerateEmbedUrlForRegisteredUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QuickSightUserNotFoundException" : self = .quickSightUserNotFoundException(try QuickSightUserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SessionLifetimeInMinutesInvalidException" : self = .sessionLifetimeInMinutesInvalidException(try SessionLifetimeInMinutesInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedPricingPlanException" : self = .unsupportedPricingPlanException(try UnsupportedPricingPlanException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GenerateEmbedUrlForRegisteredUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case quickSightUserNotFoundException(QuickSightUserNotFoundException)
    case resourceNotFoundException(ResourceNotFoundException)
    case sessionLifetimeInMinutesInvalidException(SessionLifetimeInMinutesInvalidException)
    case throttlingException(ThrottlingException)
    case unsupportedPricingPlanException(UnsupportedPricingPlanException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GenerateEmbedUrlForRegisteredUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GenerateEmbedUrlForRegisteredUserOutputResponse(requestId: \(Swift.String(describing: requestId)), status: \(Swift.String(describing: status)), embedUrl: \"CONTENT_REDACTED\")"}
}

extension GenerateEmbedUrlForRegisteredUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GenerateEmbedUrlForRegisteredUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.embedUrl = output.embedUrl
            self.requestId = output.requestId
        } else {
            self.embedUrl = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct GenerateEmbedUrlForRegisteredUserOutputResponse: Swift.Equatable {
    /// The embed URL for the Amazon QuickSight dashboard, visual, Q search bar, or console.
    /// This member is required.
    public var embedUrl: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    /// This member is required.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    /// This member is required.
    public var status: Swift.Int

    public init (
        embedUrl: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.embedUrl = embedUrl
        self.requestId = requestId
        self.status = status
    }
}

struct GenerateEmbedUrlForRegisteredUserOutputResponseBody: Swift.Equatable {
    let embedUrl: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension GenerateEmbedUrlForRegisteredUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case embedUrl = "EmbedUrl"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let embedUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .embedUrl)
        embedUrl = embedUrlDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.GeoSpatialColumnGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columns = "Columns"
        case countryCode = "CountryCode"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for columnname0 in columns {
                try columnsContainer.encode(columnname0)
            }
        }
        if let countryCode = self.countryCode {
            try encodeContainer.encode(countryCode.rawValue, forKey: .countryCode)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let countryCodeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GeoSpatialCountryCode.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let columnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .columns)
        var columnsDecoded0:[Swift.String]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [Swift.String]()
            for string0 in columnsContainer {
                if let string0 = string0 {
                    columnsDecoded0?.append(string0)
                }
            }
        }
        columns = columnsDecoded0
    }
}

extension QuickSightClientTypes {
    /// Geospatial column group that denotes a hierarchy.
    public struct GeoSpatialColumnGroup: Swift.Equatable {
        /// Columns in this hierarchy.
        /// This member is required.
        public var columns: [Swift.String]?
        /// Country code.
        public var countryCode: QuickSightClientTypes.GeoSpatialCountryCode?
        /// A display name for the hierarchy.
        /// This member is required.
        public var name: Swift.String?

        public init (
            columns: [Swift.String]? = nil,
            countryCode: QuickSightClientTypes.GeoSpatialCountryCode? = nil,
            name: Swift.String? = nil
        )
        {
            self.columns = columns
            self.countryCode = countryCode
            self.name = name
        }
    }

}

extension QuickSightClientTypes {
    public enum GeoSpatialCountryCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case us
        case sdkUnknown(Swift.String)

        public static var allCases: [GeoSpatialCountryCode] {
            return [
                .us,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .us: return "US"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GeoSpatialCountryCode(rawValue: rawValue) ?? GeoSpatialCountryCode.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum GeoSpatialDataRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case city
        case country
        case county
        case latitude
        case longitude
        case postcode
        case state
        case sdkUnknown(Swift.String)

        public static var allCases: [GeoSpatialDataRole] {
            return [
                .city,
                .country,
                .county,
                .latitude,
                .longitude,
                .postcode,
                .state,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .city: return "CITY"
            case .country: return "COUNTRY"
            case .county: return "COUNTY"
            case .latitude: return "LATITUDE"
            case .longitude: return "LONGITUDE"
            case .postcode: return "POSTCODE"
            case .state: return "STATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GeoSpatialDataRole(rawValue: rawValue) ?? GeoSpatialDataRole.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.GeospatialCoordinateBounds: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case east = "East"
        case north = "North"
        case south = "South"
        case west = "West"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let east = self.east {
            try encodeContainer.encode(east, forKey: .east)
        }
        if let north = self.north {
            try encodeContainer.encode(north, forKey: .north)
        }
        if let south = self.south {
            try encodeContainer.encode(south, forKey: .south)
        }
        if let west = self.west {
            try encodeContainer.encode(west, forKey: .west)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let northDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .north)
        north = northDecoded
        let southDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .south)
        south = southDecoded
        let westDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .west)
        west = westDecoded
        let eastDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .east)
        east = eastDecoded
    }
}

extension QuickSightClientTypes {
    /// The bound options (north, south, west, east) of the geospatial window options.
    public struct GeospatialCoordinateBounds: Swift.Equatable {
        /// The longitude of the east bound of the geospatial coordinate bounds.
        /// This member is required.
        public var east: Swift.Double?
        /// The latitude of the north bound of the geospatial coordinate bounds.
        /// This member is required.
        public var north: Swift.Double?
        /// The latitude of the south bound of the geospatial coordinate bounds.
        /// This member is required.
        public var south: Swift.Double?
        /// The longitude of the west bound of the geospatial coordinate bounds.
        /// This member is required.
        public var west: Swift.Double?

        public init (
            east: Swift.Double? = nil,
            north: Swift.Double? = nil,
            south: Swift.Double? = nil,
            west: Swift.Double? = nil
        )
        {
            self.east = east
            self.north = north
            self.south = south
            self.west = west
        }
    }

}

extension QuickSightClientTypes.GeospatialMapAggregatedFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case colors = "Colors"
        case geospatial = "Geospatial"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let colors = colors {
            var colorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .colors)
            for dimensionfield0 in colors {
                try colorsContainer.encode(dimensionfield0)
            }
        }
        if let geospatial = geospatial {
            var geospatialContainer = encodeContainer.nestedUnkeyedContainer(forKey: .geospatial)
            for dimensionfield0 in geospatial {
                try geospatialContainer.encode(dimensionfield0)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for measurefield0 in values {
                try valuesContainer.encode(measurefield0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geospatialContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .geospatial)
        var geospatialDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let geospatialContainer = geospatialContainer {
            geospatialDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in geospatialContainer {
                if let structure0 = structure0 {
                    geospatialDecoded0?.append(structure0)
                }
            }
        }
        geospatial = geospatialDecoded0
        let valuesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .values)
        var valuesDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
        let colorsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .colors)
        var colorsDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let colorsContainer = colorsContainer {
            colorsDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in colorsContainer {
                if let structure0 = structure0 {
                    colorsDecoded0?.append(structure0)
                }
            }
        }
        colors = colorsDecoded0
    }
}

extension QuickSightClientTypes {
    /// The aggregated field wells for a geospatial map.
    public struct GeospatialMapAggregatedFieldWells: Swift.Equatable {
        /// The color field wells of a geospatial map.
        public var colors: [QuickSightClientTypes.DimensionField]?
        /// The geospatial field wells of a geospatial map. Values are grouped by geospatial fields.
        public var geospatial: [QuickSightClientTypes.DimensionField]?
        /// The size field wells of a geospatial map. Values are aggregated based on geospatial fields.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init (
            colors: [QuickSightClientTypes.DimensionField]? = nil,
            geospatial: [QuickSightClientTypes.DimensionField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.colors = colors
            self.geospatial = geospatial
            self.values = values
        }
    }

}

extension QuickSightClientTypes.GeospatialMapConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldWells = "FieldWells"
        case legend = "Legend"
        case mapStyleOptions = "MapStyleOptions"
        case pointStyleOptions = "PointStyleOptions"
        case tooltip = "Tooltip"
        case visualPalette = "VisualPalette"
        case windowOptions = "WindowOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldWells = self.fieldWells {
            try encodeContainer.encode(fieldWells, forKey: .fieldWells)
        }
        if let legend = self.legend {
            try encodeContainer.encode(legend, forKey: .legend)
        }
        if let mapStyleOptions = self.mapStyleOptions {
            try encodeContainer.encode(mapStyleOptions, forKey: .mapStyleOptions)
        }
        if let pointStyleOptions = self.pointStyleOptions {
            try encodeContainer.encode(pointStyleOptions, forKey: .pointStyleOptions)
        }
        if let tooltip = self.tooltip {
            try encodeContainer.encode(tooltip, forKey: .tooltip)
        }
        if let visualPalette = self.visualPalette {
            try encodeContainer.encode(visualPalette, forKey: .visualPalette)
        }
        if let windowOptions = self.windowOptions {
            try encodeContainer.encode(windowOptions, forKey: .windowOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GeospatialMapFieldWells.self, forKey: .fieldWells)
        fieldWells = fieldWellsDecoded
        let legendDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LegendOptions.self, forKey: .legend)
        legend = legendDecoded
        let tooltipDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TooltipOptions.self, forKey: .tooltip)
        tooltip = tooltipDecoded
        let windowOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GeospatialWindowOptions.self, forKey: .windowOptions)
        windowOptions = windowOptionsDecoded
        let mapStyleOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GeospatialMapStyleOptions.self, forKey: .mapStyleOptions)
        mapStyleOptions = mapStyleOptionsDecoded
        let pointStyleOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GeospatialPointStyleOptions.self, forKey: .pointStyleOptions)
        pointStyleOptions = pointStyleOptionsDecoded
        let visualPaletteDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualPalette.self, forKey: .visualPalette)
        visualPalette = visualPaletteDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of a GeospatialMapVisual.
    public struct GeospatialMapConfiguration: Swift.Equatable {
        /// The field wells of the visual.
        public var fieldWells: QuickSightClientTypes.GeospatialMapFieldWells?
        /// The legend display setup of the visual.
        public var legend: QuickSightClientTypes.LegendOptions?
        /// The map style options of the geospatial map.
        public var mapStyleOptions: QuickSightClientTypes.GeospatialMapStyleOptions?
        /// The point style options of the geospatial map.
        public var pointStyleOptions: QuickSightClientTypes.GeospatialPointStyleOptions?
        /// The tooltip display setup of the visual.
        public var tooltip: QuickSightClientTypes.TooltipOptions?
        /// The visual display options for the visual palette.
        public var visualPalette: QuickSightClientTypes.VisualPalette?
        /// The window options of the geospatial map.
        public var windowOptions: QuickSightClientTypes.GeospatialWindowOptions?

        public init (
            fieldWells: QuickSightClientTypes.GeospatialMapFieldWells? = nil,
            legend: QuickSightClientTypes.LegendOptions? = nil,
            mapStyleOptions: QuickSightClientTypes.GeospatialMapStyleOptions? = nil,
            pointStyleOptions: QuickSightClientTypes.GeospatialPointStyleOptions? = nil,
            tooltip: QuickSightClientTypes.TooltipOptions? = nil,
            visualPalette: QuickSightClientTypes.VisualPalette? = nil,
            windowOptions: QuickSightClientTypes.GeospatialWindowOptions? = nil
        )
        {
            self.fieldWells = fieldWells
            self.legend = legend
            self.mapStyleOptions = mapStyleOptions
            self.pointStyleOptions = pointStyleOptions
            self.tooltip = tooltip
            self.visualPalette = visualPalette
            self.windowOptions = windowOptions
        }
    }

}

extension QuickSightClientTypes.GeospatialMapFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geospatialMapAggregatedFieldWells = "GeospatialMapAggregatedFieldWells"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let geospatialMapAggregatedFieldWells = self.geospatialMapAggregatedFieldWells {
            try encodeContainer.encode(geospatialMapAggregatedFieldWells, forKey: .geospatialMapAggregatedFieldWells)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geospatialMapAggregatedFieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GeospatialMapAggregatedFieldWells.self, forKey: .geospatialMapAggregatedFieldWells)
        geospatialMapAggregatedFieldWells = geospatialMapAggregatedFieldWellsDecoded
    }
}

extension QuickSightClientTypes {
    /// The field wells of a GeospatialMapVisual. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct GeospatialMapFieldWells: Swift.Equatable {
        /// The aggregated field well for a geospatial map.
        public var geospatialMapAggregatedFieldWells: QuickSightClientTypes.GeospatialMapAggregatedFieldWells?

        public init (
            geospatialMapAggregatedFieldWells: QuickSightClientTypes.GeospatialMapAggregatedFieldWells? = nil
        )
        {
            self.geospatialMapAggregatedFieldWells = geospatialMapAggregatedFieldWells
        }
    }

}

extension QuickSightClientTypes.GeospatialMapStyleOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseMapStyle = "BaseMapStyle"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseMapStyle = self.baseMapStyle {
            try encodeContainer.encode(baseMapStyle.rawValue, forKey: .baseMapStyle)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseMapStyleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.BaseMapStyleType.self, forKey: .baseMapStyle)
        baseMapStyle = baseMapStyleDecoded
    }
}

extension QuickSightClientTypes {
    /// The map style options of the geospatial map.
    public struct GeospatialMapStyleOptions: Swift.Equatable {
        /// The base map style of the geospatial map.
        public var baseMapStyle: QuickSightClientTypes.BaseMapStyleType?

        public init (
            baseMapStyle: QuickSightClientTypes.BaseMapStyleType? = nil
        )
        {
            self.baseMapStyle = baseMapStyle
        }
    }

}

extension QuickSightClientTypes.GeospatialMapVisual: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case chartConfiguration = "ChartConfiguration"
        case columnHierarchies = "ColumnHierarchies"
        case subtitle = "Subtitle"
        case title = "Title"
        case visualId = "VisualId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for visualcustomaction0 in actions {
                try actionsContainer.encode(visualcustomaction0)
            }
        }
        if let chartConfiguration = self.chartConfiguration {
            try encodeContainer.encode(chartConfiguration, forKey: .chartConfiguration)
        }
        if let columnHierarchies = columnHierarchies {
            var columnHierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnHierarchies)
            for columnhierarchy0 in columnHierarchies {
                try columnHierarchiesContainer.encode(columnhierarchy0)
            }
        }
        if let subtitle = self.subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let visualId = self.visualId {
            try encodeContainer.encode(visualId, forKey: .visualId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visualIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visualId)
        visualId = visualIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualTitleLabelOptions.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualSubtitleLabelOptions.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let chartConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GeospatialMapConfiguration.self, forKey: .chartConfiguration)
        chartConfiguration = chartConfigurationDecoded
        let columnHierarchiesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnHierarchy?].self, forKey: .columnHierarchies)
        var columnHierarchiesDecoded0:[QuickSightClientTypes.ColumnHierarchy]? = nil
        if let columnHierarchiesContainer = columnHierarchiesContainer {
            columnHierarchiesDecoded0 = [QuickSightClientTypes.ColumnHierarchy]()
            for structure0 in columnHierarchiesContainer {
                if let structure0 = structure0 {
                    columnHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        columnHierarchies = columnHierarchiesDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.VisualCustomAction?].self, forKey: .actions)
        var actionsDecoded0:[QuickSightClientTypes.VisualCustomAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [QuickSightClientTypes.VisualCustomAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A geospatial map or a points on map visual. For more information, see [Creating point maps](https://docs.aws.amazon.com/quicksight/latest/user/point-maps.html) in the Amazon QuickSight User Guide.
    public struct GeospatialMapVisual: Swift.Equatable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration settings of the visual.
        public var chartConfiguration: QuickSightClientTypes.GeospatialMapConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        /// This member is required.
        public var visualId: Swift.String?

        public init (
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.GeospatialMapConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }

}

extension QuickSightClientTypes.GeospatialPointStyleOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterMarkerConfiguration = "ClusterMarkerConfiguration"
        case selectedPointStyle = "SelectedPointStyle"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterMarkerConfiguration = self.clusterMarkerConfiguration {
            try encodeContainer.encode(clusterMarkerConfiguration, forKey: .clusterMarkerConfiguration)
        }
        if let selectedPointStyle = self.selectedPointStyle {
            try encodeContainer.encode(selectedPointStyle.rawValue, forKey: .selectedPointStyle)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectedPointStyleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GeospatialSelectedPointStyle.self, forKey: .selectedPointStyle)
        selectedPointStyle = selectedPointStyleDecoded
        let clusterMarkerConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ClusterMarkerConfiguration.self, forKey: .clusterMarkerConfiguration)
        clusterMarkerConfiguration = clusterMarkerConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The point style of the geospatial map.
    public struct GeospatialPointStyleOptions: Swift.Equatable {
        /// The cluster marker configuration of the geospatial point style.
        public var clusterMarkerConfiguration: QuickSightClientTypes.ClusterMarkerConfiguration?
        /// The selected point styles (point, cluster) of the geospatial map.
        public var selectedPointStyle: QuickSightClientTypes.GeospatialSelectedPointStyle?

        public init (
            clusterMarkerConfiguration: QuickSightClientTypes.ClusterMarkerConfiguration? = nil,
            selectedPointStyle: QuickSightClientTypes.GeospatialSelectedPointStyle? = nil
        )
        {
            self.clusterMarkerConfiguration = clusterMarkerConfiguration
            self.selectedPointStyle = selectedPointStyle
        }
    }

}

extension QuickSightClientTypes {
    public enum GeospatialSelectedPointStyle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cluster
        case point
        case sdkUnknown(Swift.String)

        public static var allCases: [GeospatialSelectedPointStyle] {
            return [
                .cluster,
                .point,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cluster: return "CLUSTER"
            case .point: return "POINT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GeospatialSelectedPointStyle(rawValue: rawValue) ?? GeospatialSelectedPointStyle.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.GeospatialWindowOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bounds = "Bounds"
        case mapZoomMode = "MapZoomMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bounds = self.bounds {
            try encodeContainer.encode(bounds, forKey: .bounds)
        }
        if let mapZoomMode = self.mapZoomMode {
            try encodeContainer.encode(mapZoomMode.rawValue, forKey: .mapZoomMode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let boundsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GeospatialCoordinateBounds.self, forKey: .bounds)
        bounds = boundsDecoded
        let mapZoomModeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.MapZoomMode.self, forKey: .mapZoomMode)
        mapZoomMode = mapZoomModeDecoded
    }
}

extension QuickSightClientTypes {
    /// The window options of the geospatial map visual.
    public struct GeospatialWindowOptions: Swift.Equatable {
        /// The bounds options (north, south, west, east) of the geospatial window options.
        public var bounds: QuickSightClientTypes.GeospatialCoordinateBounds?
        /// The map zoom modes (manual, auto) of the geospatial window options.
        public var mapZoomMode: QuickSightClientTypes.MapZoomMode?

        public init (
            bounds: QuickSightClientTypes.GeospatialCoordinateBounds? = nil,
            mapZoomMode: QuickSightClientTypes.MapZoomMode? = nil
        )
        {
            self.bounds = bounds
            self.mapZoomMode = mapZoomMode
        }
    }

}

extension GetDashboardEmbedUrlInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let identityType = identityType else {
                let message = "Creating a URL Query Item failed. identityType is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let identityTypeQueryItem = ClientRuntime.URLQueryItem(name: "creds-type".urlPercentEncoding(), value: Swift.String(identityType.rawValue).urlPercentEncoding())
            items.append(identityTypeQueryItem)
            if statePersistenceEnabled != false {
                let statePersistenceEnabledQueryItem = ClientRuntime.URLQueryItem(name: "state-persistence-enabled".urlPercentEncoding(), value: Swift.String(statePersistenceEnabled).urlPercentEncoding())
                items.append(statePersistenceEnabledQueryItem)
            }
            if let userArn = userArn {
                let userArnQueryItem = ClientRuntime.URLQueryItem(name: "user-arn".urlPercentEncoding(), value: Swift.String(userArn).urlPercentEncoding())
                items.append(userArnQueryItem)
            }
            if undoRedoDisabled != false {
                let undoRedoDisabledQueryItem = ClientRuntime.URLQueryItem(name: "undo-redo-disabled".urlPercentEncoding(), value: Swift.String(undoRedoDisabled).urlPercentEncoding())
                items.append(undoRedoDisabledQueryItem)
            }
            if let additionalDashboardIds = additionalDashboardIds {
                additionalDashboardIds.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "additional-dashboard-ids".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            if let sessionLifetimeInMinutes = sessionLifetimeInMinutes {
                let sessionLifetimeInMinutesQueryItem = ClientRuntime.URLQueryItem(name: "session-lifetime".urlPercentEncoding(), value: Swift.String(sessionLifetimeInMinutes).urlPercentEncoding())
                items.append(sessionLifetimeInMinutesQueryItem)
            }
            if resetDisabled != false {
                let resetDisabledQueryItem = ClientRuntime.URLQueryItem(name: "reset-disabled".urlPercentEncoding(), value: Swift.String(resetDisabled).urlPercentEncoding())
                items.append(resetDisabledQueryItem)
            }
            if let namespace = namespace {
                let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
                items.append(namespaceQueryItem)
            }
            return items
        }
    }
}

extension GetDashboardEmbedUrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dashboardId = dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())/embed-url"
    }
}

public struct GetDashboardEmbedUrlInput: Swift.Equatable {
    /// A list of one or more dashboard IDs that you want anonymous users to have tempporary access to. Currently, the IdentityType parameter must be set to ANONYMOUS because other identity types authenticate as Amazon QuickSight or IAM users. For example, if you set "--dashboard-id dash_id1 --dashboard-id dash_id2 dash_id3 identity-type ANONYMOUS", the session can access all three dashboards.
    public var additionalDashboardIds: [Swift.String]?
    /// The ID for the Amazon Web Services account that contains the dashboard that you're embedding.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard, also added to the Identity and Access Management (IAM) policy.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// The authentication method that the user uses to sign in.
    /// This member is required.
    public var identityType: QuickSightClientTypes.EmbeddingIdentityType?
    /// The Amazon QuickSight namespace that contains the dashboard IDs in this request. If you're not using a custom namespace, set Namespace = default.
    public var namespace: Swift.String?
    /// Remove the reset button on the embedded dashboard. The default is FALSE, which enables the reset button.
    public var resetDisabled: Swift.Bool
    /// How many minutes the session is valid. The session lifetime must be 15-600 minutes.
    public var sessionLifetimeInMinutes: Swift.Int?
    /// Adds persistence of state for the user session in an embedded dashboard. Persistence applies to the sheet and the parameter settings. These are control settings that the dashboard subscriber (Amazon QuickSight reader) chooses while viewing the dashboard. If this is set to TRUE, the settings are the same when the subscriber reopens the same dashboard URL. The state is stored in Amazon QuickSight, not in a browser cookie. If this is set to FALSE, the state of the user session is not persisted. The default is FALSE.
    public var statePersistenceEnabled: Swift.Bool
    /// Remove the undo/redo button on the embedded dashboard. The default is FALSE, which enables the undo/redo button.
    public var undoRedoDisabled: Swift.Bool
    /// The Amazon QuickSight user's Amazon Resource Name (ARN), for use with QUICKSIGHT identity type. You can use this for any Amazon QuickSight users in your account (readers, authors, or admins) authenticated as one of the following:
    ///
    /// * Active Directory (AD) users or group members
    ///
    /// * Invited nonfederated users
    ///
    /// * IAM users and IAM role-based sessions authenticated through Federated Single Sign-On using SAML, OpenID Connect, or IAM federation.
    ///
    ///
    /// Omit this parameter for users in the third group  IAM users and IAM role-based sessions.
    public var userArn: Swift.String?

    public init (
        additionalDashboardIds: [Swift.String]? = nil,
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        identityType: QuickSightClientTypes.EmbeddingIdentityType? = nil,
        namespace: Swift.String? = nil,
        resetDisabled: Swift.Bool = false,
        sessionLifetimeInMinutes: Swift.Int? = nil,
        statePersistenceEnabled: Swift.Bool = false,
        undoRedoDisabled: Swift.Bool = false,
        userArn: Swift.String? = nil
    )
    {
        self.additionalDashboardIds = additionalDashboardIds
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.identityType = identityType
        self.namespace = namespace
        self.resetDisabled = resetDisabled
        self.sessionLifetimeInMinutes = sessionLifetimeInMinutes
        self.statePersistenceEnabled = statePersistenceEnabled
        self.undoRedoDisabled = undoRedoDisabled
        self.userArn = userArn
    }
}

struct GetDashboardEmbedUrlInputBody: Swift.Equatable {
}

extension GetDashboardEmbedUrlInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDashboardEmbedUrlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDashboardEmbedUrlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotWhitelistedException" : self = .domainNotWhitelistedException(try DomainNotWhitelistedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdentityTypeNotSupportedException" : self = .identityTypeNotSupportedException(try IdentityTypeNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QuickSightUserNotFoundException" : self = .quickSightUserNotFoundException(try QuickSightUserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SessionLifetimeInMinutesInvalidException" : self = .sessionLifetimeInMinutesInvalidException(try SessionLifetimeInMinutesInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedPricingPlanException" : self = .unsupportedPricingPlanException(try UnsupportedPricingPlanException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDashboardEmbedUrlOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case domainNotWhitelistedException(DomainNotWhitelistedException)
    case identityTypeNotSupportedException(IdentityTypeNotSupportedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case quickSightUserNotFoundException(QuickSightUserNotFoundException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case sessionLifetimeInMinutesInvalidException(SessionLifetimeInMinutesInvalidException)
    case throttlingException(ThrottlingException)
    case unsupportedPricingPlanException(UnsupportedPricingPlanException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDashboardEmbedUrlOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDashboardEmbedUrlOutputResponse(requestId: \(Swift.String(describing: requestId)), status: \(Swift.String(describing: status)), embedUrl: \"CONTENT_REDACTED\")"}
}

extension GetDashboardEmbedUrlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDashboardEmbedUrlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.embedUrl = output.embedUrl
            self.requestId = output.requestId
        } else {
            self.embedUrl = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

/// Output returned from the GetDashboardEmbedUrl operation.
public struct GetDashboardEmbedUrlOutputResponse: Swift.Equatable {
    /// A single-use URL that you can put into your server-side webpage to embed your dashboard. This URL is valid for 5 minutes. The API operation provides the URL with an auth_code value that enables one (and only one) sign-on to a user session that is valid for 10 hours.
    public var embedUrl: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        embedUrl: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.embedUrl = embedUrl
        self.requestId = requestId
        self.status = status
    }
}

struct GetDashboardEmbedUrlOutputResponseBody: Swift.Equatable {
    let embedUrl: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension GetDashboardEmbedUrlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case embedUrl = "EmbedUrl"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let embedUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .embedUrl)
        embedUrl = embedUrlDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension GetSessionEmbedUrlInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let userArn = userArn {
                let userArnQueryItem = ClientRuntime.URLQueryItem(name: "user-arn".urlPercentEncoding(), value: Swift.String(userArn).urlPercentEncoding())
                items.append(userArnQueryItem)
            }
            if let entryPoint = entryPoint {
                let entryPointQueryItem = ClientRuntime.URLQueryItem(name: "entry-point".urlPercentEncoding(), value: Swift.String(entryPoint).urlPercentEncoding())
                items.append(entryPointQueryItem)
            }
            if let sessionLifetimeInMinutes = sessionLifetimeInMinutes {
                let sessionLifetimeInMinutesQueryItem = ClientRuntime.URLQueryItem(name: "session-lifetime".urlPercentEncoding(), value: Swift.String(sessionLifetimeInMinutes).urlPercentEncoding())
                items.append(sessionLifetimeInMinutesQueryItem)
            }
            return items
        }
    }
}

extension GetSessionEmbedUrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/session-embed-url"
    }
}

public struct GetSessionEmbedUrlInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account associated with your Amazon QuickSight subscription.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The URL you use to access the embedded session. The entry point URL is constrained to the following paths:
    ///
    /// * /start
    ///
    /// * /start/analyses
    ///
    /// * /start/dashboards
    ///
    /// * /start/favorites
    ///
    /// * /dashboards/DashboardId  - where DashboardId is the actual ID key from the Amazon QuickSight console URL of the dashboard
    ///
    /// * /analyses/AnalysisId  - where AnalysisId is the actual ID key from the Amazon QuickSight console URL of the analysis
    public var entryPoint: Swift.String?
    /// How many minutes the session is valid. The session lifetime must be 15-600 minutes.
    public var sessionLifetimeInMinutes: Swift.Int?
    /// The Amazon QuickSight user's Amazon Resource Name (ARN), for use with QUICKSIGHT identity type. You can use this for any type of Amazon QuickSight users in your account (readers, authors, or admins). They need to be authenticated as one of the following:
    ///
    /// * Active Directory (AD) users or group members
    ///
    /// * Invited nonfederated users
    ///
    /// * Identity and Access Management (IAM) users and IAM role-based sessions authenticated through Federated Single Sign-On using SAML, OpenID Connect, or IAM federation
    ///
    ///
    /// Omit this parameter for users in the third group, IAM users and IAM role-based sessions.
    public var userArn: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        entryPoint: Swift.String? = nil,
        sessionLifetimeInMinutes: Swift.Int? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.entryPoint = entryPoint
        self.sessionLifetimeInMinutes = sessionLifetimeInMinutes
        self.userArn = userArn
    }
}

struct GetSessionEmbedUrlInputBody: Swift.Equatable {
}

extension GetSessionEmbedUrlInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSessionEmbedUrlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSessionEmbedUrlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QuickSightUserNotFoundException" : self = .quickSightUserNotFoundException(try QuickSightUserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SessionLifetimeInMinutesInvalidException" : self = .sessionLifetimeInMinutesInvalidException(try SessionLifetimeInMinutesInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSessionEmbedUrlOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case quickSightUserNotFoundException(QuickSightUserNotFoundException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case sessionLifetimeInMinutesInvalidException(SessionLifetimeInMinutesInvalidException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSessionEmbedUrlOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSessionEmbedUrlOutputResponse(requestId: \(Swift.String(describing: requestId)), status: \(Swift.String(describing: status)), embedUrl: \"CONTENT_REDACTED\")"}
}

extension GetSessionEmbedUrlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSessionEmbedUrlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.embedUrl = output.embedUrl
            self.requestId = output.requestId
        } else {
            self.embedUrl = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct GetSessionEmbedUrlOutputResponse: Swift.Equatable {
    /// A single-use URL that you can put into your server-side web page to embed your Amazon QuickSight session. This URL is valid for 5 minutes. The API operation provides the URL with an auth_code value that enables one (and only one) sign-on to a user session that is valid for 10 hours.
    public var embedUrl: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        embedUrl: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.embedUrl = embedUrl
        self.requestId = requestId
        self.status = status
    }
}

struct GetSessionEmbedUrlOutputResponseBody: Swift.Equatable {
    let embedUrl: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension GetSessionEmbedUrlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case embedUrl = "EmbedUrl"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let embedUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .embedUrl)
        embedUrl = embedUrlDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.GlobalTableBorderOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sideSpecificBorder = "SideSpecificBorder"
        case uniformBorder = "UniformBorder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sideSpecificBorder = self.sideSpecificBorder {
            try encodeContainer.encode(sideSpecificBorder, forKey: .sideSpecificBorder)
        }
        if let uniformBorder = self.uniformBorder {
            try encodeContainer.encode(uniformBorder, forKey: .uniformBorder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uniformBorderDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableBorderOptions.self, forKey: .uniformBorder)
        uniformBorder = uniformBorderDecoded
        let sideSpecificBorderDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableSideBorderOptions.self, forKey: .sideSpecificBorder)
        sideSpecificBorder = sideSpecificBorderDecoded
    }
}

extension QuickSightClientTypes {
    /// Determines the border options for a table visual.
    public struct GlobalTableBorderOptions: Swift.Equatable {
        /// Determines the options for side specific border.
        public var sideSpecificBorder: QuickSightClientTypes.TableSideBorderOptions?
        /// Determines the options for uniform border.
        public var uniformBorder: QuickSightClientTypes.TableBorderOptions?

        public init (
            sideSpecificBorder: QuickSightClientTypes.TableSideBorderOptions? = nil,
            uniformBorder: QuickSightClientTypes.TableBorderOptions? = nil
        )
        {
            self.sideSpecificBorder = sideSpecificBorder
            self.uniformBorder = uniformBorder
        }
    }

}

extension QuickSightClientTypes.GradientColor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stops = "Stops"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stops = stops {
            var stopsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stops)
            for gradientstop0 in stops {
                try stopsContainer.encode(gradientstop0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stopsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.GradientStop?].self, forKey: .stops)
        var stopsDecoded0:[QuickSightClientTypes.GradientStop]? = nil
        if let stopsContainer = stopsContainer {
            stopsDecoded0 = [QuickSightClientTypes.GradientStop]()
            for structure0 in stopsContainer {
                if let structure0 = structure0 {
                    stopsDecoded0?.append(structure0)
                }
            }
        }
        stops = stopsDecoded0
    }
}

extension QuickSightClientTypes {
    /// Determines the gradient color settings.
    public struct GradientColor: Swift.Equatable {
        /// The list of gradient color stops.
        public var stops: [QuickSightClientTypes.GradientStop]?

        public init (
            stops: [QuickSightClientTypes.GradientStop]? = nil
        )
        {
            self.stops = stops
        }
    }

}

extension QuickSightClientTypes.GradientStop: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case color = "Color"
        case dataValue = "DataValue"
        case gradientOffset = "GradientOffset"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let color = self.color {
            try encodeContainer.encode(color, forKey: .color)
        }
        if let dataValue = self.dataValue {
            try encodeContainer.encode(dataValue, forKey: .dataValue)
        }
        if gradientOffset != 0.0 {
            try encodeContainer.encode(gradientOffset, forKey: .gradientOffset)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gradientOffsetDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .gradientOffset) ?? 0.0
        gradientOffset = gradientOffsetDecoded
        let dataValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .dataValue)
        dataValue = dataValueDecoded
        let colorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .color)
        color = colorDecoded
    }
}

extension QuickSightClientTypes {
    /// Determines the gradient stop configuration.
    public struct GradientStop: Swift.Equatable {
        /// Determines the color.
        public var color: Swift.String?
        /// Determines the data value.
        public var dataValue: Swift.Double?
        /// Determines gradient offset value.
        /// This member is required.
        public var gradientOffset: Swift.Double

        public init (
            color: Swift.String? = nil,
            dataValue: Swift.Double? = nil,
            gradientOffset: Swift.Double = 0.0
        )
        {
            self.color = color
            self.dataValue = dataValue
            self.gradientOffset = gradientOffset
        }
    }

}

extension QuickSightClientTypes.GridLayoutCanvasSizeOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case screenCanvasSizeOptions = "ScreenCanvasSizeOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let screenCanvasSizeOptions = self.screenCanvasSizeOptions {
            try encodeContainer.encode(screenCanvasSizeOptions, forKey: .screenCanvasSizeOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let screenCanvasSizeOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GridLayoutScreenCanvasSizeOptions.self, forKey: .screenCanvasSizeOptions)
        screenCanvasSizeOptions = screenCanvasSizeOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// Configuration options for the canvas of a grid layout.
    public struct GridLayoutCanvasSizeOptions: Swift.Equatable {
        /// The options that determine the sizing of the canvas used in a grid layout.
        public var screenCanvasSizeOptions: QuickSightClientTypes.GridLayoutScreenCanvasSizeOptions?

        public init (
            screenCanvasSizeOptions: QuickSightClientTypes.GridLayoutScreenCanvasSizeOptions? = nil
        )
        {
            self.screenCanvasSizeOptions = screenCanvasSizeOptions
        }
    }

}

extension QuickSightClientTypes.GridLayoutConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canvasSizeOptions = "CanvasSizeOptions"
        case elements = "Elements"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let canvasSizeOptions = self.canvasSizeOptions {
            try encodeContainer.encode(canvasSizeOptions, forKey: .canvasSizeOptions)
        }
        if let elements = elements {
            var elementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .elements)
            for gridlayoutelement0 in elements {
                try elementsContainer.encode(gridlayoutelement0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elementsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.GridLayoutElement?].self, forKey: .elements)
        var elementsDecoded0:[QuickSightClientTypes.GridLayoutElement]? = nil
        if let elementsContainer = elementsContainer {
            elementsDecoded0 = [QuickSightClientTypes.GridLayoutElement]()
            for structure0 in elementsContainer {
                if let structure0 = structure0 {
                    elementsDecoded0?.append(structure0)
                }
            }
        }
        elements = elementsDecoded0
        let canvasSizeOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GridLayoutCanvasSizeOptions.self, forKey: .canvasSizeOptions)
        canvasSizeOptions = canvasSizeOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration for a grid layout. Also called a tiled layout. Visuals snap to a grid with standard spacing and alignment. Dashboards are displayed as designed, with options to fit to screen or view at actual size.
    public struct GridLayoutConfiguration: Swift.Equatable {
        /// Configuration options for the canvas of a grid layout.
        public var canvasSizeOptions: QuickSightClientTypes.GridLayoutCanvasSizeOptions?
        /// The elements that are included in a grid layout.
        /// This member is required.
        public var elements: [QuickSightClientTypes.GridLayoutElement]?

        public init (
            canvasSizeOptions: QuickSightClientTypes.GridLayoutCanvasSizeOptions? = nil,
            elements: [QuickSightClientTypes.GridLayoutElement]? = nil
        )
        {
            self.canvasSizeOptions = canvasSizeOptions
            self.elements = elements
        }
    }

}

extension QuickSightClientTypes.GridLayoutElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnIndex = "ColumnIndex"
        case columnSpan = "ColumnSpan"
        case elementId = "ElementId"
        case elementType = "ElementType"
        case rowIndex = "RowIndex"
        case rowSpan = "RowSpan"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnIndex = self.columnIndex {
            try encodeContainer.encode(columnIndex, forKey: .columnIndex)
        }
        if let columnSpan = self.columnSpan {
            try encodeContainer.encode(columnSpan, forKey: .columnSpan)
        }
        if let elementId = self.elementId {
            try encodeContainer.encode(elementId, forKey: .elementId)
        }
        if let elementType = self.elementType {
            try encodeContainer.encode(elementType.rawValue, forKey: .elementType)
        }
        if let rowIndex = self.rowIndex {
            try encodeContainer.encode(rowIndex, forKey: .rowIndex)
        }
        if let rowSpan = self.rowSpan {
            try encodeContainer.encode(rowSpan, forKey: .rowSpan)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elementId)
        elementId = elementIdDecoded
        let elementTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LayoutElementType.self, forKey: .elementType)
        elementType = elementTypeDecoded
        let columnIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .columnIndex)
        columnIndex = columnIndexDecoded
        let columnSpanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .columnSpan)
        columnSpan = columnSpanDecoded
        let rowIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rowIndex)
        rowIndex = rowIndexDecoded
        let rowSpanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rowSpan)
        rowSpan = rowSpanDecoded
    }
}

extension QuickSightClientTypes {
    /// An element within a grid layout.
    public struct GridLayoutElement: Swift.Equatable {
        /// The column index for the upper left corner of an element.
        public var columnIndex: Swift.Int?
        /// The width of a grid element expressed as a number of grid columns.
        /// This member is required.
        public var columnSpan: Swift.Int?
        /// A unique identifier for an element within a grid layout.
        /// This member is required.
        public var elementId: Swift.String?
        /// The type of element.
        /// This member is required.
        public var elementType: QuickSightClientTypes.LayoutElementType?
        /// The row index for the upper left corner of an element.
        public var rowIndex: Swift.Int?
        /// The height of a grid element expressed as a number of grid rows.
        /// This member is required.
        public var rowSpan: Swift.Int?

        public init (
            columnIndex: Swift.Int? = nil,
            columnSpan: Swift.Int? = nil,
            elementId: Swift.String? = nil,
            elementType: QuickSightClientTypes.LayoutElementType? = nil,
            rowIndex: Swift.Int? = nil,
            rowSpan: Swift.Int? = nil
        )
        {
            self.columnIndex = columnIndex
            self.columnSpan = columnSpan
            self.elementId = elementId
            self.elementType = elementType
            self.rowIndex = rowIndex
            self.rowSpan = rowSpan
        }
    }

}

extension QuickSightClientTypes.GridLayoutScreenCanvasSizeOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optimizedViewPortWidth = "OptimizedViewPortWidth"
        case resizeOption = "ResizeOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let optimizedViewPortWidth = self.optimizedViewPortWidth {
            try encodeContainer.encode(optimizedViewPortWidth, forKey: .optimizedViewPortWidth)
        }
        if let resizeOption = self.resizeOption {
            try encodeContainer.encode(resizeOption.rawValue, forKey: .resizeOption)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resizeOptionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResizeOption.self, forKey: .resizeOption)
        resizeOption = resizeOptionDecoded
        let optimizedViewPortWidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optimizedViewPortWidth)
        optimizedViewPortWidth = optimizedViewPortWidthDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the sizing of the canvas used in a grid layout.
    public struct GridLayoutScreenCanvasSizeOptions: Swift.Equatable {
        /// The width that the view port will be optimized for when the layout renders.
        public var optimizedViewPortWidth: Swift.String?
        /// This value determines the layout behavior when the viewport is resized.
        ///
        /// * FIXED: A fixed width will be used when optimizing the layout. In the Amazon QuickSight console, this option is called Classic.
        ///
        /// * RESPONSIVE: The width of the canvas will be responsive and optimized to the view port. In the Amazon QuickSight console, this option is called Tiled.
        /// This member is required.
        public var resizeOption: QuickSightClientTypes.ResizeOption?

        public init (
            optimizedViewPortWidth: Swift.String? = nil,
            resizeOption: QuickSightClientTypes.ResizeOption? = nil
        )
        {
            self.optimizedViewPortWidth = optimizedViewPortWidth
            self.resizeOption = resizeOption
        }
    }

}

extension QuickSightClientTypes.Group: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case groupName = "GroupName"
        case principalId = "PrincipalId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension QuickSightClientTypes {
    /// A group in Amazon QuickSight consists of a set of users. You can use groups to make it easier to manage access and security.
    public struct Group: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the group.
        public var arn: Swift.String?
        /// The group description.
        public var description: Swift.String?
        /// The name of the group.
        public var groupName: Swift.String?
        /// The principal ID of the group.
        public var principalId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            groupName: Swift.String? = nil,
            principalId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.groupName = groupName
            self.principalId = principalId
        }
    }

}

extension QuickSightClientTypes {
    public enum GroupFilterAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case groupName
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupFilterAttribute] {
            return [
                .groupName,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .groupName: return "GROUP_NAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GroupFilterAttribute(rawValue: rawValue) ?? GroupFilterAttribute.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum GroupFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case startswith
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupFilterOperator] {
            return [
                .startswith,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .startswith: return "StartsWith"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GroupFilterOperator(rawValue: rawValue) ?? GroupFilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.GroupMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case memberName = "MemberName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let memberName = self.memberName {
            try encodeContainer.encode(memberName, forKey: .memberName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let memberNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberName)
        memberName = memberNameDecoded
    }
}

extension QuickSightClientTypes {
    /// A member of an Amazon QuickSight group. Currently, group members must be users. Groups can't be members of another group. .
    public struct GroupMember: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the group member (user).
        public var arn: Swift.String?
        /// The name of the group member (user).
        public var memberName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            memberName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.memberName = memberName
        }
    }

}

extension QuickSightClientTypes.GroupSearchFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case `operator` = "Operator"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GroupFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let nameDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GroupFilterAttribute.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension QuickSightClientTypes {
    /// A GroupSearchFilter object that you want to apply to your search.
    public struct GroupSearchFilter: Swift.Equatable {
        /// The name of the value that you want to use as a filter, for example "Name": "GROUP_NAME". Currently, the only supported name is GROUP_NAME.
        /// This member is required.
        public var name: QuickSightClientTypes.GroupFilterAttribute?
        /// The comparison operator that you want to use as a filter, for example "Operator": "StartsWith". Currently, the only supported operator is StartsWith.
        /// This member is required.
        public var `operator`: QuickSightClientTypes.GroupFilterOperator?
        /// The value of the named item, in this case GROUP_NAME, that you want to use as a filter.
        /// This member is required.
        public var value: Swift.String?

        public init (
            name: QuickSightClientTypes.GroupFilterAttribute? = nil,
            `operator`: QuickSightClientTypes.GroupFilterOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }
    }

}

extension QuickSightClientTypes.GrowthRateComputation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computationId = "ComputationId"
        case name = "Name"
        case periodSize = "PeriodSize"
        case time = "Time"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computationId = self.computationId {
            try encodeContainer.encode(computationId, forKey: .computationId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if periodSize != 0 {
            try encodeContainer.encode(periodSize, forKey: .periodSize)
        }
        if let time = self.time {
            try encodeContainer.encode(time, forKey: .time)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .computationId)
        computationId = computationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let timeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DimensionField.self, forKey: .time)
        time = timeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.MeasureField.self, forKey: .value)
        value = valueDecoded
        let periodSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .periodSize) ?? 0
        periodSize = periodSizeDecoded
    }
}

extension QuickSightClientTypes {
    /// The growth rate computation configuration.
    public struct GrowthRateComputation: Swift.Equatable {
        /// The ID for a computation.
        /// This member is required.
        public var computationId: Swift.String?
        /// The name of a computation.
        public var name: Swift.String?
        /// The period size setup of a growth rate computation.
        public var periodSize: Swift.Int
        /// The time field that is used in a computation.
        /// This member is required.
        public var time: QuickSightClientTypes.DimensionField?
        /// The value field that is used in a computation.
        public var value: QuickSightClientTypes.MeasureField?

        public init (
            computationId: Swift.String? = nil,
            name: Swift.String? = nil,
            periodSize: Swift.Int = 0,
            time: QuickSightClientTypes.DimensionField? = nil,
            value: QuickSightClientTypes.MeasureField? = nil
        )
        {
            self.computationId = computationId
            self.name = name
            self.periodSize = periodSize
            self.time = time
            self.value = value
        }
    }

}

extension QuickSightClientTypes.GutterStyle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case show = "Show"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let show = self.show {
            try encodeContainer.encode(show, forKey: .show)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let showDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .show)
        show = showDecoded
    }
}

extension QuickSightClientTypes {
    /// The display options for gutter spacing between tiles on a sheet.
    public struct GutterStyle: Swift.Equatable {
        /// This Boolean value controls whether to display a gutter space between sheet tiles.
        public var show: Swift.Bool?

        public init (
            show: Swift.Bool? = nil
        )
        {
            self.show = show
        }
    }

}

extension QuickSightClientTypes.HeaderFooterSectionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layout = "Layout"
        case sectionId = "SectionId"
        case style = "Style"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layout = self.layout {
            try encodeContainer.encode(layout, forKey: .layout)
        }
        if let sectionId = self.sectionId {
            try encodeContainer.encode(sectionId, forKey: .sectionId)
        }
        if let style = self.style {
            try encodeContainer.encode(style, forKey: .style)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sectionId)
        sectionId = sectionIdDecoded
        let layoutDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SectionLayoutConfiguration.self, forKey: .layout)
        layout = layoutDecoded
        let styleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SectionStyle.self, forKey: .style)
        style = styleDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of a header or footer section.
    public struct HeaderFooterSectionConfiguration: Swift.Equatable {
        /// The layout configuration of the header or footer section.
        /// This member is required.
        public var layout: QuickSightClientTypes.SectionLayoutConfiguration?
        /// The unique identifier of the header or footer section.
        /// This member is required.
        public var sectionId: Swift.String?
        /// The style options of a header or footer section.
        public var style: QuickSightClientTypes.SectionStyle?

        public init (
            layout: QuickSightClientTypes.SectionLayoutConfiguration? = nil,
            sectionId: Swift.String? = nil,
            style: QuickSightClientTypes.SectionStyle? = nil
        )
        {
            self.layout = layout
            self.sectionId = sectionId
            self.style = style
        }
    }

}

extension QuickSightClientTypes.HeatMapAggregatedFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columns = "Columns"
        case rows = "Rows"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for dimensionfield0 in columns {
                try columnsContainer.encode(dimensionfield0)
            }
        }
        if let rows = rows {
            var rowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rows)
            for dimensionfield0 in rows {
                try rowsContainer.encode(dimensionfield0)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for measurefield0 in values {
                try valuesContainer.encode(measurefield0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .rows)
        var rowsDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let rowsContainer = rowsContainer {
            rowsDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in rowsContainer {
                if let structure0 = structure0 {
                    rowsDecoded0?.append(structure0)
                }
            }
        }
        rows = rowsDecoded0
        let columnsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .columns)
        var columnsDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in columnsContainer {
                if let structure0 = structure0 {
                    columnsDecoded0?.append(structure0)
                }
            }
        }
        columns = columnsDecoded0
        let valuesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .values)
        var valuesDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension QuickSightClientTypes {
    /// The aggregated field wells of a heat map.
    public struct HeatMapAggregatedFieldWells: Swift.Equatable {
        /// The columns field well of a heat map.
        public var columns: [QuickSightClientTypes.DimensionField]?
        /// The rows field well of a heat map.
        public var rows: [QuickSightClientTypes.DimensionField]?
        /// The values field well of a heat map.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init (
            columns: [QuickSightClientTypes.DimensionField]? = nil,
            rows: [QuickSightClientTypes.DimensionField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.columns = columns
            self.rows = rows
            self.values = values
        }
    }

}

extension QuickSightClientTypes.HeatMapConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case colorScale = "ColorScale"
        case columnLabelOptions = "ColumnLabelOptions"
        case dataLabels = "DataLabels"
        case fieldWells = "FieldWells"
        case legend = "Legend"
        case rowLabelOptions = "RowLabelOptions"
        case sortConfiguration = "SortConfiguration"
        case tooltip = "Tooltip"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let colorScale = self.colorScale {
            try encodeContainer.encode(colorScale, forKey: .colorScale)
        }
        if let columnLabelOptions = self.columnLabelOptions {
            try encodeContainer.encode(columnLabelOptions, forKey: .columnLabelOptions)
        }
        if let dataLabels = self.dataLabels {
            try encodeContainer.encode(dataLabels, forKey: .dataLabels)
        }
        if let fieldWells = self.fieldWells {
            try encodeContainer.encode(fieldWells, forKey: .fieldWells)
        }
        if let legend = self.legend {
            try encodeContainer.encode(legend, forKey: .legend)
        }
        if let rowLabelOptions = self.rowLabelOptions {
            try encodeContainer.encode(rowLabelOptions, forKey: .rowLabelOptions)
        }
        if let sortConfiguration = self.sortConfiguration {
            try encodeContainer.encode(sortConfiguration, forKey: .sortConfiguration)
        }
        if let tooltip = self.tooltip {
            try encodeContainer.encode(tooltip, forKey: .tooltip)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.HeatMapFieldWells.self, forKey: .fieldWells)
        fieldWells = fieldWellsDecoded
        let sortConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.HeatMapSortConfiguration.self, forKey: .sortConfiguration)
        sortConfiguration = sortConfigurationDecoded
        let rowLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .rowLabelOptions)
        rowLabelOptions = rowLabelOptionsDecoded
        let columnLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .columnLabelOptions)
        columnLabelOptions = columnLabelOptionsDecoded
        let colorScaleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColorScale.self, forKey: .colorScale)
        colorScale = colorScaleDecoded
        let legendDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LegendOptions.self, forKey: .legend)
        legend = legendDecoded
        let dataLabelsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataLabelOptions.self, forKey: .dataLabels)
        dataLabels = dataLabelsDecoded
        let tooltipDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TooltipOptions.self, forKey: .tooltip)
        tooltip = tooltipDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of a heat map.
    public struct HeatMapConfiguration: Swift.Equatable {
        /// The color options (gradient color, point of divergence) in a heat map.
        public var colorScale: QuickSightClientTypes.ColorScale?
        /// The label options of the column that is displayed in a heat map.
        public var columnLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The options that determine if visual data labels are displayed.
        public var dataLabels: QuickSightClientTypes.DataLabelOptions?
        /// The field wells of the visual.
        public var fieldWells: QuickSightClientTypes.HeatMapFieldWells?
        /// The legend display setup of the visual.
        public var legend: QuickSightClientTypes.LegendOptions?
        /// The label options of the row that is displayed in a heat map.
        public var rowLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The sort configuration of a heat map.
        public var sortConfiguration: QuickSightClientTypes.HeatMapSortConfiguration?
        /// The tooltip display setup of the visual.
        public var tooltip: QuickSightClientTypes.TooltipOptions?

        public init (
            colorScale: QuickSightClientTypes.ColorScale? = nil,
            columnLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            dataLabels: QuickSightClientTypes.DataLabelOptions? = nil,
            fieldWells: QuickSightClientTypes.HeatMapFieldWells? = nil,
            legend: QuickSightClientTypes.LegendOptions? = nil,
            rowLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            sortConfiguration: QuickSightClientTypes.HeatMapSortConfiguration? = nil,
            tooltip: QuickSightClientTypes.TooltipOptions? = nil
        )
        {
            self.colorScale = colorScale
            self.columnLabelOptions = columnLabelOptions
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.legend = legend
            self.rowLabelOptions = rowLabelOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
        }
    }

}

extension QuickSightClientTypes.HeatMapFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case heatMapAggregatedFieldWells = "HeatMapAggregatedFieldWells"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let heatMapAggregatedFieldWells = self.heatMapAggregatedFieldWells {
            try encodeContainer.encode(heatMapAggregatedFieldWells, forKey: .heatMapAggregatedFieldWells)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let heatMapAggregatedFieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.HeatMapAggregatedFieldWells.self, forKey: .heatMapAggregatedFieldWells)
        heatMapAggregatedFieldWells = heatMapAggregatedFieldWellsDecoded
    }
}

extension QuickSightClientTypes {
    /// The field well configuration of a heat map. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct HeatMapFieldWells: Swift.Equatable {
        /// The aggregated field wells of a heat map.
        public var heatMapAggregatedFieldWells: QuickSightClientTypes.HeatMapAggregatedFieldWells?

        public init (
            heatMapAggregatedFieldWells: QuickSightClientTypes.HeatMapAggregatedFieldWells? = nil
        )
        {
            self.heatMapAggregatedFieldWells = heatMapAggregatedFieldWells
        }
    }

}

extension QuickSightClientTypes.HeatMapSortConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case heatMapColumnItemsLimitConfiguration = "HeatMapColumnItemsLimitConfiguration"
        case heatMapColumnSort = "HeatMapColumnSort"
        case heatMapRowItemsLimitConfiguration = "HeatMapRowItemsLimitConfiguration"
        case heatMapRowSort = "HeatMapRowSort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let heatMapColumnItemsLimitConfiguration = self.heatMapColumnItemsLimitConfiguration {
            try encodeContainer.encode(heatMapColumnItemsLimitConfiguration, forKey: .heatMapColumnItemsLimitConfiguration)
        }
        if let heatMapColumnSort = heatMapColumnSort {
            var heatMapColumnSortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .heatMapColumnSort)
            for fieldsortoptions0 in heatMapColumnSort {
                try heatMapColumnSortContainer.encode(fieldsortoptions0)
            }
        }
        if let heatMapRowItemsLimitConfiguration = self.heatMapRowItemsLimitConfiguration {
            try encodeContainer.encode(heatMapRowItemsLimitConfiguration, forKey: .heatMapRowItemsLimitConfiguration)
        }
        if let heatMapRowSort = heatMapRowSort {
            var heatMapRowSortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .heatMapRowSort)
            for fieldsortoptions0 in heatMapRowSort {
                try heatMapRowSortContainer.encode(fieldsortoptions0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let heatMapRowSortContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FieldSortOptions?].self, forKey: .heatMapRowSort)
        var heatMapRowSortDecoded0:[QuickSightClientTypes.FieldSortOptions]? = nil
        if let heatMapRowSortContainer = heatMapRowSortContainer {
            heatMapRowSortDecoded0 = [QuickSightClientTypes.FieldSortOptions]()
            for structure0 in heatMapRowSortContainer {
                if let structure0 = structure0 {
                    heatMapRowSortDecoded0?.append(structure0)
                }
            }
        }
        heatMapRowSort = heatMapRowSortDecoded0
        let heatMapColumnSortContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FieldSortOptions?].self, forKey: .heatMapColumnSort)
        var heatMapColumnSortDecoded0:[QuickSightClientTypes.FieldSortOptions]? = nil
        if let heatMapColumnSortContainer = heatMapColumnSortContainer {
            heatMapColumnSortDecoded0 = [QuickSightClientTypes.FieldSortOptions]()
            for structure0 in heatMapColumnSortContainer {
                if let structure0 = structure0 {
                    heatMapColumnSortDecoded0?.append(structure0)
                }
            }
        }
        heatMapColumnSort = heatMapColumnSortDecoded0
        let heatMapRowItemsLimitConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ItemsLimitConfiguration.self, forKey: .heatMapRowItemsLimitConfiguration)
        heatMapRowItemsLimitConfiguration = heatMapRowItemsLimitConfigurationDecoded
        let heatMapColumnItemsLimitConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ItemsLimitConfiguration.self, forKey: .heatMapColumnItemsLimitConfiguration)
        heatMapColumnItemsLimitConfiguration = heatMapColumnItemsLimitConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The sort configuration of a heat map.
    public struct HeatMapSortConfiguration: Swift.Equatable {
        /// The limit on the number of columns that are displayed in a heat map.
        public var heatMapColumnItemsLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The column sort configuration for heat map for columns that aren't a part of a field well.
        public var heatMapColumnSort: [QuickSightClientTypes.FieldSortOptions]?
        /// The limit on the number of rows that are displayed in a heat map.
        public var heatMapRowItemsLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The field sort configuration of the rows fields.
        public var heatMapRowSort: [QuickSightClientTypes.FieldSortOptions]?

        public init (
            heatMapColumnItemsLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            heatMapColumnSort: [QuickSightClientTypes.FieldSortOptions]? = nil,
            heatMapRowItemsLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            heatMapRowSort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.heatMapColumnItemsLimitConfiguration = heatMapColumnItemsLimitConfiguration
            self.heatMapColumnSort = heatMapColumnSort
            self.heatMapRowItemsLimitConfiguration = heatMapRowItemsLimitConfiguration
            self.heatMapRowSort = heatMapRowSort
        }
    }

}

extension QuickSightClientTypes.HeatMapVisual: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case chartConfiguration = "ChartConfiguration"
        case columnHierarchies = "ColumnHierarchies"
        case subtitle = "Subtitle"
        case title = "Title"
        case visualId = "VisualId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for visualcustomaction0 in actions {
                try actionsContainer.encode(visualcustomaction0)
            }
        }
        if let chartConfiguration = self.chartConfiguration {
            try encodeContainer.encode(chartConfiguration, forKey: .chartConfiguration)
        }
        if let columnHierarchies = columnHierarchies {
            var columnHierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnHierarchies)
            for columnhierarchy0 in columnHierarchies {
                try columnHierarchiesContainer.encode(columnhierarchy0)
            }
        }
        if let subtitle = self.subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let visualId = self.visualId {
            try encodeContainer.encode(visualId, forKey: .visualId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visualIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visualId)
        visualId = visualIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualTitleLabelOptions.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualSubtitleLabelOptions.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let chartConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.HeatMapConfiguration.self, forKey: .chartConfiguration)
        chartConfiguration = chartConfigurationDecoded
        let columnHierarchiesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnHierarchy?].self, forKey: .columnHierarchies)
        var columnHierarchiesDecoded0:[QuickSightClientTypes.ColumnHierarchy]? = nil
        if let columnHierarchiesContainer = columnHierarchiesContainer {
            columnHierarchiesDecoded0 = [QuickSightClientTypes.ColumnHierarchy]()
            for structure0 in columnHierarchiesContainer {
                if let structure0 = structure0 {
                    columnHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        columnHierarchies = columnHierarchiesDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.VisualCustomAction?].self, forKey: .actions)
        var actionsDecoded0:[QuickSightClientTypes.VisualCustomAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [QuickSightClientTypes.VisualCustomAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A heat map. For more information, see [Using heat maps](https://docs.aws.amazon.com/quicksight/latest/user/heat-map.html) in the Amazon QuickSight User Guide.
    public struct HeatMapVisual: Swift.Equatable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration of a heat map.
        public var chartConfiguration: QuickSightClientTypes.HeatMapConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init (
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.HeatMapConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }

}

extension QuickSightClientTypes.HistogramAggregatedFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for measurefield0 in values {
                try valuesContainer.encode(measurefield0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .values)
        var valuesDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension QuickSightClientTypes {
    /// The field well configuration of a histogram.
    public struct HistogramAggregatedFieldWells: Swift.Equatable {
        /// The value field wells of a histogram. Values are aggregated by COUNT or DISTINCT_COUNT.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init (
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.values = values
        }
    }

}

extension QuickSightClientTypes.HistogramBinOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case binCount = "BinCount"
        case binWidth = "BinWidth"
        case selectedBinType = "SelectedBinType"
        case startValue = "StartValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let binCount = self.binCount {
            try encodeContainer.encode(binCount, forKey: .binCount)
        }
        if let binWidth = self.binWidth {
            try encodeContainer.encode(binWidth, forKey: .binWidth)
        }
        if let selectedBinType = self.selectedBinType {
            try encodeContainer.encode(selectedBinType.rawValue, forKey: .selectedBinType)
        }
        if let startValue = self.startValue {
            try encodeContainer.encode(startValue, forKey: .startValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectedBinTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.HistogramBinType.self, forKey: .selectedBinType)
        selectedBinType = selectedBinTypeDecoded
        let binCountDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.BinCountOptions.self, forKey: .binCount)
        binCount = binCountDecoded
        let binWidthDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.BinWidthOptions.self, forKey: .binWidth)
        binWidth = binWidthDecoded
        let startValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .startValue)
        startValue = startValueDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the presentation of histogram bins.
    public struct HistogramBinOptions: Swift.Equatable {
        /// The options that determine the bin count of a histogram.
        public var binCount: QuickSightClientTypes.BinCountOptions?
        /// The options that determine the bin width of a histogram.
        public var binWidth: QuickSightClientTypes.BinWidthOptions?
        /// The options that determine the selected bin type.
        public var selectedBinType: QuickSightClientTypes.HistogramBinType?
        /// The options that determine the bin start value.
        public var startValue: Swift.Double?

        public init (
            binCount: QuickSightClientTypes.BinCountOptions? = nil,
            binWidth: QuickSightClientTypes.BinWidthOptions? = nil,
            selectedBinType: QuickSightClientTypes.HistogramBinType? = nil,
            startValue: Swift.Double? = nil
        )
        {
            self.binCount = binCount
            self.binWidth = binWidth
            self.selectedBinType = selectedBinType
            self.startValue = startValue
        }
    }

}

extension QuickSightClientTypes {
    public enum HistogramBinType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case binCount
        case binWidth
        case sdkUnknown(Swift.String)

        public static var allCases: [HistogramBinType] {
            return [
                .binCount,
                .binWidth,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .binCount: return "BIN_COUNT"
            case .binWidth: return "BIN_WIDTH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HistogramBinType(rawValue: rawValue) ?? HistogramBinType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.HistogramConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case binOptions = "BinOptions"
        case dataLabels = "DataLabels"
        case fieldWells = "FieldWells"
        case tooltip = "Tooltip"
        case visualPalette = "VisualPalette"
        case xAxisDisplayOptions = "XAxisDisplayOptions"
        case xAxisLabelOptions = "XAxisLabelOptions"
        case yAxisDisplayOptions = "YAxisDisplayOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let binOptions = self.binOptions {
            try encodeContainer.encode(binOptions, forKey: .binOptions)
        }
        if let dataLabels = self.dataLabels {
            try encodeContainer.encode(dataLabels, forKey: .dataLabels)
        }
        if let fieldWells = self.fieldWells {
            try encodeContainer.encode(fieldWells, forKey: .fieldWells)
        }
        if let tooltip = self.tooltip {
            try encodeContainer.encode(tooltip, forKey: .tooltip)
        }
        if let visualPalette = self.visualPalette {
            try encodeContainer.encode(visualPalette, forKey: .visualPalette)
        }
        if let xAxisDisplayOptions = self.xAxisDisplayOptions {
            try encodeContainer.encode(xAxisDisplayOptions, forKey: .xAxisDisplayOptions)
        }
        if let xAxisLabelOptions = self.xAxisLabelOptions {
            try encodeContainer.encode(xAxisLabelOptions, forKey: .xAxisLabelOptions)
        }
        if let yAxisDisplayOptions = self.yAxisDisplayOptions {
            try encodeContainer.encode(yAxisDisplayOptions, forKey: .yAxisDisplayOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.HistogramFieldWells.self, forKey: .fieldWells)
        fieldWells = fieldWellsDecoded
        let xAxisDisplayOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisDisplayOptions.self, forKey: .xAxisDisplayOptions)
        xAxisDisplayOptions = xAxisDisplayOptionsDecoded
        let xAxisLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .xAxisLabelOptions)
        xAxisLabelOptions = xAxisLabelOptionsDecoded
        let yAxisDisplayOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisDisplayOptions.self, forKey: .yAxisDisplayOptions)
        yAxisDisplayOptions = yAxisDisplayOptionsDecoded
        let binOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.HistogramBinOptions.self, forKey: .binOptions)
        binOptions = binOptionsDecoded
        let dataLabelsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataLabelOptions.self, forKey: .dataLabels)
        dataLabels = dataLabelsDecoded
        let tooltipDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TooltipOptions.self, forKey: .tooltip)
        tooltip = tooltipDecoded
        let visualPaletteDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualPalette.self, forKey: .visualPalette)
        visualPalette = visualPaletteDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration for a HistogramVisual.
    public struct HistogramConfiguration: Swift.Equatable {
        /// The options that determine the presentation of histogram bins.
        public var binOptions: QuickSightClientTypes.HistogramBinOptions?
        /// The data label configuration of a histogram.
        public var dataLabels: QuickSightClientTypes.DataLabelOptions?
        /// The field well configuration of a histogram.
        public var fieldWells: QuickSightClientTypes.HistogramFieldWells?
        /// The tooltip configuration of a histogram.
        public var tooltip: QuickSightClientTypes.TooltipOptions?
        /// The visual palette configuration of a histogram.
        public var visualPalette: QuickSightClientTypes.VisualPalette?
        /// The options that determine the presentation of the x-axis.
        public var xAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions?
        /// The options that determine the presentation of the x-axis label.
        public var xAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The options that determine the presentation of the y-axis.
        public var yAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions?

        public init (
            binOptions: QuickSightClientTypes.HistogramBinOptions? = nil,
            dataLabels: QuickSightClientTypes.DataLabelOptions? = nil,
            fieldWells: QuickSightClientTypes.HistogramFieldWells? = nil,
            tooltip: QuickSightClientTypes.TooltipOptions? = nil,
            visualPalette: QuickSightClientTypes.VisualPalette? = nil,
            xAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions? = nil,
            xAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            yAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions? = nil
        )
        {
            self.binOptions = binOptions
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.tooltip = tooltip
            self.visualPalette = visualPalette
            self.xAxisDisplayOptions = xAxisDisplayOptions
            self.xAxisLabelOptions = xAxisLabelOptions
            self.yAxisDisplayOptions = yAxisDisplayOptions
        }
    }

}

extension QuickSightClientTypes.HistogramFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case histogramAggregatedFieldWells = "HistogramAggregatedFieldWells"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let histogramAggregatedFieldWells = self.histogramAggregatedFieldWells {
            try encodeContainer.encode(histogramAggregatedFieldWells, forKey: .histogramAggregatedFieldWells)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let histogramAggregatedFieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.HistogramAggregatedFieldWells.self, forKey: .histogramAggregatedFieldWells)
        histogramAggregatedFieldWells = histogramAggregatedFieldWellsDecoded
    }
}

extension QuickSightClientTypes {
    /// The field well configuration of a histogram.
    public struct HistogramFieldWells: Swift.Equatable {
        /// The field well configuration of a histogram.
        public var histogramAggregatedFieldWells: QuickSightClientTypes.HistogramAggregatedFieldWells?

        public init (
            histogramAggregatedFieldWells: QuickSightClientTypes.HistogramAggregatedFieldWells? = nil
        )
        {
            self.histogramAggregatedFieldWells = histogramAggregatedFieldWells
        }
    }

}

extension QuickSightClientTypes.HistogramVisual: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case chartConfiguration = "ChartConfiguration"
        case subtitle = "Subtitle"
        case title = "Title"
        case visualId = "VisualId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for visualcustomaction0 in actions {
                try actionsContainer.encode(visualcustomaction0)
            }
        }
        if let chartConfiguration = self.chartConfiguration {
            try encodeContainer.encode(chartConfiguration, forKey: .chartConfiguration)
        }
        if let subtitle = self.subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let visualId = self.visualId {
            try encodeContainer.encode(visualId, forKey: .visualId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visualIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visualId)
        visualId = visualIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualTitleLabelOptions.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualSubtitleLabelOptions.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let chartConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.HistogramConfiguration.self, forKey: .chartConfiguration)
        chartConfiguration = chartConfigurationDecoded
        let actionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.VisualCustomAction?].self, forKey: .actions)
        var actionsDecoded0:[QuickSightClientTypes.VisualCustomAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [QuickSightClientTypes.VisualCustomAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A histogram. For more information, see [Using histograms](https://docs.aws.amazon.com/quicksight/latest/user/histogram-charts.html) in the Amazon QuickSight User Guide.
    public struct HistogramVisual: Swift.Equatable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration for a HistogramVisual.
        public var chartConfiguration: QuickSightClientTypes.HistogramConfiguration?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init (
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.HistogramConfiguration? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }

}

extension QuickSightClientTypes {
    public enum HorizontalTextAlignment: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case center
        case `left`
        case `right`
        case sdkUnknown(Swift.String)

        public static var allCases: [HorizontalTextAlignment] {
            return [
                .auto,
                .center,
                .left,
                .right,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .center: return "CENTER"
            case .left: return "LEFT"
            case .right: return "RIGHT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HorizontalTextAlignment(rawValue: rawValue) ?? HorizontalTextAlignment.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.IAMPolicyAssignment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentId = "AssignmentId"
        case assignmentName = "AssignmentName"
        case assignmentStatus = "AssignmentStatus"
        case awsAccountId = "AwsAccountId"
        case identities = "Identities"
        case policyArn = "PolicyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentId = self.assignmentId {
            try encodeContainer.encode(assignmentId, forKey: .assignmentId)
        }
        if let assignmentName = self.assignmentName {
            try encodeContainer.encode(assignmentName, forKey: .assignmentName)
        }
        if let assignmentStatus = self.assignmentStatus {
            try encodeContainer.encode(assignmentStatus.rawValue, forKey: .assignmentStatus)
        }
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let identities = identities {
            var identitiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .identities)
            for (dictKey0, identityMap0) in identities {
                var identityMap0Container = identitiesContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for identityname1 in identityMap0 {
                    try identityMap0Container.encode(identityname1)
                }
            }
        }
        if let policyArn = self.policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let assignmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentId)
        assignmentId = assignmentIdDecoded
        let assignmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentName)
        assignmentName = assignmentNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let identitiesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .identities)
        var identitiesDecoded0: [Swift.String:[Swift.String]]? = nil
        if let identitiesContainer = identitiesContainer {
            identitiesDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, identitynamelist0) in identitiesContainer {
                var identitynamelist0Decoded0: [Swift.String]? = nil
                if let identitynamelist0 = identitynamelist0 {
                    identitynamelist0Decoded0 = [Swift.String]()
                    for string1 in identitynamelist0 {
                        if let string1 = string1 {
                            identitynamelist0Decoded0?.append(string1)
                        }
                    }
                }
                identitiesDecoded0?[key0] = identitynamelist0Decoded0
            }
        }
        identities = identitiesDecoded0
        let assignmentStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AssignmentStatus.self, forKey: .assignmentStatus)
        assignmentStatus = assignmentStatusDecoded
    }
}

extension QuickSightClientTypes {
    /// An Identity and Access Management (IAM) policy assignment.
    public struct IAMPolicyAssignment: Swift.Equatable {
        /// Assignment ID.
        public var assignmentId: Swift.String?
        /// Assignment name.
        public var assignmentName: Swift.String?
        /// Assignment status.
        public var assignmentStatus: QuickSightClientTypes.AssignmentStatus?
        /// The Amazon Web Services account ID.
        public var awsAccountId: Swift.String?
        /// Identities.
        public var identities: [Swift.String:[Swift.String]]?
        /// The Amazon Resource Name (ARN) for the IAM policy.
        public var policyArn: Swift.String?

        public init (
            assignmentId: Swift.String? = nil,
            assignmentName: Swift.String? = nil,
            assignmentStatus: QuickSightClientTypes.AssignmentStatus? = nil,
            awsAccountId: Swift.String? = nil,
            identities: [Swift.String:[Swift.String]]? = nil,
            policyArn: Swift.String? = nil
        )
        {
            self.assignmentId = assignmentId
            self.assignmentName = assignmentName
            self.assignmentStatus = assignmentStatus
            self.awsAccountId = awsAccountId
            self.identities = identities
            self.policyArn = policyArn
        }
    }

}

extension QuickSightClientTypes.IAMPolicyAssignmentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentName = "AssignmentName"
        case assignmentStatus = "AssignmentStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentName = self.assignmentName {
            try encodeContainer.encode(assignmentName, forKey: .assignmentName)
        }
        if let assignmentStatus = self.assignmentStatus {
            try encodeContainer.encode(assignmentStatus.rawValue, forKey: .assignmentStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentName)
        assignmentName = assignmentNameDecoded
        let assignmentStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AssignmentStatus.self, forKey: .assignmentStatus)
        assignmentStatus = assignmentStatusDecoded
    }
}

extension QuickSightClientTypes {
    /// IAM policy assignment summary.
    public struct IAMPolicyAssignmentSummary: Swift.Equatable {
        /// Assignment name.
        public var assignmentName: Swift.String?
        /// Assignment status.
        public var assignmentStatus: QuickSightClientTypes.AssignmentStatus?

        public init (
            assignmentName: Swift.String? = nil,
            assignmentStatus: QuickSightClientTypes.AssignmentStatus? = nil
        )
        {
            self.assignmentName = assignmentName
            self.assignmentStatus = assignmentStatus
        }
    }

}

extension QuickSightClientTypes {
    public enum Icon: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arrowDown
        case arrowDownLeft
        case arrowDownRight
        case arrowLeft
        case arrowRight
        case arrowUp
        case arrowUpLeft
        case arrowUpRight
        case caretDown
        case caretUp
        case checkmark
        case circle
        case faceDown
        case faceFlat
        case faceUp
        case flag
        case minus
        case oneBar
        case plus
        case square
        case threeBar
        case thumbsDown
        case thumbsUp
        case triangle
        case twoBar
        case x
        case sdkUnknown(Swift.String)

        public static var allCases: [Icon] {
            return [
                .arrowDown,
                .arrowDownLeft,
                .arrowDownRight,
                .arrowLeft,
                .arrowRight,
                .arrowUp,
                .arrowUpLeft,
                .arrowUpRight,
                .caretDown,
                .caretUp,
                .checkmark,
                .circle,
                .faceDown,
                .faceFlat,
                .faceUp,
                .flag,
                .minus,
                .oneBar,
                .plus,
                .square,
                .threeBar,
                .thumbsDown,
                .thumbsUp,
                .triangle,
                .twoBar,
                .x,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arrowDown: return "ARROW_DOWN"
            case .arrowDownLeft: return "ARROW_DOWN_LEFT"
            case .arrowDownRight: return "ARROW_DOWN_RIGHT"
            case .arrowLeft: return "ARROW_LEFT"
            case .arrowRight: return "ARROW_RIGHT"
            case .arrowUp: return "ARROW_UP"
            case .arrowUpLeft: return "ARROW_UP_LEFT"
            case .arrowUpRight: return "ARROW_UP_RIGHT"
            case .caretDown: return "CARET_DOWN"
            case .caretUp: return "CARET_UP"
            case .checkmark: return "CHECKMARK"
            case .circle: return "CIRCLE"
            case .faceDown: return "FACE_DOWN"
            case .faceFlat: return "FACE_FLAT"
            case .faceUp: return "FACE_UP"
            case .flag: return "FLAG"
            case .minus: return "MINUS"
            case .oneBar: return "ONE_BAR"
            case .plus: return "PLUS"
            case .square: return "SQUARE"
            case .threeBar: return "THREE_BAR"
            case .thumbsDown: return "THUMBS_DOWN"
            case .thumbsUp: return "THUMBS_UP"
            case .triangle: return "TRIANGLE"
            case .twoBar: return "TWO_BAR"
            case .x: return "X"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Icon(rawValue: rawValue) ?? Icon.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum IdentityStore: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case quicksight
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityStore] {
            return [
                .quicksight,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .quicksight: return "QUICKSIGHT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdentityStore(rawValue: rawValue) ?? IdentityStore.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum IdentityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iam
        case quicksight
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityType] {
            return [
                .iam,
                .quicksight,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iam: return "IAM"
            case .quicksight: return "QUICKSIGHT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdentityType(rawValue: rawValue) ?? IdentityType.sdkUnknown(rawValue)
        }
    }
}

extension IdentityTypeNotSupportedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: IdentityTypeNotSupportedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The identity type specified isn't supported. Supported identity types include IAM and QUICKSIGHT.
public struct IdentityTypeNotSupportedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct IdentityTypeNotSupportedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension IdentityTypeNotSupportedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.Ingestion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case errorInfo = "ErrorInfo"
        case ingestionId = "IngestionId"
        case ingestionSizeInBytes = "IngestionSizeInBytes"
        case ingestionStatus = "IngestionStatus"
        case ingestionTimeInSeconds = "IngestionTimeInSeconds"
        case queueInfo = "QueueInfo"
        case requestSource = "RequestSource"
        case requestType = "RequestType"
        case rowInfo = "RowInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let errorInfo = self.errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
        if let ingestionId = self.ingestionId {
            try encodeContainer.encode(ingestionId, forKey: .ingestionId)
        }
        if let ingestionSizeInBytes = self.ingestionSizeInBytes {
            try encodeContainer.encode(ingestionSizeInBytes, forKey: .ingestionSizeInBytes)
        }
        if let ingestionStatus = self.ingestionStatus {
            try encodeContainer.encode(ingestionStatus.rawValue, forKey: .ingestionStatus)
        }
        if let ingestionTimeInSeconds = self.ingestionTimeInSeconds {
            try encodeContainer.encode(ingestionTimeInSeconds, forKey: .ingestionTimeInSeconds)
        }
        if let queueInfo = self.queueInfo {
            try encodeContainer.encode(queueInfo, forKey: .queueInfo)
        }
        if let requestSource = self.requestSource {
            try encodeContainer.encode(requestSource.rawValue, forKey: .requestSource)
        }
        if let requestType = self.requestType {
            try encodeContainer.encode(requestType.rawValue, forKey: .requestType)
        }
        if let rowInfo = self.rowInfo {
            try encodeContainer.encode(rowInfo, forKey: .rowInfo)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ingestionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ingestionId)
        ingestionId = ingestionIdDecoded
        let ingestionStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IngestionStatus.self, forKey: .ingestionStatus)
        ingestionStatus = ingestionStatusDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let rowInfoDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RowInfo.self, forKey: .rowInfo)
        rowInfo = rowInfoDecoded
        let queueInfoDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.QueueInfo.self, forKey: .queueInfo)
        queueInfo = queueInfoDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let ingestionTimeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ingestionTimeInSeconds)
        ingestionTimeInSeconds = ingestionTimeInSecondsDecoded
        let ingestionSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ingestionSizeInBytes)
        ingestionSizeInBytes = ingestionSizeInBytesDecoded
        let requestSourceDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IngestionRequestSource.self, forKey: .requestSource)
        requestSource = requestSourceDecoded
        let requestTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IngestionRequestType.self, forKey: .requestType)
        requestType = requestTypeDecoded
    }
}

extension QuickSightClientTypes {
    /// Information about the SPICE ingestion for a dataset.
    public struct Ingestion: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        /// This member is required.
        public var arn: Swift.String?
        /// The time that this ingestion started.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// Error information for this ingestion.
        public var errorInfo: QuickSightClientTypes.ErrorInfo?
        /// Ingestion ID.
        public var ingestionId: Swift.String?
        /// The size of the data ingested, in bytes.
        public var ingestionSizeInBytes: Swift.Int?
        /// Ingestion status.
        /// This member is required.
        public var ingestionStatus: QuickSightClientTypes.IngestionStatus?
        /// The time that this ingestion took, measured in seconds.
        public var ingestionTimeInSeconds: Swift.Int?
        /// Information about a queued dataset SPICE ingestion.
        public var queueInfo: QuickSightClientTypes.QueueInfo?
        /// Event source for this ingestion.
        public var requestSource: QuickSightClientTypes.IngestionRequestSource?
        /// Type of this ingestion.
        public var requestType: QuickSightClientTypes.IngestionRequestType?
        /// Information about rows for a data set SPICE ingestion.
        public var rowInfo: QuickSightClientTypes.RowInfo?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            errorInfo: QuickSightClientTypes.ErrorInfo? = nil,
            ingestionId: Swift.String? = nil,
            ingestionSizeInBytes: Swift.Int? = nil,
            ingestionStatus: QuickSightClientTypes.IngestionStatus? = nil,
            ingestionTimeInSeconds: Swift.Int? = nil,
            queueInfo: QuickSightClientTypes.QueueInfo? = nil,
            requestSource: QuickSightClientTypes.IngestionRequestSource? = nil,
            requestType: QuickSightClientTypes.IngestionRequestType? = nil,
            rowInfo: QuickSightClientTypes.RowInfo? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.errorInfo = errorInfo
            self.ingestionId = ingestionId
            self.ingestionSizeInBytes = ingestionSizeInBytes
            self.ingestionStatus = ingestionStatus
            self.ingestionTimeInSeconds = ingestionTimeInSeconds
            self.queueInfo = queueInfo
            self.requestSource = requestSource
            self.requestType = requestType
            self.rowInfo = rowInfo
        }
    }

}

extension QuickSightClientTypes {
    public enum IngestionErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountCapacityLimitExceeded
        case connectionFailure
        case cursorNotEnabled
        case customerError
        case dataSetDeleted
        case dataSetNotSpice
        case dataSetSizeLimitExceeded
        case dataSourceAuthFailed
        case dataSourceConnectionFailed
        case dataSourceNotFound
        case dataToleranceException
        case elasticsearchCursorNotEnabled
        case failureToAssumeRole
        case failureToProcessJsonFile
        case iamRoleNotAvailable
        case ingestionCanceled
        case ingestionSuperseded
        case internalServiceError
        case invalidDataprepSyntax
        case invalidDataSourceConfig
        case invalidDateFormat
        case iotDataSetFileEmpty
        case iotFileNotFound
        case oauthTokenFailure
        case passwordAuthenticationFailure
        case permissionDenied
        case permissionNotFound
        case queryTimeout
        case refreshSuppressedByEdit
        case rowSizeLimitExceeded
        case s3FileInaccessible
        case s3ManifestError
        case s3UploadedFileDeleted
        case sourceApiLimitExceededFailure
        case sourceResourceLimitExceeded
        case spiceTableNotFound
        case sqlException
        case sqlInvalidParameterValue
        case sqlNumericOverflow
        case sqlSchemaMismatchError
        case sqlTableNotFound
        case sslCertificateValidationFailure
        case unresolvableHost
        case unroutableHost
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionErrorType] {
            return [
                .accountCapacityLimitExceeded,
                .connectionFailure,
                .cursorNotEnabled,
                .customerError,
                .dataSetDeleted,
                .dataSetNotSpice,
                .dataSetSizeLimitExceeded,
                .dataSourceAuthFailed,
                .dataSourceConnectionFailed,
                .dataSourceNotFound,
                .dataToleranceException,
                .elasticsearchCursorNotEnabled,
                .failureToAssumeRole,
                .failureToProcessJsonFile,
                .iamRoleNotAvailable,
                .ingestionCanceled,
                .ingestionSuperseded,
                .internalServiceError,
                .invalidDataprepSyntax,
                .invalidDataSourceConfig,
                .invalidDateFormat,
                .iotDataSetFileEmpty,
                .iotFileNotFound,
                .oauthTokenFailure,
                .passwordAuthenticationFailure,
                .permissionDenied,
                .permissionNotFound,
                .queryTimeout,
                .refreshSuppressedByEdit,
                .rowSizeLimitExceeded,
                .s3FileInaccessible,
                .s3ManifestError,
                .s3UploadedFileDeleted,
                .sourceApiLimitExceededFailure,
                .sourceResourceLimitExceeded,
                .spiceTableNotFound,
                .sqlException,
                .sqlInvalidParameterValue,
                .sqlNumericOverflow,
                .sqlSchemaMismatchError,
                .sqlTableNotFound,
                .sslCertificateValidationFailure,
                .unresolvableHost,
                .unroutableHost,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountCapacityLimitExceeded: return "ACCOUNT_CAPACITY_LIMIT_EXCEEDED"
            case .connectionFailure: return "CONNECTION_FAILURE"
            case .cursorNotEnabled: return "CURSOR_NOT_ENABLED"
            case .customerError: return "CUSTOMER_ERROR"
            case .dataSetDeleted: return "DATA_SET_DELETED"
            case .dataSetNotSpice: return "DATA_SET_NOT_SPICE"
            case .dataSetSizeLimitExceeded: return "DATA_SET_SIZE_LIMIT_EXCEEDED"
            case .dataSourceAuthFailed: return "DATA_SOURCE_AUTH_FAILED"
            case .dataSourceConnectionFailed: return "DATA_SOURCE_CONNECTION_FAILED"
            case .dataSourceNotFound: return "DATA_SOURCE_NOT_FOUND"
            case .dataToleranceException: return "DATA_TOLERANCE_EXCEPTION"
            case .elasticsearchCursorNotEnabled: return "ELASTICSEARCH_CURSOR_NOT_ENABLED"
            case .failureToAssumeRole: return "FAILURE_TO_ASSUME_ROLE"
            case .failureToProcessJsonFile: return "FAILURE_TO_PROCESS_JSON_FILE"
            case .iamRoleNotAvailable: return "IAM_ROLE_NOT_AVAILABLE"
            case .ingestionCanceled: return "INGESTION_CANCELED"
            case .ingestionSuperseded: return "INGESTION_SUPERSEDED"
            case .internalServiceError: return "INTERNAL_SERVICE_ERROR"
            case .invalidDataprepSyntax: return "INVALID_DATAPREP_SYNTAX"
            case .invalidDataSourceConfig: return "INVALID_DATA_SOURCE_CONFIG"
            case .invalidDateFormat: return "INVALID_DATE_FORMAT"
            case .iotDataSetFileEmpty: return "IOT_DATA_SET_FILE_EMPTY"
            case .iotFileNotFound: return "IOT_FILE_NOT_FOUND"
            case .oauthTokenFailure: return "OAUTH_TOKEN_FAILURE"
            case .passwordAuthenticationFailure: return "PASSWORD_AUTHENTICATION_FAILURE"
            case .permissionDenied: return "PERMISSION_DENIED"
            case .permissionNotFound: return "PERMISSION_NOT_FOUND"
            case .queryTimeout: return "QUERY_TIMEOUT"
            case .refreshSuppressedByEdit: return "REFRESH_SUPPRESSED_BY_EDIT"
            case .rowSizeLimitExceeded: return "ROW_SIZE_LIMIT_EXCEEDED"
            case .s3FileInaccessible: return "S3_FILE_INACCESSIBLE"
            case .s3ManifestError: return "S3_MANIFEST_ERROR"
            case .s3UploadedFileDeleted: return "S3_UPLOADED_FILE_DELETED"
            case .sourceApiLimitExceededFailure: return "SOURCE_API_LIMIT_EXCEEDED_FAILURE"
            case .sourceResourceLimitExceeded: return "SOURCE_RESOURCE_LIMIT_EXCEEDED"
            case .spiceTableNotFound: return "SPICE_TABLE_NOT_FOUND"
            case .sqlException: return "SQL_EXCEPTION"
            case .sqlInvalidParameterValue: return "SQL_INVALID_PARAMETER_VALUE"
            case .sqlNumericOverflow: return "SQL_NUMERIC_OVERFLOW"
            case .sqlSchemaMismatchError: return "SQL_SCHEMA_MISMATCH_ERROR"
            case .sqlTableNotFound: return "SQL_TABLE_NOT_FOUND"
            case .sslCertificateValidationFailure: return "SSL_CERTIFICATE_VALIDATION_FAILURE"
            case .unresolvableHost: return "UNRESOLVABLE_HOST"
            case .unroutableHost: return "UNROUTABLE_HOST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionErrorType(rawValue: rawValue) ?? IngestionErrorType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum IngestionRequestSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case manual
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionRequestSource] {
            return [
                .manual,
                .scheduled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .manual: return "MANUAL"
            case .scheduled: return "SCHEDULED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionRequestSource(rawValue: rawValue) ?? IngestionRequestSource.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    /// This defines the type of ingestion request. This is returned as part of create ingestion response.
    public enum IngestionRequestType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case edit
        case fullRefresh
        case incrementalRefresh
        case initialIngestion
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionRequestType] {
            return [
                .edit,
                .fullRefresh,
                .incrementalRefresh,
                .initialIngestion,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .edit: return "EDIT"
            case .fullRefresh: return "FULL_REFRESH"
            case .incrementalRefresh: return "INCREMENTAL_REFRESH"
            case .initialIngestion: return "INITIAL_INGESTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionRequestType(rawValue: rawValue) ?? IngestionRequestType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum IngestionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case failed
        case initialized
        case queued
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionStatus] {
            return [
                .cancelled,
                .completed,
                .failed,
                .initialized,
                .queued,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .initialized: return "INITIALIZED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionStatus(rawValue: rawValue) ?? IngestionStatus.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    /// This defines the type of ingestion user wants to trigger. This is part of create ingestion request.
    public enum IngestionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullRefresh
        case incrementalRefresh
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionType] {
            return [
                .fullRefresh,
                .incrementalRefresh,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullRefresh: return "FULL_REFRESH"
            case .incrementalRefresh: return "INCREMENTAL_REFRESH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionType(rawValue: rawValue) ?? IngestionType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.InputColumn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.InputColumnDataType.self, forKey: .type)
        type = typeDecoded
    }
}

extension QuickSightClientTypes {
    /// Metadata for a column that is used as the input of a transform operation.
    public struct InputColumn: Swift.Equatable {
        /// The name of this column in the underlying data source.
        /// This member is required.
        public var name: Swift.String?
        /// The data type of the column.
        /// This member is required.
        public var type: QuickSightClientTypes.InputColumnDataType?

        public init (
            name: Swift.String? = nil,
            type: QuickSightClientTypes.InputColumnDataType? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension QuickSightClientTypes {
    public enum InputColumnDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bit
        case boolean
        case datetime
        case decimal
        case integer
        case json
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [InputColumnDataType] {
            return [
                .bit,
                .boolean,
                .datetime,
                .decimal,
                .integer,
                .json,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bit: return "BIT"
            case .boolean: return "BOOLEAN"
            case .datetime: return "DATETIME"
            case .decimal: return "DECIMAL"
            case .integer: return "INTEGER"
            case .json: return "JSON"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InputColumnDataType(rawValue: rawValue) ?? InputColumnDataType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.InsightConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computations = "Computations"
        case customNarrative = "CustomNarrative"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computations = computations {
            var computationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .computations)
            for computation0 in computations {
                try computationsContainer.encode(computation0)
            }
        }
        if let customNarrative = self.customNarrative {
            try encodeContainer.encode(customNarrative, forKey: .customNarrative)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computationsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Computation?].self, forKey: .computations)
        var computationsDecoded0:[QuickSightClientTypes.Computation]? = nil
        if let computationsContainer = computationsContainer {
            computationsDecoded0 = [QuickSightClientTypes.Computation]()
            for structure0 in computationsContainer {
                if let structure0 = structure0 {
                    computationsDecoded0?.append(structure0)
                }
            }
        }
        computations = computationsDecoded0
        let customNarrativeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CustomNarrativeOptions.self, forKey: .customNarrative)
        customNarrative = customNarrativeDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of an insight visual.
    public struct InsightConfiguration: Swift.Equatable {
        /// The computations configurations of the insight visual
        public var computations: [QuickSightClientTypes.Computation]?
        /// The custom narrative of the insight visual.
        public var customNarrative: QuickSightClientTypes.CustomNarrativeOptions?

        public init (
            computations: [QuickSightClientTypes.Computation]? = nil,
            customNarrative: QuickSightClientTypes.CustomNarrativeOptions? = nil
        )
        {
            self.computations = computations
            self.customNarrative = customNarrative
        }
    }

}

extension QuickSightClientTypes.InsightVisual: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case dataSetIdentifier = "DataSetIdentifier"
        case insightConfiguration = "InsightConfiguration"
        case subtitle = "Subtitle"
        case title = "Title"
        case visualId = "VisualId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for visualcustomaction0 in actions {
                try actionsContainer.encode(visualcustomaction0)
            }
        }
        if let dataSetIdentifier = self.dataSetIdentifier {
            try encodeContainer.encode(dataSetIdentifier, forKey: .dataSetIdentifier)
        }
        if let insightConfiguration = self.insightConfiguration {
            try encodeContainer.encode(insightConfiguration, forKey: .insightConfiguration)
        }
        if let subtitle = self.subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let visualId = self.visualId {
            try encodeContainer.encode(visualId, forKey: .visualId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visualIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visualId)
        visualId = visualIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualTitleLabelOptions.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualSubtitleLabelOptions.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let insightConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.InsightConfiguration.self, forKey: .insightConfiguration)
        insightConfiguration = insightConfigurationDecoded
        let actionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.VisualCustomAction?].self, forKey: .actions)
        var actionsDecoded0:[QuickSightClientTypes.VisualCustomAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [QuickSightClientTypes.VisualCustomAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let dataSetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetIdentifier)
        dataSetIdentifier = dataSetIdentifierDecoded
    }
}

extension QuickSightClientTypes {
    /// An insight visual. For more information, see [Working with insights](https://docs.aws.amazon.com/quicksight/latest/user/computational-insights.html) in the Amazon QuickSight User Guide.
    public struct InsightVisual: Swift.Equatable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The dataset that is used in the insight visual.
        /// This member is required.
        public var dataSetIdentifier: Swift.String?
        /// The configuration of an insight visual.
        public var insightConfiguration: QuickSightClientTypes.InsightConfiguration?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init (
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            dataSetIdentifier: Swift.String? = nil,
            insightConfiguration: QuickSightClientTypes.InsightConfiguration? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.dataSetIdentifier = dataSetIdentifier
            self.insightConfiguration = insightConfiguration
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }

}

extension QuickSightClientTypes.IntegerDefaultValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dynamicValue = "DynamicValue"
        case staticValues = "StaticValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dynamicValue = self.dynamicValue {
            try encodeContainer.encode(dynamicValue, forKey: .dynamicValue)
        }
        if let staticValues = staticValues {
            var staticValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .staticValues)
            for sensitivelongobject0 in staticValues {
                try staticValuesContainer.encode(sensitivelongobject0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dynamicValueDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DynamicDefaultValue.self, forKey: .dynamicValue)
        dynamicValue = dynamicValueDecoded
        let staticValuesContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .staticValues)
        var staticValuesDecoded0:[Swift.Int]? = nil
        if let staticValuesContainer = staticValuesContainer {
            staticValuesDecoded0 = [Swift.Int]()
            for long0 in staticValuesContainer {
                if let long0 = long0 {
                    staticValuesDecoded0?.append(long0)
                }
            }
        }
        staticValues = staticValuesDecoded0
    }
}

extension QuickSightClientTypes {
    /// The default values of the IntegerParameterDeclaration.
    public struct IntegerDefaultValues: Swift.Equatable {
        /// The dynamic value of the IntegerDefaultValues. Different defaults are displayed according to users, groups, and values mapping.
        public var dynamicValue: QuickSightClientTypes.DynamicDefaultValue?
        /// The static values of the IntegerDefaultValues.
        public var staticValues: [Swift.Int]?

        public init (
            dynamicValue: QuickSightClientTypes.DynamicDefaultValue? = nil,
            staticValues: [Swift.Int]? = nil
        )
        {
            self.dynamicValue = dynamicValue
            self.staticValues = staticValues
        }
    }

}

extension QuickSightClientTypes.IntegerParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for sensitivelong0 in values {
                try valuesContainer.encode(sensitivelong0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .values)
        var valuesDecoded0:[Swift.Int]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.Int]()
            for long0 in valuesContainer {
                if let long0 = long0 {
                    valuesDecoded0?.append(long0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension QuickSightClientTypes {
    /// An integer parameter.
    public struct IntegerParameter: Swift.Equatable {
        /// The name of the integer parameter.
        /// This member is required.
        public var name: Swift.String?
        /// The values for the integer parameter.
        /// This member is required.
        public var values: [Swift.Int]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.Int]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension QuickSightClientTypes.IntegerParameterDeclaration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValues = "DefaultValues"
        case name = "Name"
        case parameterValueType = "ParameterValueType"
        case valueWhenUnset = "ValueWhenUnset"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValues = self.defaultValues {
            try encodeContainer.encode(defaultValues, forKey: .defaultValues)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameterValueType = self.parameterValueType {
            try encodeContainer.encode(parameterValueType.rawValue, forKey: .parameterValueType)
        }
        if let valueWhenUnset = self.valueWhenUnset {
            try encodeContainer.encode(valueWhenUnset, forKey: .valueWhenUnset)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterValueTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ParameterValueType.self, forKey: .parameterValueType)
        parameterValueType = parameterValueTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let defaultValuesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IntegerDefaultValues.self, forKey: .defaultValues)
        defaultValues = defaultValuesDecoded
        let valueWhenUnsetDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IntegerValueWhenUnsetConfiguration.self, forKey: .valueWhenUnset)
        valueWhenUnset = valueWhenUnsetDecoded
    }
}

extension QuickSightClientTypes {
    /// A parameter declaration for the Integer data type.
    public struct IntegerParameterDeclaration: Swift.Equatable {
        /// The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.
        public var defaultValues: QuickSightClientTypes.IntegerDefaultValues?
        /// The name of the parameter that is being declared.
        /// This member is required.
        public var name: Swift.String?
        /// The value type determines whether the parameter is a single-value or multi-value parameter.
        /// This member is required.
        public var parameterValueType: QuickSightClientTypes.ParameterValueType?
        /// A parameter declaration for the Integer data type.
        public var valueWhenUnset: QuickSightClientTypes.IntegerValueWhenUnsetConfiguration?

        public init (
            defaultValues: QuickSightClientTypes.IntegerDefaultValues? = nil,
            name: Swift.String? = nil,
            parameterValueType: QuickSightClientTypes.ParameterValueType? = nil,
            valueWhenUnset: QuickSightClientTypes.IntegerValueWhenUnsetConfiguration? = nil
        )
        {
            self.defaultValues = defaultValues
            self.name = name
            self.parameterValueType = parameterValueType
            self.valueWhenUnset = valueWhenUnset
        }
    }

}

extension QuickSightClientTypes.IntegerValueWhenUnsetConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customValue = "CustomValue"
        case valueWhenUnsetOption = "ValueWhenUnsetOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customValue = self.customValue {
            try encodeContainer.encode(customValue, forKey: .customValue)
        }
        if let valueWhenUnsetOption = self.valueWhenUnsetOption {
            try encodeContainer.encode(valueWhenUnsetOption.rawValue, forKey: .valueWhenUnsetOption)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueWhenUnsetOptionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ValueWhenUnsetOption.self, forKey: .valueWhenUnsetOption)
        valueWhenUnsetOption = valueWhenUnsetOptionDecoded
        let customValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .customValue)
        customValue = customValueDecoded
    }
}

extension QuickSightClientTypes.IntegerValueWhenUnsetConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IntegerValueWhenUnsetConfiguration(valueWhenUnsetOption: \(Swift.String(describing: valueWhenUnsetOption)), customValue: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {
    /// A parameter declaration for the Integer data type. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct IntegerValueWhenUnsetConfiguration: Swift.Equatable {
        /// A custom value that's used when the value of a parameter isn't set.
        public var customValue: Swift.Int?
        /// The built-in options for default values. The value can be one of the following:
        ///
        /// * RECOMMENDED: The recommended value.
        ///
        /// * NULL: The NULL value.
        public var valueWhenUnsetOption: QuickSightClientTypes.ValueWhenUnsetOption?

        public init (
            customValue: Swift.Int? = nil,
            valueWhenUnsetOption: QuickSightClientTypes.ValueWhenUnsetOption? = nil
        )
        {
            self.customValue = customValue
            self.valueWhenUnsetOption = valueWhenUnsetOption
        }
    }

}

extension InternalFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal failure occurred.
public struct InternalFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The NextToken value isn't valid.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension InvalidParameterValueException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more parameters has a value that isn't valid.
public struct InvalidParameterValueException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct InvalidParameterValueExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension InvalidParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You don't have this feature activated for your account. To fix this issue, contact Amazon Web Services support.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.ItemsLimitConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case itemsLimit = "ItemsLimit"
        case otherCategories = "OtherCategories"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let itemsLimit = self.itemsLimit {
            try encodeContainer.encode(itemsLimit, forKey: .itemsLimit)
        }
        if let otherCategories = self.otherCategories {
            try encodeContainer.encode(otherCategories.rawValue, forKey: .otherCategories)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .itemsLimit)
        itemsLimit = itemsLimitDecoded
        let otherCategoriesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.OtherCategories.self, forKey: .otherCategories)
        otherCategories = otherCategoriesDecoded
    }
}

extension QuickSightClientTypes {
    /// The limit configuration of the visual display for an axis.
    public struct ItemsLimitConfiguration: Swift.Equatable {
        /// The limit on how many items of a field are showed in the chart. For example, the number of slices that are displayed in a pie chart.
        public var itemsLimit: Swift.Int?
        /// The Show other of an axis in the chart. Choose one of the following options:
        ///
        /// * INCLUDE
        ///
        /// * EXCLUDE
        public var otherCategories: QuickSightClientTypes.OtherCategories?

        public init (
            itemsLimit: Swift.Int? = nil,
            otherCategories: QuickSightClientTypes.OtherCategories? = nil
        )
        {
            self.itemsLimit = itemsLimit
            self.otherCategories = otherCategories
        }
    }

}

extension QuickSightClientTypes.JiraParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case siteBaseUrl = "SiteBaseUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let siteBaseUrl = self.siteBaseUrl {
            try encodeContainer.encode(siteBaseUrl, forKey: .siteBaseUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteBaseUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteBaseUrl)
        siteBaseUrl = siteBaseUrlDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for Jira.
    public struct JiraParameters: Swift.Equatable {
        /// The base URL of the Jira site.
        /// This member is required.
        public var siteBaseUrl: Swift.String?

        public init (
            siteBaseUrl: Swift.String? = nil
        )
        {
            self.siteBaseUrl = siteBaseUrl
        }
    }

}

extension QuickSightClientTypes.JoinInstruction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case leftJoinKeyProperties = "LeftJoinKeyProperties"
        case leftOperand = "LeftOperand"
        case onClause = "OnClause"
        case rightJoinKeyProperties = "RightJoinKeyProperties"
        case rightOperand = "RightOperand"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let leftJoinKeyProperties = self.leftJoinKeyProperties {
            try encodeContainer.encode(leftJoinKeyProperties, forKey: .leftJoinKeyProperties)
        }
        if let leftOperand = self.leftOperand {
            try encodeContainer.encode(leftOperand, forKey: .leftOperand)
        }
        if let onClause = self.onClause {
            try encodeContainer.encode(onClause, forKey: .onClause)
        }
        if let rightJoinKeyProperties = self.rightJoinKeyProperties {
            try encodeContainer.encode(rightJoinKeyProperties, forKey: .rightJoinKeyProperties)
        }
        if let rightOperand = self.rightOperand {
            try encodeContainer.encode(rightOperand, forKey: .rightOperand)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let leftOperandDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .leftOperand)
        leftOperand = leftOperandDecoded
        let rightOperandDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rightOperand)
        rightOperand = rightOperandDecoded
        let leftJoinKeyPropertiesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.JoinKeyProperties.self, forKey: .leftJoinKeyProperties)
        leftJoinKeyProperties = leftJoinKeyPropertiesDecoded
        let rightJoinKeyPropertiesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.JoinKeyProperties.self, forKey: .rightJoinKeyProperties)
        rightJoinKeyProperties = rightJoinKeyPropertiesDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.JoinType.self, forKey: .type)
        type = typeDecoded
        let onClauseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .onClause)
        onClause = onClauseDecoded
    }
}

extension QuickSightClientTypes {
    /// The instructions associated with a join.
    public struct JoinInstruction: Swift.Equatable {
        /// Join key properties of the left operand.
        public var leftJoinKeyProperties: QuickSightClientTypes.JoinKeyProperties?
        /// The operand on the left side of a join.
        /// This member is required.
        public var leftOperand: Swift.String?
        /// The join instructions provided in the ON clause of a join.
        /// This member is required.
        public var onClause: Swift.String?
        /// Join key properties of the right operand.
        public var rightJoinKeyProperties: QuickSightClientTypes.JoinKeyProperties?
        /// The operand on the right side of a join.
        /// This member is required.
        public var rightOperand: Swift.String?
        /// The type of join that it is.
        /// This member is required.
        public var type: QuickSightClientTypes.JoinType?

        public init (
            leftJoinKeyProperties: QuickSightClientTypes.JoinKeyProperties? = nil,
            leftOperand: Swift.String? = nil,
            onClause: Swift.String? = nil,
            rightJoinKeyProperties: QuickSightClientTypes.JoinKeyProperties? = nil,
            rightOperand: Swift.String? = nil,
            type: QuickSightClientTypes.JoinType? = nil
        )
        {
            self.leftJoinKeyProperties = leftJoinKeyProperties
            self.leftOperand = leftOperand
            self.onClause = onClause
            self.rightJoinKeyProperties = rightJoinKeyProperties
            self.rightOperand = rightOperand
            self.type = type
        }
    }

}

extension QuickSightClientTypes.JoinKeyProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uniqueKey = "UniqueKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let uniqueKey = self.uniqueKey {
            try encodeContainer.encode(uniqueKey, forKey: .uniqueKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uniqueKeyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .uniqueKey)
        uniqueKey = uniqueKeyDecoded
    }
}

extension QuickSightClientTypes {
    /// Properties associated with the columns participating in a join.
    public struct JoinKeyProperties: Swift.Equatable {
        /// A value that indicates that a row in a table is uniquely identified by the columns in a join key. This is used by Amazon QuickSight to optimize query performance.
        public var uniqueKey: Swift.Bool?

        public init (
            uniqueKey: Swift.Bool? = nil
        )
        {
            self.uniqueKey = uniqueKey
        }
    }

}

extension QuickSightClientTypes {
    public enum JoinType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case inner
        case `left`
        case outer
        case `right`
        case sdkUnknown(Swift.String)

        public static var allCases: [JoinType] {
            return [
                .inner,
                .left,
                .outer,
                .right,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .inner: return "INNER"
            case .left: return "LEFT"
            case .outer: return "OUTER"
            case .right: return "RIGHT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JoinType(rawValue: rawValue) ?? JoinType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.KPIConditionalFormatting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conditionalFormattingOptions = "ConditionalFormattingOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conditionalFormattingOptions = conditionalFormattingOptions {
            var conditionalFormattingOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conditionalFormattingOptions)
            for kpiconditionalformattingoption0 in conditionalFormattingOptions {
                try conditionalFormattingOptionsContainer.encode(kpiconditionalformattingoption0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionalFormattingOptionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.KPIConditionalFormattingOption?].self, forKey: .conditionalFormattingOptions)
        var conditionalFormattingOptionsDecoded0:[QuickSightClientTypes.KPIConditionalFormattingOption]? = nil
        if let conditionalFormattingOptionsContainer = conditionalFormattingOptionsContainer {
            conditionalFormattingOptionsDecoded0 = [QuickSightClientTypes.KPIConditionalFormattingOption]()
            for structure0 in conditionalFormattingOptionsContainer {
                if let structure0 = structure0 {
                    conditionalFormattingOptionsDecoded0?.append(structure0)
                }
            }
        }
        conditionalFormattingOptions = conditionalFormattingOptionsDecoded0
    }
}

extension QuickSightClientTypes {
    /// The conditional formatting of a KPI visual.
    public struct KPIConditionalFormatting: Swift.Equatable {
        /// The conditional formatting options of a KPI visual.
        public var conditionalFormattingOptions: [QuickSightClientTypes.KPIConditionalFormattingOption]?

        public init (
            conditionalFormattingOptions: [QuickSightClientTypes.KPIConditionalFormattingOption]? = nil
        )
        {
            self.conditionalFormattingOptions = conditionalFormattingOptions
        }
    }

}

extension QuickSightClientTypes.KPIConditionalFormattingOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case primaryValue = "PrimaryValue"
        case progressBar = "ProgressBar"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let primaryValue = self.primaryValue {
            try encodeContainer.encode(primaryValue, forKey: .primaryValue)
        }
        if let progressBar = self.progressBar {
            try encodeContainer.encode(progressBar, forKey: .progressBar)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryValueDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.KPIPrimaryValueConditionalFormatting.self, forKey: .primaryValue)
        primaryValue = primaryValueDecoded
        let progressBarDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.KPIProgressBarConditionalFormatting.self, forKey: .progressBar)
        progressBar = progressBarDecoded
    }
}

extension QuickSightClientTypes {
    /// The conditional formatting options of a KPI visual.
    public struct KPIConditionalFormattingOption: Swift.Equatable {
        /// The conditional formatting for the primary value of a KPI visual.
        public var primaryValue: QuickSightClientTypes.KPIPrimaryValueConditionalFormatting?
        /// The conditional formatting for the progress bar of a KPI visual.
        public var progressBar: QuickSightClientTypes.KPIProgressBarConditionalFormatting?

        public init (
            primaryValue: QuickSightClientTypes.KPIPrimaryValueConditionalFormatting? = nil,
            progressBar: QuickSightClientTypes.KPIProgressBarConditionalFormatting? = nil
        )
        {
            self.primaryValue = primaryValue
            self.progressBar = progressBar
        }
    }

}

extension QuickSightClientTypes.KPIConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldWells = "FieldWells"
        case kpiOptions = "KPIOptions"
        case sortConfiguration = "SortConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldWells = self.fieldWells {
            try encodeContainer.encode(fieldWells, forKey: .fieldWells)
        }
        if let kpiOptions = self.kpiOptions {
            try encodeContainer.encode(kpiOptions, forKey: .kpiOptions)
        }
        if let sortConfiguration = self.sortConfiguration {
            try encodeContainer.encode(sortConfiguration, forKey: .sortConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.KPIFieldWells.self, forKey: .fieldWells)
        fieldWells = fieldWellsDecoded
        let sortConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.KPISortConfiguration.self, forKey: .sortConfiguration)
        sortConfiguration = sortConfigurationDecoded
        let kpiOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.KPIOptions.self, forKey: .kpiOptions)
        kpiOptions = kpiOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of a KPI visual.
    public struct KPIConfiguration: Swift.Equatable {
        /// The field well configuration of a KPI visual.
        public var fieldWells: QuickSightClientTypes.KPIFieldWells?
        /// The options that determine the presentation of a KPI visual.
        public var kpiOptions: QuickSightClientTypes.KPIOptions?
        /// The sort configuration of a KPI visual.
        public var sortConfiguration: QuickSightClientTypes.KPISortConfiguration?

        public init (
            fieldWells: QuickSightClientTypes.KPIFieldWells? = nil,
            kpiOptions: QuickSightClientTypes.KPIOptions? = nil,
            sortConfiguration: QuickSightClientTypes.KPISortConfiguration? = nil
        )
        {
            self.fieldWells = fieldWells
            self.kpiOptions = kpiOptions
            self.sortConfiguration = sortConfiguration
        }
    }

}

extension QuickSightClientTypes.KPIFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetValues = "TargetValues"
        case trendGroups = "TrendGroups"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetValues = targetValues {
            var targetValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetValues)
            for measurefield0 in targetValues {
                try targetValuesContainer.encode(measurefield0)
            }
        }
        if let trendGroups = trendGroups {
            var trendGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trendGroups)
            for dimensionfield0 in trendGroups {
                try trendGroupsContainer.encode(dimensionfield0)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for measurefield0 in values {
                try valuesContainer.encode(measurefield0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .values)
        var valuesDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
        let targetValuesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .targetValues)
        var targetValuesDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let targetValuesContainer = targetValuesContainer {
            targetValuesDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in targetValuesContainer {
                if let structure0 = structure0 {
                    targetValuesDecoded0?.append(structure0)
                }
            }
        }
        targetValues = targetValuesDecoded0
        let trendGroupsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .trendGroups)
        var trendGroupsDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let trendGroupsContainer = trendGroupsContainer {
            trendGroupsDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in trendGroupsContainer {
                if let structure0 = structure0 {
                    trendGroupsDecoded0?.append(structure0)
                }
            }
        }
        trendGroups = trendGroupsDecoded0
    }
}

extension QuickSightClientTypes {
    /// The field well configuration of a KPI visual.
    public struct KPIFieldWells: Swift.Equatable {
        /// The target value field wells of a KPI visual.
        public var targetValues: [QuickSightClientTypes.MeasureField]?
        /// The trend group field wells of a KPI visual.
        public var trendGroups: [QuickSightClientTypes.DimensionField]?
        /// The value field wells of a KPI visual.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init (
            targetValues: [QuickSightClientTypes.MeasureField]? = nil,
            trendGroups: [QuickSightClientTypes.DimensionField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.targetValues = targetValues
            self.trendGroups = trendGroups
            self.values = values
        }
    }

}

extension QuickSightClientTypes.KPIOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparison = "Comparison"
        case primaryValueDisplayType = "PrimaryValueDisplayType"
        case primaryValueFontConfiguration = "PrimaryValueFontConfiguration"
        case progressBar = "ProgressBar"
        case secondaryValue = "SecondaryValue"
        case secondaryValueFontConfiguration = "SecondaryValueFontConfiguration"
        case trendArrows = "TrendArrows"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparison = self.comparison {
            try encodeContainer.encode(comparison, forKey: .comparison)
        }
        if let primaryValueDisplayType = self.primaryValueDisplayType {
            try encodeContainer.encode(primaryValueDisplayType.rawValue, forKey: .primaryValueDisplayType)
        }
        if let primaryValueFontConfiguration = self.primaryValueFontConfiguration {
            try encodeContainer.encode(primaryValueFontConfiguration, forKey: .primaryValueFontConfiguration)
        }
        if let progressBar = self.progressBar {
            try encodeContainer.encode(progressBar, forKey: .progressBar)
        }
        if let secondaryValue = self.secondaryValue {
            try encodeContainer.encode(secondaryValue, forKey: .secondaryValue)
        }
        if let secondaryValueFontConfiguration = self.secondaryValueFontConfiguration {
            try encodeContainer.encode(secondaryValueFontConfiguration, forKey: .secondaryValueFontConfiguration)
        }
        if let trendArrows = self.trendArrows {
            try encodeContainer.encode(trendArrows, forKey: .trendArrows)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressBarDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ProgressBarOptions.self, forKey: .progressBar)
        progressBar = progressBarDecoded
        let trendArrowsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TrendArrowOptions.self, forKey: .trendArrows)
        trendArrows = trendArrowsDecoded
        let secondaryValueDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SecondaryValueOptions.self, forKey: .secondaryValue)
        secondaryValue = secondaryValueDecoded
        let comparisonDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ComparisonConfiguration.self, forKey: .comparison)
        comparison = comparisonDecoded
        let primaryValueDisplayTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PrimaryValueDisplayType.self, forKey: .primaryValueDisplayType)
        primaryValueDisplayType = primaryValueDisplayTypeDecoded
        let primaryValueFontConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FontConfiguration.self, forKey: .primaryValueFontConfiguration)
        primaryValueFontConfiguration = primaryValueFontConfigurationDecoded
        let secondaryValueFontConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FontConfiguration.self, forKey: .secondaryValueFontConfiguration)
        secondaryValueFontConfiguration = secondaryValueFontConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the presentation of a KPI visual.
    public struct KPIOptions: Swift.Equatable {
        /// The comparison configuration of a KPI visual.
        public var comparison: QuickSightClientTypes.ComparisonConfiguration?
        /// The options that determine the primary value display type.
        public var primaryValueDisplayType: QuickSightClientTypes.PrimaryValueDisplayType?
        /// The options that determine the primary value font configuration.
        public var primaryValueFontConfiguration: QuickSightClientTypes.FontConfiguration?
        /// The options that determine the presentation of the progress bar of a KPI visual.
        public var progressBar: QuickSightClientTypes.ProgressBarOptions?
        /// The options that determine the presentation of the secondary value of a KPI visual.
        public var secondaryValue: QuickSightClientTypes.SecondaryValueOptions?
        /// The options that determine the secondary value font configuration.
        public var secondaryValueFontConfiguration: QuickSightClientTypes.FontConfiguration?
        /// The options that determine the presentation of trend arrows in a KPI visual.
        public var trendArrows: QuickSightClientTypes.TrendArrowOptions?

        public init (
            comparison: QuickSightClientTypes.ComparisonConfiguration? = nil,
            primaryValueDisplayType: QuickSightClientTypes.PrimaryValueDisplayType? = nil,
            primaryValueFontConfiguration: QuickSightClientTypes.FontConfiguration? = nil,
            progressBar: QuickSightClientTypes.ProgressBarOptions? = nil,
            secondaryValue: QuickSightClientTypes.SecondaryValueOptions? = nil,
            secondaryValueFontConfiguration: QuickSightClientTypes.FontConfiguration? = nil,
            trendArrows: QuickSightClientTypes.TrendArrowOptions? = nil
        )
        {
            self.comparison = comparison
            self.primaryValueDisplayType = primaryValueDisplayType
            self.primaryValueFontConfiguration = primaryValueFontConfiguration
            self.progressBar = progressBar
            self.secondaryValue = secondaryValue
            self.secondaryValueFontConfiguration = secondaryValueFontConfiguration
            self.trendArrows = trendArrows
        }
    }

}

extension QuickSightClientTypes.KPIPrimaryValueConditionalFormatting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case icon = "Icon"
        case textColor = "TextColor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let icon = self.icon {
            try encodeContainer.encode(icon, forKey: .icon)
        }
        if let textColor = self.textColor {
            try encodeContainer.encode(textColor, forKey: .textColor)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textColorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ConditionalFormattingColor.self, forKey: .textColor)
        textColor = textColorDecoded
        let iconDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ConditionalFormattingIcon.self, forKey: .icon)
        icon = iconDecoded
    }
}

extension QuickSightClientTypes {
    /// The conditional formatting for the primary value of a KPI visual.
    public struct KPIPrimaryValueConditionalFormatting: Swift.Equatable {
        /// The conditional formatting of the primary value's icon.
        public var icon: QuickSightClientTypes.ConditionalFormattingIcon?
        /// The conditional formatting of the primary value's text color.
        public var textColor: QuickSightClientTypes.ConditionalFormattingColor?

        public init (
            icon: QuickSightClientTypes.ConditionalFormattingIcon? = nil,
            textColor: QuickSightClientTypes.ConditionalFormattingColor? = nil
        )
        {
            self.icon = icon
            self.textColor = textColor
        }
    }

}

extension QuickSightClientTypes.KPIProgressBarConditionalFormatting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case foregroundColor = "ForegroundColor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let foregroundColor = self.foregroundColor {
            try encodeContainer.encode(foregroundColor, forKey: .foregroundColor)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let foregroundColorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ConditionalFormattingColor.self, forKey: .foregroundColor)
        foregroundColor = foregroundColorDecoded
    }
}

extension QuickSightClientTypes {
    /// The conditional formatting for the progress bar of a KPI visual.
    public struct KPIProgressBarConditionalFormatting: Swift.Equatable {
        /// The conditional formatting of the progress bar's foreground color.
        public var foregroundColor: QuickSightClientTypes.ConditionalFormattingColor?

        public init (
            foregroundColor: QuickSightClientTypes.ConditionalFormattingColor? = nil
        )
        {
            self.foregroundColor = foregroundColor
        }
    }

}

extension QuickSightClientTypes.KPISortConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trendGroupSort = "TrendGroupSort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trendGroupSort = trendGroupSort {
            var trendGroupSortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trendGroupSort)
            for fieldsortoptions0 in trendGroupSort {
                try trendGroupSortContainer.encode(fieldsortoptions0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trendGroupSortContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FieldSortOptions?].self, forKey: .trendGroupSort)
        var trendGroupSortDecoded0:[QuickSightClientTypes.FieldSortOptions]? = nil
        if let trendGroupSortContainer = trendGroupSortContainer {
            trendGroupSortDecoded0 = [QuickSightClientTypes.FieldSortOptions]()
            for structure0 in trendGroupSortContainer {
                if let structure0 = structure0 {
                    trendGroupSortDecoded0?.append(structure0)
                }
            }
        }
        trendGroupSort = trendGroupSortDecoded0
    }
}

extension QuickSightClientTypes {
    /// The sort configuration of a KPI visual.
    public struct KPISortConfiguration: Swift.Equatable {
        /// The sort configuration of the trend group fields.
        public var trendGroupSort: [QuickSightClientTypes.FieldSortOptions]?

        public init (
            trendGroupSort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.trendGroupSort = trendGroupSort
        }
    }

}

extension QuickSightClientTypes.KPIVisual: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case chartConfiguration = "ChartConfiguration"
        case columnHierarchies = "ColumnHierarchies"
        case conditionalFormatting = "ConditionalFormatting"
        case subtitle = "Subtitle"
        case title = "Title"
        case visualId = "VisualId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for visualcustomaction0 in actions {
                try actionsContainer.encode(visualcustomaction0)
            }
        }
        if let chartConfiguration = self.chartConfiguration {
            try encodeContainer.encode(chartConfiguration, forKey: .chartConfiguration)
        }
        if let columnHierarchies = columnHierarchies {
            var columnHierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnHierarchies)
            for columnhierarchy0 in columnHierarchies {
                try columnHierarchiesContainer.encode(columnhierarchy0)
            }
        }
        if let conditionalFormatting = self.conditionalFormatting {
            try encodeContainer.encode(conditionalFormatting, forKey: .conditionalFormatting)
        }
        if let subtitle = self.subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let visualId = self.visualId {
            try encodeContainer.encode(visualId, forKey: .visualId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visualIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visualId)
        visualId = visualIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualTitleLabelOptions.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualSubtitleLabelOptions.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let chartConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.KPIConfiguration.self, forKey: .chartConfiguration)
        chartConfiguration = chartConfigurationDecoded
        let conditionalFormattingDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.KPIConditionalFormatting.self, forKey: .conditionalFormatting)
        conditionalFormatting = conditionalFormattingDecoded
        let actionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.VisualCustomAction?].self, forKey: .actions)
        var actionsDecoded0:[QuickSightClientTypes.VisualCustomAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [QuickSightClientTypes.VisualCustomAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let columnHierarchiesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnHierarchy?].self, forKey: .columnHierarchies)
        var columnHierarchiesDecoded0:[QuickSightClientTypes.ColumnHierarchy]? = nil
        if let columnHierarchiesContainer = columnHierarchiesContainer {
            columnHierarchiesDecoded0 = [QuickSightClientTypes.ColumnHierarchy]()
            for structure0 in columnHierarchiesContainer {
                if let structure0 = structure0 {
                    columnHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        columnHierarchies = columnHierarchiesDecoded0
    }
}

extension QuickSightClientTypes {
    /// A key performance indicator (KPI). For more information, see [Using KPIs](https://docs.aws.amazon.com/quicksight/latest/user/kpi.html) in the Amazon QuickSight User Guide.
    public struct KPIVisual: Swift.Equatable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration of a KPI visual.
        public var chartConfiguration: QuickSightClientTypes.KPIConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The conditional formatting of a KPI visual.
        public var conditionalFormatting: QuickSightClientTypes.KPIConditionalFormatting?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init (
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.KPIConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            conditionalFormatting: QuickSightClientTypes.KPIConditionalFormatting? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.conditionalFormatting = conditionalFormatting
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }

}

extension QuickSightClientTypes.LabelOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customLabel = "CustomLabel"
        case fontConfiguration = "FontConfiguration"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customLabel = self.customLabel {
            try encodeContainer.encode(customLabel, forKey: .customLabel)
        }
        if let fontConfiguration = self.fontConfiguration {
            try encodeContainer.encode(fontConfiguration, forKey: .fontConfiguration)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
        let fontConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FontConfiguration.self, forKey: .fontConfiguration)
        fontConfiguration = fontConfigurationDecoded
        let customLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customLabel)
        customLabel = customLabelDecoded
    }
}

extension QuickSightClientTypes {
    /// The share label options for the labels.
    public struct LabelOptions: Swift.Equatable {
        /// The text for the label.
        public var customLabel: Swift.String?
        /// The font configuration of the label.
        public var fontConfiguration: QuickSightClientTypes.FontConfiguration?
        /// Determines whether or not the label is visible.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            customLabel: Swift.String? = nil,
            fontConfiguration: QuickSightClientTypes.FontConfiguration? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.customLabel = customLabel
            self.fontConfiguration = fontConfiguration
            self.visibility = visibility
        }
    }

}

extension QuickSightClientTypes.Layout: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LayoutConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension QuickSightClientTypes {
    /// A Layout defines the placement of elements within a sheet. For more information, see [Types of layout](https://docs.aws.amazon.com/quicksight/latest/user/types-of-layout.html) in the Amazon QuickSight User Guide. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct Layout: Swift.Equatable {
        /// The configuration that determines what the type of layout for a sheet.
        /// This member is required.
        public var configuration: QuickSightClientTypes.LayoutConfiguration?

        public init (
            configuration: QuickSightClientTypes.LayoutConfiguration? = nil
        )
        {
            self.configuration = configuration
        }
    }

}

extension QuickSightClientTypes.LayoutConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case freeFormLayout = "FreeFormLayout"
        case gridLayout = "GridLayout"
        case sectionBasedLayout = "SectionBasedLayout"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let freeFormLayout = self.freeFormLayout {
            try encodeContainer.encode(freeFormLayout, forKey: .freeFormLayout)
        }
        if let gridLayout = self.gridLayout {
            try encodeContainer.encode(gridLayout, forKey: .gridLayout)
        }
        if let sectionBasedLayout = self.sectionBasedLayout {
            try encodeContainer.encode(sectionBasedLayout, forKey: .sectionBasedLayout)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gridLayoutDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GridLayoutConfiguration.self, forKey: .gridLayout)
        gridLayout = gridLayoutDecoded
        let freeFormLayoutDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FreeFormLayoutConfiguration.self, forKey: .freeFormLayout)
        freeFormLayout = freeFormLayoutDecoded
        let sectionBasedLayoutDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SectionBasedLayoutConfiguration.self, forKey: .sectionBasedLayout)
        sectionBasedLayout = sectionBasedLayoutDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration that determines what the type of layout will be used on a sheet. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct LayoutConfiguration: Swift.Equatable {
        /// A free-form is optimized for a fixed width and has more control over the exact placement of layout elements.
        public var freeFormLayout: QuickSightClientTypes.FreeFormLayoutConfiguration?
        /// A type of layout that can be used on a sheet. In a grid layout, visuals snap to a grid with standard spacing and alignment. Dashboards are displayed as designed, with options to fit to screen or view at actual size. A grid layout can be configured to behave in one of two ways when the viewport is resized: FIXED or RESPONSIVE.
        public var gridLayout: QuickSightClientTypes.GridLayoutConfiguration?
        /// A section based layout organizes visuals into multiple sections and has customized header, footer and page break.
        public var sectionBasedLayout: QuickSightClientTypes.SectionBasedLayoutConfiguration?

        public init (
            freeFormLayout: QuickSightClientTypes.FreeFormLayoutConfiguration? = nil,
            gridLayout: QuickSightClientTypes.GridLayoutConfiguration? = nil,
            sectionBasedLayout: QuickSightClientTypes.SectionBasedLayoutConfiguration? = nil
        )
        {
            self.freeFormLayout = freeFormLayout
            self.gridLayout = gridLayout
            self.sectionBasedLayout = sectionBasedLayout
        }
    }

}

extension QuickSightClientTypes {
    public enum LayoutElementType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case filterControl
        case parameterControl
        case textBox
        case visual
        case sdkUnknown(Swift.String)

        public static var allCases: [LayoutElementType] {
            return [
                .filterControl,
                .parameterControl,
                .textBox,
                .visual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .filterControl: return "FILTER_CONTROL"
            case .parameterControl: return "PARAMETER_CONTROL"
            case .textBox: return "TEXT_BOX"
            case .visual: return "VISUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LayoutElementType(rawValue: rawValue) ?? LayoutElementType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.LegendOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case height = "Height"
        case position = "Position"
        case title = "Title"
        case visibility = "Visibility"
        case width = "Width"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let height = self.height {
            try encodeContainer.encode(height, forKey: .height)
        }
        if let position = self.position {
            try encodeContainer.encode(position.rawValue, forKey: .position)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
        if let width = self.width {
            try encodeContainer.encode(width, forKey: .width)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
        let titleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LabelOptions.self, forKey: .title)
        title = titleDecoded
        let positionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LegendPosition.self, forKey: .position)
        position = positionDecoded
        let widthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .width)
        width = widthDecoded
        let heightDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .height)
        height = heightDecoded
    }
}

extension QuickSightClientTypes {
    /// The options for the legend setup of a visual.
    public struct LegendOptions: Swift.Equatable {
        /// The height of the legend. If this value is omitted, a default height is used when rendering.
        public var height: Swift.String?
        /// The positions for the legend. Choose one of the following options:
        ///
        /// * AUTO
        ///
        /// * RIGHT
        ///
        /// * BOTTOM
        ///
        /// * LEFT
        public var position: QuickSightClientTypes.LegendPosition?
        /// The custom title for the legend.
        public var title: QuickSightClientTypes.LabelOptions?
        /// Determines whether or not the legend is visible.
        public var visibility: QuickSightClientTypes.Visibility?
        /// The width of the legend. If this value is omitted, a default width is used when rendering.
        public var width: Swift.String?

        public init (
            height: Swift.String? = nil,
            position: QuickSightClientTypes.LegendPosition? = nil,
            title: QuickSightClientTypes.LabelOptions? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil,
            width: Swift.String? = nil
        )
        {
            self.height = height
            self.position = position
            self.title = title
            self.visibility = visibility
            self.width = width
        }
    }

}

extension QuickSightClientTypes {
    public enum LegendPosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case bottom
        case `right`
        case top
        case sdkUnknown(Swift.String)

        public static var allCases: [LegendPosition] {
            return [
                .auto,
                .bottom,
                .right,
                .top,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .bottom: return "BOTTOM"
            case .right: return "RIGHT"
            case .top: return "TOP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LegendPosition(rawValue: rawValue) ?? LegendPosition.sdkUnknown(rawValue)
        }
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.requestId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A limit is exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?
    /// Limit exceeded.
    public var resourceType: QuickSightClientTypes.ExceptionResourceType?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceType: QuickSightClientTypes.ExceptionResourceType? = nil
    )
    {
        self.message = message
        self.requestId = requestId
        self.resourceType = resourceType
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: QuickSightClientTypes.ExceptionResourceType?
    let requestId: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ExceptionResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.LineChartAggregatedFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category = "Category"
        case colors = "Colors"
        case smallMultiples = "SmallMultiples"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            var categoryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .category)
            for dimensionfield0 in category {
                try categoryContainer.encode(dimensionfield0)
            }
        }
        if let colors = colors {
            var colorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .colors)
            for dimensionfield0 in colors {
                try colorsContainer.encode(dimensionfield0)
            }
        }
        if let smallMultiples = smallMultiples {
            var smallMultiplesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .smallMultiples)
            for dimensionfield0 in smallMultiples {
                try smallMultiplesContainer.encode(dimensionfield0)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for measurefield0 in values {
                try valuesContainer.encode(measurefield0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .category)
        var categoryDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let categoryContainer = categoryContainer {
            categoryDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in categoryContainer {
                if let structure0 = structure0 {
                    categoryDecoded0?.append(structure0)
                }
            }
        }
        category = categoryDecoded0
        let valuesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .values)
        var valuesDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
        let colorsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .colors)
        var colorsDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let colorsContainer = colorsContainer {
            colorsDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in colorsContainer {
                if let structure0 = structure0 {
                    colorsDecoded0?.append(structure0)
                }
            }
        }
        colors = colorsDecoded0
        let smallMultiplesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .smallMultiples)
        var smallMultiplesDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let smallMultiplesContainer = smallMultiplesContainer {
            smallMultiplesDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in smallMultiplesContainer {
                if let structure0 = structure0 {
                    smallMultiplesDecoded0?.append(structure0)
                }
            }
        }
        smallMultiples = smallMultiplesDecoded0
    }
}

extension QuickSightClientTypes {
    /// The field well configuration of a line chart.
    public struct LineChartAggregatedFieldWells: Swift.Equatable {
        /// The category field wells of a line chart. Values are grouped by category fields.
        public var category: [QuickSightClientTypes.DimensionField]?
        /// The color field wells of a line chart. Values are grouped by category fields.
        public var colors: [QuickSightClientTypes.DimensionField]?
        /// The small multiples field well of a line chart.
        public var smallMultiples: [QuickSightClientTypes.DimensionField]?
        /// The value field wells of a line chart. Values are aggregated based on categories.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init (
            category: [QuickSightClientTypes.DimensionField]? = nil,
            colors: [QuickSightClientTypes.DimensionField]? = nil,
            smallMultiples: [QuickSightClientTypes.DimensionField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.category = category
            self.colors = colors
            self.smallMultiples = smallMultiples
            self.values = values
        }
    }

}

extension QuickSightClientTypes.LineChartConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contributionAnalysisDefaults = "ContributionAnalysisDefaults"
        case dataLabels = "DataLabels"
        case defaultSeriesSettings = "DefaultSeriesSettings"
        case fieldWells = "FieldWells"
        case forecastConfigurations = "ForecastConfigurations"
        case legend = "Legend"
        case primaryYAxisDisplayOptions = "PrimaryYAxisDisplayOptions"
        case primaryYAxisLabelOptions = "PrimaryYAxisLabelOptions"
        case referenceLines = "ReferenceLines"
        case secondaryYAxisDisplayOptions = "SecondaryYAxisDisplayOptions"
        case secondaryYAxisLabelOptions = "SecondaryYAxisLabelOptions"
        case series = "Series"
        case smallMultiplesOptions = "SmallMultiplesOptions"
        case sortConfiguration = "SortConfiguration"
        case tooltip = "Tooltip"
        case type = "Type"
        case visualPalette = "VisualPalette"
        case xAxisDisplayOptions = "XAxisDisplayOptions"
        case xAxisLabelOptions = "XAxisLabelOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contributionAnalysisDefaults = contributionAnalysisDefaults {
            var contributionAnalysisDefaultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contributionAnalysisDefaults)
            for contributionanalysisdefault0 in contributionAnalysisDefaults {
                try contributionAnalysisDefaultsContainer.encode(contributionanalysisdefault0)
            }
        }
        if let dataLabels = self.dataLabels {
            try encodeContainer.encode(dataLabels, forKey: .dataLabels)
        }
        if let defaultSeriesSettings = self.defaultSeriesSettings {
            try encodeContainer.encode(defaultSeriesSettings, forKey: .defaultSeriesSettings)
        }
        if let fieldWells = self.fieldWells {
            try encodeContainer.encode(fieldWells, forKey: .fieldWells)
        }
        if let forecastConfigurations = forecastConfigurations {
            var forecastConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .forecastConfigurations)
            for forecastconfiguration0 in forecastConfigurations {
                try forecastConfigurationsContainer.encode(forecastconfiguration0)
            }
        }
        if let legend = self.legend {
            try encodeContainer.encode(legend, forKey: .legend)
        }
        if let primaryYAxisDisplayOptions = self.primaryYAxisDisplayOptions {
            try encodeContainer.encode(primaryYAxisDisplayOptions, forKey: .primaryYAxisDisplayOptions)
        }
        if let primaryYAxisLabelOptions = self.primaryYAxisLabelOptions {
            try encodeContainer.encode(primaryYAxisLabelOptions, forKey: .primaryYAxisLabelOptions)
        }
        if let referenceLines = referenceLines {
            var referenceLinesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceLines)
            for referenceline0 in referenceLines {
                try referenceLinesContainer.encode(referenceline0)
            }
        }
        if let secondaryYAxisDisplayOptions = self.secondaryYAxisDisplayOptions {
            try encodeContainer.encode(secondaryYAxisDisplayOptions, forKey: .secondaryYAxisDisplayOptions)
        }
        if let secondaryYAxisLabelOptions = self.secondaryYAxisLabelOptions {
            try encodeContainer.encode(secondaryYAxisLabelOptions, forKey: .secondaryYAxisLabelOptions)
        }
        if let series = series {
            var seriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .series)
            for seriesitem0 in series {
                try seriesContainer.encode(seriesitem0)
            }
        }
        if let smallMultiplesOptions = self.smallMultiplesOptions {
            try encodeContainer.encode(smallMultiplesOptions, forKey: .smallMultiplesOptions)
        }
        if let sortConfiguration = self.sortConfiguration {
            try encodeContainer.encode(sortConfiguration, forKey: .sortConfiguration)
        }
        if let tooltip = self.tooltip {
            try encodeContainer.encode(tooltip, forKey: .tooltip)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let visualPalette = self.visualPalette {
            try encodeContainer.encode(visualPalette, forKey: .visualPalette)
        }
        if let xAxisDisplayOptions = self.xAxisDisplayOptions {
            try encodeContainer.encode(xAxisDisplayOptions, forKey: .xAxisDisplayOptions)
        }
        if let xAxisLabelOptions = self.xAxisLabelOptions {
            try encodeContainer.encode(xAxisLabelOptions, forKey: .xAxisLabelOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LineChartFieldWells.self, forKey: .fieldWells)
        fieldWells = fieldWellsDecoded
        let sortConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LineChartSortConfiguration.self, forKey: .sortConfiguration)
        sortConfiguration = sortConfigurationDecoded
        let forecastConfigurationsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ForecastConfiguration?].self, forKey: .forecastConfigurations)
        var forecastConfigurationsDecoded0:[QuickSightClientTypes.ForecastConfiguration]? = nil
        if let forecastConfigurationsContainer = forecastConfigurationsContainer {
            forecastConfigurationsDecoded0 = [QuickSightClientTypes.ForecastConfiguration]()
            for structure0 in forecastConfigurationsContainer {
                if let structure0 = structure0 {
                    forecastConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        forecastConfigurations = forecastConfigurationsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LineChartType.self, forKey: .type)
        type = typeDecoded
        let smallMultiplesOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SmallMultiplesOptions.self, forKey: .smallMultiplesOptions)
        smallMultiplesOptions = smallMultiplesOptionsDecoded
        let xAxisDisplayOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisDisplayOptions.self, forKey: .xAxisDisplayOptions)
        xAxisDisplayOptions = xAxisDisplayOptionsDecoded
        let xAxisLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .xAxisLabelOptions)
        xAxisLabelOptions = xAxisLabelOptionsDecoded
        let primaryYAxisDisplayOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LineSeriesAxisDisplayOptions.self, forKey: .primaryYAxisDisplayOptions)
        primaryYAxisDisplayOptions = primaryYAxisDisplayOptionsDecoded
        let primaryYAxisLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .primaryYAxisLabelOptions)
        primaryYAxisLabelOptions = primaryYAxisLabelOptionsDecoded
        let secondaryYAxisDisplayOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LineSeriesAxisDisplayOptions.self, forKey: .secondaryYAxisDisplayOptions)
        secondaryYAxisDisplayOptions = secondaryYAxisDisplayOptionsDecoded
        let secondaryYAxisLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .secondaryYAxisLabelOptions)
        secondaryYAxisLabelOptions = secondaryYAxisLabelOptionsDecoded
        let defaultSeriesSettingsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LineChartDefaultSeriesSettings.self, forKey: .defaultSeriesSettings)
        defaultSeriesSettings = defaultSeriesSettingsDecoded
        let seriesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.SeriesItem?].self, forKey: .series)
        var seriesDecoded0:[QuickSightClientTypes.SeriesItem]? = nil
        if let seriesContainer = seriesContainer {
            seriesDecoded0 = [QuickSightClientTypes.SeriesItem]()
            for structure0 in seriesContainer {
                if let structure0 = structure0 {
                    seriesDecoded0?.append(structure0)
                }
            }
        }
        series = seriesDecoded0
        let legendDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LegendOptions.self, forKey: .legend)
        legend = legendDecoded
        let dataLabelsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataLabelOptions.self, forKey: .dataLabels)
        dataLabels = dataLabelsDecoded
        let referenceLinesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ReferenceLine?].self, forKey: .referenceLines)
        var referenceLinesDecoded0:[QuickSightClientTypes.ReferenceLine]? = nil
        if let referenceLinesContainer = referenceLinesContainer {
            referenceLinesDecoded0 = [QuickSightClientTypes.ReferenceLine]()
            for structure0 in referenceLinesContainer {
                if let structure0 = structure0 {
                    referenceLinesDecoded0?.append(structure0)
                }
            }
        }
        referenceLines = referenceLinesDecoded0
        let tooltipDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TooltipOptions.self, forKey: .tooltip)
        tooltip = tooltipDecoded
        let contributionAnalysisDefaultsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ContributionAnalysisDefault?].self, forKey: .contributionAnalysisDefaults)
        var contributionAnalysisDefaultsDecoded0:[QuickSightClientTypes.ContributionAnalysisDefault]? = nil
        if let contributionAnalysisDefaultsContainer = contributionAnalysisDefaultsContainer {
            contributionAnalysisDefaultsDecoded0 = [QuickSightClientTypes.ContributionAnalysisDefault]()
            for structure0 in contributionAnalysisDefaultsContainer {
                if let structure0 = structure0 {
                    contributionAnalysisDefaultsDecoded0?.append(structure0)
                }
            }
        }
        contributionAnalysisDefaults = contributionAnalysisDefaultsDecoded0
        let visualPaletteDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualPalette.self, forKey: .visualPalette)
        visualPalette = visualPaletteDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of a line chart.
    public struct LineChartConfiguration: Swift.Equatable {
        /// The default configuration of a line chart's contribution analysis.
        public var contributionAnalysisDefaults: [QuickSightClientTypes.ContributionAnalysisDefault]?
        /// The data label configuration of a line chart.
        public var dataLabels: QuickSightClientTypes.DataLabelOptions?
        /// The options that determine the default presentation of all line series in LineChartVisual.
        public var defaultSeriesSettings: QuickSightClientTypes.LineChartDefaultSeriesSettings?
        /// The field well configuration of a line chart.
        public var fieldWells: QuickSightClientTypes.LineChartFieldWells?
        /// The forecast configuration of a line chart.
        public var forecastConfigurations: [QuickSightClientTypes.ForecastConfiguration]?
        /// The legend configuration of a line chart.
        public var legend: QuickSightClientTypes.LegendOptions?
        /// The series axis configuration of a line chart.
        public var primaryYAxisDisplayOptions: QuickSightClientTypes.LineSeriesAxisDisplayOptions?
        /// The options that determine the presentation of the y-axis label.
        public var primaryYAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The reference lines configuration of a line chart.
        public var referenceLines: [QuickSightClientTypes.ReferenceLine]?
        /// The series axis configuration of a line chart.
        public var secondaryYAxisDisplayOptions: QuickSightClientTypes.LineSeriesAxisDisplayOptions?
        /// The options that determine the presentation of the secondary y-axis label.
        public var secondaryYAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The series item configuration of a line chart.
        public var series: [QuickSightClientTypes.SeriesItem]?
        /// The small multiples setup for the visual.
        public var smallMultiplesOptions: QuickSightClientTypes.SmallMultiplesOptions?
        /// The sort configuration of a line chart.
        public var sortConfiguration: QuickSightClientTypes.LineChartSortConfiguration?
        /// The tooltip configuration of a line chart.
        public var tooltip: QuickSightClientTypes.TooltipOptions?
        /// Determines the type of the line chart.
        public var type: QuickSightClientTypes.LineChartType?
        /// The visual palette configuration of a line chart.
        public var visualPalette: QuickSightClientTypes.VisualPalette?
        /// The options that determine the presentation of the x-axis.
        public var xAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions?
        /// The options that determine the presentation of the x-axis label.
        public var xAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?

        public init (
            contributionAnalysisDefaults: [QuickSightClientTypes.ContributionAnalysisDefault]? = nil,
            dataLabels: QuickSightClientTypes.DataLabelOptions? = nil,
            defaultSeriesSettings: QuickSightClientTypes.LineChartDefaultSeriesSettings? = nil,
            fieldWells: QuickSightClientTypes.LineChartFieldWells? = nil,
            forecastConfigurations: [QuickSightClientTypes.ForecastConfiguration]? = nil,
            legend: QuickSightClientTypes.LegendOptions? = nil,
            primaryYAxisDisplayOptions: QuickSightClientTypes.LineSeriesAxisDisplayOptions? = nil,
            primaryYAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            referenceLines: [QuickSightClientTypes.ReferenceLine]? = nil,
            secondaryYAxisDisplayOptions: QuickSightClientTypes.LineSeriesAxisDisplayOptions? = nil,
            secondaryYAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            series: [QuickSightClientTypes.SeriesItem]? = nil,
            smallMultiplesOptions: QuickSightClientTypes.SmallMultiplesOptions? = nil,
            sortConfiguration: QuickSightClientTypes.LineChartSortConfiguration? = nil,
            tooltip: QuickSightClientTypes.TooltipOptions? = nil,
            type: QuickSightClientTypes.LineChartType? = nil,
            visualPalette: QuickSightClientTypes.VisualPalette? = nil,
            xAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions? = nil,
            xAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil
        )
        {
            self.contributionAnalysisDefaults = contributionAnalysisDefaults
            self.dataLabels = dataLabels
            self.defaultSeriesSettings = defaultSeriesSettings
            self.fieldWells = fieldWells
            self.forecastConfigurations = forecastConfigurations
            self.legend = legend
            self.primaryYAxisDisplayOptions = primaryYAxisDisplayOptions
            self.primaryYAxisLabelOptions = primaryYAxisLabelOptions
            self.referenceLines = referenceLines
            self.secondaryYAxisDisplayOptions = secondaryYAxisDisplayOptions
            self.secondaryYAxisLabelOptions = secondaryYAxisLabelOptions
            self.series = series
            self.smallMultiplesOptions = smallMultiplesOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.type = type
            self.visualPalette = visualPalette
            self.xAxisDisplayOptions = xAxisDisplayOptions
            self.xAxisLabelOptions = xAxisLabelOptions
        }
    }

}

extension QuickSightClientTypes.LineChartDefaultSeriesSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case axisBinding = "AxisBinding"
        case lineStyleSettings = "LineStyleSettings"
        case markerStyleSettings = "MarkerStyleSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let axisBinding = self.axisBinding {
            try encodeContainer.encode(axisBinding.rawValue, forKey: .axisBinding)
        }
        if let lineStyleSettings = self.lineStyleSettings {
            try encodeContainer.encode(lineStyleSettings, forKey: .lineStyleSettings)
        }
        if let markerStyleSettings = self.markerStyleSettings {
            try encodeContainer.encode(markerStyleSettings, forKey: .markerStyleSettings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let axisBindingDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisBinding.self, forKey: .axisBinding)
        axisBinding = axisBindingDecoded
        let lineStyleSettingsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LineChartLineStyleSettings.self, forKey: .lineStyleSettings)
        lineStyleSettings = lineStyleSettingsDecoded
        let markerStyleSettingsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LineChartMarkerStyleSettings.self, forKey: .markerStyleSettings)
        markerStyleSettings = markerStyleSettingsDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the default presentation of all line series in LineChartVisual.
    public struct LineChartDefaultSeriesSettings: Swift.Equatable {
        /// The axis to which you are binding all line series to.
        public var axisBinding: QuickSightClientTypes.AxisBinding?
        /// Line styles options for all line series in the visual.
        public var lineStyleSettings: QuickSightClientTypes.LineChartLineStyleSettings?
        /// Marker styles options for all line series in the visual.
        public var markerStyleSettings: QuickSightClientTypes.LineChartMarkerStyleSettings?

        public init (
            axisBinding: QuickSightClientTypes.AxisBinding? = nil,
            lineStyleSettings: QuickSightClientTypes.LineChartLineStyleSettings? = nil,
            markerStyleSettings: QuickSightClientTypes.LineChartMarkerStyleSettings? = nil
        )
        {
            self.axisBinding = axisBinding
            self.lineStyleSettings = lineStyleSettings
            self.markerStyleSettings = markerStyleSettings
        }
    }

}

extension QuickSightClientTypes.LineChartFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lineChartAggregatedFieldWells = "LineChartAggregatedFieldWells"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lineChartAggregatedFieldWells = self.lineChartAggregatedFieldWells {
            try encodeContainer.encode(lineChartAggregatedFieldWells, forKey: .lineChartAggregatedFieldWells)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lineChartAggregatedFieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LineChartAggregatedFieldWells.self, forKey: .lineChartAggregatedFieldWells)
        lineChartAggregatedFieldWells = lineChartAggregatedFieldWellsDecoded
    }
}

extension QuickSightClientTypes {
    /// The field well configuration of a line chart.
    public struct LineChartFieldWells: Swift.Equatable {
        /// The field well configuration of a line chart.
        public var lineChartAggregatedFieldWells: QuickSightClientTypes.LineChartAggregatedFieldWells?

        public init (
            lineChartAggregatedFieldWells: QuickSightClientTypes.LineChartAggregatedFieldWells? = nil
        )
        {
            self.lineChartAggregatedFieldWells = lineChartAggregatedFieldWells
        }
    }

}

extension QuickSightClientTypes {
    public enum LineChartLineStyle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dashed
        case dotted
        case solid
        case sdkUnknown(Swift.String)

        public static var allCases: [LineChartLineStyle] {
            return [
                .dashed,
                .dotted,
                .solid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dashed: return "DASHED"
            case .dotted: return "DOTTED"
            case .solid: return "SOLID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LineChartLineStyle(rawValue: rawValue) ?? LineChartLineStyle.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.LineChartLineStyleSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lineInterpolation = "LineInterpolation"
        case lineStyle = "LineStyle"
        case lineVisibility = "LineVisibility"
        case lineWidth = "LineWidth"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lineInterpolation = self.lineInterpolation {
            try encodeContainer.encode(lineInterpolation.rawValue, forKey: .lineInterpolation)
        }
        if let lineStyle = self.lineStyle {
            try encodeContainer.encode(lineStyle.rawValue, forKey: .lineStyle)
        }
        if let lineVisibility = self.lineVisibility {
            try encodeContainer.encode(lineVisibility.rawValue, forKey: .lineVisibility)
        }
        if let lineWidth = self.lineWidth {
            try encodeContainer.encode(lineWidth, forKey: .lineWidth)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lineVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .lineVisibility)
        lineVisibility = lineVisibilityDecoded
        let lineInterpolationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LineInterpolation.self, forKey: .lineInterpolation)
        lineInterpolation = lineInterpolationDecoded
        let lineStyleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LineChartLineStyle.self, forKey: .lineStyle)
        lineStyle = lineStyleDecoded
        let lineWidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lineWidth)
        lineWidth = lineWidthDecoded
    }
}

extension QuickSightClientTypes {
    /// Line styles options for a line series in LineChartVisual.
    public struct LineChartLineStyleSettings: Swift.Equatable {
        /// Interpolation style for line series.
        ///
        /// * LINEAR: Show as default, linear style.
        ///
        /// * SMOOTH: Show as a smooth curve.
        ///
        /// * STEPPED: Show steps in line.
        public var lineInterpolation: QuickSightClientTypes.LineInterpolation?
        /// Line style for line series.
        ///
        /// * SOLID: Show as a solid line.
        ///
        /// * DOTTED: Show as a dotted line.
        ///
        /// * DASHED: Show as a dashed line.
        public var lineStyle: QuickSightClientTypes.LineChartLineStyle?
        /// Configuration option that determines whether to show the line for the series.
        public var lineVisibility: QuickSightClientTypes.Visibility?
        /// Width that determines the line thickness.
        public var lineWidth: Swift.String?

        public init (
            lineInterpolation: QuickSightClientTypes.LineInterpolation? = nil,
            lineStyle: QuickSightClientTypes.LineChartLineStyle? = nil,
            lineVisibility: QuickSightClientTypes.Visibility? = nil,
            lineWidth: Swift.String? = nil
        )
        {
            self.lineInterpolation = lineInterpolation
            self.lineStyle = lineStyle
            self.lineVisibility = lineVisibility
            self.lineWidth = lineWidth
        }
    }

}

extension QuickSightClientTypes {
    public enum LineChartMarkerShape: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case circle
        case diamond
        case roundedSquare
        case square
        case triangle
        case sdkUnknown(Swift.String)

        public static var allCases: [LineChartMarkerShape] {
            return [
                .circle,
                .diamond,
                .roundedSquare,
                .square,
                .triangle,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .circle: return "CIRCLE"
            case .diamond: return "DIAMOND"
            case .roundedSquare: return "ROUNDED_SQUARE"
            case .square: return "SQUARE"
            case .triangle: return "TRIANGLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LineChartMarkerShape(rawValue: rawValue) ?? LineChartMarkerShape.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.LineChartMarkerStyleSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case markerColor = "MarkerColor"
        case markerShape = "MarkerShape"
        case markerSize = "MarkerSize"
        case markerVisibility = "MarkerVisibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let markerColor = self.markerColor {
            try encodeContainer.encode(markerColor, forKey: .markerColor)
        }
        if let markerShape = self.markerShape {
            try encodeContainer.encode(markerShape.rawValue, forKey: .markerShape)
        }
        if let markerSize = self.markerSize {
            try encodeContainer.encode(markerSize, forKey: .markerSize)
        }
        if let markerVisibility = self.markerVisibility {
            try encodeContainer.encode(markerVisibility.rawValue, forKey: .markerVisibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .markerVisibility)
        markerVisibility = markerVisibilityDecoded
        let markerShapeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LineChartMarkerShape.self, forKey: .markerShape)
        markerShape = markerShapeDecoded
        let markerSizeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .markerSize)
        markerSize = markerSizeDecoded
        let markerColorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .markerColor)
        markerColor = markerColorDecoded
    }
}

extension QuickSightClientTypes {
    /// Marker styles options for a line series in LineChartVisual.
    public struct LineChartMarkerStyleSettings: Swift.Equatable {
        /// Color of marker in the series.
        public var markerColor: Swift.String?
        /// Shape option for markers in the series.
        ///
        /// * CIRCLE: Show marker as a circle.
        ///
        /// * TRIANGLE: Show marker as a triangle.
        ///
        /// * SQUARE: Show marker as a square.
        ///
        /// * DIAMOND: Show marker as a diamond.
        ///
        /// * ROUNDED_SQUARE: Show marker as a rounded square.
        public var markerShape: QuickSightClientTypes.LineChartMarkerShape?
        /// Size of marker in the series.
        public var markerSize: Swift.String?
        /// Configuration option that determines whether to show the markers in the series.
        public var markerVisibility: QuickSightClientTypes.Visibility?

        public init (
            markerColor: Swift.String? = nil,
            markerShape: QuickSightClientTypes.LineChartMarkerShape? = nil,
            markerSize: Swift.String? = nil,
            markerVisibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.markerColor = markerColor
            self.markerShape = markerShape
            self.markerSize = markerSize
            self.markerVisibility = markerVisibility
        }
    }

}

extension QuickSightClientTypes.LineChartSeriesSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lineStyleSettings = "LineStyleSettings"
        case markerStyleSettings = "MarkerStyleSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lineStyleSettings = self.lineStyleSettings {
            try encodeContainer.encode(lineStyleSettings, forKey: .lineStyleSettings)
        }
        if let markerStyleSettings = self.markerStyleSettings {
            try encodeContainer.encode(markerStyleSettings, forKey: .markerStyleSettings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lineStyleSettingsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LineChartLineStyleSettings.self, forKey: .lineStyleSettings)
        lineStyleSettings = lineStyleSettingsDecoded
        let markerStyleSettingsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LineChartMarkerStyleSettings.self, forKey: .markerStyleSettings)
        markerStyleSettings = markerStyleSettingsDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the presentation of a line series in the visual
    public struct LineChartSeriesSettings: Swift.Equatable {
        /// Line styles options for a line series in LineChartVisual.
        public var lineStyleSettings: QuickSightClientTypes.LineChartLineStyleSettings?
        /// Marker styles options for a line series in LineChartVisual.
        public var markerStyleSettings: QuickSightClientTypes.LineChartMarkerStyleSettings?

        public init (
            lineStyleSettings: QuickSightClientTypes.LineChartLineStyleSettings? = nil,
            markerStyleSettings: QuickSightClientTypes.LineChartMarkerStyleSettings? = nil
        )
        {
            self.lineStyleSettings = lineStyleSettings
            self.markerStyleSettings = markerStyleSettings
        }
    }

}

extension QuickSightClientTypes.LineChartSortConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryItemsLimitConfiguration = "CategoryItemsLimitConfiguration"
        case categorySort = "CategorySort"
        case colorItemsLimitConfiguration = "ColorItemsLimitConfiguration"
        case smallMultiplesLimitConfiguration = "SmallMultiplesLimitConfiguration"
        case smallMultiplesSort = "SmallMultiplesSort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryItemsLimitConfiguration = self.categoryItemsLimitConfiguration {
            try encodeContainer.encode(categoryItemsLimitConfiguration, forKey: .categoryItemsLimitConfiguration)
        }
        if let categorySort = categorySort {
            var categorySortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categorySort)
            for fieldsortoptions0 in categorySort {
                try categorySortContainer.encode(fieldsortoptions0)
            }
        }
        if let colorItemsLimitConfiguration = self.colorItemsLimitConfiguration {
            try encodeContainer.encode(colorItemsLimitConfiguration, forKey: .colorItemsLimitConfiguration)
        }
        if let smallMultiplesLimitConfiguration = self.smallMultiplesLimitConfiguration {
            try encodeContainer.encode(smallMultiplesLimitConfiguration, forKey: .smallMultiplesLimitConfiguration)
        }
        if let smallMultiplesSort = smallMultiplesSort {
            var smallMultiplesSortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .smallMultiplesSort)
            for fieldsortoptions0 in smallMultiplesSort {
                try smallMultiplesSortContainer.encode(fieldsortoptions0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categorySortContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FieldSortOptions?].self, forKey: .categorySort)
        var categorySortDecoded0:[QuickSightClientTypes.FieldSortOptions]? = nil
        if let categorySortContainer = categorySortContainer {
            categorySortDecoded0 = [QuickSightClientTypes.FieldSortOptions]()
            for structure0 in categorySortContainer {
                if let structure0 = structure0 {
                    categorySortDecoded0?.append(structure0)
                }
            }
        }
        categorySort = categorySortDecoded0
        let categoryItemsLimitConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ItemsLimitConfiguration.self, forKey: .categoryItemsLimitConfiguration)
        categoryItemsLimitConfiguration = categoryItemsLimitConfigurationDecoded
        let colorItemsLimitConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ItemsLimitConfiguration.self, forKey: .colorItemsLimitConfiguration)
        colorItemsLimitConfiguration = colorItemsLimitConfigurationDecoded
        let smallMultiplesSortContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FieldSortOptions?].self, forKey: .smallMultiplesSort)
        var smallMultiplesSortDecoded0:[QuickSightClientTypes.FieldSortOptions]? = nil
        if let smallMultiplesSortContainer = smallMultiplesSortContainer {
            smallMultiplesSortDecoded0 = [QuickSightClientTypes.FieldSortOptions]()
            for structure0 in smallMultiplesSortContainer {
                if let structure0 = structure0 {
                    smallMultiplesSortDecoded0?.append(structure0)
                }
            }
        }
        smallMultiplesSort = smallMultiplesSortDecoded0
        let smallMultiplesLimitConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ItemsLimitConfiguration.self, forKey: .smallMultiplesLimitConfiguration)
        smallMultiplesLimitConfiguration = smallMultiplesLimitConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The sort configuration of a line chart.
    public struct LineChartSortConfiguration: Swift.Equatable {
        /// The limit on the number of categories that are displayed in a line chart.
        public var categoryItemsLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of the category fields.
        public var categorySort: [QuickSightClientTypes.FieldSortOptions]?
        /// The limit on the number of lines that are displayed in a line chart.
        public var colorItemsLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The limit on the number of small multiples panels that are displayed.
        public var smallMultiplesLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of the small multiples field.
        public var smallMultiplesSort: [QuickSightClientTypes.FieldSortOptions]?

        public init (
            categoryItemsLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            categorySort: [QuickSightClientTypes.FieldSortOptions]? = nil,
            colorItemsLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            smallMultiplesLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            smallMultiplesSort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.categoryItemsLimitConfiguration = categoryItemsLimitConfiguration
            self.categorySort = categorySort
            self.colorItemsLimitConfiguration = colorItemsLimitConfiguration
            self.smallMultiplesLimitConfiguration = smallMultiplesLimitConfiguration
            self.smallMultiplesSort = smallMultiplesSort
        }
    }

}

extension QuickSightClientTypes {
    public enum LineChartType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case area
        case line
        case stackedArea
        case sdkUnknown(Swift.String)

        public static var allCases: [LineChartType] {
            return [
                .area,
                .line,
                .stackedArea,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .area: return "AREA"
            case .line: return "LINE"
            case .stackedArea: return "STACKED_AREA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LineChartType(rawValue: rawValue) ?? LineChartType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.LineChartVisual: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case chartConfiguration = "ChartConfiguration"
        case columnHierarchies = "ColumnHierarchies"
        case subtitle = "Subtitle"
        case title = "Title"
        case visualId = "VisualId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for visualcustomaction0 in actions {
                try actionsContainer.encode(visualcustomaction0)
            }
        }
        if let chartConfiguration = self.chartConfiguration {
            try encodeContainer.encode(chartConfiguration, forKey: .chartConfiguration)
        }
        if let columnHierarchies = columnHierarchies {
            var columnHierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnHierarchies)
            for columnhierarchy0 in columnHierarchies {
                try columnHierarchiesContainer.encode(columnhierarchy0)
            }
        }
        if let subtitle = self.subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let visualId = self.visualId {
            try encodeContainer.encode(visualId, forKey: .visualId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visualIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visualId)
        visualId = visualIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualTitleLabelOptions.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualSubtitleLabelOptions.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let chartConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LineChartConfiguration.self, forKey: .chartConfiguration)
        chartConfiguration = chartConfigurationDecoded
        let actionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.VisualCustomAction?].self, forKey: .actions)
        var actionsDecoded0:[QuickSightClientTypes.VisualCustomAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [QuickSightClientTypes.VisualCustomAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let columnHierarchiesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnHierarchy?].self, forKey: .columnHierarchies)
        var columnHierarchiesDecoded0:[QuickSightClientTypes.ColumnHierarchy]? = nil
        if let columnHierarchiesContainer = columnHierarchiesContainer {
            columnHierarchiesDecoded0 = [QuickSightClientTypes.ColumnHierarchy]()
            for structure0 in columnHierarchiesContainer {
                if let structure0 = structure0 {
                    columnHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        columnHierarchies = columnHierarchiesDecoded0
    }
}

extension QuickSightClientTypes {
    /// A line chart. For more information, see [Using line charts](https://docs.aws.amazon.com/quicksight/latest/user/line-charts.html) in the Amazon QuickSight User Guide.
    public struct LineChartVisual: Swift.Equatable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration of a line chart.
        public var chartConfiguration: QuickSightClientTypes.LineChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init (
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.LineChartConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }

}

extension QuickSightClientTypes {
    public enum LineInterpolation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linear
        case smooth
        case stepped
        case sdkUnknown(Swift.String)

        public static var allCases: [LineInterpolation] {
            return [
                .linear,
                .smooth,
                .stepped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linear: return "LINEAR"
            case .smooth: return "SMOOTH"
            case .stepped: return "STEPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LineInterpolation(rawValue: rawValue) ?? LineInterpolation.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.LineSeriesAxisDisplayOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case axisOptions = "AxisOptions"
        case missingDataConfigurations = "MissingDataConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let axisOptions = self.axisOptions {
            try encodeContainer.encode(axisOptions, forKey: .axisOptions)
        }
        if let missingDataConfigurations = missingDataConfigurations {
            var missingDataConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .missingDataConfigurations)
            for missingdataconfiguration0 in missingDataConfigurations {
                try missingDataConfigurationsContainer.encode(missingdataconfiguration0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let axisOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisDisplayOptions.self, forKey: .axisOptions)
        axisOptions = axisOptionsDecoded
        let missingDataConfigurationsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MissingDataConfiguration?].self, forKey: .missingDataConfigurations)
        var missingDataConfigurationsDecoded0:[QuickSightClientTypes.MissingDataConfiguration]? = nil
        if let missingDataConfigurationsContainer = missingDataConfigurationsContainer {
            missingDataConfigurationsDecoded0 = [QuickSightClientTypes.MissingDataConfiguration]()
            for structure0 in missingDataConfigurationsContainer {
                if let structure0 = structure0 {
                    missingDataConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        missingDataConfigurations = missingDataConfigurationsDecoded0
    }
}

extension QuickSightClientTypes {
    /// The series axis configuration of a line chart.
    public struct LineSeriesAxisDisplayOptions: Swift.Equatable {
        /// The options that determine the presentation of the line series axis.
        public var axisOptions: QuickSightClientTypes.AxisDisplayOptions?
        /// The configuration options that determine how missing data is treated during the rendering of a line chart.
        public var missingDataConfigurations: [QuickSightClientTypes.MissingDataConfiguration]?

        public init (
            axisOptions: QuickSightClientTypes.AxisDisplayOptions? = nil,
            missingDataConfigurations: [QuickSightClientTypes.MissingDataConfiguration]? = nil
        )
        {
            self.axisOptions = axisOptions
            self.missingDataConfigurations = missingDataConfigurations
        }
    }

}

extension QuickSightClientTypes.LinkSharingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissions = "Permissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for resourcepermission0 in permissions {
                try permissionsContainer.encode(resourcepermission0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A structure that contains the configuration of a shareable link to the dashboard.
    public struct LinkSharingConfiguration: Swift.Equatable {
        /// A structure that contains the permissions of a shareable link.
        public var permissions: [QuickSightClientTypes.ResourcePermission]?

        public init (
            permissions: [QuickSightClientTypes.ResourcePermission]? = nil
        )
        {
            self.permissions = permissions
        }
    }

}

extension ListAnalysesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAnalysesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/analyses"
    }
}

public struct ListAnalysesInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the analyses.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAnalysesInputBody: Swift.Equatable {
}

extension ListAnalysesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAnalysesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnalysesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAnalysesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnalysesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAnalysesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisSummaryList = output.analysisSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.analysisSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListAnalysesOutputResponse: Swift.Equatable {
    /// Metadata describing each of the analyses that are listed.
    public var analysisSummaryList: [QuickSightClientTypes.AnalysisSummary]?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        analysisSummaryList: [QuickSightClientTypes.AnalysisSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.analysisSummaryList = analysisSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListAnalysesOutputResponseBody: Swift.Equatable {
    let analysisSummaryList: [QuickSightClientTypes.AnalysisSummary]?
    let nextToken: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension ListAnalysesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisSummaryList = "AnalysisSummaryList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisSummaryListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.AnalysisSummary?].self, forKey: .analysisSummaryList)
        var analysisSummaryListDecoded0:[QuickSightClientTypes.AnalysisSummary]? = nil
        if let analysisSummaryListContainer = analysisSummaryListContainer {
            analysisSummaryListDecoded0 = [QuickSightClientTypes.AnalysisSummary]()
            for structure0 in analysisSummaryListContainer {
                if let structure0 = structure0 {
                    analysisSummaryListDecoded0?.append(structure0)
                }
            }
        }
        analysisSummaryList = analysisSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.ListControlDisplayOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case searchOptions = "SearchOptions"
        case selectAllOptions = "SelectAllOptions"
        case titleOptions = "TitleOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let searchOptions = self.searchOptions {
            try encodeContainer.encode(searchOptions, forKey: .searchOptions)
        }
        if let selectAllOptions = self.selectAllOptions {
            try encodeContainer.encode(selectAllOptions, forKey: .selectAllOptions)
        }
        if let titleOptions = self.titleOptions {
            try encodeContainer.encode(titleOptions, forKey: .titleOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ListControlSearchOptions.self, forKey: .searchOptions)
        searchOptions = searchOptionsDecoded
        let selectAllOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ListControlSelectAllOptions.self, forKey: .selectAllOptions)
        selectAllOptions = selectAllOptionsDecoded
        let titleOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LabelOptions.self, forKey: .titleOptions)
        titleOptions = titleOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// The display options of a control.
    public struct ListControlDisplayOptions: Swift.Equatable {
        /// The configuration of the search options in a list control.
        public var searchOptions: QuickSightClientTypes.ListControlSearchOptions?
        /// The configuration of the Select all options in a list control.
        public var selectAllOptions: QuickSightClientTypes.ListControlSelectAllOptions?
        /// The options to configure the title visibility, name, and font size.
        public var titleOptions: QuickSightClientTypes.LabelOptions?

        public init (
            searchOptions: QuickSightClientTypes.ListControlSearchOptions? = nil,
            selectAllOptions: QuickSightClientTypes.ListControlSelectAllOptions? = nil,
            titleOptions: QuickSightClientTypes.LabelOptions? = nil
        )
        {
            self.searchOptions = searchOptions
            self.selectAllOptions = selectAllOptions
            self.titleOptions = titleOptions
        }
    }

}

extension QuickSightClientTypes.ListControlSearchOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of the search options in a list control.
    public struct ListControlSearchOptions: Swift.Equatable {
        /// The visibility configuration of the search options in a list control.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.visibility = visibility
        }
    }

}

extension QuickSightClientTypes.ListControlSelectAllOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of the Select all options in a list control.
    public struct ListControlSelectAllOptions: Swift.Equatable {
        /// The visibility configuration of the Select all options in a list control.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.visibility = visibility
        }
    }

}

extension ListDashboardVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDashboardVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dashboardId = dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())/versions"
    }
}

public struct ListDashboardVersionsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the dashboard that you're listing versions for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDashboardVersionsInputBody: Swift.Equatable {
}

extension ListDashboardVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDashboardVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDashboardVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDashboardVersionsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDashboardVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDashboardVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dashboardVersionSummaryList = output.dashboardVersionSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.dashboardVersionSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListDashboardVersionsOutputResponse: Swift.Equatable {
    /// A structure that contains information about each version of the dashboard.
    public var dashboardVersionSummaryList: [QuickSightClientTypes.DashboardVersionSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dashboardVersionSummaryList: [QuickSightClientTypes.DashboardVersionSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dashboardVersionSummaryList = dashboardVersionSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListDashboardVersionsOutputResponseBody: Swift.Equatable {
    let dashboardVersionSummaryList: [QuickSightClientTypes.DashboardVersionSummary]?
    let nextToken: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension ListDashboardVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardVersionSummaryList = "DashboardVersionSummaryList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardVersionSummaryListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DashboardVersionSummary?].self, forKey: .dashboardVersionSummaryList)
        var dashboardVersionSummaryListDecoded0:[QuickSightClientTypes.DashboardVersionSummary]? = nil
        if let dashboardVersionSummaryListContainer = dashboardVersionSummaryListContainer {
            dashboardVersionSummaryListDecoded0 = [QuickSightClientTypes.DashboardVersionSummary]()
            for structure0 in dashboardVersionSummaryListContainer {
                if let structure0 = structure0 {
                    dashboardVersionSummaryListDecoded0?.append(structure0)
                }
            }
        }
        dashboardVersionSummaryList = dashboardVersionSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListDashboardsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDashboardsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards"
    }
}

public struct ListDashboardsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the dashboards that you're listing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDashboardsInputBody: Swift.Equatable {
}

extension ListDashboardsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDashboardsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDashboardsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDashboardsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDashboardsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDashboardsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dashboardSummaryList = output.dashboardSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.dashboardSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListDashboardsOutputResponse: Swift.Equatable {
    /// A structure that contains all of the dashboards in your Amazon Web Services account. This structure provides basic information about the dashboards.
    public var dashboardSummaryList: [QuickSightClientTypes.DashboardSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dashboardSummaryList: [QuickSightClientTypes.DashboardSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dashboardSummaryList = dashboardSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListDashboardsOutputResponseBody: Swift.Equatable {
    let dashboardSummaryList: [QuickSightClientTypes.DashboardSummary]?
    let nextToken: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension ListDashboardsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardSummaryList = "DashboardSummaryList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardSummaryListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DashboardSummary?].self, forKey: .dashboardSummaryList)
        var dashboardSummaryListDecoded0:[QuickSightClientTypes.DashboardSummary]? = nil
        if let dashboardSummaryListContainer = dashboardSummaryListContainer {
            dashboardSummaryListDecoded0 = [QuickSightClientTypes.DashboardSummary]()
            for structure0 in dashboardSummaryListContainer {
                if let structure0 = structure0 {
                    dashboardSummaryListDecoded0?.append(structure0)
                }
            }
        }
        dashboardSummaryList = dashboardSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListDataSetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDataSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets"
    }
}

public struct ListDataSetsInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataSetsInputBody: Swift.Equatable {
}

extension ListDataSetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDataSetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataSetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDataSetsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataSetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDataSetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSetSummaries = output.dataSetSummaries
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.dataSetSummaries = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListDataSetsOutputResponse: Swift.Equatable {
    /// The list of dataset summaries.
    public var dataSetSummaries: [QuickSightClientTypes.DataSetSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dataSetSummaries: [QuickSightClientTypes.DataSetSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSetSummaries = dataSetSummaries
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListDataSetsOutputResponseBody: Swift.Equatable {
    let dataSetSummaries: [QuickSightClientTypes.DataSetSummary]?
    let nextToken: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension ListDataSetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetSummaries = "DataSetSummaries"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetSummariesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataSetSummary?].self, forKey: .dataSetSummaries)
        var dataSetSummariesDecoded0:[QuickSightClientTypes.DataSetSummary]? = nil
        if let dataSetSummariesContainer = dataSetSummariesContainer {
            dataSetSummariesDecoded0 = [QuickSightClientTypes.DataSetSummary]()
            for structure0 in dataSetSummariesContainer {
                if let structure0 = structure0 {
                    dataSetSummariesDecoded0?.append(structure0)
                }
            }
        }
        dataSetSummaries = dataSetSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension ListDataSourcesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDataSourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sources"
    }
}

public struct ListDataSourcesInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataSourcesInputBody: Swift.Equatable {
}

extension ListDataSourcesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDataSourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataSourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDataSourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataSourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDataSourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSources = output.dataSources
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.dataSources = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListDataSourcesOutputResponse: Swift.Equatable {
    /// A list of data sources.
    public var dataSources: [QuickSightClientTypes.DataSource]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dataSources: [QuickSightClientTypes.DataSource]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSources = dataSources
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListDataSourcesOutputResponseBody: Swift.Equatable {
    let dataSources: [QuickSightClientTypes.DataSource]?
    let nextToken: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension ListDataSourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSources = "DataSources"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourcesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[QuickSightClientTypes.DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [QuickSightClientTypes.DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension ListFolderMembersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListFolderMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let folderId = folderId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())/members"
    }
}

public struct ListFolderMembersInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFolderMembersInputBody: Swift.Equatable {
}

extension ListFolderMembersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFolderMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFolderMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListFolderMembersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFolderMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListFolderMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.folderMemberList = output.folderMemberList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.folderMemberList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListFolderMembersOutputResponse: Swift.Equatable {
    /// A structure that contains all of the folder members (dashboards, analyses, and datasets) in the folder.
    public var folderMemberList: [QuickSightClientTypes.MemberIdArnPair]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        folderMemberList: [QuickSightClientTypes.MemberIdArnPair]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.folderMemberList = folderMemberList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListFolderMembersOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let folderMemberList: [QuickSightClientTypes.MemberIdArnPair]?
    let nextToken: Swift.String?
    let requestId: Swift.String?
}

extension ListFolderMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case folderMemberList = "FolderMemberList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let folderMemberListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MemberIdArnPair?].self, forKey: .folderMemberList)
        var folderMemberListDecoded0:[QuickSightClientTypes.MemberIdArnPair]? = nil
        if let folderMemberListContainer = folderMemberListContainer {
            folderMemberListDecoded0 = [QuickSightClientTypes.MemberIdArnPair]()
            for structure0 in folderMemberListContainer {
                if let structure0 = structure0 {
                    folderMemberListDecoded0?.append(structure0)
                }
            }
        }
        folderMemberList = folderMemberListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListFoldersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListFoldersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders"
    }
}

public struct ListFoldersInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFoldersInputBody: Swift.Equatable {
}

extension ListFoldersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFoldersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFoldersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListFoldersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFoldersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListFoldersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.folderSummaryList = output.folderSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.folderSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListFoldersOutputResponse: Swift.Equatable {
    /// A structure that contains all of the folders in the Amazon Web Services account. This structure provides basic information about the folders.
    public var folderSummaryList: [QuickSightClientTypes.FolderSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        folderSummaryList: [QuickSightClientTypes.FolderSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.folderSummaryList = folderSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListFoldersOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let folderSummaryList: [QuickSightClientTypes.FolderSummary]?
    let nextToken: Swift.String?
    let requestId: Swift.String?
}

extension ListFoldersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case folderSummaryList = "FolderSummaryList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let folderSummaryListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FolderSummary?].self, forKey: .folderSummaryList)
        var folderSummaryListDecoded0:[QuickSightClientTypes.FolderSummary]? = nil
        if let folderSummaryListContainer = folderSummaryListContainer {
            folderSummaryListDecoded0 = [QuickSightClientTypes.FolderSummary]()
            for structure0 in folderSummaryListContainer {
                if let structure0 = structure0 {
                    folderSummaryListDecoded0?.append(structure0)
                }
            }
        }
        folderSummaryList = folderSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListGroupMembershipsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListGroupMembershipsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let groupName = groupName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups/\(groupName.urlPercentEncoding())/members"
    }
}

public struct ListGroupMembershipsInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The name of the group that you want to see a membership list of.
    /// This member is required.
    public var groupName: Swift.String?
    /// The maximum number of results to return from this request.
    public var maxResults: Swift.Int?
    /// The namespace of the group that you want a list of users from.
    /// This member is required.
    public var namespace: Swift.String?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.groupName = groupName
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
    }
}

struct ListGroupMembershipsInputBody: Swift.Equatable {
}

extension ListGroupMembershipsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListGroupMembershipsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroupMembershipsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListGroupMembershipsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupMembershipsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListGroupMembershipsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groupMemberList = output.groupMemberList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.groupMemberList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListGroupMembershipsOutputResponse: Swift.Equatable {
    /// The list of the members of the group.
    public var groupMemberList: [QuickSightClientTypes.GroupMember]?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        groupMemberList: [QuickSightClientTypes.GroupMember]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.groupMemberList = groupMemberList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListGroupMembershipsOutputResponseBody: Swift.Equatable {
    let groupMemberList: [QuickSightClientTypes.GroupMember]?
    let nextToken: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension ListGroupMembershipsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupMemberList = "GroupMemberList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupMemberListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.GroupMember?].self, forKey: .groupMemberList)
        var groupMemberListDecoded0:[QuickSightClientTypes.GroupMember]? = nil
        if let groupMemberListContainer = groupMemberListContainer {
            groupMemberListDecoded0 = [QuickSightClientTypes.GroupMember]()
            for structure0 in groupMemberListContainer {
                if let structure0 = structure0 {
                    groupMemberListDecoded0?.append(structure0)
                }
            }
        }
        groupMemberList = groupMemberListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension ListGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups"
    }
}

public struct ListGroupsInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The namespace that you want a list of groups from.
    /// This member is required.
    public var namespace: Swift.String?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
    }
}

struct ListGroupsInputBody: Swift.Equatable {
}

extension ListGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListGroupsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groupList = output.groupList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.groupList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListGroupsOutputResponse: Swift.Equatable {
    /// The list of the groups.
    public var groupList: [QuickSightClientTypes.Group]?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        groupList: [QuickSightClientTypes.Group]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.groupList = groupList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListGroupsOutputResponseBody: Swift.Equatable {
    let groupList: [QuickSightClientTypes.Group]?
    let nextToken: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension ListGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupList = "GroupList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Group?].self, forKey: .groupList)
        var groupListDecoded0:[QuickSightClientTypes.Group]? = nil
        if let groupListContainer = groupListContainer {
            groupListDecoded0 = [QuickSightClientTypes.Group]()
            for structure0 in groupListContainer {
                if let structure0 = structure0 {
                    groupListDecoded0?.append(structure0)
                }
            }
        }
        groupList = groupListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension ListIAMPolicyAssignmentsForUserInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListIAMPolicyAssignmentsForUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let userName = userName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/users/\(userName.urlPercentEncoding())/iam-policy-assignments"
    }
}

public struct ListIAMPolicyAssignmentsForUserInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the assignments.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The namespace of the assignment.
    /// This member is required.
    public var namespace: Swift.String?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The name of the user.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
        self.userName = userName
    }
}

struct ListIAMPolicyAssignmentsForUserInputBody: Swift.Equatable {
}

extension ListIAMPolicyAssignmentsForUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListIAMPolicyAssignmentsForUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIAMPolicyAssignmentsForUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentUpdatingException" : self = .concurrentUpdatingException(try ConcurrentUpdatingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListIAMPolicyAssignmentsForUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case concurrentUpdatingException(ConcurrentUpdatingException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIAMPolicyAssignmentsForUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListIAMPolicyAssignmentsForUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.activeAssignments = output.activeAssignments
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.activeAssignments = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListIAMPolicyAssignmentsForUserOutputResponse: Swift.Equatable {
    /// The active assignments for this user.
    public var activeAssignments: [QuickSightClientTypes.ActiveIAMPolicyAssignment]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        activeAssignments: [QuickSightClientTypes.ActiveIAMPolicyAssignment]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.activeAssignments = activeAssignments
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListIAMPolicyAssignmentsForUserOutputResponseBody: Swift.Equatable {
    let activeAssignments: [QuickSightClientTypes.ActiveIAMPolicyAssignment]?
    let requestId: Swift.String?
    let nextToken: Swift.String?
    let status: Swift.Int
}

extension ListIAMPolicyAssignmentsForUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeAssignments = "ActiveAssignments"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeAssignmentsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ActiveIAMPolicyAssignment?].self, forKey: .activeAssignments)
        var activeAssignmentsDecoded0:[QuickSightClientTypes.ActiveIAMPolicyAssignment]? = nil
        if let activeAssignmentsContainer = activeAssignmentsContainer {
            activeAssignmentsDecoded0 = [QuickSightClientTypes.ActiveIAMPolicyAssignment]()
            for structure0 in activeAssignmentsContainer {
                if let structure0 = structure0 {
                    activeAssignmentsDecoded0?.append(structure0)
                }
            }
        }
        activeAssignments = activeAssignmentsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension ListIAMPolicyAssignmentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentStatus = "AssignmentStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentStatus = self.assignmentStatus {
            try encodeContainer.encode(assignmentStatus.rawValue, forKey: .assignmentStatus)
        }
    }
}

extension ListIAMPolicyAssignmentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListIAMPolicyAssignmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/iam-policy-assignments"
    }
}

public struct ListIAMPolicyAssignmentsInput: Swift.Equatable {
    /// The status of the assignments.
    public var assignmentStatus: QuickSightClientTypes.AssignmentStatus?
    /// The ID of the Amazon Web Services account that contains these IAM policy assignments.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The namespace for the assignments.
    /// This member is required.
    public var namespace: Swift.String?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        assignmentStatus: QuickSightClientTypes.AssignmentStatus? = nil,
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assignmentStatus = assignmentStatus
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
    }
}

struct ListIAMPolicyAssignmentsInputBody: Swift.Equatable {
    let assignmentStatus: QuickSightClientTypes.AssignmentStatus?
}

extension ListIAMPolicyAssignmentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentStatus = "AssignmentStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AssignmentStatus.self, forKey: .assignmentStatus)
        assignmentStatus = assignmentStatusDecoded
    }
}

extension ListIAMPolicyAssignmentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIAMPolicyAssignmentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListIAMPolicyAssignmentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIAMPolicyAssignmentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListIAMPolicyAssignmentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.iamPolicyAssignments = output.iamPolicyAssignments
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.iamPolicyAssignments = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListIAMPolicyAssignmentsOutputResponse: Swift.Equatable {
    /// Information describing the IAM policy assignments.
    public var iamPolicyAssignments: [QuickSightClientTypes.IAMPolicyAssignmentSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        iamPolicyAssignments: [QuickSightClientTypes.IAMPolicyAssignmentSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.iamPolicyAssignments = iamPolicyAssignments
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListIAMPolicyAssignmentsOutputResponseBody: Swift.Equatable {
    let iamPolicyAssignments: [QuickSightClientTypes.IAMPolicyAssignmentSummary]?
    let nextToken: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension ListIAMPolicyAssignmentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamPolicyAssignments = "IAMPolicyAssignments"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamPolicyAssignmentsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.IAMPolicyAssignmentSummary?].self, forKey: .iamPolicyAssignments)
        var iamPolicyAssignmentsDecoded0:[QuickSightClientTypes.IAMPolicyAssignmentSummary]? = nil
        if let iamPolicyAssignmentsContainer = iamPolicyAssignmentsContainer {
            iamPolicyAssignmentsDecoded0 = [QuickSightClientTypes.IAMPolicyAssignmentSummary]()
            for structure0 in iamPolicyAssignmentsContainer {
                if let structure0 = structure0 {
                    iamPolicyAssignmentsDecoded0?.append(structure0)
                }
            }
        }
        iamPolicyAssignments = iamPolicyAssignmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension ListIngestionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListIngestionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSetId = dataSetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/ingestions"
    }
}

public struct ListIngestionsInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dataset used in the ingestion.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIngestionsInputBody: Swift.Equatable {
}

extension ListIngestionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListIngestionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIngestionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListIngestionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIngestionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListIngestionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ingestions = output.ingestions
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.ingestions = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListIngestionsOutputResponse: Swift.Equatable {
    /// A list of the ingestions.
    public var ingestions: [QuickSightClientTypes.Ingestion]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        ingestions: [QuickSightClientTypes.Ingestion]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.ingestions = ingestions
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListIngestionsOutputResponseBody: Swift.Equatable {
    let ingestions: [QuickSightClientTypes.Ingestion]?
    let nextToken: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension ListIngestionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingestions = "Ingestions"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ingestionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Ingestion?].self, forKey: .ingestions)
        var ingestionsDecoded0:[QuickSightClientTypes.Ingestion]? = nil
        if let ingestionsContainer = ingestionsContainer {
            ingestionsDecoded0 = [QuickSightClientTypes.Ingestion]()
            for structure0 in ingestionsContainer {
                if let structure0 = structure0 {
                    ingestionsDecoded0?.append(structure0)
                }
            }
        }
        ingestions = ingestionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension ListNamespacesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListNamespacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces"
    }
}

public struct ListNamespacesInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the Amazon QuickSight namespaces that you want to list.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A unique pagination token that can be used in a subsequent request. You will receive a pagination token in the response body of a previous ListNameSpaces API call if there is more data that can be returned. To receive the data, make another ListNamespaces API call with the returned token to retrieve the next page of data. Each token is valid for 24 hours. If you try to make a ListNamespaces API call with an expired token, you will receive a HTTP 400 InvalidNextTokenException error.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListNamespacesInputBody: Swift.Equatable {
}

extension ListNamespacesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListNamespacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNamespacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListNamespacesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNamespacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListNamespacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.namespaces = output.namespaces
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.namespaces = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListNamespacesOutputResponse: Swift.Equatable {
    /// The information about the namespaces in this Amazon Web Services account. The response includes the namespace ARN, name, Amazon Web Services Region, notification email address, creation status, and identity store.
    public var namespaces: [QuickSightClientTypes.NamespaceInfoV2]?
    /// A unique pagination token that can be used in a subsequent request. Receiving NextToken in your response inticates that there is more data that can be returned. To receive the data, make another ListNamespaces API call with the returned token to retrieve the next page of data. Each token is valid for 24 hours. If you try to make a ListNamespaces API call with an expired token, you will receive a HTTP 400 InvalidNextTokenException error.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        namespaces: [QuickSightClientTypes.NamespaceInfoV2]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.namespaces = namespaces
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListNamespacesOutputResponseBody: Swift.Equatable {
    let namespaces: [QuickSightClientTypes.NamespaceInfoV2]?
    let nextToken: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension ListNamespacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespaces = "Namespaces"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespacesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.NamespaceInfoV2?].self, forKey: .namespaces)
        var namespacesDecoded0:[QuickSightClientTypes.NamespaceInfoV2]? = nil
        if let namespacesContainer = namespacesContainer {
            namespacesDecoded0 = [QuickSightClientTypes.NamespaceInfoV2]()
            for structure0 in namespacesContainer {
                if let structure0 = structure0 {
                    namespacesDecoded0?.append(structure0)
                }
            }
        }
        namespaces = namespacesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/resources/\(resourceArn.urlPercentEncoding())/tags"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want a list of tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.tags = output.tags
        } else {
            self.requestId = nil
            self.tags = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.
    public var tags: [QuickSightClientTypes.Tag]?

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        tags: [QuickSightClientTypes.Tag]? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [QuickSightClientTypes.Tag]?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QuickSightClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QuickSightClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension ListTemplateAliasesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-result".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListTemplateAliasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/aliases"
    }
}

public struct ListTemplateAliasesInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the template aliases that you're listing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The ID for the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.templateId = templateId
    }
}

struct ListTemplateAliasesInputBody: Swift.Equatable {
}

extension ListTemplateAliasesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTemplateAliasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTemplateAliasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTemplateAliasesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTemplateAliasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTemplateAliasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.requestId = output.requestId
            self.templateAliasList = output.templateAliasList
        } else {
            self.nextToken = nil
            self.requestId = nil
            self.templateAliasList = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListTemplateAliasesOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// A structure containing the list of the template's aliases.
    public var templateAliasList: [QuickSightClientTypes.TemplateAlias]?

    public init (
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateAliasList: [QuickSightClientTypes.TemplateAlias]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.templateAliasList = templateAliasList
    }
}

struct ListTemplateAliasesOutputResponseBody: Swift.Equatable {
    let templateAliasList: [QuickSightClientTypes.TemplateAlias]?
    let status: Swift.Int
    let requestId: Swift.String?
    let nextToken: Swift.String?
}

extension ListTemplateAliasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
        case templateAliasList = "TemplateAliasList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateAliasListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.TemplateAlias?].self, forKey: .templateAliasList)
        var templateAliasListDecoded0:[QuickSightClientTypes.TemplateAlias]? = nil
        if let templateAliasListContainer = templateAliasListContainer {
            templateAliasListDecoded0 = [QuickSightClientTypes.TemplateAlias]()
            for structure0 in templateAliasListContainer {
                if let structure0 = structure0 {
                    templateAliasListDecoded0?.append(structure0)
                }
            }
        }
        templateAliasList = templateAliasListDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTemplateVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListTemplateVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/versions"
    }
}

public struct ListTemplateVersionsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the templates that you're listing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The ID for the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.templateId = templateId
    }
}

struct ListTemplateVersionsInputBody: Swift.Equatable {
}

extension ListTemplateVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTemplateVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTemplateVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTemplateVersionsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTemplateVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTemplateVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.requestId = output.requestId
            self.templateVersionSummaryList = output.templateVersionSummaryList
        } else {
            self.nextToken = nil
            self.requestId = nil
            self.templateVersionSummaryList = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListTemplateVersionsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// A structure containing a list of all the versions of the specified template.
    public var templateVersionSummaryList: [QuickSightClientTypes.TemplateVersionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateVersionSummaryList: [QuickSightClientTypes.TemplateVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.templateVersionSummaryList = templateVersionSummaryList
    }
}

struct ListTemplateVersionsOutputResponseBody: Swift.Equatable {
    let templateVersionSummaryList: [QuickSightClientTypes.TemplateVersionSummary]?
    let nextToken: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension ListTemplateVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
        case templateVersionSummaryList = "TemplateVersionSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateVersionSummaryListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.TemplateVersionSummary?].self, forKey: .templateVersionSummaryList)
        var templateVersionSummaryListDecoded0:[QuickSightClientTypes.TemplateVersionSummary]? = nil
        if let templateVersionSummaryListContainer = templateVersionSummaryListContainer {
            templateVersionSummaryListDecoded0 = [QuickSightClientTypes.TemplateVersionSummary]()
            for structure0 in templateVersionSummaryListContainer {
                if let structure0 = structure0 {
                    templateVersionSummaryListDecoded0?.append(structure0)
                }
            }
        }
        templateVersionSummaryList = templateVersionSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListTemplatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-result".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates"
    }
}

public struct ListTemplatesInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the templates that you're listing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTemplatesInputBody: Swift.Equatable {
}

extension ListTemplatesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTemplatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTemplatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTemplatesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTemplatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.requestId = output.requestId
            self.templateSummaryList = output.templateSummaryList
        } else {
            self.nextToken = nil
            self.requestId = nil
            self.templateSummaryList = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListTemplatesOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// A structure containing information about the templates in the list.
    public var templateSummaryList: [QuickSightClientTypes.TemplateSummary]?

    public init (
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateSummaryList: [QuickSightClientTypes.TemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.templateSummaryList = templateSummaryList
    }
}

struct ListTemplatesOutputResponseBody: Swift.Equatable {
    let templateSummaryList: [QuickSightClientTypes.TemplateSummary]?
    let nextToken: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension ListTemplatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
        case templateSummaryList = "TemplateSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateSummaryListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.TemplateSummary?].self, forKey: .templateSummaryList)
        var templateSummaryListDecoded0:[QuickSightClientTypes.TemplateSummary]? = nil
        if let templateSummaryListContainer = templateSummaryListContainer {
            templateSummaryListDecoded0 = [QuickSightClientTypes.TemplateSummary]()
            for structure0 in templateSummaryListContainer {
                if let structure0 = structure0 {
                    templateSummaryListDecoded0?.append(structure0)
                }
            }
        }
        templateSummaryList = templateSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListThemeAliasesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-result".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListThemeAliasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let themeId = themeId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())/aliases"
    }
}

public struct ListThemeAliasesInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the theme aliases that you're listing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The ID for the theme.
    /// This member is required.
    public var themeId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        themeId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.themeId = themeId
    }
}

struct ListThemeAliasesInputBody: Swift.Equatable {
}

extension ListThemeAliasesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListThemeAliasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThemeAliasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListThemeAliasesOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThemeAliasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListThemeAliasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.requestId = output.requestId
            self.themeAliasList = output.themeAliasList
        } else {
            self.nextToken = nil
            self.requestId = nil
            self.themeAliasList = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListThemeAliasesOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// A structure containing the list of the theme's aliases.
    public var themeAliasList: [QuickSightClientTypes.ThemeAlias]?

    public init (
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeAliasList: [QuickSightClientTypes.ThemeAlias]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.themeAliasList = themeAliasList
    }
}

struct ListThemeAliasesOutputResponseBody: Swift.Equatable {
    let themeAliasList: [QuickSightClientTypes.ThemeAlias]?
    let status: Swift.Int
    let requestId: Swift.String?
    let nextToken: Swift.String?
}

extension ListThemeAliasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
        case themeAliasList = "ThemeAliasList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeAliasListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ThemeAlias?].self, forKey: .themeAliasList)
        var themeAliasListDecoded0:[QuickSightClientTypes.ThemeAlias]? = nil
        if let themeAliasListContainer = themeAliasListContainer {
            themeAliasListDecoded0 = [QuickSightClientTypes.ThemeAlias]()
            for structure0 in themeAliasListContainer {
                if let structure0 = structure0 {
                    themeAliasListDecoded0?.append(structure0)
                }
            }
        }
        themeAliasList = themeAliasListDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListThemeVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListThemeVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let themeId = themeId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())/versions"
    }
}

public struct ListThemeVersionsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the themes that you're listing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The ID for the theme.
    /// This member is required.
    public var themeId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        themeId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.themeId = themeId
    }
}

struct ListThemeVersionsInputBody: Swift.Equatable {
}

extension ListThemeVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListThemeVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThemeVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListThemeVersionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThemeVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListThemeVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.requestId = output.requestId
            self.themeVersionSummaryList = output.themeVersionSummaryList
        } else {
            self.nextToken = nil
            self.requestId = nil
            self.themeVersionSummaryList = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListThemeVersionsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// A structure containing a list of all the versions of the specified theme.
    public var themeVersionSummaryList: [QuickSightClientTypes.ThemeVersionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeVersionSummaryList: [QuickSightClientTypes.ThemeVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.themeVersionSummaryList = themeVersionSummaryList
    }
}

struct ListThemeVersionsOutputResponseBody: Swift.Equatable {
    let themeVersionSummaryList: [QuickSightClientTypes.ThemeVersionSummary]?
    let nextToken: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension ListThemeVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
        case themeVersionSummaryList = "ThemeVersionSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeVersionSummaryListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ThemeVersionSummary?].self, forKey: .themeVersionSummaryList)
        var themeVersionSummaryListDecoded0:[QuickSightClientTypes.ThemeVersionSummary]? = nil
        if let themeVersionSummaryListContainer = themeVersionSummaryListContainer {
            themeVersionSummaryListDecoded0 = [QuickSightClientTypes.ThemeVersionSummary]()
            for structure0 in themeVersionSummaryListContainer {
                if let structure0 = structure0 {
                    themeVersionSummaryListDecoded0?.append(structure0)
                }
            }
        }
        themeVersionSummaryList = themeVersionSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListThemesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let type = type {
                let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
                items.append(typeQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListThemesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes"
    }
}

public struct ListThemesInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the themes that you're listing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The type of themes that you want to list. Valid options include the following:
    ///
    /// * ALL (default)- Display all existing themes.
    ///
    /// * CUSTOM - Display only the themes created by people using Amazon QuickSight.
    ///
    /// * QUICKSIGHT - Display only the starting themes defined by Amazon QuickSight.
    public var type: QuickSightClientTypes.ThemeType?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: QuickSightClientTypes.ThemeType? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListThemesInputBody: Swift.Equatable {
}

extension ListThemesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListThemesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThemesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListThemesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThemesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListThemesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.requestId = output.requestId
            self.themeSummaryList = output.themeSummaryList
        } else {
            self.nextToken = nil
            self.requestId = nil
            self.themeSummaryList = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListThemesOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// Information about the themes in the list.
    public var themeSummaryList: [QuickSightClientTypes.ThemeSummary]?

    public init (
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeSummaryList: [QuickSightClientTypes.ThemeSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.themeSummaryList = themeSummaryList
    }
}

struct ListThemesOutputResponseBody: Swift.Equatable {
    let themeSummaryList: [QuickSightClientTypes.ThemeSummary]?
    let nextToken: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension ListThemesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
        case themeSummaryList = "ThemeSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeSummaryListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ThemeSummary?].self, forKey: .themeSummaryList)
        var themeSummaryListDecoded0:[QuickSightClientTypes.ThemeSummary]? = nil
        if let themeSummaryListContainer = themeSummaryListContainer {
            themeSummaryListDecoded0 = [QuickSightClientTypes.ThemeSummary]()
            for structure0 in themeSummaryListContainer {
                if let structure0 = structure0 {
                    themeSummaryListDecoded0?.append(structure0)
                }
            }
        }
        themeSummaryList = themeSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListUserGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListUserGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let userName = userName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/users/\(userName.urlPercentEncoding())/groups"
    }
}

public struct ListUserGroupsInput: Swift.Equatable {
    /// The Amazon Web Services account ID that the user is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to return from this request.
    public var maxResults: Swift.Int?
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon QuickSight user name that you want to list group memberships for.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
        self.userName = userName
    }
}

struct ListUserGroupsInputBody: Swift.Equatable {
}

extension ListUserGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListUserGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUserGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListUserGroupsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUserGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListUserGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groupList = output.groupList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.groupList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListUserGroupsOutputResponse: Swift.Equatable {
    /// The list of groups the user is a member of.
    public var groupList: [QuickSightClientTypes.Group]?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        groupList: [QuickSightClientTypes.Group]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.groupList = groupList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct ListUserGroupsOutputResponseBody: Swift.Equatable {
    let groupList: [QuickSightClientTypes.Group]?
    let nextToken: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension ListUserGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupList = "GroupList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Group?].self, forKey: .groupList)
        var groupListDecoded0:[QuickSightClientTypes.Group]? = nil
        if let groupListContainer = groupListContainer {
            groupListDecoded0 = [QuickSightClientTypes.Group]()
            for structure0 in groupListContainer {
                if let structure0 = structure0 {
                    groupListDecoded0?.append(structure0)
                }
            }
        }
        groupList = groupListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension ListUsersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/users"
    }
}

public struct ListUsersInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to return from this request.
    public var maxResults: Swift.Int?
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
    }
}

struct ListUsersInputBody: Swift.Equatable {
}

extension ListUsersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListUsersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUsersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListUsersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListUsersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.requestId = output.requestId
            self.userList = output.userList
        } else {
            self.nextToken = nil
            self.requestId = nil
            self.userList = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct ListUsersOutputResponse: Swift.Equatable {
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The list of users.
    public var userList: [QuickSightClientTypes.User]?

    public init (
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        userList: [QuickSightClientTypes.User]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.userList = userList
    }
}

struct ListUsersOutputResponseBody: Swift.Equatable {
    let userList: [QuickSightClientTypes.User]?
    let nextToken: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension ListUsersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
        case userList = "UserList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.User?].self, forKey: .userList)
        var userListDecoded0:[QuickSightClientTypes.User]? = nil
        if let userListContainer = userListContainer {
            userListDecoded0 = [QuickSightClientTypes.User]()
            for structure0 in userListContainer {
                if let structure0 = structure0 {
                    userListDecoded0?.append(structure0)
                }
            }
        }
        userList = userListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension QuickSightClientTypes.LoadingAnimation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of loading animation in free-form layout.
    public struct LoadingAnimation: Swift.Equatable {
        /// The visibility configuration of LoadingAnimation.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.visibility = visibility
        }
    }

}

extension QuickSightClientTypes.LocalNavigationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetSheetId = "TargetSheetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetSheetId = self.targetSheetId {
            try encodeContainer.encode(targetSheetId, forKey: .targetSheetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetSheetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetSheetId)
        targetSheetId = targetSheetIdDecoded
    }
}

extension QuickSightClientTypes {
    /// The navigation configuration for CustomActionNavigationOperation.
    public struct LocalNavigationConfiguration: Swift.Equatable {
        /// The sheet that is targeted for navigation in the same analysis.
        /// This member is required.
        public var targetSheetId: Swift.String?

        public init (
            targetSheetId: Swift.String? = nil
        )
        {
            self.targetSheetId = targetSheetId
        }
    }

}

extension QuickSightClientTypes.LogicalTable: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case dataTransforms = "DataTransforms"
        case source = "Source"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let dataTransforms = dataTransforms {
            var dataTransformsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataTransforms)
            for transformoperation0 in dataTransforms {
                try dataTransformsContainer.encode(transformoperation0)
            }
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let dataTransformsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.TransformOperation?].self, forKey: .dataTransforms)
        var dataTransformsDecoded0:[QuickSightClientTypes.TransformOperation]? = nil
        if let dataTransformsContainer = dataTransformsContainer {
            dataTransformsDecoded0 = [QuickSightClientTypes.TransformOperation]()
            for union0 in dataTransformsContainer {
                if let union0 = union0 {
                    dataTransformsDecoded0?.append(union0)
                }
            }
        }
        dataTransforms = dataTransformsDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LogicalTableSource.self, forKey: .source)
        source = sourceDecoded
    }
}

extension QuickSightClientTypes {
    /// A logical table is a unit that joins and that data transformations operate on. A logical table has a source, which can be either a physical table or result of a join. When a logical table points to a physical table, the logical table acts as a mutable copy of that physical table through transform operations.
    public struct LogicalTable: Swift.Equatable {
        /// A display name for the logical table.
        /// This member is required.
        public var alias: Swift.String?
        /// Transform operations that act on this logical table.
        public var dataTransforms: [QuickSightClientTypes.TransformOperation]?
        /// Source of this logical table.
        /// This member is required.
        public var source: QuickSightClientTypes.LogicalTableSource?

        public init (
            alias: Swift.String? = nil,
            dataTransforms: [QuickSightClientTypes.TransformOperation]? = nil,
            source: QuickSightClientTypes.LogicalTableSource? = nil
        )
        {
            self.alias = alias
            self.dataTransforms = dataTransforms
            self.source = source
        }
    }

}

extension QuickSightClientTypes.LogicalTableSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetArn = "DataSetArn"
        case joinInstruction = "JoinInstruction"
        case physicalTableId = "PhysicalTableId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSetArn = self.dataSetArn {
            try encodeContainer.encode(dataSetArn, forKey: .dataSetArn)
        }
        if let joinInstruction = self.joinInstruction {
            try encodeContainer.encode(joinInstruction, forKey: .joinInstruction)
        }
        if let physicalTableId = self.physicalTableId {
            try encodeContainer.encode(physicalTableId, forKey: .physicalTableId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let joinInstructionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.JoinInstruction.self, forKey: .joinInstruction)
        joinInstruction = joinInstructionDecoded
        let physicalTableIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .physicalTableId)
        physicalTableId = physicalTableIdDecoded
        let dataSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetArn)
        dataSetArn = dataSetArnDecoded
    }
}

extension QuickSightClientTypes {
    /// Information about the source of a logical table. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
    public struct LogicalTableSource: Swift.Equatable {
        /// The Amazon Resource Number (ARN) of the parent dataset.
        public var dataSetArn: Swift.String?
        /// Specifies the result of a join of two logical tables.
        public var joinInstruction: QuickSightClientTypes.JoinInstruction?
        /// Physical table ID.
        public var physicalTableId: Swift.String?

        public init (
            dataSetArn: Swift.String? = nil,
            joinInstruction: QuickSightClientTypes.JoinInstruction? = nil,
            physicalTableId: Swift.String? = nil
        )
        {
            self.dataSetArn = dataSetArn
            self.joinInstruction = joinInstruction
            self.physicalTableId = physicalTableId
        }
    }

}

extension QuickSightClientTypes.LongFormatText: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case plainText = "PlainText"
        case richText = "RichText"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let plainText = self.plainText {
            try encodeContainer.encode(plainText, forKey: .plainText)
        }
        if let richText = self.richText {
            try encodeContainer.encode(richText, forKey: .richText)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let plainTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .plainText)
        plainText = plainTextDecoded
        let richTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .richText)
        richText = richTextDecoded
    }
}

extension QuickSightClientTypes {
    /// The text format for a subtitle. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct LongFormatText: Swift.Equatable {
        /// Plain text format.
        public var plainText: Swift.String?
        /// Rich text. Examples of rich text include bold, underline, and italics.
        public var richText: Swift.String?

        public init (
            plainText: Swift.String? = nil,
            richText: Swift.String? = nil
        )
        {
            self.plainText = plainText
            self.richText = richText
        }
    }

}

extension QuickSightClientTypes.ManifestFileLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension QuickSightClientTypes {
    /// Amazon S3 manifest file location.
    public struct ManifestFileLocation: Swift.Equatable {
        /// Amazon S3 bucket.
        /// This member is required.
        public var bucket: Swift.String?
        /// Amazon S3 key that identifies an object.
        /// This member is required.
        public var key: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
        }
    }

}

extension QuickSightClientTypes {
    public enum MapZoomMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [MapZoomMode] {
            return [
                .auto,
                .manual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MapZoomMode(rawValue: rawValue) ?? MapZoomMode.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.MarginStyle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case show = "Show"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let show = self.show {
            try encodeContainer.encode(show, forKey: .show)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let showDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .show)
        show = showDecoded
    }
}

extension QuickSightClientTypes {
    /// The display options for margins around the outside edge of sheets.
    public struct MarginStyle: Swift.Equatable {
        /// This Boolean value controls whether to display sheet margins.
        public var show: Swift.Bool?

        public init (
            show: Swift.Bool? = nil
        )
        {
            self.show = show
        }
    }

}

extension QuickSightClientTypes.MariaDbParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for MariaDB.
    public struct MariaDbParameters: Swift.Equatable {
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int

        public init (
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.database = database
            self.host = host
            self.port = port
        }
    }

}

extension QuickSightClientTypes.MaximumLabelType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension QuickSightClientTypes {
    /// The maximum label of a data path label.
    public struct MaximumLabelType: Swift.Equatable {
        /// The visibility of the maximum label.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.visibility = visibility
        }
    }

}

extension QuickSightClientTypes.MaximumMinimumComputation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computationId = "ComputationId"
        case name = "Name"
        case time = "Time"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computationId = self.computationId {
            try encodeContainer.encode(computationId, forKey: .computationId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let time = self.time {
            try encodeContainer.encode(time, forKey: .time)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .computationId)
        computationId = computationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let timeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DimensionField.self, forKey: .time)
        time = timeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.MeasureField.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.MaximumMinimumComputationType.self, forKey: .type)
        type = typeDecoded
    }
}

extension QuickSightClientTypes {
    /// The maximum and minimum computation configuration.
    public struct MaximumMinimumComputation: Swift.Equatable {
        /// The ID for a computation.
        /// This member is required.
        public var computationId: Swift.String?
        /// The name of a computation.
        public var name: Swift.String?
        /// The time field that is used in a computation.
        /// This member is required.
        public var time: QuickSightClientTypes.DimensionField?
        /// The type of computation. Choose one of the following options:
        ///
        /// * MAXIMUM: A maximum computation.
        ///
        /// * MINIMUM: A minimum computation.
        /// This member is required.
        public var type: QuickSightClientTypes.MaximumMinimumComputationType?
        /// The value field that is used in a computation.
        public var value: QuickSightClientTypes.MeasureField?

        public init (
            computationId: Swift.String? = nil,
            name: Swift.String? = nil,
            time: QuickSightClientTypes.DimensionField? = nil,
            type: QuickSightClientTypes.MaximumMinimumComputationType? = nil,
            value: QuickSightClientTypes.MeasureField? = nil
        )
        {
            self.computationId = computationId
            self.name = name
            self.time = time
            self.type = type
            self.value = value
        }
    }

}

extension QuickSightClientTypes {
    public enum MaximumMinimumComputationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case maximum
        case minimum
        case sdkUnknown(Swift.String)

        public static var allCases: [MaximumMinimumComputationType] {
            return [
                .maximum,
                .minimum,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .maximum: return "MAXIMUM"
            case .minimum: return "MINIMUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MaximumMinimumComputationType(rawValue: rawValue) ?? MaximumMinimumComputationType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.MeasureField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculatedMeasureField = "CalculatedMeasureField"
        case categoricalMeasureField = "CategoricalMeasureField"
        case dateMeasureField = "DateMeasureField"
        case numericalMeasureField = "NumericalMeasureField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let calculatedMeasureField = self.calculatedMeasureField {
            try encodeContainer.encode(calculatedMeasureField, forKey: .calculatedMeasureField)
        }
        if let categoricalMeasureField = self.categoricalMeasureField {
            try encodeContainer.encode(categoricalMeasureField, forKey: .categoricalMeasureField)
        }
        if let dateMeasureField = self.dateMeasureField {
            try encodeContainer.encode(dateMeasureField, forKey: .dateMeasureField)
        }
        if let numericalMeasureField = self.numericalMeasureField {
            try encodeContainer.encode(numericalMeasureField, forKey: .numericalMeasureField)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numericalMeasureFieldDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumericalMeasureField.self, forKey: .numericalMeasureField)
        numericalMeasureField = numericalMeasureFieldDecoded
        let categoricalMeasureFieldDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CategoricalMeasureField.self, forKey: .categoricalMeasureField)
        categoricalMeasureField = categoricalMeasureFieldDecoded
        let dateMeasureFieldDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DateMeasureField.self, forKey: .dateMeasureField)
        dateMeasureField = dateMeasureFieldDecoded
        let calculatedMeasureFieldDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CalculatedMeasureField.self, forKey: .calculatedMeasureField)
        calculatedMeasureField = calculatedMeasureFieldDecoded
    }
}

extension QuickSightClientTypes {
    /// The measure (metric) type field.
    public struct MeasureField: Swift.Equatable {
        /// The calculated measure field only used in pivot tables.
        public var calculatedMeasureField: QuickSightClientTypes.CalculatedMeasureField?
        /// The measure type field with categorical type columns.
        public var categoricalMeasureField: QuickSightClientTypes.CategoricalMeasureField?
        /// The measure type field with date type columns.
        public var dateMeasureField: QuickSightClientTypes.DateMeasureField?
        /// The measure type field with numerical type columns.
        public var numericalMeasureField: QuickSightClientTypes.NumericalMeasureField?

        public init (
            calculatedMeasureField: QuickSightClientTypes.CalculatedMeasureField? = nil,
            categoricalMeasureField: QuickSightClientTypes.CategoricalMeasureField? = nil,
            dateMeasureField: QuickSightClientTypes.DateMeasureField? = nil,
            numericalMeasureField: QuickSightClientTypes.NumericalMeasureField? = nil
        )
        {
            self.calculatedMeasureField = calculatedMeasureField
            self.categoricalMeasureField = categoricalMeasureField
            self.dateMeasureField = dateMeasureField
            self.numericalMeasureField = numericalMeasureField
        }
    }

}

extension QuickSightClientTypes.MemberIdArnPair: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArn = "MemberArn"
        case memberId = "MemberId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberArn = self.memberArn {
            try encodeContainer.encode(memberArn, forKey: .memberArn)
        }
        if let memberId = self.memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberId)
        memberId = memberIdDecoded
        let memberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberArn)
        memberArn = memberArnDecoded
    }
}

extension QuickSightClientTypes {
    /// An object that consists of a member Amazon Resource Name (ARN) and a member ID.
    public struct MemberIdArnPair: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the member.
        public var memberArn: Swift.String?
        /// The ID of the member.
        public var memberId: Swift.String?

        public init (
            memberArn: Swift.String? = nil,
            memberId: Swift.String? = nil
        )
        {
            self.memberArn = memberArn
            self.memberId = memberId
        }
    }

}

extension QuickSightClientTypes {
    public enum MemberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case analysis
        case dashboard
        case dataset
        case sdkUnknown(Swift.String)

        public static var allCases: [MemberType] {
            return [
                .analysis,
                .dashboard,
                .dataset,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .analysis: return "ANALYSIS"
            case .dashboard: return "DASHBOARD"
            case .dataset: return "DATASET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MemberType(rawValue: rawValue) ?? MemberType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.MetricComparisonComputation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computationId = "ComputationId"
        case fromValue = "FromValue"
        case name = "Name"
        case targetValue = "TargetValue"
        case time = "Time"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computationId = self.computationId {
            try encodeContainer.encode(computationId, forKey: .computationId)
        }
        if let fromValue = self.fromValue {
            try encodeContainer.encode(fromValue, forKey: .fromValue)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let targetValue = self.targetValue {
            try encodeContainer.encode(targetValue, forKey: .targetValue)
        }
        if let time = self.time {
            try encodeContainer.encode(time, forKey: .time)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .computationId)
        computationId = computationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let timeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DimensionField.self, forKey: .time)
        time = timeDecoded
        let fromValueDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.MeasureField.self, forKey: .fromValue)
        fromValue = fromValueDecoded
        let targetValueDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.MeasureField.self, forKey: .targetValue)
        targetValue = targetValueDecoded
    }
}

extension QuickSightClientTypes {
    /// The metric comparison computation configuration.
    public struct MetricComparisonComputation: Swift.Equatable {
        /// The ID for a computation.
        /// This member is required.
        public var computationId: Swift.String?
        /// The field that is used in a metric comparison from value setup.
        /// This member is required.
        public var fromValue: QuickSightClientTypes.MeasureField?
        /// The name of a computation.
        public var name: Swift.String?
        /// The field that is used in a metric comparison to value setup.
        /// This member is required.
        public var targetValue: QuickSightClientTypes.MeasureField?
        /// The time field that is used in a computation.
        /// This member is required.
        public var time: QuickSightClientTypes.DimensionField?

        public init (
            computationId: Swift.String? = nil,
            fromValue: QuickSightClientTypes.MeasureField? = nil,
            name: Swift.String? = nil,
            targetValue: QuickSightClientTypes.MeasureField? = nil,
            time: QuickSightClientTypes.DimensionField? = nil
        )
        {
            self.computationId = computationId
            self.fromValue = fromValue
            self.name = name
            self.targetValue = targetValue
            self.time = time
        }
    }

}

extension QuickSightClientTypes.MinimumLabelType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension QuickSightClientTypes {
    /// The minimum label of a data path label.
    public struct MinimumLabelType: Swift.Equatable {
        /// The visibility of the minimum label.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.visibility = visibility
        }
    }

}

extension QuickSightClientTypes.MissingDataConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case treatmentOption = "TreatmentOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let treatmentOption = self.treatmentOption {
            try encodeContainer.encode(treatmentOption.rawValue, forKey: .treatmentOption)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let treatmentOptionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.MissingDataTreatmentOption.self, forKey: .treatmentOption)
        treatmentOption = treatmentOptionDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration options that determine how missing data is treated during the rendering of a line chart.
    public struct MissingDataConfiguration: Swift.Equatable {
        /// The treatment option that determines how missing data should be rendered. Choose from the following options:
        ///
        /// * INTERPOLATE: Interpolate missing values between the prior and the next known value.
        ///
        /// * SHOW_AS_ZERO: Show missing values as the value 0.
        ///
        /// * SHOW_AS_BLANK: Display a blank space when rendering missing data.
        public var treatmentOption: QuickSightClientTypes.MissingDataTreatmentOption?

        public init (
            treatmentOption: QuickSightClientTypes.MissingDataTreatmentOption? = nil
        )
        {
            self.treatmentOption = treatmentOption
        }
    }

}

extension QuickSightClientTypes {
    public enum MissingDataTreatmentOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case interpolate
        case showAsBlank
        case showAsZero
        case sdkUnknown(Swift.String)

        public static var allCases: [MissingDataTreatmentOption] {
            return [
                .interpolate,
                .showAsBlank,
                .showAsZero,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .interpolate: return "INTERPOLATE"
            case .showAsBlank: return "SHOW_AS_BLANK"
            case .showAsZero: return "SHOW_AS_ZERO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MissingDataTreatmentOption(rawValue: rawValue) ?? MissingDataTreatmentOption.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.MySqlParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for MySQL.
    public struct MySqlParameters: Swift.Equatable {
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int

        public init (
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.database = database
            self.host = host
            self.port = port
        }
    }

}

extension QuickSightClientTypes.NamespaceError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NamespaceErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QuickSightClientTypes {
    /// Errors that occur during namespace creation.
    public struct NamespaceError: Swift.Equatable {
        /// The message for the error.
        public var message: Swift.String?
        /// The error type.
        public var type: QuickSightClientTypes.NamespaceErrorType?

        public init (
            message: Swift.String? = nil,
            type: QuickSightClientTypes.NamespaceErrorType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }

}

extension QuickSightClientTypes {
    public enum NamespaceErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalServiceError
        case permissionDenied
        case sdkUnknown(Swift.String)

        public static var allCases: [NamespaceErrorType] {
            return [
                .internalServiceError,
                .permissionDenied,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalServiceError: return "INTERNAL_SERVICE_ERROR"
            case .permissionDenied: return "PERMISSION_DENIED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NamespaceErrorType(rawValue: rawValue) ?? NamespaceErrorType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.NamespaceInfoV2: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case capacityRegion = "CapacityRegion"
        case creationStatus = "CreationStatus"
        case identityStore = "IdentityStore"
        case name = "Name"
        case namespaceError = "NamespaceError"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let capacityRegion = self.capacityRegion {
            try encodeContainer.encode(capacityRegion, forKey: .capacityRegion)
        }
        if let creationStatus = self.creationStatus {
            try encodeContainer.encode(creationStatus.rawValue, forKey: .creationStatus)
        }
        if let identityStore = self.identityStore {
            try encodeContainer.encode(identityStore.rawValue, forKey: .identityStore)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespaceError = self.namespaceError {
            try encodeContainer.encode(namespaceError, forKey: .namespaceError)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let capacityRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacityRegion)
        capacityRegion = capacityRegionDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NamespaceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let identityStoreDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IdentityStore.self, forKey: .identityStore)
        identityStore = identityStoreDecoded
        let namespaceErrorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NamespaceError.self, forKey: .namespaceError)
        namespaceError = namespaceErrorDecoded
    }
}

extension QuickSightClientTypes {
    /// The error type.
    public struct NamespaceInfoV2: Swift.Equatable {
        /// The namespace ARN.
        public var arn: Swift.String?
        /// The namespace Amazon Web Services Region.
        public var capacityRegion: Swift.String?
        /// The creation status of a namespace that is not yet completely created.
        public var creationStatus: QuickSightClientTypes.NamespaceStatus?
        /// The identity store used for the namespace.
        public var identityStore: QuickSightClientTypes.IdentityStore?
        /// The name of the error.
        public var name: Swift.String?
        /// An error that occurred when the namespace was created.
        public var namespaceError: QuickSightClientTypes.NamespaceError?

        public init (
            arn: Swift.String? = nil,
            capacityRegion: Swift.String? = nil,
            creationStatus: QuickSightClientTypes.NamespaceStatus? = nil,
            identityStore: QuickSightClientTypes.IdentityStore? = nil,
            name: Swift.String? = nil,
            namespaceError: QuickSightClientTypes.NamespaceError? = nil
        )
        {
            self.arn = arn
            self.capacityRegion = capacityRegion
            self.creationStatus = creationStatus
            self.identityStore = identityStore
            self.name = name
            self.namespaceError = namespaceError
        }
    }

}

extension QuickSightClientTypes {
    public enum NamespaceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case creating
        case deleting
        case nonRetryableFailure
        case retryableFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [NamespaceStatus] {
            return [
                .created,
                .creating,
                .deleting,
                .nonRetryableFailure,
                .retryableFailure,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .nonRetryableFailure: return "NON_RETRYABLE_FAILURE"
            case .retryableFailure: return "RETRYABLE_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NamespaceStatus(rawValue: rawValue) ?? NamespaceStatus.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.NegativeValueConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayMode = "DisplayMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayMode = self.displayMode {
            try encodeContainer.encode(displayMode.rawValue, forKey: .displayMode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayModeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NegativeValueDisplayMode.self, forKey: .displayMode)
        displayMode = displayModeDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the negative value configuration.
    public struct NegativeValueConfiguration: Swift.Equatable {
        /// Determines the display mode of the negative value configuration.
        /// This member is required.
        public var displayMode: QuickSightClientTypes.NegativeValueDisplayMode?

        public init (
            displayMode: QuickSightClientTypes.NegativeValueDisplayMode? = nil
        )
        {
            self.displayMode = displayMode
        }
    }

}

extension QuickSightClientTypes {
    public enum NegativeValueDisplayMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case negative
        case positive
        case sdkUnknown(Swift.String)

        public static var allCases: [NegativeValueDisplayMode] {
            return [
                .negative,
                .positive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .negative: return "NEGATIVE"
            case .positive: return "POSITIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NegativeValueDisplayMode(rawValue: rawValue) ?? NegativeValueDisplayMode.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.NullValueFormatConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nullString = "NullString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nullString = self.nullString {
            try encodeContainer.encode(nullString, forKey: .nullString)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nullStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nullString)
        nullString = nullStringDecoded
    }
}

extension QuickSightClientTypes.NullValueFormatConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NullValueFormatConfiguration(nullString: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {
    /// The options that determine the null value format configuration.
    public struct NullValueFormatConfiguration: Swift.Equatable {
        /// Determines the null string of null values.
        /// This member is required.
        public var nullString: Swift.String?

        public init (
            nullString: Swift.String? = nil
        )
        {
            self.nullString = nullString
        }
    }

}

extension QuickSightClientTypes.NumberDisplayFormatConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decimalPlacesConfiguration = "DecimalPlacesConfiguration"
        case negativeValueConfiguration = "NegativeValueConfiguration"
        case nullValueFormatConfiguration = "NullValueFormatConfiguration"
        case numberScale = "NumberScale"
        case `prefix` = "Prefix"
        case separatorConfiguration = "SeparatorConfiguration"
        case suffix = "Suffix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decimalPlacesConfiguration = self.decimalPlacesConfiguration {
            try encodeContainer.encode(decimalPlacesConfiguration, forKey: .decimalPlacesConfiguration)
        }
        if let negativeValueConfiguration = self.negativeValueConfiguration {
            try encodeContainer.encode(negativeValueConfiguration, forKey: .negativeValueConfiguration)
        }
        if let nullValueFormatConfiguration = self.nullValueFormatConfiguration {
            try encodeContainer.encode(nullValueFormatConfiguration, forKey: .nullValueFormatConfiguration)
        }
        if let numberScale = self.numberScale {
            try encodeContainer.encode(numberScale.rawValue, forKey: .numberScale)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
        if let separatorConfiguration = self.separatorConfiguration {
            try encodeContainer.encode(separatorConfiguration, forKey: .separatorConfiguration)
        }
        if let suffix = self.suffix {
            try encodeContainer.encode(suffix, forKey: .suffix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let suffixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suffix)
        suffix = suffixDecoded
        let separatorConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumericSeparatorConfiguration.self, forKey: .separatorConfiguration)
        separatorConfiguration = separatorConfigurationDecoded
        let decimalPlacesConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DecimalPlacesConfiguration.self, forKey: .decimalPlacesConfiguration)
        decimalPlacesConfiguration = decimalPlacesConfigurationDecoded
        let numberScaleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumberScale.self, forKey: .numberScale)
        numberScale = numberScaleDecoded
        let negativeValueConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NegativeValueConfiguration.self, forKey: .negativeValueConfiguration)
        negativeValueConfiguration = negativeValueConfigurationDecoded
        let nullValueFormatConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NullValueFormatConfiguration.self, forKey: .nullValueFormatConfiguration)
        nullValueFormatConfiguration = nullValueFormatConfigurationDecoded
    }
}

extension QuickSightClientTypes.NumberDisplayFormatConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NumberDisplayFormatConfiguration(decimalPlacesConfiguration: \(Swift.String(describing: decimalPlacesConfiguration)), negativeValueConfiguration: \(Swift.String(describing: negativeValueConfiguration)), nullValueFormatConfiguration: \(Swift.String(describing: nullValueFormatConfiguration)), numberScale: \(Swift.String(describing: numberScale)), separatorConfiguration: \(Swift.String(describing: separatorConfiguration)), prefix: \"CONTENT_REDACTED\", suffix: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {
    /// The options that determine the number display format configuration.
    public struct NumberDisplayFormatConfiguration: Swift.Equatable {
        /// The option that determines the decimal places configuration.
        public var decimalPlacesConfiguration: QuickSightClientTypes.DecimalPlacesConfiguration?
        /// The options that determine the negative value configuration.
        public var negativeValueConfiguration: QuickSightClientTypes.NegativeValueConfiguration?
        /// The options that determine the null value format configuration.
        public var nullValueFormatConfiguration: QuickSightClientTypes.NullValueFormatConfiguration?
        /// Determines the number scale value of the number format.
        public var numberScale: QuickSightClientTypes.NumberScale?
        /// Determines the prefix value of the number format.
        public var `prefix`: Swift.String?
        /// The options that determine the numeric separator configuration.
        public var separatorConfiguration: QuickSightClientTypes.NumericSeparatorConfiguration?
        /// Determines the suffix value of the number format.
        public var suffix: Swift.String?

        public init (
            decimalPlacesConfiguration: QuickSightClientTypes.DecimalPlacesConfiguration? = nil,
            negativeValueConfiguration: QuickSightClientTypes.NegativeValueConfiguration? = nil,
            nullValueFormatConfiguration: QuickSightClientTypes.NullValueFormatConfiguration? = nil,
            numberScale: QuickSightClientTypes.NumberScale? = nil,
            `prefix`: Swift.String? = nil,
            separatorConfiguration: QuickSightClientTypes.NumericSeparatorConfiguration? = nil,
            suffix: Swift.String? = nil
        )
        {
            self.decimalPlacesConfiguration = decimalPlacesConfiguration
            self.negativeValueConfiguration = negativeValueConfiguration
            self.nullValueFormatConfiguration = nullValueFormatConfiguration
            self.numberScale = numberScale
            self.`prefix` = `prefix`
            self.separatorConfiguration = separatorConfiguration
            self.suffix = suffix
        }
    }

}

extension QuickSightClientTypes.NumberFormatConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case formatConfiguration = "FormatConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let formatConfiguration = self.formatConfiguration {
            try encodeContainer.encode(formatConfiguration, forKey: .formatConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumericFormatConfiguration.self, forKey: .formatConfiguration)
        formatConfiguration = formatConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// Formatting configuration for number fields.
    public struct NumberFormatConfiguration: Swift.Equatable {
        /// The options that determine the numeric format configuration.
        public var formatConfiguration: QuickSightClientTypes.NumericFormatConfiguration?

        public init (
            formatConfiguration: QuickSightClientTypes.NumericFormatConfiguration? = nil
        )
        {
            self.formatConfiguration = formatConfiguration
        }
    }

}

extension QuickSightClientTypes {
    public enum NumberScale: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case billions
        case millions
        case `none`
        case thousands
        case trillions
        case sdkUnknown(Swift.String)

        public static var allCases: [NumberScale] {
            return [
                .auto,
                .billions,
                .millions,
                .none,
                .thousands,
                .trillions,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .billions: return "BILLIONS"
            case .millions: return "MILLIONS"
            case .none: return "NONE"
            case .thousands: return "THOUSANDS"
            case .trillions: return "TRILLIONS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NumberScale(rawValue: rawValue) ?? NumberScale.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.NumericAxisOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case range = "Range"
        case scale = "Scale"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let range = self.range {
            try encodeContainer.encode(range, forKey: .range)
        }
        if let scale = self.scale {
            try encodeContainer.encode(scale, forKey: .scale)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scaleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisScale.self, forKey: .scale)
        scale = scaleDecoded
        let rangeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisDisplayRange.self, forKey: .range)
        range = rangeDecoded
    }
}

extension QuickSightClientTypes {
    /// The options for an axis with a numeric field.
    public struct NumericAxisOptions: Swift.Equatable {
        /// The range setup of a numeric axis.
        public var range: QuickSightClientTypes.AxisDisplayRange?
        /// The scale setup of a numeric axis.
        public var scale: QuickSightClientTypes.AxisScale?

        public init (
            range: QuickSightClientTypes.AxisDisplayRange? = nil,
            scale: QuickSightClientTypes.AxisScale? = nil
        )
        {
            self.range = range
            self.scale = scale
        }
    }

}

extension QuickSightClientTypes.NumericEqualityDrillDownFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case column = "Column"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let column = self.column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if value != 0.0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .column)
        column = columnDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value) ?? 0.0
        value = valueDecoded
    }
}

extension QuickSightClientTypes {
    /// The category drill down filter.
    public struct NumericEqualityDrillDownFilter: Swift.Equatable {
        /// The column that the filter is applied to.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The value of the double input numeric drill down filter.
        /// This member is required.
        public var value: Swift.Double

        public init (
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            value: Swift.Double = 0.0
        )
        {
            self.column = column
            self.value = value
        }
    }

}

extension QuickSightClientTypes.NumericEqualityFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationFunction = "AggregationFunction"
        case column = "Column"
        case filterId = "FilterId"
        case matchOperator = "MatchOperator"
        case nullOption = "NullOption"
        case parameterName = "ParameterName"
        case selectAllOptions = "SelectAllOptions"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationFunction = self.aggregationFunction {
            try encodeContainer.encode(aggregationFunction, forKey: .aggregationFunction)
        }
        if let column = self.column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let filterId = self.filterId {
            try encodeContainer.encode(filterId, forKey: .filterId)
        }
        if let matchOperator = self.matchOperator {
            try encodeContainer.encode(matchOperator.rawValue, forKey: .matchOperator)
        }
        if let nullOption = self.nullOption {
            try encodeContainer.encode(nullOption.rawValue, forKey: .nullOption)
        }
        if let parameterName = self.parameterName {
            try encodeContainer.encode(parameterName, forKey: .parameterName)
        }
        if let selectAllOptions = self.selectAllOptions {
            try encodeContainer.encode(selectAllOptions.rawValue, forKey: .selectAllOptions)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterId)
        filterId = filterIdDecoded
        let columnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .column)
        column = columnDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
        let selectAllOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumericFilterSelectAllOptions.self, forKey: .selectAllOptions)
        selectAllOptions = selectAllOptionsDecoded
        let matchOperatorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumericEqualityMatchOperator.self, forKey: .matchOperator)
        matchOperator = matchOperatorDecoded
        let aggregationFunctionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AggregationFunction.self, forKey: .aggregationFunction)
        aggregationFunction = aggregationFunctionDecoded
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let nullOptionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterNullOption.self, forKey: .nullOption)
        nullOption = nullOptionDecoded
    }
}

extension QuickSightClientTypes {
    /// A NumericEqualityFilter filters values that are equal to the specified value.
    public struct NumericEqualityFilter: Swift.Equatable {
        /// The aggregation function of the filter.
        public var aggregationFunction: QuickSightClientTypes.AggregationFunction?
        /// The column that the filter is applied to.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        /// This member is required.
        public var filterId: Swift.String?
        /// The match operator that is used to determine if a filter should be applied.
        /// This member is required.
        public var matchOperator: QuickSightClientTypes.NumericEqualityMatchOperator?
        /// This option determines how null values should be treated when filtering data.
        ///
        /// * ALL_VALUES: Include null values in filtered results.
        ///
        /// * NULLS_ONLY: Only include null values in filtered results.
        ///
        /// * NON_NULLS_ONLY: Exclude null values from filtered results.
        /// This member is required.
        public var nullOption: QuickSightClientTypes.FilterNullOption?
        /// The parameter whose value should be used for the filter value.
        public var parameterName: Swift.String?
        /// Select all of the values. Null is not the assigned value of select all.
        ///
        /// * FILTER_ALL_VALUES
        public var selectAllOptions: QuickSightClientTypes.NumericFilterSelectAllOptions?
        /// The input value.
        public var value: Swift.Double?

        public init (
            aggregationFunction: QuickSightClientTypes.AggregationFunction? = nil,
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            filterId: Swift.String? = nil,
            matchOperator: QuickSightClientTypes.NumericEqualityMatchOperator? = nil,
            nullOption: QuickSightClientTypes.FilterNullOption? = nil,
            parameterName: Swift.String? = nil,
            selectAllOptions: QuickSightClientTypes.NumericFilterSelectAllOptions? = nil,
            value: Swift.Double? = nil
        )
        {
            self.aggregationFunction = aggregationFunction
            self.column = column
            self.filterId = filterId
            self.matchOperator = matchOperator
            self.nullOption = nullOption
            self.parameterName = parameterName
            self.selectAllOptions = selectAllOptions
            self.value = value
        }
    }

}

extension QuickSightClientTypes {
    public enum NumericEqualityMatchOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case doesNotEqual
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [NumericEqualityMatchOperator] {
            return [
                .doesNotEqual,
                .equals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .doesNotEqual: return "DOES_NOT_EQUAL"
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NumericEqualityMatchOperator(rawValue: rawValue) ?? NumericEqualityMatchOperator.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum NumericFilterSelectAllOptions: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case filterAllValues
        case sdkUnknown(Swift.String)

        public static var allCases: [NumericFilterSelectAllOptions] {
            return [
                .filterAllValues,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .filterAllValues: return "FILTER_ALL_VALUES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NumericFilterSelectAllOptions(rawValue: rawValue) ?? NumericFilterSelectAllOptions.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.NumericFormatConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyDisplayFormatConfiguration = "CurrencyDisplayFormatConfiguration"
        case numberDisplayFormatConfiguration = "NumberDisplayFormatConfiguration"
        case percentageDisplayFormatConfiguration = "PercentageDisplayFormatConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyDisplayFormatConfiguration = self.currencyDisplayFormatConfiguration {
            try encodeContainer.encode(currencyDisplayFormatConfiguration, forKey: .currencyDisplayFormatConfiguration)
        }
        if let numberDisplayFormatConfiguration = self.numberDisplayFormatConfiguration {
            try encodeContainer.encode(numberDisplayFormatConfiguration, forKey: .numberDisplayFormatConfiguration)
        }
        if let percentageDisplayFormatConfiguration = self.percentageDisplayFormatConfiguration {
            try encodeContainer.encode(percentageDisplayFormatConfiguration, forKey: .percentageDisplayFormatConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberDisplayFormatConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumberDisplayFormatConfiguration.self, forKey: .numberDisplayFormatConfiguration)
        numberDisplayFormatConfiguration = numberDisplayFormatConfigurationDecoded
        let currencyDisplayFormatConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CurrencyDisplayFormatConfiguration.self, forKey: .currencyDisplayFormatConfiguration)
        currencyDisplayFormatConfiguration = currencyDisplayFormatConfigurationDecoded
        let percentageDisplayFormatConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PercentageDisplayFormatConfiguration.self, forKey: .percentageDisplayFormatConfiguration)
        percentageDisplayFormatConfiguration = percentageDisplayFormatConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the numeric format configuration. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct NumericFormatConfiguration: Swift.Equatable {
        /// The options that determine the currency display format configuration.
        public var currencyDisplayFormatConfiguration: QuickSightClientTypes.CurrencyDisplayFormatConfiguration?
        /// The options that determine the number display format configuration.
        public var numberDisplayFormatConfiguration: QuickSightClientTypes.NumberDisplayFormatConfiguration?
        /// The options that determine the percentage display format configuration.
        public var percentageDisplayFormatConfiguration: QuickSightClientTypes.PercentageDisplayFormatConfiguration?

        public init (
            currencyDisplayFormatConfiguration: QuickSightClientTypes.CurrencyDisplayFormatConfiguration? = nil,
            numberDisplayFormatConfiguration: QuickSightClientTypes.NumberDisplayFormatConfiguration? = nil,
            percentageDisplayFormatConfiguration: QuickSightClientTypes.PercentageDisplayFormatConfiguration? = nil
        )
        {
            self.currencyDisplayFormatConfiguration = currencyDisplayFormatConfiguration
            self.numberDisplayFormatConfiguration = numberDisplayFormatConfiguration
            self.percentageDisplayFormatConfiguration = percentageDisplayFormatConfiguration
        }
    }

}

extension QuickSightClientTypes.NumericRangeFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationFunction = "AggregationFunction"
        case column = "Column"
        case filterId = "FilterId"
        case includeMaximum = "IncludeMaximum"
        case includeMinimum = "IncludeMinimum"
        case nullOption = "NullOption"
        case rangeMaximum = "RangeMaximum"
        case rangeMinimum = "RangeMinimum"
        case selectAllOptions = "SelectAllOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationFunction = self.aggregationFunction {
            try encodeContainer.encode(aggregationFunction, forKey: .aggregationFunction)
        }
        if let column = self.column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let filterId = self.filterId {
            try encodeContainer.encode(filterId, forKey: .filterId)
        }
        if let includeMaximum = self.includeMaximum {
            try encodeContainer.encode(includeMaximum, forKey: .includeMaximum)
        }
        if let includeMinimum = self.includeMinimum {
            try encodeContainer.encode(includeMinimum, forKey: .includeMinimum)
        }
        if let nullOption = self.nullOption {
            try encodeContainer.encode(nullOption.rawValue, forKey: .nullOption)
        }
        if let rangeMaximum = self.rangeMaximum {
            try encodeContainer.encode(rangeMaximum, forKey: .rangeMaximum)
        }
        if let rangeMinimum = self.rangeMinimum {
            try encodeContainer.encode(rangeMinimum, forKey: .rangeMinimum)
        }
        if let selectAllOptions = self.selectAllOptions {
            try encodeContainer.encode(selectAllOptions.rawValue, forKey: .selectAllOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterId)
        filterId = filterIdDecoded
        let columnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .column)
        column = columnDecoded
        let includeMinimumDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeMinimum)
        includeMinimum = includeMinimumDecoded
        let includeMaximumDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeMaximum)
        includeMaximum = includeMaximumDecoded
        let rangeMinimumDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumericRangeFilterValue.self, forKey: .rangeMinimum)
        rangeMinimum = rangeMinimumDecoded
        let rangeMaximumDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumericRangeFilterValue.self, forKey: .rangeMaximum)
        rangeMaximum = rangeMaximumDecoded
        let selectAllOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumericFilterSelectAllOptions.self, forKey: .selectAllOptions)
        selectAllOptions = selectAllOptionsDecoded
        let aggregationFunctionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AggregationFunction.self, forKey: .aggregationFunction)
        aggregationFunction = aggregationFunctionDecoded
        let nullOptionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterNullOption.self, forKey: .nullOption)
        nullOption = nullOptionDecoded
    }
}

extension QuickSightClientTypes {
    /// A NumericRangeFilter filters values that are within the value range.
    public struct NumericRangeFilter: Swift.Equatable {
        /// The aggregation function of the filter.
        public var aggregationFunction: QuickSightClientTypes.AggregationFunction?
        /// The column that the filter is applied to.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        /// This member is required.
        public var filterId: Swift.String?
        /// Determines whether the maximum value in the filter value range should be included in the filtered results.
        public var includeMaximum: Swift.Bool?
        /// Determines whether the minimum value in the filter value range should be included in the filtered results.
        public var includeMinimum: Swift.Bool?
        /// This option determines how null values should be treated when filtering data.
        ///
        /// * ALL_VALUES: Include null values in filtered results.
        ///
        /// * NULLS_ONLY: Only include null values in filtered results.
        ///
        /// * NON_NULLS_ONLY: Exclude null values from filtered results.
        /// This member is required.
        public var nullOption: QuickSightClientTypes.FilterNullOption?
        /// The maximum value for the filter value range.
        public var rangeMaximum: QuickSightClientTypes.NumericRangeFilterValue?
        /// The minimum value for the filter value range.
        public var rangeMinimum: QuickSightClientTypes.NumericRangeFilterValue?
        /// Select all of the values. Null is not the assigned value of select all.
        ///
        /// * FILTER_ALL_VALUES
        public var selectAllOptions: QuickSightClientTypes.NumericFilterSelectAllOptions?

        public init (
            aggregationFunction: QuickSightClientTypes.AggregationFunction? = nil,
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            filterId: Swift.String? = nil,
            includeMaximum: Swift.Bool? = nil,
            includeMinimum: Swift.Bool? = nil,
            nullOption: QuickSightClientTypes.FilterNullOption? = nil,
            rangeMaximum: QuickSightClientTypes.NumericRangeFilterValue? = nil,
            rangeMinimum: QuickSightClientTypes.NumericRangeFilterValue? = nil,
            selectAllOptions: QuickSightClientTypes.NumericFilterSelectAllOptions? = nil
        )
        {
            self.aggregationFunction = aggregationFunction
            self.column = column
            self.filterId = filterId
            self.includeMaximum = includeMaximum
            self.includeMinimum = includeMinimum
            self.nullOption = nullOption
            self.rangeMaximum = rangeMaximum
            self.rangeMinimum = rangeMinimum
            self.selectAllOptions = selectAllOptions
        }
    }

}

extension QuickSightClientTypes.NumericRangeFilterValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameter = "Parameter"
        case staticValue = "StaticValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameter = self.parameter {
            try encodeContainer.encode(parameter, forKey: .parameter)
        }
        if let staticValue = self.staticValue {
            try encodeContainer.encode(staticValue, forKey: .staticValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let staticValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .staticValue)
        staticValue = staticValueDecoded
        let parameterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameter)
        parameter = parameterDecoded
    }
}

extension QuickSightClientTypes {
    /// The value input pf the numeric range filter.
    public struct NumericRangeFilterValue: Swift.Equatable {
        /// The parameter that is used in the numeric range.
        public var parameter: Swift.String?
        /// The static value of the numeric range filter.
        public var staticValue: Swift.Double?

        public init (
            parameter: Swift.String? = nil,
            staticValue: Swift.Double? = nil
        )
        {
            self.parameter = parameter
            self.staticValue = staticValue
        }
    }

}

extension QuickSightClientTypes.NumericSeparatorConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decimalSeparator = "DecimalSeparator"
        case thousandsSeparator = "ThousandsSeparator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decimalSeparator = self.decimalSeparator {
            try encodeContainer.encode(decimalSeparator.rawValue, forKey: .decimalSeparator)
        }
        if let thousandsSeparator = self.thousandsSeparator {
            try encodeContainer.encode(thousandsSeparator, forKey: .thousandsSeparator)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let decimalSeparatorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumericSeparatorSymbol.self, forKey: .decimalSeparator)
        decimalSeparator = decimalSeparatorDecoded
        let thousandsSeparatorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ThousandSeparatorOptions.self, forKey: .thousandsSeparator)
        thousandsSeparator = thousandsSeparatorDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the numeric separator configuration.
    public struct NumericSeparatorConfiguration: Swift.Equatable {
        /// Determines the decimal separator.
        public var decimalSeparator: QuickSightClientTypes.NumericSeparatorSymbol?
        /// The options that determine the thousands separator configuration.
        public var thousandsSeparator: QuickSightClientTypes.ThousandSeparatorOptions?

        public init (
            decimalSeparator: QuickSightClientTypes.NumericSeparatorSymbol? = nil,
            thousandsSeparator: QuickSightClientTypes.ThousandSeparatorOptions? = nil
        )
        {
            self.decimalSeparator = decimalSeparator
            self.thousandsSeparator = thousandsSeparator
        }
    }

}

extension QuickSightClientTypes {
    public enum NumericSeparatorSymbol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case comma
        case dot
        case space
        case sdkUnknown(Swift.String)

        public static var allCases: [NumericSeparatorSymbol] {
            return [
                .comma,
                .dot,
                .space,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .comma: return "COMMA"
            case .dot: return "DOT"
            case .space: return "SPACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NumericSeparatorSymbol(rawValue: rawValue) ?? NumericSeparatorSymbol.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.NumericalAggregationFunction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case percentileAggregation = "PercentileAggregation"
        case simpleNumericalAggregation = "SimpleNumericalAggregation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let percentileAggregation = self.percentileAggregation {
            try encodeContainer.encode(percentileAggregation, forKey: .percentileAggregation)
        }
        if let simpleNumericalAggregation = self.simpleNumericalAggregation {
            try encodeContainer.encode(simpleNumericalAggregation.rawValue, forKey: .simpleNumericalAggregation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simpleNumericalAggregationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SimpleNumericalAggregationFunction.self, forKey: .simpleNumericalAggregation)
        simpleNumericalAggregation = simpleNumericalAggregationDecoded
        let percentileAggregationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PercentileAggregation.self, forKey: .percentileAggregation)
        percentileAggregation = percentileAggregationDecoded
    }
}

extension QuickSightClientTypes {
    /// Aggregation for numerical values.
    public struct NumericalAggregationFunction: Swift.Equatable {
        /// An aggregation based on the percentile of values in a dimension or measure.
        public var percentileAggregation: QuickSightClientTypes.PercentileAggregation?
        /// Built-in aggregation functions for numerical values.
        ///
        /// * SUM: The sum of a dimension or measure.
        ///
        /// * AVERAGE: The average of a dimension or measure.
        ///
        /// * MIN: The minimum value of a dimension or measure.
        ///
        /// * MAX: The maximum value of a dimension or measure.
        ///
        /// * COUNT: The count of a dimension or measure.
        ///
        /// * DISTINCT_COUNT: The count of distinct values in a dimension or measure.
        ///
        /// * VAR: The variance of a dimension or measure.
        ///
        /// * VARP: The partitioned variance of a dimension or measure.
        ///
        /// * STDEV: The standard deviation of a dimension or measure.
        ///
        /// * STDEVP: The partitioned standard deviation of a dimension or measure.
        ///
        /// * MEDIAN: The median value of a dimension or measure.
        public var simpleNumericalAggregation: QuickSightClientTypes.SimpleNumericalAggregationFunction?

        public init (
            percentileAggregation: QuickSightClientTypes.PercentileAggregation? = nil,
            simpleNumericalAggregation: QuickSightClientTypes.SimpleNumericalAggregationFunction? = nil
        )
        {
            self.percentileAggregation = percentileAggregation
            self.simpleNumericalAggregation = simpleNumericalAggregation
        }
    }

}

extension QuickSightClientTypes.NumericalDimensionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case column = "Column"
        case fieldId = "FieldId"
        case formatConfiguration = "FormatConfiguration"
        case hierarchyId = "HierarchyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let column = self.column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
        if let formatConfiguration = self.formatConfiguration {
            try encodeContainer.encode(formatConfiguration, forKey: .formatConfiguration)
        }
        if let hierarchyId = self.hierarchyId {
            try encodeContainer.encode(hierarchyId, forKey: .hierarchyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let columnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .column)
        column = columnDecoded
        let hierarchyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyId)
        hierarchyId = hierarchyIdDecoded
        let formatConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumberFormatConfiguration.self, forKey: .formatConfiguration)
        formatConfiguration = formatConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The dimension type field with numerical type columns.
    public struct NumericalDimensionField: Swift.Equatable {
        /// The column that is used in the NumericalDimensionField.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The custom field ID.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The format configuration of the field.
        public var formatConfiguration: QuickSightClientTypes.NumberFormatConfiguration?
        /// The custom hierarchy ID.
        public var hierarchyId: Swift.String?

        public init (
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            fieldId: Swift.String? = nil,
            formatConfiguration: QuickSightClientTypes.NumberFormatConfiguration? = nil,
            hierarchyId: Swift.String? = nil
        )
        {
            self.column = column
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
            self.hierarchyId = hierarchyId
        }
    }

}

extension QuickSightClientTypes.NumericalMeasureField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationFunction = "AggregationFunction"
        case column = "Column"
        case fieldId = "FieldId"
        case formatConfiguration = "FormatConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationFunction = self.aggregationFunction {
            try encodeContainer.encode(aggregationFunction, forKey: .aggregationFunction)
        }
        if let column = self.column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
        if let formatConfiguration = self.formatConfiguration {
            try encodeContainer.encode(formatConfiguration, forKey: .formatConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let columnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .column)
        column = columnDecoded
        let aggregationFunctionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumericalAggregationFunction.self, forKey: .aggregationFunction)
        aggregationFunction = aggregationFunctionDecoded
        let formatConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumberFormatConfiguration.self, forKey: .formatConfiguration)
        formatConfiguration = formatConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The measure type field with numerical type columns.
    public struct NumericalMeasureField: Swift.Equatable {
        /// The aggregation function of the measure field.
        public var aggregationFunction: QuickSightClientTypes.NumericalAggregationFunction?
        /// The column that is used in the NumericalMeasureField.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The custom field ID.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The format configuration of the field.
        public var formatConfiguration: QuickSightClientTypes.NumberFormatConfiguration?

        public init (
            aggregationFunction: QuickSightClientTypes.NumericalAggregationFunction? = nil,
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            fieldId: Swift.String? = nil,
            formatConfiguration: QuickSightClientTypes.NumberFormatConfiguration? = nil
        )
        {
            self.aggregationFunction = aggregationFunction
            self.column = column
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
        }
    }

}

extension QuickSightClientTypes.OracleParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for Oracle.
    public struct OracleParameters: Swift.Equatable {
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// An Oracle host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int

        public init (
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.database = database
            self.host = host
            self.port = port
        }
    }

}

extension QuickSightClientTypes {
    public enum OtherCategories: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case exclude
        case include
        case sdkUnknown(Swift.String)

        public static var allCases: [OtherCategories] {
            return [
                .exclude,
                .include,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .exclude: return "EXCLUDE"
            case .include: return "INCLUDE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OtherCategories(rawValue: rawValue) ?? OtherCategories.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.OutputColumn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnDataType.self, forKey: .type)
        type = typeDecoded
    }
}

extension QuickSightClientTypes {
    /// Output column.
    public struct OutputColumn: Swift.Equatable {
        /// A description for a column.
        public var description: Swift.String?
        /// A display name for the dataset.
        public var name: Swift.String?
        /// Type.
        public var type: QuickSightClientTypes.ColumnDataType?

        public init (
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            type: QuickSightClientTypes.ColumnDataType? = nil
        )
        {
            self.description = description
            self.name = name
            self.type = type
        }
    }

}

extension QuickSightClientTypes.PaginationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pageNumber = "PageNumber"
        case pageSize = "PageSize"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pageNumber = self.pageNumber {
            try encodeContainer.encode(pageNumber, forKey: .pageNumber)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageNumber)
        pageNumber = pageNumberDecoded
    }
}

extension QuickSightClientTypes {
    /// The pagination configuration for a table visual or boxplot.
    public struct PaginationConfiguration: Swift.Equatable {
        /// Indicates the page number.
        /// This member is required.
        public var pageNumber: Swift.Int?
        /// Indicates how many items render in one page.
        /// This member is required.
        public var pageSize: Swift.Int?

        public init (
            pageNumber: Swift.Int? = nil,
            pageSize: Swift.Int? = nil
        )
        {
            self.pageNumber = pageNumber
            self.pageSize = pageSize
        }
    }

}

extension QuickSightClientTypes {
    public enum PanelBorderStyle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dashed
        case dotted
        case solid
        case sdkUnknown(Swift.String)

        public static var allCases: [PanelBorderStyle] {
            return [
                .dashed,
                .dotted,
                .solid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dashed: return "DASHED"
            case .dotted: return "DOTTED"
            case .solid: return "SOLID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PanelBorderStyle(rawValue: rawValue) ?? PanelBorderStyle.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.PanelConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backgroundColor = "BackgroundColor"
        case backgroundVisibility = "BackgroundVisibility"
        case borderColor = "BorderColor"
        case borderStyle = "BorderStyle"
        case borderThickness = "BorderThickness"
        case borderVisibility = "BorderVisibility"
        case gutterSpacing = "GutterSpacing"
        case gutterVisibility = "GutterVisibility"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backgroundColor = self.backgroundColor {
            try encodeContainer.encode(backgroundColor, forKey: .backgroundColor)
        }
        if let backgroundVisibility = self.backgroundVisibility {
            try encodeContainer.encode(backgroundVisibility.rawValue, forKey: .backgroundVisibility)
        }
        if let borderColor = self.borderColor {
            try encodeContainer.encode(borderColor, forKey: .borderColor)
        }
        if let borderStyle = self.borderStyle {
            try encodeContainer.encode(borderStyle.rawValue, forKey: .borderStyle)
        }
        if let borderThickness = self.borderThickness {
            try encodeContainer.encode(borderThickness, forKey: .borderThickness)
        }
        if let borderVisibility = self.borderVisibility {
            try encodeContainer.encode(borderVisibility.rawValue, forKey: .borderVisibility)
        }
        if let gutterSpacing = self.gutterSpacing {
            try encodeContainer.encode(gutterSpacing, forKey: .gutterSpacing)
        }
        if let gutterVisibility = self.gutterVisibility {
            try encodeContainer.encode(gutterVisibility.rawValue, forKey: .gutterVisibility)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PanelTitleOptions.self, forKey: .title)
        title = titleDecoded
        let borderVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .borderVisibility)
        borderVisibility = borderVisibilityDecoded
        let borderThicknessDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .borderThickness)
        borderThickness = borderThicknessDecoded
        let borderStyleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PanelBorderStyle.self, forKey: .borderStyle)
        borderStyle = borderStyleDecoded
        let borderColorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .borderColor)
        borderColor = borderColorDecoded
        let gutterVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .gutterVisibility)
        gutterVisibility = gutterVisibilityDecoded
        let gutterSpacingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gutterSpacing)
        gutterSpacing = gutterSpacingDecoded
        let backgroundVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .backgroundVisibility)
        backgroundVisibility = backgroundVisibilityDecoded
        let backgroundColorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backgroundColor)
        backgroundColor = backgroundColorDecoded
    }
}

extension QuickSightClientTypes {
    /// A collection of options that configure how each panel displays in a small multiples chart.
    public struct PanelConfiguration: Swift.Equatable {
        /// Sets the background color for each panel.
        public var backgroundColor: Swift.String?
        /// Determines whether or not a background for each small multiples panel is rendered.
        public var backgroundVisibility: QuickSightClientTypes.Visibility?
        /// Sets the line color of panel borders.
        public var borderColor: Swift.String?
        /// Sets the line style of panel borders.
        public var borderStyle: QuickSightClientTypes.PanelBorderStyle?
        /// Sets the line thickness of panel borders.
        public var borderThickness: Swift.String?
        /// Determines whether or not each panel displays a border.
        public var borderVisibility: QuickSightClientTypes.Visibility?
        /// Sets the total amount of negative space to display between sibling panels.
        public var gutterSpacing: Swift.String?
        /// Determines whether or not negative space between sibling panels is rendered.
        public var gutterVisibility: QuickSightClientTypes.Visibility?
        /// Configures the title display within each small multiples panel.
        public var title: QuickSightClientTypes.PanelTitleOptions?

        public init (
            backgroundColor: Swift.String? = nil,
            backgroundVisibility: QuickSightClientTypes.Visibility? = nil,
            borderColor: Swift.String? = nil,
            borderStyle: QuickSightClientTypes.PanelBorderStyle? = nil,
            borderThickness: Swift.String? = nil,
            borderVisibility: QuickSightClientTypes.Visibility? = nil,
            gutterSpacing: Swift.String? = nil,
            gutterVisibility: QuickSightClientTypes.Visibility? = nil,
            title: QuickSightClientTypes.PanelTitleOptions? = nil
        )
        {
            self.backgroundColor = backgroundColor
            self.backgroundVisibility = backgroundVisibility
            self.borderColor = borderColor
            self.borderStyle = borderStyle
            self.borderThickness = borderThickness
            self.borderVisibility = borderVisibility
            self.gutterSpacing = gutterSpacing
            self.gutterVisibility = gutterVisibility
            self.title = title
        }
    }

}

extension QuickSightClientTypes.PanelTitleOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fontConfiguration = "FontConfiguration"
        case horizontalTextAlignment = "HorizontalTextAlignment"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fontConfiguration = self.fontConfiguration {
            try encodeContainer.encode(fontConfiguration, forKey: .fontConfiguration)
        }
        if let horizontalTextAlignment = self.horizontalTextAlignment {
            try encodeContainer.encode(horizontalTextAlignment.rawValue, forKey: .horizontalTextAlignment)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
        let fontConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FontConfiguration.self, forKey: .fontConfiguration)
        fontConfiguration = fontConfigurationDecoded
        let horizontalTextAlignmentDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.HorizontalTextAlignment.self, forKey: .horizontalTextAlignment)
        horizontalTextAlignment = horizontalTextAlignmentDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the title styles for each small multiples panel.
    public struct PanelTitleOptions: Swift.Equatable {
        /// Configures the display properties of the given text.
        public var fontConfiguration: QuickSightClientTypes.FontConfiguration?
        /// Sets the horizontal text alignment of the title within each panel.
        public var horizontalTextAlignment: QuickSightClientTypes.HorizontalTextAlignment?
        /// Determines whether or not panel titles are displayed.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            fontConfiguration: QuickSightClientTypes.FontConfiguration? = nil,
            horizontalTextAlignment: QuickSightClientTypes.HorizontalTextAlignment? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.fontConfiguration = fontConfiguration
            self.horizontalTextAlignment = horizontalTextAlignment
            self.visibility = visibility
        }
    }

}

extension QuickSightClientTypes {
    public enum PaperOrientation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case landscape
        case portrait
        case sdkUnknown(Swift.String)

        public static var allCases: [PaperOrientation] {
            return [
                .landscape,
                .portrait,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .landscape: return "LANDSCAPE"
            case .portrait: return "PORTRAIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PaperOrientation(rawValue: rawValue) ?? PaperOrientation.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum PaperSize: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case a0
        case a1
        case a2
        case a3
        case a4
        case a5
        case jisB4
        case jisB5
        case usLegal
        case usLetter
        case usTabloidLedger
        case sdkUnknown(Swift.String)

        public static var allCases: [PaperSize] {
            return [
                .a0,
                .a1,
                .a2,
                .a3,
                .a4,
                .a5,
                .jisB4,
                .jisB5,
                .usLegal,
                .usLetter,
                .usTabloidLedger,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .a0: return "A0"
            case .a1: return "A1"
            case .a2: return "A2"
            case .a3: return "A3"
            case .a4: return "A4"
            case .a5: return "A5"
            case .jisB4: return "JIS_B4"
            case .jisB5: return "JIS_B5"
            case .usLegal: return "US_LEGAL"
            case .usLetter: return "US_LETTER"
            case .usTabloidLedger: return "US_TABLOID_LEDGER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PaperSize(rawValue: rawValue) ?? PaperSize.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.ParameterControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateTimePicker = "DateTimePicker"
        case dropdown = "Dropdown"
        case list = "List"
        case slider = "Slider"
        case textArea = "TextArea"
        case textField = "TextField"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateTimePicker = self.dateTimePicker {
            try encodeContainer.encode(dateTimePicker, forKey: .dateTimePicker)
        }
        if let dropdown = self.dropdown {
            try encodeContainer.encode(dropdown, forKey: .dropdown)
        }
        if let list = self.list {
            try encodeContainer.encode(list, forKey: .list)
        }
        if let slider = self.slider {
            try encodeContainer.encode(slider, forKey: .slider)
        }
        if let textArea = self.textArea {
            try encodeContainer.encode(textArea, forKey: .textArea)
        }
        if let textField = self.textField {
            try encodeContainer.encode(textField, forKey: .textField)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateTimePickerDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ParameterDateTimePickerControl.self, forKey: .dateTimePicker)
        dateTimePicker = dateTimePickerDecoded
        let listDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ParameterListControl.self, forKey: .list)
        list = listDecoded
        let dropdownDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ParameterDropDownControl.self, forKey: .dropdown)
        dropdown = dropdownDecoded
        let textFieldDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ParameterTextFieldControl.self, forKey: .textField)
        textField = textFieldDecoded
        let textAreaDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ParameterTextAreaControl.self, forKey: .textArea)
        textArea = textAreaDecoded
        let sliderDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ParameterSliderControl.self, forKey: .slider)
        slider = sliderDecoded
    }
}

extension QuickSightClientTypes {
    /// The control of a parameter that users can interact with in a dashboard or an analysis. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct ParameterControl: Swift.Equatable {
        /// A control from a date parameter that specifies date and time.
        public var dateTimePicker: QuickSightClientTypes.ParameterDateTimePickerControl?
        /// A control to display a dropdown list with buttons that are used to select a single value.
        public var dropdown: QuickSightClientTypes.ParameterDropDownControl?
        /// A control to display a list with buttons or boxes that are used to select either a single value or multiple values.
        public var list: QuickSightClientTypes.ParameterListControl?
        /// A control to display a horizontal toggle bar. This is used to change a value by sliding the toggle.
        public var slider: QuickSightClientTypes.ParameterSliderControl?
        /// A control to display a text box that is used to enter multiple entries.
        public var textArea: QuickSightClientTypes.ParameterTextAreaControl?
        /// A control to display a text box that is used to enter a single entry.
        public var textField: QuickSightClientTypes.ParameterTextFieldControl?

        public init (
            dateTimePicker: QuickSightClientTypes.ParameterDateTimePickerControl? = nil,
            dropdown: QuickSightClientTypes.ParameterDropDownControl? = nil,
            list: QuickSightClientTypes.ParameterListControl? = nil,
            slider: QuickSightClientTypes.ParameterSliderControl? = nil,
            textArea: QuickSightClientTypes.ParameterTextAreaControl? = nil,
            textField: QuickSightClientTypes.ParameterTextFieldControl? = nil
        )
        {
            self.dateTimePicker = dateTimePicker
            self.dropdown = dropdown
            self.list = list
            self.slider = slider
            self.textArea = textArea
            self.textField = textField
        }
    }

}

extension QuickSightClientTypes.ParameterDateTimePickerControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayOptions = "DisplayOptions"
        case parameterControlId = "ParameterControlId"
        case sourceParameterName = "SourceParameterName"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayOptions = self.displayOptions {
            try encodeContainer.encode(displayOptions, forKey: .displayOptions)
        }
        if let parameterControlId = self.parameterControlId {
            try encodeContainer.encode(parameterControlId, forKey: .parameterControlId)
        }
        if let sourceParameterName = self.sourceParameterName {
            try encodeContainer.encode(sourceParameterName, forKey: .sourceParameterName)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterControlIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterControlId)
        parameterControlId = parameterControlIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let sourceParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceParameterName)
        sourceParameterName = sourceParameterNameDecoded
        let displayOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DateTimePickerControlDisplayOptions.self, forKey: .displayOptions)
        displayOptions = displayOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// A control from a date parameter that specifies date and time.
    public struct ParameterDateTimePickerControl: Swift.Equatable {
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.DateTimePickerControlDisplayOptions?
        /// The ID of the ParameterDateTimePickerControl.
        /// This member is required.
        public var parameterControlId: Swift.String?
        /// The name of the ParameterDateTimePickerControl.
        /// This member is required.
        public var sourceParameterName: Swift.String?
        /// The title of the ParameterDateTimePickerControl.
        /// This member is required.
        public var title: Swift.String?

        public init (
            displayOptions: QuickSightClientTypes.DateTimePickerControlDisplayOptions? = nil,
            parameterControlId: Swift.String? = nil,
            sourceParameterName: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.displayOptions = displayOptions
            self.parameterControlId = parameterControlId
            self.sourceParameterName = sourceParameterName
            self.title = title
        }
    }

}

extension QuickSightClientTypes.ParameterDeclaration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateTimeParameterDeclaration = "DateTimeParameterDeclaration"
        case decimalParameterDeclaration = "DecimalParameterDeclaration"
        case integerParameterDeclaration = "IntegerParameterDeclaration"
        case stringParameterDeclaration = "StringParameterDeclaration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateTimeParameterDeclaration = self.dateTimeParameterDeclaration {
            try encodeContainer.encode(dateTimeParameterDeclaration, forKey: .dateTimeParameterDeclaration)
        }
        if let decimalParameterDeclaration = self.decimalParameterDeclaration {
            try encodeContainer.encode(decimalParameterDeclaration, forKey: .decimalParameterDeclaration)
        }
        if let integerParameterDeclaration = self.integerParameterDeclaration {
            try encodeContainer.encode(integerParameterDeclaration, forKey: .integerParameterDeclaration)
        }
        if let stringParameterDeclaration = self.stringParameterDeclaration {
            try encodeContainer.encode(stringParameterDeclaration, forKey: .stringParameterDeclaration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stringParameterDeclarationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.StringParameterDeclaration.self, forKey: .stringParameterDeclaration)
        stringParameterDeclaration = stringParameterDeclarationDecoded
        let decimalParameterDeclarationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DecimalParameterDeclaration.self, forKey: .decimalParameterDeclaration)
        decimalParameterDeclaration = decimalParameterDeclarationDecoded
        let integerParameterDeclarationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IntegerParameterDeclaration.self, forKey: .integerParameterDeclaration)
        integerParameterDeclaration = integerParameterDeclarationDecoded
        let dateTimeParameterDeclarationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DateTimeParameterDeclaration.self, forKey: .dateTimeParameterDeclaration)
        dateTimeParameterDeclaration = dateTimeParameterDeclarationDecoded
    }
}

extension QuickSightClientTypes {
    /// The declaration definition of a parameter. For more information, see [Parameters in Amazon QuickSight](https://docs.aws.amazon.com/quicksight/latest/user/parameters-in-quicksight.html) in the Amazon QuickSight User Guide. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct ParameterDeclaration: Swift.Equatable {
        /// A parameter declaration for the DateTime data type.
        public var dateTimeParameterDeclaration: QuickSightClientTypes.DateTimeParameterDeclaration?
        /// A parameter declaration for the Decimal data type.
        public var decimalParameterDeclaration: QuickSightClientTypes.DecimalParameterDeclaration?
        /// A parameter declaration for the Integer data type.
        public var integerParameterDeclaration: QuickSightClientTypes.IntegerParameterDeclaration?
        /// A parameter declaration for the String data type.
        public var stringParameterDeclaration: QuickSightClientTypes.StringParameterDeclaration?

        public init (
            dateTimeParameterDeclaration: QuickSightClientTypes.DateTimeParameterDeclaration? = nil,
            decimalParameterDeclaration: QuickSightClientTypes.DecimalParameterDeclaration? = nil,
            integerParameterDeclaration: QuickSightClientTypes.IntegerParameterDeclaration? = nil,
            stringParameterDeclaration: QuickSightClientTypes.StringParameterDeclaration? = nil
        )
        {
            self.dateTimeParameterDeclaration = dateTimeParameterDeclaration
            self.decimalParameterDeclaration = decimalParameterDeclaration
            self.integerParameterDeclaration = integerParameterDeclaration
            self.stringParameterDeclaration = stringParameterDeclaration
        }
    }

}

extension QuickSightClientTypes.ParameterDropDownControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cascadingControlConfiguration = "CascadingControlConfiguration"
        case displayOptions = "DisplayOptions"
        case parameterControlId = "ParameterControlId"
        case selectableValues = "SelectableValues"
        case sourceParameterName = "SourceParameterName"
        case title = "Title"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cascadingControlConfiguration = self.cascadingControlConfiguration {
            try encodeContainer.encode(cascadingControlConfiguration, forKey: .cascadingControlConfiguration)
        }
        if let displayOptions = self.displayOptions {
            try encodeContainer.encode(displayOptions, forKey: .displayOptions)
        }
        if let parameterControlId = self.parameterControlId {
            try encodeContainer.encode(parameterControlId, forKey: .parameterControlId)
        }
        if let selectableValues = self.selectableValues {
            try encodeContainer.encode(selectableValues, forKey: .selectableValues)
        }
        if let sourceParameterName = self.sourceParameterName {
            try encodeContainer.encode(sourceParameterName, forKey: .sourceParameterName)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterControlIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterControlId)
        parameterControlId = parameterControlIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let sourceParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceParameterName)
        sourceParameterName = sourceParameterNameDecoded
        let displayOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DropDownControlDisplayOptions.self, forKey: .displayOptions)
        displayOptions = displayOptionsDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SheetControlListType.self, forKey: .type)
        type = typeDecoded
        let selectableValuesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ParameterSelectableValues.self, forKey: .selectableValues)
        selectableValues = selectableValuesDecoded
        let cascadingControlConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CascadingControlConfiguration.self, forKey: .cascadingControlConfiguration)
        cascadingControlConfiguration = cascadingControlConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// A control to display a dropdown list with buttons that are used to select a single value.
    public struct ParameterDropDownControl: Swift.Equatable {
        /// The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.
        public var cascadingControlConfiguration: QuickSightClientTypes.CascadingControlConfiguration?
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.DropDownControlDisplayOptions?
        /// The ID of the ParameterDropDownControl.
        /// This member is required.
        public var parameterControlId: Swift.String?
        /// A list of selectable values that are used in a control.
        public var selectableValues: QuickSightClientTypes.ParameterSelectableValues?
        /// The source parameter name of the ParameterDropDownControl.
        /// This member is required.
        public var sourceParameterName: Swift.String?
        /// The title of the ParameterDropDownControl.
        /// This member is required.
        public var title: Swift.String?
        /// The type parameter name of the ParameterDropDownControl.
        public var type: QuickSightClientTypes.SheetControlListType?

        public init (
            cascadingControlConfiguration: QuickSightClientTypes.CascadingControlConfiguration? = nil,
            displayOptions: QuickSightClientTypes.DropDownControlDisplayOptions? = nil,
            parameterControlId: Swift.String? = nil,
            selectableValues: QuickSightClientTypes.ParameterSelectableValues? = nil,
            sourceParameterName: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QuickSightClientTypes.SheetControlListType? = nil
        )
        {
            self.cascadingControlConfiguration = cascadingControlConfiguration
            self.displayOptions = displayOptions
            self.parameterControlId = parameterControlId
            self.selectableValues = selectableValues
            self.sourceParameterName = sourceParameterName
            self.title = title
            self.type = type
        }
    }

}

extension QuickSightClientTypes.ParameterListControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cascadingControlConfiguration = "CascadingControlConfiguration"
        case displayOptions = "DisplayOptions"
        case parameterControlId = "ParameterControlId"
        case selectableValues = "SelectableValues"
        case sourceParameterName = "SourceParameterName"
        case title = "Title"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cascadingControlConfiguration = self.cascadingControlConfiguration {
            try encodeContainer.encode(cascadingControlConfiguration, forKey: .cascadingControlConfiguration)
        }
        if let displayOptions = self.displayOptions {
            try encodeContainer.encode(displayOptions, forKey: .displayOptions)
        }
        if let parameterControlId = self.parameterControlId {
            try encodeContainer.encode(parameterControlId, forKey: .parameterControlId)
        }
        if let selectableValues = self.selectableValues {
            try encodeContainer.encode(selectableValues, forKey: .selectableValues)
        }
        if let sourceParameterName = self.sourceParameterName {
            try encodeContainer.encode(sourceParameterName, forKey: .sourceParameterName)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterControlIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterControlId)
        parameterControlId = parameterControlIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let sourceParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceParameterName)
        sourceParameterName = sourceParameterNameDecoded
        let displayOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ListControlDisplayOptions.self, forKey: .displayOptions)
        displayOptions = displayOptionsDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SheetControlListType.self, forKey: .type)
        type = typeDecoded
        let selectableValuesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ParameterSelectableValues.self, forKey: .selectableValues)
        selectableValues = selectableValuesDecoded
        let cascadingControlConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CascadingControlConfiguration.self, forKey: .cascadingControlConfiguration)
        cascadingControlConfiguration = cascadingControlConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// A control to display a list with buttons or boxes that are used to select either a single value or multiple values.
    public struct ParameterListControl: Swift.Equatable {
        /// The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.
        public var cascadingControlConfiguration: QuickSightClientTypes.CascadingControlConfiguration?
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.ListControlDisplayOptions?
        /// The ID of the ParameterListControl.
        /// This member is required.
        public var parameterControlId: Swift.String?
        /// A list of selectable values that are used in a control.
        public var selectableValues: QuickSightClientTypes.ParameterSelectableValues?
        /// The source parameter name of the ParameterListControl.
        /// This member is required.
        public var sourceParameterName: Swift.String?
        /// The title of the ParameterListControl.
        /// This member is required.
        public var title: Swift.String?
        /// The type of ParameterListControl.
        public var type: QuickSightClientTypes.SheetControlListType?

        public init (
            cascadingControlConfiguration: QuickSightClientTypes.CascadingControlConfiguration? = nil,
            displayOptions: QuickSightClientTypes.ListControlDisplayOptions? = nil,
            parameterControlId: Swift.String? = nil,
            selectableValues: QuickSightClientTypes.ParameterSelectableValues? = nil,
            sourceParameterName: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QuickSightClientTypes.SheetControlListType? = nil
        )
        {
            self.cascadingControlConfiguration = cascadingControlConfiguration
            self.displayOptions = displayOptions
            self.parameterControlId = parameterControlId
            self.selectableValues = selectableValues
            self.sourceParameterName = sourceParameterName
            self.title = title
            self.type = type
        }
    }

}

extension QuickSightClientTypes.ParameterSelectableValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkToDataSetColumn = "LinkToDataSetColumn"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let linkToDataSetColumn = self.linkToDataSetColumn {
            try encodeContainer.encode(linkToDataSetColumn, forKey: .linkToDataSetColumn)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string0 in values {
                try valuesContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let linkToDataSetColumnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .linkToDataSetColumn)
        linkToDataSetColumn = linkToDataSetColumnDecoded
    }
}

extension QuickSightClientTypes {
    /// A list of selectable values that are used in a control.
    public struct ParameterSelectableValues: Swift.Equatable {
        /// The column identifier that fetches values from the data set.
        public var linkToDataSetColumn: QuickSightClientTypes.ColumnIdentifier?
        /// The values that are used in ParameterSelectableValues.
        public var values: [Swift.String]?

        public init (
            linkToDataSetColumn: QuickSightClientTypes.ColumnIdentifier? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.linkToDataSetColumn = linkToDataSetColumn
            self.values = values
        }
    }

}

extension QuickSightClientTypes.ParameterSliderControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayOptions = "DisplayOptions"
        case maximumValue = "MaximumValue"
        case minimumValue = "MinimumValue"
        case parameterControlId = "ParameterControlId"
        case sourceParameterName = "SourceParameterName"
        case stepSize = "StepSize"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayOptions = self.displayOptions {
            try encodeContainer.encode(displayOptions, forKey: .displayOptions)
        }
        if maximumValue != 0.0 {
            try encodeContainer.encode(maximumValue, forKey: .maximumValue)
        }
        if minimumValue != 0.0 {
            try encodeContainer.encode(minimumValue, forKey: .minimumValue)
        }
        if let parameterControlId = self.parameterControlId {
            try encodeContainer.encode(parameterControlId, forKey: .parameterControlId)
        }
        if let sourceParameterName = self.sourceParameterName {
            try encodeContainer.encode(sourceParameterName, forKey: .sourceParameterName)
        }
        if stepSize != 0.0 {
            try encodeContainer.encode(stepSize, forKey: .stepSize)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterControlIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterControlId)
        parameterControlId = parameterControlIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let sourceParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceParameterName)
        sourceParameterName = sourceParameterNameDecoded
        let displayOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SliderControlDisplayOptions.self, forKey: .displayOptions)
        displayOptions = displayOptionsDecoded
        let maximumValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .maximumValue) ?? 0.0
        maximumValue = maximumValueDecoded
        let minimumValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minimumValue) ?? 0.0
        minimumValue = minimumValueDecoded
        let stepSizeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .stepSize) ?? 0.0
        stepSize = stepSizeDecoded
    }
}

extension QuickSightClientTypes {
    /// A control to display a horizontal toggle bar. This is used to change a value by sliding the toggle.
    public struct ParameterSliderControl: Swift.Equatable {
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.SliderControlDisplayOptions?
        /// The smaller value that is displayed at the left of the slider.
        /// This member is required.
        public var maximumValue: Swift.Double
        /// The larger value that is displayed at the right of the slider.
        /// This member is required.
        public var minimumValue: Swift.Double
        /// The ID of the ParameterSliderControl.
        /// This member is required.
        public var parameterControlId: Swift.String?
        /// The source parameter name of the ParameterSliderControl.
        /// This member is required.
        public var sourceParameterName: Swift.String?
        /// The number of increments that the slider bar is divided into.
        /// This member is required.
        public var stepSize: Swift.Double
        /// The title of the ParameterSliderControl.
        /// This member is required.
        public var title: Swift.String?

        public init (
            displayOptions: QuickSightClientTypes.SliderControlDisplayOptions? = nil,
            maximumValue: Swift.Double = 0.0,
            minimumValue: Swift.Double = 0.0,
            parameterControlId: Swift.String? = nil,
            sourceParameterName: Swift.String? = nil,
            stepSize: Swift.Double = 0.0,
            title: Swift.String? = nil
        )
        {
            self.displayOptions = displayOptions
            self.maximumValue = maximumValue
            self.minimumValue = minimumValue
            self.parameterControlId = parameterControlId
            self.sourceParameterName = sourceParameterName
            self.stepSize = stepSize
            self.title = title
        }
    }

}

extension QuickSightClientTypes.ParameterTextAreaControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delimiter = "Delimiter"
        case displayOptions = "DisplayOptions"
        case parameterControlId = "ParameterControlId"
        case sourceParameterName = "SourceParameterName"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let delimiter = self.delimiter {
            try encodeContainer.encode(delimiter, forKey: .delimiter)
        }
        if let displayOptions = self.displayOptions {
            try encodeContainer.encode(displayOptions, forKey: .displayOptions)
        }
        if let parameterControlId = self.parameterControlId {
            try encodeContainer.encode(parameterControlId, forKey: .parameterControlId)
        }
        if let sourceParameterName = self.sourceParameterName {
            try encodeContainer.encode(sourceParameterName, forKey: .sourceParameterName)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterControlIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterControlId)
        parameterControlId = parameterControlIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let sourceParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceParameterName)
        sourceParameterName = sourceParameterNameDecoded
        let delimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let displayOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TextAreaControlDisplayOptions.self, forKey: .displayOptions)
        displayOptions = displayOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// A control to display a text box that is used to enter multiple entries.
    public struct ParameterTextAreaControl: Swift.Equatable {
        /// The delimiter that is used to separate the lines in text.
        public var delimiter: Swift.String?
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.TextAreaControlDisplayOptions?
        /// The ID of the ParameterTextAreaControl.
        /// This member is required.
        public var parameterControlId: Swift.String?
        /// The source parameter name of the ParameterTextAreaControl.
        /// This member is required.
        public var sourceParameterName: Swift.String?
        /// The title of the ParameterTextAreaControl.
        /// This member is required.
        public var title: Swift.String?

        public init (
            delimiter: Swift.String? = nil,
            displayOptions: QuickSightClientTypes.TextAreaControlDisplayOptions? = nil,
            parameterControlId: Swift.String? = nil,
            sourceParameterName: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.delimiter = delimiter
            self.displayOptions = displayOptions
            self.parameterControlId = parameterControlId
            self.sourceParameterName = sourceParameterName
            self.title = title
        }
    }

}

extension QuickSightClientTypes.ParameterTextFieldControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayOptions = "DisplayOptions"
        case parameterControlId = "ParameterControlId"
        case sourceParameterName = "SourceParameterName"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayOptions = self.displayOptions {
            try encodeContainer.encode(displayOptions, forKey: .displayOptions)
        }
        if let parameterControlId = self.parameterControlId {
            try encodeContainer.encode(parameterControlId, forKey: .parameterControlId)
        }
        if let sourceParameterName = self.sourceParameterName {
            try encodeContainer.encode(sourceParameterName, forKey: .sourceParameterName)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterControlIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterControlId)
        parameterControlId = parameterControlIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let sourceParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceParameterName)
        sourceParameterName = sourceParameterNameDecoded
        let displayOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TextFieldControlDisplayOptions.self, forKey: .displayOptions)
        displayOptions = displayOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// A control to display a text box that is used to enter a single entry.
    public struct ParameterTextFieldControl: Swift.Equatable {
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.TextFieldControlDisplayOptions?
        /// The ID of the ParameterTextFieldControl.
        /// This member is required.
        public var parameterControlId: Swift.String?
        /// The source parameter name of the ParameterTextFieldControl.
        /// This member is required.
        public var sourceParameterName: Swift.String?
        /// The title of the ParameterTextFieldControl.
        /// This member is required.
        public var title: Swift.String?

        public init (
            displayOptions: QuickSightClientTypes.TextFieldControlDisplayOptions? = nil,
            parameterControlId: Swift.String? = nil,
            sourceParameterName: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.displayOptions = displayOptions
            self.parameterControlId = parameterControlId
            self.sourceParameterName = sourceParameterName
            self.title = title
        }
    }

}

extension QuickSightClientTypes {
    public enum ParameterValueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case multiValued
        case singleValued
        case sdkUnknown(Swift.String)

        public static var allCases: [ParameterValueType] {
            return [
                .multiValued,
                .singleValued,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .multiValued: return "MULTI_VALUED"
            case .singleValued: return "SINGLE_VALUED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParameterValueType(rawValue: rawValue) ?? ParameterValueType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.Parameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateTimeParameters = "DateTimeParameters"
        case decimalParameters = "DecimalParameters"
        case integerParameters = "IntegerParameters"
        case stringParameters = "StringParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateTimeParameters = dateTimeParameters {
            var dateTimeParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dateTimeParameters)
            for datetimeparameter0 in dateTimeParameters {
                try dateTimeParametersContainer.encode(datetimeparameter0)
            }
        }
        if let decimalParameters = decimalParameters {
            var decimalParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .decimalParameters)
            for decimalparameter0 in decimalParameters {
                try decimalParametersContainer.encode(decimalparameter0)
            }
        }
        if let integerParameters = integerParameters {
            var integerParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .integerParameters)
            for integerparameter0 in integerParameters {
                try integerParametersContainer.encode(integerparameter0)
            }
        }
        if let stringParameters = stringParameters {
            var stringParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stringParameters)
            for stringparameter0 in stringParameters {
                try stringParametersContainer.encode(stringparameter0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stringParametersContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.StringParameter?].self, forKey: .stringParameters)
        var stringParametersDecoded0:[QuickSightClientTypes.StringParameter]? = nil
        if let stringParametersContainer = stringParametersContainer {
            stringParametersDecoded0 = [QuickSightClientTypes.StringParameter]()
            for structure0 in stringParametersContainer {
                if let structure0 = structure0 {
                    stringParametersDecoded0?.append(structure0)
                }
            }
        }
        stringParameters = stringParametersDecoded0
        let integerParametersContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.IntegerParameter?].self, forKey: .integerParameters)
        var integerParametersDecoded0:[QuickSightClientTypes.IntegerParameter]? = nil
        if let integerParametersContainer = integerParametersContainer {
            integerParametersDecoded0 = [QuickSightClientTypes.IntegerParameter]()
            for structure0 in integerParametersContainer {
                if let structure0 = structure0 {
                    integerParametersDecoded0?.append(structure0)
                }
            }
        }
        integerParameters = integerParametersDecoded0
        let decimalParametersContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DecimalParameter?].self, forKey: .decimalParameters)
        var decimalParametersDecoded0:[QuickSightClientTypes.DecimalParameter]? = nil
        if let decimalParametersContainer = decimalParametersContainer {
            decimalParametersDecoded0 = [QuickSightClientTypes.DecimalParameter]()
            for structure0 in decimalParametersContainer {
                if let structure0 = structure0 {
                    decimalParametersDecoded0?.append(structure0)
                }
            }
        }
        decimalParameters = decimalParametersDecoded0
        let dateTimeParametersContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DateTimeParameter?].self, forKey: .dateTimeParameters)
        var dateTimeParametersDecoded0:[QuickSightClientTypes.DateTimeParameter]? = nil
        if let dateTimeParametersContainer = dateTimeParametersContainer {
            dateTimeParametersDecoded0 = [QuickSightClientTypes.DateTimeParameter]()
            for structure0 in dateTimeParametersContainer {
                if let structure0 = structure0 {
                    dateTimeParametersDecoded0?.append(structure0)
                }
            }
        }
        dateTimeParameters = dateTimeParametersDecoded0
    }
}

extension QuickSightClientTypes {
    /// A list of Amazon QuickSight parameters and the list's override values.
    public struct Parameters: Swift.Equatable {
        /// The parameters that have a data type of date-time.
        public var dateTimeParameters: [QuickSightClientTypes.DateTimeParameter]?
        /// The parameters that have a data type of decimal.
        public var decimalParameters: [QuickSightClientTypes.DecimalParameter]?
        /// The parameters that have a data type of integer.
        public var integerParameters: [QuickSightClientTypes.IntegerParameter]?
        /// The parameters that have a data type of string.
        public var stringParameters: [QuickSightClientTypes.StringParameter]?

        public init (
            dateTimeParameters: [QuickSightClientTypes.DateTimeParameter]? = nil,
            decimalParameters: [QuickSightClientTypes.DecimalParameter]? = nil,
            integerParameters: [QuickSightClientTypes.IntegerParameter]? = nil,
            stringParameters: [QuickSightClientTypes.StringParameter]? = nil
        )
        {
            self.dateTimeParameters = dateTimeParameters
            self.decimalParameters = decimalParameters
            self.integerParameters = integerParameters
            self.stringParameters = stringParameters
        }
    }

}

extension QuickSightClientTypes.PercentVisibleRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case from = "From"
        case to = "To"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let from = self.from {
            try encodeContainer.encode(from, forKey: .from)
        }
        if let to = self.to {
            try encodeContainer.encode(to, forKey: .to)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .from)
        from = fromDecoded
        let toDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .to)
        to = toDecoded
    }
}

extension QuickSightClientTypes {
    /// The percent range in the visible range.
    public struct PercentVisibleRange: Swift.Equatable {
        /// The lower bound of the range.
        public var from: Swift.Double?
        /// The top bound of the range.
        public var to: Swift.Double?

        public init (
            from: Swift.Double? = nil,
            to: Swift.Double? = nil
        )
        {
            self.from = from
            self.to = to
        }
    }

}

extension QuickSightClientTypes.PercentageDisplayFormatConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decimalPlacesConfiguration = "DecimalPlacesConfiguration"
        case negativeValueConfiguration = "NegativeValueConfiguration"
        case nullValueFormatConfiguration = "NullValueFormatConfiguration"
        case `prefix` = "Prefix"
        case separatorConfiguration = "SeparatorConfiguration"
        case suffix = "Suffix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decimalPlacesConfiguration = self.decimalPlacesConfiguration {
            try encodeContainer.encode(decimalPlacesConfiguration, forKey: .decimalPlacesConfiguration)
        }
        if let negativeValueConfiguration = self.negativeValueConfiguration {
            try encodeContainer.encode(negativeValueConfiguration, forKey: .negativeValueConfiguration)
        }
        if let nullValueFormatConfiguration = self.nullValueFormatConfiguration {
            try encodeContainer.encode(nullValueFormatConfiguration, forKey: .nullValueFormatConfiguration)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
        if let separatorConfiguration = self.separatorConfiguration {
            try encodeContainer.encode(separatorConfiguration, forKey: .separatorConfiguration)
        }
        if let suffix = self.suffix {
            try encodeContainer.encode(suffix, forKey: .suffix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let suffixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suffix)
        suffix = suffixDecoded
        let separatorConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumericSeparatorConfiguration.self, forKey: .separatorConfiguration)
        separatorConfiguration = separatorConfigurationDecoded
        let decimalPlacesConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DecimalPlacesConfiguration.self, forKey: .decimalPlacesConfiguration)
        decimalPlacesConfiguration = decimalPlacesConfigurationDecoded
        let negativeValueConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NegativeValueConfiguration.self, forKey: .negativeValueConfiguration)
        negativeValueConfiguration = negativeValueConfigurationDecoded
        let nullValueFormatConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NullValueFormatConfiguration.self, forKey: .nullValueFormatConfiguration)
        nullValueFormatConfiguration = nullValueFormatConfigurationDecoded
    }
}

extension QuickSightClientTypes.PercentageDisplayFormatConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PercentageDisplayFormatConfiguration(decimalPlacesConfiguration: \(Swift.String(describing: decimalPlacesConfiguration)), negativeValueConfiguration: \(Swift.String(describing: negativeValueConfiguration)), nullValueFormatConfiguration: \(Swift.String(describing: nullValueFormatConfiguration)), separatorConfiguration: \(Swift.String(describing: separatorConfiguration)), prefix: \"CONTENT_REDACTED\", suffix: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {
    /// The options that determine the percentage display format configuration.
    public struct PercentageDisplayFormatConfiguration: Swift.Equatable {
        /// The option that determines the decimal places configuration.
        public var decimalPlacesConfiguration: QuickSightClientTypes.DecimalPlacesConfiguration?
        /// The options that determine the negative value configuration.
        public var negativeValueConfiguration: QuickSightClientTypes.NegativeValueConfiguration?
        /// The options that determine the null value format configuration.
        public var nullValueFormatConfiguration: QuickSightClientTypes.NullValueFormatConfiguration?
        /// Determines the prefix value of the percentage format.
        public var `prefix`: Swift.String?
        /// The options that determine the numeric separator configuration.
        public var separatorConfiguration: QuickSightClientTypes.NumericSeparatorConfiguration?
        /// Determines the suffix value of the percentage format.
        public var suffix: Swift.String?

        public init (
            decimalPlacesConfiguration: QuickSightClientTypes.DecimalPlacesConfiguration? = nil,
            negativeValueConfiguration: QuickSightClientTypes.NegativeValueConfiguration? = nil,
            nullValueFormatConfiguration: QuickSightClientTypes.NullValueFormatConfiguration? = nil,
            `prefix`: Swift.String? = nil,
            separatorConfiguration: QuickSightClientTypes.NumericSeparatorConfiguration? = nil,
            suffix: Swift.String? = nil
        )
        {
            self.decimalPlacesConfiguration = decimalPlacesConfiguration
            self.negativeValueConfiguration = negativeValueConfiguration
            self.nullValueFormatConfiguration = nullValueFormatConfiguration
            self.`prefix` = `prefix`
            self.separatorConfiguration = separatorConfiguration
            self.suffix = suffix
        }
    }

}

extension QuickSightClientTypes.PercentileAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case percentileValue = "PercentileValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let percentileValue = self.percentileValue {
            try encodeContainer.encode(percentileValue, forKey: .percentileValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentileValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .percentileValue)
        percentileValue = percentileValueDecoded
    }
}

extension QuickSightClientTypes {
    /// An aggregation based on the percentile of values in a dimension or measure.
    public struct PercentileAggregation: Swift.Equatable {
        /// The percentile value. This value can be any numeric constant 0100. A percentile value of 50 computes the median value of the measure.
        public var percentileValue: Swift.Double?

        public init (
            percentileValue: Swift.Double? = nil
        )
        {
            self.percentileValue = percentileValue
        }
    }

}

extension QuickSightClientTypes.PeriodOverPeriodComputation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computationId = "ComputationId"
        case name = "Name"
        case time = "Time"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computationId = self.computationId {
            try encodeContainer.encode(computationId, forKey: .computationId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let time = self.time {
            try encodeContainer.encode(time, forKey: .time)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .computationId)
        computationId = computationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let timeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DimensionField.self, forKey: .time)
        time = timeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.MeasureField.self, forKey: .value)
        value = valueDecoded
    }
}

extension QuickSightClientTypes {
    /// The period over period computation configuration.
    public struct PeriodOverPeriodComputation: Swift.Equatable {
        /// The ID for a computation.
        /// This member is required.
        public var computationId: Swift.String?
        /// The name of a computation.
        public var name: Swift.String?
        /// The time field that is used in a computation.
        /// This member is required.
        public var time: QuickSightClientTypes.DimensionField?
        /// The value field that is used in a computation.
        public var value: QuickSightClientTypes.MeasureField?

        public init (
            computationId: Swift.String? = nil,
            name: Swift.String? = nil,
            time: QuickSightClientTypes.DimensionField? = nil,
            value: QuickSightClientTypes.MeasureField? = nil
        )
        {
            self.computationId = computationId
            self.name = name
            self.time = time
            self.value = value
        }
    }

}

extension QuickSightClientTypes.PeriodToDateComputation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computationId = "ComputationId"
        case name = "Name"
        case periodTimeGranularity = "PeriodTimeGranularity"
        case time = "Time"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computationId = self.computationId {
            try encodeContainer.encode(computationId, forKey: .computationId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let periodTimeGranularity = self.periodTimeGranularity {
            try encodeContainer.encode(periodTimeGranularity.rawValue, forKey: .periodTimeGranularity)
        }
        if let time = self.time {
            try encodeContainer.encode(time, forKey: .time)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .computationId)
        computationId = computationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let timeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DimensionField.self, forKey: .time)
        time = timeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.MeasureField.self, forKey: .value)
        value = valueDecoded
        let periodTimeGranularityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TimeGranularity.self, forKey: .periodTimeGranularity)
        periodTimeGranularity = periodTimeGranularityDecoded
    }
}

extension QuickSightClientTypes {
    /// The period to date computation configuration.
    public struct PeriodToDateComputation: Swift.Equatable {
        /// The ID for a computation.
        /// This member is required.
        public var computationId: Swift.String?
        /// The name of a computation.
        public var name: Swift.String?
        /// The time granularity setup of period to date computation. Choose from the following options:
        ///
        /// * YEAR: Year to date.
        ///
        /// * MONTH: Month to date.
        public var periodTimeGranularity: QuickSightClientTypes.TimeGranularity?
        /// The time field that is used in a computation.
        /// This member is required.
        public var time: QuickSightClientTypes.DimensionField?
        /// The value field that is used in a computation.
        public var value: QuickSightClientTypes.MeasureField?

        public init (
            computationId: Swift.String? = nil,
            name: Swift.String? = nil,
            periodTimeGranularity: QuickSightClientTypes.TimeGranularity? = nil,
            time: QuickSightClientTypes.DimensionField? = nil,
            value: QuickSightClientTypes.MeasureField? = nil
        )
        {
            self.computationId = computationId
            self.name = name
            self.periodTimeGranularity = periodTimeGranularity
            self.time = time
            self.value = value
        }
    }

}

extension QuickSightClientTypes.PhysicalTable: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customsql = "CustomSql"
        case relationaltable = "RelationalTable"
        case s3source = "S3Source"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .customsql(customsql):
                try container.encode(customsql, forKey: .customsql)
            case let .relationaltable(relationaltable):
                try container.encode(relationaltable, forKey: .relationaltable)
            case let .s3source(s3source):
                try container.encode(s3source, forKey: .s3source)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let relationaltableDecoded = try values.decodeIfPresent(QuickSightClientTypes.RelationalTable.self, forKey: .relationaltable)
        if let relationaltable = relationaltableDecoded {
            self = .relationaltable(relationaltable)
            return
        }
        let customsqlDecoded = try values.decodeIfPresent(QuickSightClientTypes.CustomSql.self, forKey: .customsql)
        if let customsql = customsqlDecoded {
            self = .customsql(customsql)
            return
        }
        let s3sourceDecoded = try values.decodeIfPresent(QuickSightClientTypes.S3Source.self, forKey: .s3source)
        if let s3source = s3sourceDecoded {
            self = .s3source(s3source)
            return
        }
        self = .sdkUnknown("")
    }
}

extension QuickSightClientTypes {
    /// A view of a data source that contains information about the shape of the data in the underlying source. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
    public enum PhysicalTable: Swift.Equatable {
        /// A physical table type for relational data sources.
        case relationaltable(QuickSightClientTypes.RelationalTable)
        /// A physical table type built from the results of the custom SQL query.
        case customsql(QuickSightClientTypes.CustomSql)
        /// A physical table type for as S3 data source.
        case s3source(QuickSightClientTypes.S3Source)
        case sdkUnknown(Swift.String)
    }

}

extension QuickSightClientTypes.PieChartAggregatedFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category = "Category"
        case smallMultiples = "SmallMultiples"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            var categoryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .category)
            for dimensionfield0 in category {
                try categoryContainer.encode(dimensionfield0)
            }
        }
        if let smallMultiples = smallMultiples {
            var smallMultiplesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .smallMultiples)
            for dimensionfield0 in smallMultiples {
                try smallMultiplesContainer.encode(dimensionfield0)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for measurefield0 in values {
                try valuesContainer.encode(measurefield0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .category)
        var categoryDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let categoryContainer = categoryContainer {
            categoryDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in categoryContainer {
                if let structure0 = structure0 {
                    categoryDecoded0?.append(structure0)
                }
            }
        }
        category = categoryDecoded0
        let valuesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .values)
        var valuesDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
        let smallMultiplesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .smallMultiples)
        var smallMultiplesDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let smallMultiplesContainer = smallMultiplesContainer {
            smallMultiplesDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in smallMultiplesContainer {
                if let structure0 = structure0 {
                    smallMultiplesDecoded0?.append(structure0)
                }
            }
        }
        smallMultiples = smallMultiplesDecoded0
    }
}

extension QuickSightClientTypes {
    /// The field well configuration of a pie chart.
    public struct PieChartAggregatedFieldWells: Swift.Equatable {
        /// The category (group/color) field wells of a pie chart.
        public var category: [QuickSightClientTypes.DimensionField]?
        /// The small multiples field well of a pie chart.
        public var smallMultiples: [QuickSightClientTypes.DimensionField]?
        /// The value field wells of a pie chart. Values are aggregated based on categories.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init (
            category: [QuickSightClientTypes.DimensionField]? = nil,
            smallMultiples: [QuickSightClientTypes.DimensionField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.category = category
            self.smallMultiples = smallMultiples
            self.values = values
        }
    }

}

extension QuickSightClientTypes.PieChartConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryLabelOptions = "CategoryLabelOptions"
        case contributionAnalysisDefaults = "ContributionAnalysisDefaults"
        case dataLabels = "DataLabels"
        case donutOptions = "DonutOptions"
        case fieldWells = "FieldWells"
        case legend = "Legend"
        case smallMultiplesOptions = "SmallMultiplesOptions"
        case sortConfiguration = "SortConfiguration"
        case tooltip = "Tooltip"
        case valueLabelOptions = "ValueLabelOptions"
        case visualPalette = "VisualPalette"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryLabelOptions = self.categoryLabelOptions {
            try encodeContainer.encode(categoryLabelOptions, forKey: .categoryLabelOptions)
        }
        if let contributionAnalysisDefaults = contributionAnalysisDefaults {
            var contributionAnalysisDefaultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contributionAnalysisDefaults)
            for contributionanalysisdefault0 in contributionAnalysisDefaults {
                try contributionAnalysisDefaultsContainer.encode(contributionanalysisdefault0)
            }
        }
        if let dataLabels = self.dataLabels {
            try encodeContainer.encode(dataLabels, forKey: .dataLabels)
        }
        if let donutOptions = self.donutOptions {
            try encodeContainer.encode(donutOptions, forKey: .donutOptions)
        }
        if let fieldWells = self.fieldWells {
            try encodeContainer.encode(fieldWells, forKey: .fieldWells)
        }
        if let legend = self.legend {
            try encodeContainer.encode(legend, forKey: .legend)
        }
        if let smallMultiplesOptions = self.smallMultiplesOptions {
            try encodeContainer.encode(smallMultiplesOptions, forKey: .smallMultiplesOptions)
        }
        if let sortConfiguration = self.sortConfiguration {
            try encodeContainer.encode(sortConfiguration, forKey: .sortConfiguration)
        }
        if let tooltip = self.tooltip {
            try encodeContainer.encode(tooltip, forKey: .tooltip)
        }
        if let valueLabelOptions = self.valueLabelOptions {
            try encodeContainer.encode(valueLabelOptions, forKey: .valueLabelOptions)
        }
        if let visualPalette = self.visualPalette {
            try encodeContainer.encode(visualPalette, forKey: .visualPalette)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PieChartFieldWells.self, forKey: .fieldWells)
        fieldWells = fieldWellsDecoded
        let sortConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PieChartSortConfiguration.self, forKey: .sortConfiguration)
        sortConfiguration = sortConfigurationDecoded
        let donutOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DonutOptions.self, forKey: .donutOptions)
        donutOptions = donutOptionsDecoded
        let smallMultiplesOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SmallMultiplesOptions.self, forKey: .smallMultiplesOptions)
        smallMultiplesOptions = smallMultiplesOptionsDecoded
        let categoryLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .categoryLabelOptions)
        categoryLabelOptions = categoryLabelOptionsDecoded
        let valueLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .valueLabelOptions)
        valueLabelOptions = valueLabelOptionsDecoded
        let legendDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LegendOptions.self, forKey: .legend)
        legend = legendDecoded
        let dataLabelsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataLabelOptions.self, forKey: .dataLabels)
        dataLabels = dataLabelsDecoded
        let tooltipDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TooltipOptions.self, forKey: .tooltip)
        tooltip = tooltipDecoded
        let visualPaletteDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualPalette.self, forKey: .visualPalette)
        visualPalette = visualPaletteDecoded
        let contributionAnalysisDefaultsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ContributionAnalysisDefault?].self, forKey: .contributionAnalysisDefaults)
        var contributionAnalysisDefaultsDecoded0:[QuickSightClientTypes.ContributionAnalysisDefault]? = nil
        if let contributionAnalysisDefaultsContainer = contributionAnalysisDefaultsContainer {
            contributionAnalysisDefaultsDecoded0 = [QuickSightClientTypes.ContributionAnalysisDefault]()
            for structure0 in contributionAnalysisDefaultsContainer {
                if let structure0 = structure0 {
                    contributionAnalysisDefaultsDecoded0?.append(structure0)
                }
            }
        }
        contributionAnalysisDefaults = contributionAnalysisDefaultsDecoded0
    }
}

extension QuickSightClientTypes {
    /// The configuration of a pie chart.
    public struct PieChartConfiguration: Swift.Equatable {
        /// The label options of the group/color that is displayed in a pie chart.
        public var categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The contribution analysis (anomaly configuration) setup of the visual.
        public var contributionAnalysisDefaults: [QuickSightClientTypes.ContributionAnalysisDefault]?
        /// The options that determine if visual data labels are displayed.
        public var dataLabels: QuickSightClientTypes.DataLabelOptions?
        /// The options that determine the shape of the chart. This option determines whether the chart is a pie chart or a donut chart.
        public var donutOptions: QuickSightClientTypes.DonutOptions?
        /// The field wells of the visual.
        public var fieldWells: QuickSightClientTypes.PieChartFieldWells?
        /// The legend display setup of the visual.
        public var legend: QuickSightClientTypes.LegendOptions?
        /// The small multiples setup for the visual.
        public var smallMultiplesOptions: QuickSightClientTypes.SmallMultiplesOptions?
        /// The sort configuration of a pie chart.
        public var sortConfiguration: QuickSightClientTypes.PieChartSortConfiguration?
        /// The tooltip display setup of the visual.
        public var tooltip: QuickSightClientTypes.TooltipOptions?
        /// The label options for the value that is displayed in a pie chart.
        public var valueLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The palette (chart color) display setup of the visual.
        public var visualPalette: QuickSightClientTypes.VisualPalette?

        public init (
            categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            contributionAnalysisDefaults: [QuickSightClientTypes.ContributionAnalysisDefault]? = nil,
            dataLabels: QuickSightClientTypes.DataLabelOptions? = nil,
            donutOptions: QuickSightClientTypes.DonutOptions? = nil,
            fieldWells: QuickSightClientTypes.PieChartFieldWells? = nil,
            legend: QuickSightClientTypes.LegendOptions? = nil,
            smallMultiplesOptions: QuickSightClientTypes.SmallMultiplesOptions? = nil,
            sortConfiguration: QuickSightClientTypes.PieChartSortConfiguration? = nil,
            tooltip: QuickSightClientTypes.TooltipOptions? = nil,
            valueLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            visualPalette: QuickSightClientTypes.VisualPalette? = nil
        )
        {
            self.categoryLabelOptions = categoryLabelOptions
            self.contributionAnalysisDefaults = contributionAnalysisDefaults
            self.dataLabels = dataLabels
            self.donutOptions = donutOptions
            self.fieldWells = fieldWells
            self.legend = legend
            self.smallMultiplesOptions = smallMultiplesOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.valueLabelOptions = valueLabelOptions
            self.visualPalette = visualPalette
        }
    }

}

extension QuickSightClientTypes.PieChartFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pieChartAggregatedFieldWells = "PieChartAggregatedFieldWells"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pieChartAggregatedFieldWells = self.pieChartAggregatedFieldWells {
            try encodeContainer.encode(pieChartAggregatedFieldWells, forKey: .pieChartAggregatedFieldWells)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pieChartAggregatedFieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PieChartAggregatedFieldWells.self, forKey: .pieChartAggregatedFieldWells)
        pieChartAggregatedFieldWells = pieChartAggregatedFieldWellsDecoded
    }
}

extension QuickSightClientTypes {
    /// The field well configuration of a pie chart. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct PieChartFieldWells: Swift.Equatable {
        /// The field well configuration of a pie chart.
        public var pieChartAggregatedFieldWells: QuickSightClientTypes.PieChartAggregatedFieldWells?

        public init (
            pieChartAggregatedFieldWells: QuickSightClientTypes.PieChartAggregatedFieldWells? = nil
        )
        {
            self.pieChartAggregatedFieldWells = pieChartAggregatedFieldWells
        }
    }

}

extension QuickSightClientTypes.PieChartSortConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryItemsLimit = "CategoryItemsLimit"
        case categorySort = "CategorySort"
        case smallMultiplesLimitConfiguration = "SmallMultiplesLimitConfiguration"
        case smallMultiplesSort = "SmallMultiplesSort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryItemsLimit = self.categoryItemsLimit {
            try encodeContainer.encode(categoryItemsLimit, forKey: .categoryItemsLimit)
        }
        if let categorySort = categorySort {
            var categorySortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categorySort)
            for fieldsortoptions0 in categorySort {
                try categorySortContainer.encode(fieldsortoptions0)
            }
        }
        if let smallMultiplesLimitConfiguration = self.smallMultiplesLimitConfiguration {
            try encodeContainer.encode(smallMultiplesLimitConfiguration, forKey: .smallMultiplesLimitConfiguration)
        }
        if let smallMultiplesSort = smallMultiplesSort {
            var smallMultiplesSortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .smallMultiplesSort)
            for fieldsortoptions0 in smallMultiplesSort {
                try smallMultiplesSortContainer.encode(fieldsortoptions0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categorySortContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FieldSortOptions?].self, forKey: .categorySort)
        var categorySortDecoded0:[QuickSightClientTypes.FieldSortOptions]? = nil
        if let categorySortContainer = categorySortContainer {
            categorySortDecoded0 = [QuickSightClientTypes.FieldSortOptions]()
            for structure0 in categorySortContainer {
                if let structure0 = structure0 {
                    categorySortDecoded0?.append(structure0)
                }
            }
        }
        categorySort = categorySortDecoded0
        let categoryItemsLimitDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ItemsLimitConfiguration.self, forKey: .categoryItemsLimit)
        categoryItemsLimit = categoryItemsLimitDecoded
        let smallMultiplesSortContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FieldSortOptions?].self, forKey: .smallMultiplesSort)
        var smallMultiplesSortDecoded0:[QuickSightClientTypes.FieldSortOptions]? = nil
        if let smallMultiplesSortContainer = smallMultiplesSortContainer {
            smallMultiplesSortDecoded0 = [QuickSightClientTypes.FieldSortOptions]()
            for structure0 in smallMultiplesSortContainer {
                if let structure0 = structure0 {
                    smallMultiplesSortDecoded0?.append(structure0)
                }
            }
        }
        smallMultiplesSort = smallMultiplesSortDecoded0
        let smallMultiplesLimitConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ItemsLimitConfiguration.self, forKey: .smallMultiplesLimitConfiguration)
        smallMultiplesLimitConfiguration = smallMultiplesLimitConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The sort configuration of a pie chart.
    public struct PieChartSortConfiguration: Swift.Equatable {
        /// The limit on the number of categories that are displayed in a pie chart.
        public var categoryItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of the category fields.
        public var categorySort: [QuickSightClientTypes.FieldSortOptions]?
        /// The limit on the number of small multiples panels that are displayed.
        public var smallMultiplesLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of the small multiples field.
        public var smallMultiplesSort: [QuickSightClientTypes.FieldSortOptions]?

        public init (
            categoryItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            categorySort: [QuickSightClientTypes.FieldSortOptions]? = nil,
            smallMultiplesLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            smallMultiplesSort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.categoryItemsLimit = categoryItemsLimit
            self.categorySort = categorySort
            self.smallMultiplesLimitConfiguration = smallMultiplesLimitConfiguration
            self.smallMultiplesSort = smallMultiplesSort
        }
    }

}

extension QuickSightClientTypes.PieChartVisual: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case chartConfiguration = "ChartConfiguration"
        case columnHierarchies = "ColumnHierarchies"
        case subtitle = "Subtitle"
        case title = "Title"
        case visualId = "VisualId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for visualcustomaction0 in actions {
                try actionsContainer.encode(visualcustomaction0)
            }
        }
        if let chartConfiguration = self.chartConfiguration {
            try encodeContainer.encode(chartConfiguration, forKey: .chartConfiguration)
        }
        if let columnHierarchies = columnHierarchies {
            var columnHierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnHierarchies)
            for columnhierarchy0 in columnHierarchies {
                try columnHierarchiesContainer.encode(columnhierarchy0)
            }
        }
        if let subtitle = self.subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let visualId = self.visualId {
            try encodeContainer.encode(visualId, forKey: .visualId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visualIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visualId)
        visualId = visualIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualTitleLabelOptions.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualSubtitleLabelOptions.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let chartConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PieChartConfiguration.self, forKey: .chartConfiguration)
        chartConfiguration = chartConfigurationDecoded
        let actionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.VisualCustomAction?].self, forKey: .actions)
        var actionsDecoded0:[QuickSightClientTypes.VisualCustomAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [QuickSightClientTypes.VisualCustomAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let columnHierarchiesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnHierarchy?].self, forKey: .columnHierarchies)
        var columnHierarchiesDecoded0:[QuickSightClientTypes.ColumnHierarchy]? = nil
        if let columnHierarchiesContainer = columnHierarchiesContainer {
            columnHierarchiesDecoded0 = [QuickSightClientTypes.ColumnHierarchy]()
            for structure0 in columnHierarchiesContainer {
                if let structure0 = structure0 {
                    columnHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        columnHierarchies = columnHierarchiesDecoded0
    }
}

extension QuickSightClientTypes {
    /// A pie or donut chart. The PieChartVisual structure describes a visual that is a member of the pie chart family. The following charts can be described by using this structure:
    ///
    /// * Pie charts
    ///
    /// * Donut charts
    ///
    ///
    /// For more information, see [Using pie charts](https://docs.aws.amazon.com/quicksight/latest/user/pie-chart.html) in the Amazon QuickSight User Guide. For more information, see [Using donut charts](https://docs.aws.amazon.com/quicksight/latest/user/donut-chart.html) in the Amazon QuickSight User Guide.
    public struct PieChartVisual: Swift.Equatable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration of a pie chart.
        public var chartConfiguration: QuickSightClientTypes.PieChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init (
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.PieChartConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }

}

extension QuickSightClientTypes.PivotFieldSortOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldId = "FieldId"
        case sortBy = "SortBy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PivotTableSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension QuickSightClientTypes {
    /// The field sort options for a pivot table sort configuration.
    public struct PivotFieldSortOptions: Swift.Equatable {
        /// The field ID for the field sort options.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The sort by field for the field sort options.
        /// This member is required.
        public var sortBy: QuickSightClientTypes.PivotTableSortBy?

        public init (
            fieldId: Swift.String? = nil,
            sortBy: QuickSightClientTypes.PivotTableSortBy? = nil
        )
        {
            self.fieldId = fieldId
            self.sortBy = sortBy
        }
    }

}

extension QuickSightClientTypes.PivotTableAggregatedFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columns = "Columns"
        case rows = "Rows"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for dimensionfield0 in columns {
                try columnsContainer.encode(dimensionfield0)
            }
        }
        if let rows = rows {
            var rowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rows)
            for dimensionfield0 in rows {
                try rowsContainer.encode(dimensionfield0)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for measurefield0 in values {
                try valuesContainer.encode(measurefield0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .rows)
        var rowsDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let rowsContainer = rowsContainer {
            rowsDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in rowsContainer {
                if let structure0 = structure0 {
                    rowsDecoded0?.append(structure0)
                }
            }
        }
        rows = rowsDecoded0
        let columnsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .columns)
        var columnsDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in columnsContainer {
                if let structure0 = structure0 {
                    columnsDecoded0?.append(structure0)
                }
            }
        }
        columns = columnsDecoded0
        let valuesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .values)
        var valuesDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension QuickSightClientTypes {
    /// The aggregated field well for the pivot table.
    public struct PivotTableAggregatedFieldWells: Swift.Equatable {
        /// The columns field well for a pivot table. Values are grouped by columns fields.
        public var columns: [QuickSightClientTypes.DimensionField]?
        /// The rows field well for a pivot table. Values are grouped by rows fields.
        public var rows: [QuickSightClientTypes.DimensionField]?
        /// The values field well for a pivot table. Values are aggregated based on rows and columns fields.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init (
            columns: [QuickSightClientTypes.DimensionField]? = nil,
            rows: [QuickSightClientTypes.DimensionField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.columns = columns
            self.rows = rows
            self.values = values
        }
    }

}

extension QuickSightClientTypes.PivotTableCellConditionalFormatting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldId = "FieldId"
        case scope = "Scope"
        case textFormat = "TextFormat"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
        if let scope = self.scope {
            try encodeContainer.encode(scope, forKey: .scope)
        }
        if let textFormat = self.textFormat {
            try encodeContainer.encode(textFormat, forKey: .textFormat)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let textFormatDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TextConditionalFormat.self, forKey: .textFormat)
        textFormat = textFormatDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PivotTableConditionalFormattingScope.self, forKey: .scope)
        scope = scopeDecoded
    }
}

extension QuickSightClientTypes {
    /// The cell conditional formatting option for a pivot table.
    public struct PivotTableCellConditionalFormatting: Swift.Equatable {
        /// The field ID of the cell for conditional formatting.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The scope of the cell for conditional formatting.
        public var scope: QuickSightClientTypes.PivotTableConditionalFormattingScope?
        /// The text format of the cell for conditional formatting.
        public var textFormat: QuickSightClientTypes.TextConditionalFormat?

        public init (
            fieldId: Swift.String? = nil,
            scope: QuickSightClientTypes.PivotTableConditionalFormattingScope? = nil,
            textFormat: QuickSightClientTypes.TextConditionalFormat? = nil
        )
        {
            self.fieldId = fieldId
            self.scope = scope
            self.textFormat = textFormat
        }
    }

}

extension QuickSightClientTypes.PivotTableConditionalFormatting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conditionalFormattingOptions = "ConditionalFormattingOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conditionalFormattingOptions = conditionalFormattingOptions {
            var conditionalFormattingOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conditionalFormattingOptions)
            for pivottableconditionalformattingoption0 in conditionalFormattingOptions {
                try conditionalFormattingOptionsContainer.encode(pivottableconditionalformattingoption0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionalFormattingOptionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.PivotTableConditionalFormattingOption?].self, forKey: .conditionalFormattingOptions)
        var conditionalFormattingOptionsDecoded0:[QuickSightClientTypes.PivotTableConditionalFormattingOption]? = nil
        if let conditionalFormattingOptionsContainer = conditionalFormattingOptionsContainer {
            conditionalFormattingOptionsDecoded0 = [QuickSightClientTypes.PivotTableConditionalFormattingOption]()
            for structure0 in conditionalFormattingOptionsContainer {
                if let structure0 = structure0 {
                    conditionalFormattingOptionsDecoded0?.append(structure0)
                }
            }
        }
        conditionalFormattingOptions = conditionalFormattingOptionsDecoded0
    }
}

extension QuickSightClientTypes {
    /// The conditional formatting for a PivotTableVisual.
    public struct PivotTableConditionalFormatting: Swift.Equatable {
        /// Conditional formatting options for a PivotTableVisual.
        public var conditionalFormattingOptions: [QuickSightClientTypes.PivotTableConditionalFormattingOption]?

        public init (
            conditionalFormattingOptions: [QuickSightClientTypes.PivotTableConditionalFormattingOption]? = nil
        )
        {
            self.conditionalFormattingOptions = conditionalFormattingOptions
        }
    }

}

extension QuickSightClientTypes.PivotTableConditionalFormattingOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cell = "Cell"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cell = self.cell {
            try encodeContainer.encode(cell, forKey: .cell)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PivotTableCellConditionalFormatting.self, forKey: .cell)
        cell = cellDecoded
    }
}

extension QuickSightClientTypes {
    /// Conditional formatting options for a PivotTableVisual.
    public struct PivotTableConditionalFormattingOption: Swift.Equatable {
        /// The cell conditional formatting option for a pivot table.
        public var cell: QuickSightClientTypes.PivotTableCellConditionalFormatting?

        public init (
            cell: QuickSightClientTypes.PivotTableCellConditionalFormatting? = nil
        )
        {
            self.cell = cell
        }
    }

}

extension QuickSightClientTypes.PivotTableConditionalFormattingScope: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case role = "Role"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let role = self.role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PivotTableConditionalFormattingScopeRole.self, forKey: .role)
        role = roleDecoded
    }
}

extension QuickSightClientTypes {
    /// The scope of the cell for conditional formatting.
    public struct PivotTableConditionalFormattingScope: Swift.Equatable {
        /// The role (field, field total, grand total) of the cell for conditional formatting.
        public var role: QuickSightClientTypes.PivotTableConditionalFormattingScopeRole?

        public init (
            role: QuickSightClientTypes.PivotTableConditionalFormattingScopeRole? = nil
        )
        {
            self.role = role
        }
    }

}

extension QuickSightClientTypes {
    public enum PivotTableConditionalFormattingScopeRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case field
        case fieldTotal
        case grandTotal
        case sdkUnknown(Swift.String)

        public static var allCases: [PivotTableConditionalFormattingScopeRole] {
            return [
                .field,
                .fieldTotal,
                .grandTotal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .field: return "FIELD"
            case .fieldTotal: return "FIELD_TOTAL"
            case .grandTotal: return "GRAND_TOTAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PivotTableConditionalFormattingScopeRole(rawValue: rawValue) ?? PivotTableConditionalFormattingScopeRole.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.PivotTableConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldOptions = "FieldOptions"
        case fieldWells = "FieldWells"
        case paginatedReportOptions = "PaginatedReportOptions"
        case sortConfiguration = "SortConfiguration"
        case tableOptions = "TableOptions"
        case totalOptions = "TotalOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldOptions = self.fieldOptions {
            try encodeContainer.encode(fieldOptions, forKey: .fieldOptions)
        }
        if let fieldWells = self.fieldWells {
            try encodeContainer.encode(fieldWells, forKey: .fieldWells)
        }
        if let paginatedReportOptions = self.paginatedReportOptions {
            try encodeContainer.encode(paginatedReportOptions, forKey: .paginatedReportOptions)
        }
        if let sortConfiguration = self.sortConfiguration {
            try encodeContainer.encode(sortConfiguration, forKey: .sortConfiguration)
        }
        if let tableOptions = self.tableOptions {
            try encodeContainer.encode(tableOptions, forKey: .tableOptions)
        }
        if let totalOptions = self.totalOptions {
            try encodeContainer.encode(totalOptions, forKey: .totalOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PivotTableFieldWells.self, forKey: .fieldWells)
        fieldWells = fieldWellsDecoded
        let sortConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PivotTableSortConfiguration.self, forKey: .sortConfiguration)
        sortConfiguration = sortConfigurationDecoded
        let tableOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PivotTableOptions.self, forKey: .tableOptions)
        tableOptions = tableOptionsDecoded
        let totalOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PivotTableTotalOptions.self, forKey: .totalOptions)
        totalOptions = totalOptionsDecoded
        let fieldOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PivotTableFieldOptions.self, forKey: .fieldOptions)
        fieldOptions = fieldOptionsDecoded
        let paginatedReportOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PivotTablePaginatedReportOptions.self, forKey: .paginatedReportOptions)
        paginatedReportOptions = paginatedReportOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration for a PivotTableVisual.
    public struct PivotTableConfiguration: Swift.Equatable {
        /// The field options for a pivot table visual.
        public var fieldOptions: QuickSightClientTypes.PivotTableFieldOptions?
        /// The field wells of the visual.
        public var fieldWells: QuickSightClientTypes.PivotTableFieldWells?
        /// The paginated report options for a pivot table visual.
        public var paginatedReportOptions: QuickSightClientTypes.PivotTablePaginatedReportOptions?
        /// The sort configuration for a PivotTableVisual.
        public var sortConfiguration: QuickSightClientTypes.PivotTableSortConfiguration?
        /// The table options for a pivot table visual.
        public var tableOptions: QuickSightClientTypes.PivotTableOptions?
        /// The total options for a pivot table visual.
        public var totalOptions: QuickSightClientTypes.PivotTableTotalOptions?

        public init (
            fieldOptions: QuickSightClientTypes.PivotTableFieldOptions? = nil,
            fieldWells: QuickSightClientTypes.PivotTableFieldWells? = nil,
            paginatedReportOptions: QuickSightClientTypes.PivotTablePaginatedReportOptions? = nil,
            sortConfiguration: QuickSightClientTypes.PivotTableSortConfiguration? = nil,
            tableOptions: QuickSightClientTypes.PivotTableOptions? = nil,
            totalOptions: QuickSightClientTypes.PivotTableTotalOptions? = nil
        )
        {
            self.fieldOptions = fieldOptions
            self.fieldWells = fieldWells
            self.paginatedReportOptions = paginatedReportOptions
            self.sortConfiguration = sortConfiguration
            self.tableOptions = tableOptions
            self.totalOptions = totalOptions
        }
    }

}

extension QuickSightClientTypes.PivotTableDataPathOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataPathList = "DataPathList"
        case width = "Width"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataPathList = dataPathList {
            var dataPathListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataPathList)
            for datapathvalue0 in dataPathList {
                try dataPathListContainer.encode(datapathvalue0)
            }
        }
        if let width = self.width {
            try encodeContainer.encode(width, forKey: .width)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataPathListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataPathValue?].self, forKey: .dataPathList)
        var dataPathListDecoded0:[QuickSightClientTypes.DataPathValue]? = nil
        if let dataPathListContainer = dataPathListContainer {
            dataPathListDecoded0 = [QuickSightClientTypes.DataPathValue]()
            for structure0 in dataPathListContainer {
                if let structure0 = structure0 {
                    dataPathListDecoded0?.append(structure0)
                }
            }
        }
        dataPathList = dataPathListDecoded0
        let widthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .width)
        width = widthDecoded
    }
}

extension QuickSightClientTypes {
    /// The data path options for the pivot table field options.
    public struct PivotTableDataPathOption: Swift.Equatable {
        /// The list of data path values for the data path options.
        /// This member is required.
        public var dataPathList: [QuickSightClientTypes.DataPathValue]?
        /// The width of the data path option.
        public var width: Swift.String?

        public init (
            dataPathList: [QuickSightClientTypes.DataPathValue]? = nil,
            width: Swift.String? = nil
        )
        {
            self.dataPathList = dataPathList
            self.width = width
        }
    }

}

extension QuickSightClientTypes.PivotTableFieldOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customLabel = "CustomLabel"
        case fieldId = "FieldId"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customLabel = self.customLabel {
            try encodeContainer.encode(customLabel, forKey: .customLabel)
        }
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let customLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customLabel)
        customLabel = customLabelDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension QuickSightClientTypes {
    /// The selected field options for the pivot table field options.
    public struct PivotTableFieldOption: Swift.Equatable {
        /// The custom label of the pivot table field.
        public var customLabel: Swift.String?
        /// The field ID of the pivot table field.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The visibility of the pivot table field.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            customLabel: Swift.String? = nil,
            fieldId: Swift.String? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.customLabel = customLabel
            self.fieldId = fieldId
            self.visibility = visibility
        }
    }

}

extension QuickSightClientTypes.PivotTableFieldOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataPathOptions = "DataPathOptions"
        case selectedFieldOptions = "SelectedFieldOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataPathOptions = dataPathOptions {
            var dataPathOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataPathOptions)
            for pivottabledatapathoption0 in dataPathOptions {
                try dataPathOptionsContainer.encode(pivottabledatapathoption0)
            }
        }
        if let selectedFieldOptions = selectedFieldOptions {
            var selectedFieldOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedFieldOptions)
            for pivottablefieldoption0 in selectedFieldOptions {
                try selectedFieldOptionsContainer.encode(pivottablefieldoption0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectedFieldOptionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.PivotTableFieldOption?].self, forKey: .selectedFieldOptions)
        var selectedFieldOptionsDecoded0:[QuickSightClientTypes.PivotTableFieldOption]? = nil
        if let selectedFieldOptionsContainer = selectedFieldOptionsContainer {
            selectedFieldOptionsDecoded0 = [QuickSightClientTypes.PivotTableFieldOption]()
            for structure0 in selectedFieldOptionsContainer {
                if let structure0 = structure0 {
                    selectedFieldOptionsDecoded0?.append(structure0)
                }
            }
        }
        selectedFieldOptions = selectedFieldOptionsDecoded0
        let dataPathOptionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.PivotTableDataPathOption?].self, forKey: .dataPathOptions)
        var dataPathOptionsDecoded0:[QuickSightClientTypes.PivotTableDataPathOption]? = nil
        if let dataPathOptionsContainer = dataPathOptionsContainer {
            dataPathOptionsDecoded0 = [QuickSightClientTypes.PivotTableDataPathOption]()
            for structure0 in dataPathOptionsContainer {
                if let structure0 = structure0 {
                    dataPathOptionsDecoded0?.append(structure0)
                }
            }
        }
        dataPathOptions = dataPathOptionsDecoded0
    }
}

extension QuickSightClientTypes {
    /// The field options for a pivot table visual.
    public struct PivotTableFieldOptions: Swift.Equatable {
        /// The data path options for the pivot table field options.
        public var dataPathOptions: [QuickSightClientTypes.PivotTableDataPathOption]?
        /// The selected field options for the pivot table field options.
        public var selectedFieldOptions: [QuickSightClientTypes.PivotTableFieldOption]?

        public init (
            dataPathOptions: [QuickSightClientTypes.PivotTableDataPathOption]? = nil,
            selectedFieldOptions: [QuickSightClientTypes.PivotTableFieldOption]? = nil
        )
        {
            self.dataPathOptions = dataPathOptions
            self.selectedFieldOptions = selectedFieldOptions
        }
    }

}

extension QuickSightClientTypes.PivotTableFieldSubtotalOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldId = "FieldId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
    }
}

extension QuickSightClientTypes {
    /// The optional configuration of subtotals cells.
    public struct PivotTableFieldSubtotalOptions: Swift.Equatable {
        /// The field ID of the subtotal options.
        public var fieldId: Swift.String?

        public init (
            fieldId: Swift.String? = nil
        )
        {
            self.fieldId = fieldId
        }
    }

}

extension QuickSightClientTypes.PivotTableFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pivotTableAggregatedFieldWells = "PivotTableAggregatedFieldWells"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pivotTableAggregatedFieldWells = self.pivotTableAggregatedFieldWells {
            try encodeContainer.encode(pivotTableAggregatedFieldWells, forKey: .pivotTableAggregatedFieldWells)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pivotTableAggregatedFieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PivotTableAggregatedFieldWells.self, forKey: .pivotTableAggregatedFieldWells)
        pivotTableAggregatedFieldWells = pivotTableAggregatedFieldWellsDecoded
    }
}

extension QuickSightClientTypes {
    /// The field wells for a pivot table visual. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct PivotTableFieldWells: Swift.Equatable {
        /// The aggregated field well for the pivot table.
        public var pivotTableAggregatedFieldWells: QuickSightClientTypes.PivotTableAggregatedFieldWells?

        public init (
            pivotTableAggregatedFieldWells: QuickSightClientTypes.PivotTableAggregatedFieldWells? = nil
        )
        {
            self.pivotTableAggregatedFieldWells = pivotTableAggregatedFieldWells
        }
    }

}

extension QuickSightClientTypes {
    public enum PivotTableMetricPlacement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case column
        case row
        case sdkUnknown(Swift.String)

        public static var allCases: [PivotTableMetricPlacement] {
            return [
                .column,
                .row,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .column: return "COLUMN"
            case .row: return "ROW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PivotTableMetricPlacement(rawValue: rawValue) ?? PivotTableMetricPlacement.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.PivotTableOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellStyle = "CellStyle"
        case columnHeaderStyle = "ColumnHeaderStyle"
        case columnNamesVisibility = "ColumnNamesVisibility"
        case metricPlacement = "MetricPlacement"
        case rowAlternateColorOptions = "RowAlternateColorOptions"
        case rowFieldNamesStyle = "RowFieldNamesStyle"
        case rowHeaderStyle = "RowHeaderStyle"
        case singleMetricVisibility = "SingleMetricVisibility"
        case toggleButtonsVisibility = "ToggleButtonsVisibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cellStyle = self.cellStyle {
            try encodeContainer.encode(cellStyle, forKey: .cellStyle)
        }
        if let columnHeaderStyle = self.columnHeaderStyle {
            try encodeContainer.encode(columnHeaderStyle, forKey: .columnHeaderStyle)
        }
        if let columnNamesVisibility = self.columnNamesVisibility {
            try encodeContainer.encode(columnNamesVisibility.rawValue, forKey: .columnNamesVisibility)
        }
        if let metricPlacement = self.metricPlacement {
            try encodeContainer.encode(metricPlacement.rawValue, forKey: .metricPlacement)
        }
        if let rowAlternateColorOptions = self.rowAlternateColorOptions {
            try encodeContainer.encode(rowAlternateColorOptions, forKey: .rowAlternateColorOptions)
        }
        if let rowFieldNamesStyle = self.rowFieldNamesStyle {
            try encodeContainer.encode(rowFieldNamesStyle, forKey: .rowFieldNamesStyle)
        }
        if let rowHeaderStyle = self.rowHeaderStyle {
            try encodeContainer.encode(rowHeaderStyle, forKey: .rowHeaderStyle)
        }
        if let singleMetricVisibility = self.singleMetricVisibility {
            try encodeContainer.encode(singleMetricVisibility.rawValue, forKey: .singleMetricVisibility)
        }
        if let toggleButtonsVisibility = self.toggleButtonsVisibility {
            try encodeContainer.encode(toggleButtonsVisibility.rawValue, forKey: .toggleButtonsVisibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricPlacementDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PivotTableMetricPlacement.self, forKey: .metricPlacement)
        metricPlacement = metricPlacementDecoded
        let singleMetricVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .singleMetricVisibility)
        singleMetricVisibility = singleMetricVisibilityDecoded
        let columnNamesVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .columnNamesVisibility)
        columnNamesVisibility = columnNamesVisibilityDecoded
        let toggleButtonsVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .toggleButtonsVisibility)
        toggleButtonsVisibility = toggleButtonsVisibilityDecoded
        let columnHeaderStyleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableCellStyle.self, forKey: .columnHeaderStyle)
        columnHeaderStyle = columnHeaderStyleDecoded
        let rowHeaderStyleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableCellStyle.self, forKey: .rowHeaderStyle)
        rowHeaderStyle = rowHeaderStyleDecoded
        let cellStyleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableCellStyle.self, forKey: .cellStyle)
        cellStyle = cellStyleDecoded
        let rowFieldNamesStyleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableCellStyle.self, forKey: .rowFieldNamesStyle)
        rowFieldNamesStyle = rowFieldNamesStyleDecoded
        let rowAlternateColorOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RowAlternateColorOptions.self, forKey: .rowAlternateColorOptions)
        rowAlternateColorOptions = rowAlternateColorOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// The table options for a pivot table visual.
    public struct PivotTableOptions: Swift.Equatable {
        /// The table cell style of cells.
        public var cellStyle: QuickSightClientTypes.TableCellStyle?
        /// The table cell style of the column header.
        public var columnHeaderStyle: QuickSightClientTypes.TableCellStyle?
        /// The visibility of the column names.
        public var columnNamesVisibility: QuickSightClientTypes.Visibility?
        /// The metric placement (row, column) options.
        public var metricPlacement: QuickSightClientTypes.PivotTableMetricPlacement?
        /// The row alternate color options (widget status, row alternate colors).
        public var rowAlternateColorOptions: QuickSightClientTypes.RowAlternateColorOptions?
        /// The table cell style of row field names.
        public var rowFieldNamesStyle: QuickSightClientTypes.TableCellStyle?
        /// The table cell style of the row headers.
        public var rowHeaderStyle: QuickSightClientTypes.TableCellStyle?
        /// The visibility of the single metric options.
        public var singleMetricVisibility: QuickSightClientTypes.Visibility?
        /// Determines the visibility of the pivot table.
        public var toggleButtonsVisibility: QuickSightClientTypes.Visibility?

        public init (
            cellStyle: QuickSightClientTypes.TableCellStyle? = nil,
            columnHeaderStyle: QuickSightClientTypes.TableCellStyle? = nil,
            columnNamesVisibility: QuickSightClientTypes.Visibility? = nil,
            metricPlacement: QuickSightClientTypes.PivotTableMetricPlacement? = nil,
            rowAlternateColorOptions: QuickSightClientTypes.RowAlternateColorOptions? = nil,
            rowFieldNamesStyle: QuickSightClientTypes.TableCellStyle? = nil,
            rowHeaderStyle: QuickSightClientTypes.TableCellStyle? = nil,
            singleMetricVisibility: QuickSightClientTypes.Visibility? = nil,
            toggleButtonsVisibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.cellStyle = cellStyle
            self.columnHeaderStyle = columnHeaderStyle
            self.columnNamesVisibility = columnNamesVisibility
            self.metricPlacement = metricPlacement
            self.rowAlternateColorOptions = rowAlternateColorOptions
            self.rowFieldNamesStyle = rowFieldNamesStyle
            self.rowHeaderStyle = rowHeaderStyle
            self.singleMetricVisibility = singleMetricVisibility
            self.toggleButtonsVisibility = toggleButtonsVisibility
        }
    }

}

extension QuickSightClientTypes.PivotTablePaginatedReportOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overflowColumnHeaderVisibility = "OverflowColumnHeaderVisibility"
        case verticalOverflowVisibility = "VerticalOverflowVisibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let overflowColumnHeaderVisibility = self.overflowColumnHeaderVisibility {
            try encodeContainer.encode(overflowColumnHeaderVisibility.rawValue, forKey: .overflowColumnHeaderVisibility)
        }
        if let verticalOverflowVisibility = self.verticalOverflowVisibility {
            try encodeContainer.encode(verticalOverflowVisibility.rawValue, forKey: .verticalOverflowVisibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let verticalOverflowVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .verticalOverflowVisibility)
        verticalOverflowVisibility = verticalOverflowVisibilityDecoded
        let overflowColumnHeaderVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .overflowColumnHeaderVisibility)
        overflowColumnHeaderVisibility = overflowColumnHeaderVisibilityDecoded
    }
}

extension QuickSightClientTypes {
    /// The paginated report options for a pivot table visual.
    public struct PivotTablePaginatedReportOptions: Swift.Equatable {
        /// The visibility of the repeating header rows on each page.
        public var overflowColumnHeaderVisibility: QuickSightClientTypes.Visibility?
        /// The visibility of the printing table overflow across pages.
        public var verticalOverflowVisibility: QuickSightClientTypes.Visibility?

        public init (
            overflowColumnHeaderVisibility: QuickSightClientTypes.Visibility? = nil,
            verticalOverflowVisibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.overflowColumnHeaderVisibility = overflowColumnHeaderVisibility
            self.verticalOverflowVisibility = verticalOverflowVisibility
        }
    }

}

extension QuickSightClientTypes.PivotTableSortBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case column = "Column"
        case dataPath = "DataPath"
        case field = "Field"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let column = self.column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let dataPath = self.dataPath {
            try encodeContainer.encode(dataPath, forKey: .dataPath)
        }
        if let field = self.field {
            try encodeContainer.encode(field, forKey: .field)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FieldSort.self, forKey: .field)
        field = fieldDecoded
        let columnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnSort.self, forKey: .column)
        column = columnDecoded
        let dataPathDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataPathSort.self, forKey: .dataPath)
        dataPath = dataPathDecoded
    }
}

extension QuickSightClientTypes {
    /// The sort by field for the field sort options.
    public struct PivotTableSortBy: Swift.Equatable {
        /// The column sort (field id, direction) for the pivot table sort by options.
        public var column: QuickSightClientTypes.ColumnSort?
        /// The data path sort (data path value, direction) for the pivot table sort by options.
        public var dataPath: QuickSightClientTypes.DataPathSort?
        /// The field sort (field id, direction) for the pivot table sort by options.
        public var field: QuickSightClientTypes.FieldSort?

        public init (
            column: QuickSightClientTypes.ColumnSort? = nil,
            dataPath: QuickSightClientTypes.DataPathSort? = nil,
            field: QuickSightClientTypes.FieldSort? = nil
        )
        {
            self.column = column
            self.dataPath = dataPath
            self.field = field
        }
    }

}

extension QuickSightClientTypes.PivotTableSortConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldSortOptions = "FieldSortOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldSortOptions = fieldSortOptions {
            var fieldSortOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldSortOptions)
            for pivotfieldsortoptions0 in fieldSortOptions {
                try fieldSortOptionsContainer.encode(pivotfieldsortoptions0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldSortOptionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.PivotFieldSortOptions?].self, forKey: .fieldSortOptions)
        var fieldSortOptionsDecoded0:[QuickSightClientTypes.PivotFieldSortOptions]? = nil
        if let fieldSortOptionsContainer = fieldSortOptionsContainer {
            fieldSortOptionsDecoded0 = [QuickSightClientTypes.PivotFieldSortOptions]()
            for structure0 in fieldSortOptionsContainer {
                if let structure0 = structure0 {
                    fieldSortOptionsDecoded0?.append(structure0)
                }
            }
        }
        fieldSortOptions = fieldSortOptionsDecoded0
    }
}

extension QuickSightClientTypes {
    /// The sort configuration for a PivotTableVisual.
    public struct PivotTableSortConfiguration: Swift.Equatable {
        /// The field sort options for a pivot table sort configuration.
        public var fieldSortOptions: [QuickSightClientTypes.PivotFieldSortOptions]?

        public init (
            fieldSortOptions: [QuickSightClientTypes.PivotFieldSortOptions]? = nil
        )
        {
            self.fieldSortOptions = fieldSortOptions
        }
    }

}

extension QuickSightClientTypes {
    public enum PivotTableSubtotalLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case custom
        case last
        case sdkUnknown(Swift.String)

        public static var allCases: [PivotTableSubtotalLevel] {
            return [
                .all,
                .custom,
                .last,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .custom: return "CUSTOM"
            case .last: return "LAST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PivotTableSubtotalLevel(rawValue: rawValue) ?? PivotTableSubtotalLevel.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.PivotTableTotalOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnSubtotalOptions = "ColumnSubtotalOptions"
        case columnTotalOptions = "ColumnTotalOptions"
        case rowSubtotalOptions = "RowSubtotalOptions"
        case rowTotalOptions = "RowTotalOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnSubtotalOptions = self.columnSubtotalOptions {
            try encodeContainer.encode(columnSubtotalOptions, forKey: .columnSubtotalOptions)
        }
        if let columnTotalOptions = self.columnTotalOptions {
            try encodeContainer.encode(columnTotalOptions, forKey: .columnTotalOptions)
        }
        if let rowSubtotalOptions = self.rowSubtotalOptions {
            try encodeContainer.encode(rowSubtotalOptions, forKey: .rowSubtotalOptions)
        }
        if let rowTotalOptions = self.rowTotalOptions {
            try encodeContainer.encode(rowTotalOptions, forKey: .rowTotalOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowSubtotalOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SubtotalOptions.self, forKey: .rowSubtotalOptions)
        rowSubtotalOptions = rowSubtotalOptionsDecoded
        let columnSubtotalOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SubtotalOptions.self, forKey: .columnSubtotalOptions)
        columnSubtotalOptions = columnSubtotalOptionsDecoded
        let rowTotalOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PivotTotalOptions.self, forKey: .rowTotalOptions)
        rowTotalOptions = rowTotalOptionsDecoded
        let columnTotalOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PivotTotalOptions.self, forKey: .columnTotalOptions)
        columnTotalOptions = columnTotalOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// The total options for a pivot table visual.
    public struct PivotTableTotalOptions: Swift.Equatable {
        /// The column subtotal options.
        public var columnSubtotalOptions: QuickSightClientTypes.SubtotalOptions?
        /// The column total options.
        public var columnTotalOptions: QuickSightClientTypes.PivotTotalOptions?
        /// The row subtotal options.
        public var rowSubtotalOptions: QuickSightClientTypes.SubtotalOptions?
        /// The row total options.
        public var rowTotalOptions: QuickSightClientTypes.PivotTotalOptions?

        public init (
            columnSubtotalOptions: QuickSightClientTypes.SubtotalOptions? = nil,
            columnTotalOptions: QuickSightClientTypes.PivotTotalOptions? = nil,
            rowSubtotalOptions: QuickSightClientTypes.SubtotalOptions? = nil,
            rowTotalOptions: QuickSightClientTypes.PivotTotalOptions? = nil
        )
        {
            self.columnSubtotalOptions = columnSubtotalOptions
            self.columnTotalOptions = columnTotalOptions
            self.rowSubtotalOptions = rowSubtotalOptions
            self.rowTotalOptions = rowTotalOptions
        }
    }

}

extension QuickSightClientTypes.PivotTableVisual: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case chartConfiguration = "ChartConfiguration"
        case conditionalFormatting = "ConditionalFormatting"
        case subtitle = "Subtitle"
        case title = "Title"
        case visualId = "VisualId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for visualcustomaction0 in actions {
                try actionsContainer.encode(visualcustomaction0)
            }
        }
        if let chartConfiguration = self.chartConfiguration {
            try encodeContainer.encode(chartConfiguration, forKey: .chartConfiguration)
        }
        if let conditionalFormatting = self.conditionalFormatting {
            try encodeContainer.encode(conditionalFormatting, forKey: .conditionalFormatting)
        }
        if let subtitle = self.subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let visualId = self.visualId {
            try encodeContainer.encode(visualId, forKey: .visualId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visualIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visualId)
        visualId = visualIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualTitleLabelOptions.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualSubtitleLabelOptions.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let chartConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PivotTableConfiguration.self, forKey: .chartConfiguration)
        chartConfiguration = chartConfigurationDecoded
        let conditionalFormattingDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PivotTableConditionalFormatting.self, forKey: .conditionalFormatting)
        conditionalFormatting = conditionalFormattingDecoded
        let actionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.VisualCustomAction?].self, forKey: .actions)
        var actionsDecoded0:[QuickSightClientTypes.VisualCustomAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [QuickSightClientTypes.VisualCustomAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A pivot table. For more information, see [Using pivot tables](https://docs.aws.amazon.com/quicksight/latest/user/pivot-table.html) in the Amazon QuickSight User Guide.
    public struct PivotTableVisual: Swift.Equatable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration settings of the visual.
        public var chartConfiguration: QuickSightClientTypes.PivotTableConfiguration?
        /// The conditional formatting for a PivotTableVisual.
        public var conditionalFormatting: QuickSightClientTypes.PivotTableConditionalFormatting?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        /// This member is required.
        public var visualId: Swift.String?

        public init (
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.PivotTableConfiguration? = nil,
            conditionalFormatting: QuickSightClientTypes.PivotTableConditionalFormatting? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.conditionalFormatting = conditionalFormatting
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }

}

extension QuickSightClientTypes.PivotTotalOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customLabel = "CustomLabel"
        case metricHeaderCellStyle = "MetricHeaderCellStyle"
        case placement = "Placement"
        case scrollStatus = "ScrollStatus"
        case totalCellStyle = "TotalCellStyle"
        case totalsVisibility = "TotalsVisibility"
        case valueCellStyle = "ValueCellStyle"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customLabel = self.customLabel {
            try encodeContainer.encode(customLabel, forKey: .customLabel)
        }
        if let metricHeaderCellStyle = self.metricHeaderCellStyle {
            try encodeContainer.encode(metricHeaderCellStyle, forKey: .metricHeaderCellStyle)
        }
        if let placement = self.placement {
            try encodeContainer.encode(placement.rawValue, forKey: .placement)
        }
        if let scrollStatus = self.scrollStatus {
            try encodeContainer.encode(scrollStatus.rawValue, forKey: .scrollStatus)
        }
        if let totalCellStyle = self.totalCellStyle {
            try encodeContainer.encode(totalCellStyle, forKey: .totalCellStyle)
        }
        if let totalsVisibility = self.totalsVisibility {
            try encodeContainer.encode(totalsVisibility.rawValue, forKey: .totalsVisibility)
        }
        if let valueCellStyle = self.valueCellStyle {
            try encodeContainer.encode(valueCellStyle, forKey: .valueCellStyle)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalsVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .totalsVisibility)
        totalsVisibility = totalsVisibilityDecoded
        let placementDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableTotalsPlacement.self, forKey: .placement)
        placement = placementDecoded
        let scrollStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableTotalsScrollStatus.self, forKey: .scrollStatus)
        scrollStatus = scrollStatusDecoded
        let customLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customLabel)
        customLabel = customLabelDecoded
        let totalCellStyleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableCellStyle.self, forKey: .totalCellStyle)
        totalCellStyle = totalCellStyleDecoded
        let valueCellStyleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableCellStyle.self, forKey: .valueCellStyle)
        valueCellStyle = valueCellStyleDecoded
        let metricHeaderCellStyleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableCellStyle.self, forKey: .metricHeaderCellStyle)
        metricHeaderCellStyle = metricHeaderCellStyleDecoded
    }
}

extension QuickSightClientTypes {
    /// The optional configuration of totals cells in a PivotTableVisual.
    public struct PivotTotalOptions: Swift.Equatable {
        /// The custom label string for the total cells.
        public var customLabel: Swift.String?
        /// The cell styling options for the total of header cells.
        public var metricHeaderCellStyle: QuickSightClientTypes.TableCellStyle?
        /// The placement (start, end) for the total cells.
        public var placement: QuickSightClientTypes.TableTotalsPlacement?
        /// The scroll status (pinned, scrolled) for the total cells.
        public var scrollStatus: QuickSightClientTypes.TableTotalsScrollStatus?
        /// The cell styling options for the total cells.
        public var totalCellStyle: QuickSightClientTypes.TableCellStyle?
        /// The visibility configuration for the total cells.
        public var totalsVisibility: QuickSightClientTypes.Visibility?
        /// The cell styling options for the totals of value cells.
        public var valueCellStyle: QuickSightClientTypes.TableCellStyle?

        public init (
            customLabel: Swift.String? = nil,
            metricHeaderCellStyle: QuickSightClientTypes.TableCellStyle? = nil,
            placement: QuickSightClientTypes.TableTotalsPlacement? = nil,
            scrollStatus: QuickSightClientTypes.TableTotalsScrollStatus? = nil,
            totalCellStyle: QuickSightClientTypes.TableCellStyle? = nil,
            totalsVisibility: QuickSightClientTypes.Visibility? = nil,
            valueCellStyle: QuickSightClientTypes.TableCellStyle? = nil
        )
        {
            self.customLabel = customLabel
            self.metricHeaderCellStyle = metricHeaderCellStyle
            self.placement = placement
            self.scrollStatus = scrollStatus
            self.totalCellStyle = totalCellStyle
            self.totalsVisibility = totalsVisibility
            self.valueCellStyle = valueCellStyle
        }
    }

}

extension QuickSightClientTypes.PostgreSqlParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for PostgreSQL.
    public struct PostgreSqlParameters: Swift.Equatable {
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int

        public init (
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.database = database
            self.host = host
            self.port = port
        }
    }

}

extension PreconditionNotMetException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PreconditionNotMetExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more preconditions aren't met.
public struct PreconditionNotMetException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct PreconditionNotMetExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension PreconditionNotMetExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.PredefinedHierarchy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columns = "Columns"
        case drillDownFilters = "DrillDownFilters"
        case hierarchyId = "HierarchyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for columnidentifier0 in columns {
                try columnsContainer.encode(columnidentifier0)
            }
        }
        if let drillDownFilters = drillDownFilters {
            var drillDownFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .drillDownFilters)
            for drilldownfilter0 in drillDownFilters {
                try drillDownFiltersContainer.encode(drilldownfilter0)
            }
        }
        if let hierarchyId = self.hierarchyId {
            try encodeContainer.encode(hierarchyId, forKey: .hierarchyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyId)
        hierarchyId = hierarchyIdDecoded
        let columnsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnIdentifier?].self, forKey: .columns)
        var columnsDecoded0:[QuickSightClientTypes.ColumnIdentifier]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [QuickSightClientTypes.ColumnIdentifier]()
            for structure0 in columnsContainer {
                if let structure0 = structure0 {
                    columnsDecoded0?.append(structure0)
                }
            }
        }
        columns = columnsDecoded0
        let drillDownFiltersContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DrillDownFilter?].self, forKey: .drillDownFilters)
        var drillDownFiltersDecoded0:[QuickSightClientTypes.DrillDownFilter]? = nil
        if let drillDownFiltersContainer = drillDownFiltersContainer {
            drillDownFiltersDecoded0 = [QuickSightClientTypes.DrillDownFilter]()
            for structure0 in drillDownFiltersContainer {
                if let structure0 = structure0 {
                    drillDownFiltersDecoded0?.append(structure0)
                }
            }
        }
        drillDownFilters = drillDownFiltersDecoded0
    }
}

extension QuickSightClientTypes {
    /// The option that determines the hierarchy of the fields that are defined during data preparation. These fields are available to use in any analysis that uses the data source.
    public struct PredefinedHierarchy: Swift.Equatable {
        /// The list of columns that define the predefined hierarchy.
        /// This member is required.
        public var columns: [QuickSightClientTypes.ColumnIdentifier]?
        /// The option that determines the drill down filters for the predefined hierarchy.
        public var drillDownFilters: [QuickSightClientTypes.DrillDownFilter]?
        /// The hierarchy ID of the predefined hierarchy.
        /// This member is required.
        public var hierarchyId: Swift.String?

        public init (
            columns: [QuickSightClientTypes.ColumnIdentifier]? = nil,
            drillDownFilters: [QuickSightClientTypes.DrillDownFilter]? = nil,
            hierarchyId: Swift.String? = nil
        )
        {
            self.columns = columns
            self.drillDownFilters = drillDownFilters
            self.hierarchyId = hierarchyId
        }
    }

}

extension QuickSightClientTypes.PrestoParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalog = "Catalog"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalog = self.catalog {
            try encodeContainer.encode(catalog, forKey: .catalog)
        }
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let catalogDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalog)
        catalog = catalogDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for Presto.
    public struct PrestoParameters: Swift.Equatable {
        /// Catalog.
        /// This member is required.
        public var catalog: Swift.String?
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int

        public init (
            catalog: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.catalog = catalog
            self.host = host
            self.port = port
        }
    }

}

extension QuickSightClientTypes {
    public enum PrimaryValueDisplayType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case actual
        case comparison
        case hidden
        case sdkUnknown(Swift.String)

        public static var allCases: [PrimaryValueDisplayType] {
            return [
                .actual,
                .comparison,
                .hidden,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .actual: return "ACTUAL"
            case .comparison: return "COMPARISON"
            case .hidden: return "HIDDEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PrimaryValueDisplayType(rawValue: rawValue) ?? PrimaryValueDisplayType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.ProgressBarOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the presentation of the progress bar of a KPI visual.
    public struct ProgressBarOptions: Swift.Equatable {
        /// The visibility of the progress bar.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.visibility = visibility
        }
    }

}

extension QuickSightClientTypes.ProjectOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectedColumns = "ProjectedColumns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectedColumns = projectedColumns {
            var projectedColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .projectedColumns)
            for string0 in projectedColumns {
                try projectedColumnsContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectedColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .projectedColumns)
        var projectedColumnsDecoded0:[Swift.String]? = nil
        if let projectedColumnsContainer = projectedColumnsContainer {
            projectedColumnsDecoded0 = [Swift.String]()
            for string0 in projectedColumnsContainer {
                if let string0 = string0 {
                    projectedColumnsDecoded0?.append(string0)
                }
            }
        }
        projectedColumns = projectedColumnsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A transform operation that projects columns. Operations that come after a projection can only refer to projected columns.
    public struct ProjectOperation: Swift.Equatable {
        /// Projected columns.
        /// This member is required.
        public var projectedColumns: [Swift.String]?

        public init (
            projectedColumns: [Swift.String]? = nil
        )
        {
            self.projectedColumns = projectedColumns
        }
    }

}

extension QuickSightClientTypes.QueueInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queuedIngestion = "QueuedIngestion"
        case waitingOnIngestion = "WaitingOnIngestion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queuedIngestion = self.queuedIngestion {
            try encodeContainer.encode(queuedIngestion, forKey: .queuedIngestion)
        }
        if let waitingOnIngestion = self.waitingOnIngestion {
            try encodeContainer.encode(waitingOnIngestion, forKey: .waitingOnIngestion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waitingOnIngestionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waitingOnIngestion)
        waitingOnIngestion = waitingOnIngestionDecoded
        let queuedIngestionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queuedIngestion)
        queuedIngestion = queuedIngestionDecoded
    }
}

extension QuickSightClientTypes {
    /// Information about a queued dataset SPICE ingestion.
    public struct QueueInfo: Swift.Equatable {
        /// The ID of the ongoing ingestion. The queued ingestion is waiting for the ongoing ingestion to complete.
        /// This member is required.
        public var queuedIngestion: Swift.String?
        /// The ID of the queued ingestion.
        /// This member is required.
        public var waitingOnIngestion: Swift.String?

        public init (
            queuedIngestion: Swift.String? = nil,
            waitingOnIngestion: Swift.String? = nil
        )
        {
            self.queuedIngestion = queuedIngestion
            self.waitingOnIngestion = waitingOnIngestion
        }
    }

}

extension QuickSightUserNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: QuickSightUserNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user with the provided name isn't found. This error can happen in any operation that requires finding a user based on a provided user name, such as DeleteUser, DescribeUser, and so on.
public struct QuickSightUserNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct QuickSightUserNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension QuickSightUserNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.RangeEndsLabelType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension QuickSightClientTypes {
    /// The range ends label type of a data path label.
    public struct RangeEndsLabelType: Swift.Equatable {
        /// The visibility of the range ends label.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.visibility = visibility
        }
    }

}

extension QuickSightClientTypes.RdsParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for Amazon RDS.
    public struct RdsParameters: Swift.Equatable {
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Instance ID.
        /// This member is required.
        public var instanceId: Swift.String?

        public init (
            database: Swift.String? = nil,
            instanceId: Swift.String? = nil
        )
        {
            self.database = database
            self.instanceId = instanceId
        }
    }

}

extension QuickSightClientTypes.RedshiftParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterId = self.clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for Amazon Redshift. The ClusterId field can be blank if Host and Port are both set. The Host and Port fields can be blank if the ClusterId field is set.
    public struct RedshiftParameters: Swift.Equatable {
        /// Cluster ID. This field can be blank if the Host and Port are provided.
        public var clusterId: Swift.String?
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Host. This field can be blank if ClusterId is provided.
        public var host: Swift.String?
        /// Port. This field can be blank if the ClusterId is provided.
        public var port: Swift.Int

        public init (
            clusterId: Swift.String? = nil,
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.clusterId = clusterId
            self.database = database
            self.host = host
            self.port = port
        }
    }

}

extension QuickSightClientTypes.ReferenceLine: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataConfiguration = "DataConfiguration"
        case labelConfiguration = "LabelConfiguration"
        case status = "Status"
        case styleConfiguration = "StyleConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataConfiguration = self.dataConfiguration {
            try encodeContainer.encode(dataConfiguration, forKey: .dataConfiguration)
        }
        if let labelConfiguration = self.labelConfiguration {
            try encodeContainer.encode(labelConfiguration, forKey: .labelConfiguration)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let styleConfiguration = self.styleConfiguration {
            try encodeContainer.encode(styleConfiguration, forKey: .styleConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.WidgetStatus.self, forKey: .status)
        status = statusDecoded
        let dataConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ReferenceLineDataConfiguration.self, forKey: .dataConfiguration)
        dataConfiguration = dataConfigurationDecoded
        let styleConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ReferenceLineStyleConfiguration.self, forKey: .styleConfiguration)
        styleConfiguration = styleConfigurationDecoded
        let labelConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ReferenceLineLabelConfiguration.self, forKey: .labelConfiguration)
        labelConfiguration = labelConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The reference line visual display options.
    public struct ReferenceLine: Swift.Equatable {
        /// The data configuration of the reference line.
        /// This member is required.
        public var dataConfiguration: QuickSightClientTypes.ReferenceLineDataConfiguration?
        /// The label configuration of the reference line.
        public var labelConfiguration: QuickSightClientTypes.ReferenceLineLabelConfiguration?
        /// The status of the reference line. Choose one of the following options:
        ///
        /// * ENABLE
        ///
        /// * DISABLE
        public var status: QuickSightClientTypes.WidgetStatus?
        /// The style configuration of the reference line.
        public var styleConfiguration: QuickSightClientTypes.ReferenceLineStyleConfiguration?

        public init (
            dataConfiguration: QuickSightClientTypes.ReferenceLineDataConfiguration? = nil,
            labelConfiguration: QuickSightClientTypes.ReferenceLineLabelConfiguration? = nil,
            status: QuickSightClientTypes.WidgetStatus? = nil,
            styleConfiguration: QuickSightClientTypes.ReferenceLineStyleConfiguration? = nil
        )
        {
            self.dataConfiguration = dataConfiguration
            self.labelConfiguration = labelConfiguration
            self.status = status
            self.styleConfiguration = styleConfiguration
        }
    }

}

extension QuickSightClientTypes.ReferenceLineCustomLabelConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customLabel = "CustomLabel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customLabel = self.customLabel {
            try encodeContainer.encode(customLabel, forKey: .customLabel)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customLabel)
        customLabel = customLabelDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration for a custom label on a ReferenceLine.
    public struct ReferenceLineCustomLabelConfiguration: Swift.Equatable {
        /// The string text of the custom label.
        /// This member is required.
        public var customLabel: Swift.String?

        public init (
            customLabel: Swift.String? = nil
        )
        {
            self.customLabel = customLabel
        }
    }

}

extension QuickSightClientTypes.ReferenceLineDataConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case axisBinding = "AxisBinding"
        case dynamicConfiguration = "DynamicConfiguration"
        case staticConfiguration = "StaticConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let axisBinding = self.axisBinding {
            try encodeContainer.encode(axisBinding.rawValue, forKey: .axisBinding)
        }
        if let dynamicConfiguration = self.dynamicConfiguration {
            try encodeContainer.encode(dynamicConfiguration, forKey: .dynamicConfiguration)
        }
        if let staticConfiguration = self.staticConfiguration {
            try encodeContainer.encode(staticConfiguration, forKey: .staticConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let staticConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ReferenceLineStaticDataConfiguration.self, forKey: .staticConfiguration)
        staticConfiguration = staticConfigurationDecoded
        let dynamicConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ReferenceLineDynamicDataConfiguration.self, forKey: .dynamicConfiguration)
        dynamicConfiguration = dynamicConfigurationDecoded
        let axisBindingDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisBinding.self, forKey: .axisBinding)
        axisBinding = axisBindingDecoded
    }
}

extension QuickSightClientTypes {
    /// The data configuration of the reference line.
    public struct ReferenceLineDataConfiguration: Swift.Equatable {
        /// The axis binding type of the reference line. Choose one of the following options:
        ///
        /// * PrimaryY
        ///
        /// * SecondaryY
        public var axisBinding: QuickSightClientTypes.AxisBinding?
        /// The dynamic configuration of the reference line data configuration.
        public var dynamicConfiguration: QuickSightClientTypes.ReferenceLineDynamicDataConfiguration?
        /// The static data configuration of the reference line data configuration.
        public var staticConfiguration: QuickSightClientTypes.ReferenceLineStaticDataConfiguration?

        public init (
            axisBinding: QuickSightClientTypes.AxisBinding? = nil,
            dynamicConfiguration: QuickSightClientTypes.ReferenceLineDynamicDataConfiguration? = nil,
            staticConfiguration: QuickSightClientTypes.ReferenceLineStaticDataConfiguration? = nil
        )
        {
            self.axisBinding = axisBinding
            self.dynamicConfiguration = dynamicConfiguration
            self.staticConfiguration = staticConfiguration
        }
    }

}

extension QuickSightClientTypes.ReferenceLineDynamicDataConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculation = "Calculation"
        case column = "Column"
        case measureAggregationFunction = "MeasureAggregationFunction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let calculation = self.calculation {
            try encodeContainer.encode(calculation, forKey: .calculation)
        }
        if let column = self.column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let measureAggregationFunction = self.measureAggregationFunction {
            try encodeContainer.encode(measureAggregationFunction, forKey: .measureAggregationFunction)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .column)
        column = columnDecoded
        let measureAggregationFunctionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AggregationFunction.self, forKey: .measureAggregationFunction)
        measureAggregationFunction = measureAggregationFunctionDecoded
        let calculationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumericalAggregationFunction.self, forKey: .calculation)
        calculation = calculationDecoded
    }
}

extension QuickSightClientTypes {
    /// The dynamic configuration of the reference line data configuration.
    public struct ReferenceLineDynamicDataConfiguration: Swift.Equatable {
        /// The calculation that is used in the dynamic data.
        /// This member is required.
        public var calculation: QuickSightClientTypes.NumericalAggregationFunction?
        /// The column that the dynamic data targets.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The aggregation function that is used in the dynamic data.
        /// This member is required.
        public var measureAggregationFunction: QuickSightClientTypes.AggregationFunction?

        public init (
            calculation: QuickSightClientTypes.NumericalAggregationFunction? = nil,
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            measureAggregationFunction: QuickSightClientTypes.AggregationFunction? = nil
        )
        {
            self.calculation = calculation
            self.column = column
            self.measureAggregationFunction = measureAggregationFunction
        }
    }

}

extension QuickSightClientTypes.ReferenceLineLabelConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customLabelConfiguration = "CustomLabelConfiguration"
        case fontColor = "FontColor"
        case fontConfiguration = "FontConfiguration"
        case horizontalPosition = "HorizontalPosition"
        case valueLabelConfiguration = "ValueLabelConfiguration"
        case verticalPosition = "VerticalPosition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customLabelConfiguration = self.customLabelConfiguration {
            try encodeContainer.encode(customLabelConfiguration, forKey: .customLabelConfiguration)
        }
        if let fontColor = self.fontColor {
            try encodeContainer.encode(fontColor, forKey: .fontColor)
        }
        if let fontConfiguration = self.fontConfiguration {
            try encodeContainer.encode(fontConfiguration, forKey: .fontConfiguration)
        }
        if let horizontalPosition = self.horizontalPosition {
            try encodeContainer.encode(horizontalPosition.rawValue, forKey: .horizontalPosition)
        }
        if let valueLabelConfiguration = self.valueLabelConfiguration {
            try encodeContainer.encode(valueLabelConfiguration, forKey: .valueLabelConfiguration)
        }
        if let verticalPosition = self.verticalPosition {
            try encodeContainer.encode(verticalPosition.rawValue, forKey: .verticalPosition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueLabelConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ReferenceLineValueLabelConfiguration.self, forKey: .valueLabelConfiguration)
        valueLabelConfiguration = valueLabelConfigurationDecoded
        let customLabelConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ReferenceLineCustomLabelConfiguration.self, forKey: .customLabelConfiguration)
        customLabelConfiguration = customLabelConfigurationDecoded
        let fontConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FontConfiguration.self, forKey: .fontConfiguration)
        fontConfiguration = fontConfigurationDecoded
        let fontColorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fontColor)
        fontColor = fontColorDecoded
        let horizontalPositionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ReferenceLineLabelHorizontalPosition.self, forKey: .horizontalPosition)
        horizontalPosition = horizontalPositionDecoded
        let verticalPositionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ReferenceLineLabelVerticalPosition.self, forKey: .verticalPosition)
        verticalPosition = verticalPositionDecoded
    }
}

extension QuickSightClientTypes {
    /// The label configuration of a reference line.
    public struct ReferenceLineLabelConfiguration: Swift.Equatable {
        /// The custom label configuration of the label in a reference line.
        public var customLabelConfiguration: QuickSightClientTypes.ReferenceLineCustomLabelConfiguration?
        /// The font color configuration of the label in a reference line.
        public var fontColor: Swift.String?
        /// The font configuration of the label in a reference line.
        public var fontConfiguration: QuickSightClientTypes.FontConfiguration?
        /// The horizontal position configuration of the label in a reference line. Choose one of the following options:
        ///
        /// * LEFT
        ///
        /// * CENTER
        ///
        /// * RIGHT
        public var horizontalPosition: QuickSightClientTypes.ReferenceLineLabelHorizontalPosition?
        /// The value label configuration of the label in a reference line.
        public var valueLabelConfiguration: QuickSightClientTypes.ReferenceLineValueLabelConfiguration?
        /// The vertical position configuration of the label in a reference line. Choose one of the following options:
        ///
        /// * ABOVE
        ///
        /// * BELOW
        public var verticalPosition: QuickSightClientTypes.ReferenceLineLabelVerticalPosition?

        public init (
            customLabelConfiguration: QuickSightClientTypes.ReferenceLineCustomLabelConfiguration? = nil,
            fontColor: Swift.String? = nil,
            fontConfiguration: QuickSightClientTypes.FontConfiguration? = nil,
            horizontalPosition: QuickSightClientTypes.ReferenceLineLabelHorizontalPosition? = nil,
            valueLabelConfiguration: QuickSightClientTypes.ReferenceLineValueLabelConfiguration? = nil,
            verticalPosition: QuickSightClientTypes.ReferenceLineLabelVerticalPosition? = nil
        )
        {
            self.customLabelConfiguration = customLabelConfiguration
            self.fontColor = fontColor
            self.fontConfiguration = fontConfiguration
            self.horizontalPosition = horizontalPosition
            self.valueLabelConfiguration = valueLabelConfiguration
            self.verticalPosition = verticalPosition
        }
    }

}

extension QuickSightClientTypes {
    public enum ReferenceLineLabelHorizontalPosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case center
        case `left`
        case `right`
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceLineLabelHorizontalPosition] {
            return [
                .center,
                .left,
                .right,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .center: return "CENTER"
            case .left: return "LEFT"
            case .right: return "RIGHT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReferenceLineLabelHorizontalPosition(rawValue: rawValue) ?? ReferenceLineLabelHorizontalPosition.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum ReferenceLineLabelVerticalPosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case above
        case below
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceLineLabelVerticalPosition] {
            return [
                .above,
                .below,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .above: return "ABOVE"
            case .below: return "BELOW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReferenceLineLabelVerticalPosition(rawValue: rawValue) ?? ReferenceLineLabelVerticalPosition.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum ReferenceLinePatternType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dashed
        case dotted
        case solid
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceLinePatternType] {
            return [
                .dashed,
                .dotted,
                .solid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dashed: return "DASHED"
            case .dotted: return "DOTTED"
            case .solid: return "SOLID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReferenceLinePatternType(rawValue: rawValue) ?? ReferenceLinePatternType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.ReferenceLineStaticDataConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if value != 0.0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value) ?? 0.0
        value = valueDecoded
    }
}

extension QuickSightClientTypes.ReferenceLineStaticDataConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReferenceLineStaticDataConfiguration(value: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {
    /// The static data configuration of the reference line data configuration.
    public struct ReferenceLineStaticDataConfiguration: Swift.Equatable {
        /// The double input of the static data.
        /// This member is required.
        public var value: Swift.Double

        public init (
            value: Swift.Double = 0.0
        )
        {
            self.value = value
        }
    }

}

extension QuickSightClientTypes.ReferenceLineStyleConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case color = "Color"
        case pattern = "Pattern"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let color = self.color {
            try encodeContainer.encode(color, forKey: .color)
        }
        if let pattern = self.pattern {
            try encodeContainer.encode(pattern.rawValue, forKey: .pattern)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patternDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ReferenceLinePatternType.self, forKey: .pattern)
        pattern = patternDecoded
        let colorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .color)
        color = colorDecoded
    }
}

extension QuickSightClientTypes {
    /// The style configuration of the reference line.
    public struct ReferenceLineStyleConfiguration: Swift.Equatable {
        /// The hex color of the reference line.
        public var color: Swift.String?
        /// The pattern type of the line style. Choose one of the following options:
        ///
        /// * SOLID
        ///
        /// * DASHED
        ///
        /// * DOTTED
        public var pattern: QuickSightClientTypes.ReferenceLinePatternType?

        public init (
            color: Swift.String? = nil,
            pattern: QuickSightClientTypes.ReferenceLinePatternType? = nil
        )
        {
            self.color = color
            self.pattern = pattern
        }
    }

}

extension QuickSightClientTypes.ReferenceLineValueLabelConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case formatConfiguration = "FormatConfiguration"
        case relativePosition = "RelativePosition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let formatConfiguration = self.formatConfiguration {
            try encodeContainer.encode(formatConfiguration, forKey: .formatConfiguration)
        }
        if let relativePosition = self.relativePosition {
            try encodeContainer.encode(relativePosition.rawValue, forKey: .relativePosition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relativePositionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ReferenceLineValueLabelRelativePosition.self, forKey: .relativePosition)
        relativePosition = relativePositionDecoded
        let formatConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumericFormatConfiguration.self, forKey: .formatConfiguration)
        formatConfiguration = formatConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The value label configuration of the label in a reference line.
    public struct ReferenceLineValueLabelConfiguration: Swift.Equatable {
        /// The format configuration of the value label.
        public var formatConfiguration: QuickSightClientTypes.NumericFormatConfiguration?
        /// The relative position of the value label. Choose one of the following options:
        ///
        /// * BEFORE_CUSTOM_LABEL
        ///
        /// * AFTER_CUSTOM_LABEL
        public var relativePosition: QuickSightClientTypes.ReferenceLineValueLabelRelativePosition?

        public init (
            formatConfiguration: QuickSightClientTypes.NumericFormatConfiguration? = nil,
            relativePosition: QuickSightClientTypes.ReferenceLineValueLabelRelativePosition? = nil
        )
        {
            self.formatConfiguration = formatConfiguration
            self.relativePosition = relativePosition
        }
    }

}

extension QuickSightClientTypes {
    public enum ReferenceLineValueLabelRelativePosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case afterCustomLabel
        case beforeCustomLabel
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceLineValueLabelRelativePosition] {
            return [
                .afterCustomLabel,
                .beforeCustomLabel,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .afterCustomLabel: return "AFTER_CUSTOM_LABEL"
            case .beforeCustomLabel: return "BEFORE_CUSTOM_LABEL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReferenceLineValueLabelRelativePosition(rawValue: rawValue) ?? ReferenceLineValueLabelRelativePosition.sdkUnknown(rawValue)
        }
    }
}

extension RegisterUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customFederationProviderUrl = "CustomFederationProviderUrl"
        case customPermissionsName = "CustomPermissionsName"
        case email = "Email"
        case externalLoginFederationProviderType = "ExternalLoginFederationProviderType"
        case externalLoginId = "ExternalLoginId"
        case iamArn = "IamArn"
        case identityType = "IdentityType"
        case sessionName = "SessionName"
        case userName = "UserName"
        case userRole = "UserRole"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customFederationProviderUrl = self.customFederationProviderUrl {
            try encodeContainer.encode(customFederationProviderUrl, forKey: .customFederationProviderUrl)
        }
        if let customPermissionsName = self.customPermissionsName {
            try encodeContainer.encode(customPermissionsName, forKey: .customPermissionsName)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let externalLoginFederationProviderType = self.externalLoginFederationProviderType {
            try encodeContainer.encode(externalLoginFederationProviderType, forKey: .externalLoginFederationProviderType)
        }
        if let externalLoginId = self.externalLoginId {
            try encodeContainer.encode(externalLoginId, forKey: .externalLoginId)
        }
        if let iamArn = self.iamArn {
            try encodeContainer.encode(iamArn, forKey: .iamArn)
        }
        if let identityType = self.identityType {
            try encodeContainer.encode(identityType.rawValue, forKey: .identityType)
        }
        if let sessionName = self.sessionName {
            try encodeContainer.encode(sessionName, forKey: .sessionName)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userRole = self.userRole {
            try encodeContainer.encode(userRole.rawValue, forKey: .userRole)
        }
    }
}

extension RegisterUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/users"
    }
}

public struct RegisterUserInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The URL of the custom OpenID Connect (OIDC) provider that provides identity to let a user federate into Amazon QuickSight with an associated Identity and Access Management(IAM) role. This parameter should only be used when ExternalLoginFederationProviderType parameter is set to CUSTOM_OIDC.
    public var customFederationProviderUrl: Swift.String?
    /// (Enterprise edition only) The name of the custom permissions profile that you want to assign to this user. Customized permissions allows you to control a user's access by restricting access the following operations:
    ///
    /// * Create and update data sources
    ///
    /// * Create and update datasets
    ///
    /// * Create and update email reports
    ///
    /// * Subscribe to email reports
    ///
    ///
    /// To add custom permissions to an existing user, use [UpdateUser](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_UpdateUser.html) instead. A set of custom permissions includes any combination of these restrictions. Currently, you need to create the profile names for custom permission sets by using the Amazon QuickSight console. Then, you use the RegisterUser API operation to assign the named set of permissions to a Amazon QuickSight user. Amazon QuickSight custom permissions are applied through IAM policies. Therefore, they override the permissions typically granted by assigning Amazon QuickSight users to one of the default security cohorts in Amazon QuickSight (admin, author, reader). This feature is available only to Amazon QuickSight Enterprise edition subscriptions.
    public var customPermissionsName: Swift.String?
    /// The email address of the user that you want to register.
    /// This member is required.
    public var email: Swift.String?
    /// The type of supported external login provider that provides identity to let a user federate into Amazon QuickSight with an associated Identity and Access Management(IAM) role. The type of supported external login provider can be one of the following.
    ///
    /// * COGNITO: Amazon Cognito. The provider URL is cognito-identity.amazonaws.com. When choosing the COGNITO provider type, dont use the "CustomFederationProviderUrl" parameter which is only needed when the external provider is custom.
    ///
    /// * CUSTOM_OIDC: Custom OpenID Connect (OIDC) provider. When choosing CUSTOM_OIDC type, use the CustomFederationProviderUrl parameter to provide the custom OIDC provider URL.
    public var externalLoginFederationProviderType: Swift.String?
    /// The identity ID for a user in the external login provider.
    public var externalLoginId: Swift.String?
    /// The ARN of the IAM user or role that you are registering with Amazon QuickSight.
    public var iamArn: Swift.String?
    /// Amazon QuickSight supports several ways of managing the identity of users. This parameter accepts two values:
    ///
    /// * IAM: A user whose identity maps to an existing IAM user or role.
    ///
    /// * QUICKSIGHT: A user whose identity is owned and managed internally by Amazon QuickSight.
    /// This member is required.
    public var identityType: QuickSightClientTypes.IdentityType?
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// You need to use this parameter only when you register one or more users using an assumed IAM role. You don't need to provide the session name for other scenarios, for example when you are registering an IAM user or an Amazon QuickSight user. You can register multiple users using the same IAM role if each user has a different session name. For more information on assuming IAM roles, see [assume-role](https://docs.aws.amazon.com/cli/latest/reference/sts/assume-role.html) in the CLI Reference.
    public var sessionName: Swift.String?
    /// The Amazon QuickSight user name that you want to create for the user you are registering.
    public var userName: Swift.String?
    /// The Amazon QuickSight role for the user. The user role can be one of the following:
    ///
    /// * READER: A user who has read-only access to dashboards.
    ///
    /// * AUTHOR: A user who can create data sources, datasets, analyses, and dashboards.
    ///
    /// * ADMIN: A user who is an author, who can also manage Amazon QuickSight settings.
    ///
    /// * RESTRICTED_READER: This role isn't currently available for use.
    ///
    /// * RESTRICTED_AUTHOR: This role isn't currently available for use.
    /// This member is required.
    public var userRole: QuickSightClientTypes.UserRole?

    public init (
        awsAccountId: Swift.String? = nil,
        customFederationProviderUrl: Swift.String? = nil,
        customPermissionsName: Swift.String? = nil,
        email: Swift.String? = nil,
        externalLoginFederationProviderType: Swift.String? = nil,
        externalLoginId: Swift.String? = nil,
        iamArn: Swift.String? = nil,
        identityType: QuickSightClientTypes.IdentityType? = nil,
        namespace: Swift.String? = nil,
        sessionName: Swift.String? = nil,
        userName: Swift.String? = nil,
        userRole: QuickSightClientTypes.UserRole? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.customFederationProviderUrl = customFederationProviderUrl
        self.customPermissionsName = customPermissionsName
        self.email = email
        self.externalLoginFederationProviderType = externalLoginFederationProviderType
        self.externalLoginId = externalLoginId
        self.iamArn = iamArn
        self.identityType = identityType
        self.namespace = namespace
        self.sessionName = sessionName
        self.userName = userName
        self.userRole = userRole
    }
}

struct RegisterUserInputBody: Swift.Equatable {
    let identityType: QuickSightClientTypes.IdentityType?
    let email: Swift.String?
    let userRole: QuickSightClientTypes.UserRole?
    let iamArn: Swift.String?
    let sessionName: Swift.String?
    let userName: Swift.String?
    let customPermissionsName: Swift.String?
    let externalLoginFederationProviderType: Swift.String?
    let customFederationProviderUrl: Swift.String?
    let externalLoginId: Swift.String?
}

extension RegisterUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customFederationProviderUrl = "CustomFederationProviderUrl"
        case customPermissionsName = "CustomPermissionsName"
        case email = "Email"
        case externalLoginFederationProviderType = "ExternalLoginFederationProviderType"
        case externalLoginId = "ExternalLoginId"
        case iamArn = "IamArn"
        case identityType = "IdentityType"
        case sessionName = "SessionName"
        case userName = "UserName"
        case userRole = "UserRole"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IdentityType.self, forKey: .identityType)
        identityType = identityTypeDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let userRoleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.UserRole.self, forKey: .userRole)
        userRole = userRoleDecoded
        let iamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamArn)
        iamArn = iamArnDecoded
        let sessionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionName)
        sessionName = sessionNameDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let customPermissionsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customPermissionsName)
        customPermissionsName = customPermissionsNameDecoded
        let externalLoginFederationProviderTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalLoginFederationProviderType)
        externalLoginFederationProviderType = externalLoginFederationProviderTypeDecoded
        let customFederationProviderUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customFederationProviderUrl)
        customFederationProviderUrl = customFederationProviderUrlDecoded
        let externalLoginIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalLoginId)
        externalLoginId = externalLoginIdDecoded
    }
}

extension RegisterUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RegisterUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RegisterUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.user = output.user
            self.userInvitationUrl = output.userInvitationUrl
        } else {
            self.requestId = nil
            self.user = nil
            self.userInvitationUrl = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct RegisterUserOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The user's user name.
    public var user: QuickSightClientTypes.User?
    /// The URL the user visits to complete registration and provide a password. This is returned only for users with an identity type of QUICKSIGHT.
    public var userInvitationUrl: Swift.String?

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        user: QuickSightClientTypes.User? = nil,
        userInvitationUrl: Swift.String? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.user = user
        self.userInvitationUrl = userInvitationUrl
    }
}

struct RegisterUserOutputResponseBody: Swift.Equatable {
    let user: QuickSightClientTypes.User?
    let userInvitationUrl: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension RegisterUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case user = "User"
        case userInvitationUrl = "UserInvitationUrl"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.User.self, forKey: .user)
        user = userDecoded
        let userInvitationUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userInvitationUrl)
        userInvitationUrl = userInvitationUrlDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension QuickSightClientTypes.RegisteredUserDashboardEmbeddingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialDashboardId = "InitialDashboardId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialDashboardId = self.initialDashboardId {
            try encodeContainer.encode(initialDashboardId, forKey: .initialDashboardId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialDashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialDashboardId)
        initialDashboardId = initialDashboardIdDecoded
    }
}

extension QuickSightClientTypes {
    /// Information about the dashboard you want to embed.
    public struct RegisteredUserDashboardEmbeddingConfiguration: Swift.Equatable {
        /// The dashboard ID for the dashboard that you want the user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this dashboard if the user has permissions to view it. If the user does not have permission to view this dashboard, they see a permissions error message.
        /// This member is required.
        public var initialDashboardId: Swift.String?

        public init (
            initialDashboardId: Swift.String? = nil
        )
        {
            self.initialDashboardId = initialDashboardId
        }
    }

}

extension QuickSightClientTypes.RegisteredUserDashboardVisualEmbeddingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialDashboardVisualId = "InitialDashboardVisualId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialDashboardVisualId = self.initialDashboardVisualId {
            try encodeContainer.encode(initialDashboardVisualId, forKey: .initialDashboardVisualId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialDashboardVisualIdDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardVisualId.self, forKey: .initialDashboardVisualId)
        initialDashboardVisualId = initialDashboardVisualIdDecoded
    }
}

extension QuickSightClientTypes {
    /// The experience that you are embedding. You can use this object to generate a url that embeds a visual into your application.
    public struct RegisteredUserDashboardVisualEmbeddingConfiguration: Swift.Equatable {
        /// The visual ID for the visual that you want the user to embed. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this visual. The Amazon Resource Name (ARN) of the dashboard that the visual belongs to must be included in the AuthorizedResourceArns parameter. Otherwise, the request will fail with InvalidParameterValueException.
        /// This member is required.
        public var initialDashboardVisualId: QuickSightClientTypes.DashboardVisualId?

        public init (
            initialDashboardVisualId: QuickSightClientTypes.DashboardVisualId? = nil
        )
        {
            self.initialDashboardVisualId = initialDashboardVisualId
        }
    }

}

extension QuickSightClientTypes.RegisteredUserEmbeddingExperienceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboard = "Dashboard"
        case dashboardVisual = "DashboardVisual"
        case qSearchBar = "QSearchBar"
        case quickSightConsole = "QuickSightConsole"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dashboard = self.dashboard {
            try encodeContainer.encode(dashboard, forKey: .dashboard)
        }
        if let dashboardVisual = self.dashboardVisual {
            try encodeContainer.encode(dashboardVisual, forKey: .dashboardVisual)
        }
        if let qSearchBar = self.qSearchBar {
            try encodeContainer.encode(qSearchBar, forKey: .qSearchBar)
        }
        if let quickSightConsole = self.quickSightConsole {
            try encodeContainer.encode(quickSightConsole, forKey: .quickSightConsole)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RegisteredUserDashboardEmbeddingConfiguration.self, forKey: .dashboard)
        dashboard = dashboardDecoded
        let quickSightConsoleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RegisteredUserQuickSightConsoleEmbeddingConfiguration.self, forKey: .quickSightConsole)
        quickSightConsole = quickSightConsoleDecoded
        let qSearchBarDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RegisteredUserQSearchBarEmbeddingConfiguration.self, forKey: .qSearchBar)
        qSearchBar = qSearchBarDecoded
        let dashboardVisualDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RegisteredUserDashboardVisualEmbeddingConfiguration.self, forKey: .dashboardVisual)
        dashboardVisual = dashboardVisualDecoded
    }
}

extension QuickSightClientTypes {
    /// The type of experience you want to embed. For registered users, you can embed Amazon QuickSight dashboards or the Amazon QuickSight console. Exactly one of the experience configurations is required. You can choose Dashboard or QuickSightConsole. You cannot choose more than one experience configuration.
    public struct RegisteredUserEmbeddingExperienceConfiguration: Swift.Equatable {
        /// The configuration details for providing a dashboard embedding experience.
        public var dashboard: QuickSightClientTypes.RegisteredUserDashboardEmbeddingConfiguration?
        /// The type of embedding experience. In this case, Amazon QuickSight visuals.
        public var dashboardVisual: QuickSightClientTypes.RegisteredUserDashboardVisualEmbeddingConfiguration?
        /// The configuration details for embedding the Q search bar. For more information about embedding the Q search bar, see [Embedding Overview](https://docs.aws.amazon.com/quicksight/latest/user/embedding-overview.html) in the Amazon QuickSight User Guide.
        public var qSearchBar: QuickSightClientTypes.RegisteredUserQSearchBarEmbeddingConfiguration?
        /// The configuration details for providing each Amazon QuickSight console embedding experience. This can be used along with custom permissions to restrict access to certain features. For more information, see [Customizing Access to the Amazon QuickSight Console](https://docs.aws.amazon.com/quicksight/latest/user/customizing-permissions-to-the-quicksight-console.html) in the Amazon QuickSight User Guide. Use [GenerateEmbedUrlForRegisteredUser](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_GenerateEmbedUrlForRegisteredUser.html) where you want to provide an authoring portal that allows users to create data sources, datasets, analyses, and dashboards. The users who accesses an embedded Amazon QuickSight console needs to belong to the author or admin security cohort. If you want to restrict permissions to some of these features, add a custom permissions profile to the user with the [UpdateUser](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_UpdateUser.html) API operation. Use the [RegisterUser](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_RegisterUser.html) API operation to add a new user with a custom permission profile attached. For more information, see the following sections in the Amazon QuickSight User Guide:
        ///
        /// * [Embedding the Full Functionality of the Amazon QuickSight Console for Authenticated Users](https://docs.aws.amazon.com/quicksight/latest/user/embedded-analytics-full-console-for-authenticated-users.html)
        ///
        /// * [Customizing Access to the Amazon QuickSight Console](https://docs.aws.amazon.com/quicksight/latest/user/customizing-permissions-to-the-quicksight-console.html)
        ///
        ///
        /// For more information about the high-level steps for embedding and for an interactive demo of the ways you can customize embedding, visit the [Amazon QuickSight Developer Portal](https://docs.aws.amazon.com/quicksight/latest/user/quicksight-dev-portal.html).
        public var quickSightConsole: QuickSightClientTypes.RegisteredUserQuickSightConsoleEmbeddingConfiguration?

        public init (
            dashboard: QuickSightClientTypes.RegisteredUserDashboardEmbeddingConfiguration? = nil,
            dashboardVisual: QuickSightClientTypes.RegisteredUserDashboardVisualEmbeddingConfiguration? = nil,
            qSearchBar: QuickSightClientTypes.RegisteredUserQSearchBarEmbeddingConfiguration? = nil,
            quickSightConsole: QuickSightClientTypes.RegisteredUserQuickSightConsoleEmbeddingConfiguration? = nil
        )
        {
            self.dashboard = dashboard
            self.dashboardVisual = dashboardVisual
            self.qSearchBar = qSearchBar
            self.quickSightConsole = quickSightConsole
        }
    }

}

extension QuickSightClientTypes.RegisteredUserQSearchBarEmbeddingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialTopicId = "InitialTopicId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialTopicId = self.initialTopicId {
            try encodeContainer.encode(initialTopicId, forKey: .initialTopicId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialTopicIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialTopicId)
        initialTopicId = initialTopicIdDecoded
    }
}

extension QuickSightClientTypes {
    /// Information about the Q search bar embedding experience.
    public struct RegisteredUserQSearchBarEmbeddingConfiguration: Swift.Equatable {
        /// The ID of the Q topic that you want to make the starting topic in the Q search bar. You can find a topic ID by navigating to the Topics pane in the Amazon QuickSight application and opening a topic. The ID is in the URL for the topic that you open. If you don't specify an initial topic, a list of all shared topics is shown in the Q bar for your readers. When you select an initial topic, you can specify whether or not readers are allowed to select other topics from the available ones in the list.
        public var initialTopicId: Swift.String?

        public init (
            initialTopicId: Swift.String? = nil
        )
        {
            self.initialTopicId = initialTopicId
        }
    }

}

extension QuickSightClientTypes.RegisteredUserQuickSightConsoleEmbeddingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialPath = "InitialPath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialPath = self.initialPath {
            try encodeContainer.encode(initialPath, forKey: .initialPath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialPath)
        initialPath = initialPathDecoded
    }
}

extension QuickSightClientTypes {
    /// Information about the Amazon QuickSight console that you want to embed.
    public struct RegisteredUserQuickSightConsoleEmbeddingConfiguration: Swift.Equatable {
        /// The initial URL path for the Amazon QuickSight console. InitialPath is required. The entry point URL is constrained to the following paths:
        ///
        /// * /start
        ///
        /// * /start/analyses
        ///
        /// * /start/dashboards
        ///
        /// * /start/favorites
        ///
        /// * /dashboards/DashboardId. DashboardId is the actual ID key from the Amazon QuickSight console URL of the dashboard.
        ///
        /// * /analyses/AnalysisId. AnalysisId is the actual ID key from the Amazon QuickSight console URL of the analysis.
        public var initialPath: Swift.String?

        public init (
            initialPath: Swift.String? = nil
        )
        {
            self.initialPath = initialPath
        }
    }

}

extension QuickSightClientTypes.RelationalTable: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalog = "Catalog"
        case dataSourceArn = "DataSourceArn"
        case inputColumns = "InputColumns"
        case name = "Name"
        case schema = "Schema"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalog = self.catalog {
            try encodeContainer.encode(catalog, forKey: .catalog)
        }
        if let dataSourceArn = self.dataSourceArn {
            try encodeContainer.encode(dataSourceArn, forKey: .dataSourceArn)
        }
        if let inputColumns = inputColumns {
            var inputColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputColumns)
            for inputcolumn0 in inputColumns {
                try inputColumnsContainer.encode(inputcolumn0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceArn)
        dataSourceArn = dataSourceArnDecoded
        let catalogDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalog)
        catalog = catalogDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let inputColumnsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.InputColumn?].self, forKey: .inputColumns)
        var inputColumnsDecoded0:[QuickSightClientTypes.InputColumn]? = nil
        if let inputColumnsContainer = inputColumnsContainer {
            inputColumnsDecoded0 = [QuickSightClientTypes.InputColumn]()
            for structure0 in inputColumnsContainer {
                if let structure0 = structure0 {
                    inputColumnsDecoded0?.append(structure0)
                }
            }
        }
        inputColumns = inputColumnsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A physical table type for relational data sources.
    public struct RelationalTable: Swift.Equatable {
        /// The catalog associated with a table.
        public var catalog: Swift.String?
        /// The Amazon Resource Name (ARN) for the data source.
        /// This member is required.
        public var dataSourceArn: Swift.String?
        /// The column schema of the table.
        /// This member is required.
        public var inputColumns: [QuickSightClientTypes.InputColumn]?
        /// The name of the relational table.
        /// This member is required.
        public var name: Swift.String?
        /// The schema name. This name applies to certain relational database engines.
        public var schema: Swift.String?

        public init (
            catalog: Swift.String? = nil,
            dataSourceArn: Swift.String? = nil,
            inputColumns: [QuickSightClientTypes.InputColumn]? = nil,
            name: Swift.String? = nil,
            schema: Swift.String? = nil
        )
        {
            self.catalog = catalog
            self.dataSourceArn = dataSourceArn
            self.inputColumns = inputColumns
            self.name = name
            self.schema = schema
        }
    }

}

extension QuickSightClientTypes.RelativeDateTimeControlDisplayOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateTimeFormat = "DateTimeFormat"
        case titleOptions = "TitleOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateTimeFormat = self.dateTimeFormat {
            try encodeContainer.encode(dateTimeFormat, forKey: .dateTimeFormat)
        }
        if let titleOptions = self.titleOptions {
            try encodeContainer.encode(titleOptions, forKey: .titleOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LabelOptions.self, forKey: .titleOptions)
        titleOptions = titleOptionsDecoded
        let dateTimeFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateTimeFormat)
        dateTimeFormat = dateTimeFormatDecoded
    }
}

extension QuickSightClientTypes {
    /// The display options of a control.
    public struct RelativeDateTimeControlDisplayOptions: Swift.Equatable {
        /// Customize how dates are formatted in controls.
        public var dateTimeFormat: Swift.String?
        /// The options to configure the title visibility, name, and font size.
        public var titleOptions: QuickSightClientTypes.LabelOptions?

        public init (
            dateTimeFormat: Swift.String? = nil,
            titleOptions: QuickSightClientTypes.LabelOptions? = nil
        )
        {
            self.dateTimeFormat = dateTimeFormat
            self.titleOptions = titleOptions
        }
    }

}

extension QuickSightClientTypes {
    public enum RelativeDateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case last
        case next
        case now
        case previous
        case `this`
        case sdkUnknown(Swift.String)

        public static var allCases: [RelativeDateType] {
            return [
                .last,
                .next,
                .now,
                .previous,
                .this,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .last: return "LAST"
            case .next: return "NEXT"
            case .now: return "NOW"
            case .previous: return "PREVIOUS"
            case .this: return "THIS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RelativeDateType(rawValue: rawValue) ?? RelativeDateType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.RelativeDatesFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anchorDateConfiguration = "AnchorDateConfiguration"
        case column = "Column"
        case excludePeriodConfiguration = "ExcludePeriodConfiguration"
        case filterId = "FilterId"
        case minimumGranularity = "MinimumGranularity"
        case nullOption = "NullOption"
        case parameterName = "ParameterName"
        case relativeDateType = "RelativeDateType"
        case relativeDateValue = "RelativeDateValue"
        case timeGranularity = "TimeGranularity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anchorDateConfiguration = self.anchorDateConfiguration {
            try encodeContainer.encode(anchorDateConfiguration, forKey: .anchorDateConfiguration)
        }
        if let column = self.column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let excludePeriodConfiguration = self.excludePeriodConfiguration {
            try encodeContainer.encode(excludePeriodConfiguration, forKey: .excludePeriodConfiguration)
        }
        if let filterId = self.filterId {
            try encodeContainer.encode(filterId, forKey: .filterId)
        }
        if let minimumGranularity = self.minimumGranularity {
            try encodeContainer.encode(minimumGranularity.rawValue, forKey: .minimumGranularity)
        }
        if let nullOption = self.nullOption {
            try encodeContainer.encode(nullOption.rawValue, forKey: .nullOption)
        }
        if let parameterName = self.parameterName {
            try encodeContainer.encode(parameterName, forKey: .parameterName)
        }
        if let relativeDateType = self.relativeDateType {
            try encodeContainer.encode(relativeDateType.rawValue, forKey: .relativeDateType)
        }
        if let relativeDateValue = self.relativeDateValue {
            try encodeContainer.encode(relativeDateValue, forKey: .relativeDateValue)
        }
        if let timeGranularity = self.timeGranularity {
            try encodeContainer.encode(timeGranularity.rawValue, forKey: .timeGranularity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterId)
        filterId = filterIdDecoded
        let columnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .column)
        column = columnDecoded
        let anchorDateConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AnchorDateConfiguration.self, forKey: .anchorDateConfiguration)
        anchorDateConfiguration = anchorDateConfigurationDecoded
        let minimumGranularityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TimeGranularity.self, forKey: .minimumGranularity)
        minimumGranularity = minimumGranularityDecoded
        let timeGranularityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TimeGranularity.self, forKey: .timeGranularity)
        timeGranularity = timeGranularityDecoded
        let relativeDateTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RelativeDateType.self, forKey: .relativeDateType)
        relativeDateType = relativeDateTypeDecoded
        let relativeDateValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .relativeDateValue)
        relativeDateValue = relativeDateValueDecoded
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let nullOptionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterNullOption.self, forKey: .nullOption)
        nullOption = nullOptionDecoded
        let excludePeriodConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ExcludePeriodConfiguration.self, forKey: .excludePeriodConfiguration)
        excludePeriodConfiguration = excludePeriodConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// A RelativeDatesFilter filters relative dates values.
    public struct RelativeDatesFilter: Swift.Equatable {
        /// The date configuration of the filter.
        /// This member is required.
        public var anchorDateConfiguration: QuickSightClientTypes.AnchorDateConfiguration?
        /// The column that the filter is applied to.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The configuration for the exclude period of the filter.
        public var excludePeriodConfiguration: QuickSightClientTypes.ExcludePeriodConfiguration?
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        /// This member is required.
        public var filterId: Swift.String?
        /// The minimum granularity (period granularity) of the relative dates filter.
        public var minimumGranularity: QuickSightClientTypes.TimeGranularity?
        /// This option determines how null values should be treated when filtering data.
        ///
        /// * ALL_VALUES: Include null values in filtered results.
        ///
        /// * NULLS_ONLY: Only include null values in filtered results.
        ///
        /// * NON_NULLS_ONLY: Exclude null values from filtered results.
        /// This member is required.
        public var nullOption: QuickSightClientTypes.FilterNullOption?
        /// The parameter whose value should be used for the filter value.
        public var parameterName: Swift.String?
        /// The range date type of the filter. Choose one of the options below:
        ///
        /// * PREVIOUS
        ///
        /// * THIS
        ///
        /// * LAST
        ///
        /// * NOW
        ///
        /// * NEXT
        /// This member is required.
        public var relativeDateType: QuickSightClientTypes.RelativeDateType?
        /// The date value of the filter.
        public var relativeDateValue: Swift.Int?
        /// The level of time precision that is used to aggregate DateTime values.
        /// This member is required.
        public var timeGranularity: QuickSightClientTypes.TimeGranularity?

        public init (
            anchorDateConfiguration: QuickSightClientTypes.AnchorDateConfiguration? = nil,
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            excludePeriodConfiguration: QuickSightClientTypes.ExcludePeriodConfiguration? = nil,
            filterId: Swift.String? = nil,
            minimumGranularity: QuickSightClientTypes.TimeGranularity? = nil,
            nullOption: QuickSightClientTypes.FilterNullOption? = nil,
            parameterName: Swift.String? = nil,
            relativeDateType: QuickSightClientTypes.RelativeDateType? = nil,
            relativeDateValue: Swift.Int? = nil,
            timeGranularity: QuickSightClientTypes.TimeGranularity? = nil
        )
        {
            self.anchorDateConfiguration = anchorDateConfiguration
            self.column = column
            self.excludePeriodConfiguration = excludePeriodConfiguration
            self.filterId = filterId
            self.minimumGranularity = minimumGranularity
            self.nullOption = nullOption
            self.parameterName = parameterName
            self.relativeDateType = relativeDateType
            self.relativeDateValue = relativeDateValue
            self.timeGranularity = timeGranularity
        }
    }

}

extension QuickSightClientTypes {
    public enum RelativeFontSize: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case extraLarge
        case extraSmall
        case large
        case medium
        case small
        case sdkUnknown(Swift.String)

        public static var allCases: [RelativeFontSize] {
            return [
                .extraLarge,
                .extraSmall,
                .large,
                .medium,
                .small,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .extraLarge: return "EXTRA_LARGE"
            case .extraSmall: return "EXTRA_SMALL"
            case .large: return "LARGE"
            case .medium: return "MEDIUM"
            case .small: return "SMALL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RelativeFontSize(rawValue: rawValue) ?? RelativeFontSize.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.RenameColumnOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnName = "ColumnName"
        case newColumnName = "NewColumnName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnName = self.columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let newColumnName = self.newColumnName {
            try encodeContainer.encode(newColumnName, forKey: .newColumnName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let newColumnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newColumnName)
        newColumnName = newColumnNameDecoded
    }
}

extension QuickSightClientTypes {
    /// A transform operation that renames a column.
    public struct RenameColumnOperation: Swift.Equatable {
        /// The name of the column to be renamed.
        /// This member is required.
        public var columnName: Swift.String?
        /// The new name for the column.
        /// This member is required.
        public var newColumnName: Swift.String?

        public init (
            columnName: Swift.String? = nil,
            newColumnName: Swift.String? = nil
        )
        {
            self.columnName = columnName
            self.newColumnName = newColumnName
        }
    }

}

extension QuickSightClientTypes {
    public enum ResizeOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fixed
        case responsive
        case sdkUnknown(Swift.String)

        public static var allCases: [ResizeOption] {
            return [
                .fixed,
                .responsive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fixed: return "FIXED"
            case .responsive: return "RESPONSIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResizeOption(rawValue: rawValue) ?? ResizeOption.sdkUnknown(rawValue)
        }
    }
}

extension ResourceExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.requestId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource specified already exists.
public struct ResourceExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?
    /// The resource type for this request.
    public var resourceType: QuickSightClientTypes.ExceptionResourceType?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceType: QuickSightClientTypes.ExceptionResourceType? = nil
    )
    {
        self.message = message
        self.requestId = requestId
        self.resourceType = resourceType
    }
}

struct ResourceExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: QuickSightClientTypes.ExceptionResourceType?
    let requestId: Swift.String?
}

extension ResourceExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ExceptionResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.requestId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more resources can't be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?
    /// The resource type for this request.
    public var resourceType: QuickSightClientTypes.ExceptionResourceType?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceType: QuickSightClientTypes.ExceptionResourceType? = nil
    )
    {
        self.message = message
        self.requestId = requestId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: QuickSightClientTypes.ExceptionResourceType?
    let requestId: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ExceptionResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.ResourcePermission: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case principal = "Principal"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for string0 in actions {
                try actionsContainer.encode(string0)
            }
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .actions)
        var actionsDecoded0:[Swift.String]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension QuickSightClientTypes {
    /// Permission for the resource.
    public struct ResourcePermission: Swift.Equatable {
        /// The IAM action to grant or revoke permissions on.
        /// This member is required.
        public var actions: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the principal. This can be one of the following:
        ///
        /// * The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)
        ///
        /// * The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)
        ///
        /// * The ARN of an Amazon Web Services account root: This is an IAM ARN rather than a QuickSight ARN. Use this option only to share resources (templates) across Amazon Web Services accounts. (This is less common.)
        /// This member is required.
        public var principal: Swift.String?

        public init (
            actions: [Swift.String]? = nil,
            principal: Swift.String? = nil
        )
        {
            self.actions = actions
            self.principal = principal
        }
    }

}

extension QuickSightClientTypes {
    public enum ResourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creationFailed
        case creationInProgress
        case creationSuccessful
        case deleted
        case updateFailed
        case updateInProgress
        case updateSuccessful
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceStatus] {
            return [
                .creationFailed,
                .creationInProgress,
                .creationSuccessful,
                .deleted,
                .updateFailed,
                .updateInProgress,
                .updateSuccessful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creationFailed: return "CREATION_FAILED"
            case .creationInProgress: return "CREATION_IN_PROGRESS"
            case .creationSuccessful: return "CREATION_SUCCESSFUL"
            case .deleted: return "DELETED"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case .updateSuccessful: return "UPDATE_SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceStatus(rawValue: rawValue) ?? ResourceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResourceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.requestId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This resource is currently unavailable.
public struct ResourceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?
    /// The resource type for this request.
    public var resourceType: QuickSightClientTypes.ExceptionResourceType?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceType: QuickSightClientTypes.ExceptionResourceType? = nil
    )
    {
        self.message = message
        self.requestId = requestId
        self.resourceType = resourceType
    }
}

struct ResourceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: QuickSightClientTypes.ExceptionResourceType?
    let requestId: Swift.String?
}

extension ResourceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ExceptionResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension RestoreAnalysisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let analysisId = analysisId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/restore/analyses/\(analysisId.urlPercentEncoding())"
    }
}

public struct RestoreAnalysisInput: Swift.Equatable {
    /// The ID of the analysis that you're restoring.
    /// This member is required.
    public var analysisId: Swift.String?
    /// The ID of the Amazon Web Services account that contains the analysis.
    /// This member is required.
    public var awsAccountId: Swift.String?

    public init (
        analysisId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
    }
}

struct RestoreAnalysisInputBody: Swift.Equatable {
}

extension RestoreAnalysisInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RestoreAnalysisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestoreAnalysisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RestoreAnalysisOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreAnalysisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RestoreAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisId = output.analysisId
            self.arn = output.arn
            self.requestId = output.requestId
        } else {
            self.analysisId = nil
            self.arn = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct RestoreAnalysisOutputResponse: Swift.Equatable {
    /// The ID of the analysis that you're restoring.
    public var analysisId: Swift.String?
    /// The Amazon Resource Name (ARN) of the analysis that you're restoring.
    public var arn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        analysisId: Swift.String? = nil,
        arn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.analysisId = analysisId
        self.arn = arn
        self.requestId = requestId
        self.status = status
    }
}

struct RestoreAnalysisOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let arn: Swift.String?
    let analysisId: Swift.String?
    let requestId: Swift.String?
}

extension RestoreAnalysisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisId = "AnalysisId"
        case arn = "Arn"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let analysisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.RollingDateConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetIdentifier = "DataSetIdentifier"
        case expression = "Expression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSetIdentifier = self.dataSetIdentifier {
            try encodeContainer.encode(dataSetIdentifier, forKey: .dataSetIdentifier)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetIdentifier)
        dataSetIdentifier = dataSetIdentifierDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
    }
}

extension QuickSightClientTypes.RollingDateConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RollingDateConfiguration(dataSetIdentifier: \(Swift.String(describing: dataSetIdentifier)), expression: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {
    /// The rolling date configuration of a date time filter.
    public struct RollingDateConfiguration: Swift.Equatable {
        /// The data set that is used in the rolling date configuration.
        public var dataSetIdentifier: Swift.String?
        /// The expression of the rolling date configuration.
        /// This member is required.
        public var expression: Swift.String?

        public init (
            dataSetIdentifier: Swift.String? = nil,
            expression: Swift.String? = nil
        )
        {
            self.dataSetIdentifier = dataSetIdentifier
            self.expression = expression
        }
    }

}

extension QuickSightClientTypes.RowAlternateColorOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rowAlternateColors = "RowAlternateColors"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rowAlternateColors = rowAlternateColors {
            var rowAlternateColorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rowAlternateColors)
            for hexcolor0 in rowAlternateColors {
                try rowAlternateColorsContainer.encode(hexcolor0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.WidgetStatus.self, forKey: .status)
        status = statusDecoded
        let rowAlternateColorsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rowAlternateColors)
        var rowAlternateColorsDecoded0:[Swift.String]? = nil
        if let rowAlternateColorsContainer = rowAlternateColorsContainer {
            rowAlternateColorsDecoded0 = [Swift.String]()
            for string0 in rowAlternateColorsContainer {
                if let string0 = string0 {
                    rowAlternateColorsDecoded0?.append(string0)
                }
            }
        }
        rowAlternateColors = rowAlternateColorsDecoded0
    }
}

extension QuickSightClientTypes {
    /// Determines the row alternate color options.
    public struct RowAlternateColorOptions: Swift.Equatable {
        /// Determines the list of row alternate colors.
        public var rowAlternateColors: [Swift.String]?
        /// Determines the widget status.
        public var status: QuickSightClientTypes.WidgetStatus?

        public init (
            rowAlternateColors: [Swift.String]? = nil,
            status: QuickSightClientTypes.WidgetStatus? = nil
        )
        {
            self.rowAlternateColors = rowAlternateColors
            self.status = status
        }
    }

}

extension QuickSightClientTypes.RowInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rowsDropped = "RowsDropped"
        case rowsIngested = "RowsIngested"
        case totalRowsInDataset = "TotalRowsInDataset"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rowsDropped = self.rowsDropped {
            try encodeContainer.encode(rowsDropped, forKey: .rowsDropped)
        }
        if let rowsIngested = self.rowsIngested {
            try encodeContainer.encode(rowsIngested, forKey: .rowsIngested)
        }
        if let totalRowsInDataset = self.totalRowsInDataset {
            try encodeContainer.encode(totalRowsInDataset, forKey: .totalRowsInDataset)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowsIngestedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rowsIngested)
        rowsIngested = rowsIngestedDecoded
        let rowsDroppedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rowsDropped)
        rowsDropped = rowsDroppedDecoded
        let totalRowsInDatasetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalRowsInDataset)
        totalRowsInDataset = totalRowsInDatasetDecoded
    }
}

extension QuickSightClientTypes {
    /// Information about rows for a data set SPICE ingestion.
    public struct RowInfo: Swift.Equatable {
        /// The number of rows that were not ingested.
        public var rowsDropped: Swift.Int?
        /// The number of rows that were ingested.
        public var rowsIngested: Swift.Int?
        /// The total number of rows in the dataset.
        public var totalRowsInDataset: Swift.Int?

        public init (
            rowsDropped: Swift.Int? = nil,
            rowsIngested: Swift.Int? = nil,
            totalRowsInDataset: Swift.Int? = nil
        )
        {
            self.rowsDropped = rowsDropped
            self.rowsIngested = rowsIngested
            self.totalRowsInDataset = totalRowsInDataset
        }
    }

}

extension QuickSightClientTypes.RowLevelPermissionDataSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case formatVersion = "FormatVersion"
        case namespace = "Namespace"
        case permissionPolicy = "PermissionPolicy"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let formatVersion = self.formatVersion {
            try encodeContainer.encode(formatVersion.rawValue, forKey: .formatVersion)
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let permissionPolicy = self.permissionPolicy {
            try encodeContainer.encode(permissionPolicy.rawValue, forKey: .permissionPolicy)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let permissionPolicyDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RowLevelPermissionPolicy.self, forKey: .permissionPolicy)
        permissionPolicy = permissionPolicyDecoded
        let formatVersionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RowLevelPermissionFormatVersion.self, forKey: .formatVersion)
        formatVersion = formatVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

extension QuickSightClientTypes {
    /// Information about a dataset that contains permissions for row-level security (RLS). The permissions dataset maps fields to users or groups. For more information, see [Using Row-Level Security (RLS) to Restrict Access to a Dataset](https://docs.aws.amazon.com/quicksight/latest/user/restrict-access-to-a-data-set-using-row-level-security.html) in the Amazon QuickSight User Guide. The option to deny permissions by setting PermissionPolicy to DENY_ACCESS is not supported for new RLS datasets.
    public struct RowLevelPermissionDataSet: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the dataset that contains permissions for RLS.
        /// This member is required.
        public var arn: Swift.String?
        /// The user or group rules associated with the dataset that contains permissions for RLS. By default, FormatVersion is VERSION_1. When FormatVersion is VERSION_1, UserName and GroupName are required. When FormatVersion is VERSION_2, UserARN and GroupARN are required, and Namespace must not exist.
        public var formatVersion: QuickSightClientTypes.RowLevelPermissionFormatVersion?
        /// The namespace associated with the dataset that contains permissions for RLS.
        public var namespace: Swift.String?
        /// The type of permissions to use when interpreting the permissions for RLS. DENY_ACCESS is included for backward compatibility only.
        /// This member is required.
        public var permissionPolicy: QuickSightClientTypes.RowLevelPermissionPolicy?
        /// The status of the row-level security permission dataset. If enabled, the status is ENABLED. If disabled, the status is DISABLED.
        public var status: QuickSightClientTypes.Status?

        public init (
            arn: Swift.String? = nil,
            formatVersion: QuickSightClientTypes.RowLevelPermissionFormatVersion? = nil,
            namespace: Swift.String? = nil,
            permissionPolicy: QuickSightClientTypes.RowLevelPermissionPolicy? = nil,
            status: QuickSightClientTypes.Status? = nil
        )
        {
            self.arn = arn
            self.formatVersion = formatVersion
            self.namespace = namespace
            self.permissionPolicy = permissionPolicy
            self.status = status
        }
    }

}

extension QuickSightClientTypes {
    public enum RowLevelPermissionFormatVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case version1
        case version2
        case sdkUnknown(Swift.String)

        public static var allCases: [RowLevelPermissionFormatVersion] {
            return [
                .version1,
                .version2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .version1: return "VERSION_1"
            case .version2: return "VERSION_2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RowLevelPermissionFormatVersion(rawValue: rawValue) ?? RowLevelPermissionFormatVersion.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum RowLevelPermissionPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case denyAccess
        case grantAccess
        case sdkUnknown(Swift.String)

        public static var allCases: [RowLevelPermissionPolicy] {
            return [
                .denyAccess,
                .grantAccess,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .denyAccess: return "DENY_ACCESS"
            case .grantAccess: return "GRANT_ACCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RowLevelPermissionPolicy(rawValue: rawValue) ?? RowLevelPermissionPolicy.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.RowLevelPermissionTagConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case tagRules = "TagRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tagRules = tagRules {
            var tagRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagRules)
            for rowlevelpermissiontagrule0 in tagRules {
                try tagRulesContainer.encode(rowlevelpermissiontagrule0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let tagRulesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.RowLevelPermissionTagRule?].self, forKey: .tagRules)
        var tagRulesDecoded0:[QuickSightClientTypes.RowLevelPermissionTagRule]? = nil
        if let tagRulesContainer = tagRulesContainer {
            tagRulesDecoded0 = [QuickSightClientTypes.RowLevelPermissionTagRule]()
            for structure0 in tagRulesContainer {
                if let structure0 = structure0 {
                    tagRulesDecoded0?.append(structure0)
                }
            }
        }
        tagRules = tagRulesDecoded0
    }
}

extension QuickSightClientTypes {
    /// The configuration of tags on a dataset to set row-level security.
    public struct RowLevelPermissionTagConfiguration: Swift.Equatable {
        /// The status of row-level security tags. If enabled, the status is ENABLED. If disabled, the status is DISABLED.
        public var status: QuickSightClientTypes.Status?
        /// A set of rules associated with row-level security, such as the tag names and columns that they are assigned to.
        /// This member is required.
        public var tagRules: [QuickSightClientTypes.RowLevelPermissionTagRule]?

        public init (
            status: QuickSightClientTypes.Status? = nil,
            tagRules: [QuickSightClientTypes.RowLevelPermissionTagRule]? = nil
        )
        {
            self.status = status
            self.tagRules = tagRules
        }
    }

}

extension QuickSightClientTypes.RowLevelPermissionTagRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnName = "ColumnName"
        case matchAllValue = "MatchAllValue"
        case tagKey = "TagKey"
        case tagMultiValueDelimiter = "TagMultiValueDelimiter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnName = self.columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let matchAllValue = self.matchAllValue {
            try encodeContainer.encode(matchAllValue, forKey: .matchAllValue)
        }
        if let tagKey = self.tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let tagMultiValueDelimiter = self.tagMultiValueDelimiter {
            try encodeContainer.encode(tagMultiValueDelimiter, forKey: .tagMultiValueDelimiter)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let columnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let tagMultiValueDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagMultiValueDelimiter)
        tagMultiValueDelimiter = tagMultiValueDelimiterDecoded
        let matchAllValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .matchAllValue)
        matchAllValue = matchAllValueDecoded
    }
}

extension QuickSightClientTypes.RowLevelPermissionTagRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RowLevelPermissionTagRule(columnName: \(Swift.String(describing: columnName)), tagKey: \(Swift.String(describing: tagKey)), tagMultiValueDelimiter: \(Swift.String(describing: tagMultiValueDelimiter)), matchAllValue: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {
    /// A set of rules associated with a tag.
    public struct RowLevelPermissionTagRule: Swift.Equatable {
        /// The column name that a tag key is assigned to.
        /// This member is required.
        public var columnName: Swift.String?
        /// A string that you want to use to filter by all the values in a column in the dataset and dont want to list the values one by one. For example, you can use an asterisk as your match all value.
        public var matchAllValue: Swift.String?
        /// The unique key for a tag.
        /// This member is required.
        public var tagKey: Swift.String?
        /// A string that you want to use to delimit the values when you pass the values at run time. For example, you can delimit the values with a comma.
        public var tagMultiValueDelimiter: Swift.String?

        public init (
            columnName: Swift.String? = nil,
            matchAllValue: Swift.String? = nil,
            tagKey: Swift.String? = nil,
            tagMultiValueDelimiter: Swift.String? = nil
        )
        {
            self.columnName = columnName
            self.matchAllValue = matchAllValue
            self.tagKey = tagKey
            self.tagMultiValueDelimiter = tagMultiValueDelimiter
        }
    }

}

extension QuickSightClientTypes.S3Parameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case manifestFileLocation = "ManifestFileLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let manifestFileLocation = self.manifestFileLocation {
            try encodeContainer.encode(manifestFileLocation, forKey: .manifestFileLocation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestFileLocationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ManifestFileLocation.self, forKey: .manifestFileLocation)
        manifestFileLocation = manifestFileLocationDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for S3.
    public struct S3Parameters: Swift.Equatable {
        /// Location of the Amazon S3 manifest file. This is NULL if the manifest file was uploaded into Amazon QuickSight.
        /// This member is required.
        public var manifestFileLocation: QuickSightClientTypes.ManifestFileLocation?

        public init (
            manifestFileLocation: QuickSightClientTypes.ManifestFileLocation? = nil
        )
        {
            self.manifestFileLocation = manifestFileLocation
        }
    }

}

extension QuickSightClientTypes.S3Source: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceArn = "DataSourceArn"
        case inputColumns = "InputColumns"
        case uploadSettings = "UploadSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceArn = self.dataSourceArn {
            try encodeContainer.encode(dataSourceArn, forKey: .dataSourceArn)
        }
        if let inputColumns = inputColumns {
            var inputColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputColumns)
            for inputcolumn0 in inputColumns {
                try inputColumnsContainer.encode(inputcolumn0)
            }
        }
        if let uploadSettings = self.uploadSettings {
            try encodeContainer.encode(uploadSettings, forKey: .uploadSettings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceArn)
        dataSourceArn = dataSourceArnDecoded
        let uploadSettingsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.UploadSettings.self, forKey: .uploadSettings)
        uploadSettings = uploadSettingsDecoded
        let inputColumnsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.InputColumn?].self, forKey: .inputColumns)
        var inputColumnsDecoded0:[QuickSightClientTypes.InputColumn]? = nil
        if let inputColumnsContainer = inputColumnsContainer {
            inputColumnsDecoded0 = [QuickSightClientTypes.InputColumn]()
            for structure0 in inputColumnsContainer {
                if let structure0 = structure0 {
                    inputColumnsDecoded0?.append(structure0)
                }
            }
        }
        inputColumns = inputColumnsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A physical table type for an S3 data source.
    public struct S3Source: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the data source.
        /// This member is required.
        public var dataSourceArn: Swift.String?
        /// A physical table type for an S3 data source. For files that aren't JSON, only STRING data types are supported in input columns.
        /// This member is required.
        public var inputColumns: [QuickSightClientTypes.InputColumn]?
        /// Information about the format for the S3 source file or files.
        public var uploadSettings: QuickSightClientTypes.UploadSettings?

        public init (
            dataSourceArn: Swift.String? = nil,
            inputColumns: [QuickSightClientTypes.InputColumn]? = nil,
            uploadSettings: QuickSightClientTypes.UploadSettings? = nil
        )
        {
            self.dataSourceArn = dataSourceArn
            self.inputColumns = inputColumns
            self.uploadSettings = uploadSettings
        }
    }

}

extension QuickSightClientTypes.SameSheetTargetVisualConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetVisualOptions = "TargetVisualOptions"
        case targetVisuals = "TargetVisuals"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetVisualOptions = self.targetVisualOptions {
            try encodeContainer.encode(targetVisualOptions.rawValue, forKey: .targetVisualOptions)
        }
        if let targetVisuals = targetVisuals {
            var targetVisualsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetVisuals)
            for shortrestrictiveresourceid0 in targetVisuals {
                try targetVisualsContainer.encode(shortrestrictiveresourceid0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetVisualsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetVisuals)
        var targetVisualsDecoded0:[Swift.String]? = nil
        if let targetVisualsContainer = targetVisualsContainer {
            targetVisualsDecoded0 = [Swift.String]()
            for string0 in targetVisualsContainer {
                if let string0 = string0 {
                    targetVisualsDecoded0?.append(string0)
                }
            }
        }
        targetVisuals = targetVisualsDecoded0
        let targetVisualOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TargetVisualOptions.self, forKey: .targetVisualOptions)
        targetVisualOptions = targetVisualOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of the same-sheet target visuals that you want to be filtered. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct SameSheetTargetVisualConfiguration: Swift.Equatable {
        /// The options that choose the target visual in the same sheet. Valid values are defined as follows:
        ///
        /// * ALL_VISUALS: Applies the filter operation to all visuals in the same sheet.
        public var targetVisualOptions: QuickSightClientTypes.TargetVisualOptions?
        /// A list of the target visual IDs that are located in the same sheet of the analysis.
        public var targetVisuals: [Swift.String]?

        public init (
            targetVisualOptions: QuickSightClientTypes.TargetVisualOptions? = nil,
            targetVisuals: [Swift.String]? = nil
        )
        {
            self.targetVisualOptions = targetVisualOptions
            self.targetVisuals = targetVisuals
        }
    }

}

extension QuickSightClientTypes.SankeyDiagramAggregatedFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case source = "Source"
        case weight = "Weight"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            var destinationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destination)
            for dimensionfield0 in destination {
                try destinationContainer.encode(dimensionfield0)
            }
        }
        if let source = source {
            var sourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .source)
            for dimensionfield0 in source {
                try sourceContainer.encode(dimensionfield0)
            }
        }
        if let weight = weight {
            var weightContainer = encodeContainer.nestedUnkeyedContainer(forKey: .weight)
            for measurefield0 in weight {
                try weightContainer.encode(measurefield0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .source)
        var sourceDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let sourceContainer = sourceContainer {
            sourceDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in sourceContainer {
                if let structure0 = structure0 {
                    sourceDecoded0?.append(structure0)
                }
            }
        }
        source = sourceDecoded0
        let destinationContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .destination)
        var destinationDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let destinationContainer = destinationContainer {
            destinationDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in destinationContainer {
                if let structure0 = structure0 {
                    destinationDecoded0?.append(structure0)
                }
            }
        }
        destination = destinationDecoded0
        let weightContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .weight)
        var weightDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let weightContainer = weightContainer {
            weightDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in weightContainer {
                if let structure0 = structure0 {
                    weightDecoded0?.append(structure0)
                }
            }
        }
        weight = weightDecoded0
    }
}

extension QuickSightClientTypes {
    /// The field well configuration of a sankey diagram.
    public struct SankeyDiagramAggregatedFieldWells: Swift.Equatable {
        /// The destination field wells of a sankey diagram.
        public var destination: [QuickSightClientTypes.DimensionField]?
        /// The source field wells of a sankey diagram.
        public var source: [QuickSightClientTypes.DimensionField]?
        /// The weight field wells of a sankey diagram.
        public var weight: [QuickSightClientTypes.MeasureField]?

        public init (
            destination: [QuickSightClientTypes.DimensionField]? = nil,
            source: [QuickSightClientTypes.DimensionField]? = nil,
            weight: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.destination = destination
            self.source = source
            self.weight = weight
        }
    }

}

extension QuickSightClientTypes.SankeyDiagramChartConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataLabels = "DataLabels"
        case fieldWells = "FieldWells"
        case sortConfiguration = "SortConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataLabels = self.dataLabels {
            try encodeContainer.encode(dataLabels, forKey: .dataLabels)
        }
        if let fieldWells = self.fieldWells {
            try encodeContainer.encode(fieldWells, forKey: .fieldWells)
        }
        if let sortConfiguration = self.sortConfiguration {
            try encodeContainer.encode(sortConfiguration, forKey: .sortConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SankeyDiagramFieldWells.self, forKey: .fieldWells)
        fieldWells = fieldWellsDecoded
        let sortConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SankeyDiagramSortConfiguration.self, forKey: .sortConfiguration)
        sortConfiguration = sortConfigurationDecoded
        let dataLabelsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataLabelOptions.self, forKey: .dataLabels)
        dataLabels = dataLabelsDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of a sankey diagram.
    public struct SankeyDiagramChartConfiguration: Swift.Equatable {
        /// The data label configuration of a sankey diagram.
        public var dataLabels: QuickSightClientTypes.DataLabelOptions?
        /// The field well configuration of a sankey diagram.
        public var fieldWells: QuickSightClientTypes.SankeyDiagramFieldWells?
        /// The sort configuration of a sankey diagram.
        public var sortConfiguration: QuickSightClientTypes.SankeyDiagramSortConfiguration?

        public init (
            dataLabels: QuickSightClientTypes.DataLabelOptions? = nil,
            fieldWells: QuickSightClientTypes.SankeyDiagramFieldWells? = nil,
            sortConfiguration: QuickSightClientTypes.SankeyDiagramSortConfiguration? = nil
        )
        {
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.sortConfiguration = sortConfiguration
        }
    }

}

extension QuickSightClientTypes.SankeyDiagramFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sankeyDiagramAggregatedFieldWells = "SankeyDiagramAggregatedFieldWells"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sankeyDiagramAggregatedFieldWells = self.sankeyDiagramAggregatedFieldWells {
            try encodeContainer.encode(sankeyDiagramAggregatedFieldWells, forKey: .sankeyDiagramAggregatedFieldWells)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sankeyDiagramAggregatedFieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SankeyDiagramAggregatedFieldWells.self, forKey: .sankeyDiagramAggregatedFieldWells)
        sankeyDiagramAggregatedFieldWells = sankeyDiagramAggregatedFieldWellsDecoded
    }
}

extension QuickSightClientTypes {
    /// The field well configuration of a sankey diagram.
    public struct SankeyDiagramFieldWells: Swift.Equatable {
        /// The field well configuration of a sankey diagram.
        public var sankeyDiagramAggregatedFieldWells: QuickSightClientTypes.SankeyDiagramAggregatedFieldWells?

        public init (
            sankeyDiagramAggregatedFieldWells: QuickSightClientTypes.SankeyDiagramAggregatedFieldWells? = nil
        )
        {
            self.sankeyDiagramAggregatedFieldWells = sankeyDiagramAggregatedFieldWells
        }
    }

}

extension QuickSightClientTypes.SankeyDiagramSortConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationItemsLimit = "DestinationItemsLimit"
        case sourceItemsLimit = "SourceItemsLimit"
        case weightSort = "WeightSort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationItemsLimit = self.destinationItemsLimit {
            try encodeContainer.encode(destinationItemsLimit, forKey: .destinationItemsLimit)
        }
        if let sourceItemsLimit = self.sourceItemsLimit {
            try encodeContainer.encode(sourceItemsLimit, forKey: .sourceItemsLimit)
        }
        if let weightSort = weightSort {
            var weightSortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .weightSort)
            for fieldsortoptions0 in weightSort {
                try weightSortContainer.encode(fieldsortoptions0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let weightSortContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FieldSortOptions?].self, forKey: .weightSort)
        var weightSortDecoded0:[QuickSightClientTypes.FieldSortOptions]? = nil
        if let weightSortContainer = weightSortContainer {
            weightSortDecoded0 = [QuickSightClientTypes.FieldSortOptions]()
            for structure0 in weightSortContainer {
                if let structure0 = structure0 {
                    weightSortDecoded0?.append(structure0)
                }
            }
        }
        weightSort = weightSortDecoded0
        let sourceItemsLimitDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ItemsLimitConfiguration.self, forKey: .sourceItemsLimit)
        sourceItemsLimit = sourceItemsLimitDecoded
        let destinationItemsLimitDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ItemsLimitConfiguration.self, forKey: .destinationItemsLimit)
        destinationItemsLimit = destinationItemsLimitDecoded
    }
}

extension QuickSightClientTypes {
    /// The sort configuration of a sankey diagram.
    public struct SankeyDiagramSortConfiguration: Swift.Equatable {
        /// The limit on the number of destination nodes that are displayed in a sankey diagram.
        public var destinationItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The limit on the number of source nodes that are displayed in a sankey diagram.
        public var sourceItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of the weight fields.
        public var weightSort: [QuickSightClientTypes.FieldSortOptions]?

        public init (
            destinationItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            sourceItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            weightSort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.destinationItemsLimit = destinationItemsLimit
            self.sourceItemsLimit = sourceItemsLimit
            self.weightSort = weightSort
        }
    }

}

extension QuickSightClientTypes.SankeyDiagramVisual: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case chartConfiguration = "ChartConfiguration"
        case subtitle = "Subtitle"
        case title = "Title"
        case visualId = "VisualId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for visualcustomaction0 in actions {
                try actionsContainer.encode(visualcustomaction0)
            }
        }
        if let chartConfiguration = self.chartConfiguration {
            try encodeContainer.encode(chartConfiguration, forKey: .chartConfiguration)
        }
        if let subtitle = self.subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let visualId = self.visualId {
            try encodeContainer.encode(visualId, forKey: .visualId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visualIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visualId)
        visualId = visualIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualTitleLabelOptions.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualSubtitleLabelOptions.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let chartConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SankeyDiagramChartConfiguration.self, forKey: .chartConfiguration)
        chartConfiguration = chartConfigurationDecoded
        let actionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.VisualCustomAction?].self, forKey: .actions)
        var actionsDecoded0:[QuickSightClientTypes.VisualCustomAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [QuickSightClientTypes.VisualCustomAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A sankey diagram. For more information, see [Using Sankey diagrams](https://docs.aws.amazon.com/quicksight/latest/user/sankey-diagram.html) in the Amazon QuickSight User Guide.
    public struct SankeyDiagramVisual: Swift.Equatable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration of a sankey diagram.
        public var chartConfiguration: QuickSightClientTypes.SankeyDiagramChartConfiguration?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init (
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.SankeyDiagramChartConfiguration? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }

}

extension QuickSightClientTypes.ScatterPlotCategoricallyAggregatedFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category = "Category"
        case size = "Size"
        case xAxis = "XAxis"
        case yAxis = "YAxis"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            var categoryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .category)
            for dimensionfield0 in category {
                try categoryContainer.encode(dimensionfield0)
            }
        }
        if let size = size {
            var sizeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .size)
            for measurefield0 in size {
                try sizeContainer.encode(measurefield0)
            }
        }
        if let xAxis = xAxis {
            var xAxisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .xAxis)
            for measurefield0 in xAxis {
                try xAxisContainer.encode(measurefield0)
            }
        }
        if let yAxis = yAxis {
            var yAxisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .yAxis)
            for measurefield0 in yAxis {
                try yAxisContainer.encode(measurefield0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let xAxisContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .xAxis)
        var xAxisDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let xAxisContainer = xAxisContainer {
            xAxisDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in xAxisContainer {
                if let structure0 = structure0 {
                    xAxisDecoded0?.append(structure0)
                }
            }
        }
        xAxis = xAxisDecoded0
        let yAxisContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .yAxis)
        var yAxisDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let yAxisContainer = yAxisContainer {
            yAxisDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in yAxisContainer {
                if let structure0 = structure0 {
                    yAxisDecoded0?.append(structure0)
                }
            }
        }
        yAxis = yAxisDecoded0
        let categoryContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .category)
        var categoryDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let categoryContainer = categoryContainer {
            categoryDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in categoryContainer {
                if let structure0 = structure0 {
                    categoryDecoded0?.append(structure0)
                }
            }
        }
        category = categoryDecoded0
        let sizeContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .size)
        var sizeDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let sizeContainer = sizeContainer {
            sizeDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in sizeContainer {
                if let structure0 = structure0 {
                    sizeDecoded0?.append(structure0)
                }
            }
        }
        size = sizeDecoded0
    }
}

extension QuickSightClientTypes {
    /// The aggregated field well of a scatter plot.
    public struct ScatterPlotCategoricallyAggregatedFieldWells: Swift.Equatable {
        /// The category field well of a scatter plot.
        public var category: [QuickSightClientTypes.DimensionField]?
        /// The size field well of a scatter plot.
        public var size: [QuickSightClientTypes.MeasureField]?
        /// The x-axis field well of a scatter plot. The x-axis is aggregated by category.
        public var xAxis: [QuickSightClientTypes.MeasureField]?
        /// The y-axis field well of a scatter plot. The y-axis is aggregated by category.
        public var yAxis: [QuickSightClientTypes.MeasureField]?

        public init (
            category: [QuickSightClientTypes.DimensionField]? = nil,
            size: [QuickSightClientTypes.MeasureField]? = nil,
            xAxis: [QuickSightClientTypes.MeasureField]? = nil,
            yAxis: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.category = category
            self.size = size
            self.xAxis = xAxis
            self.yAxis = yAxis
        }
    }

}

extension QuickSightClientTypes.ScatterPlotConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataLabels = "DataLabels"
        case fieldWells = "FieldWells"
        case legend = "Legend"
        case tooltip = "Tooltip"
        case visualPalette = "VisualPalette"
        case xAxisDisplayOptions = "XAxisDisplayOptions"
        case xAxisLabelOptions = "XAxisLabelOptions"
        case yAxisDisplayOptions = "YAxisDisplayOptions"
        case yAxisLabelOptions = "YAxisLabelOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataLabels = self.dataLabels {
            try encodeContainer.encode(dataLabels, forKey: .dataLabels)
        }
        if let fieldWells = self.fieldWells {
            try encodeContainer.encode(fieldWells, forKey: .fieldWells)
        }
        if let legend = self.legend {
            try encodeContainer.encode(legend, forKey: .legend)
        }
        if let tooltip = self.tooltip {
            try encodeContainer.encode(tooltip, forKey: .tooltip)
        }
        if let visualPalette = self.visualPalette {
            try encodeContainer.encode(visualPalette, forKey: .visualPalette)
        }
        if let xAxisDisplayOptions = self.xAxisDisplayOptions {
            try encodeContainer.encode(xAxisDisplayOptions, forKey: .xAxisDisplayOptions)
        }
        if let xAxisLabelOptions = self.xAxisLabelOptions {
            try encodeContainer.encode(xAxisLabelOptions, forKey: .xAxisLabelOptions)
        }
        if let yAxisDisplayOptions = self.yAxisDisplayOptions {
            try encodeContainer.encode(yAxisDisplayOptions, forKey: .yAxisDisplayOptions)
        }
        if let yAxisLabelOptions = self.yAxisLabelOptions {
            try encodeContainer.encode(yAxisLabelOptions, forKey: .yAxisLabelOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ScatterPlotFieldWells.self, forKey: .fieldWells)
        fieldWells = fieldWellsDecoded
        let xAxisLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .xAxisLabelOptions)
        xAxisLabelOptions = xAxisLabelOptionsDecoded
        let xAxisDisplayOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisDisplayOptions.self, forKey: .xAxisDisplayOptions)
        xAxisDisplayOptions = xAxisDisplayOptionsDecoded
        let yAxisLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .yAxisLabelOptions)
        yAxisLabelOptions = yAxisLabelOptionsDecoded
        let yAxisDisplayOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisDisplayOptions.self, forKey: .yAxisDisplayOptions)
        yAxisDisplayOptions = yAxisDisplayOptionsDecoded
        let legendDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LegendOptions.self, forKey: .legend)
        legend = legendDecoded
        let dataLabelsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataLabelOptions.self, forKey: .dataLabels)
        dataLabels = dataLabelsDecoded
        let tooltipDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TooltipOptions.self, forKey: .tooltip)
        tooltip = tooltipDecoded
        let visualPaletteDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualPalette.self, forKey: .visualPalette)
        visualPalette = visualPaletteDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of a scatter plot.
    public struct ScatterPlotConfiguration: Swift.Equatable {
        /// The options that determine if visual data labels are displayed.
        public var dataLabels: QuickSightClientTypes.DataLabelOptions?
        /// The field wells of the visual.
        public var fieldWells: QuickSightClientTypes.ScatterPlotFieldWells?
        /// The legend display setup of the visual.
        public var legend: QuickSightClientTypes.LegendOptions?
        /// The legend display setup of the visual.
        public var tooltip: QuickSightClientTypes.TooltipOptions?
        /// The palette (chart color) display setup of the visual.
        public var visualPalette: QuickSightClientTypes.VisualPalette?
        /// The label display options (grid line, range, scale, and axis step) of the scatter plot's x-axis.
        public var xAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions?
        /// The label options (label text, label visibility, and sort icon visibility) of the scatter plot's x-axis.
        public var xAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The label display options (grid line, range, scale, and axis step) of the scatter plot's y-axis.
        public var yAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions?
        /// The label options (label text, label visibility, and sort icon visibility) of the scatter plot's y-axis.
        public var yAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?

        public init (
            dataLabels: QuickSightClientTypes.DataLabelOptions? = nil,
            fieldWells: QuickSightClientTypes.ScatterPlotFieldWells? = nil,
            legend: QuickSightClientTypes.LegendOptions? = nil,
            tooltip: QuickSightClientTypes.TooltipOptions? = nil,
            visualPalette: QuickSightClientTypes.VisualPalette? = nil,
            xAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions? = nil,
            xAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            yAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions? = nil,
            yAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil
        )
        {
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.legend = legend
            self.tooltip = tooltip
            self.visualPalette = visualPalette
            self.xAxisDisplayOptions = xAxisDisplayOptions
            self.xAxisLabelOptions = xAxisLabelOptions
            self.yAxisDisplayOptions = yAxisDisplayOptions
            self.yAxisLabelOptions = yAxisLabelOptions
        }
    }

}

extension QuickSightClientTypes.ScatterPlotFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scatterPlotCategoricallyAggregatedFieldWells = "ScatterPlotCategoricallyAggregatedFieldWells"
        case scatterPlotUnaggregatedFieldWells = "ScatterPlotUnaggregatedFieldWells"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scatterPlotCategoricallyAggregatedFieldWells = self.scatterPlotCategoricallyAggregatedFieldWells {
            try encodeContainer.encode(scatterPlotCategoricallyAggregatedFieldWells, forKey: .scatterPlotCategoricallyAggregatedFieldWells)
        }
        if let scatterPlotUnaggregatedFieldWells = self.scatterPlotUnaggregatedFieldWells {
            try encodeContainer.encode(scatterPlotUnaggregatedFieldWells, forKey: .scatterPlotUnaggregatedFieldWells)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scatterPlotCategoricallyAggregatedFieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ScatterPlotCategoricallyAggregatedFieldWells.self, forKey: .scatterPlotCategoricallyAggregatedFieldWells)
        scatterPlotCategoricallyAggregatedFieldWells = scatterPlotCategoricallyAggregatedFieldWellsDecoded
        let scatterPlotUnaggregatedFieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ScatterPlotUnaggregatedFieldWells.self, forKey: .scatterPlotUnaggregatedFieldWells)
        scatterPlotUnaggregatedFieldWells = scatterPlotUnaggregatedFieldWellsDecoded
    }
}

extension QuickSightClientTypes {
    /// The field well configuration of a scatter plot. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct ScatterPlotFieldWells: Swift.Equatable {
        /// The aggregated field wells of a scatter plot. Scatter plots that have a field in the category (group/color) field will have aggregated field wells. The x and y-axes of these scatter plots are aggregated by category.
        public var scatterPlotCategoricallyAggregatedFieldWells: QuickSightClientTypes.ScatterPlotCategoricallyAggregatedFieldWells?
        /// The unaggregated field wells of a scatter plot. Scatter plots without a category field well have unaggregated field wells. The x and y-axes of these scatter plots are unaggregated.
        public var scatterPlotUnaggregatedFieldWells: QuickSightClientTypes.ScatterPlotUnaggregatedFieldWells?

        public init (
            scatterPlotCategoricallyAggregatedFieldWells: QuickSightClientTypes.ScatterPlotCategoricallyAggregatedFieldWells? = nil,
            scatterPlotUnaggregatedFieldWells: QuickSightClientTypes.ScatterPlotUnaggregatedFieldWells? = nil
        )
        {
            self.scatterPlotCategoricallyAggregatedFieldWells = scatterPlotCategoricallyAggregatedFieldWells
            self.scatterPlotUnaggregatedFieldWells = scatterPlotUnaggregatedFieldWells
        }
    }

}

extension QuickSightClientTypes.ScatterPlotUnaggregatedFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case size = "Size"
        case xAxis = "XAxis"
        case yAxis = "YAxis"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let size = size {
            var sizeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .size)
            for measurefield0 in size {
                try sizeContainer.encode(measurefield0)
            }
        }
        if let xAxis = xAxis {
            var xAxisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .xAxis)
            for dimensionfield0 in xAxis {
                try xAxisContainer.encode(dimensionfield0)
            }
        }
        if let yAxis = yAxis {
            var yAxisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .yAxis)
            for dimensionfield0 in yAxis {
                try yAxisContainer.encode(dimensionfield0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let xAxisContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .xAxis)
        var xAxisDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let xAxisContainer = xAxisContainer {
            xAxisDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in xAxisContainer {
                if let structure0 = structure0 {
                    xAxisDecoded0?.append(structure0)
                }
            }
        }
        xAxis = xAxisDecoded0
        let yAxisContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .yAxis)
        var yAxisDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let yAxisContainer = yAxisContainer {
            yAxisDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in yAxisContainer {
                if let structure0 = structure0 {
                    yAxisDecoded0?.append(structure0)
                }
            }
        }
        yAxis = yAxisDecoded0
        let sizeContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .size)
        var sizeDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let sizeContainer = sizeContainer {
            sizeDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in sizeContainer {
                if let structure0 = structure0 {
                    sizeDecoded0?.append(structure0)
                }
            }
        }
        size = sizeDecoded0
    }
}

extension QuickSightClientTypes {
    /// The unaggregated field wells of a scatter plot.
    public struct ScatterPlotUnaggregatedFieldWells: Swift.Equatable {
        /// The size field well of a scatter plot.
        public var size: [QuickSightClientTypes.MeasureField]?
        /// The x-axis field well of a scatter plot. The x-axis is a dimension field and cannot be aggregated.
        public var xAxis: [QuickSightClientTypes.DimensionField]?
        /// The y-axis field well of a scatter plot. The y-axis is a dimension field and cannot be aggregated.
        public var yAxis: [QuickSightClientTypes.DimensionField]?

        public init (
            size: [QuickSightClientTypes.MeasureField]? = nil,
            xAxis: [QuickSightClientTypes.DimensionField]? = nil,
            yAxis: [QuickSightClientTypes.DimensionField]? = nil
        )
        {
            self.size = size
            self.xAxis = xAxis
            self.yAxis = yAxis
        }
    }

}

extension QuickSightClientTypes.ScatterPlotVisual: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case chartConfiguration = "ChartConfiguration"
        case columnHierarchies = "ColumnHierarchies"
        case subtitle = "Subtitle"
        case title = "Title"
        case visualId = "VisualId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for visualcustomaction0 in actions {
                try actionsContainer.encode(visualcustomaction0)
            }
        }
        if let chartConfiguration = self.chartConfiguration {
            try encodeContainer.encode(chartConfiguration, forKey: .chartConfiguration)
        }
        if let columnHierarchies = columnHierarchies {
            var columnHierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnHierarchies)
            for columnhierarchy0 in columnHierarchies {
                try columnHierarchiesContainer.encode(columnhierarchy0)
            }
        }
        if let subtitle = self.subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let visualId = self.visualId {
            try encodeContainer.encode(visualId, forKey: .visualId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visualIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visualId)
        visualId = visualIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualTitleLabelOptions.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualSubtitleLabelOptions.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let chartConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ScatterPlotConfiguration.self, forKey: .chartConfiguration)
        chartConfiguration = chartConfigurationDecoded
        let actionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.VisualCustomAction?].self, forKey: .actions)
        var actionsDecoded0:[QuickSightClientTypes.VisualCustomAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [QuickSightClientTypes.VisualCustomAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let columnHierarchiesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnHierarchy?].self, forKey: .columnHierarchies)
        var columnHierarchiesDecoded0:[QuickSightClientTypes.ColumnHierarchy]? = nil
        if let columnHierarchiesContainer = columnHierarchiesContainer {
            columnHierarchiesDecoded0 = [QuickSightClientTypes.ColumnHierarchy]()
            for structure0 in columnHierarchiesContainer {
                if let structure0 = structure0 {
                    columnHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        columnHierarchies = columnHierarchiesDecoded0
    }
}

extension QuickSightClientTypes {
    /// A scatter plot. For more information, see [Using scatter plots](https://docs.aws.amazon.com/quicksight/latest/user/scatter-plot.html) in the Amazon QuickSight User Guide.
    public struct ScatterPlotVisual: Swift.Equatable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration settings of the visual.
        public var chartConfiguration: QuickSightClientTypes.ScatterPlotConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init (
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.ScatterPlotConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }

}

extension QuickSightClientTypes.ScrollBarOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case visibility = "Visibility"
        case visibleRange = "VisibleRange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
        if let visibleRange = self.visibleRange {
            try encodeContainer.encode(visibleRange, forKey: .visibleRange)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
        let visibleRangeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisibleRangeOptions.self, forKey: .visibleRange)
        visibleRange = visibleRangeDecoded
    }
}

extension QuickSightClientTypes {
    /// The visual display options for a data zoom scroll bar.
    public struct ScrollBarOptions: Swift.Equatable {
        /// The visibility of the data zoom scroll bar.
        public var visibility: QuickSightClientTypes.Visibility?
        /// The visibility range for the data zoom scroll bar.
        public var visibleRange: QuickSightClientTypes.VisibleRangeOptions?

        public init (
            visibility: QuickSightClientTypes.Visibility? = nil,
            visibleRange: QuickSightClientTypes.VisibleRangeOptions? = nil
        )
        {
            self.visibility = visibility
            self.visibleRange = visibleRange
        }
    }

}

extension SearchAnalysesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for analysissearchfilter0 in filters {
                try filtersContainer.encode(analysissearchfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchAnalysesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/search/analyses"
    }
}

public struct SearchAnalysesInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the analyses that you're searching for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The structure for the search filters that you want to apply to your search.
    /// This member is required.
    public var filters: [QuickSightClientTypes.AnalysisSearchFilter]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        filters: [QuickSightClientTypes.AnalysisSearchFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchAnalysesInputBody: Swift.Equatable {
    let filters: [QuickSightClientTypes.AnalysisSearchFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension SearchAnalysesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.AnalysisSearchFilter?].self, forKey: .filters)
        var filtersDecoded0:[QuickSightClientTypes.AnalysisSearchFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [QuickSightClientTypes.AnalysisSearchFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchAnalysesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchAnalysesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SearchAnalysesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchAnalysesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SearchAnalysesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisSummaryList = output.analysisSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.analysisSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct SearchAnalysesOutputResponse: Swift.Equatable {
    /// Metadata describing the analyses that you searched for.
    public var analysisSummaryList: [QuickSightClientTypes.AnalysisSummary]?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        analysisSummaryList: [QuickSightClientTypes.AnalysisSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.analysisSummaryList = analysisSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct SearchAnalysesOutputResponseBody: Swift.Equatable {
    let analysisSummaryList: [QuickSightClientTypes.AnalysisSummary]?
    let nextToken: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension SearchAnalysesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisSummaryList = "AnalysisSummaryList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisSummaryListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.AnalysisSummary?].self, forKey: .analysisSummaryList)
        var analysisSummaryListDecoded0:[QuickSightClientTypes.AnalysisSummary]? = nil
        if let analysisSummaryListContainer = analysisSummaryListContainer {
            analysisSummaryListDecoded0 = [QuickSightClientTypes.AnalysisSummary]()
            for structure0 in analysisSummaryListContainer {
                if let structure0 = structure0 {
                    analysisSummaryListDecoded0?.append(structure0)
                }
            }
        }
        analysisSummaryList = analysisSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension SearchDashboardsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for dashboardsearchfilter0 in filters {
                try filtersContainer.encode(dashboardsearchfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchDashboardsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/search/dashboards"
    }
}

public struct SearchDashboardsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the user whose dashboards you're searching for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The filters to apply to the search. Currently, you can search only by user name, for example, "Filters": [ { "Name": "QUICKSIGHT_USER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1" } ]
    /// This member is required.
    public var filters: [QuickSightClientTypes.DashboardSearchFilter]?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        filters: [QuickSightClientTypes.DashboardSearchFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchDashboardsInputBody: Swift.Equatable {
    let filters: [QuickSightClientTypes.DashboardSearchFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension SearchDashboardsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DashboardSearchFilter?].self, forKey: .filters)
        var filtersDecoded0:[QuickSightClientTypes.DashboardSearchFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [QuickSightClientTypes.DashboardSearchFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchDashboardsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchDashboardsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SearchDashboardsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchDashboardsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SearchDashboardsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dashboardSummaryList = output.dashboardSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.dashboardSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct SearchDashboardsOutputResponse: Swift.Equatable {
    /// The list of dashboards owned by the user specified in Filters in your request.
    public var dashboardSummaryList: [QuickSightClientTypes.DashboardSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dashboardSummaryList: [QuickSightClientTypes.DashboardSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dashboardSummaryList = dashboardSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct SearchDashboardsOutputResponseBody: Swift.Equatable {
    let dashboardSummaryList: [QuickSightClientTypes.DashboardSummary]?
    let nextToken: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension SearchDashboardsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardSummaryList = "DashboardSummaryList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardSummaryListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DashboardSummary?].self, forKey: .dashboardSummaryList)
        var dashboardSummaryListDecoded0:[QuickSightClientTypes.DashboardSummary]? = nil
        if let dashboardSummaryListContainer = dashboardSummaryListContainer {
            dashboardSummaryListDecoded0 = [QuickSightClientTypes.DashboardSummary]()
            for structure0 in dashboardSummaryListContainer {
                if let structure0 = structure0 {
                    dashboardSummaryListDecoded0?.append(structure0)
                }
            }
        }
        dashboardSummaryList = dashboardSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension SearchDataSetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for datasetsearchfilter0 in filters {
                try filtersContainer.encode(datasetsearchfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchDataSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/search/data-sets"
    }
}

public struct SearchDataSetsInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The filters to apply to the search.
    /// This member is required.
    public var filters: [QuickSightClientTypes.DataSetSearchFilter]?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        filters: [QuickSightClientTypes.DataSetSearchFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchDataSetsInputBody: Swift.Equatable {
    let filters: [QuickSightClientTypes.DataSetSearchFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension SearchDataSetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataSetSearchFilter?].self, forKey: .filters)
        var filtersDecoded0:[QuickSightClientTypes.DataSetSearchFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [QuickSightClientTypes.DataSetSearchFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchDataSetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchDataSetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SearchDataSetsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchDataSetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SearchDataSetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSetSummaries = output.dataSetSummaries
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.dataSetSummaries = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct SearchDataSetsOutputResponse: Swift.Equatable {
    /// A DataSetSummaries object that returns a summary of a dataset.
    public var dataSetSummaries: [QuickSightClientTypes.DataSetSummary]?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dataSetSummaries: [QuickSightClientTypes.DataSetSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSetSummaries = dataSetSummaries
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct SearchDataSetsOutputResponseBody: Swift.Equatable {
    let dataSetSummaries: [QuickSightClientTypes.DataSetSummary]?
    let nextToken: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension SearchDataSetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetSummaries = "DataSetSummaries"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetSummariesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataSetSummary?].self, forKey: .dataSetSummaries)
        var dataSetSummariesDecoded0:[QuickSightClientTypes.DataSetSummary]? = nil
        if let dataSetSummariesContainer = dataSetSummariesContainer {
            dataSetSummariesDecoded0 = [QuickSightClientTypes.DataSetSummary]()
            for structure0 in dataSetSummariesContainer {
                if let structure0 = structure0 {
                    dataSetSummariesDecoded0?.append(structure0)
                }
            }
        }
        dataSetSummaries = dataSetSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension SearchDataSourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for datasourcesearchfilter0 in filters {
                try filtersContainer.encode(datasourcesearchfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchDataSourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/search/data-sources"
    }
}

public struct SearchDataSourcesInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The filters to apply to the search.
    /// This member is required.
    public var filters: [QuickSightClientTypes.DataSourceSearchFilter]?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        filters: [QuickSightClientTypes.DataSourceSearchFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchDataSourcesInputBody: Swift.Equatable {
    let filters: [QuickSightClientTypes.DataSourceSearchFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension SearchDataSourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataSourceSearchFilter?].self, forKey: .filters)
        var filtersDecoded0:[QuickSightClientTypes.DataSourceSearchFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [QuickSightClientTypes.DataSourceSearchFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchDataSourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchDataSourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SearchDataSourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchDataSourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SearchDataSourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSourceSummaries = output.dataSourceSummaries
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.dataSourceSummaries = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct SearchDataSourcesOutputResponse: Swift.Equatable {
    /// A DataSourceSummaries object that returns a summary of a data source.
    public var dataSourceSummaries: [QuickSightClientTypes.DataSourceSummary]?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dataSourceSummaries: [QuickSightClientTypes.DataSourceSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSourceSummaries = dataSourceSummaries
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct SearchDataSourcesOutputResponseBody: Swift.Equatable {
    let dataSourceSummaries: [QuickSightClientTypes.DataSourceSummary]?
    let nextToken: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension SearchDataSourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceSummaries = "DataSourceSummaries"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceSummariesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataSourceSummary?].self, forKey: .dataSourceSummaries)
        var dataSourceSummariesDecoded0:[QuickSightClientTypes.DataSourceSummary]? = nil
        if let dataSourceSummariesContainer = dataSourceSummariesContainer {
            dataSourceSummariesDecoded0 = [QuickSightClientTypes.DataSourceSummary]()
            for structure0 in dataSourceSummariesContainer {
                if let structure0 = structure0 {
                    dataSourceSummariesDecoded0?.append(structure0)
                }
            }
        }
        dataSourceSummaries = dataSourceSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension SearchFoldersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for foldersearchfilter0 in filters {
                try filtersContainer.encode(foldersearchfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchFoldersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/search/folders"
    }
}

public struct SearchFoldersInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The filters to apply to the search. Currently, you can search only by the parent folder ARN. For example, "Filters": [ { "Name": "PARENT_FOLDER_ARN", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:folder/folderId" } ].
    /// This member is required.
    public var filters: [QuickSightClientTypes.FolderSearchFilter]?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        filters: [QuickSightClientTypes.FolderSearchFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchFoldersInputBody: Swift.Equatable {
    let filters: [QuickSightClientTypes.FolderSearchFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension SearchFoldersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FolderSearchFilter?].self, forKey: .filters)
        var filtersDecoded0:[QuickSightClientTypes.FolderSearchFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [QuickSightClientTypes.FolderSearchFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchFoldersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchFoldersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SearchFoldersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchFoldersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SearchFoldersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.folderSummaryList = output.folderSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.folderSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct SearchFoldersOutputResponse: Swift.Equatable {
    /// A structure that contains all of the folders in the Amazon Web Services account. This structure provides basic information about the folders.
    public var folderSummaryList: [QuickSightClientTypes.FolderSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        folderSummaryList: [QuickSightClientTypes.FolderSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.folderSummaryList = folderSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct SearchFoldersOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let folderSummaryList: [QuickSightClientTypes.FolderSummary]?
    let nextToken: Swift.String?
    let requestId: Swift.String?
}

extension SearchFoldersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case folderSummaryList = "FolderSummaryList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let folderSummaryListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FolderSummary?].self, forKey: .folderSummaryList)
        var folderSummaryListDecoded0:[QuickSightClientTypes.FolderSummary]? = nil
        if let folderSummaryListContainer = folderSummaryListContainer {
            folderSummaryListDecoded0 = [QuickSightClientTypes.FolderSummary]()
            for structure0 in folderSummaryListContainer {
                if let structure0 = structure0 {
                    folderSummaryListDecoded0?.append(structure0)
                }
            }
        }
        folderSummaryList = folderSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension SearchGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for groupsearchfilter0 in filters {
                try filtersContainer.encode(groupsearchfilter0)
            }
        }
    }
}

extension SearchGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension SearchGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups-search"
    }
}

public struct SearchGroupsInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The structure for the search filters that you want to apply to your search.
    /// This member is required.
    public var filters: [QuickSightClientTypes.GroupSearchFilter]?
    /// The maximum number of results to return from this request.
    public var maxResults: Swift.Int?
    /// The namespace that you want to search.
    /// This member is required.
    public var namespace: Swift.String?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        filters: [QuickSightClientTypes.GroupSearchFilter]? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.filters = filters
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
    }
}

struct SearchGroupsInputBody: Swift.Equatable {
    let filters: [QuickSightClientTypes.GroupSearchFilter]?
}

extension SearchGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.GroupSearchFilter?].self, forKey: .filters)
        var filtersDecoded0:[QuickSightClientTypes.GroupSearchFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [QuickSightClientTypes.GroupSearchFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension SearchGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SearchGroupsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SearchGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groupList = output.groupList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.groupList = nil
            self.nextToken = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct SearchGroupsOutputResponse: Swift.Equatable {
    /// A list of groups in a specified namespace that match the filters you set in your SearchGroups request.
    public var groupList: [QuickSightClientTypes.Group]?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        groupList: [QuickSightClientTypes.Group]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.groupList = groupList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

struct SearchGroupsOutputResponseBody: Swift.Equatable {
    let groupList: [QuickSightClientTypes.Group]?
    let nextToken: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension SearchGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupList = "GroupList"
        case nextToken = "NextToken"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupListContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Group?].self, forKey: .groupList)
        var groupListDecoded0:[QuickSightClientTypes.Group]? = nil
        if let groupListContainer = groupListContainer {
            groupListDecoded0 = [QuickSightClientTypes.Group]()
            for structure0 in groupListContainer {
                if let structure0 = structure0 {
                    groupListDecoded0?.append(structure0)
                }
            }
        }
        groupList = groupListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension QuickSightClientTypes.SecondaryValueOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the presentation of the secondary value of a KPI visual.
    public struct SecondaryValueOptions: Swift.Equatable {
        /// Determines the visibility of the secondary value.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.visibility = visibility
        }
    }

}

extension QuickSightClientTypes.SectionAfterPageBreak: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SectionPageBreakStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of a page break after a section.
    public struct SectionAfterPageBreak: Swift.Equatable {
        /// The option that enables or disables a page break at the end of a section.
        public var status: QuickSightClientTypes.SectionPageBreakStatus?

        public init (
            status: QuickSightClientTypes.SectionPageBreakStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension QuickSightClientTypes.SectionBasedLayoutCanvasSizeOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case paperCanvasSizeOptions = "PaperCanvasSizeOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let paperCanvasSizeOptions = self.paperCanvasSizeOptions {
            try encodeContainer.encode(paperCanvasSizeOptions, forKey: .paperCanvasSizeOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let paperCanvasSizeOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SectionBasedLayoutPaperCanvasSizeOptions.self, forKey: .paperCanvasSizeOptions)
        paperCanvasSizeOptions = paperCanvasSizeOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// The options for the canvas of a section-based layout.
    public struct SectionBasedLayoutCanvasSizeOptions: Swift.Equatable {
        /// The options for a paper canvas of a section-based layout.
        public var paperCanvasSizeOptions: QuickSightClientTypes.SectionBasedLayoutPaperCanvasSizeOptions?

        public init (
            paperCanvasSizeOptions: QuickSightClientTypes.SectionBasedLayoutPaperCanvasSizeOptions? = nil
        )
        {
            self.paperCanvasSizeOptions = paperCanvasSizeOptions
        }
    }

}

extension QuickSightClientTypes.SectionBasedLayoutConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bodySections = "BodySections"
        case canvasSizeOptions = "CanvasSizeOptions"
        case footerSections = "FooterSections"
        case headerSections = "HeaderSections"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bodySections = bodySections {
            var bodySectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bodySections)
            for bodysectionconfiguration0 in bodySections {
                try bodySectionsContainer.encode(bodysectionconfiguration0)
            }
        }
        if let canvasSizeOptions = self.canvasSizeOptions {
            try encodeContainer.encode(canvasSizeOptions, forKey: .canvasSizeOptions)
        }
        if let footerSections = footerSections {
            var footerSectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .footerSections)
            for headerfootersectionconfiguration0 in footerSections {
                try footerSectionsContainer.encode(headerfootersectionconfiguration0)
            }
        }
        if let headerSections = headerSections {
            var headerSectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .headerSections)
            for headerfootersectionconfiguration0 in headerSections {
                try headerSectionsContainer.encode(headerfootersectionconfiguration0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerSectionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.HeaderFooterSectionConfiguration?].self, forKey: .headerSections)
        var headerSectionsDecoded0:[QuickSightClientTypes.HeaderFooterSectionConfiguration]? = nil
        if let headerSectionsContainer = headerSectionsContainer {
            headerSectionsDecoded0 = [QuickSightClientTypes.HeaderFooterSectionConfiguration]()
            for structure0 in headerSectionsContainer {
                if let structure0 = structure0 {
                    headerSectionsDecoded0?.append(structure0)
                }
            }
        }
        headerSections = headerSectionsDecoded0
        let bodySectionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.BodySectionConfiguration?].self, forKey: .bodySections)
        var bodySectionsDecoded0:[QuickSightClientTypes.BodySectionConfiguration]? = nil
        if let bodySectionsContainer = bodySectionsContainer {
            bodySectionsDecoded0 = [QuickSightClientTypes.BodySectionConfiguration]()
            for structure0 in bodySectionsContainer {
                if let structure0 = structure0 {
                    bodySectionsDecoded0?.append(structure0)
                }
            }
        }
        bodySections = bodySectionsDecoded0
        let footerSectionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.HeaderFooterSectionConfiguration?].self, forKey: .footerSections)
        var footerSectionsDecoded0:[QuickSightClientTypes.HeaderFooterSectionConfiguration]? = nil
        if let footerSectionsContainer = footerSectionsContainer {
            footerSectionsDecoded0 = [QuickSightClientTypes.HeaderFooterSectionConfiguration]()
            for structure0 in footerSectionsContainer {
                if let structure0 = structure0 {
                    footerSectionsDecoded0?.append(structure0)
                }
            }
        }
        footerSections = footerSectionsDecoded0
        let canvasSizeOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SectionBasedLayoutCanvasSizeOptions.self, forKey: .canvasSizeOptions)
        canvasSizeOptions = canvasSizeOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration for a section-based layout.
    public struct SectionBasedLayoutConfiguration: Swift.Equatable {
        /// A list of body section configurations.
        /// This member is required.
        public var bodySections: [QuickSightClientTypes.BodySectionConfiguration]?
        /// The options for the canvas of a section-based layout.
        /// This member is required.
        public var canvasSizeOptions: QuickSightClientTypes.SectionBasedLayoutCanvasSizeOptions?
        /// A list of footer section configurations.
        /// This member is required.
        public var footerSections: [QuickSightClientTypes.HeaderFooterSectionConfiguration]?
        /// A list of header section configurations.
        /// This member is required.
        public var headerSections: [QuickSightClientTypes.HeaderFooterSectionConfiguration]?

        public init (
            bodySections: [QuickSightClientTypes.BodySectionConfiguration]? = nil,
            canvasSizeOptions: QuickSightClientTypes.SectionBasedLayoutCanvasSizeOptions? = nil,
            footerSections: [QuickSightClientTypes.HeaderFooterSectionConfiguration]? = nil,
            headerSections: [QuickSightClientTypes.HeaderFooterSectionConfiguration]? = nil
        )
        {
            self.bodySections = bodySections
            self.canvasSizeOptions = canvasSizeOptions
            self.footerSections = footerSections
            self.headerSections = headerSections
        }
    }

}

extension QuickSightClientTypes.SectionBasedLayoutPaperCanvasSizeOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case paperMargin = "PaperMargin"
        case paperOrientation = "PaperOrientation"
        case paperSize = "PaperSize"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let paperMargin = self.paperMargin {
            try encodeContainer.encode(paperMargin, forKey: .paperMargin)
        }
        if let paperOrientation = self.paperOrientation {
            try encodeContainer.encode(paperOrientation.rawValue, forKey: .paperOrientation)
        }
        if let paperSize = self.paperSize {
            try encodeContainer.encode(paperSize.rawValue, forKey: .paperSize)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let paperSizeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PaperSize.self, forKey: .paperSize)
        paperSize = paperSizeDecoded
        let paperOrientationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PaperOrientation.self, forKey: .paperOrientation)
        paperOrientation = paperOrientationDecoded
        let paperMarginDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Spacing.self, forKey: .paperMargin)
        paperMargin = paperMarginDecoded
    }
}

extension QuickSightClientTypes {
    /// The options for a paper canvas of a section-based layout.
    public struct SectionBasedLayoutPaperCanvasSizeOptions: Swift.Equatable {
        /// Defines the spacing between the canvas content and the top, bottom, left, and right edges.
        public var paperMargin: QuickSightClientTypes.Spacing?
        /// The paper orientation that is used to define canvas dimensions. Choose one of the following options:
        ///
        /// * PORTRAIT
        ///
        /// * LANDSCAPE
        public var paperOrientation: QuickSightClientTypes.PaperOrientation?
        /// The paper size that is used to define canvas dimensions.
        public var paperSize: QuickSightClientTypes.PaperSize?

        public init (
            paperMargin: QuickSightClientTypes.Spacing? = nil,
            paperOrientation: QuickSightClientTypes.PaperOrientation? = nil,
            paperSize: QuickSightClientTypes.PaperSize? = nil
        )
        {
            self.paperMargin = paperMargin
            self.paperOrientation = paperOrientation
            self.paperSize = paperSize
        }
    }

}

extension QuickSightClientTypes.SectionLayoutConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case freeFormLayout = "FreeFormLayout"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let freeFormLayout = self.freeFormLayout {
            try encodeContainer.encode(freeFormLayout, forKey: .freeFormLayout)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let freeFormLayoutDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FreeFormSectionLayoutConfiguration.self, forKey: .freeFormLayout)
        freeFormLayout = freeFormLayoutDecoded
    }
}

extension QuickSightClientTypes {
    /// The layout configuration of a section.
    public struct SectionLayoutConfiguration: Swift.Equatable {
        /// The free-form layout configuration of a section.
        /// This member is required.
        public var freeFormLayout: QuickSightClientTypes.FreeFormSectionLayoutConfiguration?

        public init (
            freeFormLayout: QuickSightClientTypes.FreeFormSectionLayoutConfiguration? = nil
        )
        {
            self.freeFormLayout = freeFormLayout
        }
    }

}

extension QuickSightClientTypes.SectionPageBreakConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case after = "After"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let after = self.after {
            try encodeContainer.encode(after, forKey: .after)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let afterDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SectionAfterPageBreak.self, forKey: .after)
        after = afterDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of a page break for a section.
    public struct SectionPageBreakConfiguration: Swift.Equatable {
        /// The configuration of a page break after a section.
        public var after: QuickSightClientTypes.SectionAfterPageBreak?

        public init (
            after: QuickSightClientTypes.SectionAfterPageBreak? = nil
        )
        {
            self.after = after
        }
    }

}

extension QuickSightClientTypes {
    public enum SectionPageBreakStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [SectionPageBreakStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SectionPageBreakStatus(rawValue: rawValue) ?? SectionPageBreakStatus.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.SectionStyle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case height = "Height"
        case padding = "Padding"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let height = self.height {
            try encodeContainer.encode(height, forKey: .height)
        }
        if let padding = self.padding {
            try encodeContainer.encode(padding, forKey: .padding)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let heightDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .height)
        height = heightDecoded
        let paddingDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Spacing.self, forKey: .padding)
        padding = paddingDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that style a section.
    public struct SectionStyle: Swift.Equatable {
        /// The height of a section. Heights can only be defined for header and footer sections. The default height margin is 0.5 inches.
        public var height: Swift.String?
        /// The spacing between section content and its top, bottom, left, and right edges. There is no padding by default.
        public var padding: QuickSightClientTypes.Spacing?

        public init (
            height: Swift.String? = nil,
            padding: QuickSightClientTypes.Spacing? = nil
        )
        {
            self.height = height
            self.padding = padding
        }
    }

}

extension QuickSightClientTypes {
    public enum SelectAllValueOptions: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allValues
        case sdkUnknown(Swift.String)

        public static var allCases: [SelectAllValueOptions] {
            return [
                .allValues,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allValues: return "ALL_VALUES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SelectAllValueOptions(rawValue: rawValue) ?? SelectAllValueOptions.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum SelectedFieldOptions: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allFields
        case sdkUnknown(Swift.String)

        public static var allCases: [SelectedFieldOptions] {
            return [
                .allFields,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allFields: return "ALL_FIELDS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SelectedFieldOptions(rawValue: rawValue) ?? SelectedFieldOptions.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.SelectedSheetsFilterScopeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sheetVisualScopingConfigurations = "SheetVisualScopingConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sheetVisualScopingConfigurations = sheetVisualScopingConfigurations {
            var sheetVisualScopingConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sheetVisualScopingConfigurations)
            for sheetvisualscopingconfiguration0 in sheetVisualScopingConfigurations {
                try sheetVisualScopingConfigurationsContainer.encode(sheetvisualscopingconfiguration0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sheetVisualScopingConfigurationsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.SheetVisualScopingConfiguration?].self, forKey: .sheetVisualScopingConfigurations)
        var sheetVisualScopingConfigurationsDecoded0:[QuickSightClientTypes.SheetVisualScopingConfiguration]? = nil
        if let sheetVisualScopingConfigurationsContainer = sheetVisualScopingConfigurationsContainer {
            sheetVisualScopingConfigurationsDecoded0 = [QuickSightClientTypes.SheetVisualScopingConfiguration]()
            for structure0 in sheetVisualScopingConfigurationsContainer {
                if let structure0 = structure0 {
                    sheetVisualScopingConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sheetVisualScopingConfigurations = sheetVisualScopingConfigurationsDecoded0
    }
}

extension QuickSightClientTypes {
    /// The configuration for applying a filter to specific sheets or visuals. You can apply this filter to multiple visuals that are on one sheet or to all visuals on a sheet. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct SelectedSheetsFilterScopeConfiguration: Swift.Equatable {
        /// The sheet ID and visual IDs of the sheet and visuals that the filter is applied to.
        public var sheetVisualScopingConfigurations: [QuickSightClientTypes.SheetVisualScopingConfiguration]?

        public init (
            sheetVisualScopingConfigurations: [QuickSightClientTypes.SheetVisualScopingConfiguration]? = nil
        )
        {
            self.sheetVisualScopingConfigurations = sheetVisualScopingConfigurations
        }
    }

}

extension QuickSightClientTypes {
    public enum SelectedTooltipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case basic
        case detailed
        case sdkUnknown(Swift.String)

        public static var allCases: [SelectedTooltipType] {
            return [
                .basic,
                .detailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .basic: return "BASIC"
            case .detailed: return "DETAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SelectedTooltipType(rawValue: rawValue) ?? SelectedTooltipType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.SeriesItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataFieldSeriesItem = "DataFieldSeriesItem"
        case fieldSeriesItem = "FieldSeriesItem"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataFieldSeriesItem = self.dataFieldSeriesItem {
            try encodeContainer.encode(dataFieldSeriesItem, forKey: .dataFieldSeriesItem)
        }
        if let fieldSeriesItem = self.fieldSeriesItem {
            try encodeContainer.encode(fieldSeriesItem, forKey: .fieldSeriesItem)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldSeriesItemDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FieldSeriesItem.self, forKey: .fieldSeriesItem)
        fieldSeriesItem = fieldSeriesItemDecoded
        let dataFieldSeriesItemDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataFieldSeriesItem.self, forKey: .dataFieldSeriesItem)
        dataFieldSeriesItem = dataFieldSeriesItemDecoded
    }
}

extension QuickSightClientTypes {
    /// The series item configuration of a line chart. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct SeriesItem: Swift.Equatable {
        /// The data field series item configuration of a line chart.
        public var dataFieldSeriesItem: QuickSightClientTypes.DataFieldSeriesItem?
        /// The field series item configuration of a line chart.
        public var fieldSeriesItem: QuickSightClientTypes.FieldSeriesItem?

        public init (
            dataFieldSeriesItem: QuickSightClientTypes.DataFieldSeriesItem? = nil,
            fieldSeriesItem: QuickSightClientTypes.FieldSeriesItem? = nil
        )
        {
            self.dataFieldSeriesItem = dataFieldSeriesItem
            self.fieldSeriesItem = fieldSeriesItem
        }
    }

}

extension QuickSightClientTypes.ServiceNowParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case siteBaseUrl = "SiteBaseUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let siteBaseUrl = self.siteBaseUrl {
            try encodeContainer.encode(siteBaseUrl, forKey: .siteBaseUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteBaseUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteBaseUrl)
        siteBaseUrl = siteBaseUrlDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for ServiceNow.
    public struct ServiceNowParameters: Swift.Equatable {
        /// URL of the base site.
        /// This member is required.
        public var siteBaseUrl: Swift.String?

        public init (
            siteBaseUrl: Swift.String? = nil
        )
        {
            self.siteBaseUrl = siteBaseUrl
        }
    }

}

extension SessionLifetimeInMinutesInvalidException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SessionLifetimeInMinutesInvalidExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of minutes specified for the lifetime of a session isn't valid. The session lifetime must be 15-600 minutes.
public struct SessionLifetimeInMinutesInvalidException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct SessionLifetimeInMinutesInvalidExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension SessionLifetimeInMinutesInvalidExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.SessionTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension QuickSightClientTypes.SessionTag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SessionTag(key: \(Swift.String(describing: key)), value: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {
    /// The key-value pair used for the row-level security tags feature.
    public struct SessionTag: Swift.Equatable {
        /// The key for the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value that you want to assign the tag.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension QuickSightClientTypes.SetParameterValueConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationParameterName = "DestinationParameterName"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationParameterName = self.destinationParameterName {
            try encodeContainer.encode(destinationParameterName, forKey: .destinationParameterName)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationParameterName)
        destinationParameterName = destinationParameterNameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DestinationParameterValueConfiguration.self, forKey: .value)
        value = valueDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of adding parameters in action.
    public struct SetParameterValueConfiguration: Swift.Equatable {
        /// The destination parameter name of the SetParameterValueConfiguration.
        /// This member is required.
        public var destinationParameterName: Swift.String?
        /// The configuration of destination parameter values. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
        /// This member is required.
        public var value: QuickSightClientTypes.DestinationParameterValueConfiguration?

        public init (
            destinationParameterName: Swift.String? = nil,
            value: QuickSightClientTypes.DestinationParameterValueConfiguration? = nil
        )
        {
            self.destinationParameterName = destinationParameterName
            self.value = value
        }
    }

}

extension QuickSightClientTypes.ShapeConditionalFormat: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backgroundColor = "BackgroundColor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backgroundColor = self.backgroundColor {
            try encodeContainer.encode(backgroundColor, forKey: .backgroundColor)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backgroundColorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ConditionalFormattingColor.self, forKey: .backgroundColor)
        backgroundColor = backgroundColorDecoded
    }
}

extension QuickSightClientTypes {
    /// The shape conditional formatting of a filled map visual.
    public struct ShapeConditionalFormat: Swift.Equatable {
        /// The conditional formatting for the shape background color of a filled map visual.
        /// This member is required.
        public var backgroundColor: QuickSightClientTypes.ConditionalFormattingColor?

        public init (
            backgroundColor: QuickSightClientTypes.ConditionalFormattingColor? = nil
        )
        {
            self.backgroundColor = backgroundColor
        }
    }

}

extension QuickSightClientTypes.Sheet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case sheetId = "SheetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sheetId = self.sheetId {
            try encodeContainer.encode(sheetId, forKey: .sheetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sheetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sheetId)
        sheetId = sheetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension QuickSightClientTypes {
    /// A sheet, which is an object that contains a set of visuals that are viewed together on one page in Amazon QuickSight. Every analysis and dashboard contains at least one sheet. Each sheet contains at least one visualization widget, for example a chart, pivot table, or narrative insight. Sheets can be associated with other components, such as controls, filters, and so on.
    public struct Sheet: Swift.Equatable {
        /// The name of a sheet. This name is displayed on the sheet's tab in the Amazon QuickSight console.
        public var name: Swift.String?
        /// The unique identifier associated with a sheet.
        public var sheetId: Swift.String?

        public init (
            name: Swift.String? = nil,
            sheetId: Swift.String? = nil
        )
        {
            self.name = name
            self.sheetId = sheetId
        }
    }

}

extension QuickSightClientTypes {
    public enum SheetContentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case interactive
        case paginated
        case sdkUnknown(Swift.String)

        public static var allCases: [SheetContentType] {
            return [
                .interactive,
                .paginated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .interactive: return "INTERACTIVE"
            case .paginated: return "PAGINATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SheetContentType(rawValue: rawValue) ?? SheetContentType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum SheetControlDateTimePickerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dateRange
        case singleValued
        case sdkUnknown(Swift.String)

        public static var allCases: [SheetControlDateTimePickerType] {
            return [
                .dateRange,
                .singleValued,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dateRange: return "DATE_RANGE"
            case .singleValued: return "SINGLE_VALUED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SheetControlDateTimePickerType(rawValue: rawValue) ?? SheetControlDateTimePickerType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.SheetControlLayout: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SheetControlLayoutConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension QuickSightClientTypes {
    /// A grid layout to define the placement of sheet control.
    public struct SheetControlLayout: Swift.Equatable {
        /// The configuration that determines the elements and canvas size options of sheet control.
        /// This member is required.
        public var configuration: QuickSightClientTypes.SheetControlLayoutConfiguration?

        public init (
            configuration: QuickSightClientTypes.SheetControlLayoutConfiguration? = nil
        )
        {
            self.configuration = configuration
        }
    }

}

extension QuickSightClientTypes.SheetControlLayoutConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gridLayout = "GridLayout"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gridLayout = self.gridLayout {
            try encodeContainer.encode(gridLayout, forKey: .gridLayout)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gridLayoutDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GridLayoutConfiguration.self, forKey: .gridLayout)
        gridLayout = gridLayoutDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration that determines the elements and canvas size options of sheet control.
    public struct SheetControlLayoutConfiguration: Swift.Equatable {
        /// The configuration that determines the elements and canvas size options of sheet control.
        public var gridLayout: QuickSightClientTypes.GridLayoutConfiguration?

        public init (
            gridLayout: QuickSightClientTypes.GridLayoutConfiguration? = nil
        )
        {
            self.gridLayout = gridLayout
        }
    }

}

extension QuickSightClientTypes {
    public enum SheetControlListType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case multiSelect
        case singleSelect
        case sdkUnknown(Swift.String)

        public static var allCases: [SheetControlListType] {
            return [
                .multiSelect,
                .singleSelect,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .multiSelect: return "MULTI_SELECT"
            case .singleSelect: return "SINGLE_SELECT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SheetControlListType(rawValue: rawValue) ?? SheetControlListType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum SheetControlSliderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case range
        case singlePoint
        case sdkUnknown(Swift.String)

        public static var allCases: [SheetControlSliderType] {
            return [
                .range,
                .singlePoint,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .range: return "RANGE"
            case .singlePoint: return "SINGLE_POINT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SheetControlSliderType(rawValue: rawValue) ?? SheetControlSliderType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.SheetControlsOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case visibilityState = "VisibilityState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let visibilityState = self.visibilityState {
            try encodeContainer.encode(visibilityState.rawValue, forKey: .visibilityState)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityStateDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardUIState.self, forKey: .visibilityState)
        visibilityState = visibilityStateDecoded
    }
}

extension QuickSightClientTypes {
    /// Sheet controls option.
    public struct SheetControlsOption: Swift.Equatable {
        /// Visibility state.
        public var visibilityState: QuickSightClientTypes.DashboardUIState?

        public init (
            visibilityState: QuickSightClientTypes.DashboardUIState? = nil
        )
        {
            self.visibilityState = visibilityState
        }
    }

}

extension QuickSightClientTypes.SheetDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "ContentType"
        case description = "Description"
        case filterControls = "FilterControls"
        case layouts = "Layouts"
        case name = "Name"
        case parameterControls = "ParameterControls"
        case sheetControlLayouts = "SheetControlLayouts"
        case sheetId = "SheetId"
        case textBoxes = "TextBoxes"
        case title = "Title"
        case visuals = "Visuals"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType.rawValue, forKey: .contentType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let filterControls = filterControls {
            var filterControlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterControls)
            for filtercontrol0 in filterControls {
                try filterControlsContainer.encode(filtercontrol0)
            }
        }
        if let layouts = layouts {
            var layoutsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layouts)
            for layout0 in layouts {
                try layoutsContainer.encode(layout0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameterControls = parameterControls {
            var parameterControlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterControls)
            for parametercontrol0 in parameterControls {
                try parameterControlsContainer.encode(parametercontrol0)
            }
        }
        if let sheetControlLayouts = sheetControlLayouts {
            var sheetControlLayoutsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sheetControlLayouts)
            for sheetcontrollayout0 in sheetControlLayouts {
                try sheetControlLayoutsContainer.encode(sheetcontrollayout0)
            }
        }
        if let sheetId = self.sheetId {
            try encodeContainer.encode(sheetId, forKey: .sheetId)
        }
        if let textBoxes = textBoxes {
            var textBoxesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .textBoxes)
            for sheettextbox0 in textBoxes {
                try textBoxesContainer.encode(sheettextbox0)
            }
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let visuals = visuals {
            var visualsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .visuals)
            for visual0 in visuals {
                try visualsContainer.encode(visual0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sheetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sheetId)
        sheetId = sheetIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let parameterControlsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ParameterControl?].self, forKey: .parameterControls)
        var parameterControlsDecoded0:[QuickSightClientTypes.ParameterControl]? = nil
        if let parameterControlsContainer = parameterControlsContainer {
            parameterControlsDecoded0 = [QuickSightClientTypes.ParameterControl]()
            for structure0 in parameterControlsContainer {
                if let structure0 = structure0 {
                    parameterControlsDecoded0?.append(structure0)
                }
            }
        }
        parameterControls = parameterControlsDecoded0
        let filterControlsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FilterControl?].self, forKey: .filterControls)
        var filterControlsDecoded0:[QuickSightClientTypes.FilterControl]? = nil
        if let filterControlsContainer = filterControlsContainer {
            filterControlsDecoded0 = [QuickSightClientTypes.FilterControl]()
            for structure0 in filterControlsContainer {
                if let structure0 = structure0 {
                    filterControlsDecoded0?.append(structure0)
                }
            }
        }
        filterControls = filterControlsDecoded0
        let visualsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Visual?].self, forKey: .visuals)
        var visualsDecoded0:[QuickSightClientTypes.Visual]? = nil
        if let visualsContainer = visualsContainer {
            visualsDecoded0 = [QuickSightClientTypes.Visual]()
            for structure0 in visualsContainer {
                if let structure0 = structure0 {
                    visualsDecoded0?.append(structure0)
                }
            }
        }
        visuals = visualsDecoded0
        let textBoxesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.SheetTextBox?].self, forKey: .textBoxes)
        var textBoxesDecoded0:[QuickSightClientTypes.SheetTextBox]? = nil
        if let textBoxesContainer = textBoxesContainer {
            textBoxesDecoded0 = [QuickSightClientTypes.SheetTextBox]()
            for structure0 in textBoxesContainer {
                if let structure0 = structure0 {
                    textBoxesDecoded0?.append(structure0)
                }
            }
        }
        textBoxes = textBoxesDecoded0
        let layoutsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Layout?].self, forKey: .layouts)
        var layoutsDecoded0:[QuickSightClientTypes.Layout]? = nil
        if let layoutsContainer = layoutsContainer {
            layoutsDecoded0 = [QuickSightClientTypes.Layout]()
            for structure0 in layoutsContainer {
                if let structure0 = structure0 {
                    layoutsDecoded0?.append(structure0)
                }
            }
        }
        layouts = layoutsDecoded0
        let sheetControlLayoutsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.SheetControlLayout?].self, forKey: .sheetControlLayouts)
        var sheetControlLayoutsDecoded0:[QuickSightClientTypes.SheetControlLayout]? = nil
        if let sheetControlLayoutsContainer = sheetControlLayoutsContainer {
            sheetControlLayoutsDecoded0 = [QuickSightClientTypes.SheetControlLayout]()
            for structure0 in sheetControlLayoutsContainer {
                if let structure0 = structure0 {
                    sheetControlLayoutsDecoded0?.append(structure0)
                }
            }
        }
        sheetControlLayouts = sheetControlLayoutsDecoded0
        let contentTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SheetContentType.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension QuickSightClientTypes {
    /// A sheet is an object that contains a set of visuals that are viewed together on one page in a paginated report. Every analysis and dashboard must contain at least one sheet.
    public struct SheetDefinition: Swift.Equatable {
        /// The layout content type of the sheet. Choose one of the following options:
        ///
        /// * PAGINATED: Creates a sheet for a paginated report.
        ///
        /// * INTERACTIVE: Creates a sheet for an interactive dashboard.
        public var contentType: QuickSightClientTypes.SheetContentType?
        /// A description of the sheet.
        public var description: Swift.String?
        /// The list of filter controls that are on a sheet. For more information, see [Adding filter controls to analysis sheets](https://docs.aws.amazon.com/quicksight/latest/user/filter-controls.html) in the Amazon QuickSight User Guide.
        public var filterControls: [QuickSightClientTypes.FilterControl]?
        /// Layouts define how the components of a sheet are arranged. For more information, see [Types of layout](https://docs.aws.amazon.com/quicksight/latest/user/types-of-layout.html) in the Amazon QuickSight User Guide.
        public var layouts: [QuickSightClientTypes.Layout]?
        /// The name of the sheet. This name is displayed on the sheet's tab in the Amazon QuickSight console.
        public var name: Swift.String?
        /// The list of parameter controls that are on a sheet. For more information, see [Using a Control with a Parameter in Amazon QuickSight](https://docs.aws.amazon.com/quicksight/latest/user/parameters-controls.html) in the Amazon QuickSight User Guide.
        public var parameterControls: [QuickSightClientTypes.ParameterControl]?
        /// The control layouts of the sheet.
        public var sheetControlLayouts: [QuickSightClientTypes.SheetControlLayout]?
        /// The unique identifier of a sheet.
        /// This member is required.
        public var sheetId: Swift.String?
        /// The text boxes that are on a sheet.
        public var textBoxes: [QuickSightClientTypes.SheetTextBox]?
        /// The title of the sheet.
        public var title: Swift.String?
        /// A list of the visuals that are on a sheet. Visual placement is determined by the layout of the sheet.
        public var visuals: [QuickSightClientTypes.Visual]?

        public init (
            contentType: QuickSightClientTypes.SheetContentType? = nil,
            description: Swift.String? = nil,
            filterControls: [QuickSightClientTypes.FilterControl]? = nil,
            layouts: [QuickSightClientTypes.Layout]? = nil,
            name: Swift.String? = nil,
            parameterControls: [QuickSightClientTypes.ParameterControl]? = nil,
            sheetControlLayouts: [QuickSightClientTypes.SheetControlLayout]? = nil,
            sheetId: Swift.String? = nil,
            textBoxes: [QuickSightClientTypes.SheetTextBox]? = nil,
            title: Swift.String? = nil,
            visuals: [QuickSightClientTypes.Visual]? = nil
        )
        {
            self.contentType = contentType
            self.description = description
            self.filterControls = filterControls
            self.layouts = layouts
            self.name = name
            self.parameterControls = parameterControls
            self.sheetControlLayouts = sheetControlLayouts
            self.sheetId = sheetId
            self.textBoxes = textBoxes
            self.title = title
            self.visuals = visuals
        }
    }

}

extension QuickSightClientTypes.SheetElementConfigurationOverrides: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension QuickSightClientTypes {
    /// The override configuration of the rendering rules of a sheet.
    public struct SheetElementConfigurationOverrides: Swift.Equatable {
        /// Determines whether or not the overrides are visible. Choose one of the following options:
        ///
        /// * VISIBLE
        ///
        /// * HIDDEN
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.visibility = visibility
        }
    }

}

extension QuickSightClientTypes.SheetElementRenderingRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationOverrides = "ConfigurationOverrides"
        case expression = "Expression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationOverrides = self.configurationOverrides {
            try encodeContainer.encode(configurationOverrides, forKey: .configurationOverrides)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let configurationOverridesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SheetElementConfigurationOverrides.self, forKey: .configurationOverrides)
        configurationOverrides = configurationOverridesDecoded
    }
}

extension QuickSightClientTypes.SheetElementRenderingRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SheetElementRenderingRule(configurationOverrides: \(Swift.String(describing: configurationOverrides)), expression: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {
    /// The rendering rules of a sheet that uses a free-form layout.
    public struct SheetElementRenderingRule: Swift.Equatable {
        /// The override configuration of the rendering rules of a sheet.
        /// This member is required.
        public var configurationOverrides: QuickSightClientTypes.SheetElementConfigurationOverrides?
        /// The expression of the rendering rules of a sheet.
        /// This member is required.
        public var expression: Swift.String?

        public init (
            configurationOverrides: QuickSightClientTypes.SheetElementConfigurationOverrides? = nil,
            expression: Swift.String? = nil
        )
        {
            self.configurationOverrides = configurationOverrides
            self.expression = expression
        }
    }

}

extension QuickSightClientTypes.SheetStyle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tile = "Tile"
        case tileLayout = "TileLayout"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tile = self.tile {
            try encodeContainer.encode(tile, forKey: .tile)
        }
        if let tileLayout = self.tileLayout {
            try encodeContainer.encode(tileLayout, forKey: .tileLayout)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tileDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TileStyle.self, forKey: .tile)
        tile = tileDecoded
        let tileLayoutDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TileLayoutStyle.self, forKey: .tileLayout)
        tileLayout = tileLayoutDecoded
    }
}

extension QuickSightClientTypes {
    /// The theme display options for sheets.
    public struct SheetStyle: Swift.Equatable {
        /// The display options for tiles.
        public var tile: QuickSightClientTypes.TileStyle?
        /// The layout options for tiles.
        public var tileLayout: QuickSightClientTypes.TileLayoutStyle?

        public init (
            tile: QuickSightClientTypes.TileStyle? = nil,
            tileLayout: QuickSightClientTypes.TileLayoutStyle? = nil
        )
        {
            self.tile = tile
            self.tileLayout = tileLayout
        }
    }

}

extension QuickSightClientTypes.SheetTextBox: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case sheetTextBoxId = "SheetTextBoxId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let sheetTextBoxId = self.sheetTextBoxId {
            try encodeContainer.encode(sheetTextBoxId, forKey: .sheetTextBoxId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sheetTextBoxIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sheetTextBoxId)
        sheetTextBoxId = sheetTextBoxIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension QuickSightClientTypes {
    /// A text box.
    public struct SheetTextBox: Swift.Equatable {
        /// The content that is displayed in the text box.
        public var content: Swift.String?
        /// The unique identifier for a text box. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have text boxes that share identifiers.
        /// This member is required.
        public var sheetTextBoxId: Swift.String?

        public init (
            content: Swift.String? = nil,
            sheetTextBoxId: Swift.String? = nil
        )
        {
            self.content = content
            self.sheetTextBoxId = sheetTextBoxId
        }
    }

}

extension QuickSightClientTypes.SheetVisualScopingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scope = "Scope"
        case sheetId = "SheetId"
        case visualIds = "VisualIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scope = self.scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
        if let sheetId = self.sheetId {
            try encodeContainer.encode(sheetId, forKey: .sheetId)
        }
        if let visualIds = visualIds {
            var visualIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .visualIds)
            for shortrestrictiveresourceid0 in visualIds {
                try visualIdsContainer.encode(shortrestrictiveresourceid0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sheetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sheetId)
        sheetId = sheetIdDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterVisualScope.self, forKey: .scope)
        scope = scopeDecoded
        let visualIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .visualIds)
        var visualIdsDecoded0:[Swift.String]? = nil
        if let visualIdsContainer = visualIdsContainer {
            visualIdsDecoded0 = [Swift.String]()
            for string0 in visualIdsContainer {
                if let string0 = string0 {
                    visualIdsDecoded0?.append(string0)
                }
            }
        }
        visualIds = visualIdsDecoded0
    }
}

extension QuickSightClientTypes {
    /// The filter that is applied to the options.
    public struct SheetVisualScopingConfiguration: Swift.Equatable {
        /// The scope of the applied entities. Choose one of the following options:
        ///
        /// * ALL_VISUALS
        ///
        /// * SELECTED_VISUALS
        /// This member is required.
        public var scope: QuickSightClientTypes.FilterVisualScope?
        /// The selected sheet that the filter is applied to.
        /// This member is required.
        public var sheetId: Swift.String?
        /// The selected visuals that the filter is applied to.
        public var visualIds: [Swift.String]?

        public init (
            scope: QuickSightClientTypes.FilterVisualScope? = nil,
            sheetId: Swift.String? = nil,
            visualIds: [Swift.String]? = nil
        )
        {
            self.scope = scope
            self.sheetId = sheetId
            self.visualIds = visualIds
        }
    }

}

extension QuickSightClientTypes.ShortFormatText: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case plainText = "PlainText"
        case richText = "RichText"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let plainText = self.plainText {
            try encodeContainer.encode(plainText, forKey: .plainText)
        }
        if let richText = self.richText {
            try encodeContainer.encode(richText, forKey: .richText)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let plainTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .plainText)
        plainText = plainTextDecoded
        let richTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .richText)
        richText = richTextDecoded
    }
}

extension QuickSightClientTypes {
    /// The text format for the title. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct ShortFormatText: Swift.Equatable {
        /// Plain text format.
        public var plainText: Swift.String?
        /// Rich text. Examples of rich text include bold, underline, and italics.
        public var richText: Swift.String?

        public init (
            plainText: Swift.String? = nil,
            richText: Swift.String? = nil
        )
        {
            self.plainText = plainText
            self.richText = richText
        }
    }

}

extension QuickSightClientTypes.SignupResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamUser = "IAMUser"
        case accountName
        case directoryType
        case userLoginName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if iamUser != false {
            try encodeContainer.encode(iamUser, forKey: .iamUser)
        }
        if let accountName = self.accountName {
            try encodeContainer.encode(accountName, forKey: .accountName)
        }
        if let directoryType = self.directoryType {
            try encodeContainer.encode(directoryType, forKey: .directoryType)
        }
        if let userLoginName = self.userLoginName {
            try encodeContainer.encode(userLoginName, forKey: .userLoginName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamUserDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .iamUser) ?? false
        iamUser = iamUserDecoded
        let userLoginNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userLoginName)
        userLoginName = userLoginNameDecoded
        let accountNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountName)
        accountName = accountNameDecoded
        let directoryTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryType)
        directoryType = directoryTypeDecoded
    }
}

extension QuickSightClientTypes {
    /// A SignupResponse object that contains a summary of a newly created account.
    public struct SignupResponse: Swift.Equatable {
        /// The name of your Amazon QuickSight account.
        public var accountName: Swift.String?
        /// The type of Active Directory that is being used to authenticate the Amazon QuickSight account. Valid values are SIMPLE_AD, AD_CONNECTOR, and MICROSOFT_AD.
        public var directoryType: Swift.String?
        /// A Boolean that is TRUE if the Amazon QuickSight uses IAM as an authentication method.
        public var iamUser: Swift.Bool
        /// The user login name for your Amazon QuickSight account.
        public var userLoginName: Swift.String?

        public init (
            accountName: Swift.String? = nil,
            directoryType: Swift.String? = nil,
            iamUser: Swift.Bool = false,
            userLoginName: Swift.String? = nil
        )
        {
            self.accountName = accountName
            self.directoryType = directoryType
            self.iamUser = iamUser
            self.userLoginName = userLoginName
        }
    }

}

extension QuickSightClientTypes.SimpleClusterMarker: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case color = "Color"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let color = self.color {
            try encodeContainer.encode(color, forKey: .color)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let colorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .color)
        color = colorDecoded
    }
}

extension QuickSightClientTypes {
    /// The simple cluster marker of the cluster marker.
    public struct SimpleClusterMarker: Swift.Equatable {
        /// The color of the simple cluster marker.
        public var color: Swift.String?

        public init (
            color: Swift.String? = nil
        )
        {
            self.color = color
        }
    }

}

extension QuickSightClientTypes {
    public enum SimpleNumericalAggregationFunction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case average
        case count
        case distinctCount
        case max
        case median
        case min
        case stdev
        case stdevp
        case sum
        case `var`
        case varp
        case sdkUnknown(Swift.String)

        public static var allCases: [SimpleNumericalAggregationFunction] {
            return [
                .average,
                .count,
                .distinctCount,
                .max,
                .median,
                .min,
                .stdev,
                .stdevp,
                .sum,
                .var,
                .varp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .average: return "AVERAGE"
            case .count: return "COUNT"
            case .distinctCount: return "DISTINCT_COUNT"
            case .max: return "MAX"
            case .median: return "MEDIAN"
            case .min: return "MIN"
            case .stdev: return "STDEV"
            case .stdevp: return "STDEVP"
            case .sum: return "SUM"
            case .var: return "VAR"
            case .varp: return "VARP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SimpleNumericalAggregationFunction(rawValue: rawValue) ?? SimpleNumericalAggregationFunction.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.SliderControlDisplayOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case titleOptions = "TitleOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let titleOptions = self.titleOptions {
            try encodeContainer.encode(titleOptions, forKey: .titleOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LabelOptions.self, forKey: .titleOptions)
        titleOptions = titleOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// The display options of a control.
    public struct SliderControlDisplayOptions: Swift.Equatable {
        /// The options to configure the title visibility, name, and font size.
        public var titleOptions: QuickSightClientTypes.LabelOptions?

        public init (
            titleOptions: QuickSightClientTypes.LabelOptions? = nil
        )
        {
            self.titleOptions = titleOptions
        }
    }

}

extension QuickSightClientTypes.SmallMultiplesOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxVisibleColumns = "MaxVisibleColumns"
        case maxVisibleRows = "MaxVisibleRows"
        case panelConfiguration = "PanelConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxVisibleColumns = self.maxVisibleColumns {
            try encodeContainer.encode(maxVisibleColumns, forKey: .maxVisibleColumns)
        }
        if let maxVisibleRows = self.maxVisibleRows {
            try encodeContainer.encode(maxVisibleRows, forKey: .maxVisibleRows)
        }
        if let panelConfiguration = self.panelConfiguration {
            try encodeContainer.encode(panelConfiguration, forKey: .panelConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxVisibleRowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxVisibleRows)
        maxVisibleRows = maxVisibleRowsDecoded
        let maxVisibleColumnsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxVisibleColumns)
        maxVisibleColumns = maxVisibleColumnsDecoded
        let panelConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PanelConfiguration.self, forKey: .panelConfiguration)
        panelConfiguration = panelConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// Options that determine the layout and display options of a chart's small multiples.
    public struct SmallMultiplesOptions: Swift.Equatable {
        /// Sets the maximum number of visible columns to display in the grid of small multiples panels. The default is Auto, which automatically adjusts the columns in the grid to fit the overall layout and size of the given chart.
        public var maxVisibleColumns: Swift.Int?
        /// Sets the maximum number of visible rows to display in the grid of small multiples panels. The default value is Auto, which automatically adjusts the rows in the grid to fit the overall layout and size of the given chart.
        public var maxVisibleRows: Swift.Int?
        /// Configures the display options for each small multiples panel.
        public var panelConfiguration: QuickSightClientTypes.PanelConfiguration?

        public init (
            maxVisibleColumns: Swift.Int? = nil,
            maxVisibleRows: Swift.Int? = nil,
            panelConfiguration: QuickSightClientTypes.PanelConfiguration? = nil
        )
        {
            self.maxVisibleColumns = maxVisibleColumns
            self.maxVisibleRows = maxVisibleRows
            self.panelConfiguration = panelConfiguration
        }
    }

}

extension QuickSightClientTypes.SnowflakeParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case host = "Host"
        case warehouse = "Warehouse"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if let warehouse = self.warehouse {
            try encodeContainer.encode(warehouse, forKey: .warehouse)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let warehouseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .warehouse)
        warehouse = warehouseDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for Snowflake.
    public struct SnowflakeParameters: Swift.Equatable {
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Warehouse.
        /// This member is required.
        public var warehouse: Swift.String?

        public init (
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            warehouse: Swift.String? = nil
        )
        {
            self.database = database
            self.host = host
            self.warehouse = warehouse
        }
    }

}

extension QuickSightClientTypes {
    public enum SortDirection: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortDirection] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortDirection(rawValue: rawValue) ?? SortDirection.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.Spacing: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bottom = "Bottom"
        case `left` = "Left"
        case `right` = "Right"
        case top = "Top"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bottom = self.bottom {
            try encodeContainer.encode(bottom, forKey: .bottom)
        }
        if let `left` = self.`left` {
            try encodeContainer.encode(`left`, forKey: .`left`)
        }
        if let `right` = self.`right` {
            try encodeContainer.encode(`right`, forKey: .`right`)
        }
        if let top = self.top {
            try encodeContainer.encode(top, forKey: .top)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .top)
        top = topDecoded
        let bottomDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bottom)
        bottom = bottomDecoded
        let leftDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .left)
        `left` = leftDecoded
        let rightDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .right)
        `right` = rightDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of spacing (often a margin or padding).
    public struct Spacing: Swift.Equatable {
        /// Define the bottom spacing.
        public var bottom: Swift.String?
        /// Define the left spacing.
        public var `left`: Swift.String?
        /// Define the right spacing.
        public var `right`: Swift.String?
        /// Define the top spacing.
        public var top: Swift.String?

        public init (
            bottom: Swift.String? = nil,
            `left`: Swift.String? = nil,
            `right`: Swift.String? = nil,
            top: Swift.String? = nil
        )
        {
            self.bottom = bottom
            self.`left` = `left`
            self.`right` = `right`
            self.top = top
        }
    }

}

extension QuickSightClientTypes.SparkParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for Spark.
    public struct SparkParameters: Swift.Equatable {
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int

        public init (
            host: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.host = host
            self.port = port
        }
    }

}

extension QuickSightClientTypes.SqlServerParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for SQL Server.
    public struct SqlServerParameters: Swift.Equatable {
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int

        public init (
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.database = database
            self.host = host
            self.port = port
        }
    }

}

extension QuickSightClientTypes.SslProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disableSsl = "DisableSsl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if disableSsl != false {
            try encodeContainer.encode(disableSsl, forKey: .disableSsl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disableSslDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableSsl) ?? false
        disableSsl = disableSslDecoded
    }
}

extension QuickSightClientTypes {
    /// Secure Socket Layer (SSL) properties that apply when Amazon QuickSight connects to your underlying data source.
    public struct SslProperties: Swift.Equatable {
        /// A Boolean option to control whether SSL should be disabled.
        public var disableSsl: Swift.Bool

        public init (
            disableSsl: Swift.Bool = false
        )
        {
            self.disableSsl = disableSsl
        }
    }

}

extension QuickSightClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.StringDefaultValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dynamicValue = "DynamicValue"
        case staticValues = "StaticValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dynamicValue = self.dynamicValue {
            try encodeContainer.encode(dynamicValue, forKey: .dynamicValue)
        }
        if let staticValues = staticValues {
            var staticValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .staticValues)
            for sensitivestringobject0 in staticValues {
                try staticValuesContainer.encode(sensitivestringobject0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dynamicValueDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DynamicDefaultValue.self, forKey: .dynamicValue)
        dynamicValue = dynamicValueDecoded
        let staticValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .staticValues)
        var staticValuesDecoded0:[Swift.String]? = nil
        if let staticValuesContainer = staticValuesContainer {
            staticValuesDecoded0 = [Swift.String]()
            for string0 in staticValuesContainer {
                if let string0 = string0 {
                    staticValuesDecoded0?.append(string0)
                }
            }
        }
        staticValues = staticValuesDecoded0
    }
}

extension QuickSightClientTypes {
    /// The default values of the StringParameterDeclaration.
    public struct StringDefaultValues: Swift.Equatable {
        /// The dynamic value of the StringDefaultValues. Different defaults displayed according to users, groups, and values mapping.
        public var dynamicValue: QuickSightClientTypes.DynamicDefaultValue?
        /// The static values of the DecimalDefaultValues.
        public var staticValues: [Swift.String]?

        public init (
            dynamicValue: QuickSightClientTypes.DynamicDefaultValue? = nil,
            staticValues: [Swift.String]? = nil
        )
        {
            self.dynamicValue = dynamicValue
            self.staticValues = staticValues
        }
    }

}

extension QuickSightClientTypes.StringFormatConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nullValueFormatConfiguration = "NullValueFormatConfiguration"
        case numericFormatConfiguration = "NumericFormatConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nullValueFormatConfiguration = self.nullValueFormatConfiguration {
            try encodeContainer.encode(nullValueFormatConfiguration, forKey: .nullValueFormatConfiguration)
        }
        if let numericFormatConfiguration = self.numericFormatConfiguration {
            try encodeContainer.encode(numericFormatConfiguration, forKey: .numericFormatConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nullValueFormatConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NullValueFormatConfiguration.self, forKey: .nullValueFormatConfiguration)
        nullValueFormatConfiguration = nullValueFormatConfigurationDecoded
        let numericFormatConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumericFormatConfiguration.self, forKey: .numericFormatConfiguration)
        numericFormatConfiguration = numericFormatConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// Formatting configuration for string fields.
    public struct StringFormatConfiguration: Swift.Equatable {
        /// The options that determine the null value format configuration.
        public var nullValueFormatConfiguration: QuickSightClientTypes.NullValueFormatConfiguration?
        /// The formatting configuration for numeric strings.
        public var numericFormatConfiguration: QuickSightClientTypes.NumericFormatConfiguration?

        public init (
            nullValueFormatConfiguration: QuickSightClientTypes.NullValueFormatConfiguration? = nil,
            numericFormatConfiguration: QuickSightClientTypes.NumericFormatConfiguration? = nil
        )
        {
            self.nullValueFormatConfiguration = nullValueFormatConfiguration
            self.numericFormatConfiguration = numericFormatConfiguration
        }
    }

}

extension QuickSightClientTypes.StringParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for sensitivestring0 in values {
                try valuesContainer.encode(sensitivestring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension QuickSightClientTypes {
    /// A string parameter.
    public struct StringParameter: Swift.Equatable {
        /// A display name for a string parameter.
        /// This member is required.
        public var name: Swift.String?
        /// The values of a string parameter.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension QuickSightClientTypes.StringParameterDeclaration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValues = "DefaultValues"
        case name = "Name"
        case parameterValueType = "ParameterValueType"
        case valueWhenUnset = "ValueWhenUnset"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValues = self.defaultValues {
            try encodeContainer.encode(defaultValues, forKey: .defaultValues)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameterValueType = self.parameterValueType {
            try encodeContainer.encode(parameterValueType.rawValue, forKey: .parameterValueType)
        }
        if let valueWhenUnset = self.valueWhenUnset {
            try encodeContainer.encode(valueWhenUnset, forKey: .valueWhenUnset)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterValueTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ParameterValueType.self, forKey: .parameterValueType)
        parameterValueType = parameterValueTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let defaultValuesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.StringDefaultValues.self, forKey: .defaultValues)
        defaultValues = defaultValuesDecoded
        let valueWhenUnsetDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.StringValueWhenUnsetConfiguration.self, forKey: .valueWhenUnset)
        valueWhenUnset = valueWhenUnsetDecoded
    }
}

extension QuickSightClientTypes {
    /// A parameter declaration for the String data type.
    public struct StringParameterDeclaration: Swift.Equatable {
        /// The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.
        public var defaultValues: QuickSightClientTypes.StringDefaultValues?
        /// The name of the parameter that is being declared.
        /// This member is required.
        public var name: Swift.String?
        /// The value type determines whether the parameter is a single-value or multi-value parameter.
        /// This member is required.
        public var parameterValueType: QuickSightClientTypes.ParameterValueType?
        /// The configuration that defines the default value of a String parameter when a value has not been set.
        public var valueWhenUnset: QuickSightClientTypes.StringValueWhenUnsetConfiguration?

        public init (
            defaultValues: QuickSightClientTypes.StringDefaultValues? = nil,
            name: Swift.String? = nil,
            parameterValueType: QuickSightClientTypes.ParameterValueType? = nil,
            valueWhenUnset: QuickSightClientTypes.StringValueWhenUnsetConfiguration? = nil
        )
        {
            self.defaultValues = defaultValues
            self.name = name
            self.parameterValueType = parameterValueType
            self.valueWhenUnset = valueWhenUnset
        }
    }

}

extension QuickSightClientTypes.StringValueWhenUnsetConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customValue = "CustomValue"
        case valueWhenUnsetOption = "ValueWhenUnsetOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customValue = self.customValue {
            try encodeContainer.encode(customValue, forKey: .customValue)
        }
        if let valueWhenUnsetOption = self.valueWhenUnsetOption {
            try encodeContainer.encode(valueWhenUnsetOption.rawValue, forKey: .valueWhenUnsetOption)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueWhenUnsetOptionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ValueWhenUnsetOption.self, forKey: .valueWhenUnsetOption)
        valueWhenUnsetOption = valueWhenUnsetOptionDecoded
        let customValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customValue)
        customValue = customValueDecoded
    }
}

extension QuickSightClientTypes.StringValueWhenUnsetConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StringValueWhenUnsetConfiguration(valueWhenUnsetOption: \(Swift.String(describing: valueWhenUnsetOption)), customValue: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {
    /// The configuration that defines the default value of a String parameter when a value has not been set.
    public struct StringValueWhenUnsetConfiguration: Swift.Equatable {
        /// A custom value that's used when the value of a parameter isn't set.
        public var customValue: Swift.String?
        /// The built-in options for default values. The value can be one of the following:
        ///
        /// * RECOMMENDED: The recommended value.
        ///
        /// * NULL: The NULL value.
        public var valueWhenUnsetOption: QuickSightClientTypes.ValueWhenUnsetOption?

        public init (
            customValue: Swift.String? = nil,
            valueWhenUnsetOption: QuickSightClientTypes.ValueWhenUnsetOption? = nil
        )
        {
            self.customValue = customValue
            self.valueWhenUnsetOption = valueWhenUnsetOption
        }
    }

}

extension QuickSightClientTypes.SubtotalOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customLabel = "CustomLabel"
        case fieldLevel = "FieldLevel"
        case fieldLevelOptions = "FieldLevelOptions"
        case metricHeaderCellStyle = "MetricHeaderCellStyle"
        case totalCellStyle = "TotalCellStyle"
        case totalsVisibility = "TotalsVisibility"
        case valueCellStyle = "ValueCellStyle"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customLabel = self.customLabel {
            try encodeContainer.encode(customLabel, forKey: .customLabel)
        }
        if let fieldLevel = self.fieldLevel {
            try encodeContainer.encode(fieldLevel.rawValue, forKey: .fieldLevel)
        }
        if let fieldLevelOptions = fieldLevelOptions {
            var fieldLevelOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldLevelOptions)
            for pivottablefieldsubtotaloptions0 in fieldLevelOptions {
                try fieldLevelOptionsContainer.encode(pivottablefieldsubtotaloptions0)
            }
        }
        if let metricHeaderCellStyle = self.metricHeaderCellStyle {
            try encodeContainer.encode(metricHeaderCellStyle, forKey: .metricHeaderCellStyle)
        }
        if let totalCellStyle = self.totalCellStyle {
            try encodeContainer.encode(totalCellStyle, forKey: .totalCellStyle)
        }
        if let totalsVisibility = self.totalsVisibility {
            try encodeContainer.encode(totalsVisibility.rawValue, forKey: .totalsVisibility)
        }
        if let valueCellStyle = self.valueCellStyle {
            try encodeContainer.encode(valueCellStyle, forKey: .valueCellStyle)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalsVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .totalsVisibility)
        totalsVisibility = totalsVisibilityDecoded
        let customLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customLabel)
        customLabel = customLabelDecoded
        let fieldLevelDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PivotTableSubtotalLevel.self, forKey: .fieldLevel)
        fieldLevel = fieldLevelDecoded
        let fieldLevelOptionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.PivotTableFieldSubtotalOptions?].self, forKey: .fieldLevelOptions)
        var fieldLevelOptionsDecoded0:[QuickSightClientTypes.PivotTableFieldSubtotalOptions]? = nil
        if let fieldLevelOptionsContainer = fieldLevelOptionsContainer {
            fieldLevelOptionsDecoded0 = [QuickSightClientTypes.PivotTableFieldSubtotalOptions]()
            for structure0 in fieldLevelOptionsContainer {
                if let structure0 = structure0 {
                    fieldLevelOptionsDecoded0?.append(structure0)
                }
            }
        }
        fieldLevelOptions = fieldLevelOptionsDecoded0
        let totalCellStyleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableCellStyle.self, forKey: .totalCellStyle)
        totalCellStyle = totalCellStyleDecoded
        let valueCellStyleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableCellStyle.self, forKey: .valueCellStyle)
        valueCellStyle = valueCellStyleDecoded
        let metricHeaderCellStyleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableCellStyle.self, forKey: .metricHeaderCellStyle)
        metricHeaderCellStyle = metricHeaderCellStyleDecoded
    }
}

extension QuickSightClientTypes {
    /// The subtotal options.
    public struct SubtotalOptions: Swift.Equatable {
        /// The custom label string for the subtotal cells.
        public var customLabel: Swift.String?
        /// The field level (all, custom, last) for the subtotal cells.
        public var fieldLevel: QuickSightClientTypes.PivotTableSubtotalLevel?
        /// The optional configuration of subtotal cells.
        public var fieldLevelOptions: [QuickSightClientTypes.PivotTableFieldSubtotalOptions]?
        /// The cell styling options for the subtotals of header cells.
        public var metricHeaderCellStyle: QuickSightClientTypes.TableCellStyle?
        /// The cell styling options for the subtotal cells.
        public var totalCellStyle: QuickSightClientTypes.TableCellStyle?
        /// The visibility configuration for the subtotal cells.
        public var totalsVisibility: QuickSightClientTypes.Visibility?
        /// The cell styling options for the subtotals of value cells.
        public var valueCellStyle: QuickSightClientTypes.TableCellStyle?

        public init (
            customLabel: Swift.String? = nil,
            fieldLevel: QuickSightClientTypes.PivotTableSubtotalLevel? = nil,
            fieldLevelOptions: [QuickSightClientTypes.PivotTableFieldSubtotalOptions]? = nil,
            metricHeaderCellStyle: QuickSightClientTypes.TableCellStyle? = nil,
            totalCellStyle: QuickSightClientTypes.TableCellStyle? = nil,
            totalsVisibility: QuickSightClientTypes.Visibility? = nil,
            valueCellStyle: QuickSightClientTypes.TableCellStyle? = nil
        )
        {
            self.customLabel = customLabel
            self.fieldLevel = fieldLevel
            self.fieldLevelOptions = fieldLevelOptions
            self.metricHeaderCellStyle = metricHeaderCellStyle
            self.totalCellStyle = totalCellStyle
            self.totalsVisibility = totalsVisibility
            self.valueCellStyle = valueCellStyle
        }
    }

}

extension QuickSightClientTypes.TableAggregatedFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupBy = "GroupBy"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupBy = groupBy {
            var groupByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupBy)
            for dimensionfield0 in groupBy {
                try groupByContainer.encode(dimensionfield0)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for measurefield0 in values {
                try valuesContainer.encode(measurefield0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupByContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .groupBy)
        var groupByDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let groupByContainer = groupByContainer {
            groupByDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in groupByContainer {
                if let structure0 = structure0 {
                    groupByDecoded0?.append(structure0)
                }
            }
        }
        groupBy = groupByDecoded0
        let valuesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .values)
        var valuesDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension QuickSightClientTypes {
    /// The aggregated field well for the table.
    public struct TableAggregatedFieldWells: Swift.Equatable {
        /// The group by field well for a pivot table. Values are grouped by group by fields.
        public var groupBy: [QuickSightClientTypes.DimensionField]?
        /// The values field well for a pivot table. Values are aggregated based on group by fields.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init (
            groupBy: [QuickSightClientTypes.DimensionField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.groupBy = groupBy
            self.values = values
        }
    }

}

extension QuickSightClientTypes.TableBorderOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case color = "Color"
        case style = "Style"
        case thickness = "Thickness"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let color = self.color {
            try encodeContainer.encode(color, forKey: .color)
        }
        if let style = self.style {
            try encodeContainer.encode(style.rawValue, forKey: .style)
        }
        if let thickness = self.thickness {
            try encodeContainer.encode(thickness, forKey: .thickness)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let colorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .color)
        color = colorDecoded
        let thicknessDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .thickness)
        thickness = thicknessDecoded
        let styleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableBorderStyle.self, forKey: .style)
        style = styleDecoded
    }
}

extension QuickSightClientTypes {
    /// The border options for a table border.
    public struct TableBorderOptions: Swift.Equatable {
        /// The color of a table border.
        public var color: Swift.String?
        /// The style (none, solid) of a table border.
        public var style: QuickSightClientTypes.TableBorderStyle?
        /// The thickness of a table border.
        public var thickness: Swift.Int?

        public init (
            color: Swift.String? = nil,
            style: QuickSightClientTypes.TableBorderStyle? = nil,
            thickness: Swift.Int? = nil
        )
        {
            self.color = color
            self.style = style
            self.thickness = thickness
        }
    }

}

extension QuickSightClientTypes {
    public enum TableBorderStyle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case solid
        case sdkUnknown(Swift.String)

        public static var allCases: [TableBorderStyle] {
            return [
                .none,
                .solid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .solid: return "SOLID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TableBorderStyle(rawValue: rawValue) ?? TableBorderStyle.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.TableCellConditionalFormatting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldId = "FieldId"
        case textFormat = "TextFormat"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
        if let textFormat = self.textFormat {
            try encodeContainer.encode(textFormat, forKey: .textFormat)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let textFormatDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TextConditionalFormat.self, forKey: .textFormat)
        textFormat = textFormatDecoded
    }
}

extension QuickSightClientTypes {
    /// The cell conditional formatting option for a table.
    public struct TableCellConditionalFormatting: Swift.Equatable {
        /// The field ID of the cell for conditional formatting.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The text format of the cell for conditional formatting.
        public var textFormat: QuickSightClientTypes.TextConditionalFormat?

        public init (
            fieldId: Swift.String? = nil,
            textFormat: QuickSightClientTypes.TextConditionalFormat? = nil
        )
        {
            self.fieldId = fieldId
            self.textFormat = textFormat
        }
    }

}

extension QuickSightClientTypes {
    public enum TableCellImageScalingConfiguration: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case doNotScale
        case fitToCellHeight
        case fitToCellWidth
        case sdkUnknown(Swift.String)

        public static var allCases: [TableCellImageScalingConfiguration] {
            return [
                .doNotScale,
                .fitToCellHeight,
                .fitToCellWidth,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .doNotScale: return "DO_NOT_SCALE"
            case .fitToCellHeight: return "FIT_TO_CELL_HEIGHT"
            case .fitToCellWidth: return "FIT_TO_CELL_WIDTH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TableCellImageScalingConfiguration(rawValue: rawValue) ?? TableCellImageScalingConfiguration.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.TableCellImageSizingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tableCellImageScalingConfiguration = "TableCellImageScalingConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tableCellImageScalingConfiguration = self.tableCellImageScalingConfiguration {
            try encodeContainer.encode(tableCellImageScalingConfiguration.rawValue, forKey: .tableCellImageScalingConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableCellImageScalingConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableCellImageScalingConfiguration.self, forKey: .tableCellImageScalingConfiguration)
        tableCellImageScalingConfiguration = tableCellImageScalingConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The sizing options for the table image configuration.
    public struct TableCellImageSizingConfiguration: Swift.Equatable {
        /// The cell scaling configuration of the sizing options for the table image configuration.
        public var tableCellImageScalingConfiguration: QuickSightClientTypes.TableCellImageScalingConfiguration?

        public init (
            tableCellImageScalingConfiguration: QuickSightClientTypes.TableCellImageScalingConfiguration? = nil
        )
        {
            self.tableCellImageScalingConfiguration = tableCellImageScalingConfiguration
        }
    }

}

extension QuickSightClientTypes.TableCellStyle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backgroundColor = "BackgroundColor"
        case border = "Border"
        case fontConfiguration = "FontConfiguration"
        case height = "Height"
        case horizontalTextAlignment = "HorizontalTextAlignment"
        case textWrap = "TextWrap"
        case verticalTextAlignment = "VerticalTextAlignment"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backgroundColor = self.backgroundColor {
            try encodeContainer.encode(backgroundColor, forKey: .backgroundColor)
        }
        if let border = self.border {
            try encodeContainer.encode(border, forKey: .border)
        }
        if let fontConfiguration = self.fontConfiguration {
            try encodeContainer.encode(fontConfiguration, forKey: .fontConfiguration)
        }
        if let height = self.height {
            try encodeContainer.encode(height, forKey: .height)
        }
        if let horizontalTextAlignment = self.horizontalTextAlignment {
            try encodeContainer.encode(horizontalTextAlignment.rawValue, forKey: .horizontalTextAlignment)
        }
        if let textWrap = self.textWrap {
            try encodeContainer.encode(textWrap.rawValue, forKey: .textWrap)
        }
        if let verticalTextAlignment = self.verticalTextAlignment {
            try encodeContainer.encode(verticalTextAlignment.rawValue, forKey: .verticalTextAlignment)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
        let fontConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FontConfiguration.self, forKey: .fontConfiguration)
        fontConfiguration = fontConfigurationDecoded
        let textWrapDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TextWrap.self, forKey: .textWrap)
        textWrap = textWrapDecoded
        let horizontalTextAlignmentDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.HorizontalTextAlignment.self, forKey: .horizontalTextAlignment)
        horizontalTextAlignment = horizontalTextAlignmentDecoded
        let verticalTextAlignmentDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VerticalTextAlignment.self, forKey: .verticalTextAlignment)
        verticalTextAlignment = verticalTextAlignmentDecoded
        let backgroundColorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backgroundColor)
        backgroundColor = backgroundColorDecoded
        let heightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .height)
        height = heightDecoded
        let borderDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GlobalTableBorderOptions.self, forKey: .border)
        border = borderDecoded
    }
}

extension QuickSightClientTypes {
    /// The table cell style for a cell in pivot table or table visual.
    public struct TableCellStyle: Swift.Equatable {
        /// The background color for the table cells.
        public var backgroundColor: Swift.String?
        /// The borders for the table cells.
        public var border: QuickSightClientTypes.GlobalTableBorderOptions?
        /// The font configuration of the table cells.
        public var fontConfiguration: QuickSightClientTypes.FontConfiguration?
        /// The height color for the table cells.
        public var height: Swift.Int?
        /// The horizontal text alignment (left, center, right, auto) for the table cells.
        public var horizontalTextAlignment: QuickSightClientTypes.HorizontalTextAlignment?
        /// The text wrap (none, wrap) for the table cells.
        public var textWrap: QuickSightClientTypes.TextWrap?
        /// The vertical text alignment (top, middle, bottom) for the table cells.
        public var verticalTextAlignment: QuickSightClientTypes.VerticalTextAlignment?
        /// The visibility of the table cells.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            backgroundColor: Swift.String? = nil,
            border: QuickSightClientTypes.GlobalTableBorderOptions? = nil,
            fontConfiguration: QuickSightClientTypes.FontConfiguration? = nil,
            height: Swift.Int? = nil,
            horizontalTextAlignment: QuickSightClientTypes.HorizontalTextAlignment? = nil,
            textWrap: QuickSightClientTypes.TextWrap? = nil,
            verticalTextAlignment: QuickSightClientTypes.VerticalTextAlignment? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.backgroundColor = backgroundColor
            self.border = border
            self.fontConfiguration = fontConfiguration
            self.height = height
            self.horizontalTextAlignment = horizontalTextAlignment
            self.textWrap = textWrap
            self.verticalTextAlignment = verticalTextAlignment
            self.visibility = visibility
        }
    }

}

extension QuickSightClientTypes.TableConditionalFormatting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conditionalFormattingOptions = "ConditionalFormattingOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conditionalFormattingOptions = conditionalFormattingOptions {
            var conditionalFormattingOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conditionalFormattingOptions)
            for tableconditionalformattingoption0 in conditionalFormattingOptions {
                try conditionalFormattingOptionsContainer.encode(tableconditionalformattingoption0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionalFormattingOptionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.TableConditionalFormattingOption?].self, forKey: .conditionalFormattingOptions)
        var conditionalFormattingOptionsDecoded0:[QuickSightClientTypes.TableConditionalFormattingOption]? = nil
        if let conditionalFormattingOptionsContainer = conditionalFormattingOptionsContainer {
            conditionalFormattingOptionsDecoded0 = [QuickSightClientTypes.TableConditionalFormattingOption]()
            for structure0 in conditionalFormattingOptionsContainer {
                if let structure0 = structure0 {
                    conditionalFormattingOptionsDecoded0?.append(structure0)
                }
            }
        }
        conditionalFormattingOptions = conditionalFormattingOptionsDecoded0
    }
}

extension QuickSightClientTypes {
    /// The conditional formatting for a PivotTableVisual.
    public struct TableConditionalFormatting: Swift.Equatable {
        /// Conditional formatting options for a PivotTableVisual.
        public var conditionalFormattingOptions: [QuickSightClientTypes.TableConditionalFormattingOption]?

        public init (
            conditionalFormattingOptions: [QuickSightClientTypes.TableConditionalFormattingOption]? = nil
        )
        {
            self.conditionalFormattingOptions = conditionalFormattingOptions
        }
    }

}

extension QuickSightClientTypes.TableConditionalFormattingOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cell = "Cell"
        case row = "Row"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cell = self.cell {
            try encodeContainer.encode(cell, forKey: .cell)
        }
        if let row = self.row {
            try encodeContainer.encode(row, forKey: .row)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableCellConditionalFormatting.self, forKey: .cell)
        cell = cellDecoded
        let rowDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableRowConditionalFormatting.self, forKey: .row)
        row = rowDecoded
    }
}

extension QuickSightClientTypes {
    /// Conditional formatting options for a PivotTableVisual.
    public struct TableConditionalFormattingOption: Swift.Equatable {
        /// The cell conditional formatting option for a table.
        public var cell: QuickSightClientTypes.TableCellConditionalFormatting?
        /// The row conditional formatting option for a table.
        public var row: QuickSightClientTypes.TableRowConditionalFormatting?

        public init (
            cell: QuickSightClientTypes.TableCellConditionalFormatting? = nil,
            row: QuickSightClientTypes.TableRowConditionalFormatting? = nil
        )
        {
            self.cell = cell
            self.row = row
        }
    }

}

extension QuickSightClientTypes.TableConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldOptions = "FieldOptions"
        case fieldWells = "FieldWells"
        case paginatedReportOptions = "PaginatedReportOptions"
        case sortConfiguration = "SortConfiguration"
        case tableOptions = "TableOptions"
        case totalOptions = "TotalOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldOptions = self.fieldOptions {
            try encodeContainer.encode(fieldOptions, forKey: .fieldOptions)
        }
        if let fieldWells = self.fieldWells {
            try encodeContainer.encode(fieldWells, forKey: .fieldWells)
        }
        if let paginatedReportOptions = self.paginatedReportOptions {
            try encodeContainer.encode(paginatedReportOptions, forKey: .paginatedReportOptions)
        }
        if let sortConfiguration = self.sortConfiguration {
            try encodeContainer.encode(sortConfiguration, forKey: .sortConfiguration)
        }
        if let tableOptions = self.tableOptions {
            try encodeContainer.encode(tableOptions, forKey: .tableOptions)
        }
        if let totalOptions = self.totalOptions {
            try encodeContainer.encode(totalOptions, forKey: .totalOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableFieldWells.self, forKey: .fieldWells)
        fieldWells = fieldWellsDecoded
        let sortConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableSortConfiguration.self, forKey: .sortConfiguration)
        sortConfiguration = sortConfigurationDecoded
        let tableOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableOptions.self, forKey: .tableOptions)
        tableOptions = tableOptionsDecoded
        let totalOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TotalOptions.self, forKey: .totalOptions)
        totalOptions = totalOptionsDecoded
        let fieldOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableFieldOptions.self, forKey: .fieldOptions)
        fieldOptions = fieldOptionsDecoded
        let paginatedReportOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TablePaginatedReportOptions.self, forKey: .paginatedReportOptions)
        paginatedReportOptions = paginatedReportOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration for a TableVisual.
    public struct TableConfiguration: Swift.Equatable {
        /// The field options for a table visual.
        public var fieldOptions: QuickSightClientTypes.TableFieldOptions?
        /// The field wells of the visual.
        public var fieldWells: QuickSightClientTypes.TableFieldWells?
        /// The paginated report options for a table visual.
        public var paginatedReportOptions: QuickSightClientTypes.TablePaginatedReportOptions?
        /// The sort configuration for a TableVisual.
        public var sortConfiguration: QuickSightClientTypes.TableSortConfiguration?
        /// The table options for a table visual.
        public var tableOptions: QuickSightClientTypes.TableOptions?
        /// The total options for a table visual.
        public var totalOptions: QuickSightClientTypes.TotalOptions?

        public init (
            fieldOptions: QuickSightClientTypes.TableFieldOptions? = nil,
            fieldWells: QuickSightClientTypes.TableFieldWells? = nil,
            paginatedReportOptions: QuickSightClientTypes.TablePaginatedReportOptions? = nil,
            sortConfiguration: QuickSightClientTypes.TableSortConfiguration? = nil,
            tableOptions: QuickSightClientTypes.TableOptions? = nil,
            totalOptions: QuickSightClientTypes.TotalOptions? = nil
        )
        {
            self.fieldOptions = fieldOptions
            self.fieldWells = fieldWells
            self.paginatedReportOptions = paginatedReportOptions
            self.sortConfiguration = sortConfiguration
            self.tableOptions = tableOptions
            self.totalOptions = totalOptions
        }
    }

}

extension QuickSightClientTypes.TableFieldCustomIconContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case icon = "Icon"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let icon = self.icon {
            try encodeContainer.encode(icon.rawValue, forKey: .icon)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iconDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableFieldIconSetType.self, forKey: .icon)
        icon = iconDecoded
    }
}

extension QuickSightClientTypes {
    /// The custom icon content for the table link content configuration.
    public struct TableFieldCustomIconContent: Swift.Equatable {
        /// The icon set type (link) of the custom icon content for table URL link content.
        public var icon: QuickSightClientTypes.TableFieldIconSetType?

        public init (
            icon: QuickSightClientTypes.TableFieldIconSetType? = nil
        )
        {
            self.icon = icon
        }
    }

}

extension QuickSightClientTypes.TableFieldCustomTextContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fontConfiguration = "FontConfiguration"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fontConfiguration = self.fontConfiguration {
            try encodeContainer.encode(fontConfiguration, forKey: .fontConfiguration)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let fontConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FontConfiguration.self, forKey: .fontConfiguration)
        fontConfiguration = fontConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The custom text content (value, font configuration) for the table link content configuration.
    public struct TableFieldCustomTextContent: Swift.Equatable {
        /// The font configuration of the custom text content for the table URL link content.
        /// This member is required.
        public var fontConfiguration: QuickSightClientTypes.FontConfiguration?
        /// The string value of the custom text content for the table URL link content.
        public var value: Swift.String?

        public init (
            fontConfiguration: QuickSightClientTypes.FontConfiguration? = nil,
            value: Swift.String? = nil
        )
        {
            self.fontConfiguration = fontConfiguration
            self.value = value
        }
    }

}

extension QuickSightClientTypes {
    public enum TableFieldIconSetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case link
        case sdkUnknown(Swift.String)

        public static var allCases: [TableFieldIconSetType] {
            return [
                .link,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .link: return "LINK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TableFieldIconSetType(rawValue: rawValue) ?? TableFieldIconSetType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.TableFieldImageConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sizingOptions = "SizingOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sizingOptions = self.sizingOptions {
            try encodeContainer.encode(sizingOptions, forKey: .sizingOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizingOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableCellImageSizingConfiguration.self, forKey: .sizingOptions)
        sizingOptions = sizingOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// The image configuration of a table field URL.
    public struct TableFieldImageConfiguration: Swift.Equatable {
        /// The sizing options for the table image configuration.
        public var sizingOptions: QuickSightClientTypes.TableCellImageSizingConfiguration?

        public init (
            sizingOptions: QuickSightClientTypes.TableCellImageSizingConfiguration? = nil
        )
        {
            self.sizingOptions = sizingOptions
        }
    }

}

extension QuickSightClientTypes.TableFieldLinkConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case target = "Target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let target = self.target {
            try encodeContainer.encode(target.rawValue, forKey: .target)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.URLTargetConfiguration.self, forKey: .target)
        target = targetDecoded
        let contentDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableFieldLinkContentConfiguration.self, forKey: .content)
        content = contentDecoded
    }
}

extension QuickSightClientTypes {
    /// The link configuration of a table field URL.
    public struct TableFieldLinkConfiguration: Swift.Equatable {
        /// The URL content (text, icon) for the table link configuration.
        /// This member is required.
        public var content: QuickSightClientTypes.TableFieldLinkContentConfiguration?
        /// The URL target (new tab, new window, same tab) for the table link configuration.
        /// This member is required.
        public var target: QuickSightClientTypes.URLTargetConfiguration?

        public init (
            content: QuickSightClientTypes.TableFieldLinkContentConfiguration? = nil,
            target: QuickSightClientTypes.URLTargetConfiguration? = nil
        )
        {
            self.content = content
            self.target = target
        }
    }

}

extension QuickSightClientTypes.TableFieldLinkContentConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customIconContent = "CustomIconContent"
        case customTextContent = "CustomTextContent"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customIconContent = self.customIconContent {
            try encodeContainer.encode(customIconContent, forKey: .customIconContent)
        }
        if let customTextContent = self.customTextContent {
            try encodeContainer.encode(customTextContent, forKey: .customTextContent)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customTextContentDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableFieldCustomTextContent.self, forKey: .customTextContent)
        customTextContent = customTextContentDecoded
        let customIconContentDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableFieldCustomIconContent.self, forKey: .customIconContent)
        customIconContent = customIconContentDecoded
    }
}

extension QuickSightClientTypes {
    /// The URL content (text, icon) for the table link configuration.
    public struct TableFieldLinkContentConfiguration: Swift.Equatable {
        /// The custom icon content for the table link content configuration.
        public var customIconContent: QuickSightClientTypes.TableFieldCustomIconContent?
        /// The custom text content (value, font configuration) for the table link content configuration.
        public var customTextContent: QuickSightClientTypes.TableFieldCustomTextContent?

        public init (
            customIconContent: QuickSightClientTypes.TableFieldCustomIconContent? = nil,
            customTextContent: QuickSightClientTypes.TableFieldCustomTextContent? = nil
        )
        {
            self.customIconContent = customIconContent
            self.customTextContent = customTextContent
        }
    }

}

extension QuickSightClientTypes.TableFieldOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customLabel = "CustomLabel"
        case fieldId = "FieldId"
        case urlStyling = "URLStyling"
        case visibility = "Visibility"
        case width = "Width"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customLabel = self.customLabel {
            try encodeContainer.encode(customLabel, forKey: .customLabel)
        }
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
        if let urlStyling = self.urlStyling {
            try encodeContainer.encode(urlStyling, forKey: .urlStyling)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
        if let width = self.width {
            try encodeContainer.encode(width, forKey: .width)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let widthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .width)
        width = widthDecoded
        let customLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customLabel)
        customLabel = customLabelDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
        let urlStylingDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableFieldURLConfiguration.self, forKey: .urlStyling)
        urlStyling = urlStylingDecoded
    }
}

extension QuickSightClientTypes {
    /// The options for a table field.
    public struct TableFieldOption: Swift.Equatable {
        /// The custom label for a table field.
        public var customLabel: Swift.String?
        /// The field ID for a table field.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The URL configuration for a table field.
        public var urlStyling: QuickSightClientTypes.TableFieldURLConfiguration?
        /// The visibility of a table field.
        public var visibility: QuickSightClientTypes.Visibility?
        /// The width for a table field.
        public var width: Swift.String?

        public init (
            customLabel: Swift.String? = nil,
            fieldId: Swift.String? = nil,
            urlStyling: QuickSightClientTypes.TableFieldURLConfiguration? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil,
            width: Swift.String? = nil
        )
        {
            self.customLabel = customLabel
            self.fieldId = fieldId
            self.urlStyling = urlStyling
            self.visibility = visibility
            self.width = width
        }
    }

}

extension QuickSightClientTypes.TableFieldOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case order = "Order"
        case selectedFieldOptions = "SelectedFieldOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let order = order {
            var orderContainer = encodeContainer.nestedUnkeyedContainer(forKey: .order)
            for fieldid0 in order {
                try orderContainer.encode(fieldid0)
            }
        }
        if let selectedFieldOptions = selectedFieldOptions {
            var selectedFieldOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedFieldOptions)
            for tablefieldoption0 in selectedFieldOptions {
                try selectedFieldOptionsContainer.encode(tablefieldoption0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectedFieldOptionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.TableFieldOption?].self, forKey: .selectedFieldOptions)
        var selectedFieldOptionsDecoded0:[QuickSightClientTypes.TableFieldOption]? = nil
        if let selectedFieldOptionsContainer = selectedFieldOptionsContainer {
            selectedFieldOptionsDecoded0 = [QuickSightClientTypes.TableFieldOption]()
            for structure0 in selectedFieldOptionsContainer {
                if let structure0 = structure0 {
                    selectedFieldOptionsDecoded0?.append(structure0)
                }
            }
        }
        selectedFieldOptions = selectedFieldOptionsDecoded0
        let orderContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .order)
        var orderDecoded0:[Swift.String]? = nil
        if let orderContainer = orderContainer {
            orderDecoded0 = [Swift.String]()
            for string0 in orderContainer {
                if let string0 = string0 {
                    orderDecoded0?.append(string0)
                }
            }
        }
        order = orderDecoded0
    }
}

extension QuickSightClientTypes {
    /// The field options for a table visual.
    public struct TableFieldOptions: Swift.Equatable {
        /// The order of field IDs of the field options for a table visual.
        public var order: [Swift.String]?
        /// The selected field options for the table field options.
        public var selectedFieldOptions: [QuickSightClientTypes.TableFieldOption]?

        public init (
            order: [Swift.String]? = nil,
            selectedFieldOptions: [QuickSightClientTypes.TableFieldOption]? = nil
        )
        {
            self.order = order
            self.selectedFieldOptions = selectedFieldOptions
        }
    }

}

extension QuickSightClientTypes.TableFieldURLConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageConfiguration = "ImageConfiguration"
        case linkConfiguration = "LinkConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageConfiguration = self.imageConfiguration {
            try encodeContainer.encode(imageConfiguration, forKey: .imageConfiguration)
        }
        if let linkConfiguration = self.linkConfiguration {
            try encodeContainer.encode(linkConfiguration, forKey: .linkConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableFieldLinkConfiguration.self, forKey: .linkConfiguration)
        linkConfiguration = linkConfigurationDecoded
        let imageConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableFieldImageConfiguration.self, forKey: .imageConfiguration)
        imageConfiguration = imageConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The URL configuration for a table field.
    public struct TableFieldURLConfiguration: Swift.Equatable {
        /// The image configuration of a table field URL.
        public var imageConfiguration: QuickSightClientTypes.TableFieldImageConfiguration?
        /// The link configuration of a table field URL.
        public var linkConfiguration: QuickSightClientTypes.TableFieldLinkConfiguration?

        public init (
            imageConfiguration: QuickSightClientTypes.TableFieldImageConfiguration? = nil,
            linkConfiguration: QuickSightClientTypes.TableFieldLinkConfiguration? = nil
        )
        {
            self.imageConfiguration = imageConfiguration
            self.linkConfiguration = linkConfiguration
        }
    }

}

extension QuickSightClientTypes.TableFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tableAggregatedFieldWells = "TableAggregatedFieldWells"
        case tableUnaggregatedFieldWells = "TableUnaggregatedFieldWells"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tableAggregatedFieldWells = self.tableAggregatedFieldWells {
            try encodeContainer.encode(tableAggregatedFieldWells, forKey: .tableAggregatedFieldWells)
        }
        if let tableUnaggregatedFieldWells = self.tableUnaggregatedFieldWells {
            try encodeContainer.encode(tableUnaggregatedFieldWells, forKey: .tableUnaggregatedFieldWells)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableAggregatedFieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableAggregatedFieldWells.self, forKey: .tableAggregatedFieldWells)
        tableAggregatedFieldWells = tableAggregatedFieldWellsDecoded
        let tableUnaggregatedFieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableUnaggregatedFieldWells.self, forKey: .tableUnaggregatedFieldWells)
        tableUnaggregatedFieldWells = tableUnaggregatedFieldWellsDecoded
    }
}

extension QuickSightClientTypes {
    /// The field wells for a table visual. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct TableFieldWells: Swift.Equatable {
        /// The aggregated field well for the table.
        public var tableAggregatedFieldWells: QuickSightClientTypes.TableAggregatedFieldWells?
        /// The unaggregated field well for the table.
        public var tableUnaggregatedFieldWells: QuickSightClientTypes.TableUnaggregatedFieldWells?

        public init (
            tableAggregatedFieldWells: QuickSightClientTypes.TableAggregatedFieldWells? = nil,
            tableUnaggregatedFieldWells: QuickSightClientTypes.TableUnaggregatedFieldWells? = nil
        )
        {
            self.tableAggregatedFieldWells = tableAggregatedFieldWells
            self.tableUnaggregatedFieldWells = tableUnaggregatedFieldWells
        }
    }

}

extension QuickSightClientTypes.TableOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellStyle = "CellStyle"
        case headerStyle = "HeaderStyle"
        case orientation = "Orientation"
        case rowAlternateColorOptions = "RowAlternateColorOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cellStyle = self.cellStyle {
            try encodeContainer.encode(cellStyle, forKey: .cellStyle)
        }
        if let headerStyle = self.headerStyle {
            try encodeContainer.encode(headerStyle, forKey: .headerStyle)
        }
        if let orientation = self.orientation {
            try encodeContainer.encode(orientation.rawValue, forKey: .orientation)
        }
        if let rowAlternateColorOptions = self.rowAlternateColorOptions {
            try encodeContainer.encode(rowAlternateColorOptions, forKey: .rowAlternateColorOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orientationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableOrientation.self, forKey: .orientation)
        orientation = orientationDecoded
        let headerStyleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableCellStyle.self, forKey: .headerStyle)
        headerStyle = headerStyleDecoded
        let cellStyleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableCellStyle.self, forKey: .cellStyle)
        cellStyle = cellStyleDecoded
        let rowAlternateColorOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RowAlternateColorOptions.self, forKey: .rowAlternateColorOptions)
        rowAlternateColorOptions = rowAlternateColorOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// The table options for a table visual.
    public struct TableOptions: Swift.Equatable {
        /// The table cell style of table cells.
        public var cellStyle: QuickSightClientTypes.TableCellStyle?
        /// The table cell style of a table header.
        public var headerStyle: QuickSightClientTypes.TableCellStyle?
        /// The orientation (vertical, horizontal) for a table.
        public var orientation: QuickSightClientTypes.TableOrientation?
        /// The row alternate color options (widget status, row alternate colors) for a table.
        public var rowAlternateColorOptions: QuickSightClientTypes.RowAlternateColorOptions?

        public init (
            cellStyle: QuickSightClientTypes.TableCellStyle? = nil,
            headerStyle: QuickSightClientTypes.TableCellStyle? = nil,
            orientation: QuickSightClientTypes.TableOrientation? = nil,
            rowAlternateColorOptions: QuickSightClientTypes.RowAlternateColorOptions? = nil
        )
        {
            self.cellStyle = cellStyle
            self.headerStyle = headerStyle
            self.orientation = orientation
            self.rowAlternateColorOptions = rowAlternateColorOptions
        }
    }

}

extension QuickSightClientTypes {
    public enum TableOrientation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case horizontal
        case vertical
        case sdkUnknown(Swift.String)

        public static var allCases: [TableOrientation] {
            return [
                .horizontal,
                .vertical,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .horizontal: return "HORIZONTAL"
            case .vertical: return "VERTICAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TableOrientation(rawValue: rawValue) ?? TableOrientation.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.TablePaginatedReportOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overflowColumnHeaderVisibility = "OverflowColumnHeaderVisibility"
        case verticalOverflowVisibility = "VerticalOverflowVisibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let overflowColumnHeaderVisibility = self.overflowColumnHeaderVisibility {
            try encodeContainer.encode(overflowColumnHeaderVisibility.rawValue, forKey: .overflowColumnHeaderVisibility)
        }
        if let verticalOverflowVisibility = self.verticalOverflowVisibility {
            try encodeContainer.encode(verticalOverflowVisibility.rawValue, forKey: .verticalOverflowVisibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let verticalOverflowVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .verticalOverflowVisibility)
        verticalOverflowVisibility = verticalOverflowVisibilityDecoded
        let overflowColumnHeaderVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .overflowColumnHeaderVisibility)
        overflowColumnHeaderVisibility = overflowColumnHeaderVisibilityDecoded
    }
}

extension QuickSightClientTypes {
    /// The paginated report options for a table visual.
    public struct TablePaginatedReportOptions: Swift.Equatable {
        /// The visibility of repeating header rows on each page.
        public var overflowColumnHeaderVisibility: QuickSightClientTypes.Visibility?
        /// The visibility of printing table overflow across pages.
        public var verticalOverflowVisibility: QuickSightClientTypes.Visibility?

        public init (
            overflowColumnHeaderVisibility: QuickSightClientTypes.Visibility? = nil,
            verticalOverflowVisibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.overflowColumnHeaderVisibility = overflowColumnHeaderVisibility
            self.verticalOverflowVisibility = verticalOverflowVisibility
        }
    }

}

extension QuickSightClientTypes.TableRowConditionalFormatting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backgroundColor = "BackgroundColor"
        case textColor = "TextColor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backgroundColor = self.backgroundColor {
            try encodeContainer.encode(backgroundColor, forKey: .backgroundColor)
        }
        if let textColor = self.textColor {
            try encodeContainer.encode(textColor, forKey: .textColor)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backgroundColorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ConditionalFormattingColor.self, forKey: .backgroundColor)
        backgroundColor = backgroundColorDecoded
        let textColorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ConditionalFormattingColor.self, forKey: .textColor)
        textColor = textColorDecoded
    }
}

extension QuickSightClientTypes {
    /// The conditional formatting of a table row.
    public struct TableRowConditionalFormatting: Swift.Equatable {
        /// The conditional formatting color (solid, gradient) of the background for a table row.
        public var backgroundColor: QuickSightClientTypes.ConditionalFormattingColor?
        /// The conditional formatting color (solid, gradient) of the text for a table row.
        public var textColor: QuickSightClientTypes.ConditionalFormattingColor?

        public init (
            backgroundColor: QuickSightClientTypes.ConditionalFormattingColor? = nil,
            textColor: QuickSightClientTypes.ConditionalFormattingColor? = nil
        )
        {
            self.backgroundColor = backgroundColor
            self.textColor = textColor
        }
    }

}

extension QuickSightClientTypes.TableSideBorderOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bottom = "Bottom"
        case innerHorizontal = "InnerHorizontal"
        case innerVertical = "InnerVertical"
        case `left` = "Left"
        case `right` = "Right"
        case top = "Top"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bottom = self.bottom {
            try encodeContainer.encode(bottom, forKey: .bottom)
        }
        if let innerHorizontal = self.innerHorizontal {
            try encodeContainer.encode(innerHorizontal, forKey: .innerHorizontal)
        }
        if let innerVertical = self.innerVertical {
            try encodeContainer.encode(innerVertical, forKey: .innerVertical)
        }
        if let `left` = self.`left` {
            try encodeContainer.encode(`left`, forKey: .`left`)
        }
        if let `right` = self.`right` {
            try encodeContainer.encode(`right`, forKey: .`right`)
        }
        if let top = self.top {
            try encodeContainer.encode(top, forKey: .top)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let innerVerticalDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableBorderOptions.self, forKey: .innerVertical)
        innerVertical = innerVerticalDecoded
        let innerHorizontalDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableBorderOptions.self, forKey: .innerHorizontal)
        innerHorizontal = innerHorizontalDecoded
        let leftDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableBorderOptions.self, forKey: .left)
        `left` = leftDecoded
        let rightDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableBorderOptions.self, forKey: .right)
        `right` = rightDecoded
        let topDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableBorderOptions.self, forKey: .top)
        top = topDecoded
        let bottomDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableBorderOptions.self, forKey: .bottom)
        bottom = bottomDecoded
    }
}

extension QuickSightClientTypes {
    /// The side border options for a table.
    public struct TableSideBorderOptions: Swift.Equatable {
        /// The table border options of the bottom border.
        public var bottom: QuickSightClientTypes.TableBorderOptions?
        /// The table border options of the inner horizontal border.
        public var innerHorizontal: QuickSightClientTypes.TableBorderOptions?
        /// The table border options of the inner vertical border.
        public var innerVertical: QuickSightClientTypes.TableBorderOptions?
        /// The table border options of the left border.
        public var `left`: QuickSightClientTypes.TableBorderOptions?
        /// The table border options of the right border.
        public var `right`: QuickSightClientTypes.TableBorderOptions?
        /// The table border options of the top border.
        public var top: QuickSightClientTypes.TableBorderOptions?

        public init (
            bottom: QuickSightClientTypes.TableBorderOptions? = nil,
            innerHorizontal: QuickSightClientTypes.TableBorderOptions? = nil,
            innerVertical: QuickSightClientTypes.TableBorderOptions? = nil,
            `left`: QuickSightClientTypes.TableBorderOptions? = nil,
            `right`: QuickSightClientTypes.TableBorderOptions? = nil,
            top: QuickSightClientTypes.TableBorderOptions? = nil
        )
        {
            self.bottom = bottom
            self.innerHorizontal = innerHorizontal
            self.innerVertical = innerVertical
            self.`left` = `left`
            self.`right` = `right`
            self.top = top
        }
    }

}

extension QuickSightClientTypes.TableSortConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case paginationConfiguration = "PaginationConfiguration"
        case rowSort = "RowSort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let paginationConfiguration = self.paginationConfiguration {
            try encodeContainer.encode(paginationConfiguration, forKey: .paginationConfiguration)
        }
        if let rowSort = rowSort {
            var rowSortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rowSort)
            for fieldsortoptions0 in rowSort {
                try rowSortContainer.encode(fieldsortoptions0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowSortContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FieldSortOptions?].self, forKey: .rowSort)
        var rowSortDecoded0:[QuickSightClientTypes.FieldSortOptions]? = nil
        if let rowSortContainer = rowSortContainer {
            rowSortDecoded0 = [QuickSightClientTypes.FieldSortOptions]()
            for structure0 in rowSortContainer {
                if let structure0 = structure0 {
                    rowSortDecoded0?.append(structure0)
                }
            }
        }
        rowSort = rowSortDecoded0
        let paginationConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PaginationConfiguration.self, forKey: .paginationConfiguration)
        paginationConfiguration = paginationConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The sort configuration for a TableVisual.
    public struct TableSortConfiguration: Swift.Equatable {
        /// The pagination configuration (page size, page number) for the table.
        public var paginationConfiguration: QuickSightClientTypes.PaginationConfiguration?
        /// The field sort options for rows in the table.
        public var rowSort: [QuickSightClientTypes.FieldSortOptions]?

        public init (
            paginationConfiguration: QuickSightClientTypes.PaginationConfiguration? = nil,
            rowSort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.paginationConfiguration = paginationConfiguration
            self.rowSort = rowSort
        }
    }

}

extension QuickSightClientTypes {
    public enum TableTotalsPlacement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case end
        case start
        case sdkUnknown(Swift.String)

        public static var allCases: [TableTotalsPlacement] {
            return [
                .end,
                .start,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .end: return "END"
            case .start: return "START"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TableTotalsPlacement(rawValue: rawValue) ?? TableTotalsPlacement.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum TableTotalsScrollStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pinned
        case scrolled
        case sdkUnknown(Swift.String)

        public static var allCases: [TableTotalsScrollStatus] {
            return [
                .pinned,
                .scrolled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pinned: return "PINNED"
            case .scrolled: return "SCROLLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TableTotalsScrollStatus(rawValue: rawValue) ?? TableTotalsScrollStatus.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.TableUnaggregatedFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for unaggregatedfield0 in values {
                try valuesContainer.encode(unaggregatedfield0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.UnaggregatedField?].self, forKey: .values)
        var valuesDecoded0:[QuickSightClientTypes.UnaggregatedField]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [QuickSightClientTypes.UnaggregatedField]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension QuickSightClientTypes {
    /// The unaggregated field well for the table.
    public struct TableUnaggregatedFieldWells: Swift.Equatable {
        /// The values field well for a pivot table. Values are unaggregated for an unaggregated table.
        public var values: [QuickSightClientTypes.UnaggregatedField]?

        public init (
            values: [QuickSightClientTypes.UnaggregatedField]? = nil
        )
        {
            self.values = values
        }
    }

}

extension QuickSightClientTypes.TableVisual: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case chartConfiguration = "ChartConfiguration"
        case conditionalFormatting = "ConditionalFormatting"
        case subtitle = "Subtitle"
        case title = "Title"
        case visualId = "VisualId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for visualcustomaction0 in actions {
                try actionsContainer.encode(visualcustomaction0)
            }
        }
        if let chartConfiguration = self.chartConfiguration {
            try encodeContainer.encode(chartConfiguration, forKey: .chartConfiguration)
        }
        if let conditionalFormatting = self.conditionalFormatting {
            try encodeContainer.encode(conditionalFormatting, forKey: .conditionalFormatting)
        }
        if let subtitle = self.subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let visualId = self.visualId {
            try encodeContainer.encode(visualId, forKey: .visualId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visualIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visualId)
        visualId = visualIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualTitleLabelOptions.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualSubtitleLabelOptions.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let chartConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableConfiguration.self, forKey: .chartConfiguration)
        chartConfiguration = chartConfigurationDecoded
        let conditionalFormattingDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableConditionalFormatting.self, forKey: .conditionalFormatting)
        conditionalFormatting = conditionalFormattingDecoded
        let actionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.VisualCustomAction?].self, forKey: .actions)
        var actionsDecoded0:[QuickSightClientTypes.VisualCustomAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [QuickSightClientTypes.VisualCustomAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A table visual. For more information, see [Using tables as visuals](https://docs.aws.amazon.com/quicksight/latest/user/tabular.html) in the Amazon QuickSight User Guide.
    public struct TableVisual: Swift.Equatable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration settings of the visual.
        public var chartConfiguration: QuickSightClientTypes.TableConfiguration?
        /// The conditional formatting for a PivotTableVisual.
        public var conditionalFormatting: QuickSightClientTypes.TableConditionalFormatting?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        /// This member is required.
        public var visualId: Swift.String?

        public init (
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.TableConfiguration? = nil,
            conditionalFormatting: QuickSightClientTypes.TableConditionalFormatting? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.conditionalFormatting = conditionalFormatting
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }

}

extension QuickSightClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension QuickSightClientTypes {
    /// The key or keys of the key-value pairs for the resource tag or tags assigned to the resource.
    public struct Tag: Swift.Equatable {
        /// Tag key.
        /// This member is required.
        public var key: Swift.String?
        /// Tag value.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension QuickSightClientTypes.TagColumnOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnName = "ColumnName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnName = self.columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for columntag0 in tags {
                try tagsContainer.encode(columntag0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnTag?].self, forKey: .tags)
        var tagsDecoded0:[QuickSightClientTypes.ColumnTag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QuickSightClientTypes.ColumnTag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A transform operation that tags a column with additional information.
    public struct TagColumnOperation: Swift.Equatable {
        /// The column that this operation acts on.
        /// This member is required.
        public var columnName: Swift.String?
        /// The dataset column tag, currently only used for geospatial type tagging. This is not tags for the Amazon Web Services tagging feature.
        /// This member is required.
        public var tags: [QuickSightClientTypes.ColumnTag]?

        public init (
            columnName: Swift.String? = nil,
            tags: [QuickSightClientTypes.ColumnTag]? = nil
        )
        {
            self.columnName = columnName
            self.tags = tags
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/resources/\(resourceArn.urlPercentEncoding())/tags"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.
    /// This member is required.
    public var tags: [QuickSightClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [QuickSightClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[QuickSightClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [QuickSightClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TagResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct TagResourceOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let status: Swift.Int
}

extension TagResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension QuickSightClientTypes {
    public enum TargetVisualOptions: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allVisuals
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetVisualOptions] {
            return [
                .allVisuals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allVisuals: return "ALL_VISUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetVisualOptions(rawValue: rawValue) ?? TargetVisualOptions.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.Template: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case templateId = "TemplateId"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let templateId = self.templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TemplateVersion.self, forKey: .version)
        version = versionDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension QuickSightClientTypes {
    /// A template object. A template is an entity in Amazon QuickSight that encapsulates the metadata required to create an analysis and that you can use to create a dashboard. A template adds a layer of abstraction by using placeholders to replace the dataset associated with an analysis. You can use templates to create dashboards by replacing dataset placeholders with datasets that follow the same schema that was used to create the source analysis and template. You can share templates across Amazon Web Services accounts by allowing users in other Amazon Web Services accounts to create a template or a dashboard from an existing template.
    public struct Template: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the template.
        public var arn: Swift.String?
        /// Time when this was created.
        public var createdTime: ClientRuntime.Date?
        /// Time when this was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The display name of the template.
        public var name: Swift.String?
        /// The ID for the template. This is unique per Amazon Web Services Region for each Amazon Web Services account.
        public var templateId: Swift.String?
        /// A structure describing the versions of the template.
        public var version: QuickSightClientTypes.TemplateVersion?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            templateId: Swift.String? = nil,
            version: QuickSightClientTypes.TemplateVersion? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.templateId = templateId
            self.version = version
        }
    }

}

extension QuickSightClientTypes.TemplateAlias: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasName = "AliasName"
        case arn = "Arn"
        case templateVersionNumber = "TemplateVersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasName = self.aliasName {
            try encodeContainer.encode(aliasName, forKey: .aliasName)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let templateVersionNumber = self.templateVersionNumber {
            try encodeContainer.encode(templateVersionNumber, forKey: .templateVersionNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasName)
        aliasName = aliasNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let templateVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .templateVersionNumber)
        templateVersionNumber = templateVersionNumberDecoded
    }
}

extension QuickSightClientTypes {
    /// The template alias.
    public struct TemplateAlias: Swift.Equatable {
        /// The display name of the template alias.
        public var aliasName: Swift.String?
        /// The Amazon Resource Name (ARN) of the template alias.
        public var arn: Swift.String?
        /// The version number of the template alias.
        public var templateVersionNumber: Swift.Int?

        public init (
            aliasName: Swift.String? = nil,
            arn: Swift.String? = nil,
            templateVersionNumber: Swift.Int? = nil
        )
        {
            self.aliasName = aliasName
            self.arn = arn
            self.templateVersionNumber = templateVersionNumber
        }
    }

}

extension QuickSightClientTypes.TemplateError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
        case violatedEntities = "ViolatedEntities"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let violatedEntities = violatedEntities {
            var violatedEntitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .violatedEntities)
            for entity0 in violatedEntities {
                try violatedEntitiesContainer.encode(entity0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TemplateErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let violatedEntitiesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Entity?].self, forKey: .violatedEntities)
        var violatedEntitiesDecoded0:[QuickSightClientTypes.Entity]? = nil
        if let violatedEntitiesContainer = violatedEntitiesContainer {
            violatedEntitiesDecoded0 = [QuickSightClientTypes.Entity]()
            for structure0 in violatedEntitiesContainer {
                if let structure0 = structure0 {
                    violatedEntitiesDecoded0?.append(structure0)
                }
            }
        }
        violatedEntities = violatedEntitiesDecoded0
    }
}

extension QuickSightClientTypes {
    /// List of errors that occurred when the template version creation failed.
    public struct TemplateError: Swift.Equatable {
        /// Description of the error type.
        public var message: Swift.String?
        /// Type of error.
        public var type: QuickSightClientTypes.TemplateErrorType?
        ///
        public var violatedEntities: [QuickSightClientTypes.Entity]?

        public init (
            message: Swift.String? = nil,
            type: QuickSightClientTypes.TemplateErrorType? = nil,
            violatedEntities: [QuickSightClientTypes.Entity]? = nil
        )
        {
            self.message = message
            self.type = type
            self.violatedEntities = violatedEntities
        }
    }

}

extension QuickSightClientTypes {
    public enum TemplateErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case dataSetNotFound
        case internalFailure
        case sourceNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [TemplateErrorType] {
            return [
                .accessDenied,
                .dataSetNotFound,
                .internalFailure,
                .sourceNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .dataSetNotFound: return "DATA_SET_NOT_FOUND"
            case .internalFailure: return "INTERNAL_FAILURE"
            case .sourceNotFound: return "SOURCE_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TemplateErrorType(rawValue: rawValue) ?? TemplateErrorType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.TemplateSourceAnalysis: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case dataSetReferences = "DataSetReferences"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dataSetReferences = dataSetReferences {
            var dataSetReferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSetReferences)
            for datasetreference0 in dataSetReferences {
                try dataSetReferencesContainer.encode(datasetreference0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let dataSetReferencesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataSetReference?].self, forKey: .dataSetReferences)
        var dataSetReferencesDecoded0:[QuickSightClientTypes.DataSetReference]? = nil
        if let dataSetReferencesContainer = dataSetReferencesContainer {
            dataSetReferencesDecoded0 = [QuickSightClientTypes.DataSetReference]()
            for structure0 in dataSetReferencesContainer {
                if let structure0 = structure0 {
                    dataSetReferencesDecoded0?.append(structure0)
                }
            }
        }
        dataSetReferences = dataSetReferencesDecoded0
    }
}

extension QuickSightClientTypes {
    /// The source analysis of the template.
    public struct TemplateSourceAnalysis: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        /// This member is required.
        public var arn: Swift.String?
        /// A structure containing information about the dataset references used as placeholders in the template.
        /// This member is required.
        public var dataSetReferences: [QuickSightClientTypes.DataSetReference]?

        public init (
            arn: Swift.String? = nil,
            dataSetReferences: [QuickSightClientTypes.DataSetReference]? = nil
        )
        {
            self.arn = arn
            self.dataSetReferences = dataSetReferences
        }
    }

}

extension QuickSightClientTypes.TemplateSourceEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceAnalysis = "SourceAnalysis"
        case sourceTemplate = "SourceTemplate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceAnalysis = self.sourceAnalysis {
            try encodeContainer.encode(sourceAnalysis, forKey: .sourceAnalysis)
        }
        if let sourceTemplate = self.sourceTemplate {
            try encodeContainer.encode(sourceTemplate, forKey: .sourceTemplate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceAnalysisDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TemplateSourceAnalysis.self, forKey: .sourceAnalysis)
        sourceAnalysis = sourceAnalysisDecoded
        let sourceTemplateDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TemplateSourceTemplate.self, forKey: .sourceTemplate)
        sourceTemplate = sourceTemplateDecoded
    }
}

extension QuickSightClientTypes {
    /// The source entity of the template.
    public struct TemplateSourceEntity: Swift.Equatable {
        /// The source analysis, if it is based on an analysis.
        public var sourceAnalysis: QuickSightClientTypes.TemplateSourceAnalysis?
        /// The source template, if it is based on an template.
        public var sourceTemplate: QuickSightClientTypes.TemplateSourceTemplate?

        public init (
            sourceAnalysis: QuickSightClientTypes.TemplateSourceAnalysis? = nil,
            sourceTemplate: QuickSightClientTypes.TemplateSourceTemplate? = nil
        )
        {
            self.sourceAnalysis = sourceAnalysis
            self.sourceTemplate = sourceTemplate
        }
    }

}

extension QuickSightClientTypes.TemplateSourceTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension QuickSightClientTypes {
    /// The source template of the template.
    public struct TemplateSourceTemplate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        /// This member is required.
        public var arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension QuickSightClientTypes.TemplateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case latestVersionNumber = "LatestVersionNumber"
        case name = "Name"
        case templateId = "TemplateId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let latestVersionNumber = self.latestVersionNumber {
            try encodeContainer.encode(latestVersionNumber, forKey: .latestVersionNumber)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let templateId = self.templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let latestVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .latestVersionNumber)
        latestVersionNumber = latestVersionNumberDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension QuickSightClientTypes {
    /// The template summary.
    public struct TemplateSummary: Swift.Equatable {
        /// A summary of a template.
        public var arn: Swift.String?
        /// The last time that this template was created.
        public var createdTime: ClientRuntime.Date?
        /// The last time that this template was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// A structure containing a list of version numbers for the template summary.
        public var latestVersionNumber: Swift.Int?
        /// A display name for the template.
        public var name: Swift.String?
        /// The ID of the template. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public var templateId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            latestVersionNumber: Swift.Int? = nil,
            name: Swift.String? = nil,
            templateId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.latestVersionNumber = latestVersionNumber
            self.name = name
            self.templateId = templateId
        }
    }

}

extension QuickSightClientTypes.TemplateVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case dataSetConfigurations = "DataSetConfigurations"
        case description = "Description"
        case errors = "Errors"
        case sheets = "Sheets"
        case sourceEntityArn = "SourceEntityArn"
        case status = "Status"
        case themeArn = "ThemeArn"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let dataSetConfigurations = dataSetConfigurations {
            var dataSetConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSetConfigurations)
            for datasetconfiguration0 in dataSetConfigurations {
                try dataSetConfigurationsContainer.encode(datasetconfiguration0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for templateerror0 in errors {
                try errorsContainer.encode(templateerror0)
            }
        }
        if let sheets = sheets {
            var sheetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sheets)
            for sheet0 in sheets {
                try sheetsContainer.encode(sheet0)
            }
        }
        if let sourceEntityArn = self.sourceEntityArn {
            try encodeContainer.encode(sourceEntityArn, forKey: .sourceEntityArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let themeArn = self.themeArn {
            try encodeContainer.encode(themeArn, forKey: .themeArn)
        }
        if let versionNumber = self.versionNumber {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let errorsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.TemplateError?].self, forKey: .errors)
        var errorsDecoded0:[QuickSightClientTypes.TemplateError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [QuickSightClientTypes.TemplateError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let dataSetConfigurationsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataSetConfiguration?].self, forKey: .dataSetConfigurations)
        var dataSetConfigurationsDecoded0:[QuickSightClientTypes.DataSetConfiguration]? = nil
        if let dataSetConfigurationsContainer = dataSetConfigurationsContainer {
            dataSetConfigurationsDecoded0 = [QuickSightClientTypes.DataSetConfiguration]()
            for structure0 in dataSetConfigurationsContainer {
                if let structure0 = structure0 {
                    dataSetConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        dataSetConfigurations = dataSetConfigurationsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceEntityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceEntityArn)
        sourceEntityArn = sourceEntityArnDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
        let sheetsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Sheet?].self, forKey: .sheets)
        var sheetsDecoded0:[QuickSightClientTypes.Sheet]? = nil
        if let sheetsContainer = sheetsContainer {
            sheetsDecoded0 = [QuickSightClientTypes.Sheet]()
            for structure0 in sheetsContainer {
                if let structure0 = structure0 {
                    sheetsDecoded0?.append(structure0)
                }
            }
        }
        sheets = sheetsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A version of a template.
    public struct TemplateVersion: Swift.Equatable {
        /// The time that this template version was created.
        public var createdTime: ClientRuntime.Date?
        /// Schema of the dataset identified by the placeholder. Any dashboard created from this template should be bound to new datasets matching the same schema described through this API operation.
        public var dataSetConfigurations: [QuickSightClientTypes.DataSetConfiguration]?
        /// The description of the template.
        public var description: Swift.String?
        /// Errors associated with this template version.
        public var errors: [QuickSightClientTypes.TemplateError]?
        /// A list of the associated sheets with the unique identifier and name of each sheet.
        public var sheets: [QuickSightClientTypes.Sheet]?
        /// The Amazon Resource Name (ARN) of an analysis or template that was used to create this template.
        public var sourceEntityArn: Swift.String?
        /// The HTTP status of the request.
        public var status: QuickSightClientTypes.ResourceStatus?
        /// The ARN of the theme associated with this version of the template.
        public var themeArn: Swift.String?
        /// The version number of the template version.
        public var versionNumber: Swift.Int?

        public init (
            createdTime: ClientRuntime.Date? = nil,
            dataSetConfigurations: [QuickSightClientTypes.DataSetConfiguration]? = nil,
            description: Swift.String? = nil,
            errors: [QuickSightClientTypes.TemplateError]? = nil,
            sheets: [QuickSightClientTypes.Sheet]? = nil,
            sourceEntityArn: Swift.String? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil,
            themeArn: Swift.String? = nil,
            versionNumber: Swift.Int? = nil
        )
        {
            self.createdTime = createdTime
            self.dataSetConfigurations = dataSetConfigurations
            self.description = description
            self.errors = errors
            self.sheets = sheets
            self.sourceEntityArn = sourceEntityArn
            self.status = status
            self.themeArn = themeArn
            self.versionNumber = versionNumber
        }
    }

}

extension QuickSightClientTypes.TemplateVersionDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisDefaults = "AnalysisDefaults"
        case calculatedFields = "CalculatedFields"
        case columnConfigurations = "ColumnConfigurations"
        case dataSetConfigurations = "DataSetConfigurations"
        case filterGroups = "FilterGroups"
        case parameterDeclarations = "ParameterDeclarations"
        case sheets = "Sheets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisDefaults = self.analysisDefaults {
            try encodeContainer.encode(analysisDefaults, forKey: .analysisDefaults)
        }
        if let calculatedFields = calculatedFields {
            var calculatedFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .calculatedFields)
            for calculatedfield0 in calculatedFields {
                try calculatedFieldsContainer.encode(calculatedfield0)
            }
        }
        if let columnConfigurations = columnConfigurations {
            var columnConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnConfigurations)
            for columnconfiguration0 in columnConfigurations {
                try columnConfigurationsContainer.encode(columnconfiguration0)
            }
        }
        if let dataSetConfigurations = dataSetConfigurations {
            var dataSetConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSetConfigurations)
            for datasetconfiguration0 in dataSetConfigurations {
                try dataSetConfigurationsContainer.encode(datasetconfiguration0)
            }
        }
        if let filterGroups = filterGroups {
            var filterGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterGroups)
            for filtergroup0 in filterGroups {
                try filterGroupsContainer.encode(filtergroup0)
            }
        }
        if let parameterDeclarations = parameterDeclarations {
            var parameterDeclarationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterDeclarations)
            for parameterdeclaration0 in parameterDeclarations {
                try parameterDeclarationsContainer.encode(parameterdeclaration0)
            }
        }
        if let sheets = sheets {
            var sheetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sheets)
            for sheetdefinition0 in sheets {
                try sheetsContainer.encode(sheetdefinition0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetConfigurationsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataSetConfiguration?].self, forKey: .dataSetConfigurations)
        var dataSetConfigurationsDecoded0:[QuickSightClientTypes.DataSetConfiguration]? = nil
        if let dataSetConfigurationsContainer = dataSetConfigurationsContainer {
            dataSetConfigurationsDecoded0 = [QuickSightClientTypes.DataSetConfiguration]()
            for structure0 in dataSetConfigurationsContainer {
                if let structure0 = structure0 {
                    dataSetConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        dataSetConfigurations = dataSetConfigurationsDecoded0
        let sheetsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.SheetDefinition?].self, forKey: .sheets)
        var sheetsDecoded0:[QuickSightClientTypes.SheetDefinition]? = nil
        if let sheetsContainer = sheetsContainer {
            sheetsDecoded0 = [QuickSightClientTypes.SheetDefinition]()
            for structure0 in sheetsContainer {
                if let structure0 = structure0 {
                    sheetsDecoded0?.append(structure0)
                }
            }
        }
        sheets = sheetsDecoded0
        let calculatedFieldsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.CalculatedField?].self, forKey: .calculatedFields)
        var calculatedFieldsDecoded0:[QuickSightClientTypes.CalculatedField]? = nil
        if let calculatedFieldsContainer = calculatedFieldsContainer {
            calculatedFieldsDecoded0 = [QuickSightClientTypes.CalculatedField]()
            for structure0 in calculatedFieldsContainer {
                if let structure0 = structure0 {
                    calculatedFieldsDecoded0?.append(structure0)
                }
            }
        }
        calculatedFields = calculatedFieldsDecoded0
        let parameterDeclarationsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ParameterDeclaration?].self, forKey: .parameterDeclarations)
        var parameterDeclarationsDecoded0:[QuickSightClientTypes.ParameterDeclaration]? = nil
        if let parameterDeclarationsContainer = parameterDeclarationsContainer {
            parameterDeclarationsDecoded0 = [QuickSightClientTypes.ParameterDeclaration]()
            for structure0 in parameterDeclarationsContainer {
                if let structure0 = structure0 {
                    parameterDeclarationsDecoded0?.append(structure0)
                }
            }
        }
        parameterDeclarations = parameterDeclarationsDecoded0
        let filterGroupsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FilterGroup?].self, forKey: .filterGroups)
        var filterGroupsDecoded0:[QuickSightClientTypes.FilterGroup]? = nil
        if let filterGroupsContainer = filterGroupsContainer {
            filterGroupsDecoded0 = [QuickSightClientTypes.FilterGroup]()
            for structure0 in filterGroupsContainer {
                if let structure0 = structure0 {
                    filterGroupsDecoded0?.append(structure0)
                }
            }
        }
        filterGroups = filterGroupsDecoded0
        let columnConfigurationsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnConfiguration?].self, forKey: .columnConfigurations)
        var columnConfigurationsDecoded0:[QuickSightClientTypes.ColumnConfiguration]? = nil
        if let columnConfigurationsContainer = columnConfigurationsContainer {
            columnConfigurationsDecoded0 = [QuickSightClientTypes.ColumnConfiguration]()
            for structure0 in columnConfigurationsContainer {
                if let structure0 = structure0 {
                    columnConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        columnConfigurations = columnConfigurationsDecoded0
        let analysisDefaultsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AnalysisDefaults.self, forKey: .analysisDefaults)
        analysisDefaults = analysisDefaultsDecoded
    }
}

extension QuickSightClientTypes {
    /// The detailed definition of a template.
    public struct TemplateVersionDefinition: Swift.Equatable {
        /// The configuration for default analysis settings.
        public var analysisDefaults: QuickSightClientTypes.AnalysisDefaults?
        /// An array of calculated field definitions for the template.
        public var calculatedFields: [QuickSightClientTypes.CalculatedField]?
        /// An array of template-level column configurations. Column configurations are used to set default formatting for a column that's used throughout a template.
        public var columnConfigurations: [QuickSightClientTypes.ColumnConfiguration]?
        /// An array of dataset configurations. These configurations define the required columns for each dataset used within a template.
        /// This member is required.
        public var dataSetConfigurations: [QuickSightClientTypes.DataSetConfiguration]?
        /// Filter definitions for a template. For more information, see [Filtering Data](https://docs.aws.amazon.com/quicksight/latest/user/filtering-visual-data.html) in the Amazon QuickSight User Guide.
        public var filterGroups: [QuickSightClientTypes.FilterGroup]?
        /// An array of parameter declarations for a template. Parameters are named variables that can transfer a value for use by an action or an object. For more information, see [Parameters in Amazon QuickSight](https://docs.aws.amazon.com/quicksight/latest/user/parameters-in-quicksight.html) in the Amazon QuickSight User Guide.
        public var parameterDeclarations: [QuickSightClientTypes.ParameterDeclaration]?
        /// An array of sheet definitions for a template.
        public var sheets: [QuickSightClientTypes.SheetDefinition]?

        public init (
            analysisDefaults: QuickSightClientTypes.AnalysisDefaults? = nil,
            calculatedFields: [QuickSightClientTypes.CalculatedField]? = nil,
            columnConfigurations: [QuickSightClientTypes.ColumnConfiguration]? = nil,
            dataSetConfigurations: [QuickSightClientTypes.DataSetConfiguration]? = nil,
            filterGroups: [QuickSightClientTypes.FilterGroup]? = nil,
            parameterDeclarations: [QuickSightClientTypes.ParameterDeclaration]? = nil,
            sheets: [QuickSightClientTypes.SheetDefinition]? = nil
        )
        {
            self.analysisDefaults = analysisDefaults
            self.calculatedFields = calculatedFields
            self.columnConfigurations = columnConfigurations
            self.dataSetConfigurations = dataSetConfigurations
            self.filterGroups = filterGroups
            self.parameterDeclarations = parameterDeclarations
            self.sheets = sheets
        }
    }

}

extension QuickSightClientTypes.TemplateVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case status = "Status"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let versionNumber = self.versionNumber {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension QuickSightClientTypes {
    /// The template version.
    public struct TemplateVersionSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the template version.
        public var arn: Swift.String?
        /// The time that this template version was created.
        public var createdTime: ClientRuntime.Date?
        /// The description of the template version.
        public var description: Swift.String?
        /// The status of the template version.
        public var status: QuickSightClientTypes.ResourceStatus?
        /// The version number of the template version.
        public var versionNumber: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil,
            versionNumber: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.status = status
            self.versionNumber = versionNumber
        }
    }

}

extension QuickSightClientTypes.TeradataParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case host = "Host"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for Teradata.
    public struct TeradataParameters: Swift.Equatable {
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int

        public init (
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.database = database
            self.host = host
            self.port = port
        }
    }

}

extension QuickSightClientTypes.TextAreaControlDisplayOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case placeholderOptions = "PlaceholderOptions"
        case titleOptions = "TitleOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let placeholderOptions = self.placeholderOptions {
            try encodeContainer.encode(placeholderOptions, forKey: .placeholderOptions)
        }
        if let titleOptions = self.titleOptions {
            try encodeContainer.encode(titleOptions, forKey: .titleOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LabelOptions.self, forKey: .titleOptions)
        titleOptions = titleOptionsDecoded
        let placeholderOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TextControlPlaceholderOptions.self, forKey: .placeholderOptions)
        placeholderOptions = placeholderOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// The display options of a control.
    public struct TextAreaControlDisplayOptions: Swift.Equatable {
        /// The configuration of the placeholder options in a text area control.
        public var placeholderOptions: QuickSightClientTypes.TextControlPlaceholderOptions?
        /// The options to configure the title visibility, name, and font size.
        public var titleOptions: QuickSightClientTypes.LabelOptions?

        public init (
            placeholderOptions: QuickSightClientTypes.TextControlPlaceholderOptions? = nil,
            titleOptions: QuickSightClientTypes.LabelOptions? = nil
        )
        {
            self.placeholderOptions = placeholderOptions
            self.titleOptions = titleOptions
        }
    }

}

extension QuickSightClientTypes.TextConditionalFormat: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backgroundColor = "BackgroundColor"
        case icon = "Icon"
        case textColor = "TextColor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backgroundColor = self.backgroundColor {
            try encodeContainer.encode(backgroundColor, forKey: .backgroundColor)
        }
        if let icon = self.icon {
            try encodeContainer.encode(icon, forKey: .icon)
        }
        if let textColor = self.textColor {
            try encodeContainer.encode(textColor, forKey: .textColor)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backgroundColorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ConditionalFormattingColor.self, forKey: .backgroundColor)
        backgroundColor = backgroundColorDecoded
        let textColorDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ConditionalFormattingColor.self, forKey: .textColor)
        textColor = textColorDecoded
        let iconDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ConditionalFormattingIcon.self, forKey: .icon)
        icon = iconDecoded
    }
}

extension QuickSightClientTypes {
    /// The conditional formatting for the text.
    public struct TextConditionalFormat: Swift.Equatable {
        /// The conditional formatting for the text background color.
        public var backgroundColor: QuickSightClientTypes.ConditionalFormattingColor?
        /// The conditional formatting for the icon.
        public var icon: QuickSightClientTypes.ConditionalFormattingIcon?
        /// The conditional formatting for the text color.
        public var textColor: QuickSightClientTypes.ConditionalFormattingColor?

        public init (
            backgroundColor: QuickSightClientTypes.ConditionalFormattingColor? = nil,
            icon: QuickSightClientTypes.ConditionalFormattingIcon? = nil,
            textColor: QuickSightClientTypes.ConditionalFormattingColor? = nil
        )
        {
            self.backgroundColor = backgroundColor
            self.icon = icon
            self.textColor = textColor
        }
    }

}

extension QuickSightClientTypes.TextControlPlaceholderOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of the placeholder options in a text control.
    public struct TextControlPlaceholderOptions: Swift.Equatable {
        /// The visibility configuration of the placeholder options in a text control.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.visibility = visibility
        }
    }

}

extension QuickSightClientTypes.TextFieldControlDisplayOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case placeholderOptions = "PlaceholderOptions"
        case titleOptions = "TitleOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let placeholderOptions = self.placeholderOptions {
            try encodeContainer.encode(placeholderOptions, forKey: .placeholderOptions)
        }
        if let titleOptions = self.titleOptions {
            try encodeContainer.encode(titleOptions, forKey: .titleOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LabelOptions.self, forKey: .titleOptions)
        titleOptions = titleOptionsDecoded
        let placeholderOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TextControlPlaceholderOptions.self, forKey: .placeholderOptions)
        placeholderOptions = placeholderOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// The display options of a control.
    public struct TextFieldControlDisplayOptions: Swift.Equatable {
        /// The configuration of the placeholder options in a text field control.
        public var placeholderOptions: QuickSightClientTypes.TextControlPlaceholderOptions?
        /// The options to configure the title visibility, name, and font size.
        public var titleOptions: QuickSightClientTypes.LabelOptions?

        public init (
            placeholderOptions: QuickSightClientTypes.TextControlPlaceholderOptions? = nil,
            titleOptions: QuickSightClientTypes.LabelOptions? = nil
        )
        {
            self.placeholderOptions = placeholderOptions
            self.titleOptions = titleOptions
        }
    }

}

extension QuickSightClientTypes {
    public enum TextQualifier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case doubleQuote
        case singleQuote
        case sdkUnknown(Swift.String)

        public static var allCases: [TextQualifier] {
            return [
                .doubleQuote,
                .singleQuote,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .doubleQuote: return "DOUBLE_QUOTE"
            case .singleQuote: return "SINGLE_QUOTE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TextQualifier(rawValue: rawValue) ?? TextQualifier.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum TextWrap: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case wrap
        case sdkUnknown(Swift.String)

        public static var allCases: [TextWrap] {
            return [
                .none,
                .wrap,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .wrap: return "WRAP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TextWrap(rawValue: rawValue) ?? TextWrap.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.Theme: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case themeId = "ThemeId"
        case type = "Type"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let themeId = self.themeId {
            try encodeContainer.encode(themeId, forKey: .themeId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let themeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeId)
        themeId = themeIdDecoded
        let versionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ThemeVersion.self, forKey: .version)
        version = versionDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ThemeType.self, forKey: .type)
        type = typeDecoded
    }
}

extension QuickSightClientTypes {
    /// Summary information about a theme.
    public struct Theme: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the theme.
        public var arn: Swift.String?
        /// The date and time that the theme was created.
        public var createdTime: ClientRuntime.Date?
        /// The date and time that the theme was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name that the user gives to the theme.
        public var name: Swift.String?
        /// The identifier that the user gives to the theme.
        public var themeId: Swift.String?
        /// The type of theme, based on how it was created. Valid values include: QUICKSIGHT and CUSTOM.
        public var type: QuickSightClientTypes.ThemeType?
        /// A version of a theme.
        public var version: QuickSightClientTypes.ThemeVersion?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            themeId: Swift.String? = nil,
            type: QuickSightClientTypes.ThemeType? = nil,
            version: QuickSightClientTypes.ThemeVersion? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.themeId = themeId
            self.type = type
            self.version = version
        }
    }

}

extension QuickSightClientTypes.ThemeAlias: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasName = "AliasName"
        case arn = "Arn"
        case themeVersionNumber = "ThemeVersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasName = self.aliasName {
            try encodeContainer.encode(aliasName, forKey: .aliasName)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let themeVersionNumber = self.themeVersionNumber {
            try encodeContainer.encode(themeVersionNumber, forKey: .themeVersionNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let aliasNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasName)
        aliasName = aliasNameDecoded
        let themeVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .themeVersionNumber)
        themeVersionNumber = themeVersionNumberDecoded
    }
}

extension QuickSightClientTypes {
    /// An alias for a theme.
    public struct ThemeAlias: Swift.Equatable {
        /// The display name of the theme alias.
        public var aliasName: Swift.String?
        /// The Amazon Resource Name (ARN) of the theme alias.
        public var arn: Swift.String?
        /// The version number of the theme alias.
        public var themeVersionNumber: Swift.Int?

        public init (
            aliasName: Swift.String? = nil,
            arn: Swift.String? = nil,
            themeVersionNumber: Swift.Int? = nil
        )
        {
            self.aliasName = aliasName
            self.arn = arn
            self.themeVersionNumber = themeVersionNumber
        }
    }

}

extension QuickSightClientTypes.ThemeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataColorPalette = "DataColorPalette"
        case sheet = "Sheet"
        case typography = "Typography"
        case uiColorPalette = "UIColorPalette"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataColorPalette = self.dataColorPalette {
            try encodeContainer.encode(dataColorPalette, forKey: .dataColorPalette)
        }
        if let sheet = self.sheet {
            try encodeContainer.encode(sheet, forKey: .sheet)
        }
        if let typography = self.typography {
            try encodeContainer.encode(typography, forKey: .typography)
        }
        if let uiColorPalette = self.uiColorPalette {
            try encodeContainer.encode(uiColorPalette, forKey: .uiColorPalette)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataColorPaletteDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataColorPalette.self, forKey: .dataColorPalette)
        dataColorPalette = dataColorPaletteDecoded
        let uiColorPaletteDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.UIColorPalette.self, forKey: .uiColorPalette)
        uiColorPalette = uiColorPaletteDecoded
        let sheetDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SheetStyle.self, forKey: .sheet)
        sheet = sheetDecoded
        let typographyDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Typography.self, forKey: .typography)
        typography = typographyDecoded
    }
}

extension QuickSightClientTypes {
    /// The theme configuration. This configuration contains all of the display properties for a theme.
    public struct ThemeConfiguration: Swift.Equatable {
        /// Color properties that apply to chart data colors.
        public var dataColorPalette: QuickSightClientTypes.DataColorPalette?
        /// Display options related to sheets.
        public var sheet: QuickSightClientTypes.SheetStyle?
        /// Determines the typography options.
        public var typography: QuickSightClientTypes.Typography?
        /// Color properties that apply to the UI and to charts, excluding the colors that apply to data.
        public var uiColorPalette: QuickSightClientTypes.UIColorPalette?

        public init (
            dataColorPalette: QuickSightClientTypes.DataColorPalette? = nil,
            sheet: QuickSightClientTypes.SheetStyle? = nil,
            typography: QuickSightClientTypes.Typography? = nil,
            uiColorPalette: QuickSightClientTypes.UIColorPalette? = nil
        )
        {
            self.dataColorPalette = dataColorPalette
            self.sheet = sheet
            self.typography = typography
            self.uiColorPalette = uiColorPalette
        }
    }

}

extension QuickSightClientTypes.ThemeError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ThemeErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QuickSightClientTypes {
    /// Theme error.
    public struct ThemeError: Swift.Equatable {
        /// The error message.
        public var message: Swift.String?
        /// The type of error.
        public var type: QuickSightClientTypes.ThemeErrorType?

        public init (
            message: Swift.String? = nil,
            type: QuickSightClientTypes.ThemeErrorType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }

}

extension QuickSightClientTypes {
    public enum ThemeErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [ThemeErrorType] {
            return [
                .internalFailure,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalFailure: return "INTERNAL_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThemeErrorType(rawValue: rawValue) ?? ThemeErrorType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.ThemeSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case latestVersionNumber = "LatestVersionNumber"
        case name = "Name"
        case themeId = "ThemeId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let latestVersionNumber = self.latestVersionNumber {
            try encodeContainer.encode(latestVersionNumber, forKey: .latestVersionNumber)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let themeId = self.themeId {
            try encodeContainer.encode(themeId, forKey: .themeId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let themeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeId)
        themeId = themeIdDecoded
        let latestVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .latestVersionNumber)
        latestVersionNumber = latestVersionNumberDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension QuickSightClientTypes {
    /// The theme summary.
    public struct ThemeSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// The date and time that this theme was created.
        public var createdTime: ClientRuntime.Date?
        /// The last date and time that this theme was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The latest version number for the theme.
        public var latestVersionNumber: Swift.Int?
        /// the display name for the theme.
        public var name: Swift.String?
        /// The ID of the theme. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public var themeId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            latestVersionNumber: Swift.Int? = nil,
            name: Swift.String? = nil,
            themeId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.latestVersionNumber = latestVersionNumber
            self.name = name
            self.themeId = themeId
        }
    }

}

extension QuickSightClientTypes {
    public enum ThemeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case custom
        case quicksight
        case sdkUnknown(Swift.String)

        public static var allCases: [ThemeType] {
            return [
                .all,
                .custom,
                .quicksight,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .custom: return "CUSTOM"
            case .quicksight: return "QUICKSIGHT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThemeType(rawValue: rawValue) ?? ThemeType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.ThemeVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case baseThemeId = "BaseThemeId"
        case configuration = "Configuration"
        case createdTime = "CreatedTime"
        case description = "Description"
        case errors = "Errors"
        case status = "Status"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let baseThemeId = self.baseThemeId {
            try encodeContainer.encode(baseThemeId, forKey: .baseThemeId)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for themeerror0 in errors {
                try errorsContainer.encode(themeerror0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let versionNumber = self.versionNumber {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let baseThemeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseThemeId)
        baseThemeId = baseThemeIdDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ThemeConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let errorsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ThemeError?].self, forKey: .errors)
        var errorsDecoded0:[QuickSightClientTypes.ThemeError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [QuickSightClientTypes.ThemeError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension QuickSightClientTypes {
    /// A version of a theme.
    public struct ThemeVersion: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// The Amazon QuickSight-defined ID of the theme that a custom theme inherits from. All themes initially inherit from a default Amazon QuickSight theme.
        public var baseThemeId: Swift.String?
        /// The theme configuration, which contains all the theme display properties.
        public var configuration: QuickSightClientTypes.ThemeConfiguration?
        /// The date and time that this theme version was created.
        public var createdTime: ClientRuntime.Date?
        /// The description of the theme.
        public var description: Swift.String?
        /// Errors associated with the theme.
        public var errors: [QuickSightClientTypes.ThemeError]?
        /// The status of the theme version.
        public var status: QuickSightClientTypes.ResourceStatus?
        /// The version number of the theme.
        public var versionNumber: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            baseThemeId: Swift.String? = nil,
            configuration: QuickSightClientTypes.ThemeConfiguration? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            errors: [QuickSightClientTypes.ThemeError]? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil,
            versionNumber: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.baseThemeId = baseThemeId
            self.configuration = configuration
            self.createdTime = createdTime
            self.description = description
            self.errors = errors
            self.status = status
            self.versionNumber = versionNumber
        }
    }

}

extension QuickSightClientTypes.ThemeVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case status = "Status"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let versionNumber = self.versionNumber {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension QuickSightClientTypes {
    /// The theme version.
    public struct ThemeVersionSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the theme version.
        public var arn: Swift.String?
        /// The date and time that this theme version was created.
        public var createdTime: ClientRuntime.Date?
        /// The description of the theme version.
        public var description: Swift.String?
        /// The status of the theme version.
        public var status: QuickSightClientTypes.ResourceStatus?
        /// The version number of the theme version.
        public var versionNumber: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil,
            versionNumber: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.status = status
            self.versionNumber = versionNumber
        }
    }

}

extension QuickSightClientTypes.ThousandSeparatorOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case symbol = "Symbol"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let symbol = self.symbol {
            try encodeContainer.encode(symbol.rawValue, forKey: .symbol)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let symbolDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.NumericSeparatorSymbol.self, forKey: .symbol)
        symbol = symbolDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the thousands separator configuration.
    public struct ThousandSeparatorOptions: Swift.Equatable {
        /// Determines the thousands separator symbol.
        public var symbol: QuickSightClientTypes.NumericSeparatorSymbol?
        /// Determines the visibility of the thousands separator.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            symbol: QuickSightClientTypes.NumericSeparatorSymbol? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.symbol = symbol
            self.visibility = visibility
        }
    }

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Access is throttled.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.TileLayoutStyle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gutter = "Gutter"
        case margin = "Margin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gutter = self.gutter {
            try encodeContainer.encode(gutter, forKey: .gutter)
        }
        if let margin = self.margin {
            try encodeContainer.encode(margin, forKey: .margin)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gutterDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GutterStyle.self, forKey: .gutter)
        gutter = gutterDecoded
        let marginDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.MarginStyle.self, forKey: .margin)
        margin = marginDecoded
    }
}

extension QuickSightClientTypes {
    /// The display options for the layout of tiles on a sheet.
    public struct TileLayoutStyle: Swift.Equatable {
        /// The gutter settings that apply between tiles.
        public var gutter: QuickSightClientTypes.GutterStyle?
        /// The margin settings that apply around the outside edge of sheets.
        public var margin: QuickSightClientTypes.MarginStyle?

        public init (
            gutter: QuickSightClientTypes.GutterStyle? = nil,
            margin: QuickSightClientTypes.MarginStyle? = nil
        )
        {
            self.gutter = gutter
            self.margin = margin
        }
    }

}

extension QuickSightClientTypes.TileStyle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case border = "Border"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let border = self.border {
            try encodeContainer.encode(border, forKey: .border)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let borderDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.BorderStyle.self, forKey: .border)
        border = borderDecoded
    }
}

extension QuickSightClientTypes {
    /// Display options related to tiles on a sheet.
    public struct TileStyle: Swift.Equatable {
        /// The border around a tile.
        public var border: QuickSightClientTypes.BorderStyle?

        public init (
            border: QuickSightClientTypes.BorderStyle? = nil
        )
        {
            self.border = border
        }
    }

}

extension QuickSightClientTypes.TimeBasedForecastProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lowerBoundary = "LowerBoundary"
        case periodsBackward = "PeriodsBackward"
        case periodsForward = "PeriodsForward"
        case predictionInterval = "PredictionInterval"
        case seasonality = "Seasonality"
        case upperBoundary = "UpperBoundary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lowerBoundary = self.lowerBoundary {
            try encodeContainer.encode(lowerBoundary, forKey: .lowerBoundary)
        }
        if let periodsBackward = self.periodsBackward {
            try encodeContainer.encode(periodsBackward, forKey: .periodsBackward)
        }
        if let periodsForward = self.periodsForward {
            try encodeContainer.encode(periodsForward, forKey: .periodsForward)
        }
        if let predictionInterval = self.predictionInterval {
            try encodeContainer.encode(predictionInterval, forKey: .predictionInterval)
        }
        if let seasonality = self.seasonality {
            try encodeContainer.encode(seasonality, forKey: .seasonality)
        }
        if let upperBoundary = self.upperBoundary {
            try encodeContainer.encode(upperBoundary, forKey: .upperBoundary)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let periodsForwardDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .periodsForward)
        periodsForward = periodsForwardDecoded
        let periodsBackwardDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .periodsBackward)
        periodsBackward = periodsBackwardDecoded
        let upperBoundaryDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .upperBoundary)
        upperBoundary = upperBoundaryDecoded
        let lowerBoundaryDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .lowerBoundary)
        lowerBoundary = lowerBoundaryDecoded
        let predictionIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .predictionInterval)
        predictionInterval = predictionIntervalDecoded
        let seasonalityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .seasonality)
        seasonality = seasonalityDecoded
    }
}

extension QuickSightClientTypes {
    /// The forecast properties setup of a forecast in the line chart.
    public struct TimeBasedForecastProperties: Swift.Equatable {
        /// The lower boundary setup of a forecast computation.
        public var lowerBoundary: Swift.Double?
        /// The periods backward setup of a forecast computation.
        public var periodsBackward: Swift.Int?
        /// The periods forward setup of a forecast computation.
        public var periodsForward: Swift.Int?
        /// The prediction interval setup of a forecast computation.
        public var predictionInterval: Swift.Int?
        /// The seasonality setup of a forecast computation. Choose one of the following options:
        ///
        /// * NULL: The input is set to NULL.
        ///
        /// * NON_NULL: The input is set to a custom value.
        public var seasonality: Swift.Int?
        /// The upper boundary setup of a forecast computation.
        public var upperBoundary: Swift.Double?

        public init (
            lowerBoundary: Swift.Double? = nil,
            periodsBackward: Swift.Int? = nil,
            periodsForward: Swift.Int? = nil,
            predictionInterval: Swift.Int? = nil,
            seasonality: Swift.Int? = nil,
            upperBoundary: Swift.Double? = nil
        )
        {
            self.lowerBoundary = lowerBoundary
            self.periodsBackward = periodsBackward
            self.periodsForward = periodsForward
            self.predictionInterval = predictionInterval
            self.seasonality = seasonality
            self.upperBoundary = upperBoundary
        }
    }

}

extension QuickSightClientTypes.TimeEqualityFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case column = "Column"
        case filterId = "FilterId"
        case parameterName = "ParameterName"
        case timeGranularity = "TimeGranularity"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let column = self.column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let filterId = self.filterId {
            try encodeContainer.encode(filterId, forKey: .filterId)
        }
        if let parameterName = self.parameterName {
            try encodeContainer.encode(parameterName, forKey: .parameterName)
        }
        if let timeGranularity = self.timeGranularity {
            try encodeContainer.encode(timeGranularity.rawValue, forKey: .timeGranularity)
        }
        if let value = self.value {
            try encodeContainer.encodeTimestamp(value, format: .epochSeconds, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterId)
        filterId = filterIdDecoded
        let columnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .column)
        column = columnDecoded
        let valueDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .value)
        value = valueDecoded
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let timeGranularityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TimeGranularity.self, forKey: .timeGranularity)
        timeGranularity = timeGranularityDecoded
    }
}

extension QuickSightClientTypes {
    /// A TimeEqualityFilter filters values that are equal to a given value.
    public struct TimeEqualityFilter: Swift.Equatable {
        /// The column that the filter is applied to.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        /// This member is required.
        public var filterId: Swift.String?
        /// The parameter whose value should be used for the filter value. This field is mutually exclusive to Value.
        public var parameterName: Swift.String?
        /// The level of time precision that is used to aggregate DateTime values.
        public var timeGranularity: QuickSightClientTypes.TimeGranularity?
        /// The value of a TimeEquality filter. This field is mutually exclusive to ParameterName.
        public var value: ClientRuntime.Date?

        public init (
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            filterId: Swift.String? = nil,
            parameterName: Swift.String? = nil,
            timeGranularity: QuickSightClientTypes.TimeGranularity? = nil,
            value: ClientRuntime.Date? = nil
        )
        {
            self.column = column
            self.filterId = filterId
            self.parameterName = parameterName
            self.timeGranularity = timeGranularity
            self.value = value
        }
    }

}

extension QuickSightClientTypes {
    public enum TimeGranularity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case day
        case hour
        case millisecond
        case minute
        case month
        case quarter
        case second
        case week
        case year
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeGranularity] {
            return [
                .day,
                .hour,
                .millisecond,
                .minute,
                .month,
                .quarter,
                .second,
                .week,
                .year,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .day: return "DAY"
            case .hour: return "HOUR"
            case .millisecond: return "MILLISECOND"
            case .minute: return "MINUTE"
            case .month: return "MONTH"
            case .quarter: return "QUARTER"
            case .second: return "SECOND"
            case .week: return "WEEK"
            case .year: return "YEAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TimeGranularity(rawValue: rawValue) ?? TimeGranularity.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.TimeRangeDrillDownFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case column = "Column"
        case rangeMaximum = "RangeMaximum"
        case rangeMinimum = "RangeMinimum"
        case timeGranularity = "TimeGranularity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let column = self.column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let rangeMaximum = self.rangeMaximum {
            try encodeContainer.encodeTimestamp(rangeMaximum, format: .epochSeconds, forKey: .rangeMaximum)
        }
        if let rangeMinimum = self.rangeMinimum {
            try encodeContainer.encodeTimestamp(rangeMinimum, format: .epochSeconds, forKey: .rangeMinimum)
        }
        if let timeGranularity = self.timeGranularity {
            try encodeContainer.encode(timeGranularity.rawValue, forKey: .timeGranularity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .column)
        column = columnDecoded
        let rangeMinimumDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .rangeMinimum)
        rangeMinimum = rangeMinimumDecoded
        let rangeMaximumDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .rangeMaximum)
        rangeMaximum = rangeMaximumDecoded
        let timeGranularityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TimeGranularity.self, forKey: .timeGranularity)
        timeGranularity = timeGranularityDecoded
    }
}

extension QuickSightClientTypes {
    /// The time range drill down filter.
    public struct TimeRangeDrillDownFilter: Swift.Equatable {
        /// The column that the filter is applied to.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The maximum value for the filter value range.
        /// This member is required.
        public var rangeMaximum: ClientRuntime.Date?
        /// The minimum value for the filter value range.
        /// This member is required.
        public var rangeMinimum: ClientRuntime.Date?
        /// The level of time precision that is used to aggregate DateTime values.
        /// This member is required.
        public var timeGranularity: QuickSightClientTypes.TimeGranularity?

        public init (
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            rangeMaximum: ClientRuntime.Date? = nil,
            rangeMinimum: ClientRuntime.Date? = nil,
            timeGranularity: QuickSightClientTypes.TimeGranularity? = nil
        )
        {
            self.column = column
            self.rangeMaximum = rangeMaximum
            self.rangeMinimum = rangeMinimum
            self.timeGranularity = timeGranularity
        }
    }

}

extension QuickSightClientTypes.TimeRangeFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case column = "Column"
        case excludePeriodConfiguration = "ExcludePeriodConfiguration"
        case filterId = "FilterId"
        case includeMaximum = "IncludeMaximum"
        case includeMinimum = "IncludeMinimum"
        case nullOption = "NullOption"
        case rangeMaximumValue = "RangeMaximumValue"
        case rangeMinimumValue = "RangeMinimumValue"
        case timeGranularity = "TimeGranularity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let column = self.column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let excludePeriodConfiguration = self.excludePeriodConfiguration {
            try encodeContainer.encode(excludePeriodConfiguration, forKey: .excludePeriodConfiguration)
        }
        if let filterId = self.filterId {
            try encodeContainer.encode(filterId, forKey: .filterId)
        }
        if let includeMaximum = self.includeMaximum {
            try encodeContainer.encode(includeMaximum, forKey: .includeMaximum)
        }
        if let includeMinimum = self.includeMinimum {
            try encodeContainer.encode(includeMinimum, forKey: .includeMinimum)
        }
        if let nullOption = self.nullOption {
            try encodeContainer.encode(nullOption.rawValue, forKey: .nullOption)
        }
        if let rangeMaximumValue = self.rangeMaximumValue {
            try encodeContainer.encode(rangeMaximumValue, forKey: .rangeMaximumValue)
        }
        if let rangeMinimumValue = self.rangeMinimumValue {
            try encodeContainer.encode(rangeMinimumValue, forKey: .rangeMinimumValue)
        }
        if let timeGranularity = self.timeGranularity {
            try encodeContainer.encode(timeGranularity.rawValue, forKey: .timeGranularity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterId)
        filterId = filterIdDecoded
        let columnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .column)
        column = columnDecoded
        let includeMinimumDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeMinimum)
        includeMinimum = includeMinimumDecoded
        let includeMaximumDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeMaximum)
        includeMaximum = includeMaximumDecoded
        let rangeMinimumValueDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TimeRangeFilterValue.self, forKey: .rangeMinimumValue)
        rangeMinimumValue = rangeMinimumValueDecoded
        let rangeMaximumValueDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TimeRangeFilterValue.self, forKey: .rangeMaximumValue)
        rangeMaximumValue = rangeMaximumValueDecoded
        let nullOptionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilterNullOption.self, forKey: .nullOption)
        nullOption = nullOptionDecoded
        let excludePeriodConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ExcludePeriodConfiguration.self, forKey: .excludePeriodConfiguration)
        excludePeriodConfiguration = excludePeriodConfigurationDecoded
        let timeGranularityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TimeGranularity.self, forKey: .timeGranularity)
        timeGranularity = timeGranularityDecoded
    }
}

extension QuickSightClientTypes {
    /// A TimeRangeFilter filters values that are between two specified values.
    public struct TimeRangeFilter: Swift.Equatable {
        /// The column that the filter is applied to.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The exclude period of the time range filter.
        public var excludePeriodConfiguration: QuickSightClientTypes.ExcludePeriodConfiguration?
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        /// This member is required.
        public var filterId: Swift.String?
        /// Determines whether the maximum value in the filter value range should be included in the filtered results.
        public var includeMaximum: Swift.Bool?
        /// Determines whether the minimum value in the filter value range should be included in the filtered results.
        public var includeMinimum: Swift.Bool?
        /// This option determines how null values should be treated when filtering data.
        ///
        /// * ALL_VALUES: Include null values in filtered results.
        ///
        /// * NULLS_ONLY: Only include null values in filtered results.
        ///
        /// * NON_NULLS_ONLY: Exclude null values from filtered results.
        /// This member is required.
        public var nullOption: QuickSightClientTypes.FilterNullOption?
        /// The maximum value for the filter value range.
        public var rangeMaximumValue: QuickSightClientTypes.TimeRangeFilterValue?
        /// The minimum value for the filter value range.
        public var rangeMinimumValue: QuickSightClientTypes.TimeRangeFilterValue?
        /// The level of time precision that is used to aggregate DateTime values.
        public var timeGranularity: QuickSightClientTypes.TimeGranularity?

        public init (
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            excludePeriodConfiguration: QuickSightClientTypes.ExcludePeriodConfiguration? = nil,
            filterId: Swift.String? = nil,
            includeMaximum: Swift.Bool? = nil,
            includeMinimum: Swift.Bool? = nil,
            nullOption: QuickSightClientTypes.FilterNullOption? = nil,
            rangeMaximumValue: QuickSightClientTypes.TimeRangeFilterValue? = nil,
            rangeMinimumValue: QuickSightClientTypes.TimeRangeFilterValue? = nil,
            timeGranularity: QuickSightClientTypes.TimeGranularity? = nil
        )
        {
            self.column = column
            self.excludePeriodConfiguration = excludePeriodConfiguration
            self.filterId = filterId
            self.includeMaximum = includeMaximum
            self.includeMinimum = includeMinimum
            self.nullOption = nullOption
            self.rangeMaximumValue = rangeMaximumValue
            self.rangeMinimumValue = rangeMinimumValue
            self.timeGranularity = timeGranularity
        }
    }

}

extension QuickSightClientTypes.TimeRangeFilterValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameter = "Parameter"
        case rollingDate = "RollingDate"
        case staticValue = "StaticValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameter = self.parameter {
            try encodeContainer.encode(parameter, forKey: .parameter)
        }
        if let rollingDate = self.rollingDate {
            try encodeContainer.encode(rollingDate, forKey: .rollingDate)
        }
        if let staticValue = self.staticValue {
            try encodeContainer.encodeTimestamp(staticValue, format: .epochSeconds, forKey: .staticValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let staticValueDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .staticValue)
        staticValue = staticValueDecoded
        let rollingDateDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RollingDateConfiguration.self, forKey: .rollingDate)
        rollingDate = rollingDateDecoded
        let parameterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameter)
        parameter = parameterDecoded
    }
}

extension QuickSightClientTypes {
    /// The value of a time range filter. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct TimeRangeFilterValue: Swift.Equatable {
        /// The parameter type input value.
        public var parameter: Swift.String?
        /// The rolling date input value.
        public var rollingDate: QuickSightClientTypes.RollingDateConfiguration?
        /// The static input value.
        public var staticValue: ClientRuntime.Date?

        public init (
            parameter: Swift.String? = nil,
            rollingDate: QuickSightClientTypes.RollingDateConfiguration? = nil,
            staticValue: ClientRuntime.Date? = nil
        )
        {
            self.parameter = parameter
            self.rollingDate = rollingDate
            self.staticValue = staticValue
        }
    }

}

extension QuickSightClientTypes.TooltipItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnTooltipItem = "ColumnTooltipItem"
        case fieldTooltipItem = "FieldTooltipItem"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnTooltipItem = self.columnTooltipItem {
            try encodeContainer.encode(columnTooltipItem, forKey: .columnTooltipItem)
        }
        if let fieldTooltipItem = self.fieldTooltipItem {
            try encodeContainer.encode(fieldTooltipItem, forKey: .fieldTooltipItem)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldTooltipItemDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FieldTooltipItem.self, forKey: .fieldTooltipItem)
        fieldTooltipItem = fieldTooltipItemDecoded
        let columnTooltipItemDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnTooltipItem.self, forKey: .columnTooltipItem)
        columnTooltipItem = columnTooltipItemDecoded
    }
}

extension QuickSightClientTypes {
    /// The tooltip. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct TooltipItem: Swift.Equatable {
        /// The tooltip item for the columns that are not part of a field well.
        public var columnTooltipItem: QuickSightClientTypes.ColumnTooltipItem?
        /// The tooltip item for the fields.
        public var fieldTooltipItem: QuickSightClientTypes.FieldTooltipItem?

        public init (
            columnTooltipItem: QuickSightClientTypes.ColumnTooltipItem? = nil,
            fieldTooltipItem: QuickSightClientTypes.FieldTooltipItem? = nil
        )
        {
            self.columnTooltipItem = columnTooltipItem
            self.fieldTooltipItem = fieldTooltipItem
        }
    }

}

extension QuickSightClientTypes.TooltipOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldBasedTooltip = "FieldBasedTooltip"
        case selectedTooltipType = "SelectedTooltipType"
        case tooltipVisibility = "TooltipVisibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldBasedTooltip = self.fieldBasedTooltip {
            try encodeContainer.encode(fieldBasedTooltip, forKey: .fieldBasedTooltip)
        }
        if let selectedTooltipType = self.selectedTooltipType {
            try encodeContainer.encode(selectedTooltipType.rawValue, forKey: .selectedTooltipType)
        }
        if let tooltipVisibility = self.tooltipVisibility {
            try encodeContainer.encode(tooltipVisibility.rawValue, forKey: .tooltipVisibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tooltipVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .tooltipVisibility)
        tooltipVisibility = tooltipVisibilityDecoded
        let selectedTooltipTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SelectedTooltipType.self, forKey: .selectedTooltipType)
        selectedTooltipType = selectedTooltipTypeDecoded
        let fieldBasedTooltipDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FieldBasedTooltip.self, forKey: .fieldBasedTooltip)
        fieldBasedTooltip = fieldBasedTooltipDecoded
    }
}

extension QuickSightClientTypes {
    /// The display options for the visual tooltip.
    public struct TooltipOptions: Swift.Equatable {
        /// The setup for the detailed tooltip. The tooltip setup is always saved. The display type is decided based on the tooltip type.
        public var fieldBasedTooltip: QuickSightClientTypes.FieldBasedTooltip?
        /// The selected type for the tooltip. Choose one of the following options:
        ///
        /// * BASIC: A basic tooltip.
        ///
        /// * DETAILED: A detailed tooltip.
        public var selectedTooltipType: QuickSightClientTypes.SelectedTooltipType?
        /// Determines whether or not the tooltip is visible.
        public var tooltipVisibility: QuickSightClientTypes.Visibility?

        public init (
            fieldBasedTooltip: QuickSightClientTypes.FieldBasedTooltip? = nil,
            selectedTooltipType: QuickSightClientTypes.SelectedTooltipType? = nil,
            tooltipVisibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.fieldBasedTooltip = fieldBasedTooltip
            self.selectedTooltipType = selectedTooltipType
            self.tooltipVisibility = tooltipVisibility
        }
    }

}

extension QuickSightClientTypes {
    public enum TooltipTitleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case primaryValue
        case sdkUnknown(Swift.String)

        public static var allCases: [TooltipTitleType] {
            return [
                .none,
                .primaryValue,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .primaryValue: return "PRIMARY_VALUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TooltipTitleType(rawValue: rawValue) ?? TooltipTitleType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum TopBottomComputationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bottom
        case top
        case sdkUnknown(Swift.String)

        public static var allCases: [TopBottomComputationType] {
            return [
                .bottom,
                .top,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bottom: return "BOTTOM"
            case .top: return "TOP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TopBottomComputationType(rawValue: rawValue) ?? TopBottomComputationType.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.TopBottomFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationSortConfigurations = "AggregationSortConfigurations"
        case column = "Column"
        case filterId = "FilterId"
        case limit = "Limit"
        case parameterName = "ParameterName"
        case timeGranularity = "TimeGranularity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationSortConfigurations = aggregationSortConfigurations {
            var aggregationSortConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aggregationSortConfigurations)
            for aggregationsortconfiguration0 in aggregationSortConfigurations {
                try aggregationSortConfigurationsContainer.encode(aggregationsortconfiguration0)
            }
        }
        if let column = self.column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let filterId = self.filterId {
            try encodeContainer.encode(filterId, forKey: .filterId)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let parameterName = self.parameterName {
            try encodeContainer.encode(parameterName, forKey: .parameterName)
        }
        if let timeGranularity = self.timeGranularity {
            try encodeContainer.encode(timeGranularity.rawValue, forKey: .timeGranularity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterId)
        filterId = filterIdDecoded
        let columnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .column)
        column = columnDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let aggregationSortConfigurationsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.AggregationSortConfiguration?].self, forKey: .aggregationSortConfigurations)
        var aggregationSortConfigurationsDecoded0:[QuickSightClientTypes.AggregationSortConfiguration]? = nil
        if let aggregationSortConfigurationsContainer = aggregationSortConfigurationsContainer {
            aggregationSortConfigurationsDecoded0 = [QuickSightClientTypes.AggregationSortConfiguration]()
            for structure0 in aggregationSortConfigurationsContainer {
                if let structure0 = structure0 {
                    aggregationSortConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        aggregationSortConfigurations = aggregationSortConfigurationsDecoded0
        let timeGranularityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TimeGranularity.self, forKey: .timeGranularity)
        timeGranularity = timeGranularityDecoded
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
    }
}

extension QuickSightClientTypes {
    /// A TopBottomFilter filters values that are at the top or the bottom.
    public struct TopBottomFilter: Swift.Equatable {
        /// The aggregation and sort configuration of the top bottom filter.
        /// This member is required.
        public var aggregationSortConfigurations: [QuickSightClientTypes.AggregationSortConfiguration]?
        /// The column that the filter is applied to.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        /// This member is required.
        public var filterId: Swift.String?
        /// The number of items to include in the top bottom filter results.
        public var limit: Swift.Int?
        /// The parameter whose value should be used for the filter value.
        public var parameterName: Swift.String?
        /// The level of time precision that is used to aggregate DateTime values.
        public var timeGranularity: QuickSightClientTypes.TimeGranularity?

        public init (
            aggregationSortConfigurations: [QuickSightClientTypes.AggregationSortConfiguration]? = nil,
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            filterId: Swift.String? = nil,
            limit: Swift.Int? = nil,
            parameterName: Swift.String? = nil,
            timeGranularity: QuickSightClientTypes.TimeGranularity? = nil
        )
        {
            self.aggregationSortConfigurations = aggregationSortConfigurations
            self.column = column
            self.filterId = filterId
            self.limit = limit
            self.parameterName = parameterName
            self.timeGranularity = timeGranularity
        }
    }

}

extension QuickSightClientTypes.TopBottomMoversComputation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category = "Category"
        case computationId = "ComputationId"
        case moverSize = "MoverSize"
        case name = "Name"
        case sortOrder = "SortOrder"
        case time = "Time"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = self.category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let computationId = self.computationId {
            try encodeContainer.encode(computationId, forKey: .computationId)
        }
        if moverSize != 0 {
            try encodeContainer.encode(moverSize, forKey: .moverSize)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
        if let time = self.time {
            try encodeContainer.encode(time, forKey: .time)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .computationId)
        computationId = computationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let timeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DimensionField.self, forKey: .time)
        time = timeDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DimensionField.self, forKey: .category)
        category = categoryDecoded
        let valueDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.MeasureField.self, forKey: .value)
        value = valueDecoded
        let moverSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .moverSize) ?? 0
        moverSize = moverSizeDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TopBottomSortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TopBottomComputationType.self, forKey: .type)
        type = typeDecoded
    }
}

extension QuickSightClientTypes {
    /// The top movers and bottom movers computation setup.
    public struct TopBottomMoversComputation: Swift.Equatable {
        /// The category field that is used in a computation.
        /// This member is required.
        public var category: QuickSightClientTypes.DimensionField?
        /// The ID for a computation.
        /// This member is required.
        public var computationId: Swift.String?
        /// The mover size setup of the top and bottom movers computation.
        public var moverSize: Swift.Int
        /// The name of a computation.
        public var name: Swift.String?
        /// The sort order setup of the top and bottom movers computation.
        public var sortOrder: QuickSightClientTypes.TopBottomSortOrder?
        /// The time field that is used in a computation.
        /// This member is required.
        public var time: QuickSightClientTypes.DimensionField?
        /// The computation type. Choose from the following options:
        ///
        /// * TOP: Top movers computation.
        ///
        /// * BOTTOM: Bottom movers computation.
        /// This member is required.
        public var type: QuickSightClientTypes.TopBottomComputationType?
        /// The value field that is used in a computation.
        public var value: QuickSightClientTypes.MeasureField?

        public init (
            category: QuickSightClientTypes.DimensionField? = nil,
            computationId: Swift.String? = nil,
            moverSize: Swift.Int = 0,
            name: Swift.String? = nil,
            sortOrder: QuickSightClientTypes.TopBottomSortOrder? = nil,
            time: QuickSightClientTypes.DimensionField? = nil,
            type: QuickSightClientTypes.TopBottomComputationType? = nil,
            value: QuickSightClientTypes.MeasureField? = nil
        )
        {
            self.category = category
            self.computationId = computationId
            self.moverSize = moverSize
            self.name = name
            self.sortOrder = sortOrder
            self.time = time
            self.type = type
            self.value = value
        }
    }

}

extension QuickSightClientTypes.TopBottomRankedComputation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category = "Category"
        case computationId = "ComputationId"
        case name = "Name"
        case resultSize = "ResultSize"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = self.category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let computationId = self.computationId {
            try encodeContainer.encode(computationId, forKey: .computationId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if resultSize != 0 {
            try encodeContainer.encode(resultSize, forKey: .resultSize)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .computationId)
        computationId = computationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DimensionField.self, forKey: .category)
        category = categoryDecoded
        let valueDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.MeasureField.self, forKey: .value)
        value = valueDecoded
        let resultSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .resultSize) ?? 0
        resultSize = resultSizeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TopBottomComputationType.self, forKey: .type)
        type = typeDecoded
    }
}

extension QuickSightClientTypes {
    /// The top ranked and bottom ranked computation configuration.
    public struct TopBottomRankedComputation: Swift.Equatable {
        /// The category field that is used in a computation.
        /// This member is required.
        public var category: QuickSightClientTypes.DimensionField?
        /// The ID for a computation.
        /// This member is required.
        public var computationId: Swift.String?
        /// The name of a computation.
        public var name: Swift.String?
        /// The result size of a top and bottom ranked computation.
        public var resultSize: Swift.Int
        /// The computation type. Choose one of the following options:
        ///
        /// * TOP: A top ranked computation.
        ///
        /// * BOTTOM: A bottom ranked computation.
        /// This member is required.
        public var type: QuickSightClientTypes.TopBottomComputationType?
        /// The value field that is used in a computation.
        public var value: QuickSightClientTypes.MeasureField?

        public init (
            category: QuickSightClientTypes.DimensionField? = nil,
            computationId: Swift.String? = nil,
            name: Swift.String? = nil,
            resultSize: Swift.Int = 0,
            type: QuickSightClientTypes.TopBottomComputationType? = nil,
            value: QuickSightClientTypes.MeasureField? = nil
        )
        {
            self.category = category
            self.computationId = computationId
            self.name = name
            self.resultSize = resultSize
            self.type = type
            self.value = value
        }
    }

}

extension QuickSightClientTypes {
    public enum TopBottomSortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case absoluteDifference
        case percentDifference
        case sdkUnknown(Swift.String)

        public static var allCases: [TopBottomSortOrder] {
            return [
                .absoluteDifference,
                .percentDifference,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .absoluteDifference: return "ABSOLUTE_DIFFERENCE"
            case .percentDifference: return "PERCENT_DIFFERENCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TopBottomSortOrder(rawValue: rawValue) ?? TopBottomSortOrder.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.TotalAggregationComputation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computationId = "ComputationId"
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computationId = self.computationId {
            try encodeContainer.encode(computationId, forKey: .computationId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .computationId)
        computationId = computationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.MeasureField.self, forKey: .value)
        value = valueDecoded
    }
}

extension QuickSightClientTypes {
    /// The total aggregation computation configuration.
    public struct TotalAggregationComputation: Swift.Equatable {
        /// The ID for a computation.
        /// This member is required.
        public var computationId: Swift.String?
        /// The name of a computation.
        public var name: Swift.String?
        /// The value field that is used in a computation.
        /// This member is required.
        public var value: QuickSightClientTypes.MeasureField?

        public init (
            computationId: Swift.String? = nil,
            name: Swift.String? = nil,
            value: QuickSightClientTypes.MeasureField? = nil
        )
        {
            self.computationId = computationId
            self.name = name
            self.value = value
        }
    }

}

extension QuickSightClientTypes.TotalOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customLabel = "CustomLabel"
        case placement = "Placement"
        case scrollStatus = "ScrollStatus"
        case totalCellStyle = "TotalCellStyle"
        case totalsVisibility = "TotalsVisibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customLabel = self.customLabel {
            try encodeContainer.encode(customLabel, forKey: .customLabel)
        }
        if let placement = self.placement {
            try encodeContainer.encode(placement.rawValue, forKey: .placement)
        }
        if let scrollStatus = self.scrollStatus {
            try encodeContainer.encode(scrollStatus.rawValue, forKey: .scrollStatus)
        }
        if let totalCellStyle = self.totalCellStyle {
            try encodeContainer.encode(totalCellStyle, forKey: .totalCellStyle)
        }
        if let totalsVisibility = self.totalsVisibility {
            try encodeContainer.encode(totalsVisibility.rawValue, forKey: .totalsVisibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalsVisibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .totalsVisibility)
        totalsVisibility = totalsVisibilityDecoded
        let placementDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableTotalsPlacement.self, forKey: .placement)
        placement = placementDecoded
        let scrollStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableTotalsScrollStatus.self, forKey: .scrollStatus)
        scrollStatus = scrollStatusDecoded
        let customLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customLabel)
        customLabel = customLabelDecoded
        let totalCellStyleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableCellStyle.self, forKey: .totalCellStyle)
        totalCellStyle = totalCellStyleDecoded
    }
}

extension QuickSightClientTypes {
    /// The total options for a table visual.
    public struct TotalOptions: Swift.Equatable {
        /// The custom label string for the total cells.
        public var customLabel: Swift.String?
        /// The placement (start, end) for the total cells.
        public var placement: QuickSightClientTypes.TableTotalsPlacement?
        /// The scroll status (pinned, scrolled) for the total cells.
        public var scrollStatus: QuickSightClientTypes.TableTotalsScrollStatus?
        /// Cell styling options for the total cells.
        public var totalCellStyle: QuickSightClientTypes.TableCellStyle?
        /// The visibility configuration for the total cells.
        public var totalsVisibility: QuickSightClientTypes.Visibility?

        public init (
            customLabel: Swift.String? = nil,
            placement: QuickSightClientTypes.TableTotalsPlacement? = nil,
            scrollStatus: QuickSightClientTypes.TableTotalsScrollStatus? = nil,
            totalCellStyle: QuickSightClientTypes.TableCellStyle? = nil,
            totalsVisibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.customLabel = customLabel
            self.placement = placement
            self.scrollStatus = scrollStatus
            self.totalCellStyle = totalCellStyle
            self.totalsVisibility = totalsVisibility
        }
    }

}

extension QuickSightClientTypes.TransformOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case castcolumntypeoperation = "CastColumnTypeOperation"
        case createcolumnsoperation = "CreateColumnsOperation"
        case filteroperation = "FilterOperation"
        case projectoperation = "ProjectOperation"
        case renamecolumnoperation = "RenameColumnOperation"
        case tagcolumnoperation = "TagColumnOperation"
        case untagcolumnoperation = "UntagColumnOperation"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .castcolumntypeoperation(castcolumntypeoperation):
                try container.encode(castcolumntypeoperation, forKey: .castcolumntypeoperation)
            case let .createcolumnsoperation(createcolumnsoperation):
                try container.encode(createcolumnsoperation, forKey: .createcolumnsoperation)
            case let .filteroperation(filteroperation):
                try container.encode(filteroperation, forKey: .filteroperation)
            case let .projectoperation(projectoperation):
                try container.encode(projectoperation, forKey: .projectoperation)
            case let .renamecolumnoperation(renamecolumnoperation):
                try container.encode(renamecolumnoperation, forKey: .renamecolumnoperation)
            case let .tagcolumnoperation(tagcolumnoperation):
                try container.encode(tagcolumnoperation, forKey: .tagcolumnoperation)
            case let .untagcolumnoperation(untagcolumnoperation):
                try container.encode(untagcolumnoperation, forKey: .untagcolumnoperation)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let projectoperationDecoded = try values.decodeIfPresent(QuickSightClientTypes.ProjectOperation.self, forKey: .projectoperation)
        if let projectoperation = projectoperationDecoded {
            self = .projectoperation(projectoperation)
            return
        }
        let filteroperationDecoded = try values.decodeIfPresent(QuickSightClientTypes.FilterOperation.self, forKey: .filteroperation)
        if let filteroperation = filteroperationDecoded {
            self = .filteroperation(filteroperation)
            return
        }
        let createcolumnsoperationDecoded = try values.decodeIfPresent(QuickSightClientTypes.CreateColumnsOperation.self, forKey: .createcolumnsoperation)
        if let createcolumnsoperation = createcolumnsoperationDecoded {
            self = .createcolumnsoperation(createcolumnsoperation)
            return
        }
        let renamecolumnoperationDecoded = try values.decodeIfPresent(QuickSightClientTypes.RenameColumnOperation.self, forKey: .renamecolumnoperation)
        if let renamecolumnoperation = renamecolumnoperationDecoded {
            self = .renamecolumnoperation(renamecolumnoperation)
            return
        }
        let castcolumntypeoperationDecoded = try values.decodeIfPresent(QuickSightClientTypes.CastColumnTypeOperation.self, forKey: .castcolumntypeoperation)
        if let castcolumntypeoperation = castcolumntypeoperationDecoded {
            self = .castcolumntypeoperation(castcolumntypeoperation)
            return
        }
        let tagcolumnoperationDecoded = try values.decodeIfPresent(QuickSightClientTypes.TagColumnOperation.self, forKey: .tagcolumnoperation)
        if let tagcolumnoperation = tagcolumnoperationDecoded {
            self = .tagcolumnoperation(tagcolumnoperation)
            return
        }
        let untagcolumnoperationDecoded = try values.decodeIfPresent(QuickSightClientTypes.UntagColumnOperation.self, forKey: .untagcolumnoperation)
        if let untagcolumnoperation = untagcolumnoperationDecoded {
            self = .untagcolumnoperation(untagcolumnoperation)
            return
        }
        self = .sdkUnknown("")
    }
}

extension QuickSightClientTypes {
    /// A data transformation on a logical table. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
    public enum TransformOperation: Swift.Equatable {
        /// An operation that projects columns. Operations that come after a projection can only refer to projected columns.
        case projectoperation(QuickSightClientTypes.ProjectOperation)
        /// An operation that filters rows based on some condition.
        case filteroperation(QuickSightClientTypes.FilterOperation)
        /// An operation that creates calculated columns. Columns created in one such operation form a lexical closure.
        case createcolumnsoperation(QuickSightClientTypes.CreateColumnsOperation)
        /// An operation that renames a column.
        case renamecolumnoperation(QuickSightClientTypes.RenameColumnOperation)
        /// A transform operation that casts a column to a different type.
        case castcolumntypeoperation(QuickSightClientTypes.CastColumnTypeOperation)
        /// An operation that tags a column with additional information.
        case tagcolumnoperation(QuickSightClientTypes.TagColumnOperation)
        /// A transform operation that removes tags associated with a column.
        case untagcolumnoperation(QuickSightClientTypes.UntagColumnOperation)
        case sdkUnknown(Swift.String)
    }

}

extension QuickSightClientTypes.TreeMapAggregatedFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case colors = "Colors"
        case groups = "Groups"
        case sizes = "Sizes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let colors = colors {
            var colorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .colors)
            for measurefield0 in colors {
                try colorsContainer.encode(measurefield0)
            }
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for dimensionfield0 in groups {
                try groupsContainer.encode(dimensionfield0)
            }
        }
        if let sizes = sizes {
            var sizesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sizes)
            for measurefield0 in sizes {
                try sizesContainer.encode(measurefield0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .groups)
        var groupsDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let sizesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .sizes)
        var sizesDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let sizesContainer = sizesContainer {
            sizesDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in sizesContainer {
                if let structure0 = structure0 {
                    sizesDecoded0?.append(structure0)
                }
            }
        }
        sizes = sizesDecoded0
        let colorsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .colors)
        var colorsDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let colorsContainer = colorsContainer {
            colorsDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in colorsContainer {
                if let structure0 = structure0 {
                    colorsDecoded0?.append(structure0)
                }
            }
        }
        colors = colorsDecoded0
    }
}

extension QuickSightClientTypes {
    /// Aggregated field wells of a tree map.
    public struct TreeMapAggregatedFieldWells: Swift.Equatable {
        /// The color field well of a tree map. Values are grouped by aggregations based on group by fields.
        public var colors: [QuickSightClientTypes.MeasureField]?
        /// The group by field well of a tree map. Values are grouped based on group by fields.
        public var groups: [QuickSightClientTypes.DimensionField]?
        /// The size field well of a tree map. Values are aggregated based on group by fields.
        public var sizes: [QuickSightClientTypes.MeasureField]?

        public init (
            colors: [QuickSightClientTypes.MeasureField]? = nil,
            groups: [QuickSightClientTypes.DimensionField]? = nil,
            sizes: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.colors = colors
            self.groups = groups
            self.sizes = sizes
        }
    }

}

extension QuickSightClientTypes.TreeMapConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case colorLabelOptions = "ColorLabelOptions"
        case colorScale = "ColorScale"
        case dataLabels = "DataLabels"
        case fieldWells = "FieldWells"
        case groupLabelOptions = "GroupLabelOptions"
        case legend = "Legend"
        case sizeLabelOptions = "SizeLabelOptions"
        case sortConfiguration = "SortConfiguration"
        case tooltip = "Tooltip"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let colorLabelOptions = self.colorLabelOptions {
            try encodeContainer.encode(colorLabelOptions, forKey: .colorLabelOptions)
        }
        if let colorScale = self.colorScale {
            try encodeContainer.encode(colorScale, forKey: .colorScale)
        }
        if let dataLabels = self.dataLabels {
            try encodeContainer.encode(dataLabels, forKey: .dataLabels)
        }
        if let fieldWells = self.fieldWells {
            try encodeContainer.encode(fieldWells, forKey: .fieldWells)
        }
        if let groupLabelOptions = self.groupLabelOptions {
            try encodeContainer.encode(groupLabelOptions, forKey: .groupLabelOptions)
        }
        if let legend = self.legend {
            try encodeContainer.encode(legend, forKey: .legend)
        }
        if let sizeLabelOptions = self.sizeLabelOptions {
            try encodeContainer.encode(sizeLabelOptions, forKey: .sizeLabelOptions)
        }
        if let sortConfiguration = self.sortConfiguration {
            try encodeContainer.encode(sortConfiguration, forKey: .sortConfiguration)
        }
        if let tooltip = self.tooltip {
            try encodeContainer.encode(tooltip, forKey: .tooltip)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TreeMapFieldWells.self, forKey: .fieldWells)
        fieldWells = fieldWellsDecoded
        let sortConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TreeMapSortConfiguration.self, forKey: .sortConfiguration)
        sortConfiguration = sortConfigurationDecoded
        let groupLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .groupLabelOptions)
        groupLabelOptions = groupLabelOptionsDecoded
        let sizeLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .sizeLabelOptions)
        sizeLabelOptions = sizeLabelOptionsDecoded
        let colorLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .colorLabelOptions)
        colorLabelOptions = colorLabelOptionsDecoded
        let colorScaleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColorScale.self, forKey: .colorScale)
        colorScale = colorScaleDecoded
        let legendDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LegendOptions.self, forKey: .legend)
        legend = legendDecoded
        let dataLabelsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataLabelOptions.self, forKey: .dataLabels)
        dataLabels = dataLabelsDecoded
        let tooltipDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TooltipOptions.self, forKey: .tooltip)
        tooltip = tooltipDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of a tree map.
    public struct TreeMapConfiguration: Swift.Equatable {
        /// The label options (label text, label visibility) for the colors displayed in a tree map.
        public var colorLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The color options (gradient color, point of divergence) of a tree map.
        public var colorScale: QuickSightClientTypes.ColorScale?
        /// The options that determine if visual data labels are displayed.
        public var dataLabels: QuickSightClientTypes.DataLabelOptions?
        /// The field wells of the visual.
        public var fieldWells: QuickSightClientTypes.TreeMapFieldWells?
        /// The label options (label text, label visibility) of the groups that are displayed in a tree map.
        public var groupLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The legend display setup of the visual.
        public var legend: QuickSightClientTypes.LegendOptions?
        /// The label options (label text, label visibility) of the sizes that are displayed in a tree map.
        public var sizeLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The sort configuration of a tree map.
        public var sortConfiguration: QuickSightClientTypes.TreeMapSortConfiguration?
        /// The tooltip display setup of the visual.
        public var tooltip: QuickSightClientTypes.TooltipOptions?

        public init (
            colorLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            colorScale: QuickSightClientTypes.ColorScale? = nil,
            dataLabels: QuickSightClientTypes.DataLabelOptions? = nil,
            fieldWells: QuickSightClientTypes.TreeMapFieldWells? = nil,
            groupLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            legend: QuickSightClientTypes.LegendOptions? = nil,
            sizeLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            sortConfiguration: QuickSightClientTypes.TreeMapSortConfiguration? = nil,
            tooltip: QuickSightClientTypes.TooltipOptions? = nil
        )
        {
            self.colorLabelOptions = colorLabelOptions
            self.colorScale = colorScale
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.groupLabelOptions = groupLabelOptions
            self.legend = legend
            self.sizeLabelOptions = sizeLabelOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
        }
    }

}

extension QuickSightClientTypes.TreeMapFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case treeMapAggregatedFieldWells = "TreeMapAggregatedFieldWells"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let treeMapAggregatedFieldWells = self.treeMapAggregatedFieldWells {
            try encodeContainer.encode(treeMapAggregatedFieldWells, forKey: .treeMapAggregatedFieldWells)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let treeMapAggregatedFieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TreeMapAggregatedFieldWells.self, forKey: .treeMapAggregatedFieldWells)
        treeMapAggregatedFieldWells = treeMapAggregatedFieldWellsDecoded
    }
}

extension QuickSightClientTypes {
    /// The field wells of a tree map. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct TreeMapFieldWells: Swift.Equatable {
        /// The aggregated field wells of a tree map.
        public var treeMapAggregatedFieldWells: QuickSightClientTypes.TreeMapAggregatedFieldWells?

        public init (
            treeMapAggregatedFieldWells: QuickSightClientTypes.TreeMapAggregatedFieldWells? = nil
        )
        {
            self.treeMapAggregatedFieldWells = treeMapAggregatedFieldWells
        }
    }

}

extension QuickSightClientTypes.TreeMapSortConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case treeMapGroupItemsLimitConfiguration = "TreeMapGroupItemsLimitConfiguration"
        case treeMapSort = "TreeMapSort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let treeMapGroupItemsLimitConfiguration = self.treeMapGroupItemsLimitConfiguration {
            try encodeContainer.encode(treeMapGroupItemsLimitConfiguration, forKey: .treeMapGroupItemsLimitConfiguration)
        }
        if let treeMapSort = treeMapSort {
            var treeMapSortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .treeMapSort)
            for fieldsortoptions0 in treeMapSort {
                try treeMapSortContainer.encode(fieldsortoptions0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let treeMapSortContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FieldSortOptions?].self, forKey: .treeMapSort)
        var treeMapSortDecoded0:[QuickSightClientTypes.FieldSortOptions]? = nil
        if let treeMapSortContainer = treeMapSortContainer {
            treeMapSortDecoded0 = [QuickSightClientTypes.FieldSortOptions]()
            for structure0 in treeMapSortContainer {
                if let structure0 = structure0 {
                    treeMapSortDecoded0?.append(structure0)
                }
            }
        }
        treeMapSort = treeMapSortDecoded0
        let treeMapGroupItemsLimitConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ItemsLimitConfiguration.self, forKey: .treeMapGroupItemsLimitConfiguration)
        treeMapGroupItemsLimitConfiguration = treeMapGroupItemsLimitConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The sort configuration of a tree map.
    public struct TreeMapSortConfiguration: Swift.Equatable {
        /// The limit on the number of groups that are displayed.
        public var treeMapGroupItemsLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of group by fields.
        public var treeMapSort: [QuickSightClientTypes.FieldSortOptions]?

        public init (
            treeMapGroupItemsLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            treeMapSort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.treeMapGroupItemsLimitConfiguration = treeMapGroupItemsLimitConfiguration
            self.treeMapSort = treeMapSort
        }
    }

}

extension QuickSightClientTypes.TreeMapVisual: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case chartConfiguration = "ChartConfiguration"
        case columnHierarchies = "ColumnHierarchies"
        case subtitle = "Subtitle"
        case title = "Title"
        case visualId = "VisualId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for visualcustomaction0 in actions {
                try actionsContainer.encode(visualcustomaction0)
            }
        }
        if let chartConfiguration = self.chartConfiguration {
            try encodeContainer.encode(chartConfiguration, forKey: .chartConfiguration)
        }
        if let columnHierarchies = columnHierarchies {
            var columnHierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnHierarchies)
            for columnhierarchy0 in columnHierarchies {
                try columnHierarchiesContainer.encode(columnhierarchy0)
            }
        }
        if let subtitle = self.subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let visualId = self.visualId {
            try encodeContainer.encode(visualId, forKey: .visualId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visualIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visualId)
        visualId = visualIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualTitleLabelOptions.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualSubtitleLabelOptions.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let chartConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TreeMapConfiguration.self, forKey: .chartConfiguration)
        chartConfiguration = chartConfigurationDecoded
        let actionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.VisualCustomAction?].self, forKey: .actions)
        var actionsDecoded0:[QuickSightClientTypes.VisualCustomAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [QuickSightClientTypes.VisualCustomAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let columnHierarchiesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnHierarchy?].self, forKey: .columnHierarchies)
        var columnHierarchiesDecoded0:[QuickSightClientTypes.ColumnHierarchy]? = nil
        if let columnHierarchiesContainer = columnHierarchiesContainer {
            columnHierarchiesDecoded0 = [QuickSightClientTypes.ColumnHierarchy]()
            for structure0 in columnHierarchiesContainer {
                if let structure0 = structure0 {
                    columnHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        columnHierarchies = columnHierarchiesDecoded0
    }
}

extension QuickSightClientTypes {
    /// A tree map. For more information, see [Using tree maps](https://docs.aws.amazon.com/quicksight/latest/user/tree-map.html) in the Amazon QuickSight User Guide.
    public struct TreeMapVisual: Swift.Equatable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration settings of the visual.
        public var chartConfiguration: QuickSightClientTypes.TreeMapConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        /// This member is required.
        public var visualId: Swift.String?

        public init (
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.TreeMapConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }

}

extension QuickSightClientTypes.TrendArrowOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the presentation of trend arrows in a KPI visual.
    public struct TrendArrowOptions: Swift.Equatable {
        /// The visibility of the trend arrows.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.visibility = visibility
        }
    }

}

extension QuickSightClientTypes.TwitterParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxRows = "MaxRows"
        case query = "Query"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxRows != 0 {
            try encodeContainer.encode(maxRows, forKey: .maxRows)
        }
        if let query = self.query {
            try encodeContainer.encode(query, forKey: .query)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .query)
        query = queryDecoded
        let maxRowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRows) ?? 0
        maxRows = maxRowsDecoded
    }
}

extension QuickSightClientTypes {
    /// The parameters for Twitter.
    public struct TwitterParameters: Swift.Equatable {
        /// Maximum number of rows to query Twitter.
        /// This member is required.
        public var maxRows: Swift.Int
        /// Twitter query string.
        /// This member is required.
        public var query: Swift.String?

        public init (
            maxRows: Swift.Int = 0,
            query: Swift.String? = nil
        )
        {
            self.maxRows = maxRows
            self.query = query
        }
    }

}

extension QuickSightClientTypes.Typography: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fontFamilies = "FontFamilies"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fontFamilies = fontFamilies {
            var fontFamiliesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fontFamilies)
            for font0 in fontFamilies {
                try fontFamiliesContainer.encode(font0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fontFamiliesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.Font?].self, forKey: .fontFamilies)
        var fontFamiliesDecoded0:[QuickSightClientTypes.Font]? = nil
        if let fontFamiliesContainer = fontFamiliesContainer {
            fontFamiliesDecoded0 = [QuickSightClientTypes.Font]()
            for structure0 in fontFamiliesContainer {
                if let structure0 = structure0 {
                    fontFamiliesDecoded0?.append(structure0)
                }
            }
        }
        fontFamilies = fontFamiliesDecoded0
    }
}

extension QuickSightClientTypes {
    /// Determines the typography options.
    public struct Typography: Swift.Equatable {
        /// Determines the list of font families.
        public var fontFamilies: [QuickSightClientTypes.Font]?

        public init (
            fontFamilies: [QuickSightClientTypes.Font]? = nil
        )
        {
            self.fontFamilies = fontFamilies
        }
    }

}

extension QuickSightClientTypes.UIColorPalette: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accent = "Accent"
        case accentForeground = "AccentForeground"
        case danger = "Danger"
        case dangerForeground = "DangerForeground"
        case dimension = "Dimension"
        case dimensionForeground = "DimensionForeground"
        case measure = "Measure"
        case measureForeground = "MeasureForeground"
        case primaryBackground = "PrimaryBackground"
        case primaryForeground = "PrimaryForeground"
        case secondaryBackground = "SecondaryBackground"
        case secondaryForeground = "SecondaryForeground"
        case success = "Success"
        case successForeground = "SuccessForeground"
        case warning = "Warning"
        case warningForeground = "WarningForeground"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accent = self.accent {
            try encodeContainer.encode(accent, forKey: .accent)
        }
        if let accentForeground = self.accentForeground {
            try encodeContainer.encode(accentForeground, forKey: .accentForeground)
        }
        if let danger = self.danger {
            try encodeContainer.encode(danger, forKey: .danger)
        }
        if let dangerForeground = self.dangerForeground {
            try encodeContainer.encode(dangerForeground, forKey: .dangerForeground)
        }
        if let dimension = self.dimension {
            try encodeContainer.encode(dimension, forKey: .dimension)
        }
        if let dimensionForeground = self.dimensionForeground {
            try encodeContainer.encode(dimensionForeground, forKey: .dimensionForeground)
        }
        if let measure = self.measure {
            try encodeContainer.encode(measure, forKey: .measure)
        }
        if let measureForeground = self.measureForeground {
            try encodeContainer.encode(measureForeground, forKey: .measureForeground)
        }
        if let primaryBackground = self.primaryBackground {
            try encodeContainer.encode(primaryBackground, forKey: .primaryBackground)
        }
        if let primaryForeground = self.primaryForeground {
            try encodeContainer.encode(primaryForeground, forKey: .primaryForeground)
        }
        if let secondaryBackground = self.secondaryBackground {
            try encodeContainer.encode(secondaryBackground, forKey: .secondaryBackground)
        }
        if let secondaryForeground = self.secondaryForeground {
            try encodeContainer.encode(secondaryForeground, forKey: .secondaryForeground)
        }
        if let success = self.success {
            try encodeContainer.encode(success, forKey: .success)
        }
        if let successForeground = self.successForeground {
            try encodeContainer.encode(successForeground, forKey: .successForeground)
        }
        if let warning = self.warning {
            try encodeContainer.encode(warning, forKey: .warning)
        }
        if let warningForeground = self.warningForeground {
            try encodeContainer.encode(warningForeground, forKey: .warningForeground)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryForegroundDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryForeground)
        primaryForeground = primaryForegroundDecoded
        let primaryBackgroundDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryBackground)
        primaryBackground = primaryBackgroundDecoded
        let secondaryForegroundDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secondaryForeground)
        secondaryForeground = secondaryForegroundDecoded
        let secondaryBackgroundDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secondaryBackground)
        secondaryBackground = secondaryBackgroundDecoded
        let accentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accent)
        accent = accentDecoded
        let accentForegroundDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accentForeground)
        accentForeground = accentForegroundDecoded
        let dangerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .danger)
        danger = dangerDecoded
        let dangerForegroundDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dangerForeground)
        dangerForeground = dangerForegroundDecoded
        let warningDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .warning)
        warning = warningDecoded
        let warningForegroundDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .warningForeground)
        warningForeground = warningForegroundDecoded
        let successDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .success)
        success = successDecoded
        let successForegroundDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .successForeground)
        successForeground = successForegroundDecoded
        let dimensionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimension)
        dimension = dimensionDecoded
        let dimensionForegroundDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimensionForeground)
        dimensionForeground = dimensionForegroundDecoded
        let measureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .measure)
        measure = measureDecoded
        let measureForegroundDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .measureForeground)
        measureForeground = measureForegroundDecoded
    }
}

extension QuickSightClientTypes {
    /// The theme colors that apply to UI and to charts, excluding data colors. The colors description is a hexadecimal color code that consists of six alphanumerical characters, prefixed with #, for example #37BFF5. For more information, see [Using Themes in Amazon QuickSight](https://docs.aws.amazon.com/quicksight/latest/user/themes-in-quicksight.html) in the Amazon QuickSight User Guide.
    public struct UIColorPalette: Swift.Equatable {
        /// This color is that applies to selected states and buttons.
        public var accent: Swift.String?
        /// The foreground color that applies to any text or other elements that appear over the accent color.
        public var accentForeground: Swift.String?
        /// The color that applies to error messages.
        public var danger: Swift.String?
        /// The foreground color that applies to any text or other elements that appear over the error color.
        public var dangerForeground: Swift.String?
        /// The color that applies to the names of fields that are identified as dimensions.
        public var dimension: Swift.String?
        /// The foreground color that applies to any text or other elements that appear over the dimension color.
        public var dimensionForeground: Swift.String?
        /// The color that applies to the names of fields that are identified as measures.
        public var measure: Swift.String?
        /// The foreground color that applies to any text or other elements that appear over the measure color.
        public var measureForeground: Swift.String?
        /// The background color that applies to visuals and other high emphasis UI.
        public var primaryBackground: Swift.String?
        /// The color of text and other foreground elements that appear over the primary background regions, such as grid lines, borders, table banding, icons, and so on.
        public var primaryForeground: Swift.String?
        /// The background color that applies to the sheet background and sheet controls.
        public var secondaryBackground: Swift.String?
        /// The foreground color that applies to any sheet title, sheet control text, or UI that appears over the secondary background.
        public var secondaryForeground: Swift.String?
        /// The color that applies to success messages, for example the check mark for a successful download.
        public var success: Swift.String?
        /// The foreground color that applies to any text or other elements that appear over the success color.
        public var successForeground: Swift.String?
        /// This color that applies to warning and informational messages.
        public var warning: Swift.String?
        /// The foreground color that applies to any text or other elements that appear over the warning color.
        public var warningForeground: Swift.String?

        public init (
            accent: Swift.String? = nil,
            accentForeground: Swift.String? = nil,
            danger: Swift.String? = nil,
            dangerForeground: Swift.String? = nil,
            dimension: Swift.String? = nil,
            dimensionForeground: Swift.String? = nil,
            measure: Swift.String? = nil,
            measureForeground: Swift.String? = nil,
            primaryBackground: Swift.String? = nil,
            primaryForeground: Swift.String? = nil,
            secondaryBackground: Swift.String? = nil,
            secondaryForeground: Swift.String? = nil,
            success: Swift.String? = nil,
            successForeground: Swift.String? = nil,
            warning: Swift.String? = nil,
            warningForeground: Swift.String? = nil
        )
        {
            self.accent = accent
            self.accentForeground = accentForeground
            self.danger = danger
            self.dangerForeground = dangerForeground
            self.dimension = dimension
            self.dimensionForeground = dimensionForeground
            self.measure = measure
            self.measureForeground = measureForeground
            self.primaryBackground = primaryBackground
            self.primaryForeground = primaryForeground
            self.secondaryBackground = secondaryBackground
            self.secondaryForeground = secondaryForeground
            self.success = success
            self.successForeground = successForeground
            self.warning = warning
            self.warningForeground = warningForeground
        }
    }

}

extension QuickSightClientTypes {
    public enum URLTargetConfiguration: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case newTab
        case newWindow
        case sameTab
        case sdkUnknown(Swift.String)

        public static var allCases: [URLTargetConfiguration] {
            return [
                .newTab,
                .newWindow,
                .sameTab,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .newTab: return "NEW_TAB"
            case .newWindow: return "NEW_WINDOW"
            case .sameTab: return "SAME_TAB"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = URLTargetConfiguration(rawValue: rawValue) ?? URLTargetConfiguration.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.UnaggregatedField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case column = "Column"
        case fieldId = "FieldId"
        case formatConfiguration = "FormatConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let column = self.column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
        if let formatConfiguration = self.formatConfiguration {
            try encodeContainer.encode(formatConfiguration, forKey: .formatConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let columnDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ColumnIdentifier.self, forKey: .column)
        column = columnDecoded
        let formatConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FormatConfiguration.self, forKey: .formatConfiguration)
        formatConfiguration = formatConfigurationDecoded
    }
}

extension QuickSightClientTypes {
    /// The unaggregated field for a table.
    public struct UnaggregatedField: Swift.Equatable {
        /// The column that is used in the UnaggregatedField.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The custom field ID.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The format configuration of the field.
        public var formatConfiguration: QuickSightClientTypes.FormatConfiguration?

        public init (
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            fieldId: Swift.String? = nil,
            formatConfiguration: QuickSightClientTypes.FormatConfiguration? = nil
        )
        {
            self.column = column
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
        }
    }

}

extension QuickSightClientTypes.UniqueValuesComputation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category = "Category"
        case computationId = "ComputationId"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = self.category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let computationId = self.computationId {
            try encodeContainer.encode(computationId, forKey: .computationId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .computationId)
        computationId = computationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DimensionField.self, forKey: .category)
        category = categoryDecoded
    }
}

extension QuickSightClientTypes {
    /// The unique values computation configuration.
    public struct UniqueValuesComputation: Swift.Equatable {
        /// The category field that is used in a computation.
        /// This member is required.
        public var category: QuickSightClientTypes.DimensionField?
        /// The ID for a computation.
        /// This member is required.
        public var computationId: Swift.String?
        /// The name of a computation.
        public var name: Swift.String?

        public init (
            category: QuickSightClientTypes.DimensionField? = nil,
            computationId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.category = category
            self.computationId = computationId
            self.name = name
        }
    }

}

extension UnsupportedPricingPlanException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnsupportedPricingPlanExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This error indicates that you are calling an embedding operation in Amazon QuickSight without the required pricing plan on your Amazon Web Services account. Before you can use embedding for anonymous users, a QuickSight administrator needs to add capacity pricing to Amazon QuickSight. You can do this on the Manage Amazon QuickSight page. After capacity pricing is added, you can use the [GetDashboardEmbedUrl](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_GetDashboardEmbedUrl.html) API operation with the --identity-type ANONYMOUS option.
public struct UnsupportedPricingPlanException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct UnsupportedPricingPlanExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension UnsupportedPricingPlanExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UnsupportedUserEditionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnsupportedUserEditionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This error indicates that you are calling an operation on an Amazon QuickSight subscription where the edition doesn't include support for that operation. Amazon Amazon QuickSight currently has Standard Edition and Enterprise Edition. Not every operation and capability is available in every edition.
public struct UnsupportedUserEditionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The Amazon Web Services request ID for this request.
    public var requestId: Swift.String?

    public init (
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.message = message
        self.requestId = requestId
    }
}

struct UnsupportedUserEditionExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension UnsupportedUserEditionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension QuickSightClientTypes.UntagColumnOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnName = "ColumnName"
        case tagNames = "TagNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnName = self.columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let tagNames = tagNames {
            var tagNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagNames)
            for columntagname0 in tagNames {
                try tagNamesContainer.encode(columntagname0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let tagNamesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnTagName?].self, forKey: .tagNames)
        var tagNamesDecoded0:[QuickSightClientTypes.ColumnTagName]? = nil
        if let tagNamesContainer = tagNamesContainer {
            tagNamesDecoded0 = [QuickSightClientTypes.ColumnTagName]()
            for enum0 in tagNamesContainer {
                if let enum0 = enum0 {
                    tagNamesDecoded0?.append(enum0)
                }
            }
        }
        tagNames = tagNamesDecoded0
    }
}

extension QuickSightClientTypes {
    /// A transform operation that removes tags associated with a column.
    public struct UntagColumnOperation: Swift.Equatable {
        /// The column that this operation acts on.
        /// This member is required.
        public var columnName: Swift.String?
        /// The column tags to remove from this column.
        /// This member is required.
        public var tagNames: [QuickSightClientTypes.ColumnTagName]?

        public init (
            columnName: Swift.String? = nil,
            tagNames: [QuickSightClientTypes.ColumnTagName]? = nil
        )
        {
            self.columnName = columnName
            self.tagNames = tagNames
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "keys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/resources/\(resourceArn.urlPercentEncoding())/tags"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the key-value pairs for the resource tag or tags assigned to the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UntagResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UntagResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension UpdateAccountCustomizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountCustomization = "AccountCustomization"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountCustomization = self.accountCustomization {
            try encodeContainer.encode(accountCustomization, forKey: .accountCustomization)
        }
    }
}

extension UpdateAccountCustomizationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let namespace = namespace {
                let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
                items.append(namespaceQueryItem)
            }
            return items
        }
    }
}

extension UpdateAccountCustomizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/customizations"
    }
}

public struct UpdateAccountCustomizationInput: Swift.Equatable {
    /// The Amazon QuickSight customizations you're updating in the current Amazon Web Services Region.
    /// This member is required.
    public var accountCustomization: QuickSightClientTypes.AccountCustomization?
    /// The ID for the Amazon Web Services account that you want to update Amazon QuickSight customizations for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace that you want to update Amazon QuickSight customizations for.
    public var namespace: Swift.String?

    public init (
        accountCustomization: QuickSightClientTypes.AccountCustomization? = nil,
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.accountCustomization = accountCustomization
        self.awsAccountId = awsAccountId
        self.namespace = namespace
    }
}

struct UpdateAccountCustomizationInputBody: Swift.Equatable {
    let accountCustomization: QuickSightClientTypes.AccountCustomization?
}

extension UpdateAccountCustomizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountCustomization = "AccountCustomization"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountCustomizationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AccountCustomization.self, forKey: .accountCustomization)
        accountCustomization = accountCustomizationDecoded
    }
}

extension UpdateAccountCustomizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAccountCustomizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAccountCustomizationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccountCustomizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateAccountCustomizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountCustomization = output.accountCustomization
            self.arn = output.arn
            self.awsAccountId = output.awsAccountId
            self.namespace = output.namespace
            self.requestId = output.requestId
        } else {
            self.accountCustomization = nil
            self.arn = nil
            self.awsAccountId = nil
            self.namespace = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateAccountCustomizationOutputResponse: Swift.Equatable {
    /// The Amazon QuickSight customizations you're updating in the current Amazon Web Services Region.
    public var accountCustomization: QuickSightClientTypes.AccountCustomization?
    /// The Amazon Resource Name (ARN) for the updated customization for this Amazon Web Services account.
    public var arn: Swift.String?
    /// The ID for the Amazon Web Services account that you want to update Amazon QuickSight customizations for.
    public var awsAccountId: Swift.String?
    /// The namespace associated with the customization that you're updating.
    public var namespace: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        accountCustomization: QuickSightClientTypes.AccountCustomization? = nil,
        arn: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.accountCustomization = accountCustomization
        self.arn = arn
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateAccountCustomizationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let awsAccountId: Swift.String?
    let namespace: Swift.String?
    let accountCustomization: QuickSightClientTypes.AccountCustomization?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateAccountCustomizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountCustomization = "AccountCustomization"
        case arn = "Arn"
        case awsAccountId = "AwsAccountId"
        case namespace = "Namespace"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let accountCustomizationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AccountCustomization.self, forKey: .accountCustomization)
        accountCustomization = accountCustomizationDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension UpdateAccountSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultNamespace = "DefaultNamespace"
        case notificationEmail = "NotificationEmail"
        case terminationProtectionEnabled = "TerminationProtectionEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultNamespace = self.defaultNamespace {
            try encodeContainer.encode(defaultNamespace, forKey: .defaultNamespace)
        }
        if let notificationEmail = self.notificationEmail {
            try encodeContainer.encode(notificationEmail, forKey: .notificationEmail)
        }
        if terminationProtectionEnabled != false {
            try encodeContainer.encode(terminationProtectionEnabled, forKey: .terminationProtectionEnabled)
        }
    }
}

extension UpdateAccountSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/settings"
    }
}

public struct UpdateAccountSettingsInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the Amazon QuickSight settings that you want to list.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The default namespace for this Amazon Web Services account. Currently, the default is default. Identity and Access Management (IAM) users that register for the first time with Amazon QuickSight provide an email address that becomes associated with the default namespace.
    /// This member is required.
    public var defaultNamespace: Swift.String?
    /// The email address that you want Amazon QuickSight to send notifications to regarding your Amazon Web Services account or Amazon QuickSight subscription.
    public var notificationEmail: Swift.String?
    /// A boolean value that determines whether or not an Amazon QuickSight account can be deleted. A True value doesn't allow the account to be deleted and results in an error message if a user tries to make a DeleteAccountSubscription request. A False value will allow the account to be deleted.
    public var terminationProtectionEnabled: Swift.Bool

    public init (
        awsAccountId: Swift.String? = nil,
        defaultNamespace: Swift.String? = nil,
        notificationEmail: Swift.String? = nil,
        terminationProtectionEnabled: Swift.Bool = false
    )
    {
        self.awsAccountId = awsAccountId
        self.defaultNamespace = defaultNamespace
        self.notificationEmail = notificationEmail
        self.terminationProtectionEnabled = terminationProtectionEnabled
    }
}

struct UpdateAccountSettingsInputBody: Swift.Equatable {
    let defaultNamespace: Swift.String?
    let notificationEmail: Swift.String?
    let terminationProtectionEnabled: Swift.Bool
}

extension UpdateAccountSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultNamespace = "DefaultNamespace"
        case notificationEmail = "NotificationEmail"
        case terminationProtectionEnabled = "TerminationProtectionEnabled"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultNamespace)
        defaultNamespace = defaultNamespaceDecoded
        let notificationEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationEmail)
        notificationEmail = notificationEmailDecoded
        let terminationProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminationProtectionEnabled) ?? false
        terminationProtectionEnabled = terminationProtectionEnabledDecoded
    }
}

extension UpdateAccountSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAccountSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAccountSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccountSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateAccountSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateAccountSettingsOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateAccountSettingsOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateAccountSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension UpdateAnalysisInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition = "Definition"
        case name = "Name"
        case parameters = "Parameters"
        case sourceEntity = "SourceEntity"
        case themeArn = "ThemeArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = self.parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let sourceEntity = self.sourceEntity {
            try encodeContainer.encode(sourceEntity, forKey: .sourceEntity)
        }
        if let themeArn = self.themeArn {
            try encodeContainer.encode(themeArn, forKey: .themeArn)
        }
    }
}

extension UpdateAnalysisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let analysisId = analysisId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/analyses/\(analysisId.urlPercentEncoding())"
    }
}

public struct UpdateAnalysisInput: Swift.Equatable {
    /// The ID for the analysis that you're updating. This ID displays in the URL of the analysis.
    /// This member is required.
    public var analysisId: Swift.String?
    /// The ID of the Amazon Web Services account that contains the analysis that you're updating.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The definition of an analysis. A definition is the data model of all features in a Dashboard, Template, or Analysis.
    public var definition: QuickSightClientTypes.AnalysisDefinition?
    /// A descriptive name for the analysis that you're updating. This name displays for the analysis in the Amazon QuickSight console.
    /// This member is required.
    public var name: Swift.String?
    /// The parameter names and override values that you want to use. An analysis can have any parameter type, and some parameters might accept multiple values.
    public var parameters: QuickSightClientTypes.Parameters?
    /// A source entity to use for the analysis that you're updating. This metadata structure contains details that describe a source template and one or more datasets.
    public var sourceEntity: QuickSightClientTypes.AnalysisSourceEntity?
    /// The Amazon Resource Name (ARN) for the theme to apply to the analysis that you're creating. To see the theme in the Amazon QuickSight console, make sure that you have access to it.
    public var themeArn: Swift.String?

    public init (
        analysisId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        definition: QuickSightClientTypes.AnalysisDefinition? = nil,
        name: Swift.String? = nil,
        parameters: QuickSightClientTypes.Parameters? = nil,
        sourceEntity: QuickSightClientTypes.AnalysisSourceEntity? = nil,
        themeArn: Swift.String? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
        self.definition = definition
        self.name = name
        self.parameters = parameters
        self.sourceEntity = sourceEntity
        self.themeArn = themeArn
    }
}

struct UpdateAnalysisInputBody: Swift.Equatable {
    let name: Swift.String?
    let parameters: QuickSightClientTypes.Parameters?
    let sourceEntity: QuickSightClientTypes.AnalysisSourceEntity?
    let themeArn: Swift.String?
    let definition: QuickSightClientTypes.AnalysisDefinition?
}

extension UpdateAnalysisInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition = "Definition"
        case name = "Name"
        case parameters = "Parameters"
        case sourceEntity = "SourceEntity"
        case themeArn = "ThemeArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Parameters.self, forKey: .parameters)
        parameters = parametersDecoded
        let sourceEntityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AnalysisSourceEntity.self, forKey: .sourceEntity)
        sourceEntity = sourceEntityDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AnalysisDefinition.self, forKey: .definition)
        definition = definitionDecoded
    }
}

extension UpdateAnalysisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAnalysisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAnalysisOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAnalysisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisId = output.analysisId
            self.arn = output.arn
            self.requestId = output.requestId
            self.updateStatus = output.updateStatus
        } else {
            self.analysisId = nil
            self.arn = nil
            self.requestId = nil
            self.updateStatus = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateAnalysisOutputResponse: Swift.Equatable {
    /// The ID of the analysis.
    public var analysisId: Swift.String?
    /// The ARN of the analysis that you're updating.
    public var arn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The update status of the last update that was made to the analysis.
    public var updateStatus: QuickSightClientTypes.ResourceStatus?

    public init (
        analysisId: Swift.String? = nil,
        arn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        updateStatus: QuickSightClientTypes.ResourceStatus? = nil
    )
    {
        self.analysisId = analysisId
        self.arn = arn
        self.requestId = requestId
        self.status = status
        self.updateStatus = updateStatus
    }
}

struct UpdateAnalysisOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let analysisId: Swift.String?
    let updateStatus: QuickSightClientTypes.ResourceStatus?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension UpdateAnalysisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisId = "AnalysisId"
        case arn = "Arn"
        case requestId = "RequestId"
        case status = "Status"
        case updateStatus = "UpdateStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let analysisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
        let updateStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .updateStatus)
        updateStatus = updateStatusDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UpdateAnalysisPermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantPermissions = grantPermissions {
            var grantPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantPermissions)
            for resourcepermission0 in grantPermissions {
                try grantPermissionsContainer.encode(resourcepermission0)
            }
        }
        if let revokePermissions = revokePermissions {
            var revokePermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revokePermissions)
            for resourcepermission0 in revokePermissions {
                try revokePermissionsContainer.encode(resourcepermission0)
            }
        }
    }
}

extension UpdateAnalysisPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let analysisId = analysisId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/analyses/\(analysisId.urlPercentEncoding())/permissions"
    }
}

public struct UpdateAnalysisPermissionsInput: Swift.Equatable {
    /// The ID of the analysis whose permissions you're updating. The ID is part of the analysis URL.
    /// This member is required.
    public var analysisId: Swift.String?
    /// The ID of the Amazon Web Services account that contains the analysis whose permissions you're updating. You must be using the Amazon Web Services account that the analysis is in.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A structure that describes the permissions to add and the principal to add them to.
    public var grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// A structure that describes the permissions to remove and the principal to remove them from.
    public var revokePermissions: [QuickSightClientTypes.ResourcePermission]?

    public init (
        analysisId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        grantPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        revokePermissions: [QuickSightClientTypes.ResourcePermission]? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
        self.grantPermissions = grantPermissions
        self.revokePermissions = revokePermissions
    }
}

struct UpdateAnalysisPermissionsInputBody: Swift.Equatable {
    let grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    let revokePermissions: [QuickSightClientTypes.ResourcePermission]?
}

extension UpdateAnalysisPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantPermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .grantPermissions)
        var grantPermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let grantPermissionsContainer = grantPermissionsContainer {
            grantPermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in grantPermissionsContainer {
                if let structure0 = structure0 {
                    grantPermissionsDecoded0?.append(structure0)
                }
            }
        }
        grantPermissions = grantPermissionsDecoded0
        let revokePermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .revokePermissions)
        var revokePermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let revokePermissionsContainer = revokePermissionsContainer {
            revokePermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in revokePermissionsContainer {
                if let structure0 = structure0 {
                    revokePermissionsDecoded0?.append(structure0)
                }
            }
        }
        revokePermissions = revokePermissionsDecoded0
    }
}

extension UpdateAnalysisPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAnalysisPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAnalysisPermissionsOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAnalysisPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateAnalysisPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysisArn = output.analysisArn
            self.analysisId = output.analysisId
            self.permissions = output.permissions
            self.requestId = output.requestId
        } else {
            self.analysisArn = nil
            self.analysisId = nil
            self.permissions = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateAnalysisPermissionsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the analysis that you updated.
    public var analysisArn: Swift.String?
    /// The ID of the analysis that you updated permissions for.
    public var analysisId: Swift.String?
    /// A structure that describes the principals and the resource-level permissions on an analysis.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        analysisArn: Swift.String? = nil,
        analysisId: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.analysisArn = analysisArn
        self.analysisId = analysisId
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateAnalysisPermissionsOutputResponseBody: Swift.Equatable {
    let analysisArn: Swift.String?
    let analysisId: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateAnalysisPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisArn = "AnalysisArn"
        case analysisId = "AnalysisId"
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisArn)
        analysisArn = analysisArnDecoded
        let analysisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisId)
        analysisId = analysisIdDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension UpdateDashboardInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardPublishOptions = "DashboardPublishOptions"
        case definition = "Definition"
        case name = "Name"
        case parameters = "Parameters"
        case sourceEntity = "SourceEntity"
        case themeArn = "ThemeArn"
        case versionDescription = "VersionDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dashboardPublishOptions = self.dashboardPublishOptions {
            try encodeContainer.encode(dashboardPublishOptions, forKey: .dashboardPublishOptions)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = self.parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let sourceEntity = self.sourceEntity {
            try encodeContainer.encode(sourceEntity, forKey: .sourceEntity)
        }
        if let themeArn = self.themeArn {
            try encodeContainer.encode(themeArn, forKey: .themeArn)
        }
        if let versionDescription = self.versionDescription {
            try encodeContainer.encode(versionDescription, forKey: .versionDescription)
        }
    }
}

extension UpdateDashboardInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dashboardId = dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())"
    }
}

public struct UpdateDashboardInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the dashboard that you're updating.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// Options for publishing the dashboard when you create it:
    ///
    /// * AvailabilityStatus for AdHocFilteringOption - This status can be either ENABLED or DISABLED. When this is set to DISABLED, Amazon QuickSight disables the left filter pane on the published dashboard, which can be used for ad hoc (one-time) filtering. This option is ENABLED by default.
    ///
    /// * AvailabilityStatus for ExportToCSVOption - This status can be either ENABLED or DISABLED. The visual option to export data to .CSV format isn't enabled when this is set to DISABLED. This option is ENABLED by default.
    ///
    /// * VisibilityState for SheetControlsOption - This visibility state can be either COLLAPSED or EXPANDED. This option is COLLAPSED by default.
    public var dashboardPublishOptions: QuickSightClientTypes.DashboardPublishOptions?
    /// The definition of a dashboard. A definition is the data model of all features in a Dashboard, Template, or Analysis.
    public var definition: QuickSightClientTypes.DashboardVersionDefinition?
    /// The display name of the dashboard.
    /// This member is required.
    public var name: Swift.String?
    /// A structure that contains the parameters of the dashboard. These are parameter overrides for a dashboard. A dashboard can have any type of parameters, and some parameters might accept multiple values.
    public var parameters: QuickSightClientTypes.Parameters?
    /// The entity that you are using as a source when you update the dashboard. In SourceEntity, you specify the type of object you're using as source. You can only update a dashboard from a template, so you use a SourceTemplate entity. If you need to update a dashboard from an analysis, first convert the analysis to a template by using the [CreateTemplate](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_CreateTemplate.html) API operation. For SourceTemplate, specify the Amazon Resource Name (ARN) of the source template. The SourceTemplate ARN can contain any Amazon Web Services account and any Amazon QuickSight-supported Amazon Web Services Region. Use the DataSetReferences entity within SourceTemplate to list the replacement datasets for the placeholders listed in the original. The schema in each dataset must match its placeholder.
    public var sourceEntity: QuickSightClientTypes.DashboardSourceEntity?
    /// The Amazon Resource Name (ARN) of the theme that is being used for this dashboard. If you add a value for this field, it overrides the value that was originally associated with the entity. The theme ARN must exist in the same Amazon Web Services account where you create the dashboard.
    public var themeArn: Swift.String?
    /// A description for the first version of the dashboard being created.
    public var versionDescription: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        dashboardPublishOptions: QuickSightClientTypes.DashboardPublishOptions? = nil,
        definition: QuickSightClientTypes.DashboardVersionDefinition? = nil,
        name: Swift.String? = nil,
        parameters: QuickSightClientTypes.Parameters? = nil,
        sourceEntity: QuickSightClientTypes.DashboardSourceEntity? = nil,
        themeArn: Swift.String? = nil,
        versionDescription: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.dashboardPublishOptions = dashboardPublishOptions
        self.definition = definition
        self.name = name
        self.parameters = parameters
        self.sourceEntity = sourceEntity
        self.themeArn = themeArn
        self.versionDescription = versionDescription
    }
}

struct UpdateDashboardInputBody: Swift.Equatable {
    let name: Swift.String?
    let sourceEntity: QuickSightClientTypes.DashboardSourceEntity?
    let parameters: QuickSightClientTypes.Parameters?
    let versionDescription: Swift.String?
    let dashboardPublishOptions: QuickSightClientTypes.DashboardPublishOptions?
    let themeArn: Swift.String?
    let definition: QuickSightClientTypes.DashboardVersionDefinition?
}

extension UpdateDashboardInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardPublishOptions = "DashboardPublishOptions"
        case definition = "Definition"
        case name = "Name"
        case parameters = "Parameters"
        case sourceEntity = "SourceEntity"
        case themeArn = "ThemeArn"
        case versionDescription = "VersionDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceEntityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardSourceEntity.self, forKey: .sourceEntity)
        sourceEntity = sourceEntityDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Parameters.self, forKey: .parameters)
        parameters = parametersDecoded
        let versionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionDescription)
        versionDescription = versionDescriptionDecoded
        let dashboardPublishOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardPublishOptions.self, forKey: .dashboardPublishOptions)
        dashboardPublishOptions = dashboardPublishOptionsDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DashboardVersionDefinition.self, forKey: .definition)
        definition = definitionDecoded
    }
}

extension UpdateDashboardOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDashboardOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDashboardOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDashboardOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDashboardOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationStatus = output.creationStatus
            self.dashboardId = output.dashboardId
            self.requestId = output.requestId
            self.status = output.status
            self.versionArn = output.versionArn
        } else {
            self.arn = nil
            self.creationStatus = nil
            self.dashboardId = nil
            self.requestId = nil
            self.status = 0
            self.versionArn = nil
        }
    }
}

public struct UpdateDashboardOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    public var arn: Swift.String?
    /// The creation status of the request.
    public var creationStatus: QuickSightClientTypes.ResourceStatus?
    /// The ID for the dashboard.
    public var dashboardId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ARN of the dashboard, including the version number.
    public var versionArn: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.ResourceStatus? = nil,
        dashboardId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        versionArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.dashboardId = dashboardId
        self.requestId = requestId
        self.status = status
        self.versionArn = versionArn
    }
}

struct UpdateDashboardOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let versionArn: Swift.String?
    let dashboardId: Swift.String?
    let creationStatus: QuickSightClientTypes.ResourceStatus?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension UpdateDashboardOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationStatus = "CreationStatus"
        case dashboardId = "DashboardId"
        case requestId = "RequestId"
        case status = "Status"
        case versionArn = "VersionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionArn)
        versionArn = versionArnDecoded
        let dashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UpdateDashboardPermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantLinkPermissions = "GrantLinkPermissions"
        case grantPermissions = "GrantPermissions"
        case revokeLinkPermissions = "RevokeLinkPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantLinkPermissions = grantLinkPermissions {
            var grantLinkPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantLinkPermissions)
            for resourcepermission0 in grantLinkPermissions {
                try grantLinkPermissionsContainer.encode(resourcepermission0)
            }
        }
        if let grantPermissions = grantPermissions {
            var grantPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantPermissions)
            for resourcepermission0 in grantPermissions {
                try grantPermissionsContainer.encode(resourcepermission0)
            }
        }
        if let revokeLinkPermissions = revokeLinkPermissions {
            var revokeLinkPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revokeLinkPermissions)
            for resourcepermission0 in revokeLinkPermissions {
                try revokeLinkPermissionsContainer.encode(resourcepermission0)
            }
        }
        if let revokePermissions = revokePermissions {
            var revokePermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revokePermissions)
            for resourcepermission0 in revokePermissions {
                try revokePermissionsContainer.encode(resourcepermission0)
            }
        }
    }
}

extension UpdateDashboardPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dashboardId = dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())/permissions"
    }
}

public struct UpdateDashboardPermissionsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the dashboard whose permissions you're updating.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// Grants link permissions to all users in a defined namespace.
    public var grantLinkPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// The permissions that you want to grant on this resource.
    public var grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// Revokes link permissions from all users in a defined namespace.
    public var revokeLinkPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// The permissions that you want to revoke from this resource.
    public var revokePermissions: [QuickSightClientTypes.ResourcePermission]?

    public init (
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        grantLinkPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        grantPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        revokeLinkPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        revokePermissions: [QuickSightClientTypes.ResourcePermission]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.grantLinkPermissions = grantLinkPermissions
        self.grantPermissions = grantPermissions
        self.revokeLinkPermissions = revokeLinkPermissions
        self.revokePermissions = revokePermissions
    }
}

struct UpdateDashboardPermissionsInputBody: Swift.Equatable {
    let grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    let revokePermissions: [QuickSightClientTypes.ResourcePermission]?
    let grantLinkPermissions: [QuickSightClientTypes.ResourcePermission]?
    let revokeLinkPermissions: [QuickSightClientTypes.ResourcePermission]?
}

extension UpdateDashboardPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantLinkPermissions = "GrantLinkPermissions"
        case grantPermissions = "GrantPermissions"
        case revokeLinkPermissions = "RevokeLinkPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantPermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .grantPermissions)
        var grantPermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let grantPermissionsContainer = grantPermissionsContainer {
            grantPermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in grantPermissionsContainer {
                if let structure0 = structure0 {
                    grantPermissionsDecoded0?.append(structure0)
                }
            }
        }
        grantPermissions = grantPermissionsDecoded0
        let revokePermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .revokePermissions)
        var revokePermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let revokePermissionsContainer = revokePermissionsContainer {
            revokePermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in revokePermissionsContainer {
                if let structure0 = structure0 {
                    revokePermissionsDecoded0?.append(structure0)
                }
            }
        }
        revokePermissions = revokePermissionsDecoded0
        let grantLinkPermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .grantLinkPermissions)
        var grantLinkPermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let grantLinkPermissionsContainer = grantLinkPermissionsContainer {
            grantLinkPermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in grantLinkPermissionsContainer {
                if let structure0 = structure0 {
                    grantLinkPermissionsDecoded0?.append(structure0)
                }
            }
        }
        grantLinkPermissions = grantLinkPermissionsDecoded0
        let revokeLinkPermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .revokeLinkPermissions)
        var revokeLinkPermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let revokeLinkPermissionsContainer = revokeLinkPermissionsContainer {
            revokeLinkPermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in revokeLinkPermissionsContainer {
                if let structure0 = structure0 {
                    revokeLinkPermissionsDecoded0?.append(structure0)
                }
            }
        }
        revokeLinkPermissions = revokeLinkPermissionsDecoded0
    }
}

extension UpdateDashboardPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDashboardPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDashboardPermissionsOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDashboardPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDashboardPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dashboardArn = output.dashboardArn
            self.dashboardId = output.dashboardId
            self.linkSharingConfiguration = output.linkSharingConfiguration
            self.permissions = output.permissions
            self.requestId = output.requestId
        } else {
            self.dashboardArn = nil
            self.dashboardId = nil
            self.linkSharingConfiguration = nil
            self.permissions = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateDashboardPermissionsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dashboard.
    public var dashboardArn: Swift.String?
    /// The ID for the dashboard.
    public var dashboardId: Swift.String?
    /// Updates the permissions of a shared link to an Amazon QuickSight dashboard.
    public var linkSharingConfiguration: QuickSightClientTypes.LinkSharingConfiguration?
    /// Information about the permissions on the dashboard.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dashboardArn: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        linkSharingConfiguration: QuickSightClientTypes.LinkSharingConfiguration? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dashboardArn = dashboardArn
        self.dashboardId = dashboardId
        self.linkSharingConfiguration = linkSharingConfiguration
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateDashboardPermissionsOutputResponseBody: Swift.Equatable {
    let dashboardArn: Swift.String?
    let dashboardId: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let requestId: Swift.String?
    let status: Swift.Int
    let linkSharingConfiguration: QuickSightClientTypes.LinkSharingConfiguration?
}

extension UpdateDashboardPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardArn = "DashboardArn"
        case dashboardId = "DashboardId"
        case linkSharingConfiguration = "LinkSharingConfiguration"
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardArn)
        dashboardArn = dashboardArnDecoded
        let dashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let linkSharingConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LinkSharingConfiguration.self, forKey: .linkSharingConfiguration)
        linkSharingConfiguration = linkSharingConfigurationDecoded
    }
}

extension UpdateDashboardPublishedVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dashboardId = dashboardId else {
            return nil
        }
        guard let versionNumber = versionNumber else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())/versions/\(versionNumber)"
    }
}

public struct UpdateDashboardPublishedVersionInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the dashboard that you're updating.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// The version number of the dashboard.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init (
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.versionNumber = versionNumber
    }
}

struct UpdateDashboardPublishedVersionInputBody: Swift.Equatable {
}

extension UpdateDashboardPublishedVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UpdateDashboardPublishedVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDashboardPublishedVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDashboardPublishedVersionOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDashboardPublishedVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDashboardPublishedVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dashboardArn = output.dashboardArn
            self.dashboardId = output.dashboardId
            self.requestId = output.requestId
        } else {
            self.dashboardArn = nil
            self.dashboardId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateDashboardPublishedVersionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dashboard.
    public var dashboardArn: Swift.String?
    /// The ID for the dashboard.
    public var dashboardId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dashboardArn: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dashboardArn = dashboardArn
        self.dashboardId = dashboardId
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateDashboardPublishedVersionOutputResponseBody: Swift.Equatable {
    let dashboardId: Swift.String?
    let dashboardArn: Swift.String?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension UpdateDashboardPublishedVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardArn = "DashboardArn"
        case dashboardId = "DashboardId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let dashboardArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardArn)
        dashboardArn = dashboardArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UpdateDataSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnGroups = "ColumnGroups"
        case columnLevelPermissionRules = "ColumnLevelPermissionRules"
        case dataSetUsageConfiguration = "DataSetUsageConfiguration"
        case fieldFolders = "FieldFolders"
        case importMode = "ImportMode"
        case logicalTableMap = "LogicalTableMap"
        case name = "Name"
        case physicalTableMap = "PhysicalTableMap"
        case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
        case rowLevelPermissionTagConfiguration = "RowLevelPermissionTagConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnGroups = columnGroups {
            var columnGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnGroups)
            for columngroup0 in columnGroups {
                try columnGroupsContainer.encode(columngroup0)
            }
        }
        if let columnLevelPermissionRules = columnLevelPermissionRules {
            var columnLevelPermissionRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnLevelPermissionRules)
            for columnlevelpermissionrule0 in columnLevelPermissionRules {
                try columnLevelPermissionRulesContainer.encode(columnlevelpermissionrule0)
            }
        }
        if let dataSetUsageConfiguration = self.dataSetUsageConfiguration {
            try encodeContainer.encode(dataSetUsageConfiguration, forKey: .dataSetUsageConfiguration)
        }
        if let fieldFolders = fieldFolders {
            var fieldFoldersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .fieldFolders)
            for (dictKey0, fieldFolderMap0) in fieldFolders {
                try fieldFoldersContainer.encode(fieldFolderMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let importMode = self.importMode {
            try encodeContainer.encode(importMode.rawValue, forKey: .importMode)
        }
        if let logicalTableMap = logicalTableMap {
            var logicalTableMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .logicalTableMap)
            for (dictKey0, logicalTableMap0) in logicalTableMap {
                try logicalTableMapContainer.encode(logicalTableMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let physicalTableMap = physicalTableMap {
            var physicalTableMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .physicalTableMap)
            for (dictKey0, physicalTableMap0) in physicalTableMap {
                try physicalTableMapContainer.encode(physicalTableMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let rowLevelPermissionDataSet = self.rowLevelPermissionDataSet {
            try encodeContainer.encode(rowLevelPermissionDataSet, forKey: .rowLevelPermissionDataSet)
        }
        if let rowLevelPermissionTagConfiguration = self.rowLevelPermissionTagConfiguration {
            try encodeContainer.encode(rowLevelPermissionTagConfiguration, forKey: .rowLevelPermissionTagConfiguration)
        }
    }
}

extension UpdateDataSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSetId = dataSetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())"
    }
}

public struct UpdateDataSetInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// Groupings of columns that work together in certain Amazon QuickSight features. Currently, only geospatial hierarchy is supported.
    public var columnGroups: [QuickSightClientTypes.ColumnGroup]?
    /// A set of one or more definitions of a [ColumnLevelPermissionRule](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ColumnLevelPermissionRule.html).
    public var columnLevelPermissionRules: [QuickSightClientTypes.ColumnLevelPermissionRule]?
    /// The ID for the dataset that you want to update. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The usage configuration to apply to child datasets that reference this dataset as a source.
    public var dataSetUsageConfiguration: QuickSightClientTypes.DataSetUsageConfiguration?
    /// The folder that contains fields and nested subfolders for your dataset.
    public var fieldFolders: [Swift.String:QuickSightClientTypes.FieldFolder]?
    /// Indicates whether you want to import the data into SPICE.
    /// This member is required.
    public var importMode: QuickSightClientTypes.DataSetImportMode?
    /// Configures the combination and transformation of the data from the physical tables.
    public var logicalTableMap: [Swift.String:QuickSightClientTypes.LogicalTable]?
    /// The display name for the dataset.
    /// This member is required.
    public var name: Swift.String?
    /// Declares the physical tables that are available in the underlying data sources.
    /// This member is required.
    public var physicalTableMap: [Swift.String:QuickSightClientTypes.PhysicalTable]?
    /// The row-level security configuration for the data you want to create.
    public var rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet?
    /// The configuration of tags on a dataset to set row-level security. Row-level security tags are currently supported for anonymous embedding only.
    public var rowLevelPermissionTagConfiguration: QuickSightClientTypes.RowLevelPermissionTagConfiguration?

    public init (
        awsAccountId: Swift.String? = nil,
        columnGroups: [QuickSightClientTypes.ColumnGroup]? = nil,
        columnLevelPermissionRules: [QuickSightClientTypes.ColumnLevelPermissionRule]? = nil,
        dataSetId: Swift.String? = nil,
        dataSetUsageConfiguration: QuickSightClientTypes.DataSetUsageConfiguration? = nil,
        fieldFolders: [Swift.String:QuickSightClientTypes.FieldFolder]? = nil,
        importMode: QuickSightClientTypes.DataSetImportMode? = nil,
        logicalTableMap: [Swift.String:QuickSightClientTypes.LogicalTable]? = nil,
        name: Swift.String? = nil,
        physicalTableMap: [Swift.String:QuickSightClientTypes.PhysicalTable]? = nil,
        rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet? = nil,
        rowLevelPermissionTagConfiguration: QuickSightClientTypes.RowLevelPermissionTagConfiguration? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.columnGroups = columnGroups
        self.columnLevelPermissionRules = columnLevelPermissionRules
        self.dataSetId = dataSetId
        self.dataSetUsageConfiguration = dataSetUsageConfiguration
        self.fieldFolders = fieldFolders
        self.importMode = importMode
        self.logicalTableMap = logicalTableMap
        self.name = name
        self.physicalTableMap = physicalTableMap
        self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
        self.rowLevelPermissionTagConfiguration = rowLevelPermissionTagConfiguration
    }
}

struct UpdateDataSetInputBody: Swift.Equatable {
    let name: Swift.String?
    let physicalTableMap: [Swift.String:QuickSightClientTypes.PhysicalTable]?
    let logicalTableMap: [Swift.String:QuickSightClientTypes.LogicalTable]?
    let importMode: QuickSightClientTypes.DataSetImportMode?
    let columnGroups: [QuickSightClientTypes.ColumnGroup]?
    let fieldFolders: [Swift.String:QuickSightClientTypes.FieldFolder]?
    let rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet?
    let rowLevelPermissionTagConfiguration: QuickSightClientTypes.RowLevelPermissionTagConfiguration?
    let columnLevelPermissionRules: [QuickSightClientTypes.ColumnLevelPermissionRule]?
    let dataSetUsageConfiguration: QuickSightClientTypes.DataSetUsageConfiguration?
}

extension UpdateDataSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnGroups = "ColumnGroups"
        case columnLevelPermissionRules = "ColumnLevelPermissionRules"
        case dataSetUsageConfiguration = "DataSetUsageConfiguration"
        case fieldFolders = "FieldFolders"
        case importMode = "ImportMode"
        case logicalTableMap = "LogicalTableMap"
        case name = "Name"
        case physicalTableMap = "PhysicalTableMap"
        case rowLevelPermissionDataSet = "RowLevelPermissionDataSet"
        case rowLevelPermissionTagConfiguration = "RowLevelPermissionTagConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let physicalTableMapContainer = try containerValues.decodeIfPresent([Swift.String: QuickSightClientTypes.PhysicalTable?].self, forKey: .physicalTableMap)
        var physicalTableMapDecoded0: [Swift.String:QuickSightClientTypes.PhysicalTable]? = nil
        if let physicalTableMapContainer = physicalTableMapContainer {
            physicalTableMapDecoded0 = [Swift.String:QuickSightClientTypes.PhysicalTable]()
            for (key0, physicaltable0) in physicalTableMapContainer {
                if let physicaltable0 = physicaltable0 {
                    physicalTableMapDecoded0?[key0] = physicaltable0
                }
            }
        }
        physicalTableMap = physicalTableMapDecoded0
        let logicalTableMapContainer = try containerValues.decodeIfPresent([Swift.String: QuickSightClientTypes.LogicalTable?].self, forKey: .logicalTableMap)
        var logicalTableMapDecoded0: [Swift.String:QuickSightClientTypes.LogicalTable]? = nil
        if let logicalTableMapContainer = logicalTableMapContainer {
            logicalTableMapDecoded0 = [Swift.String:QuickSightClientTypes.LogicalTable]()
            for (key0, logicaltable0) in logicalTableMapContainer {
                if let logicaltable0 = logicaltable0 {
                    logicalTableMapDecoded0?[key0] = logicaltable0
                }
            }
        }
        logicalTableMap = logicalTableMapDecoded0
        let importModeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSetImportMode.self, forKey: .importMode)
        importMode = importModeDecoded
        let columnGroupsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnGroup?].self, forKey: .columnGroups)
        var columnGroupsDecoded0:[QuickSightClientTypes.ColumnGroup]? = nil
        if let columnGroupsContainer = columnGroupsContainer {
            columnGroupsDecoded0 = [QuickSightClientTypes.ColumnGroup]()
            for structure0 in columnGroupsContainer {
                if let structure0 = structure0 {
                    columnGroupsDecoded0?.append(structure0)
                }
            }
        }
        columnGroups = columnGroupsDecoded0
        let fieldFoldersContainer = try containerValues.decodeIfPresent([Swift.String: QuickSightClientTypes.FieldFolder?].self, forKey: .fieldFolders)
        var fieldFoldersDecoded0: [Swift.String:QuickSightClientTypes.FieldFolder]? = nil
        if let fieldFoldersContainer = fieldFoldersContainer {
            fieldFoldersDecoded0 = [Swift.String:QuickSightClientTypes.FieldFolder]()
            for (key0, fieldfolder0) in fieldFoldersContainer {
                if let fieldfolder0 = fieldfolder0 {
                    fieldFoldersDecoded0?[key0] = fieldfolder0
                }
            }
        }
        fieldFolders = fieldFoldersDecoded0
        let rowLevelPermissionDataSetDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RowLevelPermissionDataSet.self, forKey: .rowLevelPermissionDataSet)
        rowLevelPermissionDataSet = rowLevelPermissionDataSetDecoded
        let rowLevelPermissionTagConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.RowLevelPermissionTagConfiguration.self, forKey: .rowLevelPermissionTagConfiguration)
        rowLevelPermissionTagConfiguration = rowLevelPermissionTagConfigurationDecoded
        let columnLevelPermissionRulesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnLevelPermissionRule?].self, forKey: .columnLevelPermissionRules)
        var columnLevelPermissionRulesDecoded0:[QuickSightClientTypes.ColumnLevelPermissionRule]? = nil
        if let columnLevelPermissionRulesContainer = columnLevelPermissionRulesContainer {
            columnLevelPermissionRulesDecoded0 = [QuickSightClientTypes.ColumnLevelPermissionRule]()
            for structure0 in columnLevelPermissionRulesContainer {
                if let structure0 = structure0 {
                    columnLevelPermissionRulesDecoded0?.append(structure0)
                }
            }
        }
        columnLevelPermissionRules = columnLevelPermissionRulesDecoded0
        let dataSetUsageConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSetUsageConfiguration.self, forKey: .dataSetUsageConfiguration)
        dataSetUsageConfiguration = dataSetUsageConfigurationDecoded
    }
}

extension UpdateDataSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDataSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDataSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDataSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDataSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.dataSetId = output.dataSetId
            self.ingestionArn = output.ingestionArn
            self.ingestionId = output.ingestionId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.dataSetId = nil
            self.ingestionArn = nil
            self.ingestionId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateDataSetOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset.
    public var arn: Swift.String?
    /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSetId: Swift.String?
    /// The ARN for the ingestion, which is triggered as a result of dataset creation if the import mode is SPICE.
    public var ingestionArn: Swift.String?
    /// The ID of the ingestion, which is triggered as a result of dataset creation if the import mode is SPICE.
    public var ingestionId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        ingestionArn: Swift.String? = nil,
        ingestionId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.dataSetId = dataSetId
        self.ingestionArn = ingestionArn
        self.ingestionId = ingestionId
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateDataSetOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let dataSetId: Swift.String?
    let ingestionArn: Swift.String?
    let ingestionId: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateDataSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case dataSetId = "DataSetId"
        case ingestionArn = "IngestionArn"
        case ingestionId = "IngestionId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let ingestionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ingestionArn)
        ingestionArn = ingestionArnDecoded
        let ingestionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ingestionId)
        ingestionId = ingestionIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension UpdateDataSetPermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantPermissions = grantPermissions {
            var grantPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantPermissions)
            for resourcepermission0 in grantPermissions {
                try grantPermissionsContainer.encode(resourcepermission0)
            }
        }
        if let revokePermissions = revokePermissions {
            var revokePermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revokePermissions)
            for resourcepermission0 in revokePermissions {
                try revokePermissionsContainer.encode(resourcepermission0)
            }
        }
    }
}

extension UpdateDataSetPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSetId = dataSetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/permissions"
    }
}

public struct UpdateDataSetPermissionsInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dataset whose permissions you want to update. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The resource permissions that you want to grant to the dataset.
    public var grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// The resource permissions that you want to revoke from the dataset.
    public var revokePermissions: [QuickSightClientTypes.ResourcePermission]?

    public init (
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        grantPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        revokePermissions: [QuickSightClientTypes.ResourcePermission]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
        self.grantPermissions = grantPermissions
        self.revokePermissions = revokePermissions
    }
}

struct UpdateDataSetPermissionsInputBody: Swift.Equatable {
    let grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    let revokePermissions: [QuickSightClientTypes.ResourcePermission]?
}

extension UpdateDataSetPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantPermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .grantPermissions)
        var grantPermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let grantPermissionsContainer = grantPermissionsContainer {
            grantPermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in grantPermissionsContainer {
                if let structure0 = structure0 {
                    grantPermissionsDecoded0?.append(structure0)
                }
            }
        }
        grantPermissions = grantPermissionsDecoded0
        let revokePermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .revokePermissions)
        var revokePermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let revokePermissionsContainer = revokePermissionsContainer {
            revokePermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in revokePermissionsContainer {
                if let structure0 = structure0 {
                    revokePermissionsDecoded0?.append(structure0)
                }
            }
        }
        revokePermissions = revokePermissionsDecoded0
    }
}

extension UpdateDataSetPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDataSetPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDataSetPermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDataSetPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDataSetPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSetArn = output.dataSetArn
            self.dataSetId = output.dataSetId
            self.requestId = output.requestId
        } else {
            self.dataSetArn = nil
            self.dataSetId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateDataSetPermissionsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset.
    public var dataSetArn: Swift.String?
    /// The ID for the dataset whose permissions you want to update. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSetId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dataSetArn: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSetArn = dataSetArn
        self.dataSetId = dataSetId
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateDataSetPermissionsOutputResponseBody: Swift.Equatable {
    let dataSetArn: Swift.String?
    let dataSetId: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateDataSetPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetArn = "DataSetArn"
        case dataSetId = "DataSetId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetArn)
        dataSetArn = dataSetArnDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension UpdateDataSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDataSourceInput(awsAccountId: \(Swift.String(describing: awsAccountId)), dataSourceId: \(Swift.String(describing: dataSourceId)), dataSourceParameters: \(Swift.String(describing: dataSourceParameters)), name: \(Swift.String(describing: name)), sslProperties: \(Swift.String(describing: sslProperties)), vpcConnectionProperties: \(Swift.String(describing: vpcConnectionProperties)), credentials: \"CONTENT_REDACTED\")"}
}

extension UpdateDataSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
        case dataSourceParameters = "DataSourceParameters"
        case name = "Name"
        case sslProperties = "SslProperties"
        case vpcConnectionProperties = "VpcConnectionProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credentials = self.credentials {
            try encodeContainer.encode(credentials, forKey: .credentials)
        }
        if let dataSourceParameters = self.dataSourceParameters {
            try encodeContainer.encode(dataSourceParameters, forKey: .dataSourceParameters)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sslProperties = self.sslProperties {
            try encodeContainer.encode(sslProperties, forKey: .sslProperties)
        }
        if let vpcConnectionProperties = self.vpcConnectionProperties {
            try encodeContainer.encode(vpcConnectionProperties, forKey: .vpcConnectionProperties)
        }
    }
}

extension UpdateDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSourceId = dataSourceId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sources/\(dataSourceId.urlPercentEncoding())"
    }
}

public struct UpdateDataSourceInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The credentials that Amazon QuickSight that uses to connect to your underlying source. Currently, only credentials based on user name and password are supported.
    public var credentials: QuickSightClientTypes.DataSourceCredentials?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The parameters that Amazon QuickSight uses to connect to your underlying source.
    public var dataSourceParameters: QuickSightClientTypes.DataSourceParameters?
    /// A display name for the data source.
    /// This member is required.
    public var name: Swift.String?
    /// Secure Socket Layer (SSL) properties that apply when Amazon QuickSight connects to your underlying source.
    public var sslProperties: QuickSightClientTypes.SslProperties?
    /// Use this parameter only when you want Amazon QuickSight to use a VPC connection when connecting to your underlying source.
    public var vpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties?

    public init (
        awsAccountId: Swift.String? = nil,
        credentials: QuickSightClientTypes.DataSourceCredentials? = nil,
        dataSourceId: Swift.String? = nil,
        dataSourceParameters: QuickSightClientTypes.DataSourceParameters? = nil,
        name: Swift.String? = nil,
        sslProperties: QuickSightClientTypes.SslProperties? = nil,
        vpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.credentials = credentials
        self.dataSourceId = dataSourceId
        self.dataSourceParameters = dataSourceParameters
        self.name = name
        self.sslProperties = sslProperties
        self.vpcConnectionProperties = vpcConnectionProperties
    }
}

struct UpdateDataSourceInputBody: Swift.Equatable {
    let name: Swift.String?
    let dataSourceParameters: QuickSightClientTypes.DataSourceParameters?
    let credentials: QuickSightClientTypes.DataSourceCredentials?
    let vpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties?
    let sslProperties: QuickSightClientTypes.SslProperties?
}

extension UpdateDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
        case dataSourceParameters = "DataSourceParameters"
        case name = "Name"
        case sslProperties = "SslProperties"
        case vpcConnectionProperties = "VpcConnectionProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataSourceParametersDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSourceParameters.self, forKey: .dataSourceParameters)
        dataSourceParameters = dataSourceParametersDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataSourceCredentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let vpcConnectionPropertiesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VpcConnectionProperties.self, forKey: .vpcConnectionProperties)
        vpcConnectionProperties = vpcConnectionPropertiesDecoded
        let sslPropertiesDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SslProperties.self, forKey: .sslProperties)
        sslProperties = sslPropertiesDecoded
    }
}

extension UpdateDataSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDataSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDataSourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDataSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.dataSourceId = output.dataSourceId
            self.requestId = output.requestId
            self.updateStatus = output.updateStatus
        } else {
            self.arn = nil
            self.dataSourceId = nil
            self.requestId = nil
            self.updateStatus = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateDataSourceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the data source.
    public var arn: Swift.String?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSourceId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The update status of the data source's last update.
    public var updateStatus: QuickSightClientTypes.ResourceStatus?

    public init (
        arn: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        updateStatus: QuickSightClientTypes.ResourceStatus? = nil
    )
    {
        self.arn = arn
        self.dataSourceId = dataSourceId
        self.requestId = requestId
        self.status = status
        self.updateStatus = updateStatus
    }
}

struct UpdateDataSourceOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let dataSourceId: Swift.String?
    let updateStatus: QuickSightClientTypes.ResourceStatus?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateDataSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case dataSourceId = "DataSourceId"
        case requestId = "RequestId"
        case status = "Status"
        case updateStatus = "UpdateStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let updateStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .updateStatus)
        updateStatus = updateStatusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension UpdateDataSourcePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantPermissions = grantPermissions {
            var grantPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantPermissions)
            for resourcepermission0 in grantPermissions {
                try grantPermissionsContainer.encode(resourcepermission0)
            }
        }
        if let revokePermissions = revokePermissions {
            var revokePermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revokePermissions)
            for resourcepermission0 in revokePermissions {
                try revokePermissionsContainer.encode(resourcepermission0)
            }
        }
    }
}

extension UpdateDataSourcePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let dataSourceId = dataSourceId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sources/\(dataSourceId.urlPercentEncoding())/permissions"
    }
}

public struct UpdateDataSourcePermissionsInput: Swift.Equatable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// A list of resource permissions that you want to grant on the data source.
    public var grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// A list of resource permissions that you want to revoke on the data source.
    public var revokePermissions: [QuickSightClientTypes.ResourcePermission]?

    public init (
        awsAccountId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        grantPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        revokePermissions: [QuickSightClientTypes.ResourcePermission]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSourceId = dataSourceId
        self.grantPermissions = grantPermissions
        self.revokePermissions = revokePermissions
    }
}

struct UpdateDataSourcePermissionsInputBody: Swift.Equatable {
    let grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    let revokePermissions: [QuickSightClientTypes.ResourcePermission]?
}

extension UpdateDataSourcePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantPermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .grantPermissions)
        var grantPermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let grantPermissionsContainer = grantPermissionsContainer {
            grantPermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in grantPermissionsContainer {
                if let structure0 = structure0 {
                    grantPermissionsDecoded0?.append(structure0)
                }
            }
        }
        grantPermissions = grantPermissionsDecoded0
        let revokePermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .revokePermissions)
        var revokePermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let revokePermissionsContainer = revokePermissionsContainer {
            revokePermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in revokePermissionsContainer {
                if let structure0 = structure0 {
                    revokePermissionsDecoded0?.append(structure0)
                }
            }
        }
        revokePermissions = revokePermissionsDecoded0
    }
}

extension UpdateDataSourcePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDataSourcePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDataSourcePermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDataSourcePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDataSourcePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSourceArn = output.dataSourceArn
            self.dataSourceId = output.dataSourceId
            self.requestId = output.requestId
        } else {
            self.dataSourceArn = nil
            self.dataSourceId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateDataSourcePermissionsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the data source.
    public var dataSourceArn: Swift.String?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSourceId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        dataSourceArn: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSourceArn = dataSourceArn
        self.dataSourceId = dataSourceId
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateDataSourcePermissionsOutputResponseBody: Swift.Equatable {
    let dataSourceArn: Swift.String?
    let dataSourceId: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateDataSourcePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceArn = "DataSourceArn"
        case dataSourceId = "DataSourceId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceArn)
        dataSourceArn = dataSourceArnDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension UpdateFolderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let folderId = folderId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())"
    }
}

public struct UpdateFolderInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the folder to update.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The name of the folder.
    /// This member is required.
    public var name: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
        self.name = name
    }
}

struct UpdateFolderInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateFolderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateFolderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFolderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateFolderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFolderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateFolderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.folderId = output.folderId
            self.requestId = output.requestId
        } else {
            self.arn = nil
            self.folderId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateFolderOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the folder.
    public var arn: Swift.String?
    /// The ID of the folder.
    public var folderId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        folderId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.folderId = folderId
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateFolderOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let arn: Swift.String?
    let folderId: Swift.String?
    let requestId: Swift.String?
}

extension UpdateFolderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case folderId = "FolderId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let folderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .folderId)
        folderId = folderIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UpdateFolderPermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantPermissions = grantPermissions {
            var grantPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantPermissions)
            for resourcepermission0 in grantPermissions {
                try grantPermissionsContainer.encode(resourcepermission0)
            }
        }
        if let revokePermissions = revokePermissions {
            var revokePermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revokePermissions)
            for resourcepermission0 in revokePermissions {
                try revokePermissionsContainer.encode(resourcepermission0)
            }
        }
    }
}

extension UpdateFolderPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let folderId = folderId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())/permissions"
    }
}

public struct UpdateFolderPermissionsInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that contains the folder to update.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The permissions that you want to grant on a resource.
    public var grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// The permissions that you want to revoke from a resource.
    public var revokePermissions: [QuickSightClientTypes.ResourcePermission]?

    public init (
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil,
        grantPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        revokePermissions: [QuickSightClientTypes.ResourcePermission]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
        self.grantPermissions = grantPermissions
        self.revokePermissions = revokePermissions
    }
}

struct UpdateFolderPermissionsInputBody: Swift.Equatable {
    let grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    let revokePermissions: [QuickSightClientTypes.ResourcePermission]?
}

extension UpdateFolderPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantPermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .grantPermissions)
        var grantPermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let grantPermissionsContainer = grantPermissionsContainer {
            grantPermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in grantPermissionsContainer {
                if let structure0 = structure0 {
                    grantPermissionsDecoded0?.append(structure0)
                }
            }
        }
        grantPermissions = grantPermissionsDecoded0
        let revokePermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .revokePermissions)
        var revokePermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let revokePermissionsContainer = revokePermissionsContainer {
            revokePermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in revokePermissionsContainer {
                if let structure0 = structure0 {
                    revokePermissionsDecoded0?.append(structure0)
                }
            }
        }
        revokePermissions = revokePermissionsDecoded0
    }
}

extension UpdateFolderPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFolderPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateFolderPermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFolderPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateFolderPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.folderId = output.folderId
            self.permissions = output.permissions
            self.requestId = output.requestId
            self.status = output.status
        } else {
            self.arn = nil
            self.folderId = nil
            self.permissions = nil
            self.requestId = nil
            self.status = 0
        }
    }
}

public struct UpdateFolderPermissionsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the folder.
    public var arn: Swift.String?
    /// The ID of the folder.
    public var folderId: Swift.String?
    /// Information about the permissions for the folder.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        arn: Swift.String? = nil,
        folderId: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.folderId = folderId
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateFolderPermissionsOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let arn: Swift.String?
    let folderId: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let requestId: Swift.String?
}

extension UpdateFolderPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case folderId = "FolderId"
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let folderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .folderId)
        folderId = folderIdDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UpdateGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let groupName = groupName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups/\(groupName.urlPercentEncoding())"
    }
}

public struct UpdateGroupInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The description for the group that you want to update.
    public var description: Swift.String?
    /// The name of the group that you want to update.
    /// This member is required.
    public var groupName: Swift.String?
    /// The namespace of the group that you want to update.
    /// This member is required.
    public var namespace: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        description: Swift.String? = nil,
        groupName: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.description = description
        self.groupName = groupName
        self.namespace = namespace
    }
}

struct UpdateGroupInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.group = output.group
            self.requestId = output.requestId
        } else {
            self.group = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateGroupOutputResponse: Swift.Equatable {
    /// The name of the group.
    public var group: QuickSightClientTypes.Group?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        group: QuickSightClientTypes.Group? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.group = group
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateGroupOutputResponseBody: Swift.Equatable {
    let group: QuickSightClientTypes.Group?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group = "Group"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Group.self, forKey: .group)
        group = groupDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension UpdateIAMPolicyAssignmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentStatus = "AssignmentStatus"
        case identities = "Identities"
        case policyArn = "PolicyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignmentStatus = self.assignmentStatus {
            try encodeContainer.encode(assignmentStatus.rawValue, forKey: .assignmentStatus)
        }
        if let identities = identities {
            var identitiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .identities)
            for (dictKey0, identityMap0) in identities {
                var identityMap0Container = identitiesContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for identityname1 in identityMap0 {
                    try identityMap0Container.encode(identityname1)
                }
            }
        }
        if let policyArn = self.policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
    }
}

extension UpdateIAMPolicyAssignmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let assignmentName = assignmentName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/iam-policy-assignments/\(assignmentName.urlPercentEncoding())"
    }
}

public struct UpdateIAMPolicyAssignmentInput: Swift.Equatable {
    /// The name of the assignment, also called a rule. This name must be unique within an Amazon Web Services account.
    /// This member is required.
    public var assignmentName: Swift.String?
    /// The status of the assignment. Possible values are as follows:
    ///
    /// * ENABLED - Anything specified in this assignment is used when creating the data source.
    ///
    /// * DISABLED - This assignment isn't used when creating the data source.
    ///
    /// * DRAFT - This assignment is an unfinished draft and isn't used when creating the data source.
    public var assignmentStatus: QuickSightClientTypes.AssignmentStatus?
    /// The ID of the Amazon Web Services account that contains the IAM policy assignment.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The Amazon QuickSight users, groups, or both that you want to assign the policy to.
    public var identities: [Swift.String:[Swift.String]]?
    /// The namespace of the assignment.
    /// This member is required.
    public var namespace: Swift.String?
    /// The ARN for the IAM policy to apply to the Amazon QuickSight users and groups specified in this assignment.
    public var policyArn: Swift.String?

    public init (
        assignmentName: Swift.String? = nil,
        assignmentStatus: QuickSightClientTypes.AssignmentStatus? = nil,
        awsAccountId: Swift.String? = nil,
        identities: [Swift.String:[Swift.String]]? = nil,
        namespace: Swift.String? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.assignmentName = assignmentName
        self.assignmentStatus = assignmentStatus
        self.awsAccountId = awsAccountId
        self.identities = identities
        self.namespace = namespace
        self.policyArn = policyArn
    }
}

struct UpdateIAMPolicyAssignmentInputBody: Swift.Equatable {
    let assignmentStatus: QuickSightClientTypes.AssignmentStatus?
    let policyArn: Swift.String?
    let identities: [Swift.String:[Swift.String]]?
}

extension UpdateIAMPolicyAssignmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentStatus = "AssignmentStatus"
        case identities = "Identities"
        case policyArn = "PolicyArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AssignmentStatus.self, forKey: .assignmentStatus)
        assignmentStatus = assignmentStatusDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let identitiesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .identities)
        var identitiesDecoded0: [Swift.String:[Swift.String]]? = nil
        if let identitiesContainer = identitiesContainer {
            identitiesDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, identitynamelist0) in identitiesContainer {
                var identitynamelist0Decoded0: [Swift.String]? = nil
                if let identitynamelist0 = identitynamelist0 {
                    identitynamelist0Decoded0 = [Swift.String]()
                    for string1 in identitynamelist0 {
                        if let string1 = string1 {
                            identitynamelist0Decoded0?.append(string1)
                        }
                    }
                }
                identitiesDecoded0?[key0] = identitynamelist0Decoded0
            }
        }
        identities = identitiesDecoded0
    }
}

extension UpdateIAMPolicyAssignmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIAMPolicyAssignmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentUpdatingException" : self = .concurrentUpdatingException(try ConcurrentUpdatingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateIAMPolicyAssignmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case concurrentUpdatingException(ConcurrentUpdatingException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIAMPolicyAssignmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateIAMPolicyAssignmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assignmentId = output.assignmentId
            self.assignmentName = output.assignmentName
            self.assignmentStatus = output.assignmentStatus
            self.identities = output.identities
            self.policyArn = output.policyArn
            self.requestId = output.requestId
        } else {
            self.assignmentId = nil
            self.assignmentName = nil
            self.assignmentStatus = nil
            self.identities = nil
            self.policyArn = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateIAMPolicyAssignmentOutputResponse: Swift.Equatable {
    /// The ID of the assignment.
    public var assignmentId: Swift.String?
    /// The name of the assignment or rule.
    public var assignmentName: Swift.String?
    /// The status of the assignment. Possible values are as follows:
    ///
    /// * ENABLED - Anything specified in this assignment is used when creating the data source.
    ///
    /// * DISABLED - This assignment isn't used when creating the data source.
    ///
    /// * DRAFT - This assignment is an unfinished draft and isn't used when creating the data source.
    public var assignmentStatus: QuickSightClientTypes.AssignmentStatus?
    /// The Amazon QuickSight users, groups, or both that the IAM policy is assigned to.
    public var identities: [Swift.String:[Swift.String]]?
    /// The ARN for the IAM policy applied to the Amazon QuickSight users and groups specified in this assignment.
    public var policyArn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        assignmentId: Swift.String? = nil,
        assignmentName: Swift.String? = nil,
        assignmentStatus: QuickSightClientTypes.AssignmentStatus? = nil,
        identities: [Swift.String:[Swift.String]]? = nil,
        policyArn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.assignmentId = assignmentId
        self.assignmentName = assignmentName
        self.assignmentStatus = assignmentStatus
        self.identities = identities
        self.policyArn = policyArn
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateIAMPolicyAssignmentOutputResponseBody: Swift.Equatable {
    let assignmentName: Swift.String?
    let assignmentId: Swift.String?
    let policyArn: Swift.String?
    let identities: [Swift.String:[Swift.String]]?
    let assignmentStatus: QuickSightClientTypes.AssignmentStatus?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateIAMPolicyAssignmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentId = "AssignmentId"
        case assignmentName = "AssignmentName"
        case assignmentStatus = "AssignmentStatus"
        case identities = "Identities"
        case policyArn = "PolicyArn"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentName)
        assignmentName = assignmentNameDecoded
        let assignmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignmentId)
        assignmentId = assignmentIdDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let identitiesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .identities)
        var identitiesDecoded0: [Swift.String:[Swift.String]]? = nil
        if let identitiesContainer = identitiesContainer {
            identitiesDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, identitynamelist0) in identitiesContainer {
                var identitynamelist0Decoded0: [Swift.String]? = nil
                if let identitynamelist0 = identitynamelist0 {
                    identitynamelist0Decoded0 = [Swift.String]()
                    for string1 in identitynamelist0 {
                        if let string1 = string1 {
                            identitynamelist0Decoded0?.append(string1)
                        }
                    }
                }
                identitiesDecoded0?[key0] = identitynamelist0Decoded0
            }
        }
        identities = identitiesDecoded0
        let assignmentStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AssignmentStatus.self, forKey: .assignmentStatus)
        assignmentStatus = assignmentStatusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension UpdateIpRestrictionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case ipRestrictionRuleMap = "IpRestrictionRuleMap"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let ipRestrictionRuleMap = ipRestrictionRuleMap {
            var ipRestrictionRuleMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .ipRestrictionRuleMap)
            for (dictKey0, ipRestrictionRuleMap0) in ipRestrictionRuleMap {
                try ipRestrictionRuleMapContainer.encode(ipRestrictionRuleMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateIpRestrictionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/ip-restriction"
    }
}

public struct UpdateIpRestrictionInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the IP rules.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A value that specifies whether IP rules are turned on.
    public var enabled: Swift.Bool?
    /// A map that describes the updated IP rules with CIDR ranges and descriptions.
    public var ipRestrictionRuleMap: [Swift.String:Swift.String]?

    public init (
        awsAccountId: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        ipRestrictionRuleMap: [Swift.String:Swift.String]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.enabled = enabled
        self.ipRestrictionRuleMap = ipRestrictionRuleMap
    }
}

struct UpdateIpRestrictionInputBody: Swift.Equatable {
    let ipRestrictionRuleMap: [Swift.String:Swift.String]?
    let enabled: Swift.Bool?
}

extension UpdateIpRestrictionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case ipRestrictionRuleMap = "IpRestrictionRuleMap"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipRestrictionRuleMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .ipRestrictionRuleMap)
        var ipRestrictionRuleMapDecoded0: [Swift.String:Swift.String]? = nil
        if let ipRestrictionRuleMapContainer = ipRestrictionRuleMapContainer {
            ipRestrictionRuleMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, iprestrictionruledescription0) in ipRestrictionRuleMapContainer {
                if let iprestrictionruledescription0 = iprestrictionruledescription0 {
                    ipRestrictionRuleMapDecoded0?[key0] = iprestrictionruledescription0
                }
            }
        }
        ipRestrictionRuleMap = ipRestrictionRuleMapDecoded0
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension UpdateIpRestrictionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIpRestrictionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateIpRestrictionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIpRestrictionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateIpRestrictionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awsAccountId = output.awsAccountId
            self.requestId = output.requestId
        } else {
            self.awsAccountId = nil
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateIpRestrictionOutputResponse: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the IP rules.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        awsAccountId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.awsAccountId = awsAccountId
        self.requestId = requestId
        self.status = status
    }
}

struct UpdateIpRestrictionOutputResponseBody: Swift.Equatable {
    let awsAccountId: Swift.String?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateIpRestrictionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId = "AwsAccountId"
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension UpdatePublicSharingSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicSharingEnabled = "PublicSharingEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if publicSharingEnabled != false {
            try encodeContainer.encode(publicSharingEnabled, forKey: .publicSharingEnabled)
        }
    }
}

extension UpdatePublicSharingSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/public-sharing-settings"
    }
}

public struct UpdatePublicSharingSettingsInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with your Amazon QuickSight subscription.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A Boolean value that indicates whether public sharing is turned on for an Amazon QuickSight account.
    public var publicSharingEnabled: Swift.Bool

    public init (
        awsAccountId: Swift.String? = nil,
        publicSharingEnabled: Swift.Bool = false
    )
    {
        self.awsAccountId = awsAccountId
        self.publicSharingEnabled = publicSharingEnabled
    }
}

struct UpdatePublicSharingSettingsInputBody: Swift.Equatable {
    let publicSharingEnabled: Swift.Bool
}

extension UpdatePublicSharingSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicSharingEnabled = "PublicSharingEnabled"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicSharingEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publicSharingEnabled) ?? false
        publicSharingEnabled = publicSharingEnabledDecoded
    }
}

extension UpdatePublicSharingSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePublicSharingSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedPricingPlanException" : self = .unsupportedPricingPlanException(try UnsupportedPricingPlanException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdatePublicSharingSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedPricingPlanException(UnsupportedPricingPlanException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePublicSharingSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdatePublicSharingSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
        } else {
            self.requestId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdatePublicSharingSettingsOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

struct UpdatePublicSharingSettingsOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdatePublicSharingSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension UpdateTemplateAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateVersionNumber = "TemplateVersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateVersionNumber = self.templateVersionNumber {
            try encodeContainer.encode(templateVersionNumber, forKey: .templateVersionNumber)
        }
    }
}

extension UpdateTemplateAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        guard let aliasName = aliasName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/aliases/\(aliasName.urlPercentEncoding())"
    }
}

public struct UpdateTemplateAliasInput: Swift.Equatable {
    /// The alias of the template that you want to update. If you name a specific alias, you update the version that the alias points to. You can specify the latest version of the template by providing the keyword $LATEST in the AliasName parameter. The keyword $PUBLISHED doesn't apply to templates.
    /// This member is required.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the template alias that you're updating.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the template.
    /// This member is required.
    public var templateId: Swift.String?
    /// The version number of the template.
    /// This member is required.
    public var templateVersionNumber: Swift.Int?

    public init (
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        templateId: Swift.String? = nil,
        templateVersionNumber: Swift.Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.templateId = templateId
        self.templateVersionNumber = templateVersionNumber
    }
}

struct UpdateTemplateAliasInputBody: Swift.Equatable {
    let templateVersionNumber: Swift.Int?
}

extension UpdateTemplateAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateVersionNumber = "TemplateVersionNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .templateVersionNumber)
        templateVersionNumber = templateVersionNumberDecoded
    }
}

extension UpdateTemplateAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTemplateAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateTemplateAliasOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTemplateAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateTemplateAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.templateAlias = output.templateAlias
        } else {
            self.requestId = nil
            self.templateAlias = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateTemplateAliasOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The template alias.
    public var templateAlias: QuickSightClientTypes.TemplateAlias?

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateAlias: QuickSightClientTypes.TemplateAlias? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.templateAlias = templateAlias
    }
}

struct UpdateTemplateAliasOutputResponseBody: Swift.Equatable {
    let templateAlias: QuickSightClientTypes.TemplateAlias?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension UpdateTemplateAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case templateAlias = "TemplateAlias"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateAliasDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TemplateAlias.self, forKey: .templateAlias)
        templateAlias = templateAliasDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UpdateTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition = "Definition"
        case name = "Name"
        case sourceEntity = "SourceEntity"
        case versionDescription = "VersionDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceEntity = self.sourceEntity {
            try encodeContainer.encode(sourceEntity, forKey: .sourceEntity)
        }
        if let versionDescription = self.versionDescription {
            try encodeContainer.encode(versionDescription, forKey: .versionDescription)
        }
    }
}

extension UpdateTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())"
    }
}

public struct UpdateTemplateInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the template that you're updating.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The definition of a template. A definition is the data model of all features in a Dashboard, Template, or Analysis.
    public var definition: QuickSightClientTypes.TemplateVersionDefinition?
    /// The name for the template.
    public var name: Swift.String?
    /// The entity that you are using as a source when you update the template. In SourceEntity, you specify the type of object you're using as source: SourceTemplate for a template or SourceAnalysis for an analysis. Both of these require an Amazon Resource Name (ARN). For SourceTemplate, specify the ARN of the source template. For SourceAnalysis, specify the ARN of the source analysis. The SourceTemplate ARN can contain any Amazon Web Services account and any Amazon QuickSight-supported Amazon Web Services Region;. Use the DataSetReferences entity within SourceTemplate or SourceAnalysis to list the replacement datasets for the placeholders listed in the original. The schema in each dataset must match its placeholder.
    public var sourceEntity: QuickSightClientTypes.TemplateSourceEntity?
    /// The ID for the template.
    /// This member is required.
    public var templateId: Swift.String?
    /// A description of the current template version that is being updated. Every time you call UpdateTemplate, you create a new version of the template. Each version of the template maintains a description of the version in the VersionDescription field.
    public var versionDescription: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        definition: QuickSightClientTypes.TemplateVersionDefinition? = nil,
        name: Swift.String? = nil,
        sourceEntity: QuickSightClientTypes.TemplateSourceEntity? = nil,
        templateId: Swift.String? = nil,
        versionDescription: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.definition = definition
        self.name = name
        self.sourceEntity = sourceEntity
        self.templateId = templateId
        self.versionDescription = versionDescription
    }
}

struct UpdateTemplateInputBody: Swift.Equatable {
    let sourceEntity: QuickSightClientTypes.TemplateSourceEntity?
    let versionDescription: Swift.String?
    let name: Swift.String?
    let definition: QuickSightClientTypes.TemplateVersionDefinition?
}

extension UpdateTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition = "Definition"
        case name = "Name"
        case sourceEntity = "SourceEntity"
        case versionDescription = "VersionDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceEntityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TemplateSourceEntity.self, forKey: .sourceEntity)
        sourceEntity = sourceEntityDecoded
        let versionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionDescription)
        versionDescription = versionDescriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TemplateVersionDefinition.self, forKey: .definition)
        definition = definitionDecoded
    }
}

extension UpdateTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateTemplateOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationStatus = output.creationStatus
            self.requestId = output.requestId
            self.templateId = output.templateId
            self.versionArn = output.versionArn
        } else {
            self.arn = nil
            self.creationStatus = nil
            self.requestId = nil
            self.templateId = nil
            self.versionArn = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateTemplateOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the template.
    public var arn: Swift.String?
    /// The creation status of the template.
    public var creationStatus: QuickSightClientTypes.ResourceStatus?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ID for the template.
    public var templateId: Swift.String?
    /// The ARN for the template, including the version information of the first version.
    public var versionArn: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.ResourceStatus? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateId: Swift.String? = nil,
        versionArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.requestId = requestId
        self.status = status
        self.templateId = templateId
        self.versionArn = versionArn
    }
}

struct UpdateTemplateOutputResponseBody: Swift.Equatable {
    let templateId: Swift.String?
    let arn: Swift.String?
    let versionArn: Swift.String?
    let creationStatus: QuickSightClientTypes.ResourceStatus?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension UpdateTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationStatus = "CreationStatus"
        case requestId = "RequestId"
        case status = "Status"
        case templateId = "TemplateId"
        case versionArn = "VersionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionArn)
        versionArn = versionArnDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UpdateTemplatePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantPermissions = grantPermissions {
            var grantPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantPermissions)
            for resourcepermission0 in grantPermissions {
                try grantPermissionsContainer.encode(resourcepermission0)
            }
        }
        if let revokePermissions = revokePermissions {
            var revokePermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revokePermissions)
            for resourcepermission0 in revokePermissions {
                try revokePermissionsContainer.encode(resourcepermission0)
            }
        }
    }
}

extension UpdateTemplatePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/permissions"
    }
}

public struct UpdateTemplatePermissionsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the template.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A list of resource permissions to be granted on the template.
    public var grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// A list of resource permissions to be revoked from the template.
    public var revokePermissions: [QuickSightClientTypes.ResourcePermission]?
    /// The ID for the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        grantPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        revokePermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.grantPermissions = grantPermissions
        self.revokePermissions = revokePermissions
        self.templateId = templateId
    }
}

struct UpdateTemplatePermissionsInputBody: Swift.Equatable {
    let grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    let revokePermissions: [QuickSightClientTypes.ResourcePermission]?
}

extension UpdateTemplatePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantPermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .grantPermissions)
        var grantPermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let grantPermissionsContainer = grantPermissionsContainer {
            grantPermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in grantPermissionsContainer {
                if let structure0 = structure0 {
                    grantPermissionsDecoded0?.append(structure0)
                }
            }
        }
        grantPermissions = grantPermissionsDecoded0
        let revokePermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .revokePermissions)
        var revokePermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let revokePermissionsContainer = revokePermissionsContainer {
            revokePermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in revokePermissionsContainer {
                if let structure0 = structure0 {
                    revokePermissionsDecoded0?.append(structure0)
                }
            }
        }
        revokePermissions = revokePermissionsDecoded0
    }
}

extension UpdateTemplatePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTemplatePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateTemplatePermissionsOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTemplatePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateTemplatePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.permissions = output.permissions
            self.requestId = output.requestId
            self.templateArn = output.templateArn
            self.templateId = output.templateId
        } else {
            self.permissions = nil
            self.requestId = nil
            self.templateArn = nil
            self.templateId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateTemplatePermissionsOutputResponse: Swift.Equatable {
    /// A list of resource permissions to be set on the template.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The Amazon Resource Name (ARN) of the template.
    public var templateArn: Swift.String?
    /// The ID for the template.
    public var templateId: Swift.String?

    public init (
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateArn: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
        self.templateArn = templateArn
        self.templateId = templateId
    }
}

struct UpdateTemplatePermissionsOutputResponseBody: Swift.Equatable {
    let templateId: Swift.String?
    let templateArn: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateTemplatePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
        case templateArn = "TemplateArn"
        case templateId = "TemplateId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension UpdateThemeAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case themeVersionNumber = "ThemeVersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let themeVersionNumber = self.themeVersionNumber {
            try encodeContainer.encode(themeVersionNumber, forKey: .themeVersionNumber)
        }
    }
}

extension UpdateThemeAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let themeId = themeId else {
            return nil
        }
        guard let aliasName = aliasName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())/aliases/\(aliasName.urlPercentEncoding())"
    }
}

public struct UpdateThemeAliasInput: Swift.Equatable {
    /// The name of the theme alias that you want to update.
    /// This member is required.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the theme alias that you're updating.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the theme.
    /// This member is required.
    public var themeId: Swift.String?
    /// The version number of the theme that the alias should reference.
    /// This member is required.
    public var themeVersionNumber: Swift.Int?

    public init (
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        themeId: Swift.String? = nil,
        themeVersionNumber: Swift.Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.themeId = themeId
        self.themeVersionNumber = themeVersionNumber
    }
}

struct UpdateThemeAliasInputBody: Swift.Equatable {
    let themeVersionNumber: Swift.Int?
}

extension UpdateThemeAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case themeVersionNumber = "ThemeVersionNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .themeVersionNumber)
        themeVersionNumber = themeVersionNumberDecoded
    }
}

extension UpdateThemeAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateThemeAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateThemeAliasOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateThemeAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateThemeAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.themeAlias = output.themeAlias
        } else {
            self.requestId = nil
            self.themeAlias = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateThemeAliasOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// Information about the theme alias.
    public var themeAlias: QuickSightClientTypes.ThemeAlias?

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeAlias: QuickSightClientTypes.ThemeAlias? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.themeAlias = themeAlias
    }
}

struct UpdateThemeAliasOutputResponseBody: Swift.Equatable {
    let themeAlias: QuickSightClientTypes.ThemeAlias?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension UpdateThemeAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case themeAlias = "ThemeAlias"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeAliasDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ThemeAlias.self, forKey: .themeAlias)
        themeAlias = themeAliasDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UpdateThemeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseThemeId = "BaseThemeId"
        case configuration = "Configuration"
        case name = "Name"
        case versionDescription = "VersionDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseThemeId = self.baseThemeId {
            try encodeContainer.encode(baseThemeId, forKey: .baseThemeId)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let versionDescription = self.versionDescription {
            try encodeContainer.encode(versionDescription, forKey: .versionDescription)
        }
    }
}

extension UpdateThemeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let themeId = themeId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())"
    }
}

public struct UpdateThemeInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the theme that you're updating.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The theme ID, defined by Amazon QuickSight, that a custom theme inherits from. All themes initially inherit from a default Amazon QuickSight theme.
    /// This member is required.
    public var baseThemeId: Swift.String?
    /// The theme configuration, which contains the theme display properties.
    public var configuration: QuickSightClientTypes.ThemeConfiguration?
    /// The name for the theme.
    public var name: Swift.String?
    /// The ID for the theme.
    /// This member is required.
    public var themeId: Swift.String?
    /// A description of the theme version that you're updating Every time that you call UpdateTheme, you create a new version of the theme. Each version of the theme maintains a description of the version in VersionDescription.
    public var versionDescription: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        baseThemeId: Swift.String? = nil,
        configuration: QuickSightClientTypes.ThemeConfiguration? = nil,
        name: Swift.String? = nil,
        themeId: Swift.String? = nil,
        versionDescription: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.baseThemeId = baseThemeId
        self.configuration = configuration
        self.name = name
        self.themeId = themeId
        self.versionDescription = versionDescription
    }
}

struct UpdateThemeInputBody: Swift.Equatable {
    let name: Swift.String?
    let baseThemeId: Swift.String?
    let versionDescription: Swift.String?
    let configuration: QuickSightClientTypes.ThemeConfiguration?
}

extension UpdateThemeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseThemeId = "BaseThemeId"
        case configuration = "Configuration"
        case name = "Name"
        case versionDescription = "VersionDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let baseThemeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseThemeId)
        baseThemeId = baseThemeIdDecoded
        let versionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionDescription)
        versionDescription = versionDescriptionDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ThemeConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension UpdateThemeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateThemeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateThemeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateThemeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateThemeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationStatus = output.creationStatus
            self.requestId = output.requestId
            self.themeId = output.themeId
            self.versionArn = output.versionArn
        } else {
            self.arn = nil
            self.creationStatus = nil
            self.requestId = nil
            self.themeId = nil
            self.versionArn = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateThemeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the theme.
    public var arn: Swift.String?
    /// The creation status of the theme.
    public var creationStatus: QuickSightClientTypes.ResourceStatus?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ID for the theme.
    public var themeId: Swift.String?
    /// The Amazon Resource Name (ARN) for the new version of the theme.
    public var versionArn: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.ResourceStatus? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeId: Swift.String? = nil,
        versionArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.requestId = requestId
        self.status = status
        self.themeId = themeId
        self.versionArn = versionArn
    }
}

struct UpdateThemeOutputResponseBody: Swift.Equatable {
    let themeId: Swift.String?
    let arn: Swift.String?
    let versionArn: Swift.String?
    let creationStatus: QuickSightClientTypes.ResourceStatus?
    let status: Swift.Int
    let requestId: Swift.String?
}

extension UpdateThemeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationStatus = "CreationStatus"
        case requestId = "RequestId"
        case status = "Status"
        case themeId = "ThemeId"
        case versionArn = "VersionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeId)
        themeId = themeIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionArn)
        versionArn = versionArnDecoded
        let creationStatusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ResourceStatus.self, forKey: .creationStatus)
        creationStatus = creationStatusDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UpdateThemePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantPermissions = grantPermissions {
            var grantPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grantPermissions)
            for resourcepermission0 in grantPermissions {
                try grantPermissionsContainer.encode(resourcepermission0)
            }
        }
        if let revokePermissions = revokePermissions {
            var revokePermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revokePermissions)
            for resourcepermission0 in revokePermissions {
                try revokePermissionsContainer.encode(resourcepermission0)
            }
        }
    }
}

extension UpdateThemePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let themeId = themeId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())/permissions"
    }
}

public struct UpdateThemePermissionsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account that contains the theme.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A list of resource permissions to be granted for the theme.
    public var grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// A list of resource permissions to be revoked from the theme.
    public var revokePermissions: [QuickSightClientTypes.ResourcePermission]?
    /// The ID for the theme.
    /// This member is required.
    public var themeId: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        grantPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        revokePermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        themeId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.grantPermissions = grantPermissions
        self.revokePermissions = revokePermissions
        self.themeId = themeId
    }
}

struct UpdateThemePermissionsInputBody: Swift.Equatable {
    let grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    let revokePermissions: [QuickSightClientTypes.ResourcePermission]?
}

extension UpdateThemePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantPermissions = "GrantPermissions"
        case revokePermissions = "RevokePermissions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantPermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .grantPermissions)
        var grantPermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let grantPermissionsContainer = grantPermissionsContainer {
            grantPermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in grantPermissionsContainer {
                if let structure0 = structure0 {
                    grantPermissionsDecoded0?.append(structure0)
                }
            }
        }
        grantPermissions = grantPermissionsDecoded0
        let revokePermissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .revokePermissions)
        var revokePermissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let revokePermissionsContainer = revokePermissionsContainer {
            revokePermissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in revokePermissionsContainer {
                if let structure0 = structure0 {
                    revokePermissionsDecoded0?.append(structure0)
                }
            }
        }
        revokePermissions = revokePermissionsDecoded0
    }
}

extension UpdateThemePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateThemePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserEditionException" : self = .unsupportedUserEditionException(try UnsupportedUserEditionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateThemePermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedUserEditionException(UnsupportedUserEditionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateThemePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateThemePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.permissions = output.permissions
            self.requestId = output.requestId
            self.themeArn = output.themeArn
            self.themeId = output.themeId
        } else {
            self.permissions = nil
            self.requestId = nil
            self.themeArn = nil
            self.themeId = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateThemePermissionsOutputResponse: Swift.Equatable {
    /// The resulting list of resource permissions for the theme.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The Amazon Resource Name (ARN) of the theme.
    public var themeArn: Swift.String?
    /// The ID for the theme.
    public var themeId: Swift.String?

    public init (
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeArn: Swift.String? = nil,
        themeId: Swift.String? = nil
    )
    {
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
        self.themeArn = themeArn
        self.themeId = themeId
    }
}

struct UpdateThemePermissionsOutputResponseBody: Swift.Equatable {
    let themeId: Swift.String?
    let themeArn: Swift.String?
    let permissions: [QuickSightClientTypes.ResourcePermission]?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateThemePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissions = "Permissions"
        case requestId = "RequestId"
        case status = "Status"
        case themeArn = "ThemeArn"
        case themeId = "ThemeId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeId)
        themeId = themeIdDecoded
        let themeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .themeArn)
        themeArn = themeArnDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ResourcePermission?].self, forKey: .permissions)
        var permissionsDecoded0:[QuickSightClientTypes.ResourcePermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [QuickSightClientTypes.ResourcePermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension UpdateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customFederationProviderUrl = "CustomFederationProviderUrl"
        case customPermissionsName = "CustomPermissionsName"
        case email = "Email"
        case externalLoginFederationProviderType = "ExternalLoginFederationProviderType"
        case externalLoginId = "ExternalLoginId"
        case role = "Role"
        case unapplyCustomPermissions = "UnapplyCustomPermissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customFederationProviderUrl = self.customFederationProviderUrl {
            try encodeContainer.encode(customFederationProviderUrl, forKey: .customFederationProviderUrl)
        }
        if let customPermissionsName = self.customPermissionsName {
            try encodeContainer.encode(customPermissionsName, forKey: .customPermissionsName)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let externalLoginFederationProviderType = self.externalLoginFederationProviderType {
            try encodeContainer.encode(externalLoginFederationProviderType, forKey: .externalLoginFederationProviderType)
        }
        if let externalLoginId = self.externalLoginId {
            try encodeContainer.encode(externalLoginId, forKey: .externalLoginId)
        }
        if let role = self.role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
        if unapplyCustomPermissions != false {
            try encodeContainer.encode(unapplyCustomPermissions, forKey: .unapplyCustomPermissions)
        }
    }
}

extension UpdateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let awsAccountId = awsAccountId else {
            return nil
        }
        guard let namespace = namespace else {
            return nil
        }
        guard let userName = userName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/users/\(userName.urlPercentEncoding())"
    }
}

public struct UpdateUserInput: Swift.Equatable {
    /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The URL of the custom OpenID Connect (OIDC) provider that provides identity to let a user federate into Amazon QuickSight with an associated Identity and Access Management(IAM) role. This parameter should only be used when ExternalLoginFederationProviderType parameter is set to CUSTOM_OIDC.
    public var customFederationProviderUrl: Swift.String?
    /// (Enterprise edition only) The name of the custom permissions profile that you want to assign to this user. Customized permissions allows you to control a user's access by restricting access the following operations:
    ///
    /// * Create and update data sources
    ///
    /// * Create and update datasets
    ///
    /// * Create and update email reports
    ///
    /// * Subscribe to email reports
    ///
    ///
    /// A set of custom permissions includes any combination of these restrictions. Currently, you need to create the profile names for custom permission sets by using the Amazon QuickSight console. Then, you use the RegisterUser API operation to assign the named set of permissions to a Amazon QuickSight user. Amazon QuickSight custom permissions are applied through IAM policies. Therefore, they override the permissions typically granted by assigning Amazon QuickSight users to one of the default security cohorts in Amazon QuickSight (admin, author, reader). This feature is available only to Amazon QuickSight Enterprise edition subscriptions.
    public var customPermissionsName: Swift.String?
    /// The email address of the user that you want to update.
    /// This member is required.
    public var email: Swift.String?
    /// The type of supported external login provider that provides identity to let a user federate into Amazon QuickSight with an associated Identity and Access Management(IAM) role. The type of supported external login provider can be one of the following.
    ///
    /// * COGNITO: Amazon Cognito. The provider URL is cognito-identity.amazonaws.com. When choosing the COGNITO provider type, dont use the "CustomFederationProviderUrl" parameter which is only needed when the external provider is custom.
    ///
    /// * CUSTOM_OIDC: Custom OpenID Connect (OIDC) provider. When choosing CUSTOM_OIDC type, use the CustomFederationProviderUrl parameter to provide the custom OIDC provider URL.
    ///
    /// * NONE: This clears all the previously saved external login information for a user. Use the [DescribeUser](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DescribeUser.html) API operation to check the external login information.
    public var externalLoginFederationProviderType: Swift.String?
    /// The identity ID for a user in the external login provider.
    public var externalLoginId: Swift.String?
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon QuickSight role of the user. The role can be one of the following default security cohorts:
    ///
    /// * READER: A user who has read-only access to dashboards.
    ///
    /// * AUTHOR: A user who can create data sources, datasets, analyses, and dashboards.
    ///
    /// * ADMIN: A user who is an author, who can also manage Amazon QuickSight settings.
    ///
    ///
    /// The name of the Amazon QuickSight role is invisible to the user except for the console screens dealing with permissions.
    /// This member is required.
    public var role: QuickSightClientTypes.UserRole?
    /// A flag that you use to indicate that you want to remove all custom permissions from this user. Using this parameter resets the user to the state it was in before a custom permissions profile was applied. This parameter defaults to NULL and it doesn't accept any other value.
    public var unapplyCustomPermissions: Swift.Bool
    /// The Amazon QuickSight user name that you want to update.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        customFederationProviderUrl: Swift.String? = nil,
        customPermissionsName: Swift.String? = nil,
        email: Swift.String? = nil,
        externalLoginFederationProviderType: Swift.String? = nil,
        externalLoginId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        role: QuickSightClientTypes.UserRole? = nil,
        unapplyCustomPermissions: Swift.Bool = false,
        userName: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.customFederationProviderUrl = customFederationProviderUrl
        self.customPermissionsName = customPermissionsName
        self.email = email
        self.externalLoginFederationProviderType = externalLoginFederationProviderType
        self.externalLoginId = externalLoginId
        self.namespace = namespace
        self.role = role
        self.unapplyCustomPermissions = unapplyCustomPermissions
        self.userName = userName
    }
}

struct UpdateUserInputBody: Swift.Equatable {
    let email: Swift.String?
    let role: QuickSightClientTypes.UserRole?
    let customPermissionsName: Swift.String?
    let unapplyCustomPermissions: Swift.Bool
    let externalLoginFederationProviderType: Swift.String?
    let customFederationProviderUrl: Swift.String?
    let externalLoginId: Swift.String?
}

extension UpdateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customFederationProviderUrl = "CustomFederationProviderUrl"
        case customPermissionsName = "CustomPermissionsName"
        case email = "Email"
        case externalLoginFederationProviderType = "ExternalLoginFederationProviderType"
        case externalLoginId = "ExternalLoginId"
        case role = "Role"
        case unapplyCustomPermissions = "UnapplyCustomPermissions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let roleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.UserRole.self, forKey: .role)
        role = roleDecoded
        let customPermissionsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customPermissionsName)
        customPermissionsName = customPermissionsNameDecoded
        let unapplyCustomPermissionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .unapplyCustomPermissions) ?? false
        unapplyCustomPermissions = unapplyCustomPermissionsDecoded
        let externalLoginFederationProviderTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalLoginFederationProviderType)
        externalLoginFederationProviderType = externalLoginFederationProviderTypeDecoded
        let customFederationProviderUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customFederationProviderUrl)
        customFederationProviderUrl = customFederationProviderUrlDecoded
        let externalLoginIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalLoginId)
        externalLoginId = externalLoginIdDecoded
    }
}

extension UpdateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalFailureException(InternalFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.requestId = output.requestId
            self.user = output.user
        } else {
            self.requestId = nil
            self.user = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

public struct UpdateUserOutputResponse: Swift.Equatable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The Amazon QuickSight user.
    public var user: QuickSightClientTypes.User?

    public init (
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        user: QuickSightClientTypes.User? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.user = user
    }
}

struct UpdateUserOutputResponseBody: Swift.Equatable {
    let user: QuickSightClientTypes.User?
    let requestId: Swift.String?
    let status: Swift.Int
}

extension UpdateUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestId = "RequestId"
        case status = "Status"
        case user = "User"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.User.self, forKey: .user)
        user = userDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .status) ?? 0
        status = statusDecoded
    }
}

extension QuickSightClientTypes.UploadSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containsHeader = "ContainsHeader"
        case delimiter = "Delimiter"
        case format = "Format"
        case startFromRow = "StartFromRow"
        case textQualifier = "TextQualifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containsHeader = self.containsHeader {
            try encodeContainer.encode(containsHeader, forKey: .containsHeader)
        }
        if let delimiter = self.delimiter {
            try encodeContainer.encode(delimiter, forKey: .delimiter)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let startFromRow = self.startFromRow {
            try encodeContainer.encode(startFromRow, forKey: .startFromRow)
        }
        if let textQualifier = self.textQualifier {
            try encodeContainer.encode(textQualifier.rawValue, forKey: .textQualifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FileFormat.self, forKey: .format)
        format = formatDecoded
        let startFromRowDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startFromRow)
        startFromRow = startFromRowDecoded
        let containsHeaderDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .containsHeader)
        containsHeader = containsHeaderDecoded
        let textQualifierDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TextQualifier.self, forKey: .textQualifier)
        textQualifier = textQualifierDecoded
        let delimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
    }
}

extension QuickSightClientTypes {
    /// Information about the format for a source file or files.
    public struct UploadSettings: Swift.Equatable {
        /// Whether the file has a header row, or the files each have a header row.
        public var containsHeader: Swift.Bool?
        /// The delimiter between values in the file.
        public var delimiter: Swift.String?
        /// File format.
        public var format: QuickSightClientTypes.FileFormat?
        /// A row number to start reading data from.
        public var startFromRow: Swift.Int?
        /// Text qualifier.
        public var textQualifier: QuickSightClientTypes.TextQualifier?

        public init (
            containsHeader: Swift.Bool? = nil,
            delimiter: Swift.String? = nil,
            format: QuickSightClientTypes.FileFormat? = nil,
            startFromRow: Swift.Int? = nil,
            textQualifier: QuickSightClientTypes.TextQualifier? = nil
        )
        {
            self.containsHeader = containsHeader
            self.delimiter = delimiter
            self.format = format
            self.startFromRow = startFromRow
            self.textQualifier = textQualifier
        }
    }

}

extension QuickSightClientTypes.User: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case active = "Active"
        case arn = "Arn"
        case customPermissionsName = "CustomPermissionsName"
        case email = "Email"
        case externalLoginFederationProviderType = "ExternalLoginFederationProviderType"
        case externalLoginFederationProviderUrl = "ExternalLoginFederationProviderUrl"
        case externalLoginId = "ExternalLoginId"
        case identityType = "IdentityType"
        case principalId = "PrincipalId"
        case role = "Role"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if active != false {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let customPermissionsName = self.customPermissionsName {
            try encodeContainer.encode(customPermissionsName, forKey: .customPermissionsName)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let externalLoginFederationProviderType = self.externalLoginFederationProviderType {
            try encodeContainer.encode(externalLoginFederationProviderType, forKey: .externalLoginFederationProviderType)
        }
        if let externalLoginFederationProviderUrl = self.externalLoginFederationProviderUrl {
            try encodeContainer.encode(externalLoginFederationProviderUrl, forKey: .externalLoginFederationProviderUrl)
        }
        if let externalLoginId = self.externalLoginId {
            try encodeContainer.encode(externalLoginId, forKey: .externalLoginId)
        }
        if let identityType = self.identityType {
            try encodeContainer.encode(identityType.rawValue, forKey: .identityType)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let role = self.role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let roleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.UserRole.self, forKey: .role)
        role = roleDecoded
        let identityTypeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.IdentityType.self, forKey: .identityType)
        identityType = identityTypeDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active) ?? false
        active = activeDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let customPermissionsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customPermissionsName)
        customPermissionsName = customPermissionsNameDecoded
        let externalLoginFederationProviderTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalLoginFederationProviderType)
        externalLoginFederationProviderType = externalLoginFederationProviderTypeDecoded
        let externalLoginFederationProviderUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalLoginFederationProviderUrl)
        externalLoginFederationProviderUrl = externalLoginFederationProviderUrlDecoded
        let externalLoginIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalLoginId)
        externalLoginId = externalLoginIdDecoded
    }
}

extension QuickSightClientTypes {
    /// A registered user of Amazon QuickSight.
    public struct User: Swift.Equatable {
        /// The active status of user. When you create an Amazon QuickSight user thats not an IAM user or an Active Directory user, that user is inactive until they sign in and provide a password.
        public var active: Swift.Bool
        /// The Amazon Resource Name (ARN) for the user.
        public var arn: Swift.String?
        /// The custom permissions profile associated with this user.
        public var customPermissionsName: Swift.String?
        /// The user's email address.
        public var email: Swift.String?
        /// The type of supported external login provider that provides identity to let the user federate into Amazon QuickSight with an associated IAM role. The type can be one of the following.
        ///
        /// * COGNITO: Amazon Cognito. The provider URL is cognito-identity.amazonaws.com.
        ///
        /// * CUSTOM_OIDC: Custom OpenID Connect (OIDC) provider.
        public var externalLoginFederationProviderType: Swift.String?
        /// The URL of the external login provider.
        public var externalLoginFederationProviderUrl: Swift.String?
        /// The identity ID for the user in the external login provider.
        public var externalLoginId: Swift.String?
        /// The type of identity authentication used by the user.
        public var identityType: QuickSightClientTypes.IdentityType?
        /// The principal ID of the user.
        public var principalId: Swift.String?
        /// The Amazon QuickSight role for the user. The user role can be one of the following:.
        ///
        /// * READER: A user who has read-only access to dashboards.
        ///
        /// * AUTHOR: A user who can create data sources, datasets, analyses, and dashboards.
        ///
        /// * ADMIN: A user who is an author, who can also manage Amazon Amazon QuickSight settings.
        ///
        /// * RESTRICTED_READER: This role isn't currently available for use.
        ///
        /// * RESTRICTED_AUTHOR: This role isn't currently available for use.
        public var role: QuickSightClientTypes.UserRole?
        /// The user's user name. This value is required if you are registering a user that will be managed in Amazon QuickSight. In the output, the value for UserName is N/A when the value for IdentityType is IAM and the corresponding IAM user is deleted.
        public var userName: Swift.String?

        public init (
            active: Swift.Bool = false,
            arn: Swift.String? = nil,
            customPermissionsName: Swift.String? = nil,
            email: Swift.String? = nil,
            externalLoginFederationProviderType: Swift.String? = nil,
            externalLoginFederationProviderUrl: Swift.String? = nil,
            externalLoginId: Swift.String? = nil,
            identityType: QuickSightClientTypes.IdentityType? = nil,
            principalId: Swift.String? = nil,
            role: QuickSightClientTypes.UserRole? = nil,
            userName: Swift.String? = nil
        )
        {
            self.active = active
            self.arn = arn
            self.customPermissionsName = customPermissionsName
            self.email = email
            self.externalLoginFederationProviderType = externalLoginFederationProviderType
            self.externalLoginFederationProviderUrl = externalLoginFederationProviderUrl
            self.externalLoginId = externalLoginId
            self.identityType = identityType
            self.principalId = principalId
            self.role = role
            self.userName = userName
        }
    }

}

extension QuickSightClientTypes {
    public enum UserRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case admin
        case author
        case reader
        case restrictedAuthor
        case restrictedReader
        case sdkUnknown(Swift.String)

        public static var allCases: [UserRole] {
            return [
                .admin,
                .author,
                .reader,
                .restrictedAuthor,
                .restrictedReader,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .admin: return "ADMIN"
            case .author: return "AUTHOR"
            case .reader: return "READER"
            case .restrictedAuthor: return "RESTRICTED_AUTHOR"
            case .restrictedReader: return "RESTRICTED_READER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserRole(rawValue: rawValue) ?? UserRole.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum ValueWhenUnsetOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case null
        case recommendedValue
        case sdkUnknown(Swift.String)

        public static var allCases: [ValueWhenUnsetOption] {
            return [
                .null,
                .recommendedValue,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .null: return "NULL"
            case .recommendedValue: return "RECOMMENDED_VALUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValueWhenUnsetOption(rawValue: rawValue) ?? ValueWhenUnsetOption.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum VerticalTextAlignment: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bottom
        case middle
        case top
        case sdkUnknown(Swift.String)

        public static var allCases: [VerticalTextAlignment] {
            return [
                .bottom,
                .middle,
                .top,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bottom: return "BOTTOM"
            case .middle: return "MIDDLE"
            case .top: return "TOP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VerticalTextAlignment(rawValue: rawValue) ?? VerticalTextAlignment.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum Visibility: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hidden
        case visible
        case sdkUnknown(Swift.String)

        public static var allCases: [Visibility] {
            return [
                .hidden,
                .visible,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hidden: return "HIDDEN"
            case .visible: return "VISIBLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Visibility(rawValue: rawValue) ?? Visibility.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.VisibleRangeOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case percentRange = "PercentRange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let percentRange = self.percentRange {
            try encodeContainer.encode(percentRange, forKey: .percentRange)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentRangeDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PercentVisibleRange.self, forKey: .percentRange)
        percentRange = percentRangeDecoded
    }
}

extension QuickSightClientTypes {
    /// The range options for the data zoom scroll bar.
    public struct VisibleRangeOptions: Swift.Equatable {
        /// The percent range in the visible range.
        public var percentRange: QuickSightClientTypes.PercentVisibleRange?

        public init (
            percentRange: QuickSightClientTypes.PercentVisibleRange? = nil
        )
        {
            self.percentRange = percentRange
        }
    }

}

extension QuickSightClientTypes.Visual: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case barChartVisual = "BarChartVisual"
        case boxPlotVisual = "BoxPlotVisual"
        case comboChartVisual = "ComboChartVisual"
        case customContentVisual = "CustomContentVisual"
        case emptyVisual = "EmptyVisual"
        case filledMapVisual = "FilledMapVisual"
        case funnelChartVisual = "FunnelChartVisual"
        case gaugeChartVisual = "GaugeChartVisual"
        case geospatialMapVisual = "GeospatialMapVisual"
        case heatMapVisual = "HeatMapVisual"
        case histogramVisual = "HistogramVisual"
        case insightVisual = "InsightVisual"
        case kpiVisual = "KPIVisual"
        case lineChartVisual = "LineChartVisual"
        case pieChartVisual = "PieChartVisual"
        case pivotTableVisual = "PivotTableVisual"
        case sankeyDiagramVisual = "SankeyDiagramVisual"
        case scatterPlotVisual = "ScatterPlotVisual"
        case tableVisual = "TableVisual"
        case treeMapVisual = "TreeMapVisual"
        case waterfallVisual = "WaterfallVisual"
        case wordCloudVisual = "WordCloudVisual"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let barChartVisual = self.barChartVisual {
            try encodeContainer.encode(barChartVisual, forKey: .barChartVisual)
        }
        if let boxPlotVisual = self.boxPlotVisual {
            try encodeContainer.encode(boxPlotVisual, forKey: .boxPlotVisual)
        }
        if let comboChartVisual = self.comboChartVisual {
            try encodeContainer.encode(comboChartVisual, forKey: .comboChartVisual)
        }
        if let customContentVisual = self.customContentVisual {
            try encodeContainer.encode(customContentVisual, forKey: .customContentVisual)
        }
        if let emptyVisual = self.emptyVisual {
            try encodeContainer.encode(emptyVisual, forKey: .emptyVisual)
        }
        if let filledMapVisual = self.filledMapVisual {
            try encodeContainer.encode(filledMapVisual, forKey: .filledMapVisual)
        }
        if let funnelChartVisual = self.funnelChartVisual {
            try encodeContainer.encode(funnelChartVisual, forKey: .funnelChartVisual)
        }
        if let gaugeChartVisual = self.gaugeChartVisual {
            try encodeContainer.encode(gaugeChartVisual, forKey: .gaugeChartVisual)
        }
        if let geospatialMapVisual = self.geospatialMapVisual {
            try encodeContainer.encode(geospatialMapVisual, forKey: .geospatialMapVisual)
        }
        if let heatMapVisual = self.heatMapVisual {
            try encodeContainer.encode(heatMapVisual, forKey: .heatMapVisual)
        }
        if let histogramVisual = self.histogramVisual {
            try encodeContainer.encode(histogramVisual, forKey: .histogramVisual)
        }
        if let insightVisual = self.insightVisual {
            try encodeContainer.encode(insightVisual, forKey: .insightVisual)
        }
        if let kpiVisual = self.kpiVisual {
            try encodeContainer.encode(kpiVisual, forKey: .kpiVisual)
        }
        if let lineChartVisual = self.lineChartVisual {
            try encodeContainer.encode(lineChartVisual, forKey: .lineChartVisual)
        }
        if let pieChartVisual = self.pieChartVisual {
            try encodeContainer.encode(pieChartVisual, forKey: .pieChartVisual)
        }
        if let pivotTableVisual = self.pivotTableVisual {
            try encodeContainer.encode(pivotTableVisual, forKey: .pivotTableVisual)
        }
        if let sankeyDiagramVisual = self.sankeyDiagramVisual {
            try encodeContainer.encode(sankeyDiagramVisual, forKey: .sankeyDiagramVisual)
        }
        if let scatterPlotVisual = self.scatterPlotVisual {
            try encodeContainer.encode(scatterPlotVisual, forKey: .scatterPlotVisual)
        }
        if let tableVisual = self.tableVisual {
            try encodeContainer.encode(tableVisual, forKey: .tableVisual)
        }
        if let treeMapVisual = self.treeMapVisual {
            try encodeContainer.encode(treeMapVisual, forKey: .treeMapVisual)
        }
        if let waterfallVisual = self.waterfallVisual {
            try encodeContainer.encode(waterfallVisual, forKey: .waterfallVisual)
        }
        if let wordCloudVisual = self.wordCloudVisual {
            try encodeContainer.encode(wordCloudVisual, forKey: .wordCloudVisual)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableVisualDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TableVisual.self, forKey: .tableVisual)
        tableVisual = tableVisualDecoded
        let pivotTableVisualDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PivotTableVisual.self, forKey: .pivotTableVisual)
        pivotTableVisual = pivotTableVisualDecoded
        let barChartVisualDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.BarChartVisual.self, forKey: .barChartVisual)
        barChartVisual = barChartVisualDecoded
        let kpiVisualDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.KPIVisual.self, forKey: .kpiVisual)
        kpiVisual = kpiVisualDecoded
        let pieChartVisualDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.PieChartVisual.self, forKey: .pieChartVisual)
        pieChartVisual = pieChartVisualDecoded
        let gaugeChartVisualDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GaugeChartVisual.self, forKey: .gaugeChartVisual)
        gaugeChartVisual = gaugeChartVisualDecoded
        let lineChartVisualDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LineChartVisual.self, forKey: .lineChartVisual)
        lineChartVisual = lineChartVisualDecoded
        let heatMapVisualDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.HeatMapVisual.self, forKey: .heatMapVisual)
        heatMapVisual = heatMapVisualDecoded
        let treeMapVisualDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.TreeMapVisual.self, forKey: .treeMapVisual)
        treeMapVisual = treeMapVisualDecoded
        let geospatialMapVisualDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.GeospatialMapVisual.self, forKey: .geospatialMapVisual)
        geospatialMapVisual = geospatialMapVisualDecoded
        let filledMapVisualDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FilledMapVisual.self, forKey: .filledMapVisual)
        filledMapVisual = filledMapVisualDecoded
        let funnelChartVisualDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.FunnelChartVisual.self, forKey: .funnelChartVisual)
        funnelChartVisual = funnelChartVisualDecoded
        let scatterPlotVisualDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ScatterPlotVisual.self, forKey: .scatterPlotVisual)
        scatterPlotVisual = scatterPlotVisualDecoded
        let comboChartVisualDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ComboChartVisual.self, forKey: .comboChartVisual)
        comboChartVisual = comboChartVisualDecoded
        let boxPlotVisualDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.BoxPlotVisual.self, forKey: .boxPlotVisual)
        boxPlotVisual = boxPlotVisualDecoded
        let waterfallVisualDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.WaterfallVisual.self, forKey: .waterfallVisual)
        waterfallVisual = waterfallVisualDecoded
        let histogramVisualDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.HistogramVisual.self, forKey: .histogramVisual)
        histogramVisual = histogramVisualDecoded
        let wordCloudVisualDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.WordCloudVisual.self, forKey: .wordCloudVisual)
        wordCloudVisual = wordCloudVisualDecoded
        let insightVisualDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.InsightVisual.self, forKey: .insightVisual)
        insightVisual = insightVisualDecoded
        let sankeyDiagramVisualDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.SankeyDiagramVisual.self, forKey: .sankeyDiagramVisual)
        sankeyDiagramVisual = sankeyDiagramVisualDecoded
        let customContentVisualDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CustomContentVisual.self, forKey: .customContentVisual)
        customContentVisual = customContentVisualDecoded
        let emptyVisualDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.EmptyVisual.self, forKey: .emptyVisual)
        emptyVisual = emptyVisualDecoded
    }
}

extension QuickSightClientTypes {
    /// A visual displayed on a sheet in an analysis, dashboard, or template. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct Visual: Swift.Equatable {
        /// A bar chart. For more information, see [Using bar charts](https://docs.aws.amazon.com/quicksight/latest/user/bar-charts.html) in the Amazon QuickSight User Guide.
        public var barChartVisual: QuickSightClientTypes.BarChartVisual?
        /// A box plot. For more information, see [Using box plots](https://docs.aws.amazon.com/quicksight/latest/user/box-plots.html) in the Amazon QuickSight User Guide.
        public var boxPlotVisual: QuickSightClientTypes.BoxPlotVisual?
        /// A combo chart. For more information, see [Using combo charts](https://docs.aws.amazon.com/quicksight/latest/user/combo-charts.html) in the Amazon QuickSight User Guide.
        public var comboChartVisual: QuickSightClientTypes.ComboChartVisual?
        /// A visual that contains custom content. For more information, see [Using custom visual content](https://docs.aws.amazon.com/quicksight/latest/user/custom-visual-content.html) in the Amazon QuickSight User Guide.
        public var customContentVisual: QuickSightClientTypes.CustomContentVisual?
        /// An empty visual.
        public var emptyVisual: QuickSightClientTypes.EmptyVisual?
        /// A filled map. For more information, see [Creating filled maps](https://docs.aws.amazon.com/quicksight/latest/user/filled-maps.html) in the Amazon QuickSight User Guide.
        public var filledMapVisual: QuickSightClientTypes.FilledMapVisual?
        /// A funnel chart. For more information, see [Using funnel charts](https://docs.aws.amazon.com/quicksight/latest/user/funnel-visual-content.html) in the Amazon QuickSight User Guide.
        public var funnelChartVisual: QuickSightClientTypes.FunnelChartVisual?
        /// A gauge chart. For more information, see [Using gauge charts](https://docs.aws.amazon.com/quicksight/latest/user/gauge-chart.html) in the Amazon QuickSight User Guide.
        public var gaugeChartVisual: QuickSightClientTypes.GaugeChartVisual?
        /// A geospatial map or a points on map visual. For more information, see [Creating point maps](https://docs.aws.amazon.com/quicksight/latest/user/point-maps.html) in the Amazon QuickSight User Guide.
        public var geospatialMapVisual: QuickSightClientTypes.GeospatialMapVisual?
        /// A heat map. For more information, see [Using heat maps](https://docs.aws.amazon.com/quicksight/latest/user/heat-map.html) in the Amazon QuickSight User Guide.
        public var heatMapVisual: QuickSightClientTypes.HeatMapVisual?
        /// A histogram. For more information, see [Using histograms](https://docs.aws.amazon.com/quicksight/latest/user/histogram-charts.html) in the Amazon QuickSight User Guide.
        public var histogramVisual: QuickSightClientTypes.HistogramVisual?
        /// An insight visual. For more information, see [Working with insights](https://docs.aws.amazon.com/quicksight/latest/user/computational-insights.html) in the Amazon QuickSight User Guide.
        public var insightVisual: QuickSightClientTypes.InsightVisual?
        /// A key performance indicator (KPI). For more information, see [Using KPIs](https://docs.aws.amazon.com/quicksight/latest/user/kpi.html) in the Amazon QuickSight User Guide.
        public var kpiVisual: QuickSightClientTypes.KPIVisual?
        /// A line chart. For more information, see [Using line charts](https://docs.aws.amazon.com/quicksight/latest/user/line-charts.html) in the Amazon QuickSight User Guide.
        public var lineChartVisual: QuickSightClientTypes.LineChartVisual?
        /// A pie or donut chart. For more information, see [Using pie charts](https://docs.aws.amazon.com/quicksight/latest/user/pie-chart.html) in the Amazon QuickSight User Guide.
        public var pieChartVisual: QuickSightClientTypes.PieChartVisual?
        /// A pivot table. For more information, see [Using pivot tables](https://docs.aws.amazon.com/quicksight/latest/user/pivot-table.html) in the Amazon QuickSight User Guide.
        public var pivotTableVisual: QuickSightClientTypes.PivotTableVisual?
        /// A sankey diagram. For more information, see [Using Sankey diagrams](https://docs.aws.amazon.com/quicksight/latest/user/sankey-diagram.html) in the Amazon QuickSight User Guide.
        public var sankeyDiagramVisual: QuickSightClientTypes.SankeyDiagramVisual?
        /// A scatter plot. For more information, see [Using scatter plots](https://docs.aws.amazon.com/quicksight/latest/user/scatter-plot.html) in the Amazon QuickSight User Guide.
        public var scatterPlotVisual: QuickSightClientTypes.ScatterPlotVisual?
        /// A table visual. For more information, see [Using tables as visuals](https://docs.aws.amazon.com/quicksight/latest/user/tabular.html) in the Amazon QuickSight User Guide.
        public var tableVisual: QuickSightClientTypes.TableVisual?
        /// A tree map. For more information, see [Using tree maps](https://docs.aws.amazon.com/quicksight/latest/user/tree-map.html) in the Amazon QuickSight User Guide.
        public var treeMapVisual: QuickSightClientTypes.TreeMapVisual?
        /// A waterfall chart. For more information, see [Using waterfall charts](https://docs.aws.amazon.com/quicksight/latest/user/waterfall-chart.html) in the Amazon QuickSight User Guide.
        public var waterfallVisual: QuickSightClientTypes.WaterfallVisual?
        /// A word cloud. For more information, see [Using word clouds](https://docs.aws.amazon.com/quicksight/latest/user/word-cloud.html) in the Amazon QuickSight User Guide.
        public var wordCloudVisual: QuickSightClientTypes.WordCloudVisual?

        public init (
            barChartVisual: QuickSightClientTypes.BarChartVisual? = nil,
            boxPlotVisual: QuickSightClientTypes.BoxPlotVisual? = nil,
            comboChartVisual: QuickSightClientTypes.ComboChartVisual? = nil,
            customContentVisual: QuickSightClientTypes.CustomContentVisual? = nil,
            emptyVisual: QuickSightClientTypes.EmptyVisual? = nil,
            filledMapVisual: QuickSightClientTypes.FilledMapVisual? = nil,
            funnelChartVisual: QuickSightClientTypes.FunnelChartVisual? = nil,
            gaugeChartVisual: QuickSightClientTypes.GaugeChartVisual? = nil,
            geospatialMapVisual: QuickSightClientTypes.GeospatialMapVisual? = nil,
            heatMapVisual: QuickSightClientTypes.HeatMapVisual? = nil,
            histogramVisual: QuickSightClientTypes.HistogramVisual? = nil,
            insightVisual: QuickSightClientTypes.InsightVisual? = nil,
            kpiVisual: QuickSightClientTypes.KPIVisual? = nil,
            lineChartVisual: QuickSightClientTypes.LineChartVisual? = nil,
            pieChartVisual: QuickSightClientTypes.PieChartVisual? = nil,
            pivotTableVisual: QuickSightClientTypes.PivotTableVisual? = nil,
            sankeyDiagramVisual: QuickSightClientTypes.SankeyDiagramVisual? = nil,
            scatterPlotVisual: QuickSightClientTypes.ScatterPlotVisual? = nil,
            tableVisual: QuickSightClientTypes.TableVisual? = nil,
            treeMapVisual: QuickSightClientTypes.TreeMapVisual? = nil,
            waterfallVisual: QuickSightClientTypes.WaterfallVisual? = nil,
            wordCloudVisual: QuickSightClientTypes.WordCloudVisual? = nil
        )
        {
            self.barChartVisual = barChartVisual
            self.boxPlotVisual = boxPlotVisual
            self.comboChartVisual = comboChartVisual
            self.customContentVisual = customContentVisual
            self.emptyVisual = emptyVisual
            self.filledMapVisual = filledMapVisual
            self.funnelChartVisual = funnelChartVisual
            self.gaugeChartVisual = gaugeChartVisual
            self.geospatialMapVisual = geospatialMapVisual
            self.heatMapVisual = heatMapVisual
            self.histogramVisual = histogramVisual
            self.insightVisual = insightVisual
            self.kpiVisual = kpiVisual
            self.lineChartVisual = lineChartVisual
            self.pieChartVisual = pieChartVisual
            self.pivotTableVisual = pivotTableVisual
            self.sankeyDiagramVisual = sankeyDiagramVisual
            self.scatterPlotVisual = scatterPlotVisual
            self.tableVisual = tableVisual
            self.treeMapVisual = treeMapVisual
            self.waterfallVisual = waterfallVisual
            self.wordCloudVisual = wordCloudVisual
        }
    }

}

extension QuickSightClientTypes.VisualCustomAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionOperations = "ActionOperations"
        case customActionId = "CustomActionId"
        case name = "Name"
        case status = "Status"
        case trigger = "Trigger"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionOperations = actionOperations {
            var actionOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actionOperations)
            for visualcustomactionoperation0 in actionOperations {
                try actionOperationsContainer.encode(visualcustomactionoperation0)
            }
        }
        if let customActionId = self.customActionId {
            try encodeContainer.encode(customActionId, forKey: .customActionId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let trigger = self.trigger {
            try encodeContainer.encode(trigger.rawValue, forKey: .trigger)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customActionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customActionId)
        customActionId = customActionIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.WidgetStatus.self, forKey: .status)
        status = statusDecoded
        let triggerDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualCustomActionTrigger.self, forKey: .trigger)
        trigger = triggerDecoded
        let actionOperationsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.VisualCustomActionOperation?].self, forKey: .actionOperations)
        var actionOperationsDecoded0:[QuickSightClientTypes.VisualCustomActionOperation]? = nil
        if let actionOperationsContainer = actionOperationsContainer {
            actionOperationsDecoded0 = [QuickSightClientTypes.VisualCustomActionOperation]()
            for structure0 in actionOperationsContainer {
                if let structure0 = structure0 {
                    actionOperationsDecoded0?.append(structure0)
                }
            }
        }
        actionOperations = actionOperationsDecoded0
    }
}

extension QuickSightClientTypes {
    /// A custom action defined on a visual.
    public struct VisualCustomAction: Swift.Equatable {
        /// A list of VisualCustomActionOperations. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
        /// This member is required.
        public var actionOperations: [QuickSightClientTypes.VisualCustomActionOperation]?
        /// The ID of the VisualCustomAction.
        /// This member is required.
        public var customActionId: Swift.String?
        /// The name of the VisualCustomAction.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the VisualCustomAction.
        public var status: QuickSightClientTypes.WidgetStatus?
        /// The trigger of the VisualCustomAction. Valid values are defined as follows:
        ///
        /// * DATA_POINT_CLICK: Initiates a custom action by a left pointer click on a data point.
        ///
        /// * DATA_POINT_MENU: Initiates a custom action by right pointer click from the menu.
        /// This member is required.
        public var trigger: QuickSightClientTypes.VisualCustomActionTrigger?

        public init (
            actionOperations: [QuickSightClientTypes.VisualCustomActionOperation]? = nil,
            customActionId: Swift.String? = nil,
            name: Swift.String? = nil,
            status: QuickSightClientTypes.WidgetStatus? = nil,
            trigger: QuickSightClientTypes.VisualCustomActionTrigger? = nil
        )
        {
            self.actionOperations = actionOperations
            self.customActionId = customActionId
            self.name = name
            self.status = status
            self.trigger = trigger
        }
    }

}

extension QuickSightClientTypes.VisualCustomActionOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterOperation = "FilterOperation"
        case navigationOperation = "NavigationOperation"
        case setParametersOperation = "SetParametersOperation"
        case urlOperation = "URLOperation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterOperation = self.filterOperation {
            try encodeContainer.encode(filterOperation, forKey: .filterOperation)
        }
        if let navigationOperation = self.navigationOperation {
            try encodeContainer.encode(navigationOperation, forKey: .navigationOperation)
        }
        if let setParametersOperation = self.setParametersOperation {
            try encodeContainer.encode(setParametersOperation, forKey: .setParametersOperation)
        }
        if let urlOperation = self.urlOperation {
            try encodeContainer.encode(urlOperation, forKey: .urlOperation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterOperationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CustomActionFilterOperation.self, forKey: .filterOperation)
        filterOperation = filterOperationDecoded
        let navigationOperationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CustomActionNavigationOperation.self, forKey: .navigationOperation)
        navigationOperation = navigationOperationDecoded
        let urlOperationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CustomActionURLOperation.self, forKey: .urlOperation)
        urlOperation = urlOperationDecoded
        let setParametersOperationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.CustomActionSetParametersOperation.self, forKey: .setParametersOperation)
        setParametersOperation = setParametersOperationDecoded
    }
}

extension QuickSightClientTypes {
    /// The operation that is defined by the custom action. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct VisualCustomActionOperation: Swift.Equatable {
        /// The filter operation that filters data included in a visual or in an entire sheet.
        public var filterOperation: QuickSightClientTypes.CustomActionFilterOperation?
        /// The navigation operation that navigates between different sheets in the same analysis.
        public var navigationOperation: QuickSightClientTypes.CustomActionNavigationOperation?
        /// The set parameter operation that sets parameters in custom action.
        public var setParametersOperation: QuickSightClientTypes.CustomActionSetParametersOperation?
        /// The URL operation that opens a link to another webpage.
        public var urlOperation: QuickSightClientTypes.CustomActionURLOperation?

        public init (
            filterOperation: QuickSightClientTypes.CustomActionFilterOperation? = nil,
            navigationOperation: QuickSightClientTypes.CustomActionNavigationOperation? = nil,
            setParametersOperation: QuickSightClientTypes.CustomActionSetParametersOperation? = nil,
            urlOperation: QuickSightClientTypes.CustomActionURLOperation? = nil
        )
        {
            self.filterOperation = filterOperation
            self.navigationOperation = navigationOperation
            self.setParametersOperation = setParametersOperation
            self.urlOperation = urlOperation
        }
    }

}

extension QuickSightClientTypes {
    public enum VisualCustomActionTrigger: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dataPointClick
        case dataPointMenu
        case sdkUnknown(Swift.String)

        public static var allCases: [VisualCustomActionTrigger] {
            return [
                .dataPointClick,
                .dataPointMenu,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dataPointClick: return "DATA_POINT_CLICK"
            case .dataPointMenu: return "DATA_POINT_MENU"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VisualCustomActionTrigger(rawValue: rawValue) ?? VisualCustomActionTrigger.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.VisualPalette: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chartColor = "ChartColor"
        case colorMap = "ColorMap"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chartColor = self.chartColor {
            try encodeContainer.encode(chartColor, forKey: .chartColor)
        }
        if let colorMap = colorMap {
            var colorMapContainer = encodeContainer.nestedUnkeyedContainer(forKey: .colorMap)
            for datapathcolor0 in colorMap {
                try colorMapContainer.encode(datapathcolor0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chartColorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chartColor)
        chartColor = chartColorDecoded
        let colorMapContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DataPathColor?].self, forKey: .colorMap)
        var colorMapDecoded0:[QuickSightClientTypes.DataPathColor]? = nil
        if let colorMapContainer = colorMapContainer {
            colorMapDecoded0 = [QuickSightClientTypes.DataPathColor]()
            for structure0 in colorMapContainer {
                if let structure0 = structure0 {
                    colorMapDecoded0?.append(structure0)
                }
            }
        }
        colorMap = colorMapDecoded0
    }
}

extension QuickSightClientTypes {
    /// The visual display options for the visual palette.
    public struct VisualPalette: Swift.Equatable {
        /// The chart color options for the visual palette.
        public var chartColor: Swift.String?
        /// The color map options for the visual palette.
        public var colorMap: [QuickSightClientTypes.DataPathColor]?

        public init (
            chartColor: Swift.String? = nil,
            colorMap: [QuickSightClientTypes.DataPathColor]? = nil
        )
        {
            self.chartColor = chartColor
            self.colorMap = colorMap
        }
    }

}

extension QuickSightClientTypes.VisualSubtitleLabelOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case formatText = "FormatText"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let formatText = self.formatText {
            try encodeContainer.encode(formatText, forKey: .formatText)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
        let formatTextDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LongFormatText.self, forKey: .formatText)
        formatText = formatTextDecoded
    }
}

extension QuickSightClientTypes {
    /// The subtitle label options for a visual.
    public struct VisualSubtitleLabelOptions: Swift.Equatable {
        /// The long text format of the subtitle label, such as plain text or rich text.
        public var formatText: QuickSightClientTypes.LongFormatText?
        /// The visibility of the subtitle label.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            formatText: QuickSightClientTypes.LongFormatText? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.formatText = formatText
            self.visibility = visibility
        }
    }

}

extension QuickSightClientTypes.VisualTitleLabelOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case formatText = "FormatText"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let formatText = self.formatText {
            try encodeContainer.encode(formatText, forKey: .formatText)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visibilityDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.Visibility.self, forKey: .visibility)
        visibility = visibilityDecoded
        let formatTextDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ShortFormatText.self, forKey: .formatText)
        formatText = formatTextDecoded
    }
}

extension QuickSightClientTypes {
    /// The title label options for a visual.
    public struct VisualTitleLabelOptions: Swift.Equatable {
        /// The short text format of the title label, such as plain text or rich text.
        public var formatText: QuickSightClientTypes.ShortFormatText?
        /// The visibility of the title label.
        public var visibility: QuickSightClientTypes.Visibility?

        public init (
            formatText: QuickSightClientTypes.ShortFormatText? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.formatText = formatText
            self.visibility = visibility
        }
    }

}

extension QuickSightClientTypes.VpcConnectionProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcConnectionArn = "VpcConnectionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vpcConnectionArn = self.vpcConnectionArn {
            try encodeContainer.encode(vpcConnectionArn, forKey: .vpcConnectionArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConnectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcConnectionArn)
        vpcConnectionArn = vpcConnectionArnDecoded
    }
}

extension QuickSightClientTypes {
    /// VPC connection properties.
    public struct VpcConnectionProperties: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the VPC connection.
        /// This member is required.
        public var vpcConnectionArn: Swift.String?

        public init (
            vpcConnectionArn: Swift.String? = nil
        )
        {
            self.vpcConnectionArn = vpcConnectionArn
        }
    }

}

extension QuickSightClientTypes.WaterfallChartAggregatedFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case breakdowns = "Breakdowns"
        case categories = "Categories"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let breakdowns = breakdowns {
            var breakdownsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .breakdowns)
            for dimensionfield0 in breakdowns {
                try breakdownsContainer.encode(dimensionfield0)
            }
        }
        if let categories = categories {
            var categoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categories)
            for dimensionfield0 in categories {
                try categoriesContainer.encode(dimensionfield0)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for measurefield0 in values {
                try valuesContainer.encode(measurefield0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoriesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .categories)
        var categoriesDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let categoriesContainer = categoriesContainer {
            categoriesDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in categoriesContainer {
                if let structure0 = structure0 {
                    categoriesDecoded0?.append(structure0)
                }
            }
        }
        categories = categoriesDecoded0
        let valuesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .values)
        var valuesDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
        let breakdownsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .breakdowns)
        var breakdownsDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let breakdownsContainer = breakdownsContainer {
            breakdownsDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in breakdownsContainer {
                if let structure0 = structure0 {
                    breakdownsDecoded0?.append(structure0)
                }
            }
        }
        breakdowns = breakdownsDecoded0
    }
}

extension QuickSightClientTypes {
    /// The field well configuration of a waterfall visual.
    public struct WaterfallChartAggregatedFieldWells: Swift.Equatable {
        /// The breakdown field wells of a waterfall visual.
        public var breakdowns: [QuickSightClientTypes.DimensionField]?
        /// The category field wells of a waterfall visual.
        public var categories: [QuickSightClientTypes.DimensionField]?
        /// The value field wells of a waterfall visual.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init (
            breakdowns: [QuickSightClientTypes.DimensionField]? = nil,
            categories: [QuickSightClientTypes.DimensionField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.breakdowns = breakdowns
            self.categories = categories
            self.values = values
        }
    }

}

extension QuickSightClientTypes.WaterfallChartConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryAxisDisplayOptions = "CategoryAxisDisplayOptions"
        case categoryAxisLabelOptions = "CategoryAxisLabelOptions"
        case dataLabels = "DataLabels"
        case fieldWells = "FieldWells"
        case legend = "Legend"
        case primaryYAxisDisplayOptions = "PrimaryYAxisDisplayOptions"
        case primaryYAxisLabelOptions = "PrimaryYAxisLabelOptions"
        case sortConfiguration = "SortConfiguration"
        case visualPalette = "VisualPalette"
        case waterfallChartOptions = "WaterfallChartOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryAxisDisplayOptions = self.categoryAxisDisplayOptions {
            try encodeContainer.encode(categoryAxisDisplayOptions, forKey: .categoryAxisDisplayOptions)
        }
        if let categoryAxisLabelOptions = self.categoryAxisLabelOptions {
            try encodeContainer.encode(categoryAxisLabelOptions, forKey: .categoryAxisLabelOptions)
        }
        if let dataLabels = self.dataLabels {
            try encodeContainer.encode(dataLabels, forKey: .dataLabels)
        }
        if let fieldWells = self.fieldWells {
            try encodeContainer.encode(fieldWells, forKey: .fieldWells)
        }
        if let legend = self.legend {
            try encodeContainer.encode(legend, forKey: .legend)
        }
        if let primaryYAxisDisplayOptions = self.primaryYAxisDisplayOptions {
            try encodeContainer.encode(primaryYAxisDisplayOptions, forKey: .primaryYAxisDisplayOptions)
        }
        if let primaryYAxisLabelOptions = self.primaryYAxisLabelOptions {
            try encodeContainer.encode(primaryYAxisLabelOptions, forKey: .primaryYAxisLabelOptions)
        }
        if let sortConfiguration = self.sortConfiguration {
            try encodeContainer.encode(sortConfiguration, forKey: .sortConfiguration)
        }
        if let visualPalette = self.visualPalette {
            try encodeContainer.encode(visualPalette, forKey: .visualPalette)
        }
        if let waterfallChartOptions = self.waterfallChartOptions {
            try encodeContainer.encode(waterfallChartOptions, forKey: .waterfallChartOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.WaterfallChartFieldWells.self, forKey: .fieldWells)
        fieldWells = fieldWellsDecoded
        let sortConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.WaterfallChartSortConfiguration.self, forKey: .sortConfiguration)
        sortConfiguration = sortConfigurationDecoded
        let waterfallChartOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.WaterfallChartOptions.self, forKey: .waterfallChartOptions)
        waterfallChartOptions = waterfallChartOptionsDecoded
        let categoryAxisLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .categoryAxisLabelOptions)
        categoryAxisLabelOptions = categoryAxisLabelOptionsDecoded
        let categoryAxisDisplayOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisDisplayOptions.self, forKey: .categoryAxisDisplayOptions)
        categoryAxisDisplayOptions = categoryAxisDisplayOptionsDecoded
        let primaryYAxisLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .primaryYAxisLabelOptions)
        primaryYAxisLabelOptions = primaryYAxisLabelOptionsDecoded
        let primaryYAxisDisplayOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.AxisDisplayOptions.self, forKey: .primaryYAxisDisplayOptions)
        primaryYAxisDisplayOptions = primaryYAxisDisplayOptionsDecoded
        let legendDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.LegendOptions.self, forKey: .legend)
        legend = legendDecoded
        let dataLabelsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.DataLabelOptions.self, forKey: .dataLabels)
        dataLabels = dataLabelsDecoded
        let visualPaletteDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualPalette.self, forKey: .visualPalette)
        visualPalette = visualPaletteDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration for a waterfall visual.
    public struct WaterfallChartConfiguration: Swift.Equatable {
        /// The options that determine the presentation of the category axis.
        public var categoryAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions?
        /// The options that determine the presentation of the category axis label.
        public var categoryAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The data label configuration of a waterfall visual.
        public var dataLabels: QuickSightClientTypes.DataLabelOptions?
        /// The field well configuration of a waterfall visual.
        public var fieldWells: QuickSightClientTypes.WaterfallChartFieldWells?
        /// The legend configuration of a waterfall visual.
        public var legend: QuickSightClientTypes.LegendOptions?
        /// The options that determine the presentation of the y-axis.
        public var primaryYAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions?
        /// The options that determine the presentation of the y-axis label.
        public var primaryYAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The sort configuration of a waterfall visual.
        public var sortConfiguration: QuickSightClientTypes.WaterfallChartSortConfiguration?
        /// The visual palette configuration of a waterfall visual.
        public var visualPalette: QuickSightClientTypes.VisualPalette?
        /// The options that determine the presentation of a waterfall visual.
        public var waterfallChartOptions: QuickSightClientTypes.WaterfallChartOptions?

        public init (
            categoryAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions? = nil,
            categoryAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            dataLabels: QuickSightClientTypes.DataLabelOptions? = nil,
            fieldWells: QuickSightClientTypes.WaterfallChartFieldWells? = nil,
            legend: QuickSightClientTypes.LegendOptions? = nil,
            primaryYAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions? = nil,
            primaryYAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            sortConfiguration: QuickSightClientTypes.WaterfallChartSortConfiguration? = nil,
            visualPalette: QuickSightClientTypes.VisualPalette? = nil,
            waterfallChartOptions: QuickSightClientTypes.WaterfallChartOptions? = nil
        )
        {
            self.categoryAxisDisplayOptions = categoryAxisDisplayOptions
            self.categoryAxisLabelOptions = categoryAxisLabelOptions
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.legend = legend
            self.primaryYAxisDisplayOptions = primaryYAxisDisplayOptions
            self.primaryYAxisLabelOptions = primaryYAxisLabelOptions
            self.sortConfiguration = sortConfiguration
            self.visualPalette = visualPalette
            self.waterfallChartOptions = waterfallChartOptions
        }
    }

}

extension QuickSightClientTypes.WaterfallChartFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case waterfallChartAggregatedFieldWells = "WaterfallChartAggregatedFieldWells"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let waterfallChartAggregatedFieldWells = self.waterfallChartAggregatedFieldWells {
            try encodeContainer.encode(waterfallChartAggregatedFieldWells, forKey: .waterfallChartAggregatedFieldWells)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waterfallChartAggregatedFieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.WaterfallChartAggregatedFieldWells.self, forKey: .waterfallChartAggregatedFieldWells)
        waterfallChartAggregatedFieldWells = waterfallChartAggregatedFieldWellsDecoded
    }
}

extension QuickSightClientTypes {
    /// The field well configuration of a waterfall visual.
    public struct WaterfallChartFieldWells: Swift.Equatable {
        /// The field well configuration of a waterfall visual.
        public var waterfallChartAggregatedFieldWells: QuickSightClientTypes.WaterfallChartAggregatedFieldWells?

        public init (
            waterfallChartAggregatedFieldWells: QuickSightClientTypes.WaterfallChartAggregatedFieldWells? = nil
        )
        {
            self.waterfallChartAggregatedFieldWells = waterfallChartAggregatedFieldWells
        }
    }

}

extension QuickSightClientTypes.WaterfallChartOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case totalBarLabel = "TotalBarLabel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let totalBarLabel = self.totalBarLabel {
            try encodeContainer.encode(totalBarLabel, forKey: .totalBarLabel)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalBarLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalBarLabel)
        totalBarLabel = totalBarLabelDecoded
    }
}

extension QuickSightClientTypes {
    /// The options that determine the presentation of a waterfall visual.
    public struct WaterfallChartOptions: Swift.Equatable {
        /// This option determines the total bar label of a waterfall visual.
        public var totalBarLabel: Swift.String?

        public init (
            totalBarLabel: Swift.String? = nil
        )
        {
            self.totalBarLabel = totalBarLabel
        }
    }

}

extension QuickSightClientTypes.WaterfallChartSortConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case breakdownItemsLimit = "BreakdownItemsLimit"
        case categorySort = "CategorySort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let breakdownItemsLimit = self.breakdownItemsLimit {
            try encodeContainer.encode(breakdownItemsLimit, forKey: .breakdownItemsLimit)
        }
        if let categorySort = categorySort {
            var categorySortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categorySort)
            for fieldsortoptions0 in categorySort {
                try categorySortContainer.encode(fieldsortoptions0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categorySortContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FieldSortOptions?].self, forKey: .categorySort)
        var categorySortDecoded0:[QuickSightClientTypes.FieldSortOptions]? = nil
        if let categorySortContainer = categorySortContainer {
            categorySortDecoded0 = [QuickSightClientTypes.FieldSortOptions]()
            for structure0 in categorySortContainer {
                if let structure0 = structure0 {
                    categorySortDecoded0?.append(structure0)
                }
            }
        }
        categorySort = categorySortDecoded0
        let breakdownItemsLimitDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ItemsLimitConfiguration.self, forKey: .breakdownItemsLimit)
        breakdownItemsLimit = breakdownItemsLimitDecoded
    }
}

extension QuickSightClientTypes {
    /// The sort configuration of a waterfall visual.
    public struct WaterfallChartSortConfiguration: Swift.Equatable {
        /// The limit on the number of bar groups that are displayed.
        public var breakdownItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of the category fields.
        public var categorySort: [QuickSightClientTypes.FieldSortOptions]?

        public init (
            breakdownItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            categorySort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.breakdownItemsLimit = breakdownItemsLimit
            self.categorySort = categorySort
        }
    }

}

extension QuickSightClientTypes.WaterfallVisual: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case chartConfiguration = "ChartConfiguration"
        case columnHierarchies = "ColumnHierarchies"
        case subtitle = "Subtitle"
        case title = "Title"
        case visualId = "VisualId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for visualcustomaction0 in actions {
                try actionsContainer.encode(visualcustomaction0)
            }
        }
        if let chartConfiguration = self.chartConfiguration {
            try encodeContainer.encode(chartConfiguration, forKey: .chartConfiguration)
        }
        if let columnHierarchies = columnHierarchies {
            var columnHierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnHierarchies)
            for columnhierarchy0 in columnHierarchies {
                try columnHierarchiesContainer.encode(columnhierarchy0)
            }
        }
        if let subtitle = self.subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let visualId = self.visualId {
            try encodeContainer.encode(visualId, forKey: .visualId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visualIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visualId)
        visualId = visualIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualTitleLabelOptions.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualSubtitleLabelOptions.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let chartConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.WaterfallChartConfiguration.self, forKey: .chartConfiguration)
        chartConfiguration = chartConfigurationDecoded
        let actionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.VisualCustomAction?].self, forKey: .actions)
        var actionsDecoded0:[QuickSightClientTypes.VisualCustomAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [QuickSightClientTypes.VisualCustomAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let columnHierarchiesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnHierarchy?].self, forKey: .columnHierarchies)
        var columnHierarchiesDecoded0:[QuickSightClientTypes.ColumnHierarchy]? = nil
        if let columnHierarchiesContainer = columnHierarchiesContainer {
            columnHierarchiesDecoded0 = [QuickSightClientTypes.ColumnHierarchy]()
            for structure0 in columnHierarchiesContainer {
                if let structure0 = structure0 {
                    columnHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        columnHierarchies = columnHierarchiesDecoded0
    }
}

extension QuickSightClientTypes {
    /// A waterfall chart. For more information, see [Using waterfall charts](https://docs.aws.amazon.com/quicksight/latest/user/waterfall-chart.html) in the Amazon QuickSight User Guide.
    public struct WaterfallVisual: Swift.Equatable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration for a waterfall visual.
        public var chartConfiguration: QuickSightClientTypes.WaterfallChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init (
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.WaterfallChartConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }

}

extension QuickSightClientTypes.WhatIfPointScenario: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case date = "Date"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let date = self.date {
            try encodeContainer.encodeTimestamp(date, format: .epochSeconds, forKey: .date)
        }
        if value != 0.0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .date)
        date = dateDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value) ?? 0.0
        value = valueDecoded
    }
}

extension QuickSightClientTypes {
    /// Provides the forecast to meet the target for a particular date.
    public struct WhatIfPointScenario: Swift.Equatable {
        /// The date that you need the forecast results for.
        /// This member is required.
        public var date: ClientRuntime.Date?
        /// The target value that you want to meet for the provided date.
        /// This member is required.
        public var value: Swift.Double

        public init (
            date: ClientRuntime.Date? = nil,
            value: Swift.Double = 0.0
        )
        {
            self.date = date
            self.value = value
        }
    }

}

extension QuickSightClientTypes.WhatIfRangeScenario: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endDate = "EndDate"
        case startDate = "StartDate"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endDate = self.endDate {
            try encodeContainer.encodeTimestamp(endDate, format: .epochSeconds, forKey: .endDate)
        }
        if let startDate = self.startDate {
            try encodeContainer.encodeTimestamp(startDate, format: .epochSeconds, forKey: .startDate)
        }
        if value != 0.0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endDate)
        endDate = endDateDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value) ?? 0.0
        value = valueDecoded
    }
}

extension QuickSightClientTypes {
    /// Provides the forecast to meet the target for a particular date range.
    public struct WhatIfRangeScenario: Swift.Equatable {
        /// The end date in the date range that you need the forecast results for.
        /// This member is required.
        public var endDate: ClientRuntime.Date?
        /// The start date in the date range that you need the forecast results for.
        /// This member is required.
        public var startDate: ClientRuntime.Date?
        /// The target value that you want to meet for the provided date range.
        /// This member is required.
        public var value: Swift.Double

        public init (
            endDate: ClientRuntime.Date? = nil,
            startDate: ClientRuntime.Date? = nil,
            value: Swift.Double = 0.0
        )
        {
            self.endDate = endDate
            self.startDate = startDate
            self.value = value
        }
    }

}

extension QuickSightClientTypes {
    public enum WidgetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [WidgetStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WidgetStatus(rawValue: rawValue) ?? WidgetStatus.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.WordCloudAggregatedFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupBy = "GroupBy"
        case size = "Size"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupBy = groupBy {
            var groupByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupBy)
            for dimensionfield0 in groupBy {
                try groupByContainer.encode(dimensionfield0)
            }
        }
        if let size = size {
            var sizeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .size)
            for measurefield0 in size {
                try sizeContainer.encode(measurefield0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupByContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.DimensionField?].self, forKey: .groupBy)
        var groupByDecoded0:[QuickSightClientTypes.DimensionField]? = nil
        if let groupByContainer = groupByContainer {
            groupByDecoded0 = [QuickSightClientTypes.DimensionField]()
            for structure0 in groupByContainer {
                if let structure0 = structure0 {
                    groupByDecoded0?.append(structure0)
                }
            }
        }
        groupBy = groupByDecoded0
        let sizeContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.MeasureField?].self, forKey: .size)
        var sizeDecoded0:[QuickSightClientTypes.MeasureField]? = nil
        if let sizeContainer = sizeContainer {
            sizeDecoded0 = [QuickSightClientTypes.MeasureField]()
            for structure0 in sizeContainer {
                if let structure0 = structure0 {
                    sizeDecoded0?.append(structure0)
                }
            }
        }
        size = sizeDecoded0
    }
}

extension QuickSightClientTypes {
    /// The aggregated field wells of a word cloud.
    public struct WordCloudAggregatedFieldWells: Swift.Equatable {
        /// The group by field well of a word cloud. Values are grouped by group by fields.
        public var groupBy: [QuickSightClientTypes.DimensionField]?
        /// The size field well of a word cloud. Values are aggregated based on group by fields.
        public var size: [QuickSightClientTypes.MeasureField]?

        public init (
            groupBy: [QuickSightClientTypes.DimensionField]? = nil,
            size: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.groupBy = groupBy
            self.size = size
        }
    }

}

extension QuickSightClientTypes.WordCloudChartConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryLabelOptions = "CategoryLabelOptions"
        case fieldWells = "FieldWells"
        case sortConfiguration = "SortConfiguration"
        case wordCloudOptions = "WordCloudOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryLabelOptions = self.categoryLabelOptions {
            try encodeContainer.encode(categoryLabelOptions, forKey: .categoryLabelOptions)
        }
        if let fieldWells = self.fieldWells {
            try encodeContainer.encode(fieldWells, forKey: .fieldWells)
        }
        if let sortConfiguration = self.sortConfiguration {
            try encodeContainer.encode(sortConfiguration, forKey: .sortConfiguration)
        }
        if let wordCloudOptions = self.wordCloudOptions {
            try encodeContainer.encode(wordCloudOptions, forKey: .wordCloudOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.WordCloudFieldWells.self, forKey: .fieldWells)
        fieldWells = fieldWellsDecoded
        let sortConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.WordCloudSortConfiguration.self, forKey: .sortConfiguration)
        sortConfiguration = sortConfigurationDecoded
        let categoryLabelOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ChartAxisLabelOptions.self, forKey: .categoryLabelOptions)
        categoryLabelOptions = categoryLabelOptionsDecoded
        let wordCloudOptionsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.WordCloudOptions.self, forKey: .wordCloudOptions)
        wordCloudOptions = wordCloudOptionsDecoded
    }
}

extension QuickSightClientTypes {
    /// The configuration of a word cloud visual.
    public struct WordCloudChartConfiguration: Swift.Equatable {
        /// The label options (label text, label visibility, and sort icon visibility) for the word cloud category.
        public var categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The field wells of the visual.
        public var fieldWells: QuickSightClientTypes.WordCloudFieldWells?
        /// The sort configuration of a word cloud visual.
        public var sortConfiguration: QuickSightClientTypes.WordCloudSortConfiguration?
        /// The options for a word cloud visual.
        public var wordCloudOptions: QuickSightClientTypes.WordCloudOptions?

        public init (
            categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            fieldWells: QuickSightClientTypes.WordCloudFieldWells? = nil,
            sortConfiguration: QuickSightClientTypes.WordCloudSortConfiguration? = nil,
            wordCloudOptions: QuickSightClientTypes.WordCloudOptions? = nil
        )
        {
            self.categoryLabelOptions = categoryLabelOptions
            self.fieldWells = fieldWells
            self.sortConfiguration = sortConfiguration
            self.wordCloudOptions = wordCloudOptions
        }
    }

}

extension QuickSightClientTypes {
    public enum WordCloudCloudLayout: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fluid
        case normal
        case sdkUnknown(Swift.String)

        public static var allCases: [WordCloudCloudLayout] {
            return [
                .fluid,
                .normal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fluid: return "FLUID"
            case .normal: return "NORMAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WordCloudCloudLayout(rawValue: rawValue) ?? WordCloudCloudLayout.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes.WordCloudFieldWells: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wordCloudAggregatedFieldWells = "WordCloudAggregatedFieldWells"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let wordCloudAggregatedFieldWells = self.wordCloudAggregatedFieldWells {
            try encodeContainer.encode(wordCloudAggregatedFieldWells, forKey: .wordCloudAggregatedFieldWells)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wordCloudAggregatedFieldWellsDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.WordCloudAggregatedFieldWells.self, forKey: .wordCloudAggregatedFieldWells)
        wordCloudAggregatedFieldWells = wordCloudAggregatedFieldWellsDecoded
    }
}

extension QuickSightClientTypes {
    /// The field wells of a word cloud visual. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct WordCloudFieldWells: Swift.Equatable {
        /// The aggregated field wells of a word cloud.
        public var wordCloudAggregatedFieldWells: QuickSightClientTypes.WordCloudAggregatedFieldWells?

        public init (
            wordCloudAggregatedFieldWells: QuickSightClientTypes.WordCloudAggregatedFieldWells? = nil
        )
        {
            self.wordCloudAggregatedFieldWells = wordCloudAggregatedFieldWells
        }
    }

}

extension QuickSightClientTypes.WordCloudOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudLayout = "CloudLayout"
        case maximumStringLength = "MaximumStringLength"
        case wordCasing = "WordCasing"
        case wordOrientation = "WordOrientation"
        case wordPadding = "WordPadding"
        case wordScaling = "WordScaling"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudLayout = self.cloudLayout {
            try encodeContainer.encode(cloudLayout.rawValue, forKey: .cloudLayout)
        }
        if let maximumStringLength = self.maximumStringLength {
            try encodeContainer.encode(maximumStringLength, forKey: .maximumStringLength)
        }
        if let wordCasing = self.wordCasing {
            try encodeContainer.encode(wordCasing.rawValue, forKey: .wordCasing)
        }
        if let wordOrientation = self.wordOrientation {
            try encodeContainer.encode(wordOrientation.rawValue, forKey: .wordOrientation)
        }
        if let wordPadding = self.wordPadding {
            try encodeContainer.encode(wordPadding.rawValue, forKey: .wordPadding)
        }
        if let wordScaling = self.wordScaling {
            try encodeContainer.encode(wordScaling.rawValue, forKey: .wordScaling)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wordOrientationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.WordCloudWordOrientation.self, forKey: .wordOrientation)
        wordOrientation = wordOrientationDecoded
        let wordScalingDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.WordCloudWordScaling.self, forKey: .wordScaling)
        wordScaling = wordScalingDecoded
        let cloudLayoutDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.WordCloudCloudLayout.self, forKey: .cloudLayout)
        cloudLayout = cloudLayoutDecoded
        let wordCasingDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.WordCloudWordCasing.self, forKey: .wordCasing)
        wordCasing = wordCasingDecoded
        let wordPaddingDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.WordCloudWordPadding.self, forKey: .wordPadding)
        wordPadding = wordPaddingDecoded
        let maximumStringLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumStringLength)
        maximumStringLength = maximumStringLengthDecoded
    }
}

extension QuickSightClientTypes {
    /// The word cloud options for a word cloud visual.
    public struct WordCloudOptions: Swift.Equatable {
        /// The cloud layout options (fluid, normal) of a word cloud.
        public var cloudLayout: QuickSightClientTypes.WordCloudCloudLayout?
        /// The length limit of each word from 1-100.
        public var maximumStringLength: Swift.Int?
        /// The word casing options (lower_case, existing_case) for the words in a word cloud.
        public var wordCasing: QuickSightClientTypes.WordCloudWordCasing?
        /// The word orientation options (horizontal, horizontal_and_vertical) for the words in a word cloud.
        public var wordOrientation: QuickSightClientTypes.WordCloudWordOrientation?
        /// The word padding options (none, small, medium, large) for the words in a word cloud.
        public var wordPadding: QuickSightClientTypes.WordCloudWordPadding?
        /// The word scaling options (emphasize, normal) for the words in a word cloud.
        public var wordScaling: QuickSightClientTypes.WordCloudWordScaling?

        public init (
            cloudLayout: QuickSightClientTypes.WordCloudCloudLayout? = nil,
            maximumStringLength: Swift.Int? = nil,
            wordCasing: QuickSightClientTypes.WordCloudWordCasing? = nil,
            wordOrientation: QuickSightClientTypes.WordCloudWordOrientation? = nil,
            wordPadding: QuickSightClientTypes.WordCloudWordPadding? = nil,
            wordScaling: QuickSightClientTypes.WordCloudWordScaling? = nil
        )
        {
            self.cloudLayout = cloudLayout
            self.maximumStringLength = maximumStringLength
            self.wordCasing = wordCasing
            self.wordOrientation = wordOrientation
            self.wordPadding = wordPadding
            self.wordScaling = wordScaling
        }
    }

}

extension QuickSightClientTypes.WordCloudSortConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryItemsLimit = "CategoryItemsLimit"
        case categorySort = "CategorySort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryItemsLimit = self.categoryItemsLimit {
            try encodeContainer.encode(categoryItemsLimit, forKey: .categoryItemsLimit)
        }
        if let categorySort = categorySort {
            var categorySortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categorySort)
            for fieldsortoptions0 in categorySort {
                try categorySortContainer.encode(fieldsortoptions0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryItemsLimitDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.ItemsLimitConfiguration.self, forKey: .categoryItemsLimit)
        categoryItemsLimit = categoryItemsLimitDecoded
        let categorySortContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.FieldSortOptions?].self, forKey: .categorySort)
        var categorySortDecoded0:[QuickSightClientTypes.FieldSortOptions]? = nil
        if let categorySortContainer = categorySortContainer {
            categorySortDecoded0 = [QuickSightClientTypes.FieldSortOptions]()
            for structure0 in categorySortContainer {
                if let structure0 = structure0 {
                    categorySortDecoded0?.append(structure0)
                }
            }
        }
        categorySort = categorySortDecoded0
    }
}

extension QuickSightClientTypes {
    /// The sort configuration of a word cloud visual.
    public struct WordCloudSortConfiguration: Swift.Equatable {
        /// The limit on the number of groups that are displayed in a word cloud.
        public var categoryItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of group by fields.
        public var categorySort: [QuickSightClientTypes.FieldSortOptions]?

        public init (
            categoryItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            categorySort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.categoryItemsLimit = categoryItemsLimit
            self.categorySort = categorySort
        }
    }

}

extension QuickSightClientTypes.WordCloudVisual: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case chartConfiguration = "ChartConfiguration"
        case columnHierarchies = "ColumnHierarchies"
        case subtitle = "Subtitle"
        case title = "Title"
        case visualId = "VisualId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for visualcustomaction0 in actions {
                try actionsContainer.encode(visualcustomaction0)
            }
        }
        if let chartConfiguration = self.chartConfiguration {
            try encodeContainer.encode(chartConfiguration, forKey: .chartConfiguration)
        }
        if let columnHierarchies = columnHierarchies {
            var columnHierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnHierarchies)
            for columnhierarchy0 in columnHierarchies {
                try columnHierarchiesContainer.encode(columnhierarchy0)
            }
        }
        if let subtitle = self.subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let visualId = self.visualId {
            try encodeContainer.encode(visualId, forKey: .visualId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let visualIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visualId)
        visualId = visualIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualTitleLabelOptions.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.VisualSubtitleLabelOptions.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let chartConfigurationDecoded = try containerValues.decodeIfPresent(QuickSightClientTypes.WordCloudChartConfiguration.self, forKey: .chartConfiguration)
        chartConfiguration = chartConfigurationDecoded
        let actionsContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.VisualCustomAction?].self, forKey: .actions)
        var actionsDecoded0:[QuickSightClientTypes.VisualCustomAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [QuickSightClientTypes.VisualCustomAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let columnHierarchiesContainer = try containerValues.decodeIfPresent([QuickSightClientTypes.ColumnHierarchy?].self, forKey: .columnHierarchies)
        var columnHierarchiesDecoded0:[QuickSightClientTypes.ColumnHierarchy]? = nil
        if let columnHierarchiesContainer = columnHierarchiesContainer {
            columnHierarchiesDecoded0 = [QuickSightClientTypes.ColumnHierarchy]()
            for structure0 in columnHierarchiesContainer {
                if let structure0 = structure0 {
                    columnHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        columnHierarchies = columnHierarchiesDecoded0
    }
}

extension QuickSightClientTypes {
    /// A word cloud. For more information, see [Using word clouds](https://docs.aws.amazon.com/quicksight/latest/user/word-cloud.html) in the Amazon QuickSight User Guide.
    public struct WordCloudVisual: Swift.Equatable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration settings of the visual.
        public var chartConfiguration: QuickSightClientTypes.WordCloudChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        /// This member is required.
        public var visualId: Swift.String?

        public init (
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.WordCloudChartConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }

}

extension QuickSightClientTypes {
    public enum WordCloudWordCasing: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case existingCase
        case lowerCase
        case sdkUnknown(Swift.String)

        public static var allCases: [WordCloudWordCasing] {
            return [
                .existingCase,
                .lowerCase,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .existingCase: return "EXISTING_CASE"
            case .lowerCase: return "LOWER_CASE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WordCloudWordCasing(rawValue: rawValue) ?? WordCloudWordCasing.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum WordCloudWordOrientation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case horizontal
        case horizontalAndVertical
        case sdkUnknown(Swift.String)

        public static var allCases: [WordCloudWordOrientation] {
            return [
                .horizontal,
                .horizontalAndVertical,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .horizontal: return "HORIZONTAL"
            case .horizontalAndVertical: return "HORIZONTAL_AND_VERTICAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WordCloudWordOrientation(rawValue: rawValue) ?? WordCloudWordOrientation.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum WordCloudWordPadding: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case large
        case medium
        case `none`
        case small
        case sdkUnknown(Swift.String)

        public static var allCases: [WordCloudWordPadding] {
            return [
                .large,
                .medium,
                .none,
                .small,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .large: return "LARGE"
            case .medium: return "MEDIUM"
            case .none: return "NONE"
            case .small: return "SMALL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WordCloudWordPadding(rawValue: rawValue) ?? WordCloudWordPadding.sdkUnknown(rawValue)
        }
    }
}

extension QuickSightClientTypes {
    public enum WordCloudWordScaling: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case emphasize
        case normal
        case sdkUnknown(Swift.String)

        public static var allCases: [WordCloudWordScaling] {
            return [
                .emphasize,
                .normal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .emphasize: return "EMPHASIZE"
            case .normal: return "NORMAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WordCloudWordScaling(rawValue: rawValue) ?? WordCloudWordScaling.sdkUnknown(rawValue)
        }
    }
}
