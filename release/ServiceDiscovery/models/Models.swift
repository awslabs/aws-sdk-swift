// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct CreateHttpNamespaceInputBodyMiddleware: Middleware {
    public let id: String = "CreateHttpNamespaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHttpNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHttpNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHttpNamespaceInput>
    public typealias MOutput = OperationOutput<CreateHttpNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHttpNamespaceOutputError>
}

extension CreateHttpNamespaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHttpNamespaceInput(creatorRequestId: \(String(describing: creatorRequestId)), description: \(String(describing: description)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateHttpNamespaceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateHttpNamespaceInputHeadersMiddleware: Middleware {
    public let id: String = "CreateHttpNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHttpNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHttpNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHttpNamespaceInput>
    public typealias MOutput = OperationOutput<CreateHttpNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHttpNamespaceOutputError>
}

public struct CreateHttpNamespaceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateHttpNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHttpNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHttpNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHttpNamespaceInput>
    public typealias MOutput = OperationOutput<CreateHttpNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHttpNamespaceOutputError>
}

public struct CreateHttpNamespaceInput: Equatable {
    /// <p>A unique string that identifies the request and that allows failed <code>CreateHttpNamespace</code> requests to
    ///    be retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any unique string
    ///    (for example, a date/time stamp).</p>
    public var creatorRequestId: String?
    /// <p>A description for the namespace.</p>
    public let description: String?
    /// <p>The name that you want to assign to this namespace.</p>
    public let name: String?
    /// <p>The tags to add to the namespace. Each tag consists of a key and an optional value that you define.
    ///    Tags keys can be up to 128 characters in length, and tag values can be up to 256 characters in
    ///                      length.</p>
    public let tags: [Tag]?

    public init (
        creatorRequestId: String? = nil,
        description: String? = nil,
        name: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateHttpNamespaceInputBody: Equatable {
    public let name: String?
    public let creatorRequestId: String?
    public let description: String?
    public let tags: [Tag]?
}

extension CreateHttpNamespaceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateHttpNamespaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHttpNamespaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceAlreadyExists" : self = .namespaceAlreadyExists(try NamespaceAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceeded(try ResourceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHttpNamespaceOutputError: Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case namespaceAlreadyExists(NamespaceAlreadyExists)
    case resourceLimitExceeded(ResourceLimitExceeded)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHttpNamespaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHttpNamespaceOutputResponse(operationId: \(String(describing: operationId)))"}
}

extension CreateHttpNamespaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateHttpNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct CreateHttpNamespaceOutputResponse: Equatable {
    /// <p>A value that you can use to determine whether the request completed successfully. To get the status of the
    ///    operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation</a>.</p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct CreateHttpNamespaceOutputResponseBody: Equatable {
    public let operationId: String?
}

extension CreateHttpNamespaceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct CreatePrivateDnsNamespaceInputBodyMiddleware: Middleware {
    public let id: String = "CreatePrivateDnsNamespaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePrivateDnsNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePrivateDnsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePrivateDnsNamespaceInput>
    public typealias MOutput = OperationOutput<CreatePrivateDnsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePrivateDnsNamespaceOutputError>
}

extension CreatePrivateDnsNamespaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePrivateDnsNamespaceInput(creatorRequestId: \(String(describing: creatorRequestId)), description: \(String(describing: description)), name: \(String(describing: name)), tags: \(String(describing: tags)), vpc: \(String(describing: vpc)))"}
}

extension CreatePrivateDnsNamespaceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
        case vpc = "Vpc"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let vpc = vpc {
            try encodeContainer.encode(vpc, forKey: .vpc)
        }
    }
}

public struct CreatePrivateDnsNamespaceInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePrivateDnsNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePrivateDnsNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePrivateDnsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePrivateDnsNamespaceInput>
    public typealias MOutput = OperationOutput<CreatePrivateDnsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePrivateDnsNamespaceOutputError>
}

public struct CreatePrivateDnsNamespaceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePrivateDnsNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePrivateDnsNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePrivateDnsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePrivateDnsNamespaceInput>
    public typealias MOutput = OperationOutput<CreatePrivateDnsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePrivateDnsNamespaceOutputError>
}

public struct CreatePrivateDnsNamespaceInput: Equatable {
    /// <p>A unique string that identifies the request and that allows failed <code>CreatePrivateDnsNamespace</code>
    ///    requests to be retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any
    ///    unique string (for example, a date/timestamp).</p>
    public var creatorRequestId: String?
    /// <p>A description for the namespace.</p>
    public let description: String?
    /// <p>The name that you want to assign to this namespace. When you create a private DNS namespace, AWS Cloud Map
    ///    automatically creates an Amazon Route 53 private hosted zone that has the same name as the namespace.</p>
    public let name: String?
    /// <p>The tags to add to the namespace. Each tag consists of a key and an optional value that you define.
    ///    Tags keys can be up to 128 characters in length, and tag values can be up to 256 characters in
    ///                      length.</p>
    public let tags: [Tag]?
    /// <p>The ID of the Amazon VPC that you want to associate the namespace with.</p>
    public let vpc: String?

    public init (
        creatorRequestId: String? = nil,
        description: String? = nil,
        name: String? = nil,
        tags: [Tag]? = nil,
        vpc: String? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.description = description
        self.name = name
        self.tags = tags
        self.vpc = vpc
    }
}

struct CreatePrivateDnsNamespaceInputBody: Equatable {
    public let name: String?
    public let creatorRequestId: String?
    public let description: String?
    public let vpc: String?
    public let tags: [Tag]?
}

extension CreatePrivateDnsNamespaceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
        case vpc = "Vpc"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let vpcDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpc)
        vpc = vpcDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePrivateDnsNamespaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePrivateDnsNamespaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceAlreadyExists" : self = .namespaceAlreadyExists(try NamespaceAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceeded(try ResourceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePrivateDnsNamespaceOutputError: Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case namespaceAlreadyExists(NamespaceAlreadyExists)
    case resourceLimitExceeded(ResourceLimitExceeded)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePrivateDnsNamespaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePrivateDnsNamespaceOutputResponse(operationId: \(String(describing: operationId)))"}
}

extension CreatePrivateDnsNamespaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreatePrivateDnsNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct CreatePrivateDnsNamespaceOutputResponse: Equatable {
    /// <p>A value that you can use to determine whether the request completed successfully. To get the status of the
    ///    operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation</a>.</p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct CreatePrivateDnsNamespaceOutputResponseBody: Equatable {
    public let operationId: String?
}

extension CreatePrivateDnsNamespaceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct CreatePublicDnsNamespaceInputBodyMiddleware: Middleware {
    public let id: String = "CreatePublicDnsNamespaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePublicDnsNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePublicDnsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePublicDnsNamespaceInput>
    public typealias MOutput = OperationOutput<CreatePublicDnsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePublicDnsNamespaceOutputError>
}

extension CreatePublicDnsNamespaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePublicDnsNamespaceInput(creatorRequestId: \(String(describing: creatorRequestId)), description: \(String(describing: description)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreatePublicDnsNamespaceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreatePublicDnsNamespaceInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePublicDnsNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePublicDnsNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePublicDnsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePublicDnsNamespaceInput>
    public typealias MOutput = OperationOutput<CreatePublicDnsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePublicDnsNamespaceOutputError>
}

public struct CreatePublicDnsNamespaceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePublicDnsNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePublicDnsNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePublicDnsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePublicDnsNamespaceInput>
    public typealias MOutput = OperationOutput<CreatePublicDnsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePublicDnsNamespaceOutputError>
}

public struct CreatePublicDnsNamespaceInput: Equatable {
    /// <p>A unique string that identifies the request and that allows failed <code>CreatePublicDnsNamespace</code>
    ///    requests to be retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any
    ///    unique string (for example, a date/timestamp).</p>
    public var creatorRequestId: String?
    /// <p>A description for the namespace.</p>
    public let description: String?
    /// <p>The name that you want to assign to this namespace.</p>
    public let name: String?
    /// <p>The tags to add to the namespace. Each tag consists of a key and an optional value that you define.
    ///    Tags keys can be up to 128 characters in length, and tag values can be up to 256 characters in
    ///                      length.</p>
    public let tags: [Tag]?

    public init (
        creatorRequestId: String? = nil,
        description: String? = nil,
        name: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreatePublicDnsNamespaceInputBody: Equatable {
    public let name: String?
    public let creatorRequestId: String?
    public let description: String?
    public let tags: [Tag]?
}

extension CreatePublicDnsNamespaceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePublicDnsNamespaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePublicDnsNamespaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceAlreadyExists" : self = .namespaceAlreadyExists(try NamespaceAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceeded(try ResourceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePublicDnsNamespaceOutputError: Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case namespaceAlreadyExists(NamespaceAlreadyExists)
    case resourceLimitExceeded(ResourceLimitExceeded)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePublicDnsNamespaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePublicDnsNamespaceOutputResponse(operationId: \(String(describing: operationId)))"}
}

extension CreatePublicDnsNamespaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreatePublicDnsNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct CreatePublicDnsNamespaceOutputResponse: Equatable {
    /// <p>A value that you can use to determine whether the request completed successfully. To get the status of the
    ///    operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation</a>.</p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct CreatePublicDnsNamespaceOutputResponseBody: Equatable {
    public let operationId: String?
}

extension CreatePublicDnsNamespaceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct CreateServiceInputBodyMiddleware: Middleware {
    public let id: String = "CreateServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServiceInput>
    public typealias MOutput = OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServiceOutputError>
}

extension CreateServiceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateServiceInput(creatorRequestId: \(String(describing: creatorRequestId)), description: \(String(describing: description)), dnsConfig: \(String(describing: dnsConfig)), healthCheckConfig: \(String(describing: healthCheckConfig)), healthCheckCustomConfig: \(String(describing: healthCheckCustomConfig)), name: \(String(describing: name)), namespaceId: \(String(describing: namespaceId)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

extension CreateServiceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case dnsConfig = "DnsConfig"
        case healthCheckConfig = "HealthCheckConfig"
        case healthCheckCustomConfig = "HealthCheckCustomConfig"
        case name = "Name"
        case namespaceId = "NamespaceId"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dnsConfig = dnsConfig {
            try encodeContainer.encode(dnsConfig, forKey: .dnsConfig)
        }
        if let healthCheckConfig = healthCheckConfig {
            try encodeContainer.encode(healthCheckConfig, forKey: .healthCheckConfig)
        }
        if let healthCheckCustomConfig = healthCheckCustomConfig {
            try encodeContainer.encode(healthCheckCustomConfig, forKey: .healthCheckCustomConfig)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespaceId = namespaceId {
            try encodeContainer.encode(namespaceId, forKey: .namespaceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateServiceInputHeadersMiddleware: Middleware {
    public let id: String = "CreateServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServiceInput>
    public typealias MOutput = OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServiceOutputError>
}

public struct CreateServiceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServiceInput>
    public typealias MOutput = OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServiceOutputError>
}

public struct CreateServiceInput: Equatable {
    /// <p>A unique string that identifies the request and that allows failed <code>CreateService</code> requests to be
    ///    retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any unique string (for
    ///    example, a date/timestamp).</p>
    public var creatorRequestId: String?
    /// <p>A description for the service.</p>
    public let description: String?
    /// <p>A complex type that contains information about the Amazon Route 53 records that you want AWS Cloud Map to create when you
    ///    register an instance. </p>
    public let dnsConfig: DnsConfig?
    /// <p>
    ///             <i>Public DNS and HTTP namespaces only.</i> A complex type that contains settings for an optional
    ///    Route 53 health check. If you specify settings for a health check, AWS Cloud Map associates the health check with all the
    ///    Route 53 DNS records that you specify in <code>DnsConfig</code>.</p>
    ///          <important>
    ///             <p>If you specify a health check configuration, you can specify either <code>HealthCheckCustomConfig</code> or
    ///      <code>HealthCheckConfig</code> but not both.</p>
    ///          </important>
    ///          <p>For information about the charges for health checks, see <a href="http://aws.amazon.com/cloud-map/pricing/">AWS Cloud Map Pricing</a>.</p>
    public let healthCheckConfig: HealthCheckConfig?
    /// <p>A complex type that contains information about an optional custom health check.</p>
    ///          <important>
    ///             <p>If you specify a health check configuration, you can specify either <code>HealthCheckCustomConfig</code> or
    ///      <code>HealthCheckConfig</code> but not both.</p>
    ///          </important>
    ///          <p>You can't add, update, or delete a <code>HealthCheckCustomConfig</code> configuration from an existing
    ///    service.</p>
    public let healthCheckCustomConfig: HealthCheckCustomConfig?
    /// <p>The name that you want to assign to the service.</p>
    ///          <p>If you want AWS Cloud Map to create an <code>SRV</code> record when you register an instance and you're using a
    ///    system that requires a specific <code>SRV</code> format, such as <a href="http://www.haproxy.org/">HAProxy</a>, specify the following for <code>Name</code>:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Start the name with an underscore (_), such as <code>_exampleservice</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>End the name with <i>._protocol</i>, such as <code>._tcp</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>When you register an instance, AWS Cloud Map creates an <code>SRV</code> record and assigns a name to the record by
    ///    concatenating the service name and the namespace name (for example,</p>
    ///          <p>
    ///             <code>_exampleservice._tcp.example.com</code>).</p>
    ///          <note>
    ///             <p>For services that are accessible by DNS queries, you can't create multiple services with names that differ only
    ///     by case (such as EXAMPLE and example). Otherwise, these services have the same DNS name and can't be distinguished.
    ///     However, if you use a namespace that's only accessible by API calls, then you can create services that with names
    ///     that differ only by case.</p>
    ///          </note>
    public let name: String?
    /// <p>The ID of the namespace that you want to use to create the service. The namespace ID must be specified, but it
    ///    can be specified either here or in the <code>DnsConfig</code> object.</p>
    public let namespaceId: String?
    /// <p>The tags to add to the service. Each tag consists of a key and an optional value that you define.
    ///    Tags keys can be up to 128 characters in length, and tag values can be up to 256 characters in
    ///                      length.</p>
    public let tags: [Tag]?
    /// <p>If present, specifies that the service instances are only discoverable using the <code>DiscoverInstances</code>
    ///    API operation. No DNS records is registered for the service instances. The only valid value is
    ///    <code>HTTP</code>.</p>
    public let type: ServiceTypeOption?

    public init (
        creatorRequestId: String? = nil,
        description: String? = nil,
        dnsConfig: DnsConfig? = nil,
        healthCheckConfig: HealthCheckConfig? = nil,
        healthCheckCustomConfig: HealthCheckCustomConfig? = nil,
        name: String? = nil,
        namespaceId: String? = nil,
        tags: [Tag]? = nil,
        type: ServiceTypeOption? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.description = description
        self.dnsConfig = dnsConfig
        self.healthCheckConfig = healthCheckConfig
        self.healthCheckCustomConfig = healthCheckCustomConfig
        self.name = name
        self.namespaceId = namespaceId
        self.tags = tags
        self.type = type
    }
}

struct CreateServiceInputBody: Equatable {
    public let name: String?
    public let namespaceId: String?
    public let creatorRequestId: String?
    public let description: String?
    public let dnsConfig: DnsConfig?
    public let healthCheckConfig: HealthCheckConfig?
    public let healthCheckCustomConfig: HealthCheckCustomConfig?
    public let tags: [Tag]?
    public let type: ServiceTypeOption?
}

extension CreateServiceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case dnsConfig = "DnsConfig"
        case healthCheckConfig = "HealthCheckConfig"
        case healthCheckCustomConfig = "HealthCheckCustomConfig"
        case name = "Name"
        case namespaceId = "NamespaceId"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let namespaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespaceId)
        namespaceId = namespaceIdDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let dnsConfigDecoded = try containerValues.decodeIfPresent(DnsConfig.self, forKey: .dnsConfig)
        dnsConfig = dnsConfigDecoded
        let healthCheckConfigDecoded = try containerValues.decodeIfPresent(HealthCheckConfig.self, forKey: .healthCheckConfig)
        healthCheckConfig = healthCheckConfigDecoded
        let healthCheckCustomConfigDecoded = try containerValues.decodeIfPresent(HealthCheckCustomConfig.self, forKey: .healthCheckCustomConfig)
        healthCheckCustomConfig = healthCheckCustomConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(ServiceTypeOption.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateServiceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServiceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceNotFound" : self = .namespaceNotFound(try NamespaceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceeded(try ResourceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAlreadyExists" : self = .serviceAlreadyExists(try ServiceAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateServiceOutputError: Equatable {
    case invalidInput(InvalidInput)
    case namespaceNotFound(NamespaceNotFound)
    case resourceLimitExceeded(ResourceLimitExceeded)
    case serviceAlreadyExists(ServiceAlreadyExists)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateServiceOutputResponse(service: \(String(describing: service)))"}
}

extension CreateServiceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateServiceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.service = output.service
        } else {
            self.service = nil
        }
    }
}

public struct CreateServiceOutputResponse: Equatable {
    /// <p>A complex type that contains information about the new service.</p>
    public let service: Service?

    public init (
        service: Service? = nil
    )
    {
        self.service = service
    }
}

struct CreateServiceOutputResponseBody: Equatable {
    public let service: Service?
}

extension CreateServiceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case service = "Service"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(Service.self, forKey: .service)
        service = serviceDecoded
    }
}

extension CustomHealthNotFound: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomHealthNotFound(message: \(String(describing: message)))"}
}

extension CustomHealthNotFound: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CustomHealthNotFoundBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The health check for the instance that's specified by <code>ServiceId</code> and <code>InstanceId</code> isn't a
///    custom health check. </p>
public struct CustomHealthNotFound: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CustomHealthNotFoundBody: Equatable {
    public let message: String?
}

extension CustomHealthNotFoundBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum CustomHealthStatus {
    case healthy
    case unhealthy
    case sdkUnknown(String)
}

extension CustomHealthStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CustomHealthStatus] {
        return [
            .healthy,
            .unhealthy,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .healthy: return "HEALTHY"
        case .unhealthy: return "UNHEALTHY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CustomHealthStatus(rawValue: rawValue) ?? CustomHealthStatus.sdkUnknown(rawValue)
    }
}

public struct DeleteNamespaceInputBodyMiddleware: Middleware {
    public let id: String = "DeleteNamespaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNamespaceInput>
    public typealias MOutput = OperationOutput<DeleteNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNamespaceOutputError>
}

extension DeleteNamespaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteNamespaceInput(id: \(String(describing: id)))"}
}

extension DeleteNamespaceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeleteNamespaceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNamespaceInput>
    public typealias MOutput = OperationOutput<DeleteNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNamespaceOutputError>
}

public struct DeleteNamespaceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNamespaceInput>
    public typealias MOutput = OperationOutput<DeleteNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNamespaceOutputError>
}

public struct DeleteNamespaceInput: Equatable {
    /// <p>The ID of the namespace that you want to delete.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteNamespaceInputBody: Equatable {
    public let id: String?
}

extension DeleteNamespaceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteNamespaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNamespaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceNotFound" : self = .namespaceNotFound(try NamespaceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteNamespaceOutputError: Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case namespaceNotFound(NamespaceNotFound)
    case resourceInUse(ResourceInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNamespaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteNamespaceOutputResponse(operationId: \(String(describing: operationId)))"}
}

extension DeleteNamespaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct DeleteNamespaceOutputResponse: Equatable {
    /// <p>A value that you can use to determine whether the request completed successfully. To get the status of the
    ///    operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation</a>.</p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct DeleteNamespaceOutputResponseBody: Equatable {
    public let operationId: String?
}

extension DeleteNamespaceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct DeleteServiceInputBodyMiddleware: Middleware {
    public let id: String = "DeleteServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServiceInput>
    public typealias MOutput = OperationOutput<DeleteServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServiceOutputError>
}

extension DeleteServiceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteServiceInput(id: \(String(describing: id)))"}
}

extension DeleteServiceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeleteServiceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServiceInput>
    public typealias MOutput = OperationOutput<DeleteServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServiceOutputError>
}

public struct DeleteServiceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServiceInput>
    public typealias MOutput = OperationOutput<DeleteServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServiceOutputError>
}

public struct DeleteServiceInput: Equatable {
    /// <p>The ID of the service that you want to delete.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteServiceInputBody: Equatable {
    public let id: String?
}

extension DeleteServiceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteServiceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServiceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServiceOutputError: Equatable {
    case invalidInput(InvalidInput)
    case resourceInUse(ResourceInUse)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteServiceOutputResponse()"}
}

extension DeleteServiceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteServiceOutputResponse: Equatable {

    public init() {}
}

struct DeleteServiceOutputResponseBody: Equatable {
}

extension DeleteServiceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeregisterInstanceInputBodyMiddleware: Middleware {
    public let id: String = "DeregisterInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterInstanceInput>
    public typealias MOutput = OperationOutput<DeregisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterInstanceOutputError>
}

extension DeregisterInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterInstanceInput(instanceId: \(String(describing: instanceId)), serviceId: \(String(describing: serviceId)))"}
}

extension DeregisterInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
    }
}

public struct DeregisterInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "DeregisterInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterInstanceInput>
    public typealias MOutput = OperationOutput<DeregisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterInstanceOutputError>
}

public struct DeregisterInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeregisterInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterInstanceInput>
    public typealias MOutput = OperationOutput<DeregisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterInstanceOutputError>
}

public struct DeregisterInstanceInput: Equatable {
    /// <p>The value that you specified for <code>Id</code> in the <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance</a> request.</p>
    public let instanceId: String?
    /// <p>The ID of the service that the instance is associated with.</p>
    public let serviceId: String?

    public init (
        instanceId: String? = nil,
        serviceId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.serviceId = serviceId
    }
}

struct DeregisterInstanceInputBody: Equatable {
    public let serviceId: String?
    public let instanceId: String?
}

extension DeregisterInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension DeregisterInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstanceNotFound" : self = .instanceNotFound(try InstanceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterInstanceOutputError: Equatable {
    case duplicateRequest(DuplicateRequest)
    case instanceNotFound(InstanceNotFound)
    case invalidInput(InvalidInput)
    case resourceInUse(ResourceInUse)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterInstanceOutputResponse(operationId: \(String(describing: operationId)))"}
}

extension DeregisterInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeregisterInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct DeregisterInstanceOutputResponse: Equatable {
    /// <p>A value that you can use to determine whether the request completed successfully. For more information, see
    ///     <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation</a>.</p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct DeregisterInstanceOutputResponseBody: Equatable {
    public let operationId: String?
}

extension DeregisterInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct DiscoverInstancesInputBodyMiddleware: Middleware {
    public let id: String = "DiscoverInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DiscoverInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DiscoverInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DiscoverInstancesInput>
    public typealias MOutput = OperationOutput<DiscoverInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DiscoverInstancesOutputError>
}

extension DiscoverInstancesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DiscoverInstancesInput(healthStatus: \(String(describing: healthStatus)), maxResults: \(String(describing: maxResults)), namespaceName: \(String(describing: namespaceName)), optionalParameters: \(String(describing: optionalParameters)), queryParameters: \(String(describing: queryParameters)), serviceName: \(String(describing: serviceName)))"}
}

extension DiscoverInstancesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case healthStatus = "HealthStatus"
        case maxResults = "MaxResults"
        case namespaceName = "NamespaceName"
        case optionalParameters = "OptionalParameters"
        case queryParameters = "QueryParameters"
        case serviceName = "ServiceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthStatus = healthStatus {
            try encodeContainer.encode(healthStatus.rawValue, forKey: .healthStatus)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let namespaceName = namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let optionalParameters = optionalParameters {
            var optionalParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .optionalParameters)
            for (dictKey0, attributes0) in optionalParameters {
                try optionalParametersContainer.encode(attributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let queryParameters = queryParameters {
            var queryParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .queryParameters)
            for (dictKey0, attributes0) in queryParameters {
                try queryParametersContainer.encode(attributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }
}

public struct DiscoverInstancesInputHeadersMiddleware: Middleware {
    public let id: String = "DiscoverInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DiscoverInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DiscoverInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DiscoverInstancesInput>
    public typealias MOutput = OperationOutput<DiscoverInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DiscoverInstancesOutputError>
}

public struct DiscoverInstancesInputQueryItemMiddleware: Middleware {
    public let id: String = "DiscoverInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DiscoverInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DiscoverInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DiscoverInstancesInput>
    public typealias MOutput = OperationOutput<DiscoverInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DiscoverInstancesOutputError>
}

public struct DiscoverInstancesInput: Equatable {
    /// <p>The health status of the instances that you want to discover. This parameter is ignored for services that don't
    ///    have a health check configured, and
    ///    all
    ///    instances are returned.</p>
    ///          <dl>
    ///             <dt>HEALTHY</dt>
    ///             <dd>
    ///                <p>Returns healthy instances.</p>
    ///             </dd>
    ///             <dt>UNHEALTHY</dt>
    ///             <dd>
    ///                <p>Returns unhealthy instances.</p>
    ///             </dd>
    ///             <dt>ALL</dt>
    ///             <dd>
    ///                <p>Returns all instances.</p>
    ///             </dd>
    ///             <dt>HEALTHY_OR_ELSE_ALL</dt>
    ///             <dd>
    ///                <p>Returns healthy instances, unless none are reporting a healthy state. In that case, return all instances.
    ///       This is also called failing open.</p>
    ///             </dd>
    ///          </dl>
    public let healthStatus: HealthStatusFilter?
    /// <p>The maximum number of instances that you want AWS Cloud Map to return in the response to a
    ///     <code>DiscoverInstances</code> request. If you don't specify a value for <code>MaxResults</code>, AWS Cloud Map returns up
    ///    to 100 instances.</p>
    public let maxResults: Int?
    /// <p>The <code>HttpName</code> name of the namespace. It's found in the <code>HttpProperties</code> member of the
    ///     <code>Properties</code> member of the namespace.</p>
    public let namespaceName: String?
    /// <p>Opportunistic filters to scope the results based on custom attributes. If there are instances that match both
    ///    the filters specified in both the <code>QueryParameters</code> parameter and this parameter, all of these instances
    ///    are returned. Otherwise, the filters are ignored, and only instances that match the filters that are specified in the
    ///     <code>QueryParameters</code> parameter are returned.</p>
    public let optionalParameters: [String:String]?
    /// <p>Filters to scope the results based on custom attributes for the instance (for example, <code>{version=v1,
    ///     az=1a}</code>). Only instances that match all the specified key-value pairs are returned.</p>
    public let queryParameters: [String:String]?
    /// <p>The name of the service that you specified when you registered the instance.</p>
    public let serviceName: String?

    public init (
        healthStatus: HealthStatusFilter? = nil,
        maxResults: Int? = nil,
        namespaceName: String? = nil,
        optionalParameters: [String:String]? = nil,
        queryParameters: [String:String]? = nil,
        serviceName: String? = nil
    )
    {
        self.healthStatus = healthStatus
        self.maxResults = maxResults
        self.namespaceName = namespaceName
        self.optionalParameters = optionalParameters
        self.queryParameters = queryParameters
        self.serviceName = serviceName
    }
}

struct DiscoverInstancesInputBody: Equatable {
    public let namespaceName: String?
    public let serviceName: String?
    public let maxResults: Int?
    public let queryParameters: [String:String]?
    public let optionalParameters: [String:String]?
    public let healthStatus: HealthStatusFilter?
}

extension DiscoverInstancesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case healthStatus = "HealthStatus"
        case maxResults = "MaxResults"
        case namespaceName = "NamespaceName"
        case optionalParameters = "OptionalParameters"
        case queryParameters = "QueryParameters"
        case serviceName = "ServiceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let queryParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .queryParameters)
        var queryParametersDecoded0: [String:String]? = nil
        if let queryParametersContainer = queryParametersContainer {
            queryParametersDecoded0 = [String:String]()
            for (key0, attrvalue0) in queryParametersContainer {
                if let attrvalue0 = attrvalue0 {
                    queryParametersDecoded0?[key0] = attrvalue0
                }
            }
        }
        queryParameters = queryParametersDecoded0
        let optionalParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .optionalParameters)
        var optionalParametersDecoded0: [String:String]? = nil
        if let optionalParametersContainer = optionalParametersContainer {
            optionalParametersDecoded0 = [String:String]()
            for (key0, attrvalue0) in optionalParametersContainer {
                if let attrvalue0 = attrvalue0 {
                    optionalParametersDecoded0?[key0] = attrvalue0
                }
            }
        }
        optionalParameters = optionalParametersDecoded0
        let healthStatusDecoded = try containerValues.decodeIfPresent(HealthStatusFilter.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
    }
}

extension DiscoverInstancesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DiscoverInstancesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceNotFound" : self = .namespaceNotFound(try NamespaceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestLimitExceeded" : self = .requestLimitExceeded(try RequestLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DiscoverInstancesOutputError: Equatable {
    case invalidInput(InvalidInput)
    case namespaceNotFound(NamespaceNotFound)
    case requestLimitExceeded(RequestLimitExceeded)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension DiscoverInstancesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DiscoverInstancesOutputResponse(instances: \(String(describing: instances)))"}
}

extension DiscoverInstancesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DiscoverInstancesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instances = output.instances
        } else {
            self.instances = nil
        }
    }
}

public struct DiscoverInstancesOutputResponse: Equatable {
    /// <p>A complex type that contains one <code>HttpInstanceSummary</code> for each registered instance.</p>
    public let instances: [HttpInstanceSummary]?

    public init (
        instances: [HttpInstanceSummary]? = nil
    )
    {
        self.instances = instances
    }
}

struct DiscoverInstancesOutputResponseBody: Equatable {
    public let instances: [HttpInstanceSummary]?
}

extension DiscoverInstancesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instances = "Instances"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancesContainer = try containerValues.decodeIfPresent([HttpInstanceSummary?].self, forKey: .instances)
        var instancesDecoded0:[HttpInstanceSummary]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [HttpInstanceSummary]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
    }
}

extension DnsConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dnsRecords = "DnsRecords"
        case namespaceId = "NamespaceId"
        case routingPolicy = "RoutingPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsRecords = dnsRecords {
            var dnsRecordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsRecords)
            for dnsrecordlist0 in dnsRecords {
                try dnsRecordsContainer.encode(dnsrecordlist0)
            }
        }
        if let namespaceId = namespaceId {
            try encodeContainer.encode(namespaceId, forKey: .namespaceId)
        }
        if let routingPolicy = routingPolicy {
            try encodeContainer.encode(routingPolicy.rawValue, forKey: .routingPolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespaceId)
        namespaceId = namespaceIdDecoded
        let routingPolicyDecoded = try containerValues.decodeIfPresent(RoutingPolicy.self, forKey: .routingPolicy)
        routingPolicy = routingPolicyDecoded
        let dnsRecordsContainer = try containerValues.decodeIfPresent([DnsRecord?].self, forKey: .dnsRecords)
        var dnsRecordsDecoded0:[DnsRecord]? = nil
        if let dnsRecordsContainer = dnsRecordsContainer {
            dnsRecordsDecoded0 = [DnsRecord]()
            for structure0 in dnsRecordsContainer {
                if let structure0 = structure0 {
                    dnsRecordsDecoded0?.append(structure0)
                }
            }
        }
        dnsRecords = dnsRecordsDecoded0
    }
}

extension DnsConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DnsConfig(dnsRecords: \(String(describing: dnsRecords)), namespaceId: \(String(describing: namespaceId)), routingPolicy: \(String(describing: routingPolicy)))"}
}

/// <p>A complex type that contains information about the Amazon Route 53 DNS records that you want AWS Cloud Map to create when
///    you register an instance.</p>
public struct DnsConfig: Equatable {
    /// <p>An array that contains one <code>DnsRecord</code> object for each Route 53 DNS record that you want AWS Cloud Map to
    ///    create when you register an instance.</p>
    public let dnsRecords: [DnsRecord]?
    /// <p>The ID of the namespace to use for DNS configuration.</p>
    @available(*, deprecated, message: "Top level attribute in request should be used to reference namespace-id")
    public let namespaceId: String?
    /// <p>The routing policy that you want to apply to all Route 53 DNS records that AWS Cloud Map creates when you register an
    ///    instance and specify this service.</p>
    ///          <note>
    ///             <p>If you want to use this service to register instances that create alias records, specify <code>WEIGHTED</code>
    ///     for the routing policy.</p>
    ///          </note>
    ///          <p>You can specify the following values:</p>
    ///          <dl>
    ///             <dt>MULTIVALUE</dt>
    ///             <dd>
    ///                <p>If you define a health check for the service and the health check is healthy, Route 53 returns the applicable
    ///       value for up to eight instances.</p>
    ///                <p>For example, suppose that the service includes configurations for one <code>A</code> record and a health
    ///       check. You use the service to register 10 instances. Route 53 responds to DNS queries with IP addresses for up to
    ///       eight healthy instances. If fewer than eight instances are healthy, Route 53 responds to every DNS query with the IP
    ///       addresses for all of the healthy instances.</p>
    ///                <p>If you don't define a health check for the service, Route 53 assumes that all instances are healthy and returns
    ///       the values for up to eight instances.</p>
    ///                <p>For more information about the multivalue routing policy, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-multivalue">Multivalue Answer
    ///        Routing</a> in the <i>Route 53 Developer Guide</i>.</p>
    ///             </dd>
    ///             <dt>WEIGHTED</dt>
    ///             <dd>
    ///                <p>Route 53 returns the applicable value from one randomly selected instance from among the instances that you
    ///       registered using the same service. Currently, all records have the same weight, so you can't route more or less
    ///       traffic to any instances.</p>
    ///                <p>For example, suppose that the service includes configurations for one <code>A</code> record and a health
    ///       check. You use the service to register 10 instances. Route 53 responds to DNS queries with the IP address for one
    ///       randomly selected instance from among the healthy instances. If no instances are healthy, Route 53 responds to DNS
    ///       queries as if all of the instances were healthy.</p>
    ///                <p>If you don't define a health check for the service, Route 53 assumes that all instances are healthy and returns
    ///       the applicable value for one randomly selected instance.</p>
    ///                <p>For more information about the weighted routing policy, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted">Weighted Routing</a> in the
    ///        <i>Route 53 Developer Guide</i>.</p>
    ///             </dd>
    ///          </dl>
    public let routingPolicy: RoutingPolicy?

    public init (
        dnsRecords: [DnsRecord]? = nil,
        namespaceId: String? = nil,
        routingPolicy: RoutingPolicy? = nil
    )
    {
        self.dnsRecords = dnsRecords
        self.namespaceId = namespaceId
        self.routingPolicy = routingPolicy
    }
}

extension DnsConfigChange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dnsRecords = "DnsRecords"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsRecords = dnsRecords {
            var dnsRecordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsRecords)
            for dnsrecordlist0 in dnsRecords {
                try dnsRecordsContainer.encode(dnsrecordlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dnsRecordsContainer = try containerValues.decodeIfPresent([DnsRecord?].self, forKey: .dnsRecords)
        var dnsRecordsDecoded0:[DnsRecord]? = nil
        if let dnsRecordsContainer = dnsRecordsContainer {
            dnsRecordsDecoded0 = [DnsRecord]()
            for structure0 in dnsRecordsContainer {
                if let structure0 = structure0 {
                    dnsRecordsDecoded0?.append(structure0)
                }
            }
        }
        dnsRecords = dnsRecordsDecoded0
    }
}

extension DnsConfigChange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DnsConfigChange(dnsRecords: \(String(describing: dnsRecords)))"}
}

/// <p>A complex type that contains information about changes to the Route 53 DNS records that AWS Cloud Map creates when you
///    register an instance.</p>
public struct DnsConfigChange: Equatable {
    /// <p>An array that contains one <code>DnsRecord</code> object for each Route 53 record that you want AWS Cloud Map to
    ///    create when you register an instance.</p>
    public let dnsRecords: [DnsRecord]?

    public init (
        dnsRecords: [DnsRecord]? = nil
    )
    {
        self.dnsRecords = dnsRecords
    }
}

extension DnsProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hostedZoneId = "HostedZoneId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostedZoneId = hostedZoneId {
            try encodeContainer.encode(hostedZoneId, forKey: .hostedZoneId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
    }
}

extension DnsProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DnsProperties(hostedZoneId: \(String(describing: hostedZoneId)))"}
}

/// <p>A complex type that contains the ID for the Route 53 hosted zone that AWS Cloud Map creates when you create a
///    namespace.</p>
public struct DnsProperties: Equatable {
    /// <p>The ID for the Route 53 hosted zone that AWS Cloud Map creates when you create a namespace.</p>
    public let hostedZoneId: String?

    public init (
        hostedZoneId: String? = nil
    )
    {
        self.hostedZoneId = hostedZoneId
    }
}

extension DnsRecord: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tTL = "TTL"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tTL = tTL {
            try encodeContainer.encode(tTL, forKey: .tTL)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(RecordType.self, forKey: .type)
        type = typeDecoded
        let tTLDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .tTL)
        tTL = tTLDecoded
    }
}

extension DnsRecord: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DnsRecord(tTL: \(String(describing: tTL)), type: \(String(describing: type)))"}
}

/// <p>A complex type that contains information about the Route 53 DNS records that you want AWS Cloud Map to create when you
///    register an instance.</p>
public struct DnsRecord: Equatable {
    /// <p>The amount of time, in seconds, that you want DNS resolvers to cache the settings for this record.</p>
    ///          <note>
    ///             <p>Alias records don't include a TTL because Route 53 uses the TTL for the AWS resource that an alias record routes
    ///     traffic to. If you include the <code>AWS_ALIAS_DNS_NAME</code> attribute when you submit a <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance</a> request, the
    ///      <code>TTL</code> value is ignored. Always specify a TTL for the service; you can use a service to register
    ///     instances that create either alias or non-alias records.</p>
    ///          </note>
    public let tTL: Int?
    /// <p>The type of the resource, which indicates the type of value that Route 53 returns in response to DNS queries. You
    ///    can specify values for <code>Type</code> in the following combinations:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>
    ///                      <code>A</code>
    ///                   </b>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>
    ///                      <code>AAAA</code>
    ///                   </b>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>
    ///                      <code>A</code>
    ///                   </b> and <b>
    ///                      <code>AAAA</code>
    ///                   </b>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>
    ///                      <code>SRV</code>
    ///                   </b>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>
    ///                      <code>CNAME</code>
    ///                   </b>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>If you want AWS Cloud Map to create a Route 53 alias record when you register an instance, specify <code>A</code> or
    ///     <code>AAAA</code> for <code>Type</code>.</p>
    ///          <p>You specify other settings, such as the IP address for <code>A</code> and <code>AAAA</code> records, when you
    ///    register an instance. For more information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance</a>.</p>
    ///          <p>The following values are supported:</p>
    ///          <dl>
    ///             <dt>A</dt>
    ///             <dd>
    ///                <p>Route 53 returns the IP address of the resource in IPv4 format, such as 192.0.2.44.</p>
    ///             </dd>
    ///             <dt>AAAA</dt>
    ///             <dd>
    ///                <p>Route 53 returns the IP address of the resource in IPv6 format, such as
    ///       2001:0db8:85a3:0000:0000:abcd:0001:2345.</p>
    ///             </dd>
    ///             <dt>CNAME</dt>
    ///             <dd>
    ///                <p>Route 53 returns the domain name of the resource, such as www.example.com. Note the following:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>You specify the domain name that you want to route traffic to when you register an instance. For more
    ///         information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html#cloudmap-RegisterInstance-request-Attributes">Attributes</a> in the topic <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance</a>.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>You must specify <code>WEIGHTED</code> for the value of <code>RoutingPolicy</code>.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>You can't specify both <code>CNAME</code> for <code>Type</code> and settings for
    ///          <code>HealthCheckConfig</code>. If you do, the request will fail with an <code>InvalidInput</code>
    ///         error.</p>
    ///                   </li>
    ///                </ul>
    ///             </dd>
    ///             <dt>SRV</dt>
    ///             <dd>
    ///                <p>Route 53 returns the value for an <code>SRV</code> record. The value for an <code>SRV</code> record uses the
    ///       following values:</p>
    ///                <p>
    ///                   <code>priority weight port service-hostname</code>
    ///                </p>
    ///                <p>Note the following about the values:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>The values of <code>priority</code> and <code>weight</code> are both set to <code>1</code> and can't be
    ///         changed. </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>The value of <code>port</code> comes from the value that you specify for the <code>AWS_INSTANCE_PORT</code>
    ///         attribute when you submit a <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance</a> request. </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>The value of <code>service-hostname</code> is a concatenation of the following values:</p>
    ///                      <ul>
    ///                         <li>
    ///                            <p>The value that you specify for <code>InstanceId</code> when you register an instance.</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>The name of the service.</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>The name of the namespace. </p>
    ///                         </li>
    ///                      </ul>
    ///                      <p>For example, if the value of <code>InstanceId</code> is <code>test</code>, the name of the service is
    ///          <code>backend</code>, and the name of the namespace is <code>example.com</code>, the value of
    ///          <code>service-hostname</code> is the following:</p>
    ///                      <p>
    ///                         <code>test.backend.example.com</code>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    ///                <p>If you specify settings for an <code>SRV</code> record, note the following:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>If you specify values for <code>AWS_INSTANCE_IPV4</code>, <code>AWS_INSTANCE_IPV6</code>, or both in the
    ///          <code>RegisterInstance</code> request, AWS Cloud Map automatically creates <code>A</code> and/or <code>AAAA</code>
    ///         records that have the same name as the value of <code>service-hostname</code> in the <code>SRV</code> record.
    ///         You can ignore these records.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>If you're using a system that requires a specific <code>SRV</code> format, such as HAProxy, see the <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_CreateService.html#cloudmap-CreateService-request-Name">Name</a> element in the documentation about <code>CreateService</code> for information about how to
    ///         specify the correct name format.</p>
    ///                   </li>
    ///                </ul>
    ///             </dd>
    ///          </dl>
    public let type: RecordType?

    public init (
        tTL: Int? = nil,
        type: RecordType? = nil
    )
    {
        self.tTL = tTL
        self.type = type
    }
}

extension DuplicateRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DuplicateRequest(duplicateOperationId: \(String(describing: duplicateOperationId)), message: \(String(describing: message)))"}
}

extension DuplicateRequest: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DuplicateRequestBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.duplicateOperationId = output.duplicateOperationId
            self.message = output.message
        } else {
            self.duplicateOperationId = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation is already in progress.</p>
public struct DuplicateRequest: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The ID of the operation that's already in progress.</p>
    public var duplicateOperationId: String?
    public var message: String?

    public init (
        duplicateOperationId: String? = nil,
        message: String? = nil
    )
    {
        self.duplicateOperationId = duplicateOperationId
        self.message = message
    }
}

struct DuplicateRequestBody: Equatable {
    public let message: String?
    public let duplicateOperationId: String?
}

extension DuplicateRequestBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case duplicateOperationId = "DuplicateOperationId"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let duplicateOperationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .duplicateOperationId)
        duplicateOperationId = duplicateOperationIdDecoded
    }
}

public enum FilterCondition {
    case between
    case eq
    case `in`
    case sdkUnknown(String)
}

extension FilterCondition : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FilterCondition] {
        return [
            .between,
            .eq,
            .in,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .between: return "BETWEEN"
        case .eq: return "EQ"
        case .in: return "IN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FilterCondition(rawValue: rawValue) ?? FilterCondition.sdkUnknown(rawValue)
    }
}

public struct GetInstanceInputBodyMiddleware: Middleware {
    public let id: String = "GetInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInstanceInput>
    public typealias MOutput = OperationOutput<GetInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInstanceOutputError>
}

extension GetInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInstanceInput(instanceId: \(String(describing: instanceId)), serviceId: \(String(describing: serviceId)))"}
}

extension GetInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
    }
}

public struct GetInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "GetInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInstanceInput>
    public typealias MOutput = OperationOutput<GetInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInstanceOutputError>
}

public struct GetInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "GetInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInstanceInput>
    public typealias MOutput = OperationOutput<GetInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInstanceOutputError>
}

public struct GetInstanceInput: Equatable {
    /// <p>The ID of the instance that you want to get information about.</p>
    public let instanceId: String?
    /// <p>The ID of the service that the instance is associated with.</p>
    public let serviceId: String?

    public init (
        instanceId: String? = nil,
        serviceId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.serviceId = serviceId
    }
}

struct GetInstanceInputBody: Equatable {
    public let serviceId: String?
    public let instanceId: String?
}

extension GetInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension GetInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InstanceNotFound" : self = .instanceNotFound(try InstanceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInstanceOutputError: Equatable {
    case instanceNotFound(InstanceNotFound)
    case invalidInput(InvalidInput)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInstanceOutputResponse(instance: \(String(describing: instance)))"}
}

extension GetInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instance = output.instance
        } else {
            self.instance = nil
        }
    }
}

public struct GetInstanceOutputResponse: Equatable {
    /// <p>A complex type that contains information about a specified instance.</p>
    public let instance: Instance?

    public init (
        instance: Instance? = nil
    )
    {
        self.instance = instance
    }
}

struct GetInstanceOutputResponseBody: Equatable {
    public let instance: Instance?
}

extension GetInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instance = "Instance"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceDecoded = try containerValues.decodeIfPresent(Instance.self, forKey: .instance)
        instance = instanceDecoded
    }
}

public struct GetInstancesHealthStatusInputBodyMiddleware: Middleware {
    public let id: String = "GetInstancesHealthStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInstancesHealthStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInstancesHealthStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInstancesHealthStatusInput>
    public typealias MOutput = OperationOutput<GetInstancesHealthStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInstancesHealthStatusOutputError>
}

extension GetInstancesHealthStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInstancesHealthStatusInput(instances: \(String(describing: instances)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), serviceId: \(String(describing: serviceId)))"}
}

extension GetInstancesHealthStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instances = "Instances"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceId = "ServiceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instances = instances {
            var instancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instances)
            for instanceidlist0 in instances {
                try instancesContainer.encode(instanceidlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
    }
}

public struct GetInstancesHealthStatusInputHeadersMiddleware: Middleware {
    public let id: String = "GetInstancesHealthStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInstancesHealthStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInstancesHealthStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInstancesHealthStatusInput>
    public typealias MOutput = OperationOutput<GetInstancesHealthStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInstancesHealthStatusOutputError>
}

public struct GetInstancesHealthStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "GetInstancesHealthStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInstancesHealthStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInstancesHealthStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInstancesHealthStatusInput>
    public typealias MOutput = OperationOutput<GetInstancesHealthStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInstancesHealthStatusOutputError>
}

public struct GetInstancesHealthStatusInput: Equatable {
    /// <p>An array that contains the IDs of all the instances that you want to get the health status for.</p>
    ///          <p>If you omit <code>Instances</code>, AWS Cloud Map returns the health status for all the instances that are
    ///    associated with the specified service.</p>
    ///          <note>
    ///             <p>To get the IDs for the instances that you've registered by using a specified service, submit a <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_ListInstances.html">ListInstances</a> request.</p>
    ///          </note>
    public let instances: [String]?
    /// <p>The maximum number of instances that you want AWS Cloud Map to return in the response to a
    ///     <code>GetInstancesHealthStatus</code> request. If you don't specify a value for <code>MaxResults</code>, AWS Cloud Map
    ///    returns up to 100 instances.</p>
    public let maxResults: Int?
    /// <p>For the first <code>GetInstancesHealthStatus</code> request, omit this value.</p>
    ///          <p>If more than <code>MaxResults</code> instances match the specified criteria, you can submit another
    ///     <code>GetInstancesHealthStatus</code> request to get the next group of results. Specify the value of
    ///     <code>NextToken</code> from the previous response in the next request.</p>
    public let nextToken: String?
    /// <p>The ID of the service that the instance is associated with.</p>
    public let serviceId: String?

    public init (
        instances: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        serviceId: String? = nil
    )
    {
        self.instances = instances
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceId = serviceId
    }
}

struct GetInstancesHealthStatusInputBody: Equatable {
    public let serviceId: String?
    public let instances: [String]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension GetInstancesHealthStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instances = "Instances"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceId = "ServiceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let instancesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .instances)
        var instancesDecoded0:[String]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [String]()
            for string0 in instancesContainer {
                if let string0 = string0 {
                    instancesDecoded0?.append(string0)
                }
            }
        }
        instances = instancesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetInstancesHealthStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInstancesHealthStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InstanceNotFound" : self = .instanceNotFound(try InstanceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInstancesHealthStatusOutputError: Equatable {
    case instanceNotFound(InstanceNotFound)
    case invalidInput(InvalidInput)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInstancesHealthStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInstancesHealthStatusOutputResponse(nextToken: \(String(describing: nextToken)), status: \(String(describing: status)))"}
}

extension GetInstancesHealthStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetInstancesHealthStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.status = output.status
        } else {
            self.nextToken = nil
            self.status = nil
        }
    }
}

public struct GetInstancesHealthStatusOutputResponse: Equatable {
    /// <p>If more than <code>MaxResults</code> instances match the specified criteria, you can submit another
    ///     <code>GetInstancesHealthStatus</code> request to get the next group of results. Specify the value of
    ///     <code>NextToken</code> from the previous response in the next request.</p>
    public let nextToken: String?
    /// <p>A complex type that contains the IDs and the health status of the instances that you specified in the
    ///     <code>GetInstancesHealthStatus</code> request.</p>
    public let status: [String:HealthStatus]?

    public init (
        nextToken: String? = nil,
        status: [String:HealthStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.status = status
    }
}

struct GetInstancesHealthStatusOutputResponseBody: Equatable {
    public let status: [String:HealthStatus]?
    public let nextToken: String?
}

extension GetInstancesHealthStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusContainer = try containerValues.decodeIfPresent([String: HealthStatus?].self, forKey: .status)
        var statusDecoded0: [String:HealthStatus]? = nil
        if let statusContainer = statusContainer {
            statusDecoded0 = [String:HealthStatus]()
            for (key0, healthstatus0) in statusContainer {
                if let healthstatus0 = healthstatus0 {
                    statusDecoded0?[key0] = healthstatus0
                }
            }
        }
        status = statusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetNamespaceInputBodyMiddleware: Middleware {
    public let id: String = "GetNamespaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetNamespaceInput>
    public typealias MOutput = OperationOutput<GetNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetNamespaceOutputError>
}

extension GetNamespaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetNamespaceInput(id: \(String(describing: id)))"}
}

extension GetNamespaceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct GetNamespaceInputHeadersMiddleware: Middleware {
    public let id: String = "GetNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetNamespaceInput>
    public typealias MOutput = OperationOutput<GetNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetNamespaceOutputError>
}

public struct GetNamespaceInputQueryItemMiddleware: Middleware {
    public let id: String = "GetNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetNamespaceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetNamespaceInput>
    public typealias MOutput = OperationOutput<GetNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetNamespaceOutputError>
}

public struct GetNamespaceInput: Equatable {
    /// <p>The ID of the namespace that you want to get information about.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetNamespaceInputBody: Equatable {
    public let id: String?
}

extension GetNamespaceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension GetNamespaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNamespaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NamespaceNotFound" : self = .namespaceNotFound(try NamespaceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetNamespaceOutputError: Equatable {
    case invalidInput(InvalidInput)
    case namespaceNotFound(NamespaceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNamespaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetNamespaceOutputResponse(namespace: \(String(describing: namespace)))"}
}

extension GetNamespaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.namespace = output.namespace
        } else {
            self.namespace = nil
        }
    }
}

public struct GetNamespaceOutputResponse: Equatable {
    /// <p>A complex type that contains information about the specified namespace.</p>
    public let namespace: Namespace?

    public init (
        namespace: Namespace? = nil
    )
    {
        self.namespace = namespace
    }
}

struct GetNamespaceOutputResponseBody: Equatable {
    public let namespace: Namespace?
}

extension GetNamespaceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case namespace = "Namespace"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(Namespace.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

public struct GetOperationInputBodyMiddleware: Middleware {
    public let id: String = "GetOperationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOperationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOperationInput>
    public typealias MOutput = OperationOutput<GetOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOperationOutputError>
}

extension GetOperationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOperationInput(operationId: \(String(describing: operationId)))"}
}

extension GetOperationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operationId = operationId {
            try encodeContainer.encode(operationId, forKey: .operationId)
        }
    }
}

public struct GetOperationInputHeadersMiddleware: Middleware {
    public let id: String = "GetOperationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOperationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOperationInput>
    public typealias MOutput = OperationOutput<GetOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOperationOutputError>
}

public struct GetOperationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetOperationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOperationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOperationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOperationInput>
    public typealias MOutput = OperationOutput<GetOperationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOperationOutputError>
}

public struct GetOperationInput: Equatable {
    /// <p>The ID of the operation that you want to get more information about.</p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct GetOperationInputBody: Equatable {
    public let operationId: String?
}

extension GetOperationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension GetOperationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOperationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotFound" : self = .operationNotFound(try OperationNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOperationOutputError: Equatable {
    case invalidInput(InvalidInput)
    case operationNotFound(OperationNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOperationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOperationOutputResponse(operation: \(String(describing: operation)))"}
}

extension GetOperationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetOperationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operation = output.operation
        } else {
            self.operation = nil
        }
    }
}

public struct GetOperationOutputResponse: Equatable {
    /// <p>A complex type that contains information about the operation.</p>
    public let operation: Operation?

    public init (
        operation: Operation? = nil
    )
    {
        self.operation = operation
    }
}

struct GetOperationOutputResponseBody: Equatable {
    public let operation: Operation?
}

extension GetOperationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operation = "Operation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationDecoded = try containerValues.decodeIfPresent(Operation.self, forKey: .operation)
        operation = operationDecoded
    }
}

public struct GetServiceInputBodyMiddleware: Middleware {
    public let id: String = "GetServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceInput>
    public typealias MOutput = OperationOutput<GetServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceOutputError>
}

extension GetServiceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServiceInput(id: \(String(describing: id)))"}
}

extension GetServiceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct GetServiceInputHeadersMiddleware: Middleware {
    public let id: String = "GetServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceInput>
    public typealias MOutput = OperationOutput<GetServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceOutputError>
}

public struct GetServiceInputQueryItemMiddleware: Middleware {
    public let id: String = "GetServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceInput>
    public typealias MOutput = OperationOutput<GetServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceOutputError>
}

public struct GetServiceInput: Equatable {
    /// <p>The ID of the service that you want to get settings for.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetServiceInputBody: Equatable {
    public let id: String?
}

extension GetServiceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension GetServiceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceOutputError: Equatable {
    case invalidInput(InvalidInput)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServiceOutputResponse(service: \(String(describing: service)))"}
}

extension GetServiceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetServiceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.service = output.service
        } else {
            self.service = nil
        }
    }
}

public struct GetServiceOutputResponse: Equatable {
    /// <p>A complex type that contains information about the service.</p>
    public let service: Service?

    public init (
        service: Service? = nil
    )
    {
        self.service = service
    }
}

struct GetServiceOutputResponseBody: Equatable {
    public let service: Service?
}

extension GetServiceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case service = "Service"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(Service.self, forKey: .service)
        service = serviceDecoded
    }
}

extension HealthCheckConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failureThreshold = "FailureThreshold"
        case resourcePath = "ResourcePath"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureThreshold = failureThreshold {
            try encodeContainer.encode(failureThreshold, forKey: .failureThreshold)
        }
        if let resourcePath = resourcePath {
            try encodeContainer.encode(resourcePath, forKey: .resourcePath)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(HealthCheckType.self, forKey: .type)
        type = typeDecoded
        let resourcePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourcePath)
        resourcePath = resourcePathDecoded
        let failureThresholdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .failureThreshold)
        failureThreshold = failureThresholdDecoded
    }
}

extension HealthCheckConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HealthCheckConfig(failureThreshold: \(String(describing: failureThreshold)), resourcePath: \(String(describing: resourcePath)), type: \(String(describing: type)))"}
}

/// <p>
///             <i>Public DNS and HTTP namespaces only.</i> A complex type that contains settings for an optional
///    health check. If you specify settings for a health check, AWS Cloud Map associates the health check with the records
///    that you specify in <code>DnsConfig</code>.</p>
///          <important>
///             <p>If you specify a health check configuration, you can specify either <code>HealthCheckCustomConfig</code> or
///      <code>HealthCheckConfig</code> but not both.</p>
///          </important>
///          <p>Health checks are basic Route 53 health checks that monitor an AWS endpoint. For information about pricing for
///    health checks, see <a href="http://aws.amazon.com/route53/pricing/">Amazon Route 53 Pricing</a>.</p>
///          <p>Note the following about configuring health checks.</p>
///          <dl>
///             <dt>A and AAAA records</dt>
///             <dd>
///                <p>If <code>DnsConfig</code> includes configurations for both <code>A</code> and <code>AAAA</code> records,
///       AWS Cloud Map creates a health check that uses the IPv4 address to check the health of the resource. If the endpoint
///       tthat's specified by the IPv4 address is unhealthy, Route 53 considers both the <code>A</code> and <code>AAAA</code>
///       records to be unhealthy. </p>
///             </dd>
///             <dt>CNAME records</dt>
///             <dd>
///                <p>You can't specify settings for <code>HealthCheckConfig</code> when the <code>DNSConfig</code> includes
///        <code>CNAME</code> for the value of <code>Type</code>. If you do, the <code>CreateService</code> request will
///       fail with an <code>InvalidInput</code> error.</p>
///             </dd>
///             <dt>Request interval</dt>
///             <dd>
///                <p>A Route 53 health checker in each health-checking AWS Region sends a health check request to an endpoint every
///       30 seconds. On average, your endpoint receives a health check request about every two seconds. However, health
///       checkers don't coordinate with one another. Therefore, you might sometimes see several requests in one second
///       that's followed by a few seconds with no health checks at all.</p>
///             </dd>
///             <dt>Health checking regions</dt>
///             <dd>
///                <p>Health checkers perform checks from all Route 53 health-checking Regions. For a list of the current Regions, see
///        <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_HealthCheckConfig.html#Route53-Type-HealthCheckConfig-Regions">Regions</a>.</p>
///             </dd>
///             <dt>Alias records</dt>
///             <dd>
///                <p>When you register an instance, if you include the <code>AWS_ALIAS_DNS_NAME</code> attribute, AWS Cloud Map
///       creates a Route 53 alias record. Note the following:</p>
///                <ul>
///                   <li>
///                      <p>Route 53 automatically sets <code>EvaluateTargetHealth</code> to true for alias records. When
///          <code>EvaluateTargetHealth</code> is true, the alias record inherits the health of the referenced AWS
///         resource. such as an ELB load balancer. For more information, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_AliasTarget.html#Route53-Type-AliasTarget-EvaluateTargetHealth">EvaluateTargetHealth</a>.</p>
///                   </li>
///                   <li>
///                      <p>If you include <code>HealthCheckConfig</code> and then use the service to register an instance that creates
///         an alias record, Route 53 doesn't create the health check.</p>
///                   </li>
///                </ul>
///             </dd>
///             <dt>Charges for health checks</dt>
///             <dd>
///                <p>Health checks are basic Route 53 health checks that monitor an AWS endpoint. For information about pricing for
///       health checks, see <a href="http://aws.amazon.com/route53/pricing/">Amazon Route 53 Pricing</a>.</p>
///             </dd>
///          </dl>
public struct HealthCheckConfig: Equatable {
    /// <p>The number of consecutive health checks that an endpoint must pass or fail for Route 53 to change the current
    ///    status of the endpoint from unhealthy to healthy or the other way around. For more information, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html">How Route 53
    ///     Determines Whether an Endpoint Is Healthy</a> in the <i>Route 53 Developer Guide</i>.</p>
    public let failureThreshold: Int?
    /// <p>The path that you want Route 53 to request when performing health checks. The path can be any value that your
    ///    endpoint returns an HTTP status code of a 2xx or 3xx format for when the endpoint is healthy. An example file is
    ///     <code>/docs/route53-health-check.html</code>. Route 53 automatically adds the DNS name for the service. If you don't
    ///    specify a value for <code>ResourcePath</code>, the default value is <code>/</code>.</p>
    ///          <p>If you specify <code>TCP</code> for <code>Type</code>, you must <i>not</i> specify a value for
    ///     <code>ResourcePath</code>.</p>
    public let resourcePath: String?
    /// <p>The type of health check that you want to create, which indicates how Route 53 determines whether an endpoint is
    ///    healthy.</p>
    ///          <important>
    ///             <p>You can't change the value of <code>Type</code> after you create a health check.</p>
    ///          </important>
    ///          <p>You can create the following types of health checks:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>HTTP</b>: Route 53 tries to establish a TCP connection. If successful, Route 53 submits
    ///      an HTTP request and waits for an HTTP status code of 200 or greater and less than 400.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>HTTPS</b>: Route 53 tries to establish a TCP connection. If successful, Route 53
    ///      submits an HTTPS request and waits for an HTTP status code of 200 or greater and less than 400.</p>
    ///                <important>
    ///                   <p>If you specify HTTPS for the value of <code>Type</code>, the endpoint must support TLS v1.0 or later.</p>
    ///                </important>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>TCP</b>: Route 53 tries to establish a TCP connection.</p>
    ///                <p>If you specify <code>TCP</code> for <code>Type</code>, don't specify a value for
    ///      <code>ResourcePath</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html">How Route 53 Determines Whether
    ///     an Endpoint Is Healthy</a> in the <i>Route 53 Developer Guide</i>.</p>
    public let type: HealthCheckType?

    public init (
        failureThreshold: Int? = nil,
        resourcePath: String? = nil,
        type: HealthCheckType? = nil
    )
    {
        self.failureThreshold = failureThreshold
        self.resourcePath = resourcePath
        self.type = type
    }
}

extension HealthCheckCustomConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failureThreshold = "FailureThreshold"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureThreshold = failureThreshold {
            try encodeContainer.encode(failureThreshold, forKey: .failureThreshold)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureThresholdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .failureThreshold)
        failureThreshold = failureThresholdDecoded
    }
}

extension HealthCheckCustomConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HealthCheckCustomConfig(failureThreshold: \(String(describing: failureThreshold)))"}
}

/// <p>A complex type that contains information about an optional custom health check. A custom health check, which
///    requires that you use a third-party health checker to evaluate the health of your resources, is useful in the
///    following circumstances:</p>
///          <ul>
///             <li>
///                <p>You can't use a health check that's defined by <code>HealthCheckConfig</code> because the resource isn't
///      available over the internet. For example, you can use a custom health check when the instance is in an Amazon VPC.
///      (To check the health of resources in a VPC, the health checker must also be in the VPC.)</p>
///             </li>
///             <li>
///                <p>You want to use a third-party health checker regardless of where your resources are located.</p>
///             </li>
///          </ul>
///          <important>
///             <p>If you specify a health check configuration, you can specify either <code>HealthCheckCustomConfig</code> or
///      <code>HealthCheckConfig</code> but not both.</p>
///          </important>
///          <p>To change the status of a custom health check, submit an <code>UpdateInstanceCustomHealthStatus</code> request.
///    AWS Cloud Map doesn't monitor the status of the resource, it just keeps a record of the status specified in the most recent
///     <code>UpdateInstanceCustomHealthStatus</code> request.</p>
///          <p>Here's how custom health checks work:</p>
///          <ol>
///             <li>
///                <p>You create a service.</p>
///             </li>
///             <li>
///                <p>You register an instance.</p>
///             </li>
///             <li>
///                <p>You configure a third-party health checker to monitor the resource that's associated with the new instance. </p>
///                <note>
///                   <p>AWS Cloud Map doesn't check the health of the resource directly. </p>
///                </note>
///             </li>
///             <li>
///                <p>The third-party health-checker determines that the resource is unhealthy and notifies your application.</p>
///             </li>
///             <li>
///                <p>Your application submits an <code>UpdateInstanceCustomHealthStatus</code> request.</p>
///             </li>
///             <li>
///                <p>AWS Cloud Map waits for 30 seconds.</p>
///             </li>
///             <li>
///                <p>If another <code>UpdateInstanceCustomHealthStatus</code> request doesn't arrive during that time to change the
///      status back to healthy, AWS Cloud Map stops routing traffic to the resource.</p>
///             </li>
///          </ol>
public struct HealthCheckCustomConfig: Equatable {
    /// <important>
    ///             <p>This parameter is no longer supported and is always set to 1. AWS Cloud Map waits for approximately 30 seconds after
    ///     receiving an <code>UpdateInstanceCustomHealthStatus</code> request before changing the status of the service
    ///     instance.</p>
    ///          </important>
    ///          <p>The number of 30-second intervals that you want AWS Cloud Map to wait after receiving an
    ///     <code>UpdateInstanceCustomHealthStatus</code> request before it changes the health status of a service
    ///    instance.</p>
    ///          <p>Sending a second or subsequent <code>UpdateInstanceCustomHealthStatus</code> request with the same value before
    ///    30 seconds has passed doesn't accelerate the change. AWS Cloud Map still waits <code>30</code> seconds after the first
    ///    request to make the change.</p>
    @available(*, deprecated, message: "Configurable FailureThreshold of HealthCheckCustomConfig is deprecated.  It will always have value 1.")
    public let failureThreshold: Int?

    public init (
        failureThreshold: Int? = nil
    )
    {
        self.failureThreshold = failureThreshold
    }
}

public enum HealthCheckType {
    case http
    case https
    case tcp
    case sdkUnknown(String)
}

extension HealthCheckType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HealthCheckType] {
        return [
            .http,
            .https,
            .tcp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .http: return "HTTP"
        case .https: return "HTTPS"
        case .tcp: return "TCP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HealthCheckType(rawValue: rawValue) ?? HealthCheckType.sdkUnknown(rawValue)
    }
}

public enum HealthStatus {
    case healthy
    case unhealthy
    case unknown
    case sdkUnknown(String)
}

extension HealthStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HealthStatus] {
        return [
            .healthy,
            .unhealthy,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .healthy: return "HEALTHY"
        case .unhealthy: return "UNHEALTHY"
        case .unknown: return "UNKNOWN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HealthStatus(rawValue: rawValue) ?? HealthStatus.sdkUnknown(rawValue)
    }
}

public enum HealthStatusFilter {
    case all
    case healthy
    case healthyOrElseAll
    case unhealthy
    case sdkUnknown(String)
}

extension HealthStatusFilter : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HealthStatusFilter] {
        return [
            .all,
            .healthy,
            .healthyOrElseAll,
            .unhealthy,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .healthy: return "HEALTHY"
        case .healthyOrElseAll: return "HEALTHY_OR_ELSE_ALL"
        case .unhealthy: return "UNHEALTHY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HealthStatusFilter(rawValue: rawValue) ?? HealthStatusFilter.sdkUnknown(rawValue)
    }
}

extension HttpInstanceSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case healthStatus = "HealthStatus"
        case instanceId = "InstanceId"
        case namespaceName = "NamespaceName"
        case serviceName = "ServiceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let healthStatus = healthStatus {
            try encodeContainer.encode(healthStatus.rawValue, forKey: .healthStatus)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let namespaceName = namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let namespaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let healthStatusDecoded = try containerValues.decodeIfPresent(HealthStatus.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attrvalue0) in attributesContainer {
                if let attrvalue0 = attrvalue0 {
                    attributesDecoded0?[key0] = attrvalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension HttpInstanceSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HttpInstanceSummary(attributes: \(String(describing: attributes)), healthStatus: \(String(describing: healthStatus)), instanceId: \(String(describing: instanceId)), namespaceName: \(String(describing: namespaceName)), serviceName: \(String(describing: serviceName)))"}
}

/// <p>In a response to a <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html">DiscoverInstances</a> request, <code>HttpInstanceSummary</code> contains information about one instance that
///    matches the values that you specified in the request.</p>
public struct HttpInstanceSummary: Equatable {
    /// <p>If you included any attributes when you registered the instance, the values of those attributes.</p>
    public let attributes: [String:String]?
    /// <p>If you configured health checking in the service, the current health status of the service instance.</p>
    public let healthStatus: HealthStatus?
    /// <p>The ID of an instance that matches the values that you specified in the request.</p>
    public let instanceId: String?
    /// <p>
    ///             <code></code>
    ///             <code></code>
    ///             <code></code>
    ///          </p>
    ///          <p>The <code>HttpName</code> name of the namespace. It's found in the <code>HttpProperties</code> member of the
    ///     <code>Properties</code> member of the namespace.</p>
    public let namespaceName: String?
    /// <p>The name of the service that you specified when you registered the instance.</p>
    public let serviceName: String?

    public init (
        attributes: [String:String]? = nil,
        healthStatus: HealthStatus? = nil,
        instanceId: String? = nil,
        namespaceName: String? = nil,
        serviceName: String? = nil
    )
    {
        self.attributes = attributes
        self.healthStatus = healthStatus
        self.instanceId = instanceId
        self.namespaceName = namespaceName
        self.serviceName = serviceName
    }
}

extension HttpProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case httpName = "HttpName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let httpName = httpName {
            try encodeContainer.encode(httpName, forKey: .httpName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .httpName)
        httpName = httpNameDecoded
    }
}

extension HttpProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HttpProperties(httpName: \(String(describing: httpName)))"}
}

/// <p>A complex type that contains the name of an HTTP namespace.</p>
public struct HttpProperties: Equatable {
    /// <p>The name of an HTTP namespace.</p>
    public let httpName: String?

    public init (
        httpName: String? = nil
    )
    {
        self.httpName = httpName
    }
}

extension Instance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case creatorRequestId = "CreatorRequestId"
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attrvalue0) in attributesContainer {
                if let attrvalue0 = attrvalue0 {
                    attributesDecoded0?[key0] = attrvalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension Instance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Instance(attributes: \(String(describing: attributes)), creatorRequestId: \(String(describing: creatorRequestId)), id: \(String(describing: id)))"}
}

/// <p>A complex type that contains information about an instance that AWS Cloud Map creates when you submit a
///     <code>RegisterInstance</code> request.</p>
public struct Instance: Equatable {
    /// <p>A string map that contains the following information for the service that you specify in
    ///    <code>ServiceId</code>:</p>
    ///          <ul>
    ///             <li>
    ///                <p>The attributes that apply to the records that are defined in the service. </p>
    ///             </li>
    ///             <li>
    ///                <p>For each attribute, the applicable value.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Supported attribute keys include the following:</p>
    ///          <dl>
    ///             <dt>AWS_ALIAS_DNS_NAME</dt>
    ///             <dd>
    ///                <p>If you want AWS Cloud Map to create a Route 53 alias record that routes traffic to an Elastic Load Balancing load balancer, specify
    ///       the DNS name that's associated with the load balancer. For information about how to get the DNS name, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_AliasTarget.html#Route53-Type-AliasTarget-DNSName">AliasTarget->DNSName</a> in the <i>Route 53 API Reference</i>.</p>
    ///                <p>Note the following:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>The configuration for the service that's specified by <code>ServiceId</code> must include settings for an
    ///          <code>A</code> record, an <code>AAAA</code> record, or both.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>In the service that's specified by <code>ServiceId</code>, the value of <code>RoutingPolicy</code> must be
    ///          <code>WEIGHTED</code>.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>If the service that's specified by <code>ServiceId</code> includes <code>HealthCheckConfig</code> settings,
    ///         AWS Cloud Map creates the health check, but it won't associate the health check with the alias record.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Auto naming currently doesn't support creating alias records that route traffic to AWS resources other
    ///         than ELB load balancers.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>If you specify a value for <code>AWS_ALIAS_DNS_NAME</code>, don't specify values for any of the
    ///          <code>AWS_INSTANCE</code> attributes.</p>
    ///                   </li>
    ///                </ul>
    ///             </dd>
    ///             <dt>AWS_EC2_INSTANCE_ID</dt>
    ///             <dd>
    ///                <p>
    ///                   <i>HTTP namespaces only.</i> The Amazon EC2 instance ID for the instance. The
    ///        <code>AWS_INSTANCE_IPV4</code> attribute contains the primary private IPv4 address.</p>
    ///             </dd>
    ///             <dt>AWS_INIT_HEALTH_STATUS</dt>
    ///             <dd>
    ///                <p>If the service configuration includes <code>HealthCheckCustomConfig</code>, you can optionally use
    ///        <code>AWS_INIT_HEALTH_STATUS</code> to specify the initial status of the custom health check,
    ///        <code>HEALTHY</code> or <code>UNHEALTHY</code>. If you don't specify a value for
    ///        <code>AWS_INIT_HEALTH_STATUS</code>, the initial status is <code>HEALTHY</code>.</p>
    ///             </dd>
    ///             <dt>AWS_INSTANCE_CNAME</dt>
    ///             <dd>
    ///                <p>If the service configuration includes a <code>CNAME</code> record, the domain name that you want Route 53 to
    ///       return in response to DNS queries (for example, <code>example.com</code>).</p>
    ///                <p>This value is required if the service specified by <code>ServiceId</code> includes settings for an
    ///        <code>CNAME</code> record.</p>
    ///             </dd>
    ///             <dt>AWS_INSTANCE_IPV4</dt>
    ///             <dd>
    ///                <p>If the service configuration includes an <code>A</code> record, the IPv4 address that you want Route 53 to
    ///       return in response to DNS queries (for example, <code>192.0.2.44</code>).</p>
    ///                <p>This value is required if the service specified by <code>ServiceId</code> includes settings for an
    ///        <code>A</code> record. If the service includes settings for an <code>SRV</code> record, you must specify a value
    ///       for <code>AWS_INSTANCE_IPV4</code>, <code>AWS_INSTANCE_IPV6</code>, or both.</p>
    ///             </dd>
    ///             <dt>AWS_INSTANCE_IPV6</dt>
    ///             <dd>
    ///                <p>If the service configuration includes an <code>AAAA</code> record, the IPv6 address that you want Route 53 to
    ///       return in response to DNS queries (for example, <code>2001:0db8:85a3:0000:0000:abcd:0001:2345</code>).</p>
    ///                <p>This value is required if the service specified by <code>ServiceId</code> includes settings for an
    ///        <code>AAAA</code> record. If the service includes settings for an <code>SRV</code> record, you must specify a
    ///       value for <code>AWS_INSTANCE_IPV4</code>, <code>AWS_INSTANCE_IPV6</code>, or both.</p>
    ///             </dd>
    ///             <dt>AWS_INSTANCE_PORT</dt>
    ///             <dd>
    ///                <p>If the service includes an <code>SRV</code> record, the value that you want Route 53 to return for the
    ///       port.</p>
    ///                <p>If the service includes <code>HealthCheckConfig</code>, the port on the endpoint that you want Route 53 to send
    ///       requests to. </p>
    ///                <p>This value is required if you specified settings for an <code>SRV</code> record or a Route 53 health check when
    ///       you created the service.</p>
    ///             </dd>
    ///          </dl>
    public let attributes: [String:String]?
    /// <p>A unique string that identifies the request and that allows failed <code>RegisterInstance</code> requests to be
    ///    retried without the risk of executing the operation twice. You must use a unique <code>CreatorRequestId</code> string
    ///    every time you submit a <code>RegisterInstance</code> request if you're registering additional instances for the same
    ///    namespace and service. <code>CreatorRequestId</code> can be any unique string (for example, a date/time
    ///    stamp).</p>
    public let creatorRequestId: String?
    /// <p>An identifier that you want to associate with the instance. Note the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If the service that's specified by <code>ServiceId</code> includes settings for an <code>SRV</code> record,
    ///      the value of <code>InstanceId</code> is automatically included as part of the value for the <code>SRV</code>
    ///      record. For more information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_DnsRecord.html#cloudmap-Type-DnsRecord-Type">DnsRecord > Type</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>You can use this value to update an existing instance.</p>
    ///             </li>
    ///             <li>
    ///                <p>To register a new instance, you must specify a value that's unique among instances that you register by using
    ///      the same service. </p>
    ///             </li>
    ///             <li>
    ///                <p>If you specify an existing <code>InstanceId</code> and <code>ServiceId</code>, AWS Cloud Map updates the existing
    ///      DNS records. If there's also an existing health check, AWS Cloud Map deletes the old health check and creates a new
    ///      one. </p>
    ///                <note>
    ///                   <p>The health check isn't deleted immediately, so it will still appear for a while if you submit a
    ///        <code>ListHealthChecks</code> request, for example.</p>
    ///                </note>
    ///             </li>
    ///          </ul>
    public let id: String?

    public init (
        attributes: [String:String]? = nil,
        creatorRequestId: String? = nil,
        id: String? = nil
    )
    {
        self.attributes = attributes
        self.creatorRequestId = creatorRequestId
        self.id = id
    }
}

extension InstanceNotFound: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceNotFound(message: \(String(describing: message)))"}
}

extension InstanceNotFound: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InstanceNotFoundBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>No instance exists with the specified ID, or the instance was recently registered, and information about the
///    instance hasn't propagated yet.</p>
public struct InstanceNotFound: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InstanceNotFoundBody: Equatable {
    public let message: String?
}

extension InstanceNotFoundBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InstanceSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attrvalue0) in attributesContainer {
                if let attrvalue0 = attrvalue0 {
                    attributesDecoded0?[key0] = attrvalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension InstanceSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceSummary(attributes: \(String(describing: attributes)), id: \(String(describing: id)))"}
}

/// <p>A complex type that contains information about the instances that you registered by using a specified
///    service.</p>
public struct InstanceSummary: Equatable {
    /// <p>A string map that contains the following information:</p>
    ///          <ul>
    ///             <li>
    ///                <p>The attributes that are associated with the instance. </p>
    ///             </li>
    ///             <li>
    ///                <p>For each attribute, the applicable value.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Supported attribute keys include the following:</p>
    ///          <dl>
    ///             <dt>AWS_ALIAS_DNS_NAME</dt>
    ///             <dd>
    ///                <p>For an alias record that routes traffic to an Elastic Load Balancing load balancer, the DNS name that's associated with the
    ///       load balancer. </p>
    ///             </dd>
    ///             <dt>AWS_EC2_INSTANCE_ID (HTTP namespaces only)</dt>
    ///             <dd>
    ///                <p>The Amazon EC2 instance ID for the instance. When the <code>AWS_EC2_INSTANCE_ID</code> attribute is specified,
    ///       then the <code>AWS_INSTANCE_IPV4</code> attribute contains the primary private IPv4 address.</p>
    ///             </dd>
    ///             <dt>AWS_INIT_HEALTH_STATUS</dt>
    ///             <dd>
    ///                <p>If the service configuration includes <code>HealthCheckCustomConfig</code>, you can optionally use
    ///        <code>AWS_INIT_HEALTH_STATUS</code> to specify the initial status of the custom health check,
    ///        <code>HEALTHY</code> or <code>UNHEALTHY</code>. If you don't specify a value for
    ///        <code>AWS_INIT_HEALTH_STATUS</code>, the initial status is <code>HEALTHY</code>.</p>
    ///             </dd>
    ///             <dt>AWS_INSTANCE_CNAME</dt>
    ///             <dd>
    ///                <p>For a <code>CNAME</code> record, the domain name that Route 53 returns in response to DNS queries (for example,
    ///        <code>example.com</code>).</p>
    ///             </dd>
    ///             <dt>AWS_INSTANCE_IPV4</dt>
    ///             <dd>
    ///                <p>For an <code>A</code> record, the IPv4 address that Route 53 returns in response to DNS queries (for example,
    ///        <code>192.0.2.44</code>).</p>
    ///             </dd>
    ///             <dt>AWS_INSTANCE_IPV6</dt>
    ///             <dd>
    ///                <p>For an <code>AAAA</code> record, the IPv6 address that Route 53 returns in response to DNS queries (for example,
    ///        <code>2001:0db8:85a3:0000:0000:abcd:0001:2345</code>).</p>
    ///             </dd>
    ///             <dt>AWS_INSTANCE_PORT</dt>
    ///             <dd>
    ///                <p>For an <code>SRV</code> record, the value that Route 53 returns for the port. In addition, if the service
    ///       includes <code>HealthCheckConfig</code>, the port on the endpoint that Route 53 sends requests to.</p>
    ///             </dd>
    ///          </dl>
    public let attributes: [String:String]?
    /// <p>The ID for an instance that you created by using a specified service.</p>
    public let id: String?

    public init (
        attributes: [String:String]? = nil,
        id: String? = nil
    )
    {
        self.attributes = attributes
        self.id = id
    }
}

extension InvalidInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidInput(message: \(String(describing: message)))"}
}

extension InvalidInput: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidInputBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more specified values aren't valid. For example, a required value might be missing, a numeric value might
///    be outside the allowed range, or a string value might exceed length constraints.</p>
public struct InvalidInput: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputBody: Equatable {
    public let message: String?
}

extension InvalidInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListInstancesInputBodyMiddleware: Middleware {
    public let id: String = "ListInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstancesInput>
    public typealias MOutput = OperationOutput<ListInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstancesOutputError>
}

extension ListInstancesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInstancesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), serviceId: \(String(describing: serviceId)))"}
}

extension ListInstancesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceId = "ServiceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
    }
}

public struct ListInstancesInputHeadersMiddleware: Middleware {
    public let id: String = "ListInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstancesInput>
    public typealias MOutput = OperationOutput<ListInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstancesOutputError>
}

public struct ListInstancesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstancesInput>
    public typealias MOutput = OperationOutput<ListInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstancesOutputError>
}

public struct ListInstancesInput: Equatable {
    /// <p>The maximum number of instances that you want AWS Cloud Map to return in the response to a
    ///     <code>ListInstances</code> request. If you don't specify a value for <code>MaxResults</code>, AWS Cloud Map returns up
    ///    to 100 instances.</p>
    public let maxResults: Int?
    /// <p>For the first <code>ListInstances</code> request, omit this value.</p>
    ///          <p>If more than <code>MaxResults</code> instances match the specified criteria, you can submit another
    ///     <code>ListInstances</code> request to get the next group of results. Specify the value of <code>NextToken</code>
    ///    from the previous response in the next request.</p>
    public let nextToken: String?
    /// <p>The ID of the service that you want to list instances for.</p>
    public let serviceId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        serviceId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceId = serviceId
    }
}

struct ListInstancesInputBody: Equatable {
    public let serviceId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListInstancesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceId = "ServiceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListInstancesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInstancesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInstancesOutputError: Equatable {
    case invalidInput(InvalidInput)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInstancesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInstancesOutputResponse(instances: \(String(describing: instances)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInstancesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListInstancesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instances = output.instances
            self.nextToken = output.nextToken
        } else {
            self.instances = nil
            self.nextToken = nil
        }
    }
}

public struct ListInstancesOutputResponse: Equatable {
    /// <p>Summary information about the instances that are associated with the specified service.</p>
    public let instances: [InstanceSummary]?
    /// <p>If more than <code>MaxResults</code> instances match the specified criteria, you can submit another
    ///     <code>ListInstances</code> request to get the next group of results. Specify the value of <code>NextToken</code>
    ///    from the previous response in the next request.</p>
    public let nextToken: String?

    public init (
        instances: [InstanceSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.instances = instances
        self.nextToken = nextToken
    }
}

struct ListInstancesOutputResponseBody: Equatable {
    public let instances: [InstanceSummary]?
    public let nextToken: String?
}

extension ListInstancesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instances = "Instances"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancesContainer = try containerValues.decodeIfPresent([InstanceSummary?].self, forKey: .instances)
        var instancesDecoded0:[InstanceSummary]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [InstanceSummary]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListNamespacesInputBodyMiddleware: Middleware {
    public let id: String = "ListNamespacesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListNamespacesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListNamespacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListNamespacesInput>
    public typealias MOutput = OperationOutput<ListNamespacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListNamespacesOutputError>
}

extension ListNamespacesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListNamespacesInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListNamespacesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for namespacefilters0 in filters {
                try filtersContainer.encode(namespacefilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListNamespacesInputHeadersMiddleware: Middleware {
    public let id: String = "ListNamespacesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListNamespacesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListNamespacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListNamespacesInput>
    public typealias MOutput = OperationOutput<ListNamespacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListNamespacesOutputError>
}

public struct ListNamespacesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListNamespacesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListNamespacesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListNamespacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListNamespacesInput>
    public typealias MOutput = OperationOutput<ListNamespacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListNamespacesOutputError>
}

public struct ListNamespacesInput: Equatable {
    /// <p>A complex type that contains specifications for the namespaces that you want to list.</p>
    ///          <p>If you specify more than one filter, a namespace must match all filters to be returned by
    ///     <code>ListNamespaces</code>.</p>
    public let filters: [NamespaceFilter]?
    /// <p>The maximum number of namespaces that you want AWS Cloud Map to return in the response to a
    ///     <code>ListNamespaces</code> request. If you don't specify a value for <code>MaxResults</code>, AWS Cloud Map returns up
    ///    to 100 namespaces.</p>
    public let maxResults: Int?
    /// <p>For the first <code>ListNamespaces</code> request, omit this value.</p>
    ///          <p>If the response contains <code>NextToken</code>, submit another <code>ListNamespaces</code> request to get the
    ///    next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
    ///    request.</p>
    ///          <note>
    ///             <p>AWS Cloud Map gets <code>MaxResults</code> namespaces and then filters them based on the specified criteria. It's
    ///     possible that no namespaces in the first <code>MaxResults</code> namespaces matched the specified criteria but that
    ///     subsequent groups of <code>MaxResults</code> namespaces do contain namespaces that match the criteria.</p>
    ///          </note>
    public let nextToken: String?

    public init (
        filters: [NamespaceFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListNamespacesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [NamespaceFilter]?
}

extension ListNamespacesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([NamespaceFilter?].self, forKey: .filters)
        var filtersDecoded0:[NamespaceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [NamespaceFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListNamespacesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNamespacesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListNamespacesOutputError: Equatable {
    case invalidInput(InvalidInput)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNamespacesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListNamespacesOutputResponse(namespaces: \(String(describing: namespaces)), nextToken: \(String(describing: nextToken)))"}
}

extension ListNamespacesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListNamespacesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.namespaces = output.namespaces
            self.nextToken = output.nextToken
        } else {
            self.namespaces = nil
            self.nextToken = nil
        }
    }
}

public struct ListNamespacesOutputResponse: Equatable {
    /// <p>An array that contains one <code>NamespaceSummary</code> object for each namespace that matches the specified
    ///    filter criteria.</p>
    public let namespaces: [NamespaceSummary]?
    /// <p>If the response contains <code>NextToken</code>, submit another <code>ListNamespaces</code> request to get the
    ///    next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
    ///    request.</p>
    ///          <note>
    ///             <p>AWS Cloud Map gets <code>MaxResults</code> namespaces and then filters them based on the specified criteria. It's
    ///     possible that no namespaces in the first <code>MaxResults</code> namespaces matched the specified criteria but that
    ///     subsequent groups of <code>MaxResults</code> namespaces do contain namespaces that match the criteria.</p>
    ///          </note>
    public let nextToken: String?

    public init (
        namespaces: [NamespaceSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.namespaces = namespaces
        self.nextToken = nextToken
    }
}

struct ListNamespacesOutputResponseBody: Equatable {
    public let namespaces: [NamespaceSummary]?
    public let nextToken: String?
}

extension ListNamespacesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case namespaces = "Namespaces"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespacesContainer = try containerValues.decodeIfPresent([NamespaceSummary?].self, forKey: .namespaces)
        var namespacesDecoded0:[NamespaceSummary]? = nil
        if let namespacesContainer = namespacesContainer {
            namespacesDecoded0 = [NamespaceSummary]()
            for structure0 in namespacesContainer {
                if let structure0 = structure0 {
                    namespacesDecoded0?.append(structure0)
                }
            }
        }
        namespaces = namespacesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListOperationsInputBodyMiddleware: Middleware {
    public let id: String = "ListOperationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOperationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOperationsInput>
    public typealias MOutput = OperationOutput<ListOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOperationsOutputError>
}

extension ListOperationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOperationsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListOperationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for operationfilters0 in filters {
                try filtersContainer.encode(operationfilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListOperationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListOperationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOperationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOperationsInput>
    public typealias MOutput = OperationOutput<ListOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOperationsOutputError>
}

public struct ListOperationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListOperationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOperationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOperationsInput>
    public typealias MOutput = OperationOutput<ListOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOperationsOutputError>
}

public struct ListOperationsInput: Equatable {
    /// <p>A complex type that contains specifications for the operations that you want to list, for example, operations
    ///    that you started between a specified start date and end date.</p>
    ///          <p>If you specify more than one filter, an operation must match all filters to be returned by
    ///     <code>ListOperations</code>.</p>
    public let filters: [OperationFilter]?
    /// <p>The maximum number of items that you want AWS Cloud Map to return in the response to a <code>ListOperations</code>
    ///    request. If you don't specify a value for <code>MaxResults</code>, AWS Cloud Map returns up to 100 operations.</p>
    public let maxResults: Int?
    /// <p>For the first <code>ListOperations</code> request, omit this value.</p>
    ///          <p>If the response contains <code>NextToken</code>, submit another <code>ListOperations</code> request to get the
    ///    next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
    ///    request.</p>
    ///          <note>
    ///             <p>AWS Cloud Map gets <code>MaxResults</code> operations and then filters them based on the specified criteria. It's
    ///     possible that no operations in the first <code>MaxResults</code> operations matched the specified criteria but that
    ///     subsequent groups of <code>MaxResults</code> operations do contain operations that match the criteria.</p>
    ///          </note>
    public let nextToken: String?

    public init (
        filters: [OperationFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOperationsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [OperationFilter]?
}

extension ListOperationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([OperationFilter?].self, forKey: .filters)
        var filtersDecoded0:[OperationFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [OperationFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListOperationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOperationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOperationsOutputError: Equatable {
    case invalidInput(InvalidInput)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOperationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOperationsOutputResponse(nextToken: \(String(describing: nextToken)), operations: \(String(describing: operations)))"}
}

extension ListOperationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListOperationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.operations = output.operations
        } else {
            self.nextToken = nil
            self.operations = nil
        }
    }
}

public struct ListOperationsOutputResponse: Equatable {
    /// <p>If the response contains <code>NextToken</code>, submit another <code>ListOperations</code> request to get the
    ///    next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
    ///    request.</p>
    ///          <note>
    ///             <p>AWS Cloud Map gets <code>MaxResults</code> operations and then filters them based on the specified criteria. It's
    ///     possible that no operations in the first <code>MaxResults</code> operations matched the specified criteria but that
    ///     subsequent groups of <code>MaxResults</code> operations do contain operations that match the criteria.</p>
    ///          </note>
    public let nextToken: String?
    /// <p>Summary information about the operations that match the specified criteria.</p>
    public let operations: [OperationSummary]?

    public init (
        nextToken: String? = nil,
        operations: [OperationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.operations = operations
    }
}

struct ListOperationsOutputResponseBody: Equatable {
    public let operations: [OperationSummary]?
    public let nextToken: String?
}

extension ListOperationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case operations = "Operations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationsContainer = try containerValues.decodeIfPresent([OperationSummary?].self, forKey: .operations)
        var operationsDecoded0:[OperationSummary]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [OperationSummary]()
            for structure0 in operationsContainer {
                if let structure0 = structure0 {
                    operationsDecoded0?.append(structure0)
                }
            }
        }
        operations = operationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListServicesInputBodyMiddleware: Middleware {
    public let id: String = "ListServicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServicesInput>
    public typealias MOutput = OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServicesOutputError>
}

extension ListServicesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServicesInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListServicesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for servicefilters0 in filters {
                try filtersContainer.encode(servicefilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListServicesInputHeadersMiddleware: Middleware {
    public let id: String = "ListServicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServicesInput>
    public typealias MOutput = OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServicesOutputError>
}

public struct ListServicesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListServicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServicesInput>
    public typealias MOutput = OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServicesOutputError>
}

public struct ListServicesInput: Equatable {
    /// <p>A complex type that contains specifications for the namespaces that you want to list services for. </p>
    ///          <p>If you specify more than one filter, an operation must match all filters to be returned by
    ///     <code>ListServices</code>.</p>
    public let filters: [ServiceFilter]?
    /// <p>The maximum number of services that you want AWS Cloud Map to return in the response to a <code>ListServices</code>
    ///    request. If you don't specify a value for <code>MaxResults</code>, AWS Cloud Map returns up to 100 services.</p>
    public let maxResults: Int?
    /// <p>For the first <code>ListServices</code> request, omit this value.</p>
    ///          <p>If the response contains <code>NextToken</code>, submit another <code>ListServices</code> request to get the
    ///    next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
    ///    request.</p>
    ///          <note>
    ///             <p>AWS Cloud Map gets <code>MaxResults</code> services and then filters them based on the specified criteria. It's
    ///     possible that no services in the first <code>MaxResults</code> services matched the specified criteria but that
    ///     subsequent groups of <code>MaxResults</code> services do contain services that match the criteria.</p>
    ///          </note>
    public let nextToken: String?

    public init (
        filters: [ServiceFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServicesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [ServiceFilter]?
}

extension ListServicesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ServiceFilter?].self, forKey: .filters)
        var filtersDecoded0:[ServiceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ServiceFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListServicesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServicesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServicesOutputError: Equatable {
    case invalidInput(InvalidInput)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServicesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServicesOutputResponse(nextToken: \(String(describing: nextToken)), services: \(String(describing: services)))"}
}

extension ListServicesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListServicesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.services = output.services
        } else {
            self.nextToken = nil
            self.services = nil
        }
    }
}

public struct ListServicesOutputResponse: Equatable {
    /// <p>If the response contains <code>NextToken</code>, submit another <code>ListServices</code> request to get the
    ///    next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
    ///    request.</p>
    ///          <note>
    ///             <p>AWS Cloud Map gets <code>MaxResults</code> services and then filters them based on the specified criteria. It's
    ///     possible that no services in the first <code>MaxResults</code> services matched the specified criteria but that
    ///     subsequent groups of <code>MaxResults</code> services do contain services that match the criteria.</p>
    ///          </note>
    public let nextToken: String?
    /// <p>An array that contains one <code>ServiceSummary</code> object for each service that matches the specified filter
    ///    criteria.</p>
    public let services: [ServiceSummary]?

    public init (
        nextToken: String? = nil,
        services: [ServiceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.services = services
    }
}

struct ListServicesOutputResponseBody: Equatable {
    public let services: [ServiceSummary]?
    public let nextToken: String?
}

extension ListServicesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case services = "Services"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let servicesContainer = try containerValues.decodeIfPresent([ServiceSummary?].self, forKey: .services)
        var servicesDecoded0:[ServiceSummary]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [ServiceSummary]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceARN: \(String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.</p>
    public let resourceARN: String?

    public init (
        resourceARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceARN: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case invalidInput(InvalidInput)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags that are assigned to the resource.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Namespace: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case properties = "Properties"
        case serviceCount = "ServiceCount"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
        if let serviceCount = serviceCount {
            try encodeContainer.encode(serviceCount, forKey: .serviceCount)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(NamespaceType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let serviceCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .serviceCount)
        serviceCount = serviceCountDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(NamespaceProperties.self, forKey: .properties)
        properties = propertiesDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createDate)
        createDate = createDateDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
    }
}

extension Namespace: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Namespace(arn: \(String(describing: arn)), createDate: \(String(describing: createDate)), creatorRequestId: \(String(describing: creatorRequestId)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), properties: \(String(describing: properties)), serviceCount: \(String(describing: serviceCount)), type: \(String(describing: type)))"}
}

/// <p>A complex type that contains information about a specified namespace.</p>
public struct Namespace: Equatable {
    /// <p>The Amazon Resource Name (ARN) that AWS Cloud Map assigns to the namespace when you create it.</p>
    public let arn: String?
    /// <p>The date that the namespace was created, in Unix date/time format and Coordinated Universal Time (UTC). The
    ///    value of <code>CreateDate</code> is accurate to milliseconds. For example, the value <code>1516925490.087</code>
    ///    represents Friday, January 26, 2018 12:11:30.087 AM.</p>
    public let createDate: Date?
    /// <p>A unique string that identifies the request and that allows failed requests to be retried without the risk of
    ///    running an operation twice. </p>
    public let creatorRequestId: String?
    /// <p>The description that you specify for the namespace when you create it.</p>
    public let description: String?
    /// <p>The ID of a namespace.</p>
    public let id: String?
    /// <p>The name of the namespace, such as <code>example.com</code>.</p>
    public let name: String?
    /// <p>A complex type that contains information that's specific to the type of the namespace.</p>
    public let properties: NamespaceProperties?
    /// <p>The number of services that are associated with the namespace.</p>
    public let serviceCount: Int?
    /// <p>The type of the namespace. The methods for discovering instances depends on the value that you specify:</p>
    ///          <dl>
    ///             <dt>HTTP</dt>
    ///             <dd>
    ///                <p>Instances can be discovered only programmatically, using the AWS Cloud Map <code>DiscoverInstances</code>
    ///       API.</p>
    ///             </dd>
    ///             <dt>DNS_PUBLIC</dt>
    ///             <dd>
    ///                <p>Instances can be discovered using public DNS queries and using the <code>DiscoverInstances</code> API.</p>
    ///             </dd>
    ///             <dt>DNS_PRIVATE</dt>
    ///             <dd>
    ///                <p>Instances can be discovered using DNS queries in VPCs and using the <code>DiscoverInstances</code>
    ///       API.</p>
    ///             </dd>
    ///          </dl>
    public let type: NamespaceType?

    public init (
        arn: String? = nil,
        createDate: Date? = nil,
        creatorRequestId: String? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        properties: NamespaceProperties? = nil,
        serviceCount: Int? = nil,
        type: NamespaceType? = nil
    )
    {
        self.arn = arn
        self.createDate = createDate
        self.creatorRequestId = creatorRequestId
        self.description = description
        self.id = id
        self.name = name
        self.properties = properties
        self.serviceCount = serviceCount
        self.type = type
    }
}

extension NamespaceAlreadyExists: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NamespaceAlreadyExists(creatorRequestId: \(String(describing: creatorRequestId)), message: \(String(describing: message)), namespaceId: \(String(describing: namespaceId)))"}
}

extension NamespaceAlreadyExists: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NamespaceAlreadyExistsBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creatorRequestId = output.creatorRequestId
            self.message = output.message
            self.namespaceId = output.namespaceId
        } else {
            self.creatorRequestId = nil
            self.message = nil
            self.namespaceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The namespace that you're trying to create already exists.</p>
public struct NamespaceAlreadyExists: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The <code>CreatorRequestId</code> that was used to create the namespace.</p>
    public var creatorRequestId: String?
    public var message: String?
    /// <p>The ID of the existing namespace.</p>
    public var namespaceId: String?

    public init (
        creatorRequestId: String? = nil,
        message: String? = nil,
        namespaceId: String? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.message = message
        self.namespaceId = namespaceId
    }
}

struct NamespaceAlreadyExistsBody: Equatable {
    public let message: String?
    public let creatorRequestId: String?
    public let namespaceId: String?
}

extension NamespaceAlreadyExistsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case message = "Message"
        case namespaceId = "NamespaceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let namespaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespaceId)
        namespaceId = namespaceIdDecoded
    }
}

extension NamespaceFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case condition = "Condition"
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = condition {
            try encodeContainer.encode(condition.rawValue, forKey: .condition)
        }
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(NamespaceFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let conditionDecoded = try containerValues.decodeIfPresent(FilterCondition.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension NamespaceFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NamespaceFilter(condition: \(String(describing: condition)), name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>A complex type that identifies the namespaces that you want to list. You can choose to list public or private
///    namespaces.</p>
public struct NamespaceFilter: Equatable {
    /// <p>The operator that you want to use to determine whether <code>ListNamespaces</code> returns a namespace. Valid
    ///    values for <code>condition</code> include:</p>
    ///          <dl>
    ///             <dt>EQ</dt>
    ///             <dd>
    ///                <p>When you specify <code>EQ</code> for the condition, you can choose to list only public namespaces or private
    ///       namespaces, but not both. <code>EQ</code> is the default condition and can be omitted.</p>
    ///             </dd>
    ///             <dt>IN</dt>
    ///             <dd>
    ///                <p>When you specify <code>IN</code> for the condition, you can choose to list public namespaces, private
    ///       namespaces, or both. </p>
    ///             </dd>
    ///             <dt>BETWEEN</dt>
    ///             <dd>
    ///                <p> Not applicable</p>
    ///             </dd>
    ///          </dl>
    public let condition: FilterCondition?
    /// <p>Specify <code>TYPE</code>.</p>
    public let name: NamespaceFilterName?
    /// <p>If you specify <code>EQ</code> for <code>Condition</code>, specify either <code>DNS_PUBLIC</code> or
    ///     <code>DNS_PRIVATE</code>.</p>
    ///          <p>If you specify <code>IN</code> for <code>Condition</code>, you can specify <code>DNS_PUBLIC</code>,
    ///     <code>DNS_PRIVATE</code>, or both.</p>
    public let values: [String]?

    public init (
        condition: FilterCondition? = nil,
        name: NamespaceFilterName? = nil,
        values: [String]? = nil
    )
    {
        self.condition = condition
        self.name = name
        self.values = values
    }
}

public enum NamespaceFilterName {
    case type
    case sdkUnknown(String)
}

extension NamespaceFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NamespaceFilterName] {
        return [
            .type,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .type: return "TYPE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NamespaceFilterName(rawValue: rawValue) ?? NamespaceFilterName.sdkUnknown(rawValue)
    }
}

extension NamespaceNotFound: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NamespaceNotFound(message: \(String(describing: message)))"}
}

extension NamespaceNotFound: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NamespaceNotFoundBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>No namespace exists with the specified ID.</p>
public struct NamespaceNotFound: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NamespaceNotFoundBody: Equatable {
    public let message: String?
}

extension NamespaceNotFoundBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NamespaceProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dnsProperties = "DnsProperties"
        case httpProperties = "HttpProperties"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsProperties = dnsProperties {
            try encodeContainer.encode(dnsProperties, forKey: .dnsProperties)
        }
        if let httpProperties = httpProperties {
            try encodeContainer.encode(httpProperties, forKey: .httpProperties)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dnsPropertiesDecoded = try containerValues.decodeIfPresent(DnsProperties.self, forKey: .dnsProperties)
        dnsProperties = dnsPropertiesDecoded
        let httpPropertiesDecoded = try containerValues.decodeIfPresent(HttpProperties.self, forKey: .httpProperties)
        httpProperties = httpPropertiesDecoded
    }
}

extension NamespaceProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NamespaceProperties(dnsProperties: \(String(describing: dnsProperties)), httpProperties: \(String(describing: httpProperties)))"}
}

/// <p>A complex type that contains information that's specific to the namespace type.</p>
public struct NamespaceProperties: Equatable {
    /// <p>A complex type that contains the ID for the Route 53 hosted zone that AWS Cloud Map creates when you create a
    ///    namespace.</p>
    public let dnsProperties: DnsProperties?
    /// <p>A complex type that contains the name of an HTTP namespace.</p>
    public let httpProperties: HttpProperties?

    public init (
        dnsProperties: DnsProperties? = nil,
        httpProperties: HttpProperties? = nil
    )
    {
        self.dnsProperties = dnsProperties
        self.httpProperties = httpProperties
    }
}

extension NamespaceSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case properties = "Properties"
        case serviceCount = "ServiceCount"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
        if let serviceCount = serviceCount {
            try encodeContainer.encode(serviceCount, forKey: .serviceCount)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(NamespaceType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let serviceCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .serviceCount)
        serviceCount = serviceCountDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(NamespaceProperties.self, forKey: .properties)
        properties = propertiesDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createDate)
        createDate = createDateDecoded
    }
}

extension NamespaceSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NamespaceSummary(arn: \(String(describing: arn)), createDate: \(String(describing: createDate)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), properties: \(String(describing: properties)), serviceCount: \(String(describing: serviceCount)), type: \(String(describing: type)))"}
}

/// <p>A complex type that contains information about a namespace.</p>
public struct NamespaceSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) that AWS Cloud Map assigns to the namespace when you create it.</p>
    public let arn: String?
    /// <p>The date and time that the namespace was created.</p>
    public let createDate: Date?
    /// <p>A description for the namespace.</p>
    public let description: String?
    /// <p>The ID of the namespace.</p>
    public let id: String?
    /// <p>The name of the namespace. When you create a namespace, AWS Cloud Map automatically creates a Route 53 hosted zone
    ///    that has the same name as the namespace.</p>
    public let name: String?
    /// <p>The properties of the namespace.</p>
    public let properties: NamespaceProperties?
    /// <p>The number of services that were created using the namespace.</p>
    public let serviceCount: Int?
    /// <p>The type of the namespace, either public or private.</p>
    public let type: NamespaceType?

    public init (
        arn: String? = nil,
        createDate: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        properties: NamespaceProperties? = nil,
        serviceCount: Int? = nil,
        type: NamespaceType? = nil
    )
    {
        self.arn = arn
        self.createDate = createDate
        self.description = description
        self.id = id
        self.name = name
        self.properties = properties
        self.serviceCount = serviceCount
        self.type = type
    }
}

public enum NamespaceType {
    case dnsPrivate
    case dnsPublic
    case http
    case sdkUnknown(String)
}

extension NamespaceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NamespaceType] {
        return [
            .dnsPrivate,
            .dnsPublic,
            .http,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dnsPrivate: return "DNS_PRIVATE"
        case .dnsPublic: return "DNS_PUBLIC"
        case .http: return "HTTP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NamespaceType(rawValue: rawValue) ?? NamespaceType.sdkUnknown(rawValue)
    }
}

extension Operation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createDate = "CreateDate"
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case id = "Id"
        case status = "Status"
        case targets = "Targets"
        case type = "Type"
        case updateDate = "UpdateDate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .targets)
            for (dictKey0, operationtargetsmap0) in targets {
                try targetsContainer.encode(operationtargetsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updateDate = updateDate {
            try encodeContainer.encode(updateDate.timeIntervalSince1970, forKey: .updateDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OperationType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OperationStatus.self, forKey: .status)
        status = statusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createDate)
        createDate = createDateDecoded
        let updateDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updateDate)
        updateDate = updateDateDecoded
        let targetsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .targets)
        var targetsDecoded0: [String:String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [String:String]()
            for (key0, resourceid0) in targetsContainer {
                if let resourceid0 = resourceid0 {
                    targetsDecoded0?[key0] = resourceid0
                }
            }
        }
        targets = targetsDecoded0
    }
}

extension Operation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Operation(createDate: \(String(describing: createDate)), errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), id: \(String(describing: id)), status: \(String(describing: status)), targets: \(String(describing: targets)), type: \(String(describing: type)), updateDate: \(String(describing: updateDate)))"}
}

/// <p>A complex type that contains information about a specified operation.</p>
public struct Operation: Equatable {
    /// <p>The date and time that the request was submitted, in Unix date/time format and Coordinated Universal Time (UTC).
    ///    The value of <code>CreateDate</code> is accurate to milliseconds. For example, the value <code>1516925490.087</code>
    ///    represents Friday, January 26, 2018 12:11:30.087 AM.</p>
    public let createDate: Date?
    /// <p>The code associated with <code>ErrorMessage</code>. Values for <code>ErrorCode</code> include the
    ///    following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ACCESS_DENIED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CANNOT_CREATE_HOSTED_ZONE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>EXPIRED_TOKEN</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>HOSTED_ZONE_NOT_FOUND</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INTERNAL_FAILURE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INVALID_CHANGE_BATCH</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>THROTTLED_REQUEST</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let errorCode: String?
    /// <p>If the value of <code>Status</code> is <code>FAIL</code>, the reason that the operation failed.</p>
    public let errorMessage: String?
    /// <p>The ID of the operation that you want to get information about.</p>
    public let id: String?
    /// <p>The status of the operation. Values include the following:</p>
    ///          <dl>
    ///             <dt>SUBMITTED</dt>
    ///             <dd>
    ///                <p>This is the initial state that occurs immediately after you submit a request.</p>
    ///             </dd>
    ///             <dt>PENDING</dt>
    ///             <dd>
    ///                <p>AWS Cloud Map is performing the operation.</p>
    ///             </dd>
    ///             <dt>SUCCESS</dt>
    ///             <dd>
    ///                <p>The operation succeeded.</p>
    ///             </dd>
    ///             <dt>FAIL</dt>
    ///             <dd>
    ///                <p>The operation failed. For the failure reason, see <code>ErrorMessage</code>.</p>
    ///             </dd>
    ///          </dl>
    public let status: OperationStatus?
    /// <p>The name of the target entity that's associated with the operation:</p>
    ///          <dl>
    ///             <dt>NAMESPACE</dt>
    ///             <dd>
    ///                <p>The namespace ID is returned in the <code>ResourceId</code> property.</p>
    ///             </dd>
    ///             <dt>SERVICE</dt>
    ///             <dd>
    ///                <p>The service ID is returned in the <code>ResourceId</code> property.</p>
    ///             </dd>
    ///             <dt>INSTANCE</dt>
    ///             <dd>
    ///                <p>The instance ID is returned in the <code>ResourceId</code> property.</p>
    ///             </dd>
    ///          </dl>
    public let targets: [String:String]?
    /// <p>The name of the operation that's associated with the specified ID.</p>
    public let type: OperationType?
    /// <p>The date and time that the value of <code>Status</code> changed to the current value, in Unix date/time format
    ///    and Coordinated Universal Time (UTC). The value of <code>UpdateDate</code> is accurate to milliseconds. For example,
    ///    the value <code>1516925490.087</code> represents Friday, January 26, 2018 12:11:30.087 AM.</p>
    public let updateDate: Date?

    public init (
        createDate: Date? = nil,
        errorCode: String? = nil,
        errorMessage: String? = nil,
        id: String? = nil,
        status: OperationStatus? = nil,
        targets: [String:String]? = nil,
        type: OperationType? = nil,
        updateDate: Date? = nil
    )
    {
        self.createDate = createDate
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.id = id
        self.status = status
        self.targets = targets
        self.type = type
        self.updateDate = updateDate
    }
}

extension OperationFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case condition = "Condition"
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = condition {
            try encodeContainer.encode(condition.rawValue, forKey: .condition)
        }
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(OperationFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let conditionDecoded = try containerValues.decodeIfPresent(FilterCondition.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension OperationFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperationFilter(condition: \(String(describing: condition)), name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>A complex type that lets you select the operations that you want to list.</p>
public struct OperationFilter: Equatable {
    /// <p>The operator that you want to use to determine whether an operation matches the specified value. Valid values
    ///    for condition include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>EQ</code>: When you specify <code>EQ</code> for the condition, you can specify only one value.
    ///       <code>EQ</code> is supported for <code>NAMESPACE_ID</code>, <code>SERVICE_ID</code>, <code>STATUS</code>, and
    ///       <code>TYPE</code>. <code>EQ</code> is the default condition and can be omitted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IN</code>: When you specify <code>IN</code> for the condition, you can specify a list of one or more
    ///      values. <code>IN</code> is supported for <code>STATUS</code> and <code>TYPE</code>. An operation must match one of
    ///      the specified values to be returned in the response.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>BETWEEN</code>: Specify a start date and an end date in Unix date/time format and Coordinated Universal
    ///      Time (UTC). The start date must be the first value. <code>BETWEEN</code> is supported for <code>UPDATE_DATE</code>.
    ///     </p>
    ///             </li>
    ///          </ul>
    public let condition: FilterCondition?
    /// <p>Specify the operations that you want to get:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>NAMESPACE_ID</b>: Gets operations related to specified namespaces.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>SERVICE_ID</b>: Gets operations related to specified services.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>STATUS</b>: Gets operations based on the status of the operations:
    ///       <code>SUBMITTED</code>, <code>PENDING</code>, <code>SUCCEED</code>, or <code>FAIL</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>TYPE</b>: Gets specified types of operation.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>UPDATE_DATE</b>: Gets operations that changed status during a specified date/time
    ///      range. </p>
    ///             </li>
    ///          </ul>
    public let name: OperationFilterName?
    /// <p>Specify values that are applicable to the value that you specify for <code>Name</code>: </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>NAMESPACE_ID</b>: Specify one namespace ID.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>SERVICE_ID</b>: Specify one service ID.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>STATUS</b>: Specify one or more statuses: <code>SUBMITTED</code>,
    ///       <code>PENDING</code>, <code>SUCCEED</code>, or <code>FAIL</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>TYPE</b>: Specify one or more of the following types:
    ///       <code>CREATE_NAMESPACE</code>, <code>DELETE_NAMESPACE</code>, <code>UPDATE_SERVICE</code>,
    ///       <code>REGISTER_INSTANCE</code>, or <code>DEREGISTER_INSTANCE</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>UPDATE_DATE</b>: Specify a start date and an end date in Unix date/time format
    ///      and Coordinated Universal Time (UTC). The start date must be the first value.</p>
    ///             </li>
    ///          </ul>
    public let values: [String]?

    public init (
        condition: FilterCondition? = nil,
        name: OperationFilterName? = nil,
        values: [String]? = nil
    )
    {
        self.condition = condition
        self.name = name
        self.values = values
    }
}

public enum OperationFilterName {
    case namespaceId
    case serviceId
    case status
    case type
    case updateDate
    case sdkUnknown(String)
}

extension OperationFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OperationFilterName] {
        return [
            .namespaceId,
            .serviceId,
            .status,
            .type,
            .updateDate,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .namespaceId: return "NAMESPACE_ID"
        case .serviceId: return "SERVICE_ID"
        case .status: return "STATUS"
        case .type: return "TYPE"
        case .updateDate: return "UPDATE_DATE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OperationFilterName(rawValue: rawValue) ?? OperationFilterName.sdkUnknown(rawValue)
    }
}

extension OperationNotFound: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperationNotFound(message: \(String(describing: message)))"}
}

extension OperationNotFound: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OperationNotFoundBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>No operation exists with the specified ID.</p>
public struct OperationNotFound: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotFoundBody: Equatable {
    public let message: String?
}

extension OperationNotFoundBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum OperationStatus {
    case fail
    case pending
    case submitted
    case success
    case sdkUnknown(String)
}

extension OperationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OperationStatus] {
        return [
            .fail,
            .pending,
            .submitted,
            .success,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fail: return "FAIL"
        case .pending: return "PENDING"
        case .submitted: return "SUBMITTED"
        case .success: return "SUCCESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OperationStatus(rawValue: rawValue) ?? OperationStatus.sdkUnknown(rawValue)
    }
}

extension OperationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OperationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OperationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperationSummary(id: \(String(describing: id)), status: \(String(describing: status)))"}
}

/// <p>A complex type that contains information about an operation that matches the criteria that you specified in a
///     <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_ListOperations.html">ListOperations</a>
///    request.</p>
public struct OperationSummary: Equatable {
    /// <p>The ID for an operation.</p>
    public let id: String?
    /// <p>The status of the operation. Values include the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>SUBMITTED</b>: This is the initial state immediately after you submit a
    ///      request.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>PENDING</b>: AWS Cloud Map is performing the operation.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>SUCCESS</b>: The operation succeeded.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>FAIL</b>: The operation failed. For the failure reason, see
    ///       <code>ErrorMessage</code>.</p>
    ///             </li>
    ///          </ul>
    public let status: OperationStatus?

    public init (
        id: String? = nil,
        status: OperationStatus? = nil
    )
    {
        self.id = id
        self.status = status
    }
}

public enum OperationTargetType {
    case instance
    case namespace
    case service
    case sdkUnknown(String)
}

extension OperationTargetType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OperationTargetType] {
        return [
            .instance,
            .namespace,
            .service,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .instance: return "INSTANCE"
        case .namespace: return "NAMESPACE"
        case .service: return "SERVICE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OperationTargetType(rawValue: rawValue) ?? OperationTargetType.sdkUnknown(rawValue)
    }
}

public enum OperationType {
    case createNamespace
    case deleteNamespace
    case deregisterInstance
    case registerInstance
    case updateService
    case sdkUnknown(String)
}

extension OperationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OperationType] {
        return [
            .createNamespace,
            .deleteNamespace,
            .deregisterInstance,
            .registerInstance,
            .updateService,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createNamespace: return "CREATE_NAMESPACE"
        case .deleteNamespace: return "DELETE_NAMESPACE"
        case .deregisterInstance: return "DEREGISTER_INSTANCE"
        case .registerInstance: return "REGISTER_INSTANCE"
        case .updateService: return "UPDATE_SERVICE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OperationType(rawValue: rawValue) ?? OperationType.sdkUnknown(rawValue)
    }
}

public enum RecordType {
    case a
    case aaaa
    case cname
    case srv
    case sdkUnknown(String)
}

extension RecordType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RecordType] {
        return [
            .a,
            .aaaa,
            .cname,
            .srv,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .a: return "A"
        case .aaaa: return "AAAA"
        case .cname: return "CNAME"
        case .srv: return "SRV"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RecordType(rawValue: rawValue) ?? RecordType.sdkUnknown(rawValue)
    }
}

public struct RegisterInstanceInputBodyMiddleware: Middleware {
    public let id: String = "RegisterInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterInstanceInput>
    public typealias MOutput = OperationOutput<RegisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterInstanceOutputError>
}

extension RegisterInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterInstanceInput(attributes: \(String(describing: attributes)), creatorRequestId: \(String(describing: creatorRequestId)), instanceId: \(String(describing: instanceId)), serviceId: \(String(describing: serviceId)))"}
}

extension RegisterInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case creatorRequestId = "CreatorRequestId"
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
    }
}

public struct RegisterInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterInstanceInput>
    public typealias MOutput = OperationOutput<RegisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterInstanceOutputError>
}

public struct RegisterInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterInstanceInput>
    public typealias MOutput = OperationOutput<RegisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterInstanceOutputError>
}

public struct RegisterInstanceInput: Equatable {
    /// <p>A string map that contains the following information for the service that you specify in
    ///    <code>ServiceId</code>:</p>
    ///          <ul>
    ///             <li>
    ///                <p>The attributes that apply to the records that are defined in the service. </p>
    ///             </li>
    ///             <li>
    ///                <p>For each attribute, the applicable value.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Supported attribute keys include the following:</p>
    ///          <dl>
    ///             <dt>AWS_ALIAS_DNS_NAME</dt>
    ///             <dd>
    ///                <p>If you want AWS Cloud Map to create an Amazon Route 53 alias record that routes traffic to an Elastic Load Balancing load balancer,
    ///       specify the DNS name that's associated with the load balancer. For information about how to get the DNS name, see
    ///       "DNSName" in the topic <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_AliasTarget.html">AliasTarget</a> in the <i>Route 53 API Reference</i>.</p>
    ///                <p>Note the following:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>The configuration for the service that's specified by <code>ServiceId</code> must include settings for an
    ///          <code>A</code> record, an <code>AAAA</code> record, or both.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>In the service that's specified by <code>ServiceId</code>, the value of <code>RoutingPolicy</code> must be
    ///          <code>WEIGHTED</code>.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>If the service that's specified by <code>ServiceId</code> includes <code>HealthCheckConfig</code> settings,
    ///         AWS Cloud Map will create the Route 53 health check, but it doesn't associate the health check with the alias
    ///         record.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Auto naming currently doesn't support creating alias records that route traffic to AWS resources other than
    ///         Elastic Load Balancing load balancers.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>If you specify a value for <code>AWS_ALIAS_DNS_NAME</code>, don't specify values for any of the
    ///          <code>AWS_INSTANCE</code> attributes.</p>
    ///                   </li>
    ///                </ul>
    ///             </dd>
    ///             <dt>AWS_EC2_INSTANCE_ID</dt>
    ///             <dd>
    ///                <p>
    ///                   <i>HTTP namespaces only.</i> The Amazon EC2 instance ID for the instance. If the
    ///        <code>AWS_EC2_INSTANCE_ID</code> attribute is specified, then the only other attribute that can be specified is
    ///        <code>AWS_INIT_HEALTH_STATUS</code>. When the <code>AWS_EC2_INSTANCE_ID</code> attribute is specified, then the
    ///        <code>AWS_INSTANCE_IPV4</code> attribute will be filled out with the primary private IPv4 address.</p>
    ///             </dd>
    ///             <dt>AWS_INIT_HEALTH_STATUS</dt>
    ///             <dd>
    ///                <p>If the service configuration includes <code>HealthCheckCustomConfig</code>, you can optionally use
    ///        <code>AWS_INIT_HEALTH_STATUS</code> to specify the initial status of the custom health check,
    ///        <code>HEALTHY</code> or <code>UNHEALTHY</code>. If you don't specify a value for
    ///        <code>AWS_INIT_HEALTH_STATUS</code>, the initial status is <code>HEALTHY</code>.</p>
    ///             </dd>
    ///             <dt>AWS_INSTANCE_CNAME</dt>
    ///             <dd>
    ///                <p>If the service configuration includes a <code>CNAME</code> record, the domain name that you want Route 53 to
    ///       return in response to DNS queries (for example, <code>example.com</code>).</p>
    ///                <p>This value is required if the service specified by <code>ServiceId</code> includes settings for an
    ///        <code>CNAME</code> record.</p>
    ///             </dd>
    ///             <dt>AWS_INSTANCE_IPV4</dt>
    ///             <dd>
    ///                <p>If the service configuration includes an <code>A</code> record, the IPv4 address that you want Route 53 to
    ///       return in response to DNS queries (for example, <code>192.0.2.44</code>).</p>
    ///                <p>This value is required if the service specified by <code>ServiceId</code> includes settings for an
    ///        <code>A</code> record. If the service includes settings for an <code>SRV</code> record, you must specify a value
    ///       for <code>AWS_INSTANCE_IPV4</code>, <code>AWS_INSTANCE_IPV6</code>, or both.</p>
    ///             </dd>
    ///             <dt>AWS_INSTANCE_IPV6</dt>
    ///             <dd>
    ///                <p>If the service configuration includes an <code>AAAA</code> record, the IPv6 address that you want Route 53 to
    ///       return in response to DNS queries (for example, <code>2001:0db8:85a3:0000:0000:abcd:0001:2345</code>).</p>
    ///                <p>This value is required if the service specified by <code>ServiceId</code> includes settings for an
    ///        <code>AAAA</code> record. If the service includes settings for an <code>SRV</code> record, you must specify a
    ///       value for <code>AWS_INSTANCE_IPV4</code>, <code>AWS_INSTANCE_IPV6</code>, or both.</p>
    ///             </dd>
    ///             <dt>AWS_INSTANCE_PORT</dt>
    ///             <dd>
    ///                <p>If the service includes an <code>SRV</code> record, the value that you want Route 53 to return for the
    ///       port.</p>
    ///                <p>If the service includes <code>HealthCheckConfig</code>, the port on the endpoint that you want Route 53 to send
    ///       requests to. </p>
    ///                <p>This value is required if you specified settings for an <code>SRV</code> record or a Route 53 health check when
    ///       you created the service.</p>
    ///             </dd>
    ///             <dt>Custom attributes</dt>
    ///             <dd>
    ///                <p>You can add up to 30 custom attributes. For each key-value pair, the maximum length of the attribute name is
    ///       255 characters, and the maximum length of the attribute value is 1,024 characters. The total size of all provided
    ///       attributes (sum of all keys and values) must not exceed 5,000 characters.</p>
    ///             </dd>
    ///          </dl>
    public let attributes: [String:String]?
    /// <p>A unique string that identifies the request and that allows failed <code>RegisterInstance</code> requests to be
    ///    retried without the risk of executing the operation twice. You must use a unique <code>CreatorRequestId</code> string
    ///    every time you submit a <code>RegisterInstance</code> request if you're registering additional instances for the same
    ///    namespace and service. <code>CreatorRequestId</code> can be any unique string (for example, a date/time
    ///    stamp).</p>
    public var creatorRequestId: String?
    /// <p>An identifier that you want to associate with the instance. Note the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If the service that's specified by <code>ServiceId</code> includes settings for an <code>SRV</code> record,
    ///      the value of <code>InstanceId</code> is automatically included as part of the value for the <code>SRV</code>
    ///      record. For more information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_DnsRecord.html#cloudmap-Type-DnsRecord-Type">DnsRecord > Type</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>You can use this value to update an existing instance.</p>
    ///             </li>
    ///             <li>
    ///                <p>To register a new instance, you must specify a value that's unique among instances that you register by using
    ///      the same service. </p>
    ///             </li>
    ///             <li>
    ///                <p>If you specify an existing <code>InstanceId</code> and <code>ServiceId</code>, AWS Cloud Map updates the existing
    ///      DNS records, if any. If there's also an existing health check, AWS Cloud Map deletes the old health check and creates
    ///      a new one. </p>
    ///                <note>
    ///                   <p>The health check isn't deleted immediately, so it will still appear for a while if you submit a
    ///        <code>ListHealthChecks</code> request, for example.</p>
    ///                </note>
    ///             </li>
    ///          </ul>
    public let instanceId: String?
    /// <p>The ID of the service that you want to use for settings for the instance.</p>
    public let serviceId: String?

    public init (
        attributes: [String:String]? = nil,
        creatorRequestId: String? = nil,
        instanceId: String? = nil,
        serviceId: String? = nil
    )
    {
        self.attributes = attributes
        self.creatorRequestId = creatorRequestId
        self.instanceId = instanceId
        self.serviceId = serviceId
    }
}

struct RegisterInstanceInputBody: Equatable {
    public let serviceId: String?
    public let instanceId: String?
    public let creatorRequestId: String?
    public let attributes: [String:String]?
}

extension RegisterInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case creatorRequestId = "CreatorRequestId"
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attrvalue0) in attributesContainer {
                if let attrvalue0 = attrvalue0 {
                    attributesDecoded0?[key0] = attrvalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension RegisterInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceeded" : self = .resourceLimitExceeded(try ResourceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterInstanceOutputError: Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case resourceInUse(ResourceInUse)
    case resourceLimitExceeded(ResourceLimitExceeded)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterInstanceOutputResponse(operationId: \(String(describing: operationId)))"}
}

extension RegisterInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct RegisterInstanceOutputResponse: Equatable {
    /// <p>A value that you can use to determine whether the request completed successfully. To get the status of the
    ///    operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation</a>.</p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct RegisterInstanceOutputResponseBody: Equatable {
    public let operationId: String?
}

extension RegisterInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension RequestLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestLimitExceeded(message: \(String(describing: message)))"}
}

extension RequestLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RequestLimitExceededBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation can't be completed because you've reached the quota for the number of requests. For more
///    information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/dg/throttling.html">AWS Cloud Map API request throttling
///     quota</a> in the <i>AWS Cloud Map Developer Guide</i>.</p>
public struct RequestLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RequestLimitExceededBody: Equatable {
    public let message: String?
}

extension RequestLimitExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUse(message: \(String(describing: message)))"}
}

extension ResourceInUse: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource can't be deleted because it contains other resources. For example, you can't delete a
///    service that contains any instances.</p>
public struct ResourceInUse: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseBody: Equatable {
    public let message: String?
}

extension ResourceInUseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceLimitExceeded(message: \(String(describing: message)))"}
}

extension ResourceLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceLimitExceededBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource can't be created because you've reached the quota on the number of resources.</p>
public struct ResourceLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceLimitExceededBody: Equatable {
    public let message: String?
}

extension ResourceLimitExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation can't be completed because the resource was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum RoutingPolicy {
    case multivalue
    case weighted
    case sdkUnknown(String)
}

extension RoutingPolicy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RoutingPolicy] {
        return [
            .multivalue,
            .weighted,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .multivalue: return "MULTIVALUE"
        case .weighted: return "WEIGHTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RoutingPolicy(rawValue: rawValue) ?? RoutingPolicy.sdkUnknown(rawValue)
    }
}

extension Service: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case creatorRequestId = "CreatorRequestId"
        case description = "Description"
        case dnsConfig = "DnsConfig"
        case healthCheckConfig = "HealthCheckConfig"
        case healthCheckCustomConfig = "HealthCheckCustomConfig"
        case id = "Id"
        case instanceCount = "InstanceCount"
        case name = "Name"
        case namespaceId = "NamespaceId"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dnsConfig = dnsConfig {
            try encodeContainer.encode(dnsConfig, forKey: .dnsConfig)
        }
        if let healthCheckConfig = healthCheckConfig {
            try encodeContainer.encode(healthCheckConfig, forKey: .healthCheckConfig)
        }
        if let healthCheckCustomConfig = healthCheckCustomConfig {
            try encodeContainer.encode(healthCheckCustomConfig, forKey: .healthCheckCustomConfig)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let instanceCount = instanceCount {
            try encodeContainer.encode(instanceCount, forKey: .instanceCount)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespaceId = namespaceId {
            try encodeContainer.encode(namespaceId, forKey: .namespaceId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let namespaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespaceId)
        namespaceId = namespaceIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let instanceCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .instanceCount)
        instanceCount = instanceCountDecoded
        let dnsConfigDecoded = try containerValues.decodeIfPresent(DnsConfig.self, forKey: .dnsConfig)
        dnsConfig = dnsConfigDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServiceType.self, forKey: .type)
        type = typeDecoded
        let healthCheckConfigDecoded = try containerValues.decodeIfPresent(HealthCheckConfig.self, forKey: .healthCheckConfig)
        healthCheckConfig = healthCheckConfigDecoded
        let healthCheckCustomConfigDecoded = try containerValues.decodeIfPresent(HealthCheckCustomConfig.self, forKey: .healthCheckCustomConfig)
        healthCheckCustomConfig = healthCheckCustomConfigDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createDate)
        createDate = createDateDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
    }
}

extension Service: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Service(arn: \(String(describing: arn)), createDate: \(String(describing: createDate)), creatorRequestId: \(String(describing: creatorRequestId)), description: \(String(describing: description)), dnsConfig: \(String(describing: dnsConfig)), healthCheckConfig: \(String(describing: healthCheckConfig)), healthCheckCustomConfig: \(String(describing: healthCheckCustomConfig)), id: \(String(describing: id)), instanceCount: \(String(describing: instanceCount)), name: \(String(describing: name)), namespaceId: \(String(describing: namespaceId)), type: \(String(describing: type)))"}
}

/// <p>A complex type that contains information about the specified service.</p>
public struct Service: Equatable {
    /// <p>The Amazon Resource Name (ARN) that AWS Cloud Map assigns to the service when you create it.</p>
    public let arn: String?
    /// <p>The date and time that the service was created, in Unix format and Coordinated Universal Time (UTC). The value
    ///    of <code>CreateDate</code> is accurate to milliseconds. For example, the value <code>1516925490.087</code> represents
    ///    Friday, January 26, 2018 12:11:30.087 AM.</p>
    public let createDate: Date?
    /// <p>A unique string that identifies the request and that allows failed requests to be retried without the risk of
    ///    running the operation twice. <code>CreatorRequestId</code> can be any unique string (for example, a
    ///    date/timestamp).</p>
    public let creatorRequestId: String?
    /// <p>The description of the service.</p>
    public let description: String?
    /// <p>A complex type that contains information about the Route 53 DNS records that you want AWS Cloud Map to create when you
    ///    register an instance.</p>
    public let dnsConfig: DnsConfig?
    /// <p>
    ///             <i>Public DNS and HTTP namespaces only.</i> A complex type that contains settings for an optional
    ///    health check. If you specify settings for a health check, AWS Cloud Map associates the health check with the records
    ///    that you specify in <code>DnsConfig</code>.</p>
    ///          <p>For information about the charges for health checks, see <a href="http://aws.amazon.com/route53/pricing/">Amazon Route 53 Pricing</a>.</p>
    public let healthCheckConfig: HealthCheckConfig?
    /// <p>A complex type that contains information about an optional custom health check.</p>
    ///          <important>
    ///             <p>If you specify a health check configuration, you can specify either <code>HealthCheckCustomConfig</code> or
    ///      <code>HealthCheckConfig</code> but not both.</p>
    ///          </important>
    public let healthCheckCustomConfig: HealthCheckCustomConfig?
    /// <p>The ID that AWS Cloud Map assigned to the service when you created it.</p>
    public let id: String?
    /// <p>The number of instances that are currently associated with the service. Instances that were previously
    ///    associated with the service but that are deleted aren't included in the count. The count might not reflect pending
    ///    registrations and deregistrations.</p>
    public let instanceCount: Int?
    /// <p>The name of the service.</p>
    public let name: String?
    /// <p>The ID of the namespace that was used to create the service.</p>
    public let namespaceId: String?
    /// <p>Describes the systems that can be used to discover the service instances.</p>
    ///          <dl>
    ///             <dt>DNS_HTTP</dt>
    ///             <dd>
    ///                <p>The service instances can be discovered using either DNS queries or the <code>DiscoverInstances</code> API
    ///       operation.</p>
    ///             </dd>
    ///             <dt>HTTP</dt>
    ///             <dd>
    ///                <p>The service instances can only be discovered using the <code>DiscoverInstances</code> API operation.</p>
    ///             </dd>
    ///             <dt>DNS</dt>
    ///             <dd>
    ///                <p>Reserved.</p>
    ///             </dd>
    ///          </dl>
    public let type: ServiceType?

    public init (
        arn: String? = nil,
        createDate: Date? = nil,
        creatorRequestId: String? = nil,
        description: String? = nil,
        dnsConfig: DnsConfig? = nil,
        healthCheckConfig: HealthCheckConfig? = nil,
        healthCheckCustomConfig: HealthCheckCustomConfig? = nil,
        id: String? = nil,
        instanceCount: Int? = nil,
        name: String? = nil,
        namespaceId: String? = nil,
        type: ServiceType? = nil
    )
    {
        self.arn = arn
        self.createDate = createDate
        self.creatorRequestId = creatorRequestId
        self.description = description
        self.dnsConfig = dnsConfig
        self.healthCheckConfig = healthCheckConfig
        self.healthCheckCustomConfig = healthCheckCustomConfig
        self.id = id
        self.instanceCount = instanceCount
        self.name = name
        self.namespaceId = namespaceId
        self.type = type
    }
}

extension ServiceAlreadyExists: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceAlreadyExists(creatorRequestId: \(String(describing: creatorRequestId)), message: \(String(describing: message)), serviceId: \(String(describing: serviceId)))"}
}

extension ServiceAlreadyExists: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceAlreadyExistsBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creatorRequestId = output.creatorRequestId
            self.message = output.message
            self.serviceId = output.serviceId
        } else {
            self.creatorRequestId = nil
            self.message = nil
            self.serviceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service can't be created because a service with the same name already exists.</p>
public struct ServiceAlreadyExists: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The <code>CreatorRequestId</code> that was used to create the service.</p>
    public var creatorRequestId: String?
    public var message: String?
    /// <p>The ID of the existing service.</p>
    public var serviceId: String?

    public init (
        creatorRequestId: String? = nil,
        message: String? = nil,
        serviceId: String? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.message = message
        self.serviceId = serviceId
    }
}

struct ServiceAlreadyExistsBody: Equatable {
    public let message: String?
    public let creatorRequestId: String?
    public let serviceId: String?
}

extension ServiceAlreadyExistsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case message = "Message"
        case serviceId = "ServiceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
    }
}

extension ServiceChange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case dnsConfig = "DnsConfig"
        case healthCheckConfig = "HealthCheckConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dnsConfig = dnsConfig {
            try encodeContainer.encode(dnsConfig, forKey: .dnsConfig)
        }
        if let healthCheckConfig = healthCheckConfig {
            try encodeContainer.encode(healthCheckConfig, forKey: .healthCheckConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let dnsConfigDecoded = try containerValues.decodeIfPresent(DnsConfigChange.self, forKey: .dnsConfig)
        dnsConfig = dnsConfigDecoded
        let healthCheckConfigDecoded = try containerValues.decodeIfPresent(HealthCheckConfig.self, forKey: .healthCheckConfig)
        healthCheckConfig = healthCheckConfigDecoded
    }
}

extension ServiceChange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceChange(description: \(String(describing: description)), dnsConfig: \(String(describing: dnsConfig)), healthCheckConfig: \(String(describing: healthCheckConfig)))"}
}

/// <p>A complex type that contains changes to an existing service.</p>
public struct ServiceChange: Equatable {
    /// <p>A description for the service.</p>
    public let description: String?
    /// <p>Information about the Route 53 DNS records that you want AWS Cloud Map to create when you register an instance.</p>
    public let dnsConfig: DnsConfigChange?
    /// <p>
    ///             <i>Public DNS and HTTP namespaces only.</i> Settings for an optional health check. If you specify
    ///    settings for a health check, AWS Cloud Map associates the health check with the records that you specify in
    ///     <code>DnsConfig</code>.</p>
    public let healthCheckConfig: HealthCheckConfig?

    public init (
        description: String? = nil,
        dnsConfig: DnsConfigChange? = nil,
        healthCheckConfig: HealthCheckConfig? = nil
    )
    {
        self.description = description
        self.dnsConfig = dnsConfig
        self.healthCheckConfig = healthCheckConfig
    }
}

extension ServiceFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case condition = "Condition"
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = condition {
            try encodeContainer.encode(condition.rawValue, forKey: .condition)
        }
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ServiceFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let conditionDecoded = try containerValues.decodeIfPresent(FilterCondition.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension ServiceFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceFilter(condition: \(String(describing: condition)), name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>A complex type that lets you specify the namespaces that you want to list services for.</p>
public struct ServiceFilter: Equatable {
    /// <p>The operator that you want to use to determine whether a service is returned by <code>ListServices</code>. Valid
    ///    values for <code>Condition</code> include the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>EQ</code>: When you specify <code>EQ</code>, specify one namespace ID for <code>Values</code>.
    ///       <code>EQ</code> is the default condition and can be omitted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IN</code>: When you specify <code>IN</code>, specify a list of the IDs for the namespaces that you want
    ///       <code>ListServices</code> to return a list of services for.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>BETWEEN</code>: Not applicable.</p>
    ///             </li>
    ///          </ul>
    public let condition: FilterCondition?
    /// <p>Specify <code>NAMESPACE_ID</code>.</p>
    public let name: ServiceFilterName?
    /// <p>The values that are applicable to the value that you specify for <code>Condition</code> to filter the list of
    ///    services.</p>
    public let values: [String]?

    public init (
        condition: FilterCondition? = nil,
        name: ServiceFilterName? = nil,
        values: [String]? = nil
    )
    {
        self.condition = condition
        self.name = name
        self.values = values
    }
}

public enum ServiceFilterName {
    case namespaceId
    case sdkUnknown(String)
}

extension ServiceFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServiceFilterName] {
        return [
            .namespaceId,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .namespaceId: return "NAMESPACE_ID"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServiceFilterName(rawValue: rawValue) ?? ServiceFilterName.sdkUnknown(rawValue)
    }
}

extension ServiceNotFound: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceNotFound(message: \(String(describing: message)))"}
}

extension ServiceNotFound: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceNotFoundBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>No service exists with the specified ID.</p>
public struct ServiceNotFound: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceNotFoundBody: Equatable {
    public let message: String?
}

extension ServiceNotFoundBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case description = "Description"
        case dnsConfig = "DnsConfig"
        case healthCheckConfig = "HealthCheckConfig"
        case healthCheckCustomConfig = "HealthCheckCustomConfig"
        case id = "Id"
        case instanceCount = "InstanceCount"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dnsConfig = dnsConfig {
            try encodeContainer.encode(dnsConfig, forKey: .dnsConfig)
        }
        if let healthCheckConfig = healthCheckConfig {
            try encodeContainer.encode(healthCheckConfig, forKey: .healthCheckConfig)
        }
        if let healthCheckCustomConfig = healthCheckCustomConfig {
            try encodeContainer.encode(healthCheckCustomConfig, forKey: .healthCheckCustomConfig)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let instanceCount = instanceCount {
            try encodeContainer.encode(instanceCount, forKey: .instanceCount)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServiceType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let instanceCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .instanceCount)
        instanceCount = instanceCountDecoded
        let dnsConfigDecoded = try containerValues.decodeIfPresent(DnsConfig.self, forKey: .dnsConfig)
        dnsConfig = dnsConfigDecoded
        let healthCheckConfigDecoded = try containerValues.decodeIfPresent(HealthCheckConfig.self, forKey: .healthCheckConfig)
        healthCheckConfig = healthCheckConfigDecoded
        let healthCheckCustomConfigDecoded = try containerValues.decodeIfPresent(HealthCheckCustomConfig.self, forKey: .healthCheckCustomConfig)
        healthCheckCustomConfig = healthCheckCustomConfigDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createDate)
        createDate = createDateDecoded
    }
}

extension ServiceSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceSummary(arn: \(String(describing: arn)), createDate: \(String(describing: createDate)), description: \(String(describing: description)), dnsConfig: \(String(describing: dnsConfig)), healthCheckConfig: \(String(describing: healthCheckConfig)), healthCheckCustomConfig: \(String(describing: healthCheckCustomConfig)), id: \(String(describing: id)), instanceCount: \(String(describing: instanceCount)), name: \(String(describing: name)), type: \(String(describing: type)))"}
}

/// <p>A complex type that contains information about a specified service.</p>
public struct ServiceSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) that AWS Cloud Map assigns to the service when you create it.</p>
    public let arn: String?
    /// <p>The date and time that the service was created.</p>
    public let createDate: Date?
    /// <p>The description that you specify when you create the service.</p>
    public let description: String?
    /// <p>Information about the Route 53 DNS records that you want AWS Cloud Map to create when you register an instance.</p>
    public let dnsConfig: DnsConfig?
    /// <p>
    ///             <i>Public DNS and HTTP namespaces only.</i> Settings for an optional health check. If you specify
    ///    settings for a health check, AWS Cloud Map associates the health check with the records that you specify in
    ///     <code>DnsConfig</code>.</p>
    public let healthCheckConfig: HealthCheckConfig?
    /// <p>Information about an optional custom health check. A custom health check, which requires that you use a
    ///    third-party health checker to evaluate the health of your resources, is useful in the following circumstances:</p>
    ///          <ul>
    ///             <li>
    ///                <p>You can't use a health check that's defined by <code>HealthCheckConfig</code> because the resource isn't
    ///      available over the internet. For example, you can use a custom health check when the instance is in an Amazon VPC.
    ///      (To check the health of resources in a VPC, the health checker must also be in the VPC.)</p>
    ///             </li>
    ///             <li>
    ///                <p>You want to use a third-party health checker regardless of where your resources are located.</p>
    ///             </li>
    ///          </ul>
    ///          <important>
    ///             <p>If you specify a health check configuration, you can specify either <code>HealthCheckCustomConfig</code> or
    ///      <code>HealthCheckConfig</code> but not both.</p>
    ///          </important>
    public let healthCheckCustomConfig: HealthCheckCustomConfig?
    /// <p>The ID that AWS Cloud Map assigned to the service when you created it.</p>
    public let id: String?
    /// <p>The number of instances that are currently associated with the service. Instances that were previously
    ///    associated with the service but that are deleted aren't included in the count. The count might not reflect pending
    ///    registrations and deregistrations.</p>
    public let instanceCount: Int?
    /// <p>The name of the service.</p>
    public let name: String?
    /// <p>Describes the systems that can be used to discover the service instances.</p>
    ///          <dl>
    ///             <dt>DNS_HTTP</dt>
    ///             <dd>
    ///                <p>The service instances can be discovered using either DNS queries or the <code>DiscoverInstances</code> API
    ///       operation.</p>
    ///             </dd>
    ///             <dt>HTTP</dt>
    ///             <dd>
    ///                <p>The service instances can only be discovered using the <code>DiscoverInstances</code> API operation.</p>
    ///             </dd>
    ///             <dt>DNS</dt>
    ///             <dd>
    ///                <p>Reserved.</p>
    ///             </dd>
    ///          </dl>
    public let type: ServiceType?

    public init (
        arn: String? = nil,
        createDate: Date? = nil,
        description: String? = nil,
        dnsConfig: DnsConfig? = nil,
        healthCheckConfig: HealthCheckConfig? = nil,
        healthCheckCustomConfig: HealthCheckCustomConfig? = nil,
        id: String? = nil,
        instanceCount: Int? = nil,
        name: String? = nil,
        type: ServiceType? = nil
    )
    {
        self.arn = arn
        self.createDate = createDate
        self.description = description
        self.dnsConfig = dnsConfig
        self.healthCheckConfig = healthCheckConfig
        self.healthCheckCustomConfig = healthCheckCustomConfig
        self.id = id
        self.instanceCount = instanceCount
        self.name = name
        self.type = type
    }
}

public enum ServiceType {
    case dns
    case dnsHttp
    case http
    case sdkUnknown(String)
}

extension ServiceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServiceType] {
        return [
            .dns,
            .dnsHttp,
            .http,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dns: return "DNS"
        case .dnsHttp: return "DNS_HTTP"
        case .http: return "HTTP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServiceType(rawValue: rawValue) ?? ServiceType.sdkUnknown(rawValue)
    }
}

public enum ServiceTypeOption {
    case http
    case sdkUnknown(String)
}

extension ServiceTypeOption : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServiceTypeOption] {
        return [
            .http,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .http: return "HTTP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServiceTypeOption(rawValue: rawValue) ?? ServiceTypeOption.sdkUnknown(rawValue)
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A custom key-value pair that's associated with a resource.</p>
public struct Tag: Equatable {
    /// <p>The key identifier, or name, of the tag.</p>
    public let key: String?
    /// <p>The string value that's associated with the key of the tag. You can set the value of a tag to an empty string,
    ///    but you can't set the value of a tag to null.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceARN: \(String(describing: resourceARN)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.</p>
    public let resourceARN: String?
    /// <p>The tags to add to the specified resource. Specifying the tag key is required. You can set the value of a tag to
    ///    an empty string, but you can't set the value of a tag to null.</p>
    public let tags: [Tag]?

    public init (
        resourceARN: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case invalidInput(InvalidInput)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TooManyTagsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTagsException(message: \(String(describing: message)), resourceName: \(String(describing: resourceName)))"}
}

extension TooManyTagsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The list of tags on the resource is over the quota. The maximum number of tags that can be applied to a resource
///    is 50.</p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The name of the resource.</p>
    public var resourceName: String?

    public init (
        message: String? = nil,
        resourceName: String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Equatable {
    public let message: String?
    public let resourceName: String?
}

extension TooManyTagsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceARN: \(String(describing: resourceARN)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.</p>
    public let resourceARN: String?
    /// <p>The tag keys to remove from the specified resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceARN: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case invalidInput(InvalidInput)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateInstanceCustomHealthStatusInputBodyMiddleware: Middleware {
    public let id: String = "UpdateInstanceCustomHealthStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInstanceCustomHealthStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInstanceCustomHealthStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInstanceCustomHealthStatusInput>
    public typealias MOutput = OperationOutput<UpdateInstanceCustomHealthStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInstanceCustomHealthStatusOutputError>
}

extension UpdateInstanceCustomHealthStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateInstanceCustomHealthStatusInput(instanceId: \(String(describing: instanceId)), serviceId: \(String(describing: serviceId)), status: \(String(describing: status)))"}
}

extension UpdateInstanceCustomHealthStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct UpdateInstanceCustomHealthStatusInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateInstanceCustomHealthStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInstanceCustomHealthStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInstanceCustomHealthStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInstanceCustomHealthStatusInput>
    public typealias MOutput = OperationOutput<UpdateInstanceCustomHealthStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInstanceCustomHealthStatusOutputError>
}

public struct UpdateInstanceCustomHealthStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateInstanceCustomHealthStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInstanceCustomHealthStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInstanceCustomHealthStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInstanceCustomHealthStatusInput>
    public typealias MOutput = OperationOutput<UpdateInstanceCustomHealthStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInstanceCustomHealthStatusOutputError>
}

public struct UpdateInstanceCustomHealthStatusInput: Equatable {
    /// <p>The ID of the instance that you want to change the health status for.</p>
    public let instanceId: String?
    /// <p>The ID of the service that includes the configuration for the custom health check that you want to change the
    ///    status for.</p>
    public let serviceId: String?
    /// <p>The new status of the instance, <code>HEALTHY</code> or <code>UNHEALTHY</code>.</p>
    public let status: CustomHealthStatus?

    public init (
        instanceId: String? = nil,
        serviceId: String? = nil,
        status: CustomHealthStatus? = nil
    )
    {
        self.instanceId = instanceId
        self.serviceId = serviceId
        self.status = status
    }
}

struct UpdateInstanceCustomHealthStatusInputBody: Equatable {
    public let serviceId: String?
    public let instanceId: String?
    public let status: CustomHealthStatus?
}

extension UpdateInstanceCustomHealthStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case serviceId = "ServiceId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CustomHealthStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateInstanceCustomHealthStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateInstanceCustomHealthStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CustomHealthNotFound" : self = .customHealthNotFound(try CustomHealthNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstanceNotFound" : self = .instanceNotFound(try InstanceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateInstanceCustomHealthStatusOutputError: Equatable {
    case customHealthNotFound(CustomHealthNotFound)
    case instanceNotFound(InstanceNotFound)
    case invalidInput(InvalidInput)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateInstanceCustomHealthStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateInstanceCustomHealthStatusOutputResponse()"}
}

extension UpdateInstanceCustomHealthStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateInstanceCustomHealthStatusOutputResponse: Equatable {

    public init() {}
}

struct UpdateInstanceCustomHealthStatusOutputResponseBody: Equatable {
}

extension UpdateInstanceCustomHealthStatusOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateServiceInputBodyMiddleware: Middleware {
    public let id: String = "UpdateServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServiceInput>
    public typealias MOutput = OperationOutput<UpdateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServiceOutputError>
}

extension UpdateServiceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServiceInput(id: \(String(describing: id)), service: \(String(describing: service)))"}
}

extension UpdateServiceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case service = "Service"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let service = service {
            try encodeContainer.encode(service, forKey: .service)
        }
    }
}

public struct UpdateServiceInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServiceInput>
    public typealias MOutput = OperationOutput<UpdateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServiceOutputError>
}

public struct UpdateServiceInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServiceInput>
    public typealias MOutput = OperationOutput<UpdateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServiceOutputError>
}

public struct UpdateServiceInput: Equatable {
    /// <p>The ID of the service that you want to update.</p>
    public let id: String?
    /// <p>A complex type that contains the new settings for the service.</p>
    public let service: ServiceChange?

    public init (
        id: String? = nil,
        service: ServiceChange? = nil
    )
    {
        self.id = id
        self.service = service
    }
}

struct UpdateServiceInputBody: Equatable {
    public let id: String?
    public let service: ServiceChange?
}

extension UpdateServiceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case service = "Service"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(ServiceChange.self, forKey: .service)
        service = serviceDecoded
    }
}

extension UpdateServiceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServiceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateRequest" : self = .duplicateRequest(try DuplicateRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInput" : self = .invalidInput(try InvalidInput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceNotFound" : self = .serviceNotFound(try ServiceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServiceOutputError: Equatable {
    case duplicateRequest(DuplicateRequest)
    case invalidInput(InvalidInput)
    case serviceNotFound(ServiceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServiceOutputResponse(operationId: \(String(describing: operationId)))"}
}

extension UpdateServiceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateServiceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct UpdateServiceOutputResponse: Equatable {
    /// <p>A value that you can use to determine whether the request completed successfully. To get the status of the
    ///    operation, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html">GetOperation</a>.</p>
    public let operationId: String?

    public init (
        operationId: String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct UpdateServiceOutputResponseBody: Equatable {
    public let operationId: String?
}

extension UpdateServiceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}
