// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension DynamoDbStreamsClientTypes.AttributeValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case b = "B"
        case bool = "BOOL"
        case bs = "BS"
        case l = "L"
        case m = "M"
        case n = "N"
        case ns = "NS"
        case null = "NULL"
        case s = "S"
        case ss = "SS"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .b(b):
                try container.encode(b.base64EncodedString(), forKey: .b)
            case let .bool(bool):
                try container.encode(bool, forKey: .bool)
            case let .bs(bs):
                var bsContainer = container.nestedUnkeyedContainer(forKey: .bs)
                for binarysetattributevalue0 in bs {
                    try bsContainer.encode(binarysetattributevalue0.base64EncodedString())
                }
            case let .l(l):
                var lContainer = container.nestedUnkeyedContainer(forKey: .l)
                for listattributevalue0 in l {
                    try lContainer.encode(listattributevalue0)
                }
            case let .m(m):
                var mContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .m)
                for (dictKey0, mapattributevalue0) in m {
                    try mContainer.encode(mapattributevalue0, forKey: ClientRuntime.Key(stringValue: dictKey0))
                }
            case let .n(n):
                try container.encode(n, forKey: .n)
            case let .ns(ns):
                var nsContainer = container.nestedUnkeyedContainer(forKey: .ns)
                for numbersetattributevalue0 in ns {
                    try nsContainer.encode(numbersetattributevalue0)
                }
            case let .null(null):
                try container.encode(null, forKey: .null)
            case let .s(s):
                try container.encode(s, forKey: .s)
            case let .ss(ss):
                var ssContainer = container.nestedUnkeyedContainer(forKey: .ss)
                for stringsetattributevalue0 in ss {
                    try ssContainer.encode(stringsetattributevalue0)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let sDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .s)
        if let s = sDecoded {
            self = .s(s)
            return
        }
        let nDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .n)
        if let n = nDecoded {
            self = .n(n)
            return
        }
        let bDecoded = try values.decodeIfPresent(ClientRuntime.Data.self, forKey: .b)
        if let b = bDecoded {
            self = .b(b)
            return
        }
        let ssContainer = try values.decodeIfPresent([Swift.String?].self, forKey: .ss)
        var ssDecoded0:[Swift.String]? = nil
        if let ssContainer = ssContainer {
            ssDecoded0 = [Swift.String]()
            for string0 in ssContainer {
                if let string0 = string0 {
                    ssDecoded0?.append(string0)
                }
            }
        }
        if let ss = ssDecoded0 {
            self = .ss(ss)
            return
        }
        let nsContainer = try values.decodeIfPresent([Swift.String?].self, forKey: .ns)
        var nsDecoded0:[Swift.String]? = nil
        if let nsContainer = nsContainer {
            nsDecoded0 = [Swift.String]()
            for string0 in nsContainer {
                if let string0 = string0 {
                    nsDecoded0?.append(string0)
                }
            }
        }
        if let ns = nsDecoded0 {
            self = .ns(ns)
            return
        }
        let bsContainer = try values.decodeIfPresent([ClientRuntime.Data?].self, forKey: .bs)
        var bsDecoded0:[ClientRuntime.Data]? = nil
        if let bsContainer = bsContainer {
            bsDecoded0 = [ClientRuntime.Data]()
            for blob0 in bsContainer {
                if let blob0 = blob0 {
                    bsDecoded0?.append(blob0)
                }
            }
        }
        if let bs = bsDecoded0 {
            self = .bs(bs)
            return
        }
        let mContainer = try values.decodeIfPresent([Swift.String: DynamoDbStreamsClientTypes.AttributeValue?].self, forKey: .m)
        var mDecoded0: [Swift.String:DynamoDbStreamsClientTypes.AttributeValue]? = nil
        if let mContainer = mContainer {
            mDecoded0 = [Swift.String:DynamoDbStreamsClientTypes.AttributeValue]()
            for (key0, attributevalue0) in mContainer {
                if let attributevalue0 = attributevalue0 {
                    mDecoded0?[key0] = attributevalue0
                }
            }
        }
        if let m = mDecoded0 {
            self = .m(m)
            return
        }
        let lContainer = try values.decodeIfPresent([DynamoDbStreamsClientTypes.AttributeValue?].self, forKey: .l)
        var lDecoded0:[DynamoDbStreamsClientTypes.AttributeValue]? = nil
        if let lContainer = lContainer {
            lDecoded0 = [DynamoDbStreamsClientTypes.AttributeValue]()
            for union0 in lContainer {
                if let union0 = union0 {
                    lDecoded0?.append(union0)
                }
            }
        }
        if let l = lDecoded0 {
            self = .l(l)
            return
        }
        let nullDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .null)
        if let null = nullDecoded {
            self = .null(null)
            return
        }
        let boolDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .bool)
        if let bool = boolDecoded {
            self = .bool(bool)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DynamoDbStreamsClientTypes {
    /// Represents the data for an attribute. Each attribute value is described as a name-value pair. The name is the data type, and the value is the data itself. For more information, see [Data Types](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html#HowItWorks.DataTypes) in the Amazon DynamoDB Developer Guide.
    public enum AttributeValue: Swift.Equatable {
        /// An attribute of type String. For example: "S": "Hello"
        case s(Swift.String)
        /// An attribute of type Number. For example: "N": "123.45" Numbers are sent across the network to DynamoDB as strings, to maximize compatibility across languages and libraries. However, DynamoDB treats them as number type attributes for mathematical operations.
        case n(Swift.String)
        /// An attribute of type Binary. For example: "B": "dGhpcyB0ZXh0IGlzIGJhc2U2NC1lbmNvZGVk"
        case b(ClientRuntime.Data)
        /// An attribute of type String Set. For example: "SS": ["Giraffe", "Hippo" ,"Zebra"]
        case ss([Swift.String])
        /// An attribute of type Number Set. For example: "NS": ["42.2", "-19", "7.5", "3.14"] Numbers are sent across the network to DynamoDB as strings, to maximize compatibility across languages and libraries. However, DynamoDB treats them as number type attributes for mathematical operations.
        case ns([Swift.String])
        /// An attribute of type Binary Set. For example: "BS": ["U3Vubnk=", "UmFpbnk=", "U25vd3k="]
        case bs([ClientRuntime.Data])
        /// An attribute of type Map. For example: "M": {"Name": {"S": "Joe"}, "Age": {"N": "35"}}
        case m([Swift.String:DynamoDbStreamsClientTypes.AttributeValue])
        /// An attribute of type List. For example: "L": [ {"S": "Cookies"} , {"S": "Coffee"}, {"N", "3.14159"}]
        case l([DynamoDbStreamsClientTypes.AttributeValue])
        /// An attribute of type Null. For example: "NULL": true
        case null(Swift.Bool)
        /// An attribute of type Boolean. For example: "BOOL": true
        case bool(Swift.Bool)
        case sdkUnknown(Swift.String)
    }

}

extension DescribeStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusiveStartShardId = "ExclusiveStartShardId"
        case limit = "Limit"
        case streamArn = "StreamArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclusiveStartShardId = exclusiveStartShardId {
            try encodeContainer.encode(exclusiveStartShardId, forKey: .exclusiveStartShardId)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let streamArn = streamArn {
            try encodeContainer.encode(streamArn, forKey: .streamArn)
        }
    }
}

extension DescribeStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a DescribeStream operation.
public struct DescribeStreamInput: Swift.Equatable {
    /// The shard ID of the first item that this operation will evaluate. Use the value that was returned for LastEvaluatedShardId in the previous operation.
    public var exclusiveStartShardId: Swift.String?
    /// The maximum number of shard objects to return. The upper limit is 100.
    public var limit: Swift.Int?
    /// The Amazon Resource Name (ARN) for the stream.
    /// This member is required.
    public var streamArn: Swift.String?

    public init (
        exclusiveStartShardId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        streamArn: Swift.String? = nil
    )
    {
        self.exclusiveStartShardId = exclusiveStartShardId
        self.limit = limit
        self.streamArn = streamArn
    }
}

struct DescribeStreamInputBody: Swift.Equatable {
    let streamArn: Swift.String?
    let limit: Swift.Int?
    let exclusiveStartShardId: Swift.String?
}

extension DescribeStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusiveStartShardId = "ExclusiveStartShardId"
        case limit = "Limit"
        case streamArn = "StreamArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let exclusiveStartShardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exclusiveStartShardId)
        exclusiveStartShardId = exclusiveStartShardIdDecoded
    }
}

extension DescribeStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStreamOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeStreamOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamDescription = output.streamDescription
        } else {
            self.streamDescription = nil
        }
    }
}

/// Represents the output of a DescribeStream operation.
public struct DescribeStreamOutputResponse: Swift.Equatable {
    /// A complete description of the stream, including its creation date and time, the DynamoDB table associated with the stream, the shard IDs within the stream, and the beginning and ending sequence numbers of stream records within the shards.
    public var streamDescription: DynamoDbStreamsClientTypes.StreamDescription?

    public init (
        streamDescription: DynamoDbStreamsClientTypes.StreamDescription? = nil
    )
    {
        self.streamDescription = streamDescription
    }
}

struct DescribeStreamOutputResponseBody: Swift.Equatable {
    let streamDescription: DynamoDbStreamsClientTypes.StreamDescription?
}

extension DescribeStreamOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamDescription = "StreamDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamDescriptionDecoded = try containerValues.decodeIfPresent(DynamoDbStreamsClientTypes.StreamDescription.self, forKey: .streamDescription)
        streamDescription = streamDescriptionDecoded
    }
}

extension ExpiredIteratorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExpiredIteratorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The shard iterator has expired and can no longer be used to retrieve stream records. A shard iterator expires 15 minutes after it is retrieved using the GetShardIterator action.
public struct ExpiredIteratorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The provided iterator exceeds the maximum age allowed.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ExpiredIteratorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ExpiredIteratorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetRecordsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case shardIterator = "ShardIterator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let shardIterator = shardIterator {
            try encodeContainer.encode(shardIterator, forKey: .shardIterator)
        }
    }
}

extension GetRecordsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a GetRecords operation.
public struct GetRecordsInput: Swift.Equatable {
    /// The maximum number of records to return from the shard. The upper limit is 1000.
    public var limit: Swift.Int?
    /// A shard iterator that was retrieved from a previous GetShardIterator operation. This iterator can be used to access the stream records in this shard.
    /// This member is required.
    public var shardIterator: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        shardIterator: Swift.String? = nil
    )
    {
        self.limit = limit
        self.shardIterator = shardIterator
    }
}

struct GetRecordsInputBody: Swift.Equatable {
    let shardIterator: Swift.String?
    let limit: Swift.Int?
}

extension GetRecordsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case shardIterator = "ShardIterator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shardIteratorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shardIterator)
        shardIterator = shardIteratorDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension GetRecordsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecordsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExpiredIteratorException" : self = .expiredIteratorException(try ExpiredIteratorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrimmedDataAccessException" : self = .trimmedDataAccessException(try TrimmedDataAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRecordsOutputError: Swift.Error, Swift.Equatable {
    case expiredIteratorException(ExpiredIteratorException)
    case internalServerError(InternalServerError)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case trimmedDataAccessException(TrimmedDataAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecordsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRecordsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextShardIterator = output.nextShardIterator
            self.records = output.records
        } else {
            self.nextShardIterator = nil
            self.records = nil
        }
    }
}

/// Represents the output of a GetRecords operation.
public struct GetRecordsOutputResponse: Swift.Equatable {
    /// The next position in the shard from which to start sequentially reading stream records. If set to null, the shard has been closed and the requested iterator will not return any more data.
    public var nextShardIterator: Swift.String?
    /// The stream records from the shard, which were retrieved using the shard iterator.
    public var records: [DynamoDbStreamsClientTypes.Record]?

    public init (
        nextShardIterator: Swift.String? = nil,
        records: [DynamoDbStreamsClientTypes.Record]? = nil
    )
    {
        self.nextShardIterator = nextShardIterator
        self.records = records
    }
}

struct GetRecordsOutputResponseBody: Swift.Equatable {
    let records: [DynamoDbStreamsClientTypes.Record]?
    let nextShardIterator: Swift.String?
}

extension GetRecordsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextShardIterator = "NextShardIterator"
        case records = "Records"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsContainer = try containerValues.decodeIfPresent([DynamoDbStreamsClientTypes.Record?].self, forKey: .records)
        var recordsDecoded0:[DynamoDbStreamsClientTypes.Record]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [DynamoDbStreamsClientTypes.Record]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
        let nextShardIteratorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextShardIterator)
        nextShardIterator = nextShardIteratorDecoded
    }
}

extension GetShardIteratorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sequenceNumber = "SequenceNumber"
        case shardId = "ShardId"
        case shardIteratorType = "ShardIteratorType"
        case streamArn = "StreamArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sequenceNumber = sequenceNumber {
            try encodeContainer.encode(sequenceNumber, forKey: .sequenceNumber)
        }
        if let shardId = shardId {
            try encodeContainer.encode(shardId, forKey: .shardId)
        }
        if let shardIteratorType = shardIteratorType {
            try encodeContainer.encode(shardIteratorType.rawValue, forKey: .shardIteratorType)
        }
        if let streamArn = streamArn {
            try encodeContainer.encode(streamArn, forKey: .streamArn)
        }
    }
}

extension GetShardIteratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a GetShardIterator operation.
public struct GetShardIteratorInput: Swift.Equatable {
    /// The sequence number of a stream record in the shard from which to start reading.
    public var sequenceNumber: Swift.String?
    /// The identifier of the shard. The iterator will be returned for this shard ID.
    /// This member is required.
    public var shardId: Swift.String?
    /// Determines how the shard iterator is used to start reading stream records from the shard:
    ///
    /// * AT_SEQUENCE_NUMBER - Start reading exactly from the position denoted by a specific sequence number.
    ///
    /// * AFTER_SEQUENCE_NUMBER - Start reading right after the position denoted by a specific sequence number.
    ///
    /// * TRIM_HORIZON - Start reading at the last (untrimmed) stream record, which is the oldest record in the shard. In DynamoDB Streams, there is a 24 hour limit on data retention. Stream records whose age exceeds this limit are subject to removal (trimming) from the stream.
    ///
    /// * LATEST - Start reading just after the most recent stream record in the shard, so that you always read the most recent data in the shard.
    /// This member is required.
    public var shardIteratorType: DynamoDbStreamsClientTypes.ShardIteratorType?
    /// The Amazon Resource Name (ARN) for the stream.
    /// This member is required.
    public var streamArn: Swift.String?

    public init (
        sequenceNumber: Swift.String? = nil,
        shardId: Swift.String? = nil,
        shardIteratorType: DynamoDbStreamsClientTypes.ShardIteratorType? = nil,
        streamArn: Swift.String? = nil
    )
    {
        self.sequenceNumber = sequenceNumber
        self.shardId = shardId
        self.shardIteratorType = shardIteratorType
        self.streamArn = streamArn
    }
}

struct GetShardIteratorInputBody: Swift.Equatable {
    let streamArn: Swift.String?
    let shardId: Swift.String?
    let shardIteratorType: DynamoDbStreamsClientTypes.ShardIteratorType?
    let sequenceNumber: Swift.String?
}

extension GetShardIteratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sequenceNumber = "SequenceNumber"
        case shardId = "ShardId"
        case shardIteratorType = "ShardIteratorType"
        case streamArn = "StreamArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
        let shardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shardId)
        shardId = shardIdDecoded
        let shardIteratorTypeDecoded = try containerValues.decodeIfPresent(DynamoDbStreamsClientTypes.ShardIteratorType.self, forKey: .shardIteratorType)
        shardIteratorType = shardIteratorTypeDecoded
        let sequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceNumber)
        sequenceNumber = sequenceNumberDecoded
    }
}

extension GetShardIteratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetShardIteratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrimmedDataAccessException" : self = .trimmedDataAccessException(try TrimmedDataAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetShardIteratorOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case resourceNotFoundException(ResourceNotFoundException)
    case trimmedDataAccessException(TrimmedDataAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetShardIteratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetShardIteratorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.shardIterator = output.shardIterator
        } else {
            self.shardIterator = nil
        }
    }
}

/// Represents the output of a GetShardIterator operation.
public struct GetShardIteratorOutputResponse: Swift.Equatable {
    /// The position in the shard from which to start reading stream records sequentially. A shard iterator specifies this position using the sequence number of a stream record in a shard.
    public var shardIterator: Swift.String?

    public init (
        shardIterator: Swift.String? = nil
    )
    {
        self.shardIterator = shardIterator
    }
}

struct GetShardIteratorOutputResponseBody: Swift.Equatable {
    let shardIterator: Swift.String?
}

extension GetShardIteratorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shardIterator = "ShardIterator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shardIteratorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shardIterator)
        shardIterator = shardIteratorDecoded
    }
}

extension DynamoDbStreamsClientTypes.Identity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case principalId = "PrincipalId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension DynamoDbStreamsClientTypes {
    /// Contains details about the type of identity that made the request.
    public struct Identity: Swift.Equatable {
        /// A unique identifier for the entity that made the call. For Time To Live, the principalId is "dynamodb.amazonaws.com".
        public var principalId: Swift.String?
        /// The type of the identity. For Time To Live, the type is "Service".
        public var type: Swift.String?

        public init (
            principalId: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.principalId = principalId
            self.type = type
        }
    }

}

extension InternalServerError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error occurred on the server side.
public struct InternalServerError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The server encountered an internal error trying to fulfill the request.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DynamoDbStreamsClientTypes.KeySchemaElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case keyType = "KeyType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let keyType = keyType {
            try encodeContainer.encode(keyType.rawValue, forKey: .keyType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let keyTypeDecoded = try containerValues.decodeIfPresent(DynamoDbStreamsClientTypes.KeyType.self, forKey: .keyType)
        keyType = keyTypeDecoded
    }
}

extension DynamoDbStreamsClientTypes {
    /// Represents a single element of a key schema. A key schema specifies the attributes that make up the primary key of a table, or the key attributes of an index. A KeySchemaElement represents exactly one attribute of the primary key. For example, a simple primary key would be represented by one KeySchemaElement (for the partition key). A composite primary key would require one KeySchemaElement for the partition key, and another KeySchemaElement for the sort key. A KeySchemaElement must be a scalar, top-level attribute (not a nested attribute). The data type must be one of String, Number, or Binary. The attribute cannot be nested within a List or a Map.
    public struct KeySchemaElement: Swift.Equatable {
        /// The name of a key attribute.
        /// This member is required.
        public var attributeName: Swift.String?
        /// The role that this key attribute will assume:
        ///
        /// * HASH - partition key
        ///
        /// * RANGE - sort key
        ///
        ///
        /// The partition key of an item is also known as its hash attribute. The term "hash attribute" derives from DynamoDB's usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values. The sort key of an item is also known as its range attribute. The term "range attribute" derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
        /// This member is required.
        public var keyType: DynamoDbStreamsClientTypes.KeyType?

        public init (
            attributeName: Swift.String? = nil,
            keyType: DynamoDbStreamsClientTypes.KeyType? = nil
        )
        {
            self.attributeName = attributeName
            self.keyType = keyType
        }
    }

}

extension DynamoDbStreamsClientTypes {
    public enum KeyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hash
        case range
        case sdkUnknown(Swift.String)

        public static var allCases: [KeyType] {
            return [
                .hash,
                .range,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hash: return "HASH"
            case .range: return "RANGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KeyType(rawValue: rawValue) ?? KeyType.sdkUnknown(rawValue)
        }
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is no limit to the number of daily on-demand backups that can be taken. Up to 50 simultaneous table operations are allowed per account. These operations include CreateTable, UpdateTable, DeleteTable,UpdateTimeToLive, RestoreTableFromBackup, and RestoreTableToPointInTime. The only exception is when you are creating a table with one or more secondary indexes. You can have up to 25 such requests running at a time; however, if the table or index specifications are complex, DynamoDB might temporarily reduce the number of concurrent operations. There is a soft account quota of 256 tables.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Too many operations for a given subscriber.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListStreamsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusiveStartStreamArn = "ExclusiveStartStreamArn"
        case limit = "Limit"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclusiveStartStreamArn = exclusiveStartStreamArn {
            try encodeContainer.encode(exclusiveStartStreamArn, forKey: .exclusiveStartStreamArn)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

extension ListStreamsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Represents the input of a ListStreams operation.
public struct ListStreamsInput: Swift.Equatable {
    /// The ARN (Amazon Resource Name) of the first item that this operation will evaluate. Use the value that was returned for LastEvaluatedStreamArn in the previous operation.
    public var exclusiveStartStreamArn: Swift.String?
    /// The maximum number of streams to return. The upper limit is 100.
    public var limit: Swift.Int?
    /// If this parameter is provided, then only the streams associated with this table name are returned.
    public var tableName: Swift.String?

    public init (
        exclusiveStartStreamArn: Swift.String? = nil,
        limit: Swift.Int? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.exclusiveStartStreamArn = exclusiveStartStreamArn
        self.limit = limit
        self.tableName = tableName
    }
}

struct ListStreamsInputBody: Swift.Equatable {
    let tableName: Swift.String?
    let limit: Swift.Int?
    let exclusiveStartStreamArn: Swift.String?
}

extension ListStreamsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusiveStartStreamArn = "ExclusiveStartStreamArn"
        case limit = "Limit"
        case tableName = "TableName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let exclusiveStartStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exclusiveStartStreamArn)
        exclusiveStartStreamArn = exclusiveStartStreamArnDecoded
    }
}

extension ListStreamsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStreamsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStreamsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListStreamsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lastEvaluatedStreamArn = output.lastEvaluatedStreamArn
            self.streams = output.streams
        } else {
            self.lastEvaluatedStreamArn = nil
            self.streams = nil
        }
    }
}

/// Represents the output of a ListStreams operation.
public struct ListStreamsOutputResponse: Swift.Equatable {
    /// The stream ARN of the item where the operation stopped, inclusive of the previous result set. Use this value to start a new operation, excluding this value in the new request. If LastEvaluatedStreamArn is empty, then the "last page" of results has been processed and there is no more data to be retrieved. If LastEvaluatedStreamArn is not empty, it does not necessarily mean that there is more data in the result set. The only way to know when you have reached the end of the result set is when LastEvaluatedStreamArn is empty.
    public var lastEvaluatedStreamArn: Swift.String?
    /// A list of stream descriptors associated with the current account and endpoint.
    public var streams: [DynamoDbStreamsClientTypes.Stream]?

    public init (
        lastEvaluatedStreamArn: Swift.String? = nil,
        streams: [DynamoDbStreamsClientTypes.Stream]? = nil
    )
    {
        self.lastEvaluatedStreamArn = lastEvaluatedStreamArn
        self.streams = streams
    }
}

struct ListStreamsOutputResponseBody: Swift.Equatable {
    let streams: [DynamoDbStreamsClientTypes.Stream]?
    let lastEvaluatedStreamArn: Swift.String?
}

extension ListStreamsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastEvaluatedStreamArn = "LastEvaluatedStreamArn"
        case streams = "Streams"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamsContainer = try containerValues.decodeIfPresent([DynamoDbStreamsClientTypes.Stream?].self, forKey: .streams)
        var streamsDecoded0:[DynamoDbStreamsClientTypes.Stream]? = nil
        if let streamsContainer = streamsContainer {
            streamsDecoded0 = [DynamoDbStreamsClientTypes.Stream]()
            for structure0 in streamsContainer {
                if let structure0 = structure0 {
                    streamsDecoded0?.append(structure0)
                }
            }
        }
        streams = streamsDecoded0
        let lastEvaluatedStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastEvaluatedStreamArn)
        lastEvaluatedStreamArn = lastEvaluatedStreamArnDecoded
    }
}

extension DynamoDbStreamsClientTypes {
    public enum OperationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case insert
        case modify
        case remove
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationType] {
            return [
                .insert,
                .modify,
                .remove,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .insert: return "INSERT"
            case .modify: return "MODIFY"
            case .remove: return "REMOVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationType(rawValue: rawValue) ?? OperationType.sdkUnknown(rawValue)
        }
    }
}

extension DynamoDbStreamsClientTypes.Record: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion
        case dynamodb
        case eventID
        case eventName
        case eventSource
        case eventVersion
        case userIdentity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let dynamodb = dynamodb {
            try encodeContainer.encode(dynamodb, forKey: .dynamodb)
        }
        if let eventID = eventID {
            try encodeContainer.encode(eventID, forKey: .eventID)
        }
        if let eventName = eventName {
            try encodeContainer.encode(eventName.rawValue, forKey: .eventName)
        }
        if let eventSource = eventSource {
            try encodeContainer.encode(eventSource, forKey: .eventSource)
        }
        if let eventVersion = eventVersion {
            try encodeContainer.encode(eventVersion, forKey: .eventVersion)
        }
        if let userIdentity = userIdentity {
            try encodeContainer.encode(userIdentity, forKey: .userIdentity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventID)
        eventID = eventIDDecoded
        let eventNameDecoded = try containerValues.decodeIfPresent(DynamoDbStreamsClientTypes.OperationType.self, forKey: .eventName)
        eventName = eventNameDecoded
        let eventVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventVersion)
        eventVersion = eventVersionDecoded
        let eventSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSource)
        eventSource = eventSourceDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let dynamodbDecoded = try containerValues.decodeIfPresent(DynamoDbStreamsClientTypes.StreamRecord.self, forKey: .dynamodb)
        dynamodb = dynamodbDecoded
        let userIdentityDecoded = try containerValues.decodeIfPresent(DynamoDbStreamsClientTypes.Identity.self, forKey: .userIdentity)
        userIdentity = userIdentityDecoded
    }
}

extension DynamoDbStreamsClientTypes {
    /// A description of a unique event within a stream.
    public struct Record: Swift.Equatable {
        /// The region in which the GetRecords request was received.
        public var awsRegion: Swift.String?
        /// The main body of the stream record, containing all of the DynamoDB-specific fields.
        public var dynamodb: DynamoDbStreamsClientTypes.StreamRecord?
        /// A globally unique identifier for the event that was recorded in this stream record.
        public var eventID: Swift.String?
        /// The type of data modification that was performed on the DynamoDB table:
        ///
        /// * INSERT - a new item was added to the table.
        ///
        /// * MODIFY - one or more of an existing item's attributes were modified.
        ///
        /// * REMOVE - the item was deleted from the table
        public var eventName: DynamoDbStreamsClientTypes.OperationType?
        /// The AWS service from which the stream record originated. For DynamoDB Streams, this is aws:dynamodb.
        public var eventSource: Swift.String?
        /// The version number of the stream record format. This number is updated whenever the structure of Record is modified. Client applications must not assume that eventVersion will remain at a particular value, as this number is subject to change at any time. In general, eventVersion will only increase as the low-level DynamoDB Streams API evolves.
        public var eventVersion: Swift.String?
        /// Items that are deleted by the Time to Live process after expiration have the following fields:
        ///
        /// * Records[].userIdentity.type "Service"
        ///
        /// * Records[].userIdentity.principalId "dynamodb.amazonaws.com"
        public var userIdentity: DynamoDbStreamsClientTypes.Identity?

        public init (
            awsRegion: Swift.String? = nil,
            dynamodb: DynamoDbStreamsClientTypes.StreamRecord? = nil,
            eventID: Swift.String? = nil,
            eventName: DynamoDbStreamsClientTypes.OperationType? = nil,
            eventSource: Swift.String? = nil,
            eventVersion: Swift.String? = nil,
            userIdentity: DynamoDbStreamsClientTypes.Identity? = nil
        )
        {
            self.awsRegion = awsRegion
            self.dynamodb = dynamodb
            self.eventID = eventID
            self.eventName = eventName
            self.eventSource = eventSource
            self.eventVersion = eventVersion
            self.userIdentity = userIdentity
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation tried to access a nonexistent table or index. The resource might not be specified correctly, or its status might not be ACTIVE.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The resource which is being requested does not exist.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DynamoDbStreamsClientTypes.SequenceNumberRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endingSequenceNumber = "EndingSequenceNumber"
        case startingSequenceNumber = "StartingSequenceNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endingSequenceNumber = endingSequenceNumber {
            try encodeContainer.encode(endingSequenceNumber, forKey: .endingSequenceNumber)
        }
        if let startingSequenceNumber = startingSequenceNumber {
            try encodeContainer.encode(startingSequenceNumber, forKey: .startingSequenceNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startingSequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startingSequenceNumber)
        startingSequenceNumber = startingSequenceNumberDecoded
        let endingSequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endingSequenceNumber)
        endingSequenceNumber = endingSequenceNumberDecoded
    }
}

extension DynamoDbStreamsClientTypes {
    /// The beginning and ending sequence numbers for the stream records contained within a shard.
    public struct SequenceNumberRange: Swift.Equatable {
        /// The last sequence number for the stream records contained within a shard. String contains numeric characters only.
        public var endingSequenceNumber: Swift.String?
        /// The first sequence number for the stream records contained within a shard. String contains numeric characters only.
        public var startingSequenceNumber: Swift.String?

        public init (
            endingSequenceNumber: Swift.String? = nil,
            startingSequenceNumber: Swift.String? = nil
        )
        {
            self.endingSequenceNumber = endingSequenceNumber
            self.startingSequenceNumber = startingSequenceNumber
        }
    }

}

extension DynamoDbStreamsClientTypes.Shard: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parentShardId = "ParentShardId"
        case sequenceNumberRange = "SequenceNumberRange"
        case shardId = "ShardId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parentShardId = parentShardId {
            try encodeContainer.encode(parentShardId, forKey: .parentShardId)
        }
        if let sequenceNumberRange = sequenceNumberRange {
            try encodeContainer.encode(sequenceNumberRange, forKey: .sequenceNumberRange)
        }
        if let shardId = shardId {
            try encodeContainer.encode(shardId, forKey: .shardId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shardId)
        shardId = shardIdDecoded
        let sequenceNumberRangeDecoded = try containerValues.decodeIfPresent(DynamoDbStreamsClientTypes.SequenceNumberRange.self, forKey: .sequenceNumberRange)
        sequenceNumberRange = sequenceNumberRangeDecoded
        let parentShardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentShardId)
        parentShardId = parentShardIdDecoded
    }
}

extension DynamoDbStreamsClientTypes {
    /// A uniquely identified group of stream records within a stream.
    public struct Shard: Swift.Equatable {
        /// The shard ID of the current shard's parent.
        public var parentShardId: Swift.String?
        /// The range of possible sequence numbers for the shard.
        public var sequenceNumberRange: DynamoDbStreamsClientTypes.SequenceNumberRange?
        /// The system-generated identifier for this shard.
        public var shardId: Swift.String?

        public init (
            parentShardId: Swift.String? = nil,
            sequenceNumberRange: DynamoDbStreamsClientTypes.SequenceNumberRange? = nil,
            shardId: Swift.String? = nil
        )
        {
            self.parentShardId = parentShardId
            self.sequenceNumberRange = sequenceNumberRange
            self.shardId = shardId
        }
    }

}

extension DynamoDbStreamsClientTypes {
    public enum ShardIteratorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case afterSequenceNumber
        case atSequenceNumber
        case latest
        case trimHorizon
        case sdkUnknown(Swift.String)

        public static var allCases: [ShardIteratorType] {
            return [
                .afterSequenceNumber,
                .atSequenceNumber,
                .latest,
                .trimHorizon,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .afterSequenceNumber: return "AFTER_SEQUENCE_NUMBER"
            case .atSequenceNumber: return "AT_SEQUENCE_NUMBER"
            case .latest: return "LATEST"
            case .trimHorizon: return "TRIM_HORIZON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShardIteratorType(rawValue: rawValue) ?? ShardIteratorType.sdkUnknown(rawValue)
        }
    }
}

extension DynamoDbStreamsClientTypes.Stream: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamArn = "StreamArn"
        case streamLabel = "StreamLabel"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamArn = streamArn {
            try encodeContainer.encode(streamArn, forKey: .streamArn)
        }
        if let streamLabel = streamLabel {
            try encodeContainer.encode(streamLabel, forKey: .streamLabel)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let streamLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamLabel)
        streamLabel = streamLabelDecoded
    }
}

extension DynamoDbStreamsClientTypes {
    /// Represents all of the data describing a particular stream.
    public struct Stream: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the stream.
        public var streamArn: Swift.String?
        /// A timestamp, in ISO 8601 format, for this stream. Note that LatestStreamLabel is not a unique identifier for the stream, because it is possible that a stream from another table might have the same timestamp. However, the combination of the following three elements is guaranteed to be unique:
        ///
        /// * the AWS customer ID.
        ///
        /// * the table name
        ///
        /// * the StreamLabel
        public var streamLabel: Swift.String?
        /// The DynamoDB table with which the stream is associated.
        public var tableName: Swift.String?

        public init (
            streamArn: Swift.String? = nil,
            streamLabel: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.streamArn = streamArn
            self.streamLabel = streamLabel
            self.tableName = tableName
        }
    }

}

extension DynamoDbStreamsClientTypes.StreamDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationRequestDateTime = "CreationRequestDateTime"
        case keySchema = "KeySchema"
        case lastEvaluatedShardId = "LastEvaluatedShardId"
        case shards = "Shards"
        case streamArn = "StreamArn"
        case streamLabel = "StreamLabel"
        case streamStatus = "StreamStatus"
        case streamViewType = "StreamViewType"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationRequestDateTime = creationRequestDateTime {
            try encodeContainer.encode(creationRequestDateTime.timeIntervalSince1970, forKey: .creationRequestDateTime)
        }
        if let keySchema = keySchema {
            var keySchemaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keySchema)
            for keyschema0 in keySchema {
                try keySchemaContainer.encode(keyschema0)
            }
        }
        if let lastEvaluatedShardId = lastEvaluatedShardId {
            try encodeContainer.encode(lastEvaluatedShardId, forKey: .lastEvaluatedShardId)
        }
        if let shards = shards {
            var shardsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .shards)
            for sharddescriptionlist0 in shards {
                try shardsContainer.encode(sharddescriptionlist0)
            }
        }
        if let streamArn = streamArn {
            try encodeContainer.encode(streamArn, forKey: .streamArn)
        }
        if let streamLabel = streamLabel {
            try encodeContainer.encode(streamLabel, forKey: .streamLabel)
        }
        if let streamStatus = streamStatus {
            try encodeContainer.encode(streamStatus.rawValue, forKey: .streamStatus)
        }
        if let streamViewType = streamViewType {
            try encodeContainer.encode(streamViewType.rawValue, forKey: .streamViewType)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
        let streamLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamLabel)
        streamLabel = streamLabelDecoded
        let streamStatusDecoded = try containerValues.decodeIfPresent(DynamoDbStreamsClientTypes.StreamStatus.self, forKey: .streamStatus)
        streamStatus = streamStatusDecoded
        let streamViewTypeDecoded = try containerValues.decodeIfPresent(DynamoDbStreamsClientTypes.StreamViewType.self, forKey: .streamViewType)
        streamViewType = streamViewTypeDecoded
        let creationRequestDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationRequestDateTime)
        creationRequestDateTime = creationRequestDateTimeDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let keySchemaContainer = try containerValues.decodeIfPresent([DynamoDbStreamsClientTypes.KeySchemaElement?].self, forKey: .keySchema)
        var keySchemaDecoded0:[DynamoDbStreamsClientTypes.KeySchemaElement]? = nil
        if let keySchemaContainer = keySchemaContainer {
            keySchemaDecoded0 = [DynamoDbStreamsClientTypes.KeySchemaElement]()
            for structure0 in keySchemaContainer {
                if let structure0 = structure0 {
                    keySchemaDecoded0?.append(structure0)
                }
            }
        }
        keySchema = keySchemaDecoded0
        let shardsContainer = try containerValues.decodeIfPresent([DynamoDbStreamsClientTypes.Shard?].self, forKey: .shards)
        var shardsDecoded0:[DynamoDbStreamsClientTypes.Shard]? = nil
        if let shardsContainer = shardsContainer {
            shardsDecoded0 = [DynamoDbStreamsClientTypes.Shard]()
            for structure0 in shardsContainer {
                if let structure0 = structure0 {
                    shardsDecoded0?.append(structure0)
                }
            }
        }
        shards = shardsDecoded0
        let lastEvaluatedShardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastEvaluatedShardId)
        lastEvaluatedShardId = lastEvaluatedShardIdDecoded
    }
}

extension DynamoDbStreamsClientTypes {
    /// Represents all of the data describing a particular stream.
    public struct StreamDescription: Swift.Equatable {
        /// The date and time when the request to create this stream was issued.
        public var creationRequestDateTime: ClientRuntime.Date?
        /// The key attribute(s) of the stream's DynamoDB table.
        public var keySchema: [DynamoDbStreamsClientTypes.KeySchemaElement]?
        /// The shard ID of the item where the operation stopped, inclusive of the previous result set. Use this value to start a new operation, excluding this value in the new request. If LastEvaluatedShardId is empty, then the "last page" of results has been processed and there is currently no more data to be retrieved. If LastEvaluatedShardId is not empty, it does not necessarily mean that there is more data in the result set. The only way to know when you have reached the end of the result set is when LastEvaluatedShardId is empty.
        public var lastEvaluatedShardId: Swift.String?
        /// The shards that comprise the stream.
        public var shards: [DynamoDbStreamsClientTypes.Shard]?
        /// The Amazon Resource Name (ARN) for the stream.
        public var streamArn: Swift.String?
        /// A timestamp, in ISO 8601 format, for this stream. Note that LatestStreamLabel is not a unique identifier for the stream, because it is possible that a stream from another table might have the same timestamp. However, the combination of the following three elements is guaranteed to be unique:
        ///
        /// * the AWS customer ID.
        ///
        /// * the table name
        ///
        /// * the StreamLabel
        public var streamLabel: Swift.String?
        /// Indicates the current status of the stream:
        ///
        /// * ENABLING - Streams is currently being enabled on the DynamoDB table.
        ///
        /// * ENABLED - the stream is enabled.
        ///
        /// * DISABLING - Streams is currently being disabled on the DynamoDB table.
        ///
        /// * DISABLED - the stream is disabled.
        public var streamStatus: DynamoDbStreamsClientTypes.StreamStatus?
        /// Indicates the format of the records within this stream:
        ///
        /// * KEYS_ONLY - only the key attributes of items that were modified in the DynamoDB table.
        ///
        /// * NEW_IMAGE - entire items from the table, as they appeared after they were modified.
        ///
        /// * OLD_IMAGE - entire items from the table, as they appeared before they were modified.
        ///
        /// * NEW_AND_OLD_IMAGES - both the new and the old images of the items from the table.
        public var streamViewType: DynamoDbStreamsClientTypes.StreamViewType?
        /// The DynamoDB table with which the stream is associated.
        public var tableName: Swift.String?

        public init (
            creationRequestDateTime: ClientRuntime.Date? = nil,
            keySchema: [DynamoDbStreamsClientTypes.KeySchemaElement]? = nil,
            lastEvaluatedShardId: Swift.String? = nil,
            shards: [DynamoDbStreamsClientTypes.Shard]? = nil,
            streamArn: Swift.String? = nil,
            streamLabel: Swift.String? = nil,
            streamStatus: DynamoDbStreamsClientTypes.StreamStatus? = nil,
            streamViewType: DynamoDbStreamsClientTypes.StreamViewType? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.creationRequestDateTime = creationRequestDateTime
            self.keySchema = keySchema
            self.lastEvaluatedShardId = lastEvaluatedShardId
            self.shards = shards
            self.streamArn = streamArn
            self.streamLabel = streamLabel
            self.streamStatus = streamStatus
            self.streamViewType = streamViewType
            self.tableName = tableName
        }
    }

}

extension DynamoDbStreamsClientTypes.StreamRecord: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateCreationDateTime = "ApproximateCreationDateTime"
        case keys = "Keys"
        case newImage = "NewImage"
        case oldImage = "OldImage"
        case sequenceNumber = "SequenceNumber"
        case sizeBytes = "SizeBytes"
        case streamViewType = "StreamViewType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approximateCreationDateTime = approximateCreationDateTime {
            try encodeContainer.encode(approximateCreationDateTime.timeIntervalSince1970, forKey: .approximateCreationDateTime)
        }
        if let keys = keys {
            var keysContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .keys)
            for (dictKey0, attributemap0) in keys {
                try keysContainer.encode(attributemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let newImage = newImage {
            var newImageContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .newImage)
            for (dictKey0, attributemap0) in newImage {
                try newImageContainer.encode(attributemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let oldImage = oldImage {
            var oldImageContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .oldImage)
            for (dictKey0, attributemap0) in oldImage {
                try oldImageContainer.encode(attributemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sequenceNumber = sequenceNumber {
            try encodeContainer.encode(sequenceNumber, forKey: .sequenceNumber)
        }
        if let sizeBytes = sizeBytes {
            try encodeContainer.encode(sizeBytes, forKey: .sizeBytes)
        }
        if let streamViewType = streamViewType {
            try encodeContainer.encode(streamViewType.rawValue, forKey: .streamViewType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approximateCreationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .approximateCreationDateTime)
        approximateCreationDateTime = approximateCreationDateTimeDecoded
        let keysContainer = try containerValues.decodeIfPresent([Swift.String: DynamoDbStreamsClientTypes.AttributeValue?].self, forKey: .keys)
        var keysDecoded0: [Swift.String:DynamoDbStreamsClientTypes.AttributeValue]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [Swift.String:DynamoDbStreamsClientTypes.AttributeValue]()
            for (key0, attributevalue0) in keysContainer {
                if let attributevalue0 = attributevalue0 {
                    keysDecoded0?[key0] = attributevalue0
                }
            }
        }
        keys = keysDecoded0
        let newImageContainer = try containerValues.decodeIfPresent([Swift.String: DynamoDbStreamsClientTypes.AttributeValue?].self, forKey: .newImage)
        var newImageDecoded0: [Swift.String:DynamoDbStreamsClientTypes.AttributeValue]? = nil
        if let newImageContainer = newImageContainer {
            newImageDecoded0 = [Swift.String:DynamoDbStreamsClientTypes.AttributeValue]()
            for (key0, attributevalue0) in newImageContainer {
                if let attributevalue0 = attributevalue0 {
                    newImageDecoded0?[key0] = attributevalue0
                }
            }
        }
        newImage = newImageDecoded0
        let oldImageContainer = try containerValues.decodeIfPresent([Swift.String: DynamoDbStreamsClientTypes.AttributeValue?].self, forKey: .oldImage)
        var oldImageDecoded0: [Swift.String:DynamoDbStreamsClientTypes.AttributeValue]? = nil
        if let oldImageContainer = oldImageContainer {
            oldImageDecoded0 = [Swift.String:DynamoDbStreamsClientTypes.AttributeValue]()
            for (key0, attributevalue0) in oldImageContainer {
                if let attributevalue0 = attributevalue0 {
                    oldImageDecoded0?[key0] = attributevalue0
                }
            }
        }
        oldImage = oldImageDecoded0
        let sequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceNumber)
        sequenceNumber = sequenceNumberDecoded
        let sizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sizeBytes)
        sizeBytes = sizeBytesDecoded
        let streamViewTypeDecoded = try containerValues.decodeIfPresent(DynamoDbStreamsClientTypes.StreamViewType.self, forKey: .streamViewType)
        streamViewType = streamViewTypeDecoded
    }
}

extension DynamoDbStreamsClientTypes {
    /// A description of a single data modification that was performed on an item in a DynamoDB table.
    public struct StreamRecord: Swift.Equatable {
        /// The approximate date and time when the stream record was created, in [UNIX epoch time](http://www.epochconverter.com/) format.
        public var approximateCreationDateTime: ClientRuntime.Date?
        /// The primary key attribute(s) for the DynamoDB item that was modified.
        public var keys: [Swift.String:DynamoDbStreamsClientTypes.AttributeValue]?
        /// The item in the DynamoDB table as it appeared after it was modified.
        public var newImage: [Swift.String:DynamoDbStreamsClientTypes.AttributeValue]?
        /// The item in the DynamoDB table as it appeared before it was modified.
        public var oldImage: [Swift.String:DynamoDbStreamsClientTypes.AttributeValue]?
        /// The sequence number of the stream record.
        public var sequenceNumber: Swift.String?
        /// The size of the stream record, in bytes.
        public var sizeBytes: Swift.Int?
        /// The type of data from the modified DynamoDB item that was captured in this stream record:
        ///
        /// * KEYS_ONLY - only the key attributes of the modified item.
        ///
        /// * NEW_IMAGE - the entire item, as it appeared after it was modified.
        ///
        /// * OLD_IMAGE - the entire item, as it appeared before it was modified.
        ///
        /// * NEW_AND_OLD_IMAGES - both the new and the old item images of the item.
        public var streamViewType: DynamoDbStreamsClientTypes.StreamViewType?

        public init (
            approximateCreationDateTime: ClientRuntime.Date? = nil,
            keys: [Swift.String:DynamoDbStreamsClientTypes.AttributeValue]? = nil,
            newImage: [Swift.String:DynamoDbStreamsClientTypes.AttributeValue]? = nil,
            oldImage: [Swift.String:DynamoDbStreamsClientTypes.AttributeValue]? = nil,
            sequenceNumber: Swift.String? = nil,
            sizeBytes: Swift.Int? = nil,
            streamViewType: DynamoDbStreamsClientTypes.StreamViewType? = nil
        )
        {
            self.approximateCreationDateTime = approximateCreationDateTime
            self.keys = keys
            self.newImage = newImage
            self.oldImage = oldImage
            self.sequenceNumber = sequenceNumber
            self.sizeBytes = sizeBytes
            self.streamViewType = streamViewType
        }
    }

}

extension DynamoDbStreamsClientTypes {
    public enum StreamStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case disabling
        case enabled
        case enabling
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamStatus] {
            return [
                .disabled,
                .disabling,
                .enabled,
                .enabling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disabling: return "DISABLING"
            case .enabled: return "ENABLED"
            case .enabling: return "ENABLING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamStatus(rawValue: rawValue) ?? StreamStatus.sdkUnknown(rawValue)
        }
    }
}

extension DynamoDbStreamsClientTypes {
    public enum StreamViewType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case keysOnly
        case newAndOldImages
        case newImage
        case oldImage
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamViewType] {
            return [
                .keysOnly,
                .newAndOldImages,
                .newImage,
                .oldImage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .keysOnly: return "KEYS_ONLY"
            case .newAndOldImages: return "NEW_AND_OLD_IMAGES"
            case .newImage: return "NEW_IMAGE"
            case .oldImage: return "OLD_IMAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamViewType(rawValue: rawValue) ?? StreamViewType.sdkUnknown(rawValue)
        }
    }
}

extension TrimmedDataAccessException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TrimmedDataAccessExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation attempted to read past the oldest stream record in a shard. In DynamoDB Streams, there is a 24 hour limit on data retention. Stream records whose age exceeds this limit are subject to removal (trimming) from the stream. You might receive a TrimmedDataAccessException if:
///
/// * You request a shard iterator with a sequence number older than the trim point (24 hours).
///
/// * You obtain a shard iterator, but before you use the iterator in a GetRecords request, a stream record in the shard exceeds the 24 hour period and is trimmed. This causes the iterator to access a record that no longer exists.
public struct TrimmedDataAccessException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// "The data you are trying to access has been trimmed.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TrimmedDataAccessExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TrimmedDataAccessExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
