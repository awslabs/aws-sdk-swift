// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension SavingsPlan: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commitment
        case currency
        case description
        case ec2InstanceFamily
        case end
        case offeringId
        case paymentOption
        case productTypes
        case recurringPaymentAmount
        case region
        case savingsPlanArn
        case savingsPlanId
        case savingsPlanType
        case start
        case state
        case tags
        case termDurationInSeconds
        case upfrontPaymentAmount
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitment = commitment {
            try encodeContainer.encode(commitment, forKey: .commitment)
        }
        if let currency = currency {
            try encodeContainer.encode(currency.rawValue, forKey: .currency)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2InstanceFamily = ec2InstanceFamily {
            try encodeContainer.encode(ec2InstanceFamily, forKey: .ec2InstanceFamily)
        }
        if let end = end {
            try encodeContainer.encode(end, forKey: .end)
        }
        if let offeringId = offeringId {
            try encodeContainer.encode(offeringId, forKey: .offeringId)
        }
        if let paymentOption = paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let productTypes = productTypes {
            var productTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productTypes)
            for savingsplanproducttypelist0 in productTypes {
                try productTypesContainer.encode(savingsplanproducttypelist0.rawValue)
            }
        }
        if let recurringPaymentAmount = recurringPaymentAmount {
            try encodeContainer.encode(recurringPaymentAmount, forKey: .recurringPaymentAmount)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let savingsPlanArn = savingsPlanArn {
            try encodeContainer.encode(savingsPlanArn, forKey: .savingsPlanArn)
        }
        if let savingsPlanId = savingsPlanId {
            try encodeContainer.encode(savingsPlanId, forKey: .savingsPlanId)
        }
        if let savingsPlanType = savingsPlanType {
            try encodeContainer.encode(savingsPlanType.rawValue, forKey: .savingsPlanType)
        }
        if let start = start {
            try encodeContainer.encode(start, forKey: .start)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if termDurationInSeconds != 0 {
            try encodeContainer.encode(termDurationInSeconds, forKey: .termDurationInSeconds)
        }
        if let upfrontPaymentAmount = upfrontPaymentAmount {
            try encodeContainer.encode(upfrontPaymentAmount, forKey: .upfrontPaymentAmount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .offeringId)
        offeringId = offeringIdDecoded
        let savingsPlanIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .savingsPlanId)
        savingsPlanId = savingsPlanIdDecoded
        let savingsPlanArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .savingsPlanArn)
        savingsPlanArn = savingsPlanArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let startDecoded = try containerValues.decodeIfPresent(String.self, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decodeIfPresent(String.self, forKey: .end)
        end = endDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SavingsPlanState.self, forKey: .state)
        state = stateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let ec2InstanceFamilyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ec2InstanceFamily)
        ec2InstanceFamily = ec2InstanceFamilyDecoded
        let savingsPlanTypeDecoded = try containerValues.decodeIfPresent(SavingsPlanType.self, forKey: .savingsPlanType)
        savingsPlanType = savingsPlanTypeDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(SavingsPlanPaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let productTypesContainer = try containerValues.decodeIfPresent([SavingsPlanProductType].self, forKey: .productTypes)
        var productTypesDecoded0:[SavingsPlanProductType]? = nil
        if let productTypesContainer = productTypesContainer {
            productTypesDecoded0 = [SavingsPlanProductType]()
            for string0 in productTypesContainer {
                productTypesDecoded0?.append(string0)
            }
        }
        productTypes = productTypesDecoded0
        let currencyDecoded = try containerValues.decodeIfPresent(CurrencyCode.self, forKey: .currency)
        currency = currencyDecoded
        let commitmentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitment)
        commitment = commitmentDecoded
        let upfrontPaymentAmountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .upfrontPaymentAmount)
        upfrontPaymentAmount = upfrontPaymentAmountDecoded
        let recurringPaymentAmountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recurringPaymentAmount)
        recurringPaymentAmount = recurringPaymentAmountDecoded
        let termDurationInSecondsDecoded = try containerValues.decode(Int.self, forKey: .termDurationInSeconds)
        termDurationInSeconds = termDurationInSecondsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String:String].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                tagsDecoded0?[key0] = tagvalue0
            }
        }
        tags = tagsDecoded0
    }
}
