// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct CreateSavingsPlanInputBodyMiddleware: Middleware {
    public let id: String = "CreateSavingsPlanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSavingsPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSavingsPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSavingsPlanInput>
    public typealias MOutput = OperationOutput<CreateSavingsPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSavingsPlanOutputError>
}

extension CreateSavingsPlanInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSavingsPlanInput(clientToken: \(String(describing: clientToken)), commitment: \(String(describing: commitment)), purchaseTime: \(String(describing: purchaseTime)), savingsPlanOfferingId: \(String(describing: savingsPlanOfferingId)), tags: \(String(describing: tags)), upfrontPaymentAmount: \(String(describing: upfrontPaymentAmount)))"}
}

extension CreateSavingsPlanInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case commitment
        case purchaseTime
        case savingsPlanOfferingId
        case tags
        case upfrontPaymentAmount
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let commitment = commitment {
            try encodeContainer.encode(commitment, forKey: .commitment)
        }
        if let purchaseTime = purchaseTime {
            try encodeContainer.encode(purchaseTime.timeIntervalSince1970, forKey: .purchaseTime)
        }
        if let savingsPlanOfferingId = savingsPlanOfferingId {
            try encodeContainer.encode(savingsPlanOfferingId, forKey: .savingsPlanOfferingId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let upfrontPaymentAmount = upfrontPaymentAmount {
            try encodeContainer.encode(upfrontPaymentAmount, forKey: .upfrontPaymentAmount)
        }
    }
}

public struct CreateSavingsPlanInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSavingsPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSavingsPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSavingsPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSavingsPlanInput>
    public typealias MOutput = OperationOutput<CreateSavingsPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSavingsPlanOutputError>
}

public struct CreateSavingsPlanInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSavingsPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSavingsPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSavingsPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSavingsPlanInput>
    public typealias MOutput = OperationOutput<CreateSavingsPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSavingsPlanOutputError>
}

public struct CreateSavingsPlanInput: Equatable {
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public var clientToken: String?
    /// <p>The hourly commitment, in USD. This is a value between 0.001 and 1 million. You cannot specify more
    ///         than three digits after the decimal point.</p>
    public let commitment: String?
    /// <p>The time at which to purchase the Savings Plan, in UTC format (YYYY-MM-DDTHH:MM:SSZ).</p>
    public let purchaseTime: Date?
    /// <p>The ID of the offering.</p>
    public let savingsPlanOfferingId: String?
    /// <p>One or more tags.</p>
    public let tags: [String:String]?
    /// <p>The up-front payment amount. This is a whole number between 50 and 99 percent of the total value of the Savings Plan.
    ///        This parameter is supported only if the payment option is <code>Partial Upfront</code>.</p>
    public let upfrontPaymentAmount: String?

    public init (
        clientToken: String? = nil,
        commitment: String? = nil,
        purchaseTime: Date? = nil,
        savingsPlanOfferingId: String? = nil,
        tags: [String:String]? = nil,
        upfrontPaymentAmount: String? = nil
    )
    {
        self.clientToken = clientToken
        self.commitment = commitment
        self.purchaseTime = purchaseTime
        self.savingsPlanOfferingId = savingsPlanOfferingId
        self.tags = tags
        self.upfrontPaymentAmount = upfrontPaymentAmount
    }
}

struct CreateSavingsPlanInputBody: Equatable {
    public let savingsPlanOfferingId: String?
    public let commitment: String?
    public let upfrontPaymentAmount: String?
    public let purchaseTime: Date?
    public let clientToken: String?
    public let tags: [String:String]?
}

extension CreateSavingsPlanInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case commitment
        case purchaseTime
        case savingsPlanOfferingId
        case tags
        case upfrontPaymentAmount
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlanOfferingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .savingsPlanOfferingId)
        savingsPlanOfferingId = savingsPlanOfferingIdDecoded
        let commitmentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitment)
        commitment = commitmentDecoded
        let upfrontPaymentAmountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .upfrontPaymentAmount)
        upfrontPaymentAmount = upfrontPaymentAmountDecoded
        let purchaseTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .purchaseTime)
        purchaseTime = purchaseTimeDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSavingsPlanOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSavingsPlanOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSavingsPlanOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSavingsPlanOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSavingsPlanOutputResponse(savingsPlanId: \(String(describing: savingsPlanId)))"}
}

extension CreateSavingsPlanOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSavingsPlanOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.savingsPlanId = output.savingsPlanId
        } else {
            self.savingsPlanId = nil
        }
    }
}

public struct CreateSavingsPlanOutputResponse: Equatable {
    /// <p>The ID of the Savings Plan.</p>
    public let savingsPlanId: String?

    public init (
        savingsPlanId: String? = nil
    )
    {
        self.savingsPlanId = savingsPlanId
    }
}

struct CreateSavingsPlanOutputResponseBody: Equatable {
    public let savingsPlanId: String?
}

extension CreateSavingsPlanOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case savingsPlanId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlanIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .savingsPlanId)
        savingsPlanId = savingsPlanIdDecoded
    }
}

public enum CurrencyCode {
    case cny
    case usd
    case sdkUnknown(String)
}

extension CurrencyCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CurrencyCode] {
        return [
            .cny,
            .usd,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cny: return "CNY"
        case .usd: return "USD"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CurrencyCode(rawValue: rawValue) ?? CurrencyCode.sdkUnknown(rawValue)
    }
}

public struct DeleteQueuedSavingsPlanInputBodyMiddleware: Middleware {
    public let id: String = "DeleteQueuedSavingsPlanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteQueuedSavingsPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteQueuedSavingsPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteQueuedSavingsPlanInput>
    public typealias MOutput = OperationOutput<DeleteQueuedSavingsPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteQueuedSavingsPlanOutputError>
}

extension DeleteQueuedSavingsPlanInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteQueuedSavingsPlanInput(savingsPlanId: \(String(describing: savingsPlanId)))"}
}

extension DeleteQueuedSavingsPlanInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case savingsPlanId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let savingsPlanId = savingsPlanId {
            try encodeContainer.encode(savingsPlanId, forKey: .savingsPlanId)
        }
    }
}

public struct DeleteQueuedSavingsPlanInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteQueuedSavingsPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteQueuedSavingsPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteQueuedSavingsPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteQueuedSavingsPlanInput>
    public typealias MOutput = OperationOutput<DeleteQueuedSavingsPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteQueuedSavingsPlanOutputError>
}

public struct DeleteQueuedSavingsPlanInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteQueuedSavingsPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteQueuedSavingsPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteQueuedSavingsPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteQueuedSavingsPlanInput>
    public typealias MOutput = OperationOutput<DeleteQueuedSavingsPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteQueuedSavingsPlanOutputError>
}

public struct DeleteQueuedSavingsPlanInput: Equatable {
    /// <p>The ID of the Savings Plan.</p>
    public let savingsPlanId: String?

    public init (
        savingsPlanId: String? = nil
    )
    {
        self.savingsPlanId = savingsPlanId
    }
}

struct DeleteQueuedSavingsPlanInputBody: Equatable {
    public let savingsPlanId: String?
}

extension DeleteQueuedSavingsPlanInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case savingsPlanId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlanIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .savingsPlanId)
        savingsPlanId = savingsPlanIdDecoded
    }
}

extension DeleteQueuedSavingsPlanOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteQueuedSavingsPlanOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteQueuedSavingsPlanOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteQueuedSavingsPlanOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteQueuedSavingsPlanOutputResponse()"}
}

extension DeleteQueuedSavingsPlanOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteQueuedSavingsPlanOutputResponse: Equatable {

    public init() {}
}

struct DeleteQueuedSavingsPlanOutputResponseBody: Equatable {
}

extension DeleteQueuedSavingsPlanOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeSavingsPlanRatesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSavingsPlanRatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSavingsPlanRatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSavingsPlanRatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSavingsPlanRatesInput>
    public typealias MOutput = OperationOutput<DescribeSavingsPlanRatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSavingsPlanRatesOutputError>
}

extension DescribeSavingsPlanRatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSavingsPlanRatesInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), savingsPlanId: \(String(describing: savingsPlanId)))"}
}

extension DescribeSavingsPlanRatesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
        case savingsPlanId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for savingsplanratefilterlist0 in filters {
                try filtersContainer.encode(savingsplanratefilterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let savingsPlanId = savingsPlanId {
            try encodeContainer.encode(savingsPlanId, forKey: .savingsPlanId)
        }
    }
}

public struct DescribeSavingsPlanRatesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSavingsPlanRatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSavingsPlanRatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSavingsPlanRatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSavingsPlanRatesInput>
    public typealias MOutput = OperationOutput<DescribeSavingsPlanRatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSavingsPlanRatesOutputError>
}

public struct DescribeSavingsPlanRatesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSavingsPlanRatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSavingsPlanRatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSavingsPlanRatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSavingsPlanRatesInput>
    public typealias MOutput = OperationOutput<DescribeSavingsPlanRatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSavingsPlanRatesOutputError>
}

public struct DescribeSavingsPlanRatesInput: Equatable {
    /// <p>The filters.</p>
    public let filters: [SavingsPlanRateFilter]?
    /// <p>The maximum number of results to return with a single call. To retrieve additional results, make another
    ///          call with the returned token value.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>The ID of the Savings Plan.</p>
    public let savingsPlanId: String?

    public init (
        filters: [SavingsPlanRateFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        savingsPlanId: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.savingsPlanId = savingsPlanId
    }
}

struct DescribeSavingsPlanRatesInputBody: Equatable {
    public let savingsPlanId: String?
    public let filters: [SavingsPlanRateFilter]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeSavingsPlanRatesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
        case savingsPlanId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlanIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .savingsPlanId)
        savingsPlanId = savingsPlanIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SavingsPlanRateFilter?].self, forKey: .filters)
        var filtersDecoded0:[SavingsPlanRateFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SavingsPlanRateFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeSavingsPlanRatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSavingsPlanRatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSavingsPlanRatesOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSavingsPlanRatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSavingsPlanRatesOutputResponse(nextToken: \(String(describing: nextToken)), savingsPlanId: \(String(describing: savingsPlanId)), searchResults: \(String(describing: searchResults)))"}
}

extension DescribeSavingsPlanRatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSavingsPlanRatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.savingsPlanId = output.savingsPlanId
            self.searchResults = output.searchResults
        } else {
            self.nextToken = nil
            self.savingsPlanId = nil
            self.searchResults = nil
        }
    }
}

public struct DescribeSavingsPlanRatesOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is null when there are no more
    ///          results to return.</p>
    public let nextToken: String?
    /// <p>The ID of the Savings Plan.</p>
    public let savingsPlanId: String?
    /// <p>Information about the Savings Plans rates.</p>
    public let searchResults: [SavingsPlanRate]?

    public init (
        nextToken: String? = nil,
        savingsPlanId: String? = nil,
        searchResults: [SavingsPlanRate]? = nil
    )
    {
        self.nextToken = nextToken
        self.savingsPlanId = savingsPlanId
        self.searchResults = searchResults
    }
}

struct DescribeSavingsPlanRatesOutputResponseBody: Equatable {
    public let savingsPlanId: String?
    public let searchResults: [SavingsPlanRate]?
    public let nextToken: String?
}

extension DescribeSavingsPlanRatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case savingsPlanId
        case searchResults
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlanIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .savingsPlanId)
        savingsPlanId = savingsPlanIdDecoded
        let searchResultsContainer = try containerValues.decodeIfPresent([SavingsPlanRate?].self, forKey: .searchResults)
        var searchResultsDecoded0:[SavingsPlanRate]? = nil
        if let searchResultsContainer = searchResultsContainer {
            searchResultsDecoded0 = [SavingsPlanRate]()
            for structure0 in searchResultsContainer {
                if let structure0 = structure0 {
                    searchResultsDecoded0?.append(structure0)
                }
            }
        }
        searchResults = searchResultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeSavingsPlansInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSavingsPlansInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSavingsPlansInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSavingsPlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSavingsPlansInput>
    public typealias MOutput = OperationOutput<DescribeSavingsPlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSavingsPlansOutputError>
}

extension DescribeSavingsPlansInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSavingsPlansInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), savingsPlanArns: \(String(describing: savingsPlanArns)), savingsPlanIds: \(String(describing: savingsPlanIds)), states: \(String(describing: states)))"}
}

extension DescribeSavingsPlansInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
        case savingsPlanArns
        case savingsPlanIds
        case states
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for savingsplanfilterlist0 in filters {
                try filtersContainer.encode(savingsplanfilterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let savingsPlanArns = savingsPlanArns {
            var savingsPlanArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .savingsPlanArns)
            for savingsplanarnlist0 in savingsPlanArns {
                try savingsPlanArnsContainer.encode(savingsplanarnlist0)
            }
        }
        if let savingsPlanIds = savingsPlanIds {
            var savingsPlanIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .savingsPlanIds)
            for savingsplanidlist0 in savingsPlanIds {
                try savingsPlanIdsContainer.encode(savingsplanidlist0)
            }
        }
        if let states = states {
            var statesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .states)
            for savingsplanstatelist0 in states {
                try statesContainer.encode(savingsplanstatelist0.rawValue)
            }
        }
    }
}

public struct DescribeSavingsPlansInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSavingsPlansInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSavingsPlansInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSavingsPlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSavingsPlansInput>
    public typealias MOutput = OperationOutput<DescribeSavingsPlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSavingsPlansOutputError>
}

public struct DescribeSavingsPlansInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSavingsPlansInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSavingsPlansInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSavingsPlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSavingsPlansInput>
    public typealias MOutput = OperationOutput<DescribeSavingsPlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSavingsPlansOutputError>
}

public struct DescribeSavingsPlansInput: Equatable {
    /// <p>The filters.</p>
    public let filters: [SavingsPlanFilter]?
    /// <p>The maximum number of results to return with a single call. To retrieve additional results, make another
    ///        call with the returned token value.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Names (ARN) of the Savings Plans.</p>
    public let savingsPlanArns: [String]?
    /// <p>The IDs of the Savings Plans.</p>
    public let savingsPlanIds: [String]?
    /// <p>The states.</p>
    public let states: [SavingsPlanState]?

    public init (
        filters: [SavingsPlanFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        savingsPlanArns: [String]? = nil,
        savingsPlanIds: [String]? = nil,
        states: [SavingsPlanState]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.savingsPlanArns = savingsPlanArns
        self.savingsPlanIds = savingsPlanIds
        self.states = states
    }
}

struct DescribeSavingsPlansInputBody: Equatable {
    public let savingsPlanArns: [String]?
    public let savingsPlanIds: [String]?
    public let nextToken: String?
    public let maxResults: Int?
    public let states: [SavingsPlanState]?
    public let filters: [SavingsPlanFilter]?
}

extension DescribeSavingsPlansInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
        case savingsPlanArns
        case savingsPlanIds
        case states
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlanArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .savingsPlanArns)
        var savingsPlanArnsDecoded0:[String]? = nil
        if let savingsPlanArnsContainer = savingsPlanArnsContainer {
            savingsPlanArnsDecoded0 = [String]()
            for string0 in savingsPlanArnsContainer {
                if let string0 = string0 {
                    savingsPlanArnsDecoded0?.append(string0)
                }
            }
        }
        savingsPlanArns = savingsPlanArnsDecoded0
        let savingsPlanIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .savingsPlanIds)
        var savingsPlanIdsDecoded0:[String]? = nil
        if let savingsPlanIdsContainer = savingsPlanIdsContainer {
            savingsPlanIdsDecoded0 = [String]()
            for string0 in savingsPlanIdsContainer {
                if let string0 = string0 {
                    savingsPlanIdsDecoded0?.append(string0)
                }
            }
        }
        savingsPlanIds = savingsPlanIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let statesContainer = try containerValues.decodeIfPresent([SavingsPlanState?].self, forKey: .states)
        var statesDecoded0:[SavingsPlanState]? = nil
        if let statesContainer = statesContainer {
            statesDecoded0 = [SavingsPlanState]()
            for string0 in statesContainer {
                if let string0 = string0 {
                    statesDecoded0?.append(string0)
                }
            }
        }
        states = statesDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([SavingsPlanFilter?].self, forKey: .filters)
        var filtersDecoded0:[SavingsPlanFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SavingsPlanFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

public struct DescribeSavingsPlansOfferingRatesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSavingsPlansOfferingRatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSavingsPlansOfferingRatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSavingsPlansOfferingRatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSavingsPlansOfferingRatesInput>
    public typealias MOutput = OperationOutput<DescribeSavingsPlansOfferingRatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSavingsPlansOfferingRatesOutputError>
}

extension DescribeSavingsPlansOfferingRatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSavingsPlansOfferingRatesInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), operations: \(String(describing: operations)), products: \(String(describing: products)), savingsPlanOfferingIds: \(String(describing: savingsPlanOfferingIds)), savingsPlanPaymentOptions: \(String(describing: savingsPlanPaymentOptions)), savingsPlanTypes: \(String(describing: savingsPlanTypes)), serviceCodes: \(String(describing: serviceCodes)), usageTypes: \(String(describing: usageTypes)))"}
}

extension DescribeSavingsPlansOfferingRatesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
        case operations
        case products
        case savingsPlanOfferingIds
        case savingsPlanPaymentOptions
        case savingsPlanTypes
        case serviceCodes
        case usageTypes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for savingsplanofferingratefilterslist0 in filters {
                try filtersContainer.encode(savingsplanofferingratefilterslist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let operations = operations {
            var operationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operations)
            for savingsplanrateoperationlist0 in operations {
                try operationsContainer.encode(savingsplanrateoperationlist0)
            }
        }
        if let products = products {
            var productsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .products)
            for savingsplanproducttypelist0 in products {
                try productsContainer.encode(savingsplanproducttypelist0.rawValue)
            }
        }
        if let savingsPlanOfferingIds = savingsPlanOfferingIds {
            var savingsPlanOfferingIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .savingsPlanOfferingIds)
            for uuids0 in savingsPlanOfferingIds {
                try savingsPlanOfferingIdsContainer.encode(uuids0)
            }
        }
        if let savingsPlanPaymentOptions = savingsPlanPaymentOptions {
            var savingsPlanPaymentOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .savingsPlanPaymentOptions)
            for savingsplanpaymentoptionlist0 in savingsPlanPaymentOptions {
                try savingsPlanPaymentOptionsContainer.encode(savingsplanpaymentoptionlist0.rawValue)
            }
        }
        if let savingsPlanTypes = savingsPlanTypes {
            var savingsPlanTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .savingsPlanTypes)
            for savingsplantypelist0 in savingsPlanTypes {
                try savingsPlanTypesContainer.encode(savingsplantypelist0.rawValue)
            }
        }
        if let serviceCodes = serviceCodes {
            var serviceCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceCodes)
            for savingsplanrateservicecodelist0 in serviceCodes {
                try serviceCodesContainer.encode(savingsplanrateservicecodelist0.rawValue)
            }
        }
        if let usageTypes = usageTypes {
            var usageTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usageTypes)
            for savingsplanrateusagetypelist0 in usageTypes {
                try usageTypesContainer.encode(savingsplanrateusagetypelist0)
            }
        }
    }
}

public struct DescribeSavingsPlansOfferingRatesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSavingsPlansOfferingRatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSavingsPlansOfferingRatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSavingsPlansOfferingRatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSavingsPlansOfferingRatesInput>
    public typealias MOutput = OperationOutput<DescribeSavingsPlansOfferingRatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSavingsPlansOfferingRatesOutputError>
}

public struct DescribeSavingsPlansOfferingRatesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSavingsPlansOfferingRatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSavingsPlansOfferingRatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSavingsPlansOfferingRatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSavingsPlansOfferingRatesInput>
    public typealias MOutput = OperationOutput<DescribeSavingsPlansOfferingRatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSavingsPlansOfferingRatesOutputError>
}

public struct DescribeSavingsPlansOfferingRatesInput: Equatable {
    /// <p>The filters.</p>
    public let filters: [SavingsPlanOfferingRateFilterElement]?
    /// <p>The maximum number of results to return with a single call. To retrieve additional results, make another
    ///        call with the returned token value.</p>
    public let maxResults: Int
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>The specific AWS operation for the line item in the billing report.</p>
    public let operations: [String]?
    /// <p>The AWS products.</p>
    public let products: [SavingsPlanProductType]?
    /// <p>The IDs of the offerings.</p>
    public let savingsPlanOfferingIds: [String]?
    /// <p>The payment options.</p>
    public let savingsPlanPaymentOptions: [SavingsPlanPaymentOption]?
    /// <p>The plan types.</p>
    public let savingsPlanTypes: [SavingsPlanType]?
    /// <p>The services.</p>
    public let serviceCodes: [SavingsPlanRateServiceCode]?
    /// <p>The usage details of the line item in the billing report.</p>
    public let usageTypes: [String]?

    public init (
        filters: [SavingsPlanOfferingRateFilterElement]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        operations: [String]? = nil,
        products: [SavingsPlanProductType]? = nil,
        savingsPlanOfferingIds: [String]? = nil,
        savingsPlanPaymentOptions: [SavingsPlanPaymentOption]? = nil,
        savingsPlanTypes: [SavingsPlanType]? = nil,
        serviceCodes: [SavingsPlanRateServiceCode]? = nil,
        usageTypes: [String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.operations = operations
        self.products = products
        self.savingsPlanOfferingIds = savingsPlanOfferingIds
        self.savingsPlanPaymentOptions = savingsPlanPaymentOptions
        self.savingsPlanTypes = savingsPlanTypes
        self.serviceCodes = serviceCodes
        self.usageTypes = usageTypes
    }
}

struct DescribeSavingsPlansOfferingRatesInputBody: Equatable {
    public let savingsPlanOfferingIds: [String]?
    public let savingsPlanPaymentOptions: [SavingsPlanPaymentOption]?
    public let savingsPlanTypes: [SavingsPlanType]?
    public let products: [SavingsPlanProductType]?
    public let serviceCodes: [SavingsPlanRateServiceCode]?
    public let usageTypes: [String]?
    public let operations: [String]?
    public let filters: [SavingsPlanOfferingRateFilterElement]?
    public let nextToken: String?
    public let maxResults: Int
}

extension DescribeSavingsPlansOfferingRatesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
        case operations
        case products
        case savingsPlanOfferingIds
        case savingsPlanPaymentOptions
        case savingsPlanTypes
        case serviceCodes
        case usageTypes
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlanOfferingIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .savingsPlanOfferingIds)
        var savingsPlanOfferingIdsDecoded0:[String]? = nil
        if let savingsPlanOfferingIdsContainer = savingsPlanOfferingIdsContainer {
            savingsPlanOfferingIdsDecoded0 = [String]()
            for string0 in savingsPlanOfferingIdsContainer {
                if let string0 = string0 {
                    savingsPlanOfferingIdsDecoded0?.append(string0)
                }
            }
        }
        savingsPlanOfferingIds = savingsPlanOfferingIdsDecoded0
        let savingsPlanPaymentOptionsContainer = try containerValues.decodeIfPresent([SavingsPlanPaymentOption?].self, forKey: .savingsPlanPaymentOptions)
        var savingsPlanPaymentOptionsDecoded0:[SavingsPlanPaymentOption]? = nil
        if let savingsPlanPaymentOptionsContainer = savingsPlanPaymentOptionsContainer {
            savingsPlanPaymentOptionsDecoded0 = [SavingsPlanPaymentOption]()
            for string0 in savingsPlanPaymentOptionsContainer {
                if let string0 = string0 {
                    savingsPlanPaymentOptionsDecoded0?.append(string0)
                }
            }
        }
        savingsPlanPaymentOptions = savingsPlanPaymentOptionsDecoded0
        let savingsPlanTypesContainer = try containerValues.decodeIfPresent([SavingsPlanType?].self, forKey: .savingsPlanTypes)
        var savingsPlanTypesDecoded0:[SavingsPlanType]? = nil
        if let savingsPlanTypesContainer = savingsPlanTypesContainer {
            savingsPlanTypesDecoded0 = [SavingsPlanType]()
            for string0 in savingsPlanTypesContainer {
                if let string0 = string0 {
                    savingsPlanTypesDecoded0?.append(string0)
                }
            }
        }
        savingsPlanTypes = savingsPlanTypesDecoded0
        let productsContainer = try containerValues.decodeIfPresent([SavingsPlanProductType?].self, forKey: .products)
        var productsDecoded0:[SavingsPlanProductType]? = nil
        if let productsContainer = productsContainer {
            productsDecoded0 = [SavingsPlanProductType]()
            for string0 in productsContainer {
                if let string0 = string0 {
                    productsDecoded0?.append(string0)
                }
            }
        }
        products = productsDecoded0
        let serviceCodesContainer = try containerValues.decodeIfPresent([SavingsPlanRateServiceCode?].self, forKey: .serviceCodes)
        var serviceCodesDecoded0:[SavingsPlanRateServiceCode]? = nil
        if let serviceCodesContainer = serviceCodesContainer {
            serviceCodesDecoded0 = [SavingsPlanRateServiceCode]()
            for string0 in serviceCodesContainer {
                if let string0 = string0 {
                    serviceCodesDecoded0?.append(string0)
                }
            }
        }
        serviceCodes = serviceCodesDecoded0
        let usageTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .usageTypes)
        var usageTypesDecoded0:[String]? = nil
        if let usageTypesContainer = usageTypesContainer {
            usageTypesDecoded0 = [String]()
            for string0 in usageTypesContainer {
                if let string0 = string0 {
                    usageTypesDecoded0?.append(string0)
                }
            }
        }
        usageTypes = usageTypesDecoded0
        let operationsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .operations)
        var operationsDecoded0:[String]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [String]()
            for string0 in operationsContainer {
                if let string0 = string0 {
                    operationsDecoded0?.append(string0)
                }
            }
        }
        operations = operationsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([SavingsPlanOfferingRateFilterElement?].self, forKey: .filters)
        var filtersDecoded0:[SavingsPlanOfferingRateFilterElement]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SavingsPlanOfferingRateFilterElement]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeSavingsPlansOfferingRatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSavingsPlansOfferingRatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSavingsPlansOfferingRatesOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSavingsPlansOfferingRatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSavingsPlansOfferingRatesOutputResponse(nextToken: \(String(describing: nextToken)), searchResults: \(String(describing: searchResults)))"}
}

extension DescribeSavingsPlansOfferingRatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSavingsPlansOfferingRatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.searchResults = output.searchResults
        } else {
            self.nextToken = nil
            self.searchResults = nil
        }
    }
}

public struct DescribeSavingsPlansOfferingRatesOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is null when there are no more
    ///        results to return.</p>
    public let nextToken: String?
    /// <p>Information about the Savings Plans offering rates.</p>
    public let searchResults: [SavingsPlanOfferingRate]?

    public init (
        nextToken: String? = nil,
        searchResults: [SavingsPlanOfferingRate]? = nil
    )
    {
        self.nextToken = nextToken
        self.searchResults = searchResults
    }
}

struct DescribeSavingsPlansOfferingRatesOutputResponseBody: Equatable {
    public let searchResults: [SavingsPlanOfferingRate]?
    public let nextToken: String?
}

extension DescribeSavingsPlansOfferingRatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case searchResults
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchResultsContainer = try containerValues.decodeIfPresent([SavingsPlanOfferingRate?].self, forKey: .searchResults)
        var searchResultsDecoded0:[SavingsPlanOfferingRate]? = nil
        if let searchResultsContainer = searchResultsContainer {
            searchResultsDecoded0 = [SavingsPlanOfferingRate]()
            for structure0 in searchResultsContainer {
                if let structure0 = structure0 {
                    searchResultsDecoded0?.append(structure0)
                }
            }
        }
        searchResults = searchResultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeSavingsPlansOfferingsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSavingsPlansOfferingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSavingsPlansOfferingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSavingsPlansOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSavingsPlansOfferingsInput>
    public typealias MOutput = OperationOutput<DescribeSavingsPlansOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSavingsPlansOfferingsOutputError>
}

extension DescribeSavingsPlansOfferingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSavingsPlansOfferingsInput(currencies: \(String(describing: currencies)), descriptions: \(String(describing: descriptions)), durations: \(String(describing: durations)), filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), offeringIds: \(String(describing: offeringIds)), operations: \(String(describing: operations)), paymentOptions: \(String(describing: paymentOptions)), planTypes: \(String(describing: planTypes)), productType: \(String(describing: productType)), serviceCodes: \(String(describing: serviceCodes)), usageTypes: \(String(describing: usageTypes)))"}
}

extension DescribeSavingsPlansOfferingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currencies
        case descriptions
        case durations
        case filters
        case maxResults
        case nextToken
        case offeringIds
        case operations
        case paymentOptions
        case planTypes
        case productType
        case serviceCodes
        case usageTypes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencies = currencies {
            var currenciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .currencies)
            for currencylist0 in currencies {
                try currenciesContainer.encode(currencylist0.rawValue)
            }
        }
        if let descriptions = descriptions {
            var descriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .descriptions)
            for savingsplandescriptionslist0 in descriptions {
                try descriptionsContainer.encode(savingsplandescriptionslist0)
            }
        }
        if let durations = durations {
            var durationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .durations)
            for durationslist0 in durations {
                try durationsContainer.encode(durationslist0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for savingsplanofferingfilterslist0 in filters {
                try filtersContainer.encode(savingsplanofferingfilterslist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let offeringIds = offeringIds {
            var offeringIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .offeringIds)
            for uuids0 in offeringIds {
                try offeringIdsContainer.encode(uuids0)
            }
        }
        if let operations = operations {
            var operationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operations)
            for savingsplanoperationlist0 in operations {
                try operationsContainer.encode(savingsplanoperationlist0)
            }
        }
        if let paymentOptions = paymentOptions {
            var paymentOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .paymentOptions)
            for savingsplanpaymentoptionlist0 in paymentOptions {
                try paymentOptionsContainer.encode(savingsplanpaymentoptionlist0.rawValue)
            }
        }
        if let planTypes = planTypes {
            var planTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .planTypes)
            for savingsplantypelist0 in planTypes {
                try planTypesContainer.encode(savingsplantypelist0.rawValue)
            }
        }
        if let productType = productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
        if let serviceCodes = serviceCodes {
            var serviceCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceCodes)
            for savingsplanservicecodelist0 in serviceCodes {
                try serviceCodesContainer.encode(savingsplanservicecodelist0)
            }
        }
        if let usageTypes = usageTypes {
            var usageTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usageTypes)
            for savingsplanusagetypelist0 in usageTypes {
                try usageTypesContainer.encode(savingsplanusagetypelist0)
            }
        }
    }
}

public struct DescribeSavingsPlansOfferingsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSavingsPlansOfferingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSavingsPlansOfferingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSavingsPlansOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSavingsPlansOfferingsInput>
    public typealias MOutput = OperationOutput<DescribeSavingsPlansOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSavingsPlansOfferingsOutputError>
}

public struct DescribeSavingsPlansOfferingsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSavingsPlansOfferingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSavingsPlansOfferingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSavingsPlansOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSavingsPlansOfferingsInput>
    public typealias MOutput = OperationOutput<DescribeSavingsPlansOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSavingsPlansOfferingsOutputError>
}

public struct DescribeSavingsPlansOfferingsInput: Equatable {
    /// <p>The currencies.</p>
    public let currencies: [CurrencyCode]?
    /// <p>The descriptions.</p>
    public let descriptions: [String]?
    /// <p>The durations, in seconds.</p>
    public let durations: [Int]?
    /// <p>The filters.</p>
    public let filters: [SavingsPlanOfferingFilterElement]?
    /// <p>The maximum number of results to return with a single call. To retrieve additional results, make another
    ///        call with the returned token value.</p>
    public let maxResults: Int
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>The IDs of the offerings.</p>
    public let offeringIds: [String]?
    /// <p>The specific AWS operation for the line item in the billing report.</p>
    public let operations: [String]?
    /// <p>The payment options.</p>
    public let paymentOptions: [SavingsPlanPaymentOption]?
    /// <p>The plan type.</p>
    public let planTypes: [SavingsPlanType]?
    /// <p>The product type.</p>
    public let productType: SavingsPlanProductType?
    /// <p>The services.</p>
    public let serviceCodes: [String]?
    /// <p>The usage details of the line item in the billing report.</p>
    public let usageTypes: [String]?

    public init (
        currencies: [CurrencyCode]? = nil,
        descriptions: [String]? = nil,
        durations: [Int]? = nil,
        filters: [SavingsPlanOfferingFilterElement]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        offeringIds: [String]? = nil,
        operations: [String]? = nil,
        paymentOptions: [SavingsPlanPaymentOption]? = nil,
        planTypes: [SavingsPlanType]? = nil,
        productType: SavingsPlanProductType? = nil,
        serviceCodes: [String]? = nil,
        usageTypes: [String]? = nil
    )
    {
        self.currencies = currencies
        self.descriptions = descriptions
        self.durations = durations
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.offeringIds = offeringIds
        self.operations = operations
        self.paymentOptions = paymentOptions
        self.planTypes = planTypes
        self.productType = productType
        self.serviceCodes = serviceCodes
        self.usageTypes = usageTypes
    }
}

struct DescribeSavingsPlansOfferingsInputBody: Equatable {
    public let offeringIds: [String]?
    public let paymentOptions: [SavingsPlanPaymentOption]?
    public let productType: SavingsPlanProductType?
    public let planTypes: [SavingsPlanType]?
    public let durations: [Int]?
    public let currencies: [CurrencyCode]?
    public let descriptions: [String]?
    public let serviceCodes: [String]?
    public let usageTypes: [String]?
    public let operations: [String]?
    public let filters: [SavingsPlanOfferingFilterElement]?
    public let nextToken: String?
    public let maxResults: Int
}

extension DescribeSavingsPlansOfferingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case currencies
        case descriptions
        case durations
        case filters
        case maxResults
        case nextToken
        case offeringIds
        case operations
        case paymentOptions
        case planTypes
        case productType
        case serviceCodes
        case usageTypes
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .offeringIds)
        var offeringIdsDecoded0:[String]? = nil
        if let offeringIdsContainer = offeringIdsContainer {
            offeringIdsDecoded0 = [String]()
            for string0 in offeringIdsContainer {
                if let string0 = string0 {
                    offeringIdsDecoded0?.append(string0)
                }
            }
        }
        offeringIds = offeringIdsDecoded0
        let paymentOptionsContainer = try containerValues.decodeIfPresent([SavingsPlanPaymentOption?].self, forKey: .paymentOptions)
        var paymentOptionsDecoded0:[SavingsPlanPaymentOption]? = nil
        if let paymentOptionsContainer = paymentOptionsContainer {
            paymentOptionsDecoded0 = [SavingsPlanPaymentOption]()
            for string0 in paymentOptionsContainer {
                if let string0 = string0 {
                    paymentOptionsDecoded0?.append(string0)
                }
            }
        }
        paymentOptions = paymentOptionsDecoded0
        let productTypeDecoded = try containerValues.decodeIfPresent(SavingsPlanProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let planTypesContainer = try containerValues.decodeIfPresent([SavingsPlanType?].self, forKey: .planTypes)
        var planTypesDecoded0:[SavingsPlanType]? = nil
        if let planTypesContainer = planTypesContainer {
            planTypesDecoded0 = [SavingsPlanType]()
            for string0 in planTypesContainer {
                if let string0 = string0 {
                    planTypesDecoded0?.append(string0)
                }
            }
        }
        planTypes = planTypesDecoded0
        let durationsContainer = try containerValues.decodeIfPresent([Int?].self, forKey: .durations)
        var durationsDecoded0:[Int]? = nil
        if let durationsContainer = durationsContainer {
            durationsDecoded0 = [Int]()
            for long0 in durationsContainer {
                if let long0 = long0 {
                    durationsDecoded0?.append(long0)
                }
            }
        }
        durations = durationsDecoded0
        let currenciesContainer = try containerValues.decodeIfPresent([CurrencyCode?].self, forKey: .currencies)
        var currenciesDecoded0:[CurrencyCode]? = nil
        if let currenciesContainer = currenciesContainer {
            currenciesDecoded0 = [CurrencyCode]()
            for string0 in currenciesContainer {
                if let string0 = string0 {
                    currenciesDecoded0?.append(string0)
                }
            }
        }
        currencies = currenciesDecoded0
        let descriptionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .descriptions)
        var descriptionsDecoded0:[String]? = nil
        if let descriptionsContainer = descriptionsContainer {
            descriptionsDecoded0 = [String]()
            for string0 in descriptionsContainer {
                if let string0 = string0 {
                    descriptionsDecoded0?.append(string0)
                }
            }
        }
        descriptions = descriptionsDecoded0
        let serviceCodesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .serviceCodes)
        var serviceCodesDecoded0:[String]? = nil
        if let serviceCodesContainer = serviceCodesContainer {
            serviceCodesDecoded0 = [String]()
            for string0 in serviceCodesContainer {
                if let string0 = string0 {
                    serviceCodesDecoded0?.append(string0)
                }
            }
        }
        serviceCodes = serviceCodesDecoded0
        let usageTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .usageTypes)
        var usageTypesDecoded0:[String]? = nil
        if let usageTypesContainer = usageTypesContainer {
            usageTypesDecoded0 = [String]()
            for string0 in usageTypesContainer {
                if let string0 = string0 {
                    usageTypesDecoded0?.append(string0)
                }
            }
        }
        usageTypes = usageTypesDecoded0
        let operationsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .operations)
        var operationsDecoded0:[String]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [String]()
            for string0 in operationsContainer {
                if let string0 = string0 {
                    operationsDecoded0?.append(string0)
                }
            }
        }
        operations = operationsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([SavingsPlanOfferingFilterElement?].self, forKey: .filters)
        var filtersDecoded0:[SavingsPlanOfferingFilterElement]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SavingsPlanOfferingFilterElement]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeSavingsPlansOfferingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSavingsPlansOfferingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSavingsPlansOfferingsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSavingsPlansOfferingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSavingsPlansOfferingsOutputResponse(nextToken: \(String(describing: nextToken)), searchResults: \(String(describing: searchResults)))"}
}

extension DescribeSavingsPlansOfferingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSavingsPlansOfferingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.searchResults = output.searchResults
        } else {
            self.nextToken = nil
            self.searchResults = nil
        }
    }
}

public struct DescribeSavingsPlansOfferingsOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is null when there are no more
    ///        results to return.</p>
    public let nextToken: String?
    /// <p>Information about the Savings Plans offerings.</p>
    public let searchResults: [SavingsPlanOffering]?

    public init (
        nextToken: String? = nil,
        searchResults: [SavingsPlanOffering]? = nil
    )
    {
        self.nextToken = nextToken
        self.searchResults = searchResults
    }
}

struct DescribeSavingsPlansOfferingsOutputResponseBody: Equatable {
    public let searchResults: [SavingsPlanOffering]?
    public let nextToken: String?
}

extension DescribeSavingsPlansOfferingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case searchResults
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchResultsContainer = try containerValues.decodeIfPresent([SavingsPlanOffering?].self, forKey: .searchResults)
        var searchResultsDecoded0:[SavingsPlanOffering]? = nil
        if let searchResultsContainer = searchResultsContainer {
            searchResultsDecoded0 = [SavingsPlanOffering]()
            for structure0 in searchResultsContainer {
                if let structure0 = structure0 {
                    searchResultsDecoded0?.append(structure0)
                }
            }
        }
        searchResults = searchResultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSavingsPlansOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSavingsPlansOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSavingsPlansOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSavingsPlansOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSavingsPlansOutputResponse(nextToken: \(String(describing: nextToken)), savingsPlans: \(String(describing: savingsPlans)))"}
}

extension DescribeSavingsPlansOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSavingsPlansOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.savingsPlans = output.savingsPlans
        } else {
            self.nextToken = nil
            self.savingsPlans = nil
        }
    }
}

public struct DescribeSavingsPlansOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is null when there are no more
    ///        results to return.</p>
    public let nextToken: String?
    /// <p>Information about the Savings Plans.</p>
    public let savingsPlans: [SavingsPlan]?

    public init (
        nextToken: String? = nil,
        savingsPlans: [SavingsPlan]? = nil
    )
    {
        self.nextToken = nextToken
        self.savingsPlans = savingsPlans
    }
}

struct DescribeSavingsPlansOutputResponseBody: Equatable {
    public let savingsPlans: [SavingsPlan]?
    public let nextToken: String?
}

extension DescribeSavingsPlansOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case savingsPlans
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlansContainer = try containerValues.decodeIfPresent([SavingsPlan?].self, forKey: .savingsPlans)
        var savingsPlansDecoded0:[SavingsPlan]? = nil
        if let savingsPlansContainer = savingsPlansContainer {
            savingsPlansDecoded0 = [SavingsPlan]()
            for structure0 in savingsPlansContainer {
                if let structure0 = structure0 {
                    savingsPlansDecoded0?.append(structure0)
                }
            }
        }
        savingsPlans = savingsPlansDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An unexpected error occurred.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>Information about the tags.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ParentSavingsPlanOffering: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currency
        case durationSeconds
        case offeringId
        case paymentOption
        case planDescription
        case planType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currency = currency {
            try encodeContainer.encode(currency.rawValue, forKey: .currency)
        }
        if durationSeconds != 0 {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let offeringId = offeringId {
            try encodeContainer.encode(offeringId, forKey: .offeringId)
        }
        if let paymentOption = paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let planDescription = planDescription {
            try encodeContainer.encode(planDescription, forKey: .planDescription)
        }
        if let planType = planType {
            try encodeContainer.encode(planType.rawValue, forKey: .planType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .offeringId)
        offeringId = offeringIdDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(SavingsPlanPaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let planTypeDecoded = try containerValues.decodeIfPresent(SavingsPlanType.self, forKey: .planType)
        planType = planTypeDecoded
        let durationSecondsDecoded = try containerValues.decode(Int.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
        let currencyDecoded = try containerValues.decodeIfPresent(CurrencyCode.self, forKey: .currency)
        currency = currencyDecoded
        let planDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .planDescription)
        planDescription = planDescriptionDecoded
    }
}

extension ParentSavingsPlanOffering: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParentSavingsPlanOffering(currency: \(String(describing: currency)), durationSeconds: \(String(describing: durationSeconds)), offeringId: \(String(describing: offeringId)), paymentOption: \(String(describing: paymentOption)), planDescription: \(String(describing: planDescription)), planType: \(String(describing: planType)))"}
}

/// <p>Information about a Savings Plan offering.</p>
public struct ParentSavingsPlanOffering: Equatable {
    /// <p>The currency.</p>
    public let currency: CurrencyCode?
    /// <p>The duration, in seconds.</p>
    public let durationSeconds: Int
    /// <p>The ID of the offering.</p>
    public let offeringId: String?
    /// <p>The payment option.</p>
    public let paymentOption: SavingsPlanPaymentOption?
    /// <p>The description.</p>
    public let planDescription: String?
    /// <p>The plan type.</p>
    public let planType: SavingsPlanType?

    public init (
        currency: CurrencyCode? = nil,
        durationSeconds: Int = 0,
        offeringId: String? = nil,
        paymentOption: SavingsPlanPaymentOption? = nil,
        planDescription: String? = nil,
        planType: SavingsPlanType? = nil
    )
    {
        self.currency = currency
        self.durationSeconds = durationSeconds
        self.offeringId = offeringId
        self.paymentOption = paymentOption
        self.planDescription = planDescription
        self.planType = planType
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SavingsPlan: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commitment
        case currency
        case description
        case ec2InstanceFamily
        case end
        case offeringId
        case paymentOption
        case productTypes
        case recurringPaymentAmount
        case region
        case savingsPlanArn
        case savingsPlanId
        case savingsPlanType
        case start
        case state
        case tags
        case termDurationInSeconds
        case upfrontPaymentAmount
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitment = commitment {
            try encodeContainer.encode(commitment, forKey: .commitment)
        }
        if let currency = currency {
            try encodeContainer.encode(currency.rawValue, forKey: .currency)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2InstanceFamily = ec2InstanceFamily {
            try encodeContainer.encode(ec2InstanceFamily, forKey: .ec2InstanceFamily)
        }
        if let end = end {
            try encodeContainer.encode(end, forKey: .end)
        }
        if let offeringId = offeringId {
            try encodeContainer.encode(offeringId, forKey: .offeringId)
        }
        if let paymentOption = paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let productTypes = productTypes {
            var productTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productTypes)
            for savingsplanproducttypelist0 in productTypes {
                try productTypesContainer.encode(savingsplanproducttypelist0.rawValue)
            }
        }
        if let recurringPaymentAmount = recurringPaymentAmount {
            try encodeContainer.encode(recurringPaymentAmount, forKey: .recurringPaymentAmount)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let savingsPlanArn = savingsPlanArn {
            try encodeContainer.encode(savingsPlanArn, forKey: .savingsPlanArn)
        }
        if let savingsPlanId = savingsPlanId {
            try encodeContainer.encode(savingsPlanId, forKey: .savingsPlanId)
        }
        if let savingsPlanType = savingsPlanType {
            try encodeContainer.encode(savingsPlanType.rawValue, forKey: .savingsPlanType)
        }
        if let start = start {
            try encodeContainer.encode(start, forKey: .start)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if termDurationInSeconds != 0 {
            try encodeContainer.encode(termDurationInSeconds, forKey: .termDurationInSeconds)
        }
        if let upfrontPaymentAmount = upfrontPaymentAmount {
            try encodeContainer.encode(upfrontPaymentAmount, forKey: .upfrontPaymentAmount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .offeringId)
        offeringId = offeringIdDecoded
        let savingsPlanIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .savingsPlanId)
        savingsPlanId = savingsPlanIdDecoded
        let savingsPlanArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .savingsPlanArn)
        savingsPlanArn = savingsPlanArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let startDecoded = try containerValues.decodeIfPresent(String.self, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decodeIfPresent(String.self, forKey: .end)
        end = endDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SavingsPlanState.self, forKey: .state)
        state = stateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let ec2InstanceFamilyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ec2InstanceFamily)
        ec2InstanceFamily = ec2InstanceFamilyDecoded
        let savingsPlanTypeDecoded = try containerValues.decodeIfPresent(SavingsPlanType.self, forKey: .savingsPlanType)
        savingsPlanType = savingsPlanTypeDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(SavingsPlanPaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let productTypesContainer = try containerValues.decodeIfPresent([SavingsPlanProductType?].self, forKey: .productTypes)
        var productTypesDecoded0:[SavingsPlanProductType]? = nil
        if let productTypesContainer = productTypesContainer {
            productTypesDecoded0 = [SavingsPlanProductType]()
            for string0 in productTypesContainer {
                if let string0 = string0 {
                    productTypesDecoded0?.append(string0)
                }
            }
        }
        productTypes = productTypesDecoded0
        let currencyDecoded = try containerValues.decodeIfPresent(CurrencyCode.self, forKey: .currency)
        currency = currencyDecoded
        let commitmentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitment)
        commitment = commitmentDecoded
        let upfrontPaymentAmountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .upfrontPaymentAmount)
        upfrontPaymentAmount = upfrontPaymentAmountDecoded
        let recurringPaymentAmountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recurringPaymentAmount)
        recurringPaymentAmount = recurringPaymentAmountDecoded
        let termDurationInSecondsDecoded = try containerValues.decode(Int.self, forKey: .termDurationInSeconds)
        termDurationInSeconds = termDurationInSecondsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SavingsPlan: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SavingsPlan(commitment: \(String(describing: commitment)), currency: \(String(describing: currency)), description: \(String(describing: description)), ec2InstanceFamily: \(String(describing: ec2InstanceFamily)), end: \(String(describing: end)), offeringId: \(String(describing: offeringId)), paymentOption: \(String(describing: paymentOption)), productTypes: \(String(describing: productTypes)), recurringPaymentAmount: \(String(describing: recurringPaymentAmount)), region: \(String(describing: region)), savingsPlanArn: \(String(describing: savingsPlanArn)), savingsPlanId: \(String(describing: savingsPlanId)), savingsPlanType: \(String(describing: savingsPlanType)), start: \(String(describing: start)), state: \(String(describing: state)), tags: \(String(describing: tags)), termDurationInSeconds: \(String(describing: termDurationInSeconds)), upfrontPaymentAmount: \(String(describing: upfrontPaymentAmount)))"}
}

/// <p>Information about a Savings Plan.</p>
public struct SavingsPlan: Equatable {
    /// <p>The hourly commitment, in USD.</p>
    public let commitment: String?
    /// <p>The currency.</p>
    public let currency: CurrencyCode?
    /// <p>The description.</p>
    public let description: String?
    /// <p>The EC2 instance family.</p>
    public let ec2InstanceFamily: String?
    /// <p>The end time.</p>
    public let end: String?
    /// <p>The ID of the offering.</p>
    public let offeringId: String?
    /// <p>The payment option.</p>
    public let paymentOption: SavingsPlanPaymentOption?
    /// <p>The product types.</p>
    public let productTypes: [SavingsPlanProductType]?
    /// <p>The recurring payment amount.</p>
    public let recurringPaymentAmount: String?
    /// <p>The AWS Region.</p>
    public let region: String?
    /// <p>The Amazon Resource Name (ARN) of the Savings Plan.</p>
    public let savingsPlanArn: String?
    /// <p>The ID of the Savings Plan.</p>
    public let savingsPlanId: String?
    /// <p>The plan type.</p>
    public let savingsPlanType: SavingsPlanType?
    /// <p>The start time.</p>
    public let start: String?
    /// <p>The state.</p>
    public let state: SavingsPlanState?
    /// <p>One or more tags.</p>
    public let tags: [String:String]?
    /// <p>The duration of the term, in seconds.</p>
    public let termDurationInSeconds: Int
    /// <p>The up-front payment amount.</p>
    public let upfrontPaymentAmount: String?

    public init (
        commitment: String? = nil,
        currency: CurrencyCode? = nil,
        description: String? = nil,
        ec2InstanceFamily: String? = nil,
        end: String? = nil,
        offeringId: String? = nil,
        paymentOption: SavingsPlanPaymentOption? = nil,
        productTypes: [SavingsPlanProductType]? = nil,
        recurringPaymentAmount: String? = nil,
        region: String? = nil,
        savingsPlanArn: String? = nil,
        savingsPlanId: String? = nil,
        savingsPlanType: SavingsPlanType? = nil,
        start: String? = nil,
        state: SavingsPlanState? = nil,
        tags: [String:String]? = nil,
        termDurationInSeconds: Int = 0,
        upfrontPaymentAmount: String? = nil
    )
    {
        self.commitment = commitment
        self.currency = currency
        self.description = description
        self.ec2InstanceFamily = ec2InstanceFamily
        self.end = end
        self.offeringId = offeringId
        self.paymentOption = paymentOption
        self.productTypes = productTypes
        self.recurringPaymentAmount = recurringPaymentAmount
        self.region = region
        self.savingsPlanArn = savingsPlanArn
        self.savingsPlanId = savingsPlanId
        self.savingsPlanType = savingsPlanType
        self.start = start
        self.state = state
        self.tags = tags
        self.termDurationInSeconds = termDurationInSeconds
        self.upfrontPaymentAmount = upfrontPaymentAmount
    }
}

extension SavingsPlanFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for listofstrings0 in values {
                try valuesContainer.encode(listofstrings0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(SavingsPlansFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SavingsPlanFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SavingsPlanFilter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>Information about a filter.</p>
public struct SavingsPlanFilter: Equatable {
    /// <p>The filter name.</p>
    public let name: SavingsPlansFilterName?
    /// <p>The filter value.</p>
    public let values: [String]?

    public init (
        name: SavingsPlansFilterName? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

extension SavingsPlanOffering: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currency
        case description
        case durationSeconds
        case offeringId
        case operation
        case paymentOption
        case planType
        case productTypes
        case properties
        case serviceCode
        case usageType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currency = currency {
            try encodeContainer.encode(currency.rawValue, forKey: .currency)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if durationSeconds != 0 {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let offeringId = offeringId {
            try encodeContainer.encode(offeringId, forKey: .offeringId)
        }
        if let operation = operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let paymentOption = paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let planType = planType {
            try encodeContainer.encode(planType.rawValue, forKey: .planType)
        }
        if let productTypes = productTypes {
            var productTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productTypes)
            for savingsplanproducttypelist0 in productTypes {
                try productTypesContainer.encode(savingsplanproducttypelist0.rawValue)
            }
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .properties)
            for savingsplanofferingpropertylist0 in properties {
                try propertiesContainer.encode(savingsplanofferingpropertylist0)
            }
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let usageType = usageType {
            try encodeContainer.encode(usageType, forKey: .usageType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .offeringId)
        offeringId = offeringIdDecoded
        let productTypesContainer = try containerValues.decodeIfPresent([SavingsPlanProductType?].self, forKey: .productTypes)
        var productTypesDecoded0:[SavingsPlanProductType]? = nil
        if let productTypesContainer = productTypesContainer {
            productTypesDecoded0 = [SavingsPlanProductType]()
            for string0 in productTypesContainer {
                if let string0 = string0 {
                    productTypesDecoded0?.append(string0)
                }
            }
        }
        productTypes = productTypesDecoded0
        let planTypeDecoded = try containerValues.decodeIfPresent(SavingsPlanType.self, forKey: .planType)
        planType = planTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(SavingsPlanPaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let durationSecondsDecoded = try containerValues.decode(Int.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
        let currencyDecoded = try containerValues.decodeIfPresent(CurrencyCode.self, forKey: .currency)
        currency = currencyDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let usageTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .usageType)
        usageType = usageTypeDecoded
        let operationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operation)
        operation = operationDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([SavingsPlanOfferingProperty?].self, forKey: .properties)
        var propertiesDecoded0:[SavingsPlanOfferingProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [SavingsPlanOfferingProperty]()
            for structure0 in propertiesContainer {
                if let structure0 = structure0 {
                    propertiesDecoded0?.append(structure0)
                }
            }
        }
        properties = propertiesDecoded0
    }
}

extension SavingsPlanOffering: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SavingsPlanOffering(currency: \(String(describing: currency)), description: \(String(describing: description)), durationSeconds: \(String(describing: durationSeconds)), offeringId: \(String(describing: offeringId)), operation: \(String(describing: operation)), paymentOption: \(String(describing: paymentOption)), planType: \(String(describing: planType)), productTypes: \(String(describing: productTypes)), properties: \(String(describing: properties)), serviceCode: \(String(describing: serviceCode)), usageType: \(String(describing: usageType)))"}
}

/// <p>Information about a Savings Plan offering.</p>
public struct SavingsPlanOffering: Equatable {
    /// <p>The currency.</p>
    public let currency: CurrencyCode?
    /// <p>The description.</p>
    public let description: String?
    /// <p>The duration, in seconds.</p>
    public let durationSeconds: Int
    /// <p>The ID of the offering.</p>
    public let offeringId: String?
    /// <p>The specific AWS operation for the line item in the billing report.</p>
    public let operation: String?
    /// <p>The payment option.</p>
    public let paymentOption: SavingsPlanPaymentOption?
    /// <p>The plan type.</p>
    public let planType: SavingsPlanType?
    /// <p>The product type.</p>
    public let productTypes: [SavingsPlanProductType]?
    /// <p>The properties.</p>
    public let properties: [SavingsPlanOfferingProperty]?
    /// <p>The service.</p>
    public let serviceCode: String?
    /// <p>The usage details of the line item in the billing report.</p>
    public let usageType: String?

    public init (
        currency: CurrencyCode? = nil,
        description: String? = nil,
        durationSeconds: Int = 0,
        offeringId: String? = nil,
        operation: String? = nil,
        paymentOption: SavingsPlanPaymentOption? = nil,
        planType: SavingsPlanType? = nil,
        productTypes: [SavingsPlanProductType]? = nil,
        properties: [SavingsPlanOfferingProperty]? = nil,
        serviceCode: String? = nil,
        usageType: String? = nil
    )
    {
        self.currency = currency
        self.description = description
        self.durationSeconds = durationSeconds
        self.offeringId = offeringId
        self.operation = operation
        self.paymentOption = paymentOption
        self.planType = planType
        self.productTypes = productTypes
        self.properties = properties
        self.serviceCode = serviceCode
        self.usageType = usageType
    }
}

public enum SavingsPlanOfferingFilterAttribute {
    case instancefamily
    case region
    case sdkUnknown(String)
}

extension SavingsPlanOfferingFilterAttribute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SavingsPlanOfferingFilterAttribute] {
        return [
            .instancefamily,
            .region,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .instancefamily: return "instanceFamily"
        case .region: return "region"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SavingsPlanOfferingFilterAttribute(rawValue: rawValue) ?? SavingsPlanOfferingFilterAttribute.sdkUnknown(rawValue)
    }
}

extension SavingsPlanOfferingFilterElement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalueslist0 in values {
                try valuesContainer.encode(filtervalueslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(SavingsPlanOfferingFilterAttribute.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SavingsPlanOfferingFilterElement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SavingsPlanOfferingFilterElement(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>Information about a filter.</p>
public struct SavingsPlanOfferingFilterElement: Equatable {
    /// <p>The filter name.</p>
    public let name: SavingsPlanOfferingFilterAttribute?
    /// <p>The filter values.</p>
    public let values: [String]?

    public init (
        name: SavingsPlanOfferingFilterAttribute? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

extension SavingsPlanOfferingProperty: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(SavingsPlanOfferingPropertyKey.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SavingsPlanOfferingProperty: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SavingsPlanOfferingProperty(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>Information about a property.</p>
public struct SavingsPlanOfferingProperty: Equatable {
    /// <p>The property name.</p>
    public let name: SavingsPlanOfferingPropertyKey?
    /// <p>The property value.</p>
    public let value: String?

    public init (
        name: SavingsPlanOfferingPropertyKey? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

public enum SavingsPlanOfferingPropertyKey {
    case instanceFamily
    case region
    case sdkUnknown(String)
}

extension SavingsPlanOfferingPropertyKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SavingsPlanOfferingPropertyKey] {
        return [
            .instanceFamily,
            .region,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .instanceFamily: return "instanceFamily"
        case .region: return "region"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SavingsPlanOfferingPropertyKey(rawValue: rawValue) ?? SavingsPlanOfferingPropertyKey.sdkUnknown(rawValue)
    }
}

extension SavingsPlanOfferingRate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case operation
        case productType
        case properties
        case rate
        case savingsPlanOffering
        case serviceCode
        case unit
        case usageType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operation = operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let productType = productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .properties)
            for savingsplanofferingratepropertylist0 in properties {
                try propertiesContainer.encode(savingsplanofferingratepropertylist0)
            }
        }
        if let rate = rate {
            try encodeContainer.encode(rate, forKey: .rate)
        }
        if let savingsPlanOffering = savingsPlanOffering {
            try encodeContainer.encode(savingsPlanOffering, forKey: .savingsPlanOffering)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode.rawValue, forKey: .serviceCode)
        }
        if let unit = unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let usageType = usageType {
            try encodeContainer.encode(usageType, forKey: .usageType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlanOfferingDecoded = try containerValues.decodeIfPresent(ParentSavingsPlanOffering.self, forKey: .savingsPlanOffering)
        savingsPlanOffering = savingsPlanOfferingDecoded
        let rateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rate)
        rate = rateDecoded
        let unitDecoded = try containerValues.decodeIfPresent(SavingsPlanRateUnit.self, forKey: .unit)
        unit = unitDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(SavingsPlanProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(SavingsPlanRateServiceCode.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let usageTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .usageType)
        usageType = usageTypeDecoded
        let operationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operation)
        operation = operationDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([SavingsPlanOfferingRateProperty?].self, forKey: .properties)
        var propertiesDecoded0:[SavingsPlanOfferingRateProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [SavingsPlanOfferingRateProperty]()
            for structure0 in propertiesContainer {
                if let structure0 = structure0 {
                    propertiesDecoded0?.append(structure0)
                }
            }
        }
        properties = propertiesDecoded0
    }
}

extension SavingsPlanOfferingRate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SavingsPlanOfferingRate(operation: \(String(describing: operation)), productType: \(String(describing: productType)), properties: \(String(describing: properties)), rate: \(String(describing: rate)), savingsPlanOffering: \(String(describing: savingsPlanOffering)), serviceCode: \(String(describing: serviceCode)), unit: \(String(describing: unit)), usageType: \(String(describing: usageType)))"}
}

/// <p>Information about a Savings Plan offering rate.</p>
public struct SavingsPlanOfferingRate: Equatable {
    /// <p>The specific AWS operation for the line item in the billing report.</p>
    public let operation: String?
    /// <p>The product type.</p>
    public let productType: SavingsPlanProductType?
    /// <p>The properties.</p>
    public let properties: [SavingsPlanOfferingRateProperty]?
    /// <p>The Savings Plan rate.</p>
    public let rate: String?
    /// <p>The Savings Plan offering.</p>
    public let savingsPlanOffering: ParentSavingsPlanOffering?
    /// <p>The service.</p>
    public let serviceCode: SavingsPlanRateServiceCode?
    /// <p>The unit.</p>
    public let unit: SavingsPlanRateUnit?
    /// <p>The usage details of the line item in the billing report.</p>
    public let usageType: String?

    public init (
        operation: String? = nil,
        productType: SavingsPlanProductType? = nil,
        properties: [SavingsPlanOfferingRateProperty]? = nil,
        rate: String? = nil,
        savingsPlanOffering: ParentSavingsPlanOffering? = nil,
        serviceCode: SavingsPlanRateServiceCode? = nil,
        unit: SavingsPlanRateUnit? = nil,
        usageType: String? = nil
    )
    {
        self.operation = operation
        self.productType = productType
        self.properties = properties
        self.rate = rate
        self.savingsPlanOffering = savingsPlanOffering
        self.serviceCode = serviceCode
        self.unit = unit
        self.usageType = usageType
    }
}

extension SavingsPlanOfferingRateFilterElement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalueslist0 in values {
                try valuesContainer.encode(filtervalueslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(SavingsPlanRateFilterAttribute.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SavingsPlanOfferingRateFilterElement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SavingsPlanOfferingRateFilterElement(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>Information about a filter.</p>
public struct SavingsPlanOfferingRateFilterElement: Equatable {
    /// <p>The filter name.</p>
    public let name: SavingsPlanRateFilterAttribute?
    /// <p>The filter values.</p>
    public let values: [String]?

    public init (
        name: SavingsPlanRateFilterAttribute? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

extension SavingsPlanOfferingRateProperty: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SavingsPlanOfferingRateProperty: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SavingsPlanOfferingRateProperty(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>Information about a property.</p>
public struct SavingsPlanOfferingRateProperty: Equatable {
    /// <p>The property name.</p>
    public let name: String?
    /// <p>The property value.</p>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

public enum SavingsPlanPaymentOption {
    case allUpfront
    case noUpfront
    case partialUpfront
    case sdkUnknown(String)
}

extension SavingsPlanPaymentOption : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SavingsPlanPaymentOption] {
        return [
            .allUpfront,
            .noUpfront,
            .partialUpfront,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allUpfront: return "All Upfront"
        case .noUpfront: return "No Upfront"
        case .partialUpfront: return "Partial Upfront"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SavingsPlanPaymentOption(rawValue: rawValue) ?? SavingsPlanPaymentOption.sdkUnknown(rawValue)
    }
}

public enum SavingsPlanProductType {
    case ec2
    case fargate
    case lambda
    case sagemaker
    case sdkUnknown(String)
}

extension SavingsPlanProductType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SavingsPlanProductType] {
        return [
            .ec2,
            .fargate,
            .lambda,
            .sagemaker,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ec2: return "EC2"
        case .fargate: return "Fargate"
        case .lambda: return "Lambda"
        case .sagemaker: return "SageMaker"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SavingsPlanProductType(rawValue: rawValue) ?? SavingsPlanProductType.sdkUnknown(rawValue)
    }
}

extension SavingsPlanRate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currency
        case operation
        case productType
        case properties
        case rate
        case serviceCode
        case unit
        case usageType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currency = currency {
            try encodeContainer.encode(currency.rawValue, forKey: .currency)
        }
        if let operation = operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let productType = productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .properties)
            for savingsplanratepropertylist0 in properties {
                try propertiesContainer.encode(savingsplanratepropertylist0)
            }
        }
        if let rate = rate {
            try encodeContainer.encode(rate, forKey: .rate)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode.rawValue, forKey: .serviceCode)
        }
        if let unit = unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let usageType = usageType {
            try encodeContainer.encode(usageType, forKey: .usageType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rate)
        rate = rateDecoded
        let currencyDecoded = try containerValues.decodeIfPresent(CurrencyCode.self, forKey: .currency)
        currency = currencyDecoded
        let unitDecoded = try containerValues.decodeIfPresent(SavingsPlanRateUnit.self, forKey: .unit)
        unit = unitDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(SavingsPlanProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(SavingsPlanRateServiceCode.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let usageTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .usageType)
        usageType = usageTypeDecoded
        let operationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operation)
        operation = operationDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([SavingsPlanRateProperty?].self, forKey: .properties)
        var propertiesDecoded0:[SavingsPlanRateProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [SavingsPlanRateProperty]()
            for structure0 in propertiesContainer {
                if let structure0 = structure0 {
                    propertiesDecoded0?.append(structure0)
                }
            }
        }
        properties = propertiesDecoded0
    }
}

extension SavingsPlanRate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SavingsPlanRate(currency: \(String(describing: currency)), operation: \(String(describing: operation)), productType: \(String(describing: productType)), properties: \(String(describing: properties)), rate: \(String(describing: rate)), serviceCode: \(String(describing: serviceCode)), unit: \(String(describing: unit)), usageType: \(String(describing: usageType)))"}
}

/// <p>Information about a Savings Plan rate.</p>
public struct SavingsPlanRate: Equatable {
    /// <p>The currency.</p>
    public let currency: CurrencyCode?
    /// <p>The specific AWS operation for the line item in the billing report.</p>
    public let operation: String?
    /// <p>The product type.</p>
    public let productType: SavingsPlanProductType?
    /// <p>The properties.</p>
    public let properties: [SavingsPlanRateProperty]?
    /// <p>The rate.</p>
    public let rate: String?
    /// <p>The service.</p>
    public let serviceCode: SavingsPlanRateServiceCode?
    /// <p>The unit.</p>
    public let unit: SavingsPlanRateUnit?
    /// <p>The usage details of the line item in the billing report.</p>
    public let usageType: String?

    public init (
        currency: CurrencyCode? = nil,
        operation: String? = nil,
        productType: SavingsPlanProductType? = nil,
        properties: [SavingsPlanRateProperty]? = nil,
        rate: String? = nil,
        serviceCode: SavingsPlanRateServiceCode? = nil,
        unit: SavingsPlanRateUnit? = nil,
        usageType: String? = nil
    )
    {
        self.currency = currency
        self.operation = operation
        self.productType = productType
        self.properties = properties
        self.rate = rate
        self.serviceCode = serviceCode
        self.unit = unit
        self.usageType = usageType
    }
}

extension SavingsPlanRateFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for listofstrings0 in values {
                try valuesContainer.encode(listofstrings0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(SavingsPlanRateFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SavingsPlanRateFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SavingsPlanRateFilter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>Information about a filter.</p>
public struct SavingsPlanRateFilter: Equatable {
    /// <p>The filter name.</p>
    public let name: SavingsPlanRateFilterName?
    /// <p>The filter values.</p>
    public let values: [String]?

    public init (
        name: SavingsPlanRateFilterName? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

public enum SavingsPlanRateFilterAttribute {
    case instanceFamily
    case instanceType
    case productDescription
    case productId
    case region
    case tenancy
    case sdkUnknown(String)
}

extension SavingsPlanRateFilterAttribute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SavingsPlanRateFilterAttribute] {
        return [
            .instanceFamily,
            .instanceType,
            .productDescription,
            .productId,
            .region,
            .tenancy,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .instanceFamily: return "instanceFamily"
        case .instanceType: return "instanceType"
        case .productDescription: return "productDescription"
        case .productId: return "productId"
        case .region: return "region"
        case .tenancy: return "tenancy"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SavingsPlanRateFilterAttribute(rawValue: rawValue) ?? SavingsPlanRateFilterAttribute.sdkUnknown(rawValue)
    }
}

public enum SavingsPlanRateFilterName {
    case instanceType
    case operation
    case productDescription
    case productType
    case region
    case serviceCode
    case tenancy
    case usageType
    case sdkUnknown(String)
}

extension SavingsPlanRateFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SavingsPlanRateFilterName] {
        return [
            .instanceType,
            .operation,
            .productDescription,
            .productType,
            .region,
            .serviceCode,
            .tenancy,
            .usageType,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .instanceType: return "instanceType"
        case .operation: return "operation"
        case .productDescription: return "productDescription"
        case .productType: return "productType"
        case .region: return "region"
        case .serviceCode: return "serviceCode"
        case .tenancy: return "tenancy"
        case .usageType: return "usageType"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SavingsPlanRateFilterName(rawValue: rawValue) ?? SavingsPlanRateFilterName.sdkUnknown(rawValue)
    }
}

extension SavingsPlanRateProperty: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(SavingsPlanRatePropertyKey.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SavingsPlanRateProperty: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SavingsPlanRateProperty(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>Information about a property.</p>
public struct SavingsPlanRateProperty: Equatable {
    /// <p>The property name.</p>
    public let name: SavingsPlanRatePropertyKey?
    /// <p>The property value.</p>
    public let value: String?

    public init (
        name: SavingsPlanRatePropertyKey? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

public enum SavingsPlanRatePropertyKey {
    case instanceFamily
    case instanceType
    case productDescription
    case region
    case tenancy
    case sdkUnknown(String)
}

extension SavingsPlanRatePropertyKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SavingsPlanRatePropertyKey] {
        return [
            .instanceFamily,
            .instanceType,
            .productDescription,
            .region,
            .tenancy,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .instanceFamily: return "instanceFamily"
        case .instanceType: return "instanceType"
        case .productDescription: return "productDescription"
        case .region: return "region"
        case .tenancy: return "tenancy"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SavingsPlanRatePropertyKey(rawValue: rawValue) ?? SavingsPlanRatePropertyKey.sdkUnknown(rawValue)
    }
}

public enum SavingsPlanRateServiceCode {
    case ec2
    case fargate
    case fargateEks
    case lambda
    case sagemaker
    case sdkUnknown(String)
}

extension SavingsPlanRateServiceCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SavingsPlanRateServiceCode] {
        return [
            .ec2,
            .fargate,
            .fargateEks,
            .lambda,
            .sagemaker,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ec2: return "AmazonEC2"
        case .fargate: return "AmazonECS"
        case .fargateEks: return "AmazonEKS"
        case .lambda: return "AWSLambda"
        case .sagemaker: return "AmazonSageMaker"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SavingsPlanRateServiceCode(rawValue: rawValue) ?? SavingsPlanRateServiceCode.sdkUnknown(rawValue)
    }
}

public enum SavingsPlanRateUnit {
    case hours
    case lambdaGbSecond
    case request
    case sdkUnknown(String)
}

extension SavingsPlanRateUnit : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SavingsPlanRateUnit] {
        return [
            .hours,
            .lambdaGbSecond,
            .request,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .hours: return "Hrs"
        case .lambdaGbSecond: return "Lambda-GB-Second"
        case .request: return "Request"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SavingsPlanRateUnit(rawValue: rawValue) ?? SavingsPlanRateUnit.sdkUnknown(rawValue)
    }
}

public enum SavingsPlanState {
    case active
    case paymentFailed
    case paymentPending
    case queued
    case queuedDeleted
    case retired
    case sdkUnknown(String)
}

extension SavingsPlanState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SavingsPlanState] {
        return [
            .active,
            .paymentFailed,
            .paymentPending,
            .queued,
            .queuedDeleted,
            .retired,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "active"
        case .paymentFailed: return "payment-failed"
        case .paymentPending: return "payment-pending"
        case .queued: return "queued"
        case .queuedDeleted: return "queued-deleted"
        case .retired: return "retired"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SavingsPlanState(rawValue: rawValue) ?? SavingsPlanState.sdkUnknown(rawValue)
    }
}

public enum SavingsPlanType {
    case compute
    case ec2Instance
    case sagemaker
    case sdkUnknown(String)
}

extension SavingsPlanType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SavingsPlanType] {
        return [
            .compute,
            .ec2Instance,
            .sagemaker,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .compute: return "Compute"
        case .ec2Instance: return "EC2Instance"
        case .sagemaker: return "SageMaker"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SavingsPlanType(rawValue: rawValue) ?? SavingsPlanType.sdkUnknown(rawValue)
    }
}

public enum SavingsPlansFilterName {
    case commitment
    case ec2InstanceFamily
    case end
    case paymentOption
    case region
    case savingsPlanType
    case start
    case term
    case upfront
    case sdkUnknown(String)
}

extension SavingsPlansFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SavingsPlansFilterName] {
        return [
            .commitment,
            .ec2InstanceFamily,
            .end,
            .paymentOption,
            .region,
            .savingsPlanType,
            .start,
            .term,
            .upfront,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .commitment: return "commitment"
        case .ec2InstanceFamily: return "ec2-instance-family"
        case .end: return "end"
        case .paymentOption: return "payment-option"
        case .region: return "region"
        case .savingsPlanType: return "savings-plan-type"
        case .start: return "start"
        case .term: return "term"
        case .upfront: return "upfront"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SavingsPlansFilterName(rawValue: rawValue) ?? SavingsPlansFilterName.sdkUnknown(rawValue)
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A service quota has been exceeded.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>One or more tags. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>The tag keys.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tagKeys
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One of the input parameters is not valid.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
