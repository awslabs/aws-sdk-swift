// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

/// The request was denied because you don't have sufficient access to perform this action. Verify that you are a member of a role that allows this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

extension CodeCatalystClientTypes.AccessTokenSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expiresTime
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expiresTime = self.expiresTime {
            try encodeContainer.encodeTimestamp(expiresTime, format: .dateTime, forKey: .expiresTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let expiresTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expiresTime)
        expiresTime = expiresTimeDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about a specified personal access token (PAT).
    public struct AccessTokenSummary: Swift.Equatable {
        /// The date and time when the personal access token will expire, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
        public var expiresTime: ClientRuntime.Date?
        /// The system-generated ID of the personal access token.
        /// This member is required.
        public var id: Swift.String?
        /// The friendly name of the personal access token.
        /// This member is required.
        public var name: Swift.String?

        public init (
            expiresTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.expiresTime = expiresTime
            self.id = id
            self.name = name
        }
    }

}

extension CodeCatalystClientTypes {
    public enum CatalogActionVersionFileRecordType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case license
        case readme
        case sdkUnknown(Swift.String)

        public static var allCases: [CatalogActionVersionFileRecordType] {
            return [
                .license,
                .readme,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .license: return "LICENSE"
            case .readme: return "README"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CatalogActionVersionFileRecordType(rawValue: rawValue) ?? CatalogActionVersionFileRecordType.sdkUnknown(rawValue)
        }
    }
}

extension CodeCatalystClientTypes {
    public enum ComparisonOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equals
        case greaterThan
        case greaterThanOrEquals
        case lessThan
        case lessThanOrEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .equals,
                .greaterThan,
                .greaterThanOrEquals,
                .lessThan,
                .lessThanOrEquals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQ"
            case .greaterThan: return "GT"
            case .greaterThanOrEquals: return "GE"
            case .lessThan: return "LT"
            case .lessThanOrEquals: return "LE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComparisonOperator(rawValue: rawValue) ?? ComparisonOperator.sdkUnknown(rawValue)
        }
    }
}

/// The request was denied because the requested operation would cause a conflict with the current state of a service resource associated with the request. Another user might have updated the resource. Reload, make sure you have the latest data, and then try again.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

extension CreateAccessTokenInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expiresTime
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expiresTime = self.expiresTime {
            try encodeContainer.encodeTimestamp(expiresTime, format: .dateTime, forKey: .expiresTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateAccessTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/accessTokens"
    }
}

public struct CreateAccessTokenInput: Swift.Equatable {
    /// The date and time the personal access token expires, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
    public var expiresTime: ClientRuntime.Date?
    /// The friendly name of the personal access token.
    /// This member is required.
    public var name: Swift.String?

    public init (
        expiresTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil
    )
    {
        self.expiresTime = expiresTime
        self.name = name
    }
}

struct CreateAccessTokenInputBody: Swift.Equatable {
    let name: Swift.String?
    let expiresTime: ClientRuntime.Date?
}

extension CreateAccessTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expiresTime
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let expiresTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expiresTime)
        expiresTime = expiresTimeDecoded
    }
}

extension CreateAccessTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAccessTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAccessTokenOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccessTokenOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAccessTokenOutputResponse(expiresTime: \(Swift.String(describing: expiresTime)), name: \(Swift.String(describing: name)), secret: \"CONTENT_REDACTED\")"}
}

extension CreateAccessTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAccessTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.expiresTime = output.expiresTime
            self.name = output.name
            self.secret = output.secret
        } else {
            self.expiresTime = nil
            self.name = nil
            self.secret = nil
        }
    }
}

public struct CreateAccessTokenOutputResponse: Swift.Equatable {
    /// The date and time the personal access token expires, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6). If not specified, the default is one year from creation.
    public var expiresTime: ClientRuntime.Date?
    /// The friendly name of the personal access token.
    public var name: Swift.String?
    /// The secret value of the personal access token.
    /// This member is required.
    public var secret: Swift.String?

    public init (
        expiresTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        secret: Swift.String? = nil
    )
    {
        self.expiresTime = expiresTime
        self.name = name
        self.secret = secret
    }
}

struct CreateAccessTokenOutputResponseBody: Swift.Equatable {
    let secret: Swift.String?
    let name: Swift.String?
    let expiresTime: ClientRuntime.Date?
}

extension CreateAccessTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expiresTime
        case name
        case secret
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secret)
        secret = secretDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let expiresTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expiresTime)
        expiresTime = expiresTimeDecoded
    }
}

extension CreateDevEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case ides
        case inactivityTimeoutMinutes
        case instanceType
        case persistentStorage
        case repositories
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let ides = ides {
            var idesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ides)
            for ideconfiguration0 in ides {
                try idesContainer.encode(ideconfiguration0)
            }
        }
        if inactivityTimeoutMinutes != 0 {
            try encodeContainer.encode(inactivityTimeoutMinutes, forKey: .inactivityTimeoutMinutes)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType.rawValue, forKey: .instanceType)
        }
        if let persistentStorage = self.persistentStorage {
            try encodeContainer.encode(persistentStorage, forKey: .persistentStorage)
        }
        if let repositories = repositories {
            var repositoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositories)
            for repositoryinput0 in repositories {
                try repositoriesContainer.encode(repositoryinput0)
            }
        }
    }
}

extension CreateDevEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/devEnvironments"
    }
}

public struct CreateDevEnvironmentInput: Swift.Equatable {
    /// The user-defined alias for a Dev Environment.
    public var alias: Swift.String?
    /// A user-specified idempotency token. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries return the result from the original successful request and have no additional effect.
    public var clientToken: Swift.String?
    /// Information about the integrated development environment (IDE) configured for a Dev Environment. An IDE is required to create a Dev Environment. For Dev Environment creation, this field contains configuration information and must be provided.
    public var ides: [CodeCatalystClientTypes.IdeConfiguration]?
    /// The amount of time the Dev Environment will run without any activity detected before stopping, in minutes. Only whole integers are allowed. Dev Environments consume compute minutes when running.
    public var inactivityTimeoutMinutes: Swift.Int
    /// The Amazon EC2 instace type to use for the Dev Environment.
    /// This member is required.
    public var instanceType: CodeCatalystClientTypes.InstanceType?
    /// Information about the amount of storage allocated to the Dev Environment. By default, a Dev Environment is configured to have 16GB of persistent storage. Valid values for persistent storage are based on memory sizes in 16GB increments. Valid values are 16, 32, and 64.
    /// This member is required.
    public var persistentStorage: CodeCatalystClientTypes.PersistentStorageConfiguration?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The source repository that contains the branch to clone into the Dev Environment.
    public var repositories: [CodeCatalystClientTypes.RepositoryInput]?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init (
        alias: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        ides: [CodeCatalystClientTypes.IdeConfiguration]? = nil,
        inactivityTimeoutMinutes: Swift.Int = 0,
        instanceType: CodeCatalystClientTypes.InstanceType? = nil,
        persistentStorage: CodeCatalystClientTypes.PersistentStorageConfiguration? = nil,
        projectName: Swift.String? = nil,
        repositories: [CodeCatalystClientTypes.RepositoryInput]? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.ides = ides
        self.inactivityTimeoutMinutes = inactivityTimeoutMinutes
        self.instanceType = instanceType
        self.persistentStorage = persistentStorage
        self.projectName = projectName
        self.repositories = repositories
        self.spaceName = spaceName
    }
}

struct CreateDevEnvironmentInputBody: Swift.Equatable {
    let repositories: [CodeCatalystClientTypes.RepositoryInput]?
    let clientToken: Swift.String?
    let alias: Swift.String?
    let ides: [CodeCatalystClientTypes.IdeConfiguration]?
    let instanceType: CodeCatalystClientTypes.InstanceType?
    let inactivityTimeoutMinutes: Swift.Int
    let persistentStorage: CodeCatalystClientTypes.PersistentStorageConfiguration?
}

extension CreateDevEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case ides
        case inactivityTimeoutMinutes
        case instanceType
        case persistentStorage
        case repositories
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.RepositoryInput?].self, forKey: .repositories)
        var repositoriesDecoded0:[CodeCatalystClientTypes.RepositoryInput]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [CodeCatalystClientTypes.RepositoryInput]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let idesContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.IdeConfiguration?].self, forKey: .ides)
        var idesDecoded0:[CodeCatalystClientTypes.IdeConfiguration]? = nil
        if let idesContainer = idesContainer {
            idesDecoded0 = [CodeCatalystClientTypes.IdeConfiguration]()
            for structure0 in idesContainer {
                if let structure0 = structure0 {
                    idesDecoded0?.append(structure0)
                }
            }
        }
        ides = idesDecoded0
        let instanceTypeDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.InstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let inactivityTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inactivityTimeoutMinutes) ?? 0
        inactivityTimeoutMinutes = inactivityTimeoutMinutesDecoded
        let persistentStorageDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.PersistentStorageConfiguration.self, forKey: .persistentStorage)
        persistentStorage = persistentStorageDecoded
    }
}

extension CreateDevEnvironmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDevEnvironmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDevEnvironmentOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDevEnvironmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDevEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.projectName = output.projectName
            self.spaceName = output.spaceName
        } else {
            self.id = nil
            self.projectName = nil
            self.spaceName = nil
        }
    }
}

public struct CreateDevEnvironmentOutputResponse: Swift.Equatable {
    /// The system-generated unique ID of the Dev Environment.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init (
        id: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.id = id
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct CreateDevEnvironmentOutputResponseBody: Swift.Equatable {
    let spaceName: Swift.String?
    let projectName: Swift.String?
    let id: Swift.String?
}

extension CreateDevEnvironmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case projectName
        case spaceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension CreateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
    }
}

extension CreateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects"
    }
}

public struct CreateProjectInput: Swift.Equatable {
    /// The description of the project. This description will be displayed to all users of the project. We recommend providing a brief description of the project and its intended purpose.
    public var description: Swift.String?
    /// The friendly name of the project that will be displayed to users.
    /// This member is required.
    public var displayName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init (
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.spaceName = spaceName
    }
}

struct CreateProjectInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let description: Swift.String?
}

extension CreateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateProjectOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.displayName = output.displayName
            self.name = output.name
            self.spaceName = output.spaceName
        } else {
            self.description = nil
            self.displayName = nil
            self.name = nil
            self.spaceName = nil
        }
    }
}

public struct CreateProjectOutputResponse: Swift.Equatable {
    /// The description of the project.
    public var description: Swift.String?
    /// The friendly name of the project.
    public var displayName: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the space.
    public var spaceName: Swift.String?

    public init (
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        name: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.name = name
        self.spaceName = spaceName
    }
}

struct CreateProjectOutputResponseBody: Swift.Equatable {
    let spaceName: Swift.String?
    let name: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
}

extension CreateProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case name
        case spaceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateSourceRepositoryBranchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headCommitId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headCommitId = self.headCommitId {
            try encodeContainer.encode(headCommitId, forKey: .headCommitId)
        }
    }
}

extension CreateSourceRepositoryBranchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        guard let sourceRepositoryName = sourceRepositoryName else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/sourceRepositories/\(sourceRepositoryName.urlPercentEncoding())/branches/\(name.urlPercentEncoding())"
    }
}

public struct CreateSourceRepositoryBranchInput: Swift.Equatable {
    /// The commit ID in an existing branch from which you want to create the new branch.
    public var headCommitId: Swift.String?
    /// The name for the branch you're creating.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the repository where you want to create a branch.
    /// This member is required.
    public var sourceRepositoryName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init (
        headCommitId: Swift.String? = nil,
        name: Swift.String? = nil,
        projectName: Swift.String? = nil,
        sourceRepositoryName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.headCommitId = headCommitId
        self.name = name
        self.projectName = projectName
        self.sourceRepositoryName = sourceRepositoryName
        self.spaceName = spaceName
    }
}

struct CreateSourceRepositoryBranchInputBody: Swift.Equatable {
    let headCommitId: Swift.String?
}

extension CreateSourceRepositoryBranchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headCommitId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .headCommitId)
        headCommitId = headCommitIdDecoded
    }
}

extension CreateSourceRepositoryBranchOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSourceRepositoryBranchOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSourceRepositoryBranchOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSourceRepositoryBranchOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSourceRepositoryBranchOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.headCommitId = output.headCommitId
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.ref = output.ref
        } else {
            self.headCommitId = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.ref = nil
        }
    }
}

public struct CreateSourceRepositoryBranchOutputResponse: Swift.Equatable {
    /// The commit ID of the tip of the newly created branch.
    public var headCommitId: Swift.String?
    /// The time the branch was last updated, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The name of the newly created branch.
    public var name: Swift.String?
    /// The Git reference name of the branch.
    public var ref: Swift.String?

    public init (
        headCommitId: Swift.String? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        ref: Swift.String? = nil
    )
    {
        self.headCommitId = headCommitId
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.ref = ref
    }
}

struct CreateSourceRepositoryBranchOutputResponseBody: Swift.Equatable {
    let ref: Swift.String?
    let name: Swift.String?
    let lastUpdatedTime: ClientRuntime.Date?
    let headCommitId: Swift.String?
}

extension CreateSourceRepositoryBranchOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headCommitId
        case lastUpdatedTime
        case name
        case ref
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let refDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ref)
        ref = refDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let headCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .headCommitId)
        headCommitId = headCommitIdDecoded
    }
}

extension DeleteAccessTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/v1/accessTokens/\(id.urlPercentEncoding())"
    }
}

public struct DeleteAccessTokenInput: Swift.Equatable {
    /// The ID of the personal access token to delete. You can find the IDs of all PATs associated with your user account by calling [ListAccessTokens].
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteAccessTokenInputBody: Swift.Equatable {
}

extension DeleteAccessTokenInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAccessTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccessTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAccessTokenOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccessTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccessTokenOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteDevEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/devEnvironments/\(id.urlPercentEncoding())"
    }
}

public struct DeleteDevEnvironmentInput: Swift.Equatable {
    /// The system-generated unique ID of the Dev Environment you want to delete. To retrieve a list of Dev Environment IDs, use [ListDevEnvironments].
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init (
        id: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.id = id
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct DeleteDevEnvironmentInputBody: Swift.Equatable {
}

extension DeleteDevEnvironmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDevEnvironmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDevEnvironmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDevEnvironmentOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDevEnvironmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteDevEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.projectName = output.projectName
            self.spaceName = output.spaceName
        } else {
            self.id = nil
            self.projectName = nil
            self.spaceName = nil
        }
    }
}

public struct DeleteDevEnvironmentOutputResponse: Swift.Equatable {
    /// The system-generated unique ID of the deleted Dev Environment.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init (
        id: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.id = id
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct DeleteDevEnvironmentOutputResponseBody: Swift.Equatable {
    let spaceName: Swift.String?
    let projectName: Swift.String?
    let id: Swift.String?
}

extension DeleteDevEnvironmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case projectName
        case spaceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension CodeCatalystClientTypes.DevEnvironmentAccessDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamUrl
        case tokenValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamUrl = self.streamUrl {
            try encodeContainer.encode(streamUrl, forKey: .streamUrl)
        }
        if let tokenValue = self.tokenValue {
            try encodeContainer.encode(tokenValue, forKey: .tokenValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamUrl)
        streamUrl = streamUrlDecoded
        let tokenValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenValue)
        tokenValue = tokenValueDecoded
    }
}

extension CodeCatalystClientTypes.DevEnvironmentAccessDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension CodeCatalystClientTypes {
    /// Information about connection details for a Dev Environment.
    public struct DevEnvironmentAccessDetails: Swift.Equatable {
        /// The URL used to send commands to and from the Dev Environment.
        /// This member is required.
        public var streamUrl: Swift.String?
        /// An encrypted token value that contains session and caller information used to authenticate the connection.
        /// This member is required.
        public var tokenValue: Swift.String?

        public init (
            streamUrl: Swift.String? = nil,
            tokenValue: Swift.String? = nil
        )
        {
            self.streamUrl = streamUrl
            self.tokenValue = tokenValue
        }
    }

}

extension CodeCatalystClientTypes.DevEnvironmentRepositorySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about the source repsitory for a Dev Environment.
    public struct DevEnvironmentRepositorySummary: Swift.Equatable {
        /// The name of the branch in a source repository cloned into the Dev Environment.
        public var branchName: Swift.String?
        /// The name of the source repository.
        /// This member is required.
        public var repositoryName: Swift.String?

        public init (
            branchName: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.branchName = branchName
            self.repositoryName = repositoryName
        }
    }

}

extension CodeCatalystClientTypes.DevEnvironmentSessionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executeCommandSessionConfiguration
        case sessionType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executeCommandSessionConfiguration = self.executeCommandSessionConfiguration {
            try encodeContainer.encode(executeCommandSessionConfiguration, forKey: .executeCommandSessionConfiguration)
        }
        if let sessionType = self.sessionType {
            try encodeContainer.encode(sessionType.rawValue, forKey: .sessionType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionTypeDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.DevEnvironmentSessionType.self, forKey: .sessionType)
        sessionType = sessionTypeDecoded
        let executeCommandSessionConfigurationDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.ExecuteCommandSessionConfiguration.self, forKey: .executeCommandSessionConfiguration)
        executeCommandSessionConfiguration = executeCommandSessionConfigurationDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about the configuration of a Dev Environment session.
    public struct DevEnvironmentSessionConfiguration: Swift.Equatable {
        /// Information about optional commands that will be run on the Dev Environment when the SSH session begins.
        public var executeCommandSessionConfiguration: CodeCatalystClientTypes.ExecuteCommandSessionConfiguration?
        /// The type of the session.
        /// This member is required.
        public var sessionType: CodeCatalystClientTypes.DevEnvironmentSessionType?

        public init (
            executeCommandSessionConfiguration: CodeCatalystClientTypes.ExecuteCommandSessionConfiguration? = nil,
            sessionType: CodeCatalystClientTypes.DevEnvironmentSessionType? = nil
        )
        {
            self.executeCommandSessionConfiguration = executeCommandSessionConfiguration
            self.sessionType = sessionType
        }
    }

}

extension CodeCatalystClientTypes {
    public enum DevEnvironmentSessionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ssh
        case ssm
        case sdkUnknown(Swift.String)

        public static var allCases: [DevEnvironmentSessionType] {
            return [
                .ssh,
                .ssm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ssh: return "SSH"
            case .ssm: return "SSM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DevEnvironmentSessionType(rawValue: rawValue) ?? DevEnvironmentSessionType.sdkUnknown(rawValue)
        }
    }
}

extension CodeCatalystClientTypes {
    public enum DevEnvironmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case deleting
        case failed
        case pending
        case running
        case starting
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [DevEnvironmentStatus] {
            return [
                .deleted,
                .deleting,
                .failed,
                .pending,
                .running,
                .starting,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DevEnvironmentStatus(rawValue: rawValue) ?? DevEnvironmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension CodeCatalystClientTypes.DevEnvironmentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case creatorId
        case id
        case ides
        case inactivityTimeoutMinutes
        case instanceType
        case lastUpdatedTime
        case persistentStorage
        case projectName
        case repositories
        case spaceName
        case status
        case statusReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let creatorId = self.creatorId {
            try encodeContainer.encode(creatorId, forKey: .creatorId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let ides = ides {
            var idesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ides)
            for ide0 in ides {
                try idesContainer.encode(ide0)
            }
        }
        if inactivityTimeoutMinutes != 0 {
            try encodeContainer.encode(inactivityTimeoutMinutes, forKey: .inactivityTimeoutMinutes)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType.rawValue, forKey: .instanceType)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .dateTime, forKey: .lastUpdatedTime)
        }
        if let persistentStorage = self.persistentStorage {
            try encodeContainer.encode(persistentStorage, forKey: .persistentStorage)
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let repositories = repositories {
            var repositoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositories)
            for devenvironmentrepositorysummary0 in repositories {
                try repositoriesContainer.encode(devenvironmentrepositorysummary0)
            }
        }
        if let spaceName = self.spaceName {
            try encodeContainer.encode(spaceName, forKey: .spaceName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let creatorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorId)
        creatorId = creatorIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.DevEnvironmentStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let repositoriesContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.DevEnvironmentRepositorySummary?].self, forKey: .repositories)
        var repositoriesDecoded0:[CodeCatalystClientTypes.DevEnvironmentRepositorySummary]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [CodeCatalystClientTypes.DevEnvironmentRepositorySummary]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let idesContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.Ide?].self, forKey: .ides)
        var idesDecoded0:[CodeCatalystClientTypes.Ide]? = nil
        if let idesContainer = idesContainer {
            idesDecoded0 = [CodeCatalystClientTypes.Ide]()
            for structure0 in idesContainer {
                if let structure0 = structure0 {
                    idesDecoded0?.append(structure0)
                }
            }
        }
        ides = idesDecoded0
        let instanceTypeDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.InstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let inactivityTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inactivityTimeoutMinutes) ?? 0
        inactivityTimeoutMinutes = inactivityTimeoutMinutesDecoded
        let persistentStorageDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.PersistentStorage.self, forKey: .persistentStorage)
        persistentStorage = persistentStorageDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about a Dev Environment.
    public struct DevEnvironmentSummary: Swift.Equatable {
        /// The user-specified alias for the Dev Environment.
        public var alias: Swift.String?
        /// The system-generated unique ID of the user who created the Dev Environment.
        /// This member is required.
        public var creatorId: Swift.String?
        /// The system-generated unique ID for the Dev Environment.
        /// This member is required.
        public var id: Swift.String?
        /// Information about the integrated development environment (IDE) configured for a Dev Environment.
        public var ides: [CodeCatalystClientTypes.Ide]?
        /// The amount of time the Dev Environment will run without any activity detected before stopping, in minutes. Dev Environments consume compute minutes when running.
        /// This member is required.
        public var inactivityTimeoutMinutes: Swift.Int
        /// The Amazon EC2 instace type used for the Dev Environment.
        /// This member is required.
        public var instanceType: CodeCatalystClientTypes.InstanceType?
        /// The time when the Dev Environment was last updated, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
        /// This member is required.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// Information about the configuration of persistent storage for the Dev Environment.
        /// This member is required.
        public var persistentStorage: CodeCatalystClientTypes.PersistentStorage?
        /// The name of the project in the space.
        public var projectName: Swift.String?
        /// Information about the repositories that will be cloned into the Dev Environment. If no rvalue is specified, no repository is cloned.
        /// This member is required.
        public var repositories: [CodeCatalystClientTypes.DevEnvironmentRepositorySummary]?
        /// The name of the space.
        public var spaceName: Swift.String?
        /// The status of the Dev Environment.
        /// This member is required.
        public var status: CodeCatalystClientTypes.DevEnvironmentStatus?
        /// The reason for the status.
        public var statusReason: Swift.String?

        public init (
            alias: Swift.String? = nil,
            creatorId: Swift.String? = nil,
            id: Swift.String? = nil,
            ides: [CodeCatalystClientTypes.Ide]? = nil,
            inactivityTimeoutMinutes: Swift.Int = 0,
            instanceType: CodeCatalystClientTypes.InstanceType? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            persistentStorage: CodeCatalystClientTypes.PersistentStorage? = nil,
            projectName: Swift.String? = nil,
            repositories: [CodeCatalystClientTypes.DevEnvironmentRepositorySummary]? = nil,
            spaceName: Swift.String? = nil,
            status: CodeCatalystClientTypes.DevEnvironmentStatus? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.alias = alias
            self.creatorId = creatorId
            self.id = id
            self.ides = ides
            self.inactivityTimeoutMinutes = inactivityTimeoutMinutes
            self.instanceType = instanceType
            self.lastUpdatedTime = lastUpdatedTime
            self.persistentStorage = persistentStorage
            self.projectName = projectName
            self.repositories = repositories
            self.spaceName = spaceName
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension CodeCatalystClientTypes.EmailAddress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email
        case verified
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let verified = self.verified {
            try encodeContainer.encode(verified, forKey: .verified)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let verifiedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .verified)
        verified = verifiedDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about an email address.
    public struct EmailAddress: Swift.Equatable {
        /// The email address.
        public var email: Swift.String?
        /// Whether the email address has been verified.
        public var verified: Swift.Bool?

        public init (
            email: Swift.String? = nil,
            verified: Swift.Bool? = nil
        )
        {
            self.email = email
            self.verified = verified
        }
    }

}

extension CodeCatalystClientTypes.EventLogEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case eventCategory
        case eventName
        case eventSource
        case eventTime
        case eventType
        case id
        case operationType
        case projectInformation
        case requestId
        case requestPayload
        case responsePayload
        case sourceIpAddress
        case userAgent
        case userIdentity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let eventCategory = self.eventCategory {
            try encodeContainer.encode(eventCategory, forKey: .eventCategory)
        }
        if let eventName = self.eventName {
            try encodeContainer.encode(eventName, forKey: .eventName)
        }
        if let eventSource = self.eventSource {
            try encodeContainer.encode(eventSource, forKey: .eventSource)
        }
        if let eventTime = self.eventTime {
            try encodeContainer.encodeTimestamp(eventTime, format: .dateTime, forKey: .eventTime)
        }
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let operationType = self.operationType {
            try encodeContainer.encode(operationType.rawValue, forKey: .operationType)
        }
        if let projectInformation = self.projectInformation {
            try encodeContainer.encode(projectInformation, forKey: .projectInformation)
        }
        if let requestId = self.requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let requestPayload = self.requestPayload {
            try encodeContainer.encode(requestPayload, forKey: .requestPayload)
        }
        if let responsePayload = self.responsePayload {
            try encodeContainer.encode(responsePayload, forKey: .responsePayload)
        }
        if let sourceIpAddress = self.sourceIpAddress {
            try encodeContainer.encode(sourceIpAddress, forKey: .sourceIpAddress)
        }
        if let userAgent = self.userAgent {
            try encodeContainer.encode(userAgent, forKey: .userAgent)
        }
        if let userIdentity = self.userIdentity {
            try encodeContainer.encode(userIdentity, forKey: .userIdentity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let eventNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventName)
        eventName = eventNameDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let eventCategoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventCategory)
        eventCategory = eventCategoryDecoded
        let eventSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSource)
        eventSource = eventSourceDecoded
        let eventTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let operationTypeDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.OperationType.self, forKey: .operationType)
        operationType = operationTypeDecoded
        let userIdentityDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.UserIdentity.self, forKey: .userIdentity)
        userIdentity = userIdentityDecoded
        let projectInformationDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.ProjectInformation.self, forKey: .projectInformation)
        projectInformation = projectInformationDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let requestPayloadDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.EventPayload.self, forKey: .requestPayload)
        requestPayload = requestPayloadDecoded
        let responsePayloadDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.EventPayload.self, forKey: .responsePayload)
        responsePayload = responsePayloadDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let sourceIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIpAddress)
        sourceIpAddress = sourceIpAddressDecoded
        let userAgentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAgent)
        userAgent = userAgentDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about an entry in an event log of Amazon CodeCatalyst activity.
    public struct EventLogEntry: Swift.Equatable {
        /// The code of the error, if any.
        public var errorCode: Swift.String?
        /// The category for the event.
        /// This member is required.
        public var eventCategory: Swift.String?
        /// The name of the event.
        /// This member is required.
        public var eventName: Swift.String?
        /// The source of the event.
        /// This member is required.
        public var eventSource: Swift.String?
        /// The time the event took place, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
        /// This member is required.
        public var eventTime: ClientRuntime.Date?
        /// The type of the event.
        /// This member is required.
        public var eventType: Swift.String?
        /// The system-generated unique ID of the event.
        /// This member is required.
        public var id: Swift.String?
        /// The type of the event.
        /// This member is required.
        public var operationType: CodeCatalystClientTypes.OperationType?
        /// Information about the project where the event occurred.
        public var projectInformation: CodeCatalystClientTypes.ProjectInformation?
        /// The system-generated unique ID of the request.
        public var requestId: Swift.String?
        /// Information about the payload of the request.
        public var requestPayload: CodeCatalystClientTypes.EventPayload?
        /// Information about the payload of the response, if any.
        public var responsePayload: CodeCatalystClientTypes.EventPayload?
        /// The IP address of the user whose actions are recorded in the event.
        public var sourceIpAddress: Swift.String?
        ///
        public var userAgent: Swift.String?
        /// The system-generated unique ID of the user whose actions are recorded in the event.
        /// This member is required.
        public var userIdentity: CodeCatalystClientTypes.UserIdentity?

        public init (
            errorCode: Swift.String? = nil,
            eventCategory: Swift.String? = nil,
            eventName: Swift.String? = nil,
            eventSource: Swift.String? = nil,
            eventTime: ClientRuntime.Date? = nil,
            eventType: Swift.String? = nil,
            id: Swift.String? = nil,
            operationType: CodeCatalystClientTypes.OperationType? = nil,
            projectInformation: CodeCatalystClientTypes.ProjectInformation? = nil,
            requestId: Swift.String? = nil,
            requestPayload: CodeCatalystClientTypes.EventPayload? = nil,
            responsePayload: CodeCatalystClientTypes.EventPayload? = nil,
            sourceIpAddress: Swift.String? = nil,
            userAgent: Swift.String? = nil,
            userIdentity: CodeCatalystClientTypes.UserIdentity? = nil
        )
        {
            self.errorCode = errorCode
            self.eventCategory = eventCategory
            self.eventName = eventName
            self.eventSource = eventSource
            self.eventTime = eventTime
            self.eventType = eventType
            self.id = id
            self.operationType = operationType
            self.projectInformation = projectInformation
            self.requestId = requestId
            self.requestPayload = requestPayload
            self.responsePayload = responsePayload
            self.sourceIpAddress = sourceIpAddress
            self.userAgent = userAgent
            self.userIdentity = userIdentity
        }
    }

}

extension CodeCatalystClientTypes.EventPayload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
        case data
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let data = self.data {
            try encodeContainer.encode(data, forKey: .data)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let dataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .data)
        data = dataDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about the payload of an event recording Amazon CodeCatalyst activity.
    public struct EventPayload: Swift.Equatable {
        /// The type of content in the event payload.
        public var contentType: Swift.String?
        /// The data included in the event payload.
        public var data: Swift.String?

        public init (
            contentType: Swift.String? = nil,
            data: Swift.String? = nil
        )
        {
            self.contentType = contentType
            self.data = data
        }
    }

}

extension CodeCatalystClientTypes.ExecuteCommandSessionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arguments
        case command
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arguments = arguments {
            var argumentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arguments)
            for string0 in arguments {
                try argumentsContainer.encode(string0)
            }
        }
        if let command = self.command {
            try encodeContainer.encode(command, forKey: .command)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .command)
        command = commandDecoded
        let argumentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .arguments)
        var argumentsDecoded0:[Swift.String]? = nil
        if let argumentsContainer = argumentsContainer {
            argumentsDecoded0 = [Swift.String]()
            for string0 in argumentsContainer {
                if let string0 = string0 {
                    argumentsDecoded0?.append(string0)
                }
            }
        }
        arguments = argumentsDecoded0
    }
}

extension CodeCatalystClientTypes {
    /// Information about the commands that will be run on a Dev Environment when an SSH session begins.
    public struct ExecuteCommandSessionConfiguration: Swift.Equatable {
        /// An array of arguments containing arguments and members.
        public var arguments: [Swift.String]?
        /// The command used at the beginning of the SSH session to a Dev Environment.
        /// This member is required.
        public var command: Swift.String?

        public init (
            arguments: [Swift.String]? = nil,
            command: Swift.String? = nil
        )
        {
            self.arguments = arguments
            self.command = command
        }
    }

}

extension CodeCatalystClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparisonOperator
        case key
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = self.comparisonOperator {
            try encodeContainer.encode(comparisonOperator, forKey: .comparisonOperator)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string0 in values {
                try valuesContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
    }
}

extension CodeCatalystClientTypes {
    ///
    public struct Filter: Swift.Equatable {
        ///
        public var comparisonOperator: Swift.String?
        ///
        /// This member is required.
        public var key: Swift.String?
        ///
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            comparisonOperator: Swift.String? = nil,
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.key = key
            self.values = values
        }
    }

}

extension CodeCatalystClientTypes {
    public enum FilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hasAccessTo
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterKey] {
            return [
                .hasAccessTo,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hasAccessTo: return "hasAccessTo"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterKey(rawValue: rawValue) ?? FilterKey.sdkUnknown(rawValue)
        }
    }
}

extension GetDevEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/devEnvironments/\(id.urlPercentEncoding())"
    }
}

public struct GetDevEnvironmentInput: Swift.Equatable {
    /// The system-generated unique ID of the Dev Environment for which you want to view information. To retrieve a list of Dev Environment IDs, use [ListDevEnvironments].
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init (
        id: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.id = id
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct GetDevEnvironmentInputBody: Swift.Equatable {
}

extension GetDevEnvironmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDevEnvironmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDevEnvironmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDevEnvironmentOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDevEnvironmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDevEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alias = output.alias
            self.creatorId = output.creatorId
            self.id = output.id
            self.ides = output.ides
            self.inactivityTimeoutMinutes = output.inactivityTimeoutMinutes
            self.instanceType = output.instanceType
            self.lastUpdatedTime = output.lastUpdatedTime
            self.persistentStorage = output.persistentStorage
            self.projectName = output.projectName
            self.repositories = output.repositories
            self.spaceName = output.spaceName
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.alias = nil
            self.creatorId = nil
            self.id = nil
            self.ides = nil
            self.inactivityTimeoutMinutes = 0
            self.instanceType = nil
            self.lastUpdatedTime = nil
            self.persistentStorage = nil
            self.projectName = nil
            self.repositories = nil
            self.spaceName = nil
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct GetDevEnvironmentOutputResponse: Swift.Equatable {
    /// The user-specified alias for the Dev Environment.
    public var alias: Swift.String?
    /// The system-generated unique ID of the user who created the Dev Environment.
    /// This member is required.
    public var creatorId: Swift.String?
    /// The system-generated unique ID of the Dev Environment.
    /// This member is required.
    public var id: Swift.String?
    /// Information about the integrated development environment (IDE) configured for the Dev Environment.
    public var ides: [CodeCatalystClientTypes.Ide]?
    /// The amount of time the Dev Environment will run without any activity detected before stopping, in minutes.
    /// This member is required.
    public var inactivityTimeoutMinutes: Swift.Int
    /// The Amazon EC2 instace type to use for the Dev Environment.
    /// This member is required.
    public var instanceType: CodeCatalystClientTypes.InstanceType?
    /// The time when the Dev Environment was last updated, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
    /// This member is required.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// Information about the amount of storage allocated to the Dev Environment. By default, a Dev Environment is configured to have 16GB of persistent storage.
    /// This member is required.
    public var persistentStorage: CodeCatalystClientTypes.PersistentStorage?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The source repository that contains the branch cloned into the Dev Environment.
    /// This member is required.
    public var repositories: [CodeCatalystClientTypes.DevEnvironmentRepositorySummary]?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?
    /// The current status of the Dev Environment.
    /// This member is required.
    public var status: CodeCatalystClientTypes.DevEnvironmentStatus?
    /// The reason for the status.
    public var statusReason: Swift.String?

    public init (
        alias: Swift.String? = nil,
        creatorId: Swift.String? = nil,
        id: Swift.String? = nil,
        ides: [CodeCatalystClientTypes.Ide]? = nil,
        inactivityTimeoutMinutes: Swift.Int = 0,
        instanceType: CodeCatalystClientTypes.InstanceType? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        persistentStorage: CodeCatalystClientTypes.PersistentStorage? = nil,
        projectName: Swift.String? = nil,
        repositories: [CodeCatalystClientTypes.DevEnvironmentRepositorySummary]? = nil,
        spaceName: Swift.String? = nil,
        status: CodeCatalystClientTypes.DevEnvironmentStatus? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.alias = alias
        self.creatorId = creatorId
        self.id = id
        self.ides = ides
        self.inactivityTimeoutMinutes = inactivityTimeoutMinutes
        self.instanceType = instanceType
        self.lastUpdatedTime = lastUpdatedTime
        self.persistentStorage = persistentStorage
        self.projectName = projectName
        self.repositories = repositories
        self.spaceName = spaceName
        self.status = status
        self.statusReason = statusReason
    }
}

struct GetDevEnvironmentOutputResponseBody: Swift.Equatable {
    let spaceName: Swift.String?
    let projectName: Swift.String?
    let id: Swift.String?
    let lastUpdatedTime: ClientRuntime.Date?
    let creatorId: Swift.String?
    let status: CodeCatalystClientTypes.DevEnvironmentStatus?
    let statusReason: Swift.String?
    let repositories: [CodeCatalystClientTypes.DevEnvironmentRepositorySummary]?
    let alias: Swift.String?
    let ides: [CodeCatalystClientTypes.Ide]?
    let instanceType: CodeCatalystClientTypes.InstanceType?
    let inactivityTimeoutMinutes: Swift.Int
    let persistentStorage: CodeCatalystClientTypes.PersistentStorage?
}

extension GetDevEnvironmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case creatorId
        case id
        case ides
        case inactivityTimeoutMinutes
        case instanceType
        case lastUpdatedTime
        case persistentStorage
        case projectName
        case repositories
        case spaceName
        case status
        case statusReason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let creatorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorId)
        creatorId = creatorIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.DevEnvironmentStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let repositoriesContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.DevEnvironmentRepositorySummary?].self, forKey: .repositories)
        var repositoriesDecoded0:[CodeCatalystClientTypes.DevEnvironmentRepositorySummary]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [CodeCatalystClientTypes.DevEnvironmentRepositorySummary]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let idesContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.Ide?].self, forKey: .ides)
        var idesDecoded0:[CodeCatalystClientTypes.Ide]? = nil
        if let idesContainer = idesContainer {
            idesDecoded0 = [CodeCatalystClientTypes.Ide]()
            for structure0 in idesContainer {
                if let structure0 = structure0 {
                    idesDecoded0?.append(structure0)
                }
            }
        }
        ides = idesDecoded0
        let instanceTypeDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.InstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let inactivityTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inactivityTimeoutMinutes) ?? 0
        inactivityTimeoutMinutes = inactivityTimeoutMinutesDecoded
        let persistentStorageDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.PersistentStorage.self, forKey: .persistentStorage)
        persistentStorage = persistentStorageDecoded
    }
}

extension GetProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(name.urlPercentEncoding())"
    }
}

public struct GetProjectInput: Swift.Equatable {
    /// The name of the project in the space.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init (
        name: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.name = name
        self.spaceName = spaceName
    }
}

struct GetProjectInputBody: Swift.Equatable {
}

extension GetProjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetProjectOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.displayName = output.displayName
            self.name = output.name
            self.spaceName = output.spaceName
        } else {
            self.description = nil
            self.displayName = nil
            self.name = nil
            self.spaceName = nil
        }
    }
}

public struct GetProjectOutputResponse: Swift.Equatable {
    /// The description of the project.
    public var description: Swift.String?
    /// The friendly name of the project displayed to users in Amazon CodeCatalyst.
    public var displayName: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the space.
    public var spaceName: Swift.String?

    public init (
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        name: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.name = name
        self.spaceName = spaceName
    }
}

struct GetProjectOutputResponseBody: Swift.Equatable {
    let spaceName: Swift.String?
    let name: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
}

extension GetProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case name
        case spaceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension GetSourceRepositoryCloneUrlsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        guard let sourceRepositoryName = sourceRepositoryName else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/sourceRepositories/\(sourceRepositoryName.urlPercentEncoding())/cloneUrls"
    }
}

public struct GetSourceRepositoryCloneUrlsInput: Swift.Equatable {
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the source repository.
    /// This member is required.
    public var sourceRepositoryName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init (
        projectName: Swift.String? = nil,
        sourceRepositoryName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.projectName = projectName
        self.sourceRepositoryName = sourceRepositoryName
        self.spaceName = spaceName
    }
}

struct GetSourceRepositoryCloneUrlsInputBody: Swift.Equatable {
}

extension GetSourceRepositoryCloneUrlsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSourceRepositoryCloneUrlsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSourceRepositoryCloneUrlsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSourceRepositoryCloneUrlsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSourceRepositoryCloneUrlsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSourceRepositoryCloneUrlsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.https = output.https
        } else {
            self.https = nil
        }
    }
}

public struct GetSourceRepositoryCloneUrlsOutputResponse: Swift.Equatable {
    /// The HTTPS URL to use when cloning the source repository.
    /// This member is required.
    public var https: Swift.String?

    public init (
        https: Swift.String? = nil
    )
    {
        self.https = https
    }
}

struct GetSourceRepositoryCloneUrlsOutputResponseBody: Swift.Equatable {
    let https: Swift.String?
}

extension GetSourceRepositoryCloneUrlsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case https
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .https)
        https = httpsDecoded
    }
}

extension GetSpaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v1/spaces/\(name.urlPercentEncoding())"
    }
}

public struct GetSpaceInput: Swift.Equatable {
    /// The name of the space.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetSpaceInputBody: Swift.Equatable {
}

extension GetSpaceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSpaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSpaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSpaceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSpaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSpaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.displayName = output.displayName
            self.name = output.name
            self.regionName = output.regionName
        } else {
            self.description = nil
            self.displayName = nil
            self.name = nil
            self.regionName = nil
        }
    }
}

public struct GetSpaceOutputResponse: Swift.Equatable {
    /// The description of the space.
    public var description: Swift.String?
    /// The friendly name of the space displayed to users.
    public var displayName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Web Services Region where the space exists.
    /// This member is required.
    public var regionName: Swift.String?

    public init (
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        name: Swift.String? = nil,
        regionName: Swift.String? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.name = name
        self.regionName = regionName
    }
}

struct GetSpaceOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let regionName: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
}

extension GetSpaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case name
        case regionName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let regionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionName)
        regionName = regionNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension GetSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/subscription"
    }
}

public struct GetSubscriptionInput: Swift.Equatable {
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init (
        spaceName: Swift.String? = nil
    )
    {
        self.spaceName = spaceName
    }
}

struct GetSubscriptionInputBody: Swift.Equatable {
}

extension GetSubscriptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awsAccountName = output.awsAccountName
            self.subscriptionType = output.subscriptionType
        } else {
            self.awsAccountName = nil
            self.subscriptionType = nil
        }
    }
}

public struct GetSubscriptionOutputResponse: Swift.Equatable {
    /// The display name of the Amazon Web Services account used for billing for the space.
    public var awsAccountName: Swift.String?
    /// The type of the billing plan for the space.
    public var subscriptionType: Swift.String?

    public init (
        awsAccountName: Swift.String? = nil,
        subscriptionType: Swift.String? = nil
    )
    {
        self.awsAccountName = awsAccountName
        self.subscriptionType = subscriptionType
    }
}

struct GetSubscriptionOutputResponseBody: Swift.Equatable {
    let subscriptionType: Swift.String?
    let awsAccountName: Swift.String?
}

extension GetSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountName
        case subscriptionType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionType)
        subscriptionType = subscriptionTypeDecoded
        let awsAccountNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountName)
        awsAccountName = awsAccountNameDecoded
    }
}

extension GetUserDetailsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let id = id {
                let idQueryItem = ClientRuntime.URLQueryItem(name: "id".urlPercentEncoding(), value: Swift.String(id).urlPercentEncoding())
                items.append(idQueryItem)
            }
            if let userName = userName {
                let userNameQueryItem = ClientRuntime.URLQueryItem(name: "userName".urlPercentEncoding(), value: Swift.String(userName).urlPercentEncoding())
                items.append(userNameQueryItem)
            }
            return items
        }
    }
}

extension GetUserDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/userDetails"
    }
}

public struct GetUserDetailsInput: Swift.Equatable {
    /// The system-generated unique ID of the user.
    public var id: Swift.String?
    /// The name of the user as displayed in Amazon CodeCatalyst.
    public var userName: Swift.String?

    public init (
        id: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.id = id
        self.userName = userName
    }
}

struct GetUserDetailsInputBody: Swift.Equatable {
}

extension GetUserDetailsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetUserDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUserDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetUserDetailsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUserDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetUserDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.displayName = output.displayName
            self.primaryEmail = output.primaryEmail
            self.userId = output.userId
            self.userName = output.userName
            self.version = output.version
        } else {
            self.displayName = nil
            self.primaryEmail = nil
            self.userId = nil
            self.userName = nil
            self.version = nil
        }
    }
}

public struct GetUserDetailsOutputResponse: Swift.Equatable {
    /// The friendly name displayed for the user in Amazon CodeCatalyst.
    public var displayName: Swift.String?
    /// The email address provided by the user when they signed up.
    public var primaryEmail: CodeCatalystClientTypes.EmailAddress?
    /// The system-generated unique ID of the user.
    public var userId: Swift.String?
    /// The name of the user as displayed in Amazon CodeCatalyst.
    public var userName: Swift.String?
    ///
    public var version: Swift.String?

    public init (
        displayName: Swift.String? = nil,
        primaryEmail: CodeCatalystClientTypes.EmailAddress? = nil,
        userId: Swift.String? = nil,
        userName: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.primaryEmail = primaryEmail
        self.userId = userId
        self.userName = userName
        self.version = version
    }
}

struct GetUserDetailsOutputResponseBody: Swift.Equatable {
    let userId: Swift.String?
    let userName: Swift.String?
    let displayName: Swift.String?
    let primaryEmail: CodeCatalystClientTypes.EmailAddress?
    let version: Swift.String?
}

extension GetUserDetailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case primaryEmail
        case userId
        case userName
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let primaryEmailDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.EmailAddress.self, forKey: .primaryEmail)
        primaryEmail = primaryEmailDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension CodeCatalystClientTypes.Ide: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case runtime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let runtime = self.runtime {
            try encodeContainer.encode(runtime, forKey: .runtime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runtimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtime)
        runtime = runtimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about an integrated development environment (IDE) used in a Dev Environment.
    public struct Ide: Swift.Equatable {
        /// The name of the IDE.
        public var name: Swift.String?
        /// A link to the IDE runtime image.
        public var runtime: Swift.String?

        public init (
            name: Swift.String? = nil,
            runtime: Swift.String? = nil
        )
        {
            self.name = name
            self.runtime = runtime
        }
    }

}

extension CodeCatalystClientTypes.IdeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case runtime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let runtime = self.runtime {
            try encodeContainer.encode(runtime, forKey: .runtime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runtimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtime)
        runtime = runtimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about the configuration of an integrated development environment (IDE) for a Dev Environment.
    public struct IdeConfiguration: Swift.Equatable {
        /// The name of the IDE.
        public var name: Swift.String?
        /// A link to the IDE runtime image.
        public var runtime: Swift.String?

        public init (
            name: Swift.String? = nil,
            runtime: Swift.String? = nil
        )
        {
            self.name = name
            self.runtime = runtime
        }
    }

}

extension CodeCatalystClientTypes {
    public enum InstanceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case devStandard1Large
        case devStandard1Medium
        case devStandard1Small
        case devStandard1Xlarge
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceType] {
            return [
                .devStandard1Large,
                .devStandard1Medium,
                .devStandard1Small,
                .devStandard1Xlarge,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .devStandard1Large: return "dev.standard1.large"
            case .devStandard1Medium: return "dev.standard1.medium"
            case .devStandard1Small: return "dev.standard1.small"
            case .devStandard1Xlarge: return "dev.standard1.xlarge"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstanceType(rawValue: rawValue) ?? InstanceType.sdkUnknown(rawValue)
        }
    }
}

extension ListAccessTokensInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAccessTokensInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/accessTokens"
    }
}

public struct ListAccessTokensInput: Swift.Equatable {
    /// The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a NextToken element, which you can use to obtain additional results.
    public var maxResults: Swift.Int?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAccessTokensInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAccessTokensInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAccessTokensOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccessTokensOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAccessTokensOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccessTokensOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAccessTokensOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccessTokensOutputResponse: Swift.Equatable {
    /// A list of personal access tokens (PATs) associated with the calling user.
    /// This member is required.
    public var items: [CodeCatalystClientTypes.AccessTokenSummary]?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?

    public init (
        items: [CodeCatalystClientTypes.AccessTokenSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListAccessTokensOutputResponseBody: Swift.Equatable {
    let items: [CodeCatalystClientTypes.AccessTokenSummary]?
    let nextToken: Swift.String?
}

extension ListAccessTokensOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.AccessTokenSummary?].self, forKey: .items)
        var itemsDecoded0:[CodeCatalystClientTypes.AccessTokenSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CodeCatalystClientTypes.AccessTokenSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDevEnvironmentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDevEnvironmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/devEnvironments"
    }
}

public struct ListDevEnvironmentsInput: Swift.Equatable {
    /// Information about filters to apply to narrow the results returned in the list.
    public var filters: [CodeCatalystClientTypes.Filter]?
    /// The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a NextToken element, which you can use to obtain additional results.
    public var maxResults: Swift.Int?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init (
        filters: [CodeCatalystClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct ListDevEnvironmentsInputBody: Swift.Equatable {
    let filters: [CodeCatalystClientTypes.Filter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDevEnvironmentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[CodeCatalystClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [CodeCatalystClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDevEnvironmentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDevEnvironmentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDevEnvironmentsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDevEnvironmentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDevEnvironmentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListDevEnvironmentsOutputResponse: Swift.Equatable {
    /// Information about the Dev Environments in a project.
    /// This member is required.
    public var items: [CodeCatalystClientTypes.DevEnvironmentSummary]?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?

    public init (
        items: [CodeCatalystClientTypes.DevEnvironmentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListDevEnvironmentsOutputResponseBody: Swift.Equatable {
    let items: [CodeCatalystClientTypes.DevEnvironmentSummary]?
    let nextToken: Swift.String?
}

extension ListDevEnvironmentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.DevEnvironmentSummary?].self, forKey: .items)
        var itemsDecoded0:[CodeCatalystClientTypes.DevEnvironmentSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CodeCatalystClientTypes.DevEnvironmentSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEventLogsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case eventName
        case maxResults
        case nextToken
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let eventName = self.eventName {
            try encodeContainer.encode(eventName, forKey: .eventName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
    }
}

extension ListEventLogsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/eventLogs"
    }
}

public struct ListEventLogsInput: Swift.Equatable {
    /// The time after which you do not want any events retrieved, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// The name of the event.
    public var eventName: Swift.String?
    /// The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a NextToken element, which you can use to obtain additional results.
    public var maxResults: Swift.Int?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?
    /// The date and time when you want to start retrieving events, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
    /// This member is required.
    public var startTime: ClientRuntime.Date?

    public init (
        endTime: ClientRuntime.Date? = nil,
        eventName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        spaceName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.eventName = eventName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.spaceName = spaceName
        self.startTime = startTime
    }
}

struct ListEventLogsInputBody: Swift.Equatable {
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let eventName: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEventLogsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case eventName
        case maxResults
        case nextToken
        case startTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
        let eventNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventName)
        eventName = eventNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEventLogsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEventLogsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListEventLogsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEventLogsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListEventLogsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventLogsOutputResponse: Swift.Equatable {
    /// Information about each event retrieved in the list.
    /// This member is required.
    public var items: [CodeCatalystClientTypes.EventLogEntry]?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?

    public init (
        items: [CodeCatalystClientTypes.EventLogEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListEventLogsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let items: [CodeCatalystClientTypes.EventLogEntry]?
}

extension ListEventLogsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let itemsContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.EventLogEntry?].self, forKey: .items)
        var itemsDecoded0:[CodeCatalystClientTypes.EventLogEntry]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CodeCatalystClientTypes.EventLogEntry]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension ListProjectsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for projectlistfilter0 in filters {
                try filtersContainer.encode(projectlistfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListProjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects"
    }
}

public struct ListProjectsInput: Swift.Equatable {
    /// Information about filters to apply to narrow the results returned in the list.
    public var filters: [CodeCatalystClientTypes.ProjectListFilter]?
    /// The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a NextToken element, which you can use to obtain additional results.
    public var maxResults: Swift.Int?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init (
        filters: [CodeCatalystClientTypes.ProjectListFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.spaceName = spaceName
    }
}

struct ListProjectsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [CodeCatalystClientTypes.ProjectListFilter]?
}

extension ListProjectsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.ProjectListFilter?].self, forKey: .filters)
        var filtersDecoded0:[CodeCatalystClientTypes.ProjectListFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [CodeCatalystClientTypes.ProjectListFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListProjectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProjectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListProjectsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProjectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListProjectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListProjectsOutputResponse: Swift.Equatable {
    /// Information about the projects.
    public var items: [CodeCatalystClientTypes.ProjectSummary]?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?

    public init (
        items: [CodeCatalystClientTypes.ProjectSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListProjectsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let items: [CodeCatalystClientTypes.ProjectSummary]?
}

extension ListProjectsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let itemsContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.ProjectSummary?].self, forKey: .items)
        var itemsDecoded0:[CodeCatalystClientTypes.ProjectSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CodeCatalystClientTypes.ProjectSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension ListSourceRepositoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSourceRepositoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/sourceRepositories"
    }
}

public struct ListSourceRepositoriesInput: Swift.Equatable {
    /// The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a NextToken element, which you can use to obtain additional results.
    public var maxResults: Swift.Int?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct ListSourceRepositoriesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListSourceRepositoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension CodeCatalystClientTypes.ListSourceRepositoriesItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime
        case description
        case id
        case lastUpdatedTime
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .dateTime, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .dateTime, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about a source repository returned in a list of source repositories.
    public struct ListSourceRepositoriesItem: Swift.Equatable {
        /// The time the source repository was created, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The description of the repository, if any.
        public var description: Swift.String?
        /// The system-generated unique ID of the source repository.
        /// This member is required.
        public var id: Swift.String?
        /// The time the source repository was last updated, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
        /// This member is required.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the source repository.
        /// This member is required.
        public var name: Swift.String?

        public init (
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.createdTime = createdTime
            self.description = description
            self.id = id
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }
    }

}

extension ListSourceRepositoriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSourceRepositoriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSourceRepositoriesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSourceRepositoriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSourceRepositoriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListSourceRepositoriesOutputResponse: Swift.Equatable {
    /// Information about the source repositories.
    public var items: [CodeCatalystClientTypes.ListSourceRepositoriesItem]?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?

    public init (
        items: [CodeCatalystClientTypes.ListSourceRepositoriesItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListSourceRepositoriesOutputResponseBody: Swift.Equatable {
    let items: [CodeCatalystClientTypes.ListSourceRepositoriesItem]?
    let nextToken: Swift.String?
}

extension ListSourceRepositoriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.ListSourceRepositoriesItem?].self, forKey: .items)
        var itemsDecoded0:[CodeCatalystClientTypes.ListSourceRepositoriesItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CodeCatalystClientTypes.ListSourceRepositoriesItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSourceRepositoryBranchesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSourceRepositoryBranchesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        guard let sourceRepositoryName = sourceRepositoryName else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/sourceRepositories/\(sourceRepositoryName.urlPercentEncoding())/branches"
    }
}

public struct ListSourceRepositoryBranchesInput: Swift.Equatable {
    /// The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a NextToken element, which you can use to obtain additional results.
    public var maxResults: Swift.Int?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the source repository.
    /// This member is required.
    public var sourceRepositoryName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectName: Swift.String? = nil,
        sourceRepositoryName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
        self.sourceRepositoryName = sourceRepositoryName
        self.spaceName = spaceName
    }
}

struct ListSourceRepositoryBranchesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListSourceRepositoryBranchesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension CodeCatalystClientTypes.ListSourceRepositoryBranchesItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headCommitId
        case lastUpdatedTime
        case name
        case ref
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headCommitId = self.headCommitId {
            try encodeContainer.encode(headCommitId, forKey: .headCommitId)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .dateTime, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ref = self.ref {
            try encodeContainer.encode(ref, forKey: .ref)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let refDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ref)
        ref = refDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let headCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .headCommitId)
        headCommitId = headCommitIdDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about a branch of a source repository returned in a list of branches.
    public struct ListSourceRepositoryBranchesItem: Swift.Equatable {
        /// The commit ID of the tip of the branch at the time of the request, also known as the head commit.
        public var headCommitId: Swift.String?
        /// The time the branch was last updated, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the branch.
        public var name: Swift.String?
        /// The Git reference name of the branch.
        public var ref: Swift.String?

        public init (
            headCommitId: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            ref: Swift.String? = nil
        )
        {
            self.headCommitId = headCommitId
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.ref = ref
        }
    }

}

extension ListSourceRepositoryBranchesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSourceRepositoryBranchesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSourceRepositoryBranchesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSourceRepositoryBranchesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSourceRepositoryBranchesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListSourceRepositoryBranchesOutputResponse: Swift.Equatable {
    /// Information about the source branches.
    public var items: [CodeCatalystClientTypes.ListSourceRepositoryBranchesItem]?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?

    public init (
        items: [CodeCatalystClientTypes.ListSourceRepositoryBranchesItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListSourceRepositoryBranchesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let items: [CodeCatalystClientTypes.ListSourceRepositoryBranchesItem]?
}

extension ListSourceRepositoryBranchesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let itemsContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.ListSourceRepositoryBranchesItem?].self, forKey: .items)
        var itemsDecoded0:[CodeCatalystClientTypes.ListSourceRepositoryBranchesItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CodeCatalystClientTypes.ListSourceRepositoryBranchesItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension ListSpacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSpacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/spaces"
    }
}

public struct ListSpacesInput: Swift.Equatable {
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListSpacesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListSpacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSpacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSpacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSpacesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSpacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSpacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListSpacesOutputResponse: Swift.Equatable {
    /// Information about the space.
    public var items: [CodeCatalystClientTypes.SpaceSummary]?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?

    public init (
        items: [CodeCatalystClientTypes.SpaceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListSpacesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let items: [CodeCatalystClientTypes.SpaceSummary]?
}

extension ListSpacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let itemsContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.SpaceSummary?].self, forKey: .items)
        var itemsDecoded0:[CodeCatalystClientTypes.SpaceSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CodeCatalystClientTypes.SpaceSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension CodeCatalystClientTypes {
    public enum OperationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mutation
        case readonly
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationType] {
            return [
                .mutation,
                .readonly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mutation: return "MUTATION"
            case .readonly: return "READONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationType(rawValue: rawValue) ?? OperationType.sdkUnknown(rawValue)
        }
    }
}

extension CodeCatalystClientTypes.PersistentStorage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sizeInGiB
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sizeInGiB = self.sizeInGiB {
            try encodeContainer.encode(sizeInGiB, forKey: .sizeInGiB)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeInGiBDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sizeInGiB)
        sizeInGiB = sizeInGiBDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about the persistent storage for a Dev Environment.
    public struct PersistentStorage: Swift.Equatable {
        /// The size of the persistent storage in gigabytes (specifically GiB). Valid values for storage are based on memory sizes in 16GB increments. Valid values are 16, 32, and 64.
        /// This member is required.
        public var sizeInGiB: Swift.Int?

        public init (
            sizeInGiB: Swift.Int? = nil
        )
        {
            self.sizeInGiB = sizeInGiB
        }
    }

}

extension CodeCatalystClientTypes.PersistentStorageConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sizeInGiB
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sizeInGiB = self.sizeInGiB {
            try encodeContainer.encode(sizeInGiB, forKey: .sizeInGiB)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeInGiBDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sizeInGiB)
        sizeInGiB = sizeInGiBDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about the configuration of persistent storage for a Dev Environment.
    public struct PersistentStorageConfiguration: Swift.Equatable {
        /// The size of the persistent storage in gigabytes (specifically GiB). Valid values for storage are based on memory sizes in 16GB increments. Valid values are 16, 32, and 64.
        /// This member is required.
        public var sizeInGiB: Swift.Int?

        public init (
            sizeInGiB: Swift.Int? = nil
        )
        {
            self.sizeInGiB = sizeInGiB
        }
    }

}

extension CodeCatalystClientTypes.ProjectInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case projectId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectId = self.projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about a project in a space.
    public struct ProjectInformation: Swift.Equatable {
        /// The name of the project in the space.
        public var name: Swift.String?
        /// The system-generated unique ID of the project.
        public var projectId: Swift.String?

        public init (
            name: Swift.String? = nil,
            projectId: Swift.String? = nil
        )
        {
            self.name = name
            self.projectId = projectId
        }
    }

}

extension CodeCatalystClientTypes.ProjectListFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparisonOperator
        case key
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = self.comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let key = self.key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string0 in values {
                try valuesContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.FilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
    }
}

extension CodeCatalystClientTypes {
    /// nformation about the filter used to narrow the results returned in a list of projects.
    public struct ProjectListFilter: Swift.Equatable {
        /// The operator used to compare the fields.
        public var comparisonOperator: CodeCatalystClientTypes.ComparisonOperator?
        /// A key that can be used to sort results.
        /// This member is required.
        public var key: CodeCatalystClientTypes.FilterKey?
        /// The value of the key.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            comparisonOperator: CodeCatalystClientTypes.ComparisonOperator? = nil,
            key: CodeCatalystClientTypes.FilterKey? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.key = key
            self.values = values
        }
    }

}

extension CodeCatalystClientTypes.ProjectSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about a project.
    public struct ProjectSummary: Swift.Equatable {
        /// The description of the project.
        public var description: Swift.String?
        /// The friendly name displayed to users of the project in Amazon CodeCatalyst.
        public var displayName: Swift.String?
        /// The name of the project in the space.
        /// This member is required.
        public var name: Swift.String?

        public init (
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.description = description
            self.displayName = displayName
            self.name = name
        }
    }

}

extension CodeCatalystClientTypes.RepositoryInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about a repository that will be cloned to a Dev Environment.
    public struct RepositoryInput: Swift.Equatable {
        /// The name of the branch in a source repository.
        public var branchName: Swift.String?
        /// The name of the source repository.
        /// This member is required.
        public var repositoryName: Swift.String?

        public init (
            branchName: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.branchName = branchName
            self.repositoryName = repositoryName
        }
    }

}

/// The request was denied because the specified resource was not found. Verify that the spelling is correct and that you have access to the resource.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

/// The request was denied because one or more resources has reached its limits for the tier the space belongs to. Either reduce the number of resources, or change the tier if applicable.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

extension CodeCatalystClientTypes.SpaceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case name
        case regionName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let regionName = self.regionName {
            try encodeContainer.encode(regionName, forKey: .regionName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let regionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionName)
        regionName = regionNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about an space.
    public struct SpaceSummary: Swift.Equatable {
        /// The description of the space.
        public var description: Swift.String?
        /// The friendly name of the space displayed to users.
        public var displayName: Swift.String?
        /// We need to know what this is and the basic usage information so that third-party developers know how to use this data type.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Web Services Region where the space exists.
        /// This member is required.
        public var regionName: Swift.String?

        public init (
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            name: Swift.String? = nil,
            regionName: Swift.String? = nil
        )
        {
            self.description = description
            self.displayName = displayName
            self.name = name
            self.regionName = regionName
        }
    }

}

extension StartDevEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ides
        case inactivityTimeoutMinutes
        case instanceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ides = ides {
            var idesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ides)
            for ideconfiguration0 in ides {
                try idesContainer.encode(ideconfiguration0)
            }
        }
        if inactivityTimeoutMinutes != 0 {
            try encodeContainer.encode(inactivityTimeoutMinutes, forKey: .inactivityTimeoutMinutes)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType.rawValue, forKey: .instanceType)
        }
    }
}

extension StartDevEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/devEnvironments/\(id.urlPercentEncoding())/start"
    }
}

public struct StartDevEnvironmentInput: Swift.Equatable {
    /// The system-generated unique ID of the Dev Environment.
    /// This member is required.
    public var id: Swift.String?
    /// Information about the integrated development environment (IDE) configured for a Dev Environment.
    public var ides: [CodeCatalystClientTypes.IdeConfiguration]?
    /// The amount of time the Dev Environment will run without any activity detected before stopping, in minutes. Only whole integers are allowed. Dev Environments consume compute minutes when running.
    public var inactivityTimeoutMinutes: Swift.Int
    /// The Amazon EC2 instace type to use for the Dev Environment.
    public var instanceType: CodeCatalystClientTypes.InstanceType?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init (
        id: Swift.String? = nil,
        ides: [CodeCatalystClientTypes.IdeConfiguration]? = nil,
        inactivityTimeoutMinutes: Swift.Int = 0,
        instanceType: CodeCatalystClientTypes.InstanceType? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.id = id
        self.ides = ides
        self.inactivityTimeoutMinutes = inactivityTimeoutMinutes
        self.instanceType = instanceType
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct StartDevEnvironmentInputBody: Swift.Equatable {
    let ides: [CodeCatalystClientTypes.IdeConfiguration]?
    let instanceType: CodeCatalystClientTypes.InstanceType?
    let inactivityTimeoutMinutes: Swift.Int
}

extension StartDevEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ides
        case inactivityTimeoutMinutes
        case instanceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idesContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.IdeConfiguration?].self, forKey: .ides)
        var idesDecoded0:[CodeCatalystClientTypes.IdeConfiguration]? = nil
        if let idesContainer = idesContainer {
            idesDecoded0 = [CodeCatalystClientTypes.IdeConfiguration]()
            for structure0 in idesContainer {
                if let structure0 = structure0 {
                    idesDecoded0?.append(structure0)
                }
            }
        }
        ides = idesDecoded0
        let instanceTypeDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.InstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let inactivityTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inactivityTimeoutMinutes) ?? 0
        inactivityTimeoutMinutes = inactivityTimeoutMinutesDecoded
    }
}

extension StartDevEnvironmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDevEnvironmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartDevEnvironmentOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDevEnvironmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartDevEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.projectName = output.projectName
            self.spaceName = output.spaceName
            self.status = output.status
        } else {
            self.id = nil
            self.projectName = nil
            self.spaceName = nil
            self.status = nil
        }
    }
}

public struct StartDevEnvironmentOutputResponse: Swift.Equatable {
    /// The system-generated unique ID of the Dev Environment.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?
    /// The status of the Dev Environment.
    /// This member is required.
    public var status: CodeCatalystClientTypes.DevEnvironmentStatus?

    public init (
        id: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil,
        status: CodeCatalystClientTypes.DevEnvironmentStatus? = nil
    )
    {
        self.id = id
        self.projectName = projectName
        self.spaceName = spaceName
        self.status = status
    }
}

struct StartDevEnvironmentOutputResponseBody: Swift.Equatable {
    let spaceName: Swift.String?
    let projectName: Swift.String?
    let id: Swift.String?
    let status: CodeCatalystClientTypes.DevEnvironmentStatus?
}

extension StartDevEnvironmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case projectName
        case spaceName
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.DevEnvironmentStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension StartDevEnvironmentSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionConfiguration = self.sessionConfiguration {
            try encodeContainer.encode(sessionConfiguration, forKey: .sessionConfiguration)
        }
    }
}

extension StartDevEnvironmentSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/devEnvironments/\(id.urlPercentEncoding())/session"
    }
}

public struct StartDevEnvironmentSessionInput: Swift.Equatable {
    /// The system-generated unique ID of the Dev Environment.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// Information about the configuration of a Dev Environment session.
    /// This member is required.
    public var sessionConfiguration: CodeCatalystClientTypes.DevEnvironmentSessionConfiguration?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init (
        id: Swift.String? = nil,
        projectName: Swift.String? = nil,
        sessionConfiguration: CodeCatalystClientTypes.DevEnvironmentSessionConfiguration? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.id = id
        self.projectName = projectName
        self.sessionConfiguration = sessionConfiguration
        self.spaceName = spaceName
    }
}

struct StartDevEnvironmentSessionInputBody: Swift.Equatable {
    let sessionConfiguration: CodeCatalystClientTypes.DevEnvironmentSessionConfiguration?
}

extension StartDevEnvironmentSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionConfigurationDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.DevEnvironmentSessionConfiguration.self, forKey: .sessionConfiguration)
        sessionConfiguration = sessionConfigurationDecoded
    }
}

extension StartDevEnvironmentSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDevEnvironmentSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartDevEnvironmentSessionOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDevEnvironmentSessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDevEnvironmentSessionOutputResponse(id: \(Swift.String(describing: id)), projectName: \(Swift.String(describing: projectName)), sessionId: \(Swift.String(describing: sessionId)), spaceName: \(Swift.String(describing: spaceName)), accessDetails: \"CONTENT_REDACTED\")"}
}

extension StartDevEnvironmentSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartDevEnvironmentSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessDetails = output.accessDetails
            self.id = output.id
            self.projectName = output.projectName
            self.sessionId = output.sessionId
            self.spaceName = output.spaceName
        } else {
            self.accessDetails = nil
            self.id = nil
            self.projectName = nil
            self.sessionId = nil
            self.spaceName = nil
        }
    }
}

public struct StartDevEnvironmentSessionOutputResponse: Swift.Equatable {
    /// Information about connection details for a Dev Environment.
    /// This member is required.
    public var accessDetails: CodeCatalystClientTypes.DevEnvironmentAccessDetails?
    /// The system-generated unique ID of the Dev Environment.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The system-generated unique ID of the Dev Environment session.
    public var sessionId: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init (
        accessDetails: CodeCatalystClientTypes.DevEnvironmentAccessDetails? = nil,
        id: Swift.String? = nil,
        projectName: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.accessDetails = accessDetails
        self.id = id
        self.projectName = projectName
        self.sessionId = sessionId
        self.spaceName = spaceName
    }
}

struct StartDevEnvironmentSessionOutputResponseBody: Swift.Equatable {
    let accessDetails: CodeCatalystClientTypes.DevEnvironmentAccessDetails?
    let sessionId: Swift.String?
    let spaceName: Swift.String?
    let projectName: Swift.String?
    let id: Swift.String?
}

extension StartDevEnvironmentSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessDetails
        case id
        case projectName
        case sessionId
        case spaceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessDetailsDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.DevEnvironmentAccessDetails.self, forKey: .accessDetails)
        accessDetails = accessDetailsDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension StopDevEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/devEnvironments/\(id.urlPercentEncoding())/stop"
    }
}

public struct StopDevEnvironmentInput: Swift.Equatable {
    /// The system-generated unique ID of the Dev Environment.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init (
        id: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.id = id
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct StopDevEnvironmentInputBody: Swift.Equatable {
}

extension StopDevEnvironmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StopDevEnvironmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopDevEnvironmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopDevEnvironmentOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension StopDevEnvironmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StopDevEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.projectName = output.projectName
            self.spaceName = output.spaceName
            self.status = output.status
        } else {
            self.id = nil
            self.projectName = nil
            self.spaceName = nil
            self.status = nil
        }
    }
}

public struct StopDevEnvironmentOutputResponse: Swift.Equatable {
    /// The system-generated unique ID of the Dev Environment.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?
    /// The status of the Dev Environment.
    /// This member is required.
    public var status: CodeCatalystClientTypes.DevEnvironmentStatus?

    public init (
        id: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil,
        status: CodeCatalystClientTypes.DevEnvironmentStatus? = nil
    )
    {
        self.id = id
        self.projectName = projectName
        self.spaceName = spaceName
        self.status = status
    }
}

struct StopDevEnvironmentOutputResponseBody: Swift.Equatable {
    let spaceName: Swift.String?
    let projectName: Swift.String?
    let id: Swift.String?
    let status: CodeCatalystClientTypes.DevEnvironmentStatus?
}

extension StopDevEnvironmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case projectName
        case spaceName
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.DevEnvironmentStatus.self, forKey: .status)
        status = statusDecoded
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

extension UpdateDevEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case ides
        case inactivityTimeoutMinutes
        case instanceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let ides = ides {
            var idesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ides)
            for ideconfiguration0 in ides {
                try idesContainer.encode(ideconfiguration0)
            }
        }
        if inactivityTimeoutMinutes != 0 {
            try encodeContainer.encode(inactivityTimeoutMinutes, forKey: .inactivityTimeoutMinutes)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType.rawValue, forKey: .instanceType)
        }
    }
}

extension UpdateDevEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/devEnvironments/\(id.urlPercentEncoding())"
    }
}

public struct UpdateDevEnvironmentInput: Swift.Equatable {
    /// The user-specified alias for the Dev Environment. Changing this value will not cause a restart.
    public var alias: Swift.String?
    /// A user-specified idempotency token. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries return the result from the original successful request and have no additional effect.
    public var clientToken: Swift.String?
    /// The system-generated unique ID of the Dev Environment.
    /// This member is required.
    public var id: Swift.String?
    /// Information about the integrated development environment (IDE) configured for a Dev Environment.
    public var ides: [CodeCatalystClientTypes.IdeConfiguration]?
    /// The amount of time the Dev Environment will run without any activity detected before stopping, in minutes. Only whole integers are allowed. Dev Environments consume compute minutes when running. Changing this value will cause a restart of the Dev Environment if it is running.
    public var inactivityTimeoutMinutes: Swift.Int
    /// The Amazon EC2 instace type to use for the Dev Environment. Changing this value will cause a restart of the Dev Environment if it is running.
    public var instanceType: CodeCatalystClientTypes.InstanceType?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init (
        alias: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        id: Swift.String? = nil,
        ides: [CodeCatalystClientTypes.IdeConfiguration]? = nil,
        inactivityTimeoutMinutes: Swift.Int = 0,
        instanceType: CodeCatalystClientTypes.InstanceType? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.id = id
        self.ides = ides
        self.inactivityTimeoutMinutes = inactivityTimeoutMinutes
        self.instanceType = instanceType
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct UpdateDevEnvironmentInputBody: Swift.Equatable {
    let alias: Swift.String?
    let ides: [CodeCatalystClientTypes.IdeConfiguration]?
    let instanceType: CodeCatalystClientTypes.InstanceType?
    let inactivityTimeoutMinutes: Swift.Int
    let clientToken: Swift.String?
}

extension UpdateDevEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case ides
        case inactivityTimeoutMinutes
        case instanceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let idesContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.IdeConfiguration?].self, forKey: .ides)
        var idesDecoded0:[CodeCatalystClientTypes.IdeConfiguration]? = nil
        if let idesContainer = idesContainer {
            idesDecoded0 = [CodeCatalystClientTypes.IdeConfiguration]()
            for structure0 in idesContainer {
                if let structure0 = structure0 {
                    idesDecoded0?.append(structure0)
                }
            }
        }
        ides = idesDecoded0
        let instanceTypeDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.InstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let inactivityTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inactivityTimeoutMinutes) ?? 0
        inactivityTimeoutMinutes = inactivityTimeoutMinutesDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateDevEnvironmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDevEnvironmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDevEnvironmentOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDevEnvironmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDevEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alias = output.alias
            self.clientToken = output.clientToken
            self.id = output.id
            self.ides = output.ides
            self.inactivityTimeoutMinutes = output.inactivityTimeoutMinutes
            self.instanceType = output.instanceType
            self.projectName = output.projectName
            self.spaceName = output.spaceName
        } else {
            self.alias = nil
            self.clientToken = nil
            self.id = nil
            self.ides = nil
            self.inactivityTimeoutMinutes = 0
            self.instanceType = nil
            self.projectName = nil
            self.spaceName = nil
        }
    }
}

public struct UpdateDevEnvironmentOutputResponse: Swift.Equatable {
    /// The user-specified alias for the Dev Environment.
    public var alias: Swift.String?
    /// A user-specified idempotency token. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries return the result from the original successful request and have no additional effect.
    public var clientToken: Swift.String?
    /// The system-generated unique ID of the Dev Environment.
    /// This member is required.
    public var id: Swift.String?
    /// Information about the integrated development environment (IDE) configured for the Dev Environment.
    public var ides: [CodeCatalystClientTypes.IdeConfiguration]?
    /// The amount of time the Dev Environment will run without any activity detected before stopping, in minutes.
    public var inactivityTimeoutMinutes: Swift.Int
    /// The Amazon EC2 instace type to use for the Dev Environment.
    public var instanceType: CodeCatalystClientTypes.InstanceType?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init (
        alias: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        id: Swift.String? = nil,
        ides: [CodeCatalystClientTypes.IdeConfiguration]? = nil,
        inactivityTimeoutMinutes: Swift.Int = 0,
        instanceType: CodeCatalystClientTypes.InstanceType? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.id = id
        self.ides = ides
        self.inactivityTimeoutMinutes = inactivityTimeoutMinutes
        self.instanceType = instanceType
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct UpdateDevEnvironmentOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let spaceName: Swift.String?
    let projectName: Swift.String?
    let alias: Swift.String?
    let ides: [CodeCatalystClientTypes.IdeConfiguration]?
    let instanceType: CodeCatalystClientTypes.InstanceType?
    let inactivityTimeoutMinutes: Swift.Int
    let clientToken: Swift.String?
}

extension UpdateDevEnvironmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case id
        case ides
        case inactivityTimeoutMinutes
        case instanceType
        case projectName
        case spaceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let idesContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.IdeConfiguration?].self, forKey: .ides)
        var idesDecoded0:[CodeCatalystClientTypes.IdeConfiguration]? = nil
        if let idesContainer = idesContainer {
            idesDecoded0 = [CodeCatalystClientTypes.IdeConfiguration]()
            for structure0 in idesContainer {
                if let structure0 = structure0 {
                    idesDecoded0?.append(structure0)
                }
            }
        }
        ides = idesDecoded0
        let instanceTypeDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.InstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let inactivityTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inactivityTimeoutMinutes) ?? 0
        inactivityTimeoutMinutes = inactivityTimeoutMinutesDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CodeCatalystClientTypes.UserIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case principalId
        case userName
        case userType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userType = self.userType {
            try encodeContainer.encode(userType.rawValue, forKey: .userType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userTypeDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.UserType.self, forKey: .userType)
        userType = userTypeDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about a user whose activity is recorded in an event for a space.
    public struct UserIdentity: Swift.Equatable {
        /// The Amazon Web Services account number of the user in Amazon Web Services, if any.
        public var awsAccountId: Swift.String?
        ///
        /// This member is required.
        public var principalId: Swift.String?
        /// The display name of the user in Amazon CodeCatalyst.
        public var userName: Swift.String?
        /// The role assigned to the user in a Amazon CodeCatalyst space or project when the event occurred.
        /// This member is required.
        public var userType: CodeCatalystClientTypes.UserType?

        public init (
            awsAccountId: Swift.String? = nil,
            principalId: Swift.String? = nil,
            userName: Swift.String? = nil,
            userType: CodeCatalystClientTypes.UserType? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.principalId = principalId
            self.userName = userName
            self.userType = userType
        }
    }

}

extension CodeCatalystClientTypes {
    public enum UserType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsAccount
        case unknown
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [UserType] {
            return [
                .awsAccount,
                .unknown,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsAccount: return "AWS_ACCOUNT"
            case .unknown: return "UNKNOWN"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserType(rawValue: rawValue) ?? UserType.sdkUnknown(rawValue)
        }
    }
}

/// The request was denied because an input failed to satisfy the constraints specified by the service. Check the spelling and input requirements, and then try again.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

extension VerifySessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/session"
    }
}

public struct VerifySessionInput: Swift.Equatable {

    public init () { }
}

struct VerifySessionInputBody: Swift.Equatable {
}

extension VerifySessionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension VerifySessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension VerifySessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum VerifySessionOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension VerifySessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: VerifySessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identity = output.identity
        } else {
            self.identity = nil
        }
    }
}

public struct VerifySessionOutputResponse: Swift.Equatable {
    /// The system-generated unique ID of the user in Amazon CodeCatalyst.
    public var identity: Swift.String?

    public init (
        identity: Swift.String? = nil
    )
    {
        self.identity = identity
    }
}

struct VerifySessionOutputResponseBody: Swift.Equatable {
    let identity: Swift.String?
}

extension VerifySessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identity
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identity)
        identity = identityDecoded
    }
}
