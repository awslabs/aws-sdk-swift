// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccountSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsAccountNumber
        case defaultJobTimeoutMinutes
        case maxJobTimeoutMinutes
        case maxSlots
        case skipAppResign
        case trialMinutes
        case unmeteredDevices
        case unmeteredRemoteAccessDevices
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountNumber = awsAccountNumber {
            try encodeContainer.encode(awsAccountNumber, forKey: .awsAccountNumber)
        }
        if let defaultJobTimeoutMinutes = defaultJobTimeoutMinutes {
            try encodeContainer.encode(defaultJobTimeoutMinutes, forKey: .defaultJobTimeoutMinutes)
        }
        if let maxJobTimeoutMinutes = maxJobTimeoutMinutes {
            try encodeContainer.encode(maxJobTimeoutMinutes, forKey: .maxJobTimeoutMinutes)
        }
        if let maxSlots = maxSlots {
            var maxSlotsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .maxSlots)
            for (dictKey0, maxslotmap0) in maxSlots {
                try maxSlotsContainer.encode(maxslotmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let skipAppResign = skipAppResign {
            try encodeContainer.encode(skipAppResign, forKey: .skipAppResign)
        }
        if let trialMinutes = trialMinutes {
            try encodeContainer.encode(trialMinutes, forKey: .trialMinutes)
        }
        if let unmeteredDevices = unmeteredDevices {
            var unmeteredDevicesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .unmeteredDevices)
            for (dictKey0, purchaseddevicesmap0) in unmeteredDevices {
                try unmeteredDevicesContainer.encode(purchaseddevicesmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let unmeteredRemoteAccessDevices = unmeteredRemoteAccessDevices {
            var unmeteredRemoteAccessDevicesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .unmeteredRemoteAccessDevices)
            for (dictKey0, purchaseddevicesmap0) in unmeteredRemoteAccessDevices {
                try unmeteredRemoteAccessDevicesContainer.encode(purchaseddevicesmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsAccountNumber)
        awsAccountNumber = awsAccountNumberDecoded
        let unmeteredDevicesContainer = try containerValues.decodeIfPresent([String: Int?].self, forKey: .unmeteredDevices)
        var unmeteredDevicesDecoded0: [String:Int]? = nil
        if let unmeteredDevicesContainer = unmeteredDevicesContainer {
            unmeteredDevicesDecoded0 = [String:Int]()
            for (key0, integer0) in unmeteredDevicesContainer {
                if let integer0 = integer0 {
                    unmeteredDevicesDecoded0?[key0] = integer0
                }
            }
        }
        unmeteredDevices = unmeteredDevicesDecoded0
        let unmeteredRemoteAccessDevicesContainer = try containerValues.decodeIfPresent([String: Int?].self, forKey: .unmeteredRemoteAccessDevices)
        var unmeteredRemoteAccessDevicesDecoded0: [String:Int]? = nil
        if let unmeteredRemoteAccessDevicesContainer = unmeteredRemoteAccessDevicesContainer {
            unmeteredRemoteAccessDevicesDecoded0 = [String:Int]()
            for (key0, integer0) in unmeteredRemoteAccessDevicesContainer {
                if let integer0 = integer0 {
                    unmeteredRemoteAccessDevicesDecoded0?[key0] = integer0
                }
            }
        }
        unmeteredRemoteAccessDevices = unmeteredRemoteAccessDevicesDecoded0
        let maxJobTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxJobTimeoutMinutes)
        maxJobTimeoutMinutes = maxJobTimeoutMinutesDecoded
        let trialMinutesDecoded = try containerValues.decodeIfPresent(TrialMinutes.self, forKey: .trialMinutes)
        trialMinutes = trialMinutesDecoded
        let maxSlotsContainer = try containerValues.decodeIfPresent([String: Int?].self, forKey: .maxSlots)
        var maxSlotsDecoded0: [String:Int]? = nil
        if let maxSlotsContainer = maxSlotsContainer {
            maxSlotsDecoded0 = [String:Int]()
            for (key0, integer0) in maxSlotsContainer {
                if let integer0 = integer0 {
                    maxSlotsDecoded0?[key0] = integer0
                }
            }
        }
        maxSlots = maxSlotsDecoded0
        let defaultJobTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .defaultJobTimeoutMinutes)
        defaultJobTimeoutMinutes = defaultJobTimeoutMinutesDecoded
        let skipAppResignDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .skipAppResign)
        skipAppResign = skipAppResignDecoded
    }
}

extension AccountSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountSettings(awsAccountNumber: \(String(describing: awsAccountNumber)), defaultJobTimeoutMinutes: \(String(describing: defaultJobTimeoutMinutes)), maxJobTimeoutMinutes: \(String(describing: maxJobTimeoutMinutes)), maxSlots: \(String(describing: maxSlots)), skipAppResign: \(String(describing: skipAppResign)), trialMinutes: \(String(describing: trialMinutes)), unmeteredDevices: \(String(describing: unmeteredDevices)), unmeteredRemoteAccessDevices: \(String(describing: unmeteredRemoteAccessDevices)))"}
}

/// <p>A container for account-level settings in AWS Device Farm.</p>
public struct AccountSettings: Equatable {
    /// <p>The AWS account number specified in the <code>AccountSettings</code>
    ///             container.</p>
    public let awsAccountNumber: String?
    /// <p>The default number of minutes (at the account level) a test run executes before it times out. The
    ///             default value is 150 minutes.</p>
    public let defaultJobTimeoutMinutes: Int?
    /// <p>The maximum number of minutes a test run executes before it times out.</p>
    public let maxJobTimeoutMinutes: Int?
    /// <p>The maximum number of device slots that the AWS account can purchase. Each maximum
    ///             is expressed as an <code>offering-id:number</code> pair, where the
    ///                 <code>offering-id</code> represents one of the IDs returned by the
    ///                 <code>ListOfferings</code> command.</p>
    public let maxSlots: [String:Int]?
    /// <p>When set to <code>true</code>, for private devices, Device Farm does not sign your app again. For public
    ///             devices, Device Farm always signs your apps again.</p>
    ///         <p>For more information about how Device Farm re-signs your apps, see <a href="https://aws.amazon.com/device-farm/faq/">Do you modify my app?</a> in the <i>AWS Device
    ///                 Farm FAQs</i>.</p>
    public let skipAppResign: Bool?
    /// <p>Information about an AWS account's usage of free trial device minutes.</p>
    public let trialMinutes: TrialMinutes?
    /// <p>Returns the unmetered devices you have purchased or want to purchase.</p>
    public let unmeteredDevices: [String:Int]?
    /// <p>Returns the unmetered remote access devices you have purchased or want to
    ///             purchase.</p>
    public let unmeteredRemoteAccessDevices: [String:Int]?

    public init (
        awsAccountNumber: String? = nil,
        defaultJobTimeoutMinutes: Int? = nil,
        maxJobTimeoutMinutes: Int? = nil,
        maxSlots: [String:Int]? = nil,
        skipAppResign: Bool? = nil,
        trialMinutes: TrialMinutes? = nil,
        unmeteredDevices: [String:Int]? = nil,
        unmeteredRemoteAccessDevices: [String:Int]? = nil
    )
    {
        self.awsAccountNumber = awsAccountNumber
        self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
        self.maxJobTimeoutMinutes = maxJobTimeoutMinutes
        self.maxSlots = maxSlots
        self.skipAppResign = skipAppResign
        self.trialMinutes = trialMinutes
        self.unmeteredDevices = unmeteredDevices
        self.unmeteredRemoteAccessDevices = unmeteredRemoteAccessDevices
    }
}

extension ArgumentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ArgumentException(message: \(String(describing: message)))"}
}

extension ArgumentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ArgumentExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An invalid argument was specified.</p>
public struct ArgumentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any additional information about the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ArgumentExceptionBody: Equatable {
    public let message: String?
}

extension ArgumentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Artifact: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case `extension` = "extension"
        case name
        case type
        case url
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let `extension` = `extension` {
            try encodeContainer.encode(`extension`, forKey: .`extension`)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ArtifactType.self, forKey: .type)
        type = typeDecoded
        let extensionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .extension)
        `extension` = extensionDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension Artifact: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Artifact(arn: \(String(describing: arn)), extension: \(String(describing: `extension`)), name: \(String(describing: name)), type: \(String(describing: type)), url: \(String(describing: url)))"}
}

/// <p>Represents the output of a test. Examples of artifacts include logs and
///             screenshots.</p>
public struct Artifact: Equatable {
    /// <p>The artifact's file extension.</p>
    public let `extension`: String?
    /// <p>The artifact's ARN.</p>
    public let arn: String?
    /// <p>The artifact's name.</p>
    public let name: String?
    /// <p>The artifact's type.</p>
    ///         <p>Allowed values include the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>UNKNOWN</p>
    ///             </li>
    ///             <li>
    ///                 <p>SCREENSHOT</p>
    ///             </li>
    ///             <li>
    ///                 <p>DEVICE_LOG</p>
    ///             </li>
    ///             <li>
    ///                 <p>MESSAGE_LOG</p>
    ///             </li>
    ///             <li>
    ///                 <p>VIDEO_LOG</p>
    ///             </li>
    ///             <li>
    ///                 <p>RESULT_LOG</p>
    ///             </li>
    ///             <li>
    ///                 <p>SERVICE_LOG</p>
    ///             </li>
    ///             <li>
    ///                 <p>WEBKIT_LOG</p>
    ///             </li>
    ///             <li>
    ///                 <p>INSTRUMENTATION_OUTPUT</p>
    ///             </li>
    ///             <li>
    ///                 <p>EXERCISER_MONKEY_OUTPUT: the artifact (log) generated by an Android fuzz test.</p>
    ///             </li>
    ///             <li>
    ///                 <p>CALABASH_JSON_OUTPUT</p>
    ///             </li>
    ///             <li>
    ///                 <p>CALABASH_PRETTY_OUTPUT</p>
    ///             </li>
    ///             <li>
    ///                 <p>CALABASH_STANDARD_OUTPUT</p>
    ///             </li>
    ///             <li>
    ///                 <p>CALABASH_JAVA_XML_OUTPUT</p>
    ///             </li>
    ///             <li>
    ///                 <p>AUTOMATION_OUTPUT</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_SERVER_OUTPUT</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_OUTPUT</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_XML_OUTPUT</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_PYTHON_OUTPUT</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_PYTHON_XML_OUTPUT</p>
    ///             </li>
    ///             <li>
    ///                 <p>EXPLORER_EVENT_LOG</p>
    ///             </li>
    ///             <li>
    ///                 <p>EXPLORER_SUMMARY_LOG</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPLICATION_CRASH_REPORT</p>
    ///             </li>
    ///             <li>
    ///                 <p>XCTEST_LOG</p>
    ///             </li>
    ///             <li>
    ///                 <p>VIDEO</p>
    ///             </li>
    ///             <li>
    ///                 <p>CUSTOMER_ARTIFACT</p>
    ///             </li>
    ///             <li>
    ///                 <p>CUSTOMER_ARTIFACT_LOG</p>
    ///             </li>
    ///             <li>
    ///                 <p>TESTSPEC_OUTPUT</p>
    ///             </li>
    ///          </ul>
    public let type: ArtifactType?
    /// <p>The presigned Amazon S3 URL that can be used with a GET request to download the artifact's
    ///             file.</p>
    public let url: String?

    public init (
        `extension`: String? = nil,
        arn: String? = nil,
        name: String? = nil,
        type: ArtifactType? = nil,
        url: String? = nil
    )
    {
        self.`extension` = `extension`
        self.arn = arn
        self.name = name
        self.type = type
        self.url = url
    }
}

public enum ArtifactCategory {
    case file
    case log
    case screenshot
    case sdkUnknown(String)
}

extension ArtifactCategory : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ArtifactCategory] {
        return [
            .file,
            .log,
            .screenshot,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .file: return "FILE"
        case .log: return "LOG"
        case .screenshot: return "SCREENSHOT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ArtifactCategory(rawValue: rawValue) ?? ArtifactCategory.sdkUnknown(rawValue)
    }
}

public enum ArtifactType {
    case appiumJavaOutput
    case appiumJavaXmlOutput
    case appiumPythonOutput
    case appiumPythonXmlOutput
    case appiumServerOutput
    case applicationCrashReport
    case automationOutput
    case calabashJavaXmlOutput
    case calabashJsonOutput
    case calabashPrettyOutput
    case calabashStandardOutput
    case customerArtifact
    case customerArtifactLog
    case deviceLog
    case exerciserMonkeyOutput
    case explorerEventLog
    case explorerSummaryLog
    case instrumentationOutput
    case messageLog
    case resultLog
    case screenshot
    case serviceLog
    case testspecOutput
    case unknown
    case video
    case videoLog
    case webkitLog
    case xctestLog
    case sdkUnknown(String)
}

extension ArtifactType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ArtifactType] {
        return [
            .appiumJavaOutput,
            .appiumJavaXmlOutput,
            .appiumPythonOutput,
            .appiumPythonXmlOutput,
            .appiumServerOutput,
            .applicationCrashReport,
            .automationOutput,
            .calabashJavaXmlOutput,
            .calabashJsonOutput,
            .calabashPrettyOutput,
            .calabashStandardOutput,
            .customerArtifact,
            .customerArtifactLog,
            .deviceLog,
            .exerciserMonkeyOutput,
            .explorerEventLog,
            .explorerSummaryLog,
            .instrumentationOutput,
            .messageLog,
            .resultLog,
            .screenshot,
            .serviceLog,
            .testspecOutput,
            .unknown,
            .video,
            .videoLog,
            .webkitLog,
            .xctestLog,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .appiumJavaOutput: return "APPIUM_JAVA_OUTPUT"
        case .appiumJavaXmlOutput: return "APPIUM_JAVA_XML_OUTPUT"
        case .appiumPythonOutput: return "APPIUM_PYTHON_OUTPUT"
        case .appiumPythonXmlOutput: return "APPIUM_PYTHON_XML_OUTPUT"
        case .appiumServerOutput: return "APPIUM_SERVER_OUTPUT"
        case .applicationCrashReport: return "APPLICATION_CRASH_REPORT"
        case .automationOutput: return "AUTOMATION_OUTPUT"
        case .calabashJavaXmlOutput: return "CALABASH_JAVA_XML_OUTPUT"
        case .calabashJsonOutput: return "CALABASH_JSON_OUTPUT"
        case .calabashPrettyOutput: return "CALABASH_PRETTY_OUTPUT"
        case .calabashStandardOutput: return "CALABASH_STANDARD_OUTPUT"
        case .customerArtifact: return "CUSTOMER_ARTIFACT"
        case .customerArtifactLog: return "CUSTOMER_ARTIFACT_LOG"
        case .deviceLog: return "DEVICE_LOG"
        case .exerciserMonkeyOutput: return "EXERCISER_MONKEY_OUTPUT"
        case .explorerEventLog: return "EXPLORER_EVENT_LOG"
        case .explorerSummaryLog: return "EXPLORER_SUMMARY_LOG"
        case .instrumentationOutput: return "INSTRUMENTATION_OUTPUT"
        case .messageLog: return "MESSAGE_LOG"
        case .resultLog: return "RESULT_LOG"
        case .screenshot: return "SCREENSHOT"
        case .serviceLog: return "SERVICE_LOG"
        case .testspecOutput: return "TESTSPEC_OUTPUT"
        case .unknown: return "UNKNOWN"
        case .video: return "VIDEO"
        case .videoLog: return "VIDEO_LOG"
        case .webkitLog: return "WEBKIT_LOG"
        case .xctestLog: return "XCTEST_LOG"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ArtifactType(rawValue: rawValue) ?? ArtifactType.sdkUnknown(rawValue)
    }
}

public enum BillingMethod {
    case metered
    case unmetered
    case sdkUnknown(String)
}

extension BillingMethod : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BillingMethod] {
        return [
            .metered,
            .unmetered,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .metered: return "METERED"
        case .unmetered: return "UNMETERED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BillingMethod(rawValue: rawValue) ?? BillingMethod.sdkUnknown(rawValue)
    }
}

extension CPU: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case architecture
        case clock
        case frequency
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = architecture {
            try encodeContainer.encode(architecture, forKey: .architecture)
        }
        if let clock = clock {
            try encodeContainer.encode(clock, forKey: .clock)
        }
        if let frequency = frequency {
            try encodeContainer.encode(frequency, forKey: .frequency)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frequencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .frequency)
        frequency = frequencyDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .architecture)
        architecture = architectureDecoded
        let clockDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .clock)
        clock = clockDecoded
    }
}

extension CPU: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CPU(architecture: \(String(describing: architecture)), clock: \(String(describing: clock)), frequency: \(String(describing: frequency)))"}
}

/// <p>Represents the amount of CPU that an app is using on a physical device. Does not represent system-wide
///             CPU usage.</p>
public struct CPU: Equatable {
    /// <p>The CPU's architecture (for example, x86 or ARM).</p>
    public let architecture: String?
    /// <p>The clock speed of the device's CPU, expressed in hertz (Hz). For example, a 1.2
    ///             GHz CPU is expressed as 1200000000.</p>
    public let clock: Double?
    /// <p>The CPU's frequency.</p>
    public let frequency: String?

    public init (
        architecture: String? = nil,
        clock: Double? = nil,
        frequency: String? = nil
    )
    {
        self.architecture = architecture
        self.clock = clock
        self.frequency = frequency
    }
}

extension CannotDeleteException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CannotDeleteException(message: \(String(describing: message)))"}
}

extension CannotDeleteException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CannotDeleteExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested object could not be deleted.</p>
public struct CannotDeleteException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CannotDeleteExceptionBody: Equatable {
    public let message: String?
}

extension CannotDeleteExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Counters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errored
        case failed
        case passed
        case skipped
        case stopped
        case total
        case warned
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errored = errored {
            try encodeContainer.encode(errored, forKey: .errored)
        }
        if let failed = failed {
            try encodeContainer.encode(failed, forKey: .failed)
        }
        if let passed = passed {
            try encodeContainer.encode(passed, forKey: .passed)
        }
        if let skipped = skipped {
            try encodeContainer.encode(skipped, forKey: .skipped)
        }
        if let stopped = stopped {
            try encodeContainer.encode(stopped, forKey: .stopped)
        }
        if let total = total {
            try encodeContainer.encode(total, forKey: .total)
        }
        if let warned = warned {
            try encodeContainer.encode(warned, forKey: .warned)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .total)
        total = totalDecoded
        let passedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .passed)
        passed = passedDecoded
        let failedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .failed)
        failed = failedDecoded
        let warnedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .warned)
        warned = warnedDecoded
        let erroredDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .errored)
        errored = erroredDecoded
        let stoppedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .stopped)
        stopped = stoppedDecoded
        let skippedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .skipped)
        skipped = skippedDecoded
    }
}

extension Counters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Counters(errored: \(String(describing: errored)), failed: \(String(describing: failed)), passed: \(String(describing: passed)), skipped: \(String(describing: skipped)), stopped: \(String(describing: stopped)), total: \(String(describing: total)), warned: \(String(describing: warned)))"}
}

/// <p>Represents entity counters.</p>
public struct Counters: Equatable {
    /// <p>The number of errored entities.</p>
    public let errored: Int?
    /// <p>The number of failed entities.</p>
    public let failed: Int?
    /// <p>The number of passed entities.</p>
    public let passed: Int?
    /// <p>The number of skipped entities.</p>
    public let skipped: Int?
    /// <p>The number of stopped entities.</p>
    public let stopped: Int?
    /// <p>The total number of entities.</p>
    public let total: Int?
    /// <p>The number of warned entities.</p>
    public let warned: Int?

    public init (
        errored: Int? = nil,
        failed: Int? = nil,
        passed: Int? = nil,
        skipped: Int? = nil,
        stopped: Int? = nil,
        total: Int? = nil,
        warned: Int? = nil
    )
    {
        self.errored = errored
        self.failed = failed
        self.passed = passed
        self.skipped = skipped
        self.stopped = stopped
        self.total = total
        self.warned = warned
    }
}

public struct CreateDevicePoolInputBodyMiddleware: Middleware {
    public let id: String = "CreateDevicePoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDevicePoolInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDevicePoolInput>
    public typealias MOutput = OperationOutput<CreateDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDevicePoolOutputError>
}

extension CreateDevicePoolInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDevicePoolInput(description: \(String(describing: description)), maxDevices: \(String(describing: maxDevices)), name: \(String(describing: name)), projectArn: \(String(describing: projectArn)), rules: \(String(describing: rules)))"}
}

extension CreateDevicePoolInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case maxDevices
        case name
        case projectArn
        case rules
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let maxDevices = maxDevices {
            try encodeContainer.encode(maxDevices, forKey: .maxDevices)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rules0 in rules {
                try rulesContainer.encode(rules0)
            }
        }
    }
}

public struct CreateDevicePoolInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDevicePoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDevicePoolInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDevicePoolInput>
    public typealias MOutput = OperationOutput<CreateDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDevicePoolOutputError>
}

public struct CreateDevicePoolInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDevicePoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDevicePoolInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDevicePoolInput>
    public typealias MOutput = OperationOutput<CreateDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDevicePoolOutputError>
}

/// <p>Represents a request to the create device pool operation.</p>
public struct CreateDevicePoolInput: Equatable {
    /// <p>The device pool's description.</p>
    public let description: String?
    /// <p>The number of devices that Device Farm can add to your device pool. Device Farm adds devices that are
    ///             available and meet the criteria that you assign for the <code>rules</code> parameter. Depending on how many
    ///             devices meet these constraints, your device pool might contain fewer devices than the value for this
    ///             parameter.</p>
    ///         <p>By specifying the maximum number of devices, you can control the costs that you incur
    ///             by running tests.</p>
    public let maxDevices: Int?
    /// <p>The device pool's name.</p>
    public let name: String?
    /// <p>The ARN of the project for the device pool.</p>
    public let projectArn: String?
    /// <p>The device pool's rules.</p>
    public let rules: [Rule]?

    public init (
        description: String? = nil,
        maxDevices: Int? = nil,
        name: String? = nil,
        projectArn: String? = nil,
        rules: [Rule]? = nil
    )
    {
        self.description = description
        self.maxDevices = maxDevices
        self.name = name
        self.projectArn = projectArn
        self.rules = rules
    }
}

struct CreateDevicePoolInputBody: Equatable {
    public let projectArn: String?
    public let name: String?
    public let description: String?
    public let rules: [Rule]?
    public let maxDevices: Int?
}

extension CreateDevicePoolInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case maxDevices
        case name
        case projectArn
        case rules
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([Rule?].self, forKey: .rules)
        var rulesDecoded0:[Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let maxDevicesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxDevices)
        maxDevices = maxDevicesDecoded
    }
}

extension CreateDevicePoolOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDevicePoolOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDevicePoolOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDevicePoolOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDevicePoolOutputResponse(devicePool: \(String(describing: devicePool)))"}
}

extension CreateDevicePoolOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDevicePoolOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.devicePool = output.devicePool
        } else {
            self.devicePool = nil
        }
    }
}

/// <p>Represents the result of a create device pool request.</p>
public struct CreateDevicePoolOutputResponse: Equatable {
    /// <p>The newly created device pool.</p>
    public let devicePool: DevicePool?

    public init (
        devicePool: DevicePool? = nil
    )
    {
        self.devicePool = devicePool
    }
}

struct CreateDevicePoolOutputResponseBody: Equatable {
    public let devicePool: DevicePool?
}

extension CreateDevicePoolOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case devicePool
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicePoolDecoded = try containerValues.decodeIfPresent(DevicePool.self, forKey: .devicePool)
        devicePool = devicePoolDecoded
    }
}

public struct CreateInstanceProfileInputBodyMiddleware: Middleware {
    public let id: String = "CreateInstanceProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInstanceProfileInput>
    public typealias MOutput = OperationOutput<CreateInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInstanceProfileOutputError>
}

extension CreateInstanceProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateInstanceProfileInput(description: \(String(describing: description)), excludeAppPackagesFromCleanup: \(String(describing: excludeAppPackagesFromCleanup)), name: \(String(describing: name)), packageCleanup: \(String(describing: packageCleanup)), rebootAfterUse: \(String(describing: rebootAfterUse)))"}
}

extension CreateInstanceProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case excludeAppPackagesFromCleanup
        case name
        case packageCleanup
        case rebootAfterUse
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup {
            var excludeAppPackagesFromCleanupContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeAppPackagesFromCleanup)
            for packageids0 in excludeAppPackagesFromCleanup {
                try excludeAppPackagesFromCleanupContainer.encode(packageids0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packageCleanup = packageCleanup {
            try encodeContainer.encode(packageCleanup, forKey: .packageCleanup)
        }
        if let rebootAfterUse = rebootAfterUse {
            try encodeContainer.encode(rebootAfterUse, forKey: .rebootAfterUse)
        }
    }
}

public struct CreateInstanceProfileInputHeadersMiddleware: Middleware {
    public let id: String = "CreateInstanceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInstanceProfileInput>
    public typealias MOutput = OperationOutput<CreateInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInstanceProfileOutputError>
}

public struct CreateInstanceProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateInstanceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInstanceProfileInput>
    public typealias MOutput = OperationOutput<CreateInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInstanceProfileOutputError>
}

public struct CreateInstanceProfileInput: Equatable {
    /// <p>The description of your instance profile.</p>
    public let description: String?
    /// <p>An array of strings that specifies the list of app packages that should not be cleaned up from the device
    ///             after a test run.</p>
    ///         <p>The list of packages is considered only if you set <code>packageCleanup</code> to
    ///             <code>true</code>.</p>
    public let excludeAppPackagesFromCleanup: [String]?
    /// <p>The name of your instance profile.</p>
    public let name: String?
    /// <p>When set to <code>true</code>, Device Farm removes app packages after a test run. The default value is
    ///                 <code>false</code> for private devices.</p>
    public let packageCleanup: Bool?
    /// <p>When set to <code>true</code>, Device Farm reboots the instance after a test run. The default value is
    ///                 <code>true</code>.</p>
    public let rebootAfterUse: Bool?

    public init (
        description: String? = nil,
        excludeAppPackagesFromCleanup: [String]? = nil,
        name: String? = nil,
        packageCleanup: Bool? = nil,
        rebootAfterUse: Bool? = nil
    )
    {
        self.description = description
        self.excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup
        self.name = name
        self.packageCleanup = packageCleanup
        self.rebootAfterUse = rebootAfterUse
    }
}

struct CreateInstanceProfileInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let packageCleanup: Bool?
    public let excludeAppPackagesFromCleanup: [String]?
    public let rebootAfterUse: Bool?
}

extension CreateInstanceProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case excludeAppPackagesFromCleanup
        case name
        case packageCleanup
        case rebootAfterUse
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let packageCleanupDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .packageCleanup)
        packageCleanup = packageCleanupDecoded
        let excludeAppPackagesFromCleanupContainer = try containerValues.decodeIfPresent([String?].self, forKey: .excludeAppPackagesFromCleanup)
        var excludeAppPackagesFromCleanupDecoded0:[String]? = nil
        if let excludeAppPackagesFromCleanupContainer = excludeAppPackagesFromCleanupContainer {
            excludeAppPackagesFromCleanupDecoded0 = [String]()
            for string0 in excludeAppPackagesFromCleanupContainer {
                if let string0 = string0 {
                    excludeAppPackagesFromCleanupDecoded0?.append(string0)
                }
            }
        }
        excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanupDecoded0
        let rebootAfterUseDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .rebootAfterUse)
        rebootAfterUse = rebootAfterUseDecoded
    }
}

extension CreateInstanceProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateInstanceProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateInstanceProfileOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInstanceProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateInstanceProfileOutputResponse(instanceProfile: \(String(describing: instanceProfile)))"}
}

extension CreateInstanceProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateInstanceProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instanceProfile = output.instanceProfile
        } else {
            self.instanceProfile = nil
        }
    }
}

public struct CreateInstanceProfileOutputResponse: Equatable {
    /// <p>An object that contains information about your instance profile.</p>
    public let instanceProfile: InstanceProfile?

    public init (
        instanceProfile: InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

struct CreateInstanceProfileOutputResponseBody: Equatable {
    public let instanceProfile: InstanceProfile?
}

extension CreateInstanceProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceProfile
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileDecoded = try containerValues.decodeIfPresent(InstanceProfile.self, forKey: .instanceProfile)
        instanceProfile = instanceProfileDecoded
    }
}

public struct CreateNetworkProfileInputBodyMiddleware: Middleware {
    public let id: String = "CreateNetworkProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateNetworkProfileInput>
    public typealias MOutput = OperationOutput<CreateNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateNetworkProfileOutputError>
}

extension CreateNetworkProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateNetworkProfileInput(description: \(String(describing: description)), downlinkBandwidthBits: \(String(describing: downlinkBandwidthBits)), downlinkDelayMs: \(String(describing: downlinkDelayMs)), downlinkJitterMs: \(String(describing: downlinkJitterMs)), downlinkLossPercent: \(String(describing: downlinkLossPercent)), name: \(String(describing: name)), projectArn: \(String(describing: projectArn)), type: \(String(describing: type)), uplinkBandwidthBits: \(String(describing: uplinkBandwidthBits)), uplinkDelayMs: \(String(describing: uplinkDelayMs)), uplinkJitterMs: \(String(describing: uplinkJitterMs)), uplinkLossPercent: \(String(describing: uplinkLossPercent)))"}
}

extension CreateNetworkProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case downlinkBandwidthBits
        case downlinkDelayMs
        case downlinkJitterMs
        case downlinkLossPercent
        case name
        case projectArn
        case type
        case uplinkBandwidthBits
        case uplinkDelayMs
        case uplinkJitterMs
        case uplinkLossPercent
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let downlinkBandwidthBits = downlinkBandwidthBits {
            try encodeContainer.encode(downlinkBandwidthBits, forKey: .downlinkBandwidthBits)
        }
        if let downlinkDelayMs = downlinkDelayMs {
            try encodeContainer.encode(downlinkDelayMs, forKey: .downlinkDelayMs)
        }
        if let downlinkJitterMs = downlinkJitterMs {
            try encodeContainer.encode(downlinkJitterMs, forKey: .downlinkJitterMs)
        }
        if downlinkLossPercent != 0 {
            try encodeContainer.encode(downlinkLossPercent, forKey: .downlinkLossPercent)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uplinkBandwidthBits = uplinkBandwidthBits {
            try encodeContainer.encode(uplinkBandwidthBits, forKey: .uplinkBandwidthBits)
        }
        if let uplinkDelayMs = uplinkDelayMs {
            try encodeContainer.encode(uplinkDelayMs, forKey: .uplinkDelayMs)
        }
        if let uplinkJitterMs = uplinkJitterMs {
            try encodeContainer.encode(uplinkJitterMs, forKey: .uplinkJitterMs)
        }
        if uplinkLossPercent != 0 {
            try encodeContainer.encode(uplinkLossPercent, forKey: .uplinkLossPercent)
        }
    }
}

public struct CreateNetworkProfileInputHeadersMiddleware: Middleware {
    public let id: String = "CreateNetworkProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateNetworkProfileInput>
    public typealias MOutput = OperationOutput<CreateNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateNetworkProfileOutputError>
}

public struct CreateNetworkProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateNetworkProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateNetworkProfileInput>
    public typealias MOutput = OperationOutput<CreateNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateNetworkProfileOutputError>
}

public struct CreateNetworkProfileInput: Equatable {
    /// <p>The description of the network profile.</p>
    public let description: String?
    /// <p>The data throughput rate in bits per second, as an integer from 0 to
    ///             104857600.</p>
    public let downlinkBandwidthBits: Int?
    /// <p>Delay time for all packets to destination in milliseconds as an integer from 0 to
    ///             2000.</p>
    public let downlinkDelayMs: Int?
    /// <p>Time variation in the delay of received packets in milliseconds as an integer from
    ///             0 to 2000.</p>
    public let downlinkJitterMs: Int?
    /// <p>Proportion of received packets that fail to arrive from 0 to 100 percent.</p>
    public let downlinkLossPercent: Int
    /// <p>The name for the new network profile.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the project for which you want to create a
    ///             network profile.</p>
    public let projectArn: String?
    /// <p>The type of network profile to create. Valid values are listed here.</p>
    public let type: NetworkProfileType?
    /// <p>The data throughput rate in bits per second, as an integer from 0 to
    ///             104857600.</p>
    public let uplinkBandwidthBits: Int?
    /// <p>Delay time for all packets to destination in milliseconds as an integer from 0 to
    ///             2000.</p>
    public let uplinkDelayMs: Int?
    /// <p>Time variation in the delay of received packets in milliseconds as an integer from
    ///             0 to 2000.</p>
    public let uplinkJitterMs: Int?
    /// <p>Proportion of transmitted packets that fail to arrive from 0 to 100
    ///             percent.</p>
    public let uplinkLossPercent: Int

    public init (
        description: String? = nil,
        downlinkBandwidthBits: Int? = nil,
        downlinkDelayMs: Int? = nil,
        downlinkJitterMs: Int? = nil,
        downlinkLossPercent: Int = 0,
        name: String? = nil,
        projectArn: String? = nil,
        type: NetworkProfileType? = nil,
        uplinkBandwidthBits: Int? = nil,
        uplinkDelayMs: Int? = nil,
        uplinkJitterMs: Int? = nil,
        uplinkLossPercent: Int = 0
    )
    {
        self.description = description
        self.downlinkBandwidthBits = downlinkBandwidthBits
        self.downlinkDelayMs = downlinkDelayMs
        self.downlinkJitterMs = downlinkJitterMs
        self.downlinkLossPercent = downlinkLossPercent
        self.name = name
        self.projectArn = projectArn
        self.type = type
        self.uplinkBandwidthBits = uplinkBandwidthBits
        self.uplinkDelayMs = uplinkDelayMs
        self.uplinkJitterMs = uplinkJitterMs
        self.uplinkLossPercent = uplinkLossPercent
    }
}

struct CreateNetworkProfileInputBody: Equatable {
    public let projectArn: String?
    public let name: String?
    public let description: String?
    public let type: NetworkProfileType?
    public let uplinkBandwidthBits: Int?
    public let downlinkBandwidthBits: Int?
    public let uplinkDelayMs: Int?
    public let downlinkDelayMs: Int?
    public let uplinkJitterMs: Int?
    public let downlinkJitterMs: Int?
    public let uplinkLossPercent: Int
    public let downlinkLossPercent: Int
}

extension CreateNetworkProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case downlinkBandwidthBits
        case downlinkDelayMs
        case downlinkJitterMs
        case downlinkLossPercent
        case name
        case projectArn
        case type
        case uplinkBandwidthBits
        case uplinkDelayMs
        case uplinkJitterMs
        case uplinkLossPercent
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(NetworkProfileType.self, forKey: .type)
        type = typeDecoded
        let uplinkBandwidthBitsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .uplinkBandwidthBits)
        uplinkBandwidthBits = uplinkBandwidthBitsDecoded
        let downlinkBandwidthBitsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .downlinkBandwidthBits)
        downlinkBandwidthBits = downlinkBandwidthBitsDecoded
        let uplinkDelayMsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .uplinkDelayMs)
        uplinkDelayMs = uplinkDelayMsDecoded
        let downlinkDelayMsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .downlinkDelayMs)
        downlinkDelayMs = downlinkDelayMsDecoded
        let uplinkJitterMsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .uplinkJitterMs)
        uplinkJitterMs = uplinkJitterMsDecoded
        let downlinkJitterMsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .downlinkJitterMs)
        downlinkJitterMs = downlinkJitterMsDecoded
        let uplinkLossPercentDecoded = try containerValues.decode(Int.self, forKey: .uplinkLossPercent)
        uplinkLossPercent = uplinkLossPercentDecoded
        let downlinkLossPercentDecoded = try containerValues.decode(Int.self, forKey: .downlinkLossPercent)
        downlinkLossPercent = downlinkLossPercentDecoded
    }
}

extension CreateNetworkProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNetworkProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateNetworkProfileOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNetworkProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateNetworkProfileOutputResponse(networkProfile: \(String(describing: networkProfile)))"}
}

extension CreateNetworkProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateNetworkProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.networkProfile = output.networkProfile
        } else {
            self.networkProfile = nil
        }
    }
}

public struct CreateNetworkProfileOutputResponse: Equatable {
    /// <p>The network profile that is returned by the create network profile
    ///             request.</p>
    public let networkProfile: NetworkProfile?

    public init (
        networkProfile: NetworkProfile? = nil
    )
    {
        self.networkProfile = networkProfile
    }
}

struct CreateNetworkProfileOutputResponseBody: Equatable {
    public let networkProfile: NetworkProfile?
}

extension CreateNetworkProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case networkProfile
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileDecoded = try containerValues.decodeIfPresent(NetworkProfile.self, forKey: .networkProfile)
        networkProfile = networkProfileDecoded
    }
}

public struct CreateProjectInputBodyMiddleware: Middleware {
    public let id: String = "CreateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

extension CreateProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProjectInput(defaultJobTimeoutMinutes: \(String(describing: defaultJobTimeoutMinutes)), name: \(String(describing: name)))"}
}

extension CreateProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultJobTimeoutMinutes
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultJobTimeoutMinutes = defaultJobTimeoutMinutes {
            try encodeContainer.encode(defaultJobTimeoutMinutes, forKey: .defaultJobTimeoutMinutes)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateProjectInputHeadersMiddleware: Middleware {
    public let id: String = "CreateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

public struct CreateProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

/// <p>Represents a request to the create project operation.</p>
public struct CreateProjectInput: Equatable {
    /// <p>Sets the execution timeout value (in minutes) for a project. All test runs in this project use the
    ///             specified execution timeout value unless overridden when scheduling a run.</p>
    public let defaultJobTimeoutMinutes: Int?
    /// <p>The project's name.</p>
    public let name: String?

    public init (
        defaultJobTimeoutMinutes: Int? = nil,
        name: String? = nil
    )
    {
        self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
        self.name = name
    }
}

struct CreateProjectInputBody: Equatable {
    public let name: String?
    public let defaultJobTimeoutMinutes: Int?
}

extension CreateProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultJobTimeoutMinutes
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let defaultJobTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .defaultJobTimeoutMinutes)
        defaultJobTimeoutMinutes = defaultJobTimeoutMinutesDecoded
    }
}

extension CreateProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOperationException" : self = .tagOperationException(try TagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProjectOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case tagOperationException(TagOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProjectOutputResponse(project: \(String(describing: project)))"}
}

extension CreateProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.project = output.project
        } else {
            self.project = nil
        }
    }
}

/// <p>Represents the result of a create project request.</p>
public struct CreateProjectOutputResponse: Equatable {
    /// <p>The newly created project.</p>
    public let project: Project?

    public init (
        project: Project? = nil
    )
    {
        self.project = project
    }
}

struct CreateProjectOutputResponseBody: Equatable {
    public let project: Project?
}

extension CreateProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case project
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(Project.self, forKey: .project)
        project = projectDecoded
    }
}

extension CreateRemoteAccessSessionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case billingMethod
        case vpceConfigurationArns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingMethod = billingMethod {
            try encodeContainer.encode(billingMethod.rawValue, forKey: .billingMethod)
        }
        if let vpceConfigurationArns = vpceConfigurationArns {
            var vpceConfigurationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpceConfigurationArns)
            for amazonresourcenames0 in vpceConfigurationArns {
                try vpceConfigurationArnsContainer.encode(amazonresourcenames0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingMethodDecoded = try containerValues.decodeIfPresent(BillingMethod.self, forKey: .billingMethod)
        billingMethod = billingMethodDecoded
        let vpceConfigurationArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .vpceConfigurationArns)
        var vpceConfigurationArnsDecoded0:[String]? = nil
        if let vpceConfigurationArnsContainer = vpceConfigurationArnsContainer {
            vpceConfigurationArnsDecoded0 = [String]()
            for string0 in vpceConfigurationArnsContainer {
                if let string0 = string0 {
                    vpceConfigurationArnsDecoded0?.append(string0)
                }
            }
        }
        vpceConfigurationArns = vpceConfigurationArnsDecoded0
    }
}

extension CreateRemoteAccessSessionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRemoteAccessSessionConfiguration(billingMethod: \(String(describing: billingMethod)), vpceConfigurationArns: \(String(describing: vpceConfigurationArns)))"}
}

/// <p>Configuration settings for a remote access session, including billing
///             method.</p>
public struct CreateRemoteAccessSessionConfiguration: Equatable {
    /// <p>The billing method for the remote access session.</p>
    public let billingMethod: BillingMethod?
    /// <p>An array of ARNs included in the VPC endpoint configuration.</p>
    public let vpceConfigurationArns: [String]?

    public init (
        billingMethod: BillingMethod? = nil,
        vpceConfigurationArns: [String]? = nil
    )
    {
        self.billingMethod = billingMethod
        self.vpceConfigurationArns = vpceConfigurationArns
    }
}

public struct CreateRemoteAccessSessionInputBodyMiddleware: Middleware {
    public let id: String = "CreateRemoteAccessSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRemoteAccessSessionInput>
    public typealias MOutput = OperationOutput<CreateRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRemoteAccessSessionOutputError>
}

extension CreateRemoteAccessSessionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRemoteAccessSessionInput(clientId: \(String(describing: clientId)), configuration: \(String(describing: configuration)), deviceArn: \(String(describing: deviceArn)), instanceArn: \(String(describing: instanceArn)), interactionMode: \(String(describing: interactionMode)), name: \(String(describing: name)), projectArn: \(String(describing: projectArn)), remoteDebugEnabled: \(String(describing: remoteDebugEnabled)), remoteRecordAppArn: \(String(describing: remoteRecordAppArn)), remoteRecordEnabled: \(String(describing: remoteRecordEnabled)), skipAppResign: \(String(describing: skipAppResign)), sshPublicKey: \(String(describing: sshPublicKey)))"}
}

extension CreateRemoteAccessSessionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientId
        case configuration
        case deviceArn
        case instanceArn
        case interactionMode
        case name
        case projectArn
        case remoteDebugEnabled
        case remoteRecordAppArn
        case remoteRecordEnabled
        case skipAppResign
        case sshPublicKey
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let interactionMode = interactionMode {
            try encodeContainer.encode(interactionMode.rawValue, forKey: .interactionMode)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let remoteDebugEnabled = remoteDebugEnabled {
            try encodeContainer.encode(remoteDebugEnabled, forKey: .remoteDebugEnabled)
        }
        if let remoteRecordAppArn = remoteRecordAppArn {
            try encodeContainer.encode(remoteRecordAppArn, forKey: .remoteRecordAppArn)
        }
        if let remoteRecordEnabled = remoteRecordEnabled {
            try encodeContainer.encode(remoteRecordEnabled, forKey: .remoteRecordEnabled)
        }
        if let skipAppResign = skipAppResign {
            try encodeContainer.encode(skipAppResign, forKey: .skipAppResign)
        }
        if let sshPublicKey = sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
    }
}

public struct CreateRemoteAccessSessionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRemoteAccessSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRemoteAccessSessionInput>
    public typealias MOutput = OperationOutput<CreateRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRemoteAccessSessionOutputError>
}

public struct CreateRemoteAccessSessionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRemoteAccessSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRemoteAccessSessionInput>
    public typealias MOutput = OperationOutput<CreateRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRemoteAccessSessionOutputError>
}

/// <p>Creates and submits a request to start a remote access session.</p>
public struct CreateRemoteAccessSessionInput: Equatable {
    /// <p>Unique identifier for the client. If you want access to multiple devices on the same client, you should
    ///             pass the same <code>clientId</code> value in each call to <code>CreateRemoteAccessSession</code>. This
    ///             identifier is required only if <code>remoteDebugEnabled</code> is set to <code>true</code>.</p>
    ///         <p>Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no
    ///                 longer supported</a>.</p>
    public let clientId: String?
    /// <p>The configuration information for the remote access session request.</p>
    public let configuration: CreateRemoteAccessSessionConfiguration?
    /// <p>The ARN of the device for which you want to create a remote access session.</p>
    public let deviceArn: String?
    /// <p>The Amazon Resource Name (ARN) of the device instance for which you want to create a
    ///             remote access session.</p>
    public let instanceArn: String?
    /// <p>The interaction mode of the remote access session. Valid values are:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>INTERACTIVE: You can interact with the iOS device by viewing, touching, and
    ///                     rotating the screen. You cannot run XCUITest framework-based tests in this
    ///                     mode.</p>
    ///             </li>
    ///             <li>
    ///                 <p>NO_VIDEO: You are connected to the device, but cannot interact with it or view the screen. This
    ///                     mode has the fastest test execution speed. You can run XCUITest framework-based tests in this
    ///                     mode.</p>
    ///             </li>
    ///             <li>
    ///                 <p>VIDEO_ONLY: You can view the screen, but cannot touch or rotate it. You can run XCUITest
    ///                     framework-based tests and watch the screen in this mode.</p>
    ///             </li>
    ///          </ul>
    public let interactionMode: InteractionMode?
    /// <p>The name of the remote access session to create.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the project for which you want to create a remote
    ///             access session.</p>
    public let projectArn: String?
    /// <p>Set to <code>true</code> if you want to access devices remotely for debugging in
    ///             your remote access session.</p>
    ///         <p>Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no
    ///                 longer supported</a>.</p>
    public let remoteDebugEnabled: Bool?
    /// <p>The Amazon Resource Name (ARN) for the app to be recorded in the remote access
    ///             session.</p>
    public let remoteRecordAppArn: String?
    /// <p>Set to <code>true</code> to enable remote recording for the remote access
    ///             session.</p>
    public let remoteRecordEnabled: Bool?
    /// <p>When set to <code>true</code>, for private devices, Device Farm does not sign your app again. For public
    ///             devices, Device Farm always signs your apps again.</p>
    ///         <p>For more information on how Device Farm modifies your uploads during tests, see <a href="https://aws.amazon.com/device-farm/faq/">Do you modify my app?</a>
    ///          </p>
    public let skipAppResign: Bool?
    /// <p>Ignored. The public key of the <code>ssh</code> key pair you want to use for connecting to remote
    ///             devices in your remote debugging session. This key is required only if <code>remoteDebugEnabled</code> is
    ///             set to <code>true</code>.</p>
    ///         <p>Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no
    ///                 longer supported</a>.</p>
    public let sshPublicKey: String?

    public init (
        clientId: String? = nil,
        configuration: CreateRemoteAccessSessionConfiguration? = nil,
        deviceArn: String? = nil,
        instanceArn: String? = nil,
        interactionMode: InteractionMode? = nil,
        name: String? = nil,
        projectArn: String? = nil,
        remoteDebugEnabled: Bool? = nil,
        remoteRecordAppArn: String? = nil,
        remoteRecordEnabled: Bool? = nil,
        skipAppResign: Bool? = nil,
        sshPublicKey: String? = nil
    )
    {
        self.clientId = clientId
        self.configuration = configuration
        self.deviceArn = deviceArn
        self.instanceArn = instanceArn
        self.interactionMode = interactionMode
        self.name = name
        self.projectArn = projectArn
        self.remoteDebugEnabled = remoteDebugEnabled
        self.remoteRecordAppArn = remoteRecordAppArn
        self.remoteRecordEnabled = remoteRecordEnabled
        self.skipAppResign = skipAppResign
        self.sshPublicKey = sshPublicKey
    }
}

struct CreateRemoteAccessSessionInputBody: Equatable {
    public let projectArn: String?
    public let deviceArn: String?
    public let instanceArn: String?
    public let sshPublicKey: String?
    public let remoteDebugEnabled: Bool?
    public let remoteRecordEnabled: Bool?
    public let remoteRecordAppArn: String?
    public let name: String?
    public let clientId: String?
    public let configuration: CreateRemoteAccessSessionConfiguration?
    public let interactionMode: InteractionMode?
    public let skipAppResign: Bool?
}

extension CreateRemoteAccessSessionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientId
        case configuration
        case deviceArn
        case instanceArn
        case interactionMode
        case name
        case projectArn
        case remoteDebugEnabled
        case remoteRecordAppArn
        case remoteRecordEnabled
        case skipAppResign
        case sshPublicKey
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let deviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let remoteDebugEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .remoteDebugEnabled)
        remoteDebugEnabled = remoteDebugEnabledDecoded
        let remoteRecordEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .remoteRecordEnabled)
        remoteRecordEnabled = remoteRecordEnabledDecoded
        let remoteRecordAppArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .remoteRecordAppArn)
        remoteRecordAppArn = remoteRecordAppArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(CreateRemoteAccessSessionConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let interactionModeDecoded = try containerValues.decodeIfPresent(InteractionMode.self, forKey: .interactionMode)
        interactionMode = interactionModeDecoded
        let skipAppResignDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .skipAppResign)
        skipAppResign = skipAppResignDecoded
    }
}

extension CreateRemoteAccessSessionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRemoteAccessSessionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRemoteAccessSessionOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRemoteAccessSessionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRemoteAccessSessionOutputResponse(remoteAccessSession: \(String(describing: remoteAccessSession)))"}
}

extension CreateRemoteAccessSessionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRemoteAccessSessionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.remoteAccessSession = output.remoteAccessSession
        } else {
            self.remoteAccessSession = nil
        }
    }
}

/// <p>Represents the server response from a request to create a remote access
///             session.</p>
public struct CreateRemoteAccessSessionOutputResponse: Equatable {
    /// <p>A container that describes the remote access session when the request to create a
    ///             remote access session is sent.</p>
    public let remoteAccessSession: RemoteAccessSession?

    public init (
        remoteAccessSession: RemoteAccessSession? = nil
    )
    {
        self.remoteAccessSession = remoteAccessSession
    }
}

struct CreateRemoteAccessSessionOutputResponseBody: Equatable {
    public let remoteAccessSession: RemoteAccessSession?
}

extension CreateRemoteAccessSessionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case remoteAccessSession
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remoteAccessSessionDecoded = try containerValues.decodeIfPresent(RemoteAccessSession.self, forKey: .remoteAccessSession)
        remoteAccessSession = remoteAccessSessionDecoded
    }
}

public struct CreateTestGridProjectInputBodyMiddleware: Middleware {
    public let id: String = "CreateTestGridProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTestGridProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTestGridProjectInput>
    public typealias MOutput = OperationOutput<CreateTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTestGridProjectOutputError>
}

extension CreateTestGridProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTestGridProjectInput(description: \(String(describing: description)), name: \(String(describing: name)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension CreateTestGridProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case name
        case vpcConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct CreateTestGridProjectInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTestGridProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTestGridProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTestGridProjectInput>
    public typealias MOutput = OperationOutput<CreateTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTestGridProjectOutputError>
}

public struct CreateTestGridProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTestGridProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTestGridProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTestGridProjectInput>
    public typealias MOutput = OperationOutput<CreateTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTestGridProjectOutputError>
}

public struct CreateTestGridProjectInput: Equatable {
    /// <p>Human-readable description of the project.</p>
    public let description: String?
    /// <p>Human-readable name of the Selenium testing project.</p>
    public let name: String?
    /// <p>The VPC security groups and subnets that are attached to a project.</p>
    public let vpcConfig: TestGridVpcConfig?

    public init (
        description: String? = nil,
        name: String? = nil,
        vpcConfig: TestGridVpcConfig? = nil
    )
    {
        self.description = description
        self.name = name
        self.vpcConfig = vpcConfig
    }
}

struct CreateTestGridProjectInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let vpcConfig: TestGridVpcConfig?
}

extension CreateTestGridProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case name
        case vpcConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(TestGridVpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension CreateTestGridProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTestGridProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTestGridProjectOutputError: Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTestGridProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTestGridProjectOutputResponse(testGridProject: \(String(describing: testGridProject)))"}
}

extension CreateTestGridProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateTestGridProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.testGridProject = output.testGridProject
        } else {
            self.testGridProject = nil
        }
    }
}

public struct CreateTestGridProjectOutputResponse: Equatable {
    /// <p>ARN of the Selenium testing project that was created.</p>
    public let testGridProject: TestGridProject?

    public init (
        testGridProject: TestGridProject? = nil
    )
    {
        self.testGridProject = testGridProject
    }
}

struct CreateTestGridProjectOutputResponseBody: Equatable {
    public let testGridProject: TestGridProject?
}

extension CreateTestGridProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case testGridProject
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testGridProjectDecoded = try containerValues.decodeIfPresent(TestGridProject.self, forKey: .testGridProject)
        testGridProject = testGridProjectDecoded
    }
}

public struct CreateTestGridUrlInputBodyMiddleware: Middleware {
    public let id: String = "CreateTestGridUrlInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTestGridUrlInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTestGridUrlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTestGridUrlInput>
    public typealias MOutput = OperationOutput<CreateTestGridUrlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTestGridUrlOutputError>
}

extension CreateTestGridUrlInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTestGridUrlInput(expiresInSeconds: \(String(describing: expiresInSeconds)), projectArn: \(String(describing: projectArn)))"}
}

extension CreateTestGridUrlInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case expiresInSeconds
        case projectArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expiresInSeconds = expiresInSeconds {
            try encodeContainer.encode(expiresInSeconds, forKey: .expiresInSeconds)
        }
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
    }
}

public struct CreateTestGridUrlInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTestGridUrlInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTestGridUrlInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTestGridUrlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTestGridUrlInput>
    public typealias MOutput = OperationOutput<CreateTestGridUrlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTestGridUrlOutputError>
}

public struct CreateTestGridUrlInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTestGridUrlInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTestGridUrlInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTestGridUrlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTestGridUrlInput>
    public typealias MOutput = OperationOutput<CreateTestGridUrlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTestGridUrlOutputError>
}

public struct CreateTestGridUrlInput: Equatable {
    /// <p>Lifetime, in seconds, of the URL.</p>
    public let expiresInSeconds: Int?
    /// <p>ARN (from <a>CreateTestGridProject</a> or <a>ListTestGridProjects</a>) to associate
    ///          with the short-term URL. </p>
    public let projectArn: String?

    public init (
        expiresInSeconds: Int? = nil,
        projectArn: String? = nil
    )
    {
        self.expiresInSeconds = expiresInSeconds
        self.projectArn = projectArn
    }
}

struct CreateTestGridUrlInputBody: Equatable {
    public let projectArn: String?
    public let expiresInSeconds: Int?
}

extension CreateTestGridUrlInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case expiresInSeconds
        case projectArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let expiresInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .expiresInSeconds)
        expiresInSeconds = expiresInSecondsDecoded
    }
}

extension CreateTestGridUrlOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTestGridUrlOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTestGridUrlOutputError: Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTestGridUrlOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTestGridUrlOutputResponse(expires: \(String(describing: expires)), url: \(String(describing: url)))"}
}

extension CreateTestGridUrlOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateTestGridUrlOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.expires = output.expires
            self.url = output.url
        } else {
            self.expires = nil
            self.url = nil
        }
    }
}

public struct CreateTestGridUrlOutputResponse: Equatable {
    /// <p>The number of seconds the URL from <a>CreateTestGridUrlResult$url</a> stays active.</p>
    public let expires: Date?
    /// <p>A signed URL, expiring in <a>CreateTestGridUrlRequest$expiresInSeconds</a> seconds, to be passed
    ///          to a <code>RemoteWebDriver</code>. </p>
    public let url: String?

    public init (
        expires: Date? = nil,
        url: String? = nil
    )
    {
        self.expires = expires
        self.url = url
    }
}

struct CreateTestGridUrlOutputResponseBody: Equatable {
    public let url: String?
    public let expires: Date?
}

extension CreateTestGridUrlOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case expires
        case url
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
        let expiresDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expires)
        expires = expiresDecoded
    }
}

public struct CreateUploadInputBodyMiddleware: Middleware {
    public let id: String = "CreateUploadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUploadInput>
    public typealias MOutput = OperationOutput<CreateUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUploadOutputError>
}

extension CreateUploadInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUploadInput(contentType: \(String(describing: contentType)), name: \(String(describing: name)), projectArn: \(String(describing: projectArn)), type: \(String(describing: type)))"}
}

extension CreateUploadInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentType
        case name
        case projectArn
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateUploadInputHeadersMiddleware: Middleware {
    public let id: String = "CreateUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUploadInput>
    public typealias MOutput = OperationOutput<CreateUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUploadOutputError>
}

public struct CreateUploadInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUploadInput>
    public typealias MOutput = OperationOutput<CreateUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUploadOutputError>
}

/// <p>Represents a request to the create upload operation.</p>
public struct CreateUploadInput: Equatable {
    /// <p>The upload's content type (for example, <code>application/octet-stream</code>).</p>
    public let contentType: String?
    /// <p>The upload's file name. The name should not contain any forward slashes (<code>/</code>). If you are
    ///             uploading an iOS app, the file name must end with the <code>.ipa</code> extension. If you are uploading an
    ///             Android app, the file name must end with the <code>.apk</code> extension. For all others, the file name must
    ///             end with the <code>.zip</code> file extension.</p>
    public let name: String?
    /// <p>The ARN of the project for the upload.</p>
    public let projectArn: String?
    /// <p>The upload's upload type.</p>
    ///         <p>Must be one of the following values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>ANDROID_APP</p>
    ///             </li>
    ///             <li>
    ///                 <p>IOS_APP</p>
    ///             </li>
    ///             <li>
    ///                 <p>WEB_APP</p>
    ///             </li>
    ///             <li>
    ///                 <p>EXTERNAL_DATA</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_JUNIT_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_TESTNG_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_PYTHON_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_NODE_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_RUBY_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_PYTHON_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_NODE_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_RUBY_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>CALABASH_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>INSTRUMENTATION_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>UIAUTOMATION_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>UIAUTOMATOR_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>XCTEST_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>XCTEST_UI_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_JUNIT_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_TESTNG_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_PYTHON_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_NODE_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_RUBY_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_JAVA_JUNIT_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_JAVA_TESTNG_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_PYTHON_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_NODE_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_RUBY_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>INSTRUMENTATION_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>XCTEST_UI_TEST_SPEC</p>
    ///             </li>
    ///          </ul>
    ///         <p> If you call <code>CreateUpload</code> with <code>WEB_APP</code> specified, AWS
    ///             Device Farm throws an <code>ArgumentException</code> error.</p>
    public let type: UploadType?

    public init (
        contentType: String? = nil,
        name: String? = nil,
        projectArn: String? = nil,
        type: UploadType? = nil
    )
    {
        self.contentType = contentType
        self.name = name
        self.projectArn = projectArn
        self.type = type
    }
}

struct CreateUploadInputBody: Equatable {
    public let projectArn: String?
    public let name: String?
    public let type: UploadType?
    public let contentType: String?
}

extension CreateUploadInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contentType
        case name
        case projectArn
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(UploadType.self, forKey: .type)
        type = typeDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension CreateUploadOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUploadOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUploadOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUploadOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUploadOutputResponse(upload: \(String(describing: upload)))"}
}

extension CreateUploadOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateUploadOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.upload = output.upload
        } else {
            self.upload = nil
        }
    }
}

/// <p>Represents the result of a create upload request.</p>
public struct CreateUploadOutputResponse: Equatable {
    /// <p>The newly created upload.</p>
    public let upload: Upload?

    public init (
        upload: Upload? = nil
    )
    {
        self.upload = upload
    }
}

struct CreateUploadOutputResponseBody: Equatable {
    public let upload: Upload?
}

extension CreateUploadOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case upload
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadDecoded = try containerValues.decodeIfPresent(Upload.self, forKey: .upload)
        upload = uploadDecoded
    }
}

public struct CreateVPCEConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "CreateVPCEConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVPCEConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVPCEConfigurationInput>
    public typealias MOutput = OperationOutput<CreateVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVPCEConfigurationOutputError>
}

extension CreateVPCEConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVPCEConfigurationInput(serviceDnsName: \(String(describing: serviceDnsName)), vpceConfigurationDescription: \(String(describing: vpceConfigurationDescription)), vpceConfigurationName: \(String(describing: vpceConfigurationName)), vpceServiceName: \(String(describing: vpceServiceName)))"}
}

extension CreateVPCEConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serviceDnsName
        case vpceConfigurationDescription
        case vpceConfigurationName
        case vpceServiceName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceDnsName = serviceDnsName {
            try encodeContainer.encode(serviceDnsName, forKey: .serviceDnsName)
        }
        if let vpceConfigurationDescription = vpceConfigurationDescription {
            try encodeContainer.encode(vpceConfigurationDescription, forKey: .vpceConfigurationDescription)
        }
        if let vpceConfigurationName = vpceConfigurationName {
            try encodeContainer.encode(vpceConfigurationName, forKey: .vpceConfigurationName)
        }
        if let vpceServiceName = vpceServiceName {
            try encodeContainer.encode(vpceServiceName, forKey: .vpceServiceName)
        }
    }
}

public struct CreateVPCEConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateVPCEConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVPCEConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVPCEConfigurationInput>
    public typealias MOutput = OperationOutput<CreateVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVPCEConfigurationOutputError>
}

public struct CreateVPCEConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateVPCEConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVPCEConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVPCEConfigurationInput>
    public typealias MOutput = OperationOutput<CreateVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVPCEConfigurationOutputError>
}

public struct CreateVPCEConfigurationInput: Equatable {
    /// <p>The DNS name of the service running in your VPC that you want Device Farm to
    ///             test.</p>
    public let serviceDnsName: String?
    /// <p>An optional description that provides details about your VPC endpoint configuration.</p>
    public let vpceConfigurationDescription: String?
    /// <p>The friendly name you give to your VPC endpoint configuration, to manage your
    ///             configurations more easily.</p>
    public let vpceConfigurationName: String?
    /// <p>The name of the VPC endpoint service running in your AWS account that you want Device Farm to test.</p>
    public let vpceServiceName: String?

    public init (
        serviceDnsName: String? = nil,
        vpceConfigurationDescription: String? = nil,
        vpceConfigurationName: String? = nil,
        vpceServiceName: String? = nil
    )
    {
        self.serviceDnsName = serviceDnsName
        self.vpceConfigurationDescription = vpceConfigurationDescription
        self.vpceConfigurationName = vpceConfigurationName
        self.vpceServiceName = vpceServiceName
    }
}

struct CreateVPCEConfigurationInputBody: Equatable {
    public let vpceConfigurationName: String?
    public let vpceServiceName: String?
    public let serviceDnsName: String?
    public let vpceConfigurationDescription: String?
}

extension CreateVPCEConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serviceDnsName
        case vpceConfigurationDescription
        case vpceConfigurationName
        case vpceServiceName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpceConfigurationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpceConfigurationName)
        vpceConfigurationName = vpceConfigurationNameDecoded
        let vpceServiceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpceServiceName)
        vpceServiceName = vpceServiceNameDecoded
        let serviceDnsNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceDnsName)
        serviceDnsName = serviceDnsNameDecoded
        let vpceConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpceConfigurationDescription)
        vpceConfigurationDescription = vpceConfigurationDescriptionDecoded
    }
}

extension CreateVPCEConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVPCEConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateVPCEConfigurationOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVPCEConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVPCEConfigurationOutputResponse(vpceConfiguration: \(String(describing: vpceConfiguration)))"}
}

extension CreateVPCEConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateVPCEConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.vpceConfiguration = output.vpceConfiguration
        } else {
            self.vpceConfiguration = nil
        }
    }
}

public struct CreateVPCEConfigurationOutputResponse: Equatable {
    /// <p>An object that contains information about your VPC endpoint configuration.</p>
    public let vpceConfiguration: VPCEConfiguration?

    public init (
        vpceConfiguration: VPCEConfiguration? = nil
    )
    {
        self.vpceConfiguration = vpceConfiguration
    }
}

struct CreateVPCEConfigurationOutputResponseBody: Equatable {
    public let vpceConfiguration: VPCEConfiguration?
}

extension CreateVPCEConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case vpceConfiguration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpceConfigurationDecoded = try containerValues.decodeIfPresent(VPCEConfiguration.self, forKey: .vpceConfiguration)
        vpceConfiguration = vpceConfigurationDecoded
    }
}

public enum CurrencyCode {
    case usd
    case sdkUnknown(String)
}

extension CurrencyCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CurrencyCode] {
        return [
            .usd,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .usd: return "USD"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CurrencyCode(rawValue: rawValue) ?? CurrencyCode.sdkUnknown(rawValue)
    }
}

extension CustomerArtifactPaths: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case androidPaths
        case deviceHostPaths
        case iosPaths
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let androidPaths = androidPaths {
            var androidPathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .androidPaths)
            for androidpaths0 in androidPaths {
                try androidPathsContainer.encode(androidpaths0)
            }
        }
        if let deviceHostPaths = deviceHostPaths {
            var deviceHostPathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceHostPaths)
            for devicehostpaths0 in deviceHostPaths {
                try deviceHostPathsContainer.encode(devicehostpaths0)
            }
        }
        if let iosPaths = iosPaths {
            var iosPathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .iosPaths)
            for iospaths0 in iosPaths {
                try iosPathsContainer.encode(iospaths0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iosPathsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .iosPaths)
        var iosPathsDecoded0:[String]? = nil
        if let iosPathsContainer = iosPathsContainer {
            iosPathsDecoded0 = [String]()
            for string0 in iosPathsContainer {
                if let string0 = string0 {
                    iosPathsDecoded0?.append(string0)
                }
            }
        }
        iosPaths = iosPathsDecoded0
        let androidPathsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .androidPaths)
        var androidPathsDecoded0:[String]? = nil
        if let androidPathsContainer = androidPathsContainer {
            androidPathsDecoded0 = [String]()
            for string0 in androidPathsContainer {
                if let string0 = string0 {
                    androidPathsDecoded0?.append(string0)
                }
            }
        }
        androidPaths = androidPathsDecoded0
        let deviceHostPathsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .deviceHostPaths)
        var deviceHostPathsDecoded0:[String]? = nil
        if let deviceHostPathsContainer = deviceHostPathsContainer {
            deviceHostPathsDecoded0 = [String]()
            for string0 in deviceHostPathsContainer {
                if let string0 = string0 {
                    deviceHostPathsDecoded0?.append(string0)
                }
            }
        }
        deviceHostPaths = deviceHostPathsDecoded0
    }
}

extension CustomerArtifactPaths: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomerArtifactPaths(androidPaths: \(String(describing: androidPaths)), deviceHostPaths: \(String(describing: deviceHostPaths)), iosPaths: \(String(describing: iosPaths)))"}
}

/// <p>A JSON object that specifies the paths where the artifacts generated by the customer's tests, on the
///             device or in the test environment, are pulled from.</p>
///         <p>Specify <code>deviceHostPaths</code> and optionally specify either
///                 <code>iosPaths</code> or <code>androidPaths</code>.</p>
///         <p>For web app tests, you can specify both <code>iosPaths</code> and
///                 <code>androidPaths</code>.</p>
public struct CustomerArtifactPaths: Equatable {
    /// <p>Comma-separated list of paths on the Android device where the artifacts generated by the customer's
    ///             tests are pulled from.</p>
    public let androidPaths: [String]?
    /// <p>Comma-separated list of paths in the test execution environment where the artifacts generated by the
    ///             customer's tests are pulled from.</p>
    public let deviceHostPaths: [String]?
    /// <p>Comma-separated list of paths on the iOS device where the artifacts generated by the customer's tests
    ///             are pulled from.</p>
    public let iosPaths: [String]?

    public init (
        androidPaths: [String]? = nil,
        deviceHostPaths: [String]? = nil,
        iosPaths: [String]? = nil
    )
    {
        self.androidPaths = androidPaths
        self.deviceHostPaths = deviceHostPaths
        self.iosPaths = iosPaths
    }
}

public struct DeleteDevicePoolInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDevicePoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDevicePoolInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDevicePoolInput>
    public typealias MOutput = OperationOutput<DeleteDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDevicePoolOutputError>
}

extension DeleteDevicePoolInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDevicePoolInput(arn: \(String(describing: arn)))"}
}

extension DeleteDevicePoolInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteDevicePoolInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDevicePoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDevicePoolInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDevicePoolInput>
    public typealias MOutput = OperationOutput<DeleteDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDevicePoolOutputError>
}

public struct DeleteDevicePoolInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDevicePoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDevicePoolInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDevicePoolInput>
    public typealias MOutput = OperationOutput<DeleteDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDevicePoolOutputError>
}

/// <p>Represents a request to the delete device pool operation.</p>
public struct DeleteDevicePoolInput: Equatable {
    /// <p>Represents the Amazon Resource Name (ARN) of the Device Farm device pool to delete.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteDevicePoolInputBody: Equatable {
    public let arn: String?
}

extension DeleteDevicePoolInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteDevicePoolOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDevicePoolOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDevicePoolOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDevicePoolOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDevicePoolOutputResponse()"}
}

extension DeleteDevicePoolOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Represents the result of a delete device pool request.</p>
public struct DeleteDevicePoolOutputResponse: Equatable {

    public init() {}
}

struct DeleteDevicePoolOutputResponseBody: Equatable {
}

extension DeleteDevicePoolOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteInstanceProfileInputBodyMiddleware: Middleware {
    public let id: String = "DeleteInstanceProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInstanceProfileInput>
    public typealias MOutput = OperationOutput<DeleteInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInstanceProfileOutputError>
}

extension DeleteInstanceProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInstanceProfileInput(arn: \(String(describing: arn)))"}
}

extension DeleteInstanceProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteInstanceProfileInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteInstanceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInstanceProfileInput>
    public typealias MOutput = OperationOutput<DeleteInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInstanceProfileOutputError>
}

public struct DeleteInstanceProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteInstanceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInstanceProfileInput>
    public typealias MOutput = OperationOutput<DeleteInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInstanceProfileOutputError>
}

public struct DeleteInstanceProfileInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the instance profile you are requesting to
    ///             delete.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteInstanceProfileInputBody: Equatable {
    public let arn: String?
}

extension DeleteInstanceProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteInstanceProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInstanceProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInstanceProfileOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInstanceProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInstanceProfileOutputResponse()"}
}

extension DeleteInstanceProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteInstanceProfileOutputResponse: Equatable {

    public init() {}
}

struct DeleteInstanceProfileOutputResponseBody: Equatable {
}

extension DeleteInstanceProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteNetworkProfileInputBodyMiddleware: Middleware {
    public let id: String = "DeleteNetworkProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNetworkProfileInput>
    public typealias MOutput = OperationOutput<DeleteNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNetworkProfileOutputError>
}

extension DeleteNetworkProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteNetworkProfileInput(arn: \(String(describing: arn)))"}
}

extension DeleteNetworkProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteNetworkProfileInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteNetworkProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNetworkProfileInput>
    public typealias MOutput = OperationOutput<DeleteNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNetworkProfileOutputError>
}

public struct DeleteNetworkProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteNetworkProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNetworkProfileInput>
    public typealias MOutput = OperationOutput<DeleteNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNetworkProfileOutputError>
}

public struct DeleteNetworkProfileInput: Equatable {
    /// <p>The ARN of the network profile to delete.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteNetworkProfileInputBody: Equatable {
    public let arn: String?
}

extension DeleteNetworkProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteNetworkProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNetworkProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteNetworkProfileOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNetworkProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteNetworkProfileOutputResponse()"}
}

extension DeleteNetworkProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteNetworkProfileOutputResponse: Equatable {

    public init() {}
}

struct DeleteNetworkProfileOutputResponseBody: Equatable {
}

extension DeleteNetworkProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteProjectInputBodyMiddleware: Middleware {
    public let id: String = "DeleteProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProjectOutputError>
}

extension DeleteProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProjectInput(arn: \(String(describing: arn)))"}
}

extension DeleteProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteProjectInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProjectOutputError>
}

/// <p>Represents a request to the delete project operation.</p>
public struct DeleteProjectInput: Equatable {
    /// <p>Represents the Amazon Resource Name (ARN) of the Device Farm project to delete.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteProjectInputBody: Equatable {
    public let arn: String?
}

extension DeleteProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProjectOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProjectOutputResponse()"}
}

extension DeleteProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Represents the result of a delete project request.</p>
public struct DeleteProjectOutputResponse: Equatable {

    public init() {}
}

struct DeleteProjectOutputResponseBody: Equatable {
}

extension DeleteProjectOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteRemoteAccessSessionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRemoteAccessSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRemoteAccessSessionInput>
    public typealias MOutput = OperationOutput<DeleteRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRemoteAccessSessionOutputError>
}

extension DeleteRemoteAccessSessionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRemoteAccessSessionInput(arn: \(String(describing: arn)))"}
}

extension DeleteRemoteAccessSessionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteRemoteAccessSessionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRemoteAccessSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRemoteAccessSessionInput>
    public typealias MOutput = OperationOutput<DeleteRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRemoteAccessSessionOutputError>
}

public struct DeleteRemoteAccessSessionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRemoteAccessSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRemoteAccessSessionInput>
    public typealias MOutput = OperationOutput<DeleteRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRemoteAccessSessionOutputError>
}

/// <p>Represents the request to delete the specified remote access session.</p>
public struct DeleteRemoteAccessSessionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the session for which you want to delete remote
    ///             access.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteRemoteAccessSessionInputBody: Equatable {
    public let arn: String?
}

extension DeleteRemoteAccessSessionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteRemoteAccessSessionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRemoteAccessSessionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRemoteAccessSessionOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRemoteAccessSessionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRemoteAccessSessionOutputResponse()"}
}

extension DeleteRemoteAccessSessionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The response from the server when a request is made to delete the remote access
///             session.</p>
public struct DeleteRemoteAccessSessionOutputResponse: Equatable {

    public init() {}
}

struct DeleteRemoteAccessSessionOutputResponseBody: Equatable {
}

extension DeleteRemoteAccessSessionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteRunInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRunInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRunInput>
    public typealias MOutput = OperationOutput<DeleteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRunOutputError>
}

extension DeleteRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRunInput(arn: \(String(describing: arn)))"}
}

extension DeleteRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteRunInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRunInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRunInput>
    public typealias MOutput = OperationOutput<DeleteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRunOutputError>
}

public struct DeleteRunInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRunInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRunInput>
    public typealias MOutput = OperationOutput<DeleteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRunOutputError>
}

/// <p>Represents a request to the delete run operation.</p>
public struct DeleteRunInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the run to delete.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteRunInputBody: Equatable {
    public let arn: String?
}

extension DeleteRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRunOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRunOutputResponse()"}
}

extension DeleteRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Represents the result of a delete run request.</p>
public struct DeleteRunOutputResponse: Equatable {

    public init() {}
}

struct DeleteRunOutputResponseBody: Equatable {
}

extension DeleteRunOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteTestGridProjectInputBodyMiddleware: Middleware {
    public let id: String = "DeleteTestGridProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTestGridProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTestGridProjectInput>
    public typealias MOutput = OperationOutput<DeleteTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTestGridProjectOutputError>
}

extension DeleteTestGridProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTestGridProjectInput(projectArn: \(String(describing: projectArn)))"}
}

extension DeleteTestGridProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case projectArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
    }
}

public struct DeleteTestGridProjectInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTestGridProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTestGridProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTestGridProjectInput>
    public typealias MOutput = OperationOutput<DeleteTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTestGridProjectOutputError>
}

public struct DeleteTestGridProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTestGridProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTestGridProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTestGridProjectInput>
    public typealias MOutput = OperationOutput<DeleteTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTestGridProjectOutputError>
}

public struct DeleteTestGridProjectInput: Equatable {
    /// <p>The ARN of the project to delete, from <a>CreateTestGridProject</a> or <a>ListTestGridProjects</a>.</p>
    public let projectArn: String?

    public init (
        projectArn: String? = nil
    )
    {
        self.projectArn = projectArn
    }
}

struct DeleteTestGridProjectInputBody: Equatable {
    public let projectArn: String?
}

extension DeleteTestGridProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case projectArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
    }
}

extension DeleteTestGridProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTestGridProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CannotDeleteException" : self = .cannotDeleteException(try CannotDeleteException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTestGridProjectOutputError: Equatable {
    case argumentException(ArgumentException)
    case cannotDeleteException(CannotDeleteException)
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTestGridProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTestGridProjectOutputResponse()"}
}

extension DeleteTestGridProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTestGridProjectOutputResponse: Equatable {

    public init() {}
}

struct DeleteTestGridProjectOutputResponseBody: Equatable {
}

extension DeleteTestGridProjectOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteUploadInputBodyMiddleware: Middleware {
    public let id: String = "DeleteUploadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUploadInput>
    public typealias MOutput = OperationOutput<DeleteUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUploadOutputError>
}

extension DeleteUploadInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUploadInput(arn: \(String(describing: arn)))"}
}

extension DeleteUploadInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteUploadInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUploadInput>
    public typealias MOutput = OperationOutput<DeleteUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUploadOutputError>
}

public struct DeleteUploadInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUploadInput>
    public typealias MOutput = OperationOutput<DeleteUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUploadOutputError>
}

/// <p>Represents a request to the delete upload operation.</p>
public struct DeleteUploadInput: Equatable {
    /// <p>Represents the Amazon Resource Name (ARN) of the Device Farm upload to delete.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteUploadInputBody: Equatable {
    public let arn: String?
}

extension DeleteUploadInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteUploadOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUploadOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUploadOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUploadOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUploadOutputResponse()"}
}

extension DeleteUploadOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Represents the result of a delete upload request.</p>
public struct DeleteUploadOutputResponse: Equatable {

    public init() {}
}

struct DeleteUploadOutputResponseBody: Equatable {
}

extension DeleteUploadOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteVPCEConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteVPCEConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVPCEConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVPCEConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVPCEConfigurationOutputError>
}

extension DeleteVPCEConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVPCEConfigurationInput(arn: \(String(describing: arn)))"}
}

extension DeleteVPCEConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteVPCEConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteVPCEConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVPCEConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVPCEConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVPCEConfigurationOutputError>
}

public struct DeleteVPCEConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteVPCEConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVPCEConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVPCEConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVPCEConfigurationOutputError>
}

public struct DeleteVPCEConfigurationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the VPC endpoint configuration you want to
    ///             delete.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteVPCEConfigurationInputBody: Equatable {
    public let arn: String?
}

extension DeleteVPCEConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteVPCEConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVPCEConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVPCEConfigurationOutputError: Equatable {
    case argumentException(ArgumentException)
    case invalidOperationException(InvalidOperationException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVPCEConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVPCEConfigurationOutputResponse()"}
}

extension DeleteVPCEConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVPCEConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeleteVPCEConfigurationOutputResponseBody: Equatable {
}

extension DeleteVPCEConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Device: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case availability
        case carrier
        case cpu
        case fleetName
        case fleetType
        case formFactor
        case heapSize
        case image
        case instances
        case manufacturer
        case memory
        case model
        case modelId
        case name
        case os
        case platform
        case radio
        case remoteAccessEnabled
        case remoteDebugEnabled
        case resolution
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let availability = availability {
            try encodeContainer.encode(availability.rawValue, forKey: .availability)
        }
        if let carrier = carrier {
            try encodeContainer.encode(carrier, forKey: .carrier)
        }
        if let cpu = cpu {
            try encodeContainer.encode(cpu, forKey: .cpu)
        }
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let fleetType = fleetType {
            try encodeContainer.encode(fleetType, forKey: .fleetType)
        }
        if let formFactor = formFactor {
            try encodeContainer.encode(formFactor.rawValue, forKey: .formFactor)
        }
        if let heapSize = heapSize {
            try encodeContainer.encode(heapSize, forKey: .heapSize)
        }
        if let image = image {
            try encodeContainer.encode(image, forKey: .image)
        }
        if let instances = instances {
            var instancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instances)
            for deviceinstances0 in instances {
                try instancesContainer.encode(deviceinstances0)
            }
        }
        if let manufacturer = manufacturer {
            try encodeContainer.encode(manufacturer, forKey: .manufacturer)
        }
        if let memory = memory {
            try encodeContainer.encode(memory, forKey: .memory)
        }
        if let model = model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let modelId = modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let os = os {
            try encodeContainer.encode(os, forKey: .os)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let radio = radio {
            try encodeContainer.encode(radio, forKey: .radio)
        }
        if let remoteAccessEnabled = remoteAccessEnabled {
            try encodeContainer.encode(remoteAccessEnabled, forKey: .remoteAccessEnabled)
        }
        if let remoteDebugEnabled = remoteDebugEnabled {
            try encodeContainer.encode(remoteDebugEnabled, forKey: .remoteDebugEnabled)
        }
        if let resolution = resolution {
            try encodeContainer.encode(resolution, forKey: .resolution)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let manufacturerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .manufacturer)
        manufacturer = manufacturerDecoded
        let modelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .model)
        model = modelDecoded
        let modelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let formFactorDecoded = try containerValues.decodeIfPresent(DeviceFormFactor.self, forKey: .formFactor)
        formFactor = formFactorDecoded
        let platformDecoded = try containerValues.decodeIfPresent(DevicePlatform.self, forKey: .platform)
        platform = platformDecoded
        let osDecoded = try containerValues.decodeIfPresent(String.self, forKey: .os)
        os = osDecoded
        let cpuDecoded = try containerValues.decodeIfPresent(CPU.self, forKey: .cpu)
        cpu = cpuDecoded
        let resolutionDecoded = try containerValues.decodeIfPresent(Resolution.self, forKey: .resolution)
        resolution = resolutionDecoded
        let heapSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .heapSize)
        heapSize = heapSizeDecoded
        let memoryDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .memory)
        memory = memoryDecoded
        let imageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .image)
        image = imageDecoded
        let carrierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .carrier)
        carrier = carrierDecoded
        let radioDecoded = try containerValues.decodeIfPresent(String.self, forKey: .radio)
        radio = radioDecoded
        let remoteAccessEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .remoteAccessEnabled)
        remoteAccessEnabled = remoteAccessEnabledDecoded
        let remoteDebugEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .remoteDebugEnabled)
        remoteDebugEnabled = remoteDebugEnabledDecoded
        let fleetTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetType)
        fleetType = fleetTypeDecoded
        let fleetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let instancesContainer = try containerValues.decodeIfPresent([DeviceInstance?].self, forKey: .instances)
        var instancesDecoded0:[DeviceInstance]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [DeviceInstance]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
        let availabilityDecoded = try containerValues.decodeIfPresent(DeviceAvailability.self, forKey: .availability)
        availability = availabilityDecoded
    }
}

extension Device: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Device(arn: \(String(describing: arn)), availability: \(String(describing: availability)), carrier: \(String(describing: carrier)), cpu: \(String(describing: cpu)), fleetName: \(String(describing: fleetName)), fleetType: \(String(describing: fleetType)), formFactor: \(String(describing: formFactor)), heapSize: \(String(describing: heapSize)), image: \(String(describing: image)), instances: \(String(describing: instances)), manufacturer: \(String(describing: manufacturer)), memory: \(String(describing: memory)), model: \(String(describing: model)), modelId: \(String(describing: modelId)), name: \(String(describing: name)), os: \(String(describing: os)), platform: \(String(describing: platform)), radio: \(String(describing: radio)), remoteAccessEnabled: \(String(describing: remoteAccessEnabled)), remoteDebugEnabled: \(String(describing: remoteDebugEnabled)), resolution: \(String(describing: resolution)))"}
}

/// <p>Represents a device type that an app is tested against.</p>
public struct Device: Equatable {
    /// <p>The device's ARN.</p>
    public let arn: String?
    /// <p>Indicates how likely a device is available for a test run. Currently available in the <a>ListDevices</a> and GetDevice API methods.</p>
    public let availability: DeviceAvailability?
    /// <p>The device's carrier.</p>
    public let carrier: String?
    /// <p>Information about the device's CPU.</p>
    public let cpu: CPU?
    /// <p>The name of the fleet to which this device belongs.</p>
    public let fleetName: String?
    /// <p>The type of fleet to which this device belongs. Possible values are PRIVATE and PUBLIC.</p>
    public let fleetType: String?
    /// <p>The device's form factor.</p>
    ///         <p>Allowed values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>PHONE</p>
    ///             </li>
    ///             <li>
    ///                 <p>TABLET</p>
    ///             </li>
    ///          </ul>
    public let formFactor: DeviceFormFactor?
    /// <p>The device's heap size, expressed in bytes.</p>
    public let heapSize: Int?
    /// <p>The device's image name.</p>
    public let image: String?
    /// <p>The instances that belong to this device.</p>
    public let instances: [DeviceInstance]?
    /// <p>The device's manufacturer name.</p>
    public let manufacturer: String?
    /// <p>The device's total memory size, expressed in bytes.</p>
    public let memory: Int?
    /// <p>The device's model name.</p>
    public let model: String?
    /// <p>The device's model ID.</p>
    public let modelId: String?
    /// <p>The device's display name.</p>
    public let name: String?
    /// <p>The device's operating system type.</p>
    public let os: String?
    /// <p>The device's platform.</p>
    ///         <p>Allowed values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>ANDROID</p>
    ///             </li>
    ///             <li>
    ///                 <p>IOS</p>
    ///             </li>
    ///          </ul>
    public let platform: DevicePlatform?
    /// <p>The device's radio.</p>
    public let radio: String?
    /// <p>Specifies whether remote access has been enabled for the specified
    ///             device.</p>
    public let remoteAccessEnabled: Bool?
    /// <p>This flag is set to <code>true</code> if remote debugging is enabled for the
    ///             device.</p>
    ///         <p>Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no
    ///                 longer supported</a>.</p>
    public let remoteDebugEnabled: Bool?
    /// <p>The resolution of the device.</p>
    public let resolution: Resolution?

    public init (
        arn: String? = nil,
        availability: DeviceAvailability? = nil,
        carrier: String? = nil,
        cpu: CPU? = nil,
        fleetName: String? = nil,
        fleetType: String? = nil,
        formFactor: DeviceFormFactor? = nil,
        heapSize: Int? = nil,
        image: String? = nil,
        instances: [DeviceInstance]? = nil,
        manufacturer: String? = nil,
        memory: Int? = nil,
        model: String? = nil,
        modelId: String? = nil,
        name: String? = nil,
        os: String? = nil,
        platform: DevicePlatform? = nil,
        radio: String? = nil,
        remoteAccessEnabled: Bool? = nil,
        remoteDebugEnabled: Bool? = nil,
        resolution: Resolution? = nil
    )
    {
        self.arn = arn
        self.availability = availability
        self.carrier = carrier
        self.cpu = cpu
        self.fleetName = fleetName
        self.fleetType = fleetType
        self.formFactor = formFactor
        self.heapSize = heapSize
        self.image = image
        self.instances = instances
        self.manufacturer = manufacturer
        self.memory = memory
        self.model = model
        self.modelId = modelId
        self.name = name
        self.os = os
        self.platform = platform
        self.radio = radio
        self.remoteAccessEnabled = remoteAccessEnabled
        self.remoteDebugEnabled = remoteDebugEnabled
        self.resolution = resolution
    }
}

public enum DeviceAttribute {
    case appiumVersion
    case arn
    case availability
    case fleetType
    case formFactor
    case instanceArn
    case instanceLabels
    case manufacturer
    case model
    case osVersion
    case platform
    case remoteAccessEnabled
    case remoteDebugEnabled
    case sdkUnknown(String)
}

extension DeviceAttribute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeviceAttribute] {
        return [
            .appiumVersion,
            .arn,
            .availability,
            .fleetType,
            .formFactor,
            .instanceArn,
            .instanceLabels,
            .manufacturer,
            .model,
            .osVersion,
            .platform,
            .remoteAccessEnabled,
            .remoteDebugEnabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .appiumVersion: return "APPIUM_VERSION"
        case .arn: return "ARN"
        case .availability: return "AVAILABILITY"
        case .fleetType: return "FLEET_TYPE"
        case .formFactor: return "FORM_FACTOR"
        case .instanceArn: return "INSTANCE_ARN"
        case .instanceLabels: return "INSTANCE_LABELS"
        case .manufacturer: return "MANUFACTURER"
        case .model: return "MODEL"
        case .osVersion: return "OS_VERSION"
        case .platform: return "PLATFORM"
        case .remoteAccessEnabled: return "REMOTE_ACCESS_ENABLED"
        case .remoteDebugEnabled: return "REMOTE_DEBUG_ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeviceAttribute(rawValue: rawValue) ?? DeviceAttribute.sdkUnknown(rawValue)
    }
}

public enum DeviceAvailability {
    case available
    case busy
    case highlyAvailable
    case temporaryNotAvailable
    case sdkUnknown(String)
}

extension DeviceAvailability : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeviceAvailability] {
        return [
            .available,
            .busy,
            .highlyAvailable,
            .temporaryNotAvailable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .busy: return "BUSY"
        case .highlyAvailable: return "HIGHLY_AVAILABLE"
        case .temporaryNotAvailable: return "TEMPORARY_NOT_AVAILABLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeviceAvailability(rawValue: rawValue) ?? DeviceAvailability.sdkUnknown(rawValue)
    }
}

extension DeviceFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attribute
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for devicefiltervalues0 in values {
                try valuesContainer.encode(devicefiltervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(DeviceFilterAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(RuleOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension DeviceFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceFilter(attribute: \(String(describing: attribute)), operator: \(String(describing: `operator`)), values: \(String(describing: values)))"}
}

/// <p>Represents a device filter used to select a set of devices to be included in a test
///             run. This data structure is passed in as the <code>deviceSelectionConfiguration</code>
///             parameter to <code>ScheduleRun</code>. For an example of the JSON request syntax, see
///                 <a>ScheduleRun</a>.</p>
///         <p>It is also passed in as the <code>filters</code> parameter to
///             <code>ListDevices</code>. For an example of the JSON request syntax, see <a>ListDevices</a>.</p>
public struct DeviceFilter: Equatable {
    /// <p>Specifies how Device Farm compares the filter's attribute to the value. See the attribute
    ///             descriptions.</p>
    public let `operator`: RuleOperator?
    /// <p>The aspect of a device such as platform or model used as the selection criteria in a
    ///             device filter.</p>
    ///         <p>The supported operators for each attribute are provided in the following list.</p>
    ///         <dl>
    ///             <dt>ARN</dt>
    ///             <dd>
    ///                     <p>The Amazon Resource Name (ARN) of the device (for example,
    ///                             <code>arn:aws:devicefarm:us-west-2::device:12345Example</code>).</p>
    ///                     <p>Supported operators: <code>EQUALS</code>, <code>IN</code>, <code>NOT_IN</code>
    ///                </p>
    ///                 </dd>
    ///             <dt>PLATFORM</dt>
    ///             <dd>
    ///                     <p>The device platform. Valid values are ANDROID or IOS.</p>
    ///                     <p>Supported operators: <code>EQUALS</code>
    ///                </p>
    ///                 </dd>
    ///             <dt>OS_VERSION</dt>
    ///             <dd>
    ///                     <p>The operating system version (for example, 10.3.2).</p>
    ///                     <p>Supported operators: <code>EQUALS</code>, <code>GREATER_THAN</code>,
    ///                             <code>GREATER_THAN_OR_EQUALS</code>, <code>IN</code>,
    ///                             <code>LESS_THAN</code>, <code>LESS_THAN_OR_EQUALS</code>,
    ///                             <code>NOT_IN</code>
    ///                </p>
    ///                 </dd>
    ///             <dt>MODEL</dt>
    ///             <dd>
    ///                     <p>The device model (for example, iPad 5th Gen).</p>
    ///                     <p>Supported operators: <code>CONTAINS</code>, <code>EQUALS</code>,
    ///                             <code>IN</code>, <code>NOT_IN</code>
    ///                </p>
    ///                 </dd>
    ///             <dt>AVAILABILITY</dt>
    ///             <dd>
    ///                     <p>The current availability of the device. Valid values are AVAILABLE,
    ///                         HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE.</p>
    ///                     <p>Supported operators: <code>EQUALS</code>
    ///                </p>
    ///                 </dd>
    ///             <dt>FORM_FACTOR</dt>
    ///             <dd>
    ///                     <p>The device form factor. Valid values are PHONE or TABLET.</p>
    ///                     <p>Supported operators: <code>EQUALS</code>
    ///                </p>
    ///                 </dd>
    ///             <dt>MANUFACTURER</dt>
    ///             <dd>
    ///                     <p>The device manufacturer (for example, Apple).</p>
    ///                     <p>Supported operators: <code>EQUALS</code>, <code>IN</code>,
    ///                             <code>NOT_IN</code>
    ///                </p>
    ///                 </dd>
    ///             <dt>REMOTE_ACCESS_ENABLED</dt>
    ///             <dd>
    ///                     <p>Whether the device is enabled for remote access. Valid values are TRUE or
    ///                         FALSE.</p>
    ///                     <p>Supported operators: <code>EQUALS</code>
    ///                </p>
    ///                 </dd>
    ///             <dt>REMOTE_DEBUG_ENABLED</dt>
    ///             <dd>
    ///                     <p>Whether the device is enabled for remote debugging. Valid values are TRUE or FALSE.</p>
    ///                     <p>Supported operators: <code>EQUALS</code>
    ///                </p>
    ///                     <p>Because remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no longer
    ///                             supported</a>, this filter is ignored.</p>
    ///                 </dd>
    ///             <dt>INSTANCE_ARN</dt>
    ///             <dd>
    ///                     <p>The Amazon Resource Name (ARN) of the device instance.</p>
    ///                     <p>Supported operators: <code>EQUALS</code>, <code>IN</code>,
    ///                             <code>NOT_IN</code>
    ///                </p>
    ///                 </dd>
    ///             <dt>INSTANCE_LABELS</dt>
    ///             <dd>
    ///                     <p>The label of the device instance.</p>
    ///                     <p>Supported operators: <code>CONTAINS</code>
    ///                </p>
    ///                 </dd>
    ///             <dt>FLEET_TYPE</dt>
    ///             <dd>
    ///                     <p>The fleet type. Valid values are PUBLIC or PRIVATE.</p>
    ///                     <p>Supported operators: <code>EQUALS</code>
    ///                </p>
    ///                 </dd>
    ///          </dl>
    public let attribute: DeviceFilterAttribute?
    /// <p>An array of one or more filter values used in a device filter.</p>
    ///         <p class="title">
    ///             <b>Operator Values</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                 <p>The IN and NOT_IN operators can take a values array that has more than one
    ///                     element.</p>
    ///             </li>
    ///             <li>
    ///                 <p>The other operators require an array with a single element.</p>
    ///             </li>
    ///          </ul>
    ///         <p class="title">
    ///             <b>Attribute Values</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                 <p>The PLATFORM attribute can be set to ANDROID or IOS.</p>
    ///             </li>
    ///             <li>
    ///                 <p>The AVAILABILITY attribute can be set to AVAILABLE, HIGHLY_AVAILABLE, BUSY, or
    ///                     TEMPORARY_NOT_AVAILABLE.</p>
    ///             </li>
    ///             <li>
    ///                 <p>The FORM_FACTOR attribute can be set to PHONE or TABLET.</p>
    ///             </li>
    ///             <li>
    ///                 <p>The FLEET_TYPE attribute can be set to PUBLIC or PRIVATE.</p>
    ///             </li>
    ///          </ul>
    public let values: [String]?

    public init (
        `operator`: RuleOperator? = nil,
        attribute: DeviceFilterAttribute? = nil,
        values: [String]? = nil
    )
    {
        self.`operator` = `operator`
        self.attribute = attribute
        self.values = values
    }
}

public enum DeviceFilterAttribute {
    case arn
    case availability
    case fleetType
    case formFactor
    case instanceArn
    case instanceLabels
    case manufacturer
    case model
    case osVersion
    case platform
    case remoteAccessEnabled
    case remoteDebugEnabled
    case sdkUnknown(String)
}

extension DeviceFilterAttribute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeviceFilterAttribute] {
        return [
            .arn,
            .availability,
            .fleetType,
            .formFactor,
            .instanceArn,
            .instanceLabels,
            .manufacturer,
            .model,
            .osVersion,
            .platform,
            .remoteAccessEnabled,
            .remoteDebugEnabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .arn: return "ARN"
        case .availability: return "AVAILABILITY"
        case .fleetType: return "FLEET_TYPE"
        case .formFactor: return "FORM_FACTOR"
        case .instanceArn: return "INSTANCE_ARN"
        case .instanceLabels: return "INSTANCE_LABELS"
        case .manufacturer: return "MANUFACTURER"
        case .model: return "MODEL"
        case .osVersion: return "OS_VERSION"
        case .platform: return "PLATFORM"
        case .remoteAccessEnabled: return "REMOTE_ACCESS_ENABLED"
        case .remoteDebugEnabled: return "REMOTE_DEBUG_ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeviceFilterAttribute(rawValue: rawValue) ?? DeviceFilterAttribute.sdkUnknown(rawValue)
    }
}

public enum DeviceFormFactor {
    case phone
    case tablet
    case sdkUnknown(String)
}

extension DeviceFormFactor : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeviceFormFactor] {
        return [
            .phone,
            .tablet,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .phone: return "PHONE"
        case .tablet: return "TABLET"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeviceFormFactor(rawValue: rawValue) ?? DeviceFormFactor.sdkUnknown(rawValue)
    }
}

extension DeviceInstance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case deviceArn
        case instanceProfile
        case labels
        case status
        case udid
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let instanceProfile = instanceProfile {
            try encodeContainer.encode(instanceProfile, forKey: .instanceProfile)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for instancelabels0 in labels {
                try labelsContainer.encode(instancelabels0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let udid = udid {
            try encodeContainer.encode(udid, forKey: .udid)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let deviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let labelsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .labels)
        var labelsDecoded0:[String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(InstanceStatus.self, forKey: .status)
        status = statusDecoded
        let udidDecoded = try containerValues.decodeIfPresent(String.self, forKey: .udid)
        udid = udidDecoded
        let instanceProfileDecoded = try containerValues.decodeIfPresent(InstanceProfile.self, forKey: .instanceProfile)
        instanceProfile = instanceProfileDecoded
    }
}

extension DeviceInstance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceInstance(arn: \(String(describing: arn)), deviceArn: \(String(describing: deviceArn)), instanceProfile: \(String(describing: instanceProfile)), labels: \(String(describing: labels)), status: \(String(describing: status)), udid: \(String(describing: udid)))"}
}

/// <p>Represents the device instance.</p>
public struct DeviceInstance: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the device instance.</p>
    public let arn: String?
    /// <p>The ARN of the device.</p>
    public let deviceArn: String?
    /// <p>A object that contains information about the instance profile.</p>
    public let instanceProfile: InstanceProfile?
    /// <p>An array of strings that describe the device instance.</p>
    public let labels: [String]?
    /// <p>The status of the device instance. Valid values are listed here.</p>
    public let status: InstanceStatus?
    /// <p>Unique device identifier for the device instance.</p>
    public let udid: String?

    public init (
        arn: String? = nil,
        deviceArn: String? = nil,
        instanceProfile: InstanceProfile? = nil,
        labels: [String]? = nil,
        status: InstanceStatus? = nil,
        udid: String? = nil
    )
    {
        self.arn = arn
        self.deviceArn = deviceArn
        self.instanceProfile = instanceProfile
        self.labels = labels
        self.status = status
        self.udid = udid
    }
}

extension DeviceMinutes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case metered
        case total
        case unmetered
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metered = metered {
            try encodeContainer.encode(metered, forKey: .metered)
        }
        if let total = total {
            try encodeContainer.encode(total, forKey: .total)
        }
        if let unmetered = unmetered {
            try encodeContainer.encode(unmetered, forKey: .unmetered)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .total)
        total = totalDecoded
        let meteredDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .metered)
        metered = meteredDecoded
        let unmeteredDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .unmetered)
        unmetered = unmeteredDecoded
    }
}

extension DeviceMinutes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceMinutes(metered: \(String(describing: metered)), total: \(String(describing: total)), unmetered: \(String(describing: unmetered)))"}
}

/// <p>Represents the total (metered or unmetered) minutes used by the resource to run
///             tests. Contains the sum of minutes consumed by all children.</p>
public struct DeviceMinutes: Equatable {
    /// <p>When specified, represents only the sum of metered minutes used by the resource to
    ///             run tests.</p>
    public let metered: Double?
    /// <p>When specified, represents the total minutes used by the resource to run
    ///             tests.</p>
    public let total: Double?
    /// <p>When specified, represents only the sum of unmetered minutes used by the resource
    ///             to run tests.</p>
    public let unmetered: Double?

    public init (
        metered: Double? = nil,
        total: Double? = nil,
        unmetered: Double? = nil
    )
    {
        self.metered = metered
        self.total = total
        self.unmetered = unmetered
    }
}

public enum DevicePlatform {
    case android
    case ios
    case sdkUnknown(String)
}

extension DevicePlatform : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DevicePlatform] {
        return [
            .android,
            .ios,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .android: return "ANDROID"
        case .ios: return "IOS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DevicePlatform(rawValue: rawValue) ?? DevicePlatform.sdkUnknown(rawValue)
    }
}

extension DevicePool: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case description
        case maxDevices
        case name
        case rules
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let maxDevices = maxDevices {
            try encodeContainer.encode(maxDevices, forKey: .maxDevices)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rules0 in rules {
                try rulesContainer.encode(rules0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DevicePoolType.self, forKey: .type)
        type = typeDecoded
        let rulesContainer = try containerValues.decodeIfPresent([Rule?].self, forKey: .rules)
        var rulesDecoded0:[Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let maxDevicesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxDevices)
        maxDevices = maxDevicesDecoded
    }
}

extension DevicePool: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DevicePool(arn: \(String(describing: arn)), description: \(String(describing: description)), maxDevices: \(String(describing: maxDevices)), name: \(String(describing: name)), rules: \(String(describing: rules)), type: \(String(describing: type)))"}
}

/// <p>Represents a collection of device types.</p>
public struct DevicePool: Equatable {
    /// <p>The device pool's ARN.</p>
    public let arn: String?
    /// <p>The device pool's description.</p>
    public let description: String?
    /// <p>The number of devices that Device Farm can add to your device pool. Device Farm adds devices that are
    ///             available and meet the criteria that you assign for the <code>rules</code> parameter. Depending on how many
    ///             devices meet these constraints, your device pool might contain fewer devices than the value for this
    ///             parameter.</p>
    ///         <p>By specifying the maximum number of devices, you can control the costs that you incur
    ///             by running tests.</p>
    public let maxDevices: Int?
    /// <p>The device pool's name.</p>
    public let name: String?
    /// <p>Information about the device pool's rules.</p>
    public let rules: [Rule]?
    /// <p>The device pool's type.</p>
    ///         <p>Allowed values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>CURATED: A device pool that is created and managed by AWS Device
    ///                     Farm.</p>
    ///             </li>
    ///             <li>
    ///                 <p>PRIVATE: A device pool that is created and managed by the device pool
    ///                     developer.</p>
    ///             </li>
    ///          </ul>
    public let type: DevicePoolType?

    public init (
        arn: String? = nil,
        description: String? = nil,
        maxDevices: Int? = nil,
        name: String? = nil,
        rules: [Rule]? = nil,
        type: DevicePoolType? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.maxDevices = maxDevices
        self.name = name
        self.rules = rules
        self.type = type
    }
}

extension DevicePoolCompatibilityResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case compatible
        case device
        case incompatibilityMessages
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatible = compatible {
            try encodeContainer.encode(compatible, forKey: .compatible)
        }
        if let device = device {
            try encodeContainer.encode(device, forKey: .device)
        }
        if let incompatibilityMessages = incompatibilityMessages {
            var incompatibilityMessagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .incompatibilityMessages)
            for incompatibilitymessages0 in incompatibilityMessages {
                try incompatibilityMessagesContainer.encode(incompatibilitymessages0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(Device.self, forKey: .device)
        device = deviceDecoded
        let compatibleDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .compatible)
        compatible = compatibleDecoded
        let incompatibilityMessagesContainer = try containerValues.decodeIfPresent([IncompatibilityMessage?].self, forKey: .incompatibilityMessages)
        var incompatibilityMessagesDecoded0:[IncompatibilityMessage]? = nil
        if let incompatibilityMessagesContainer = incompatibilityMessagesContainer {
            incompatibilityMessagesDecoded0 = [IncompatibilityMessage]()
            for structure0 in incompatibilityMessagesContainer {
                if let structure0 = structure0 {
                    incompatibilityMessagesDecoded0?.append(structure0)
                }
            }
        }
        incompatibilityMessages = incompatibilityMessagesDecoded0
    }
}

extension DevicePoolCompatibilityResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DevicePoolCompatibilityResult(compatible: \(String(describing: compatible)), device: \(String(describing: device)), incompatibilityMessages: \(String(describing: incompatibilityMessages)))"}
}

/// <p>Represents a device pool compatibility result.</p>
public struct DevicePoolCompatibilityResult: Equatable {
    /// <p>Whether the result was compatible with the device pool.</p>
    public let compatible: Bool?
    /// <p>The device (phone or tablet) to return information about.</p>
    public let device: Device?
    /// <p>Information about the compatibility.</p>
    public let incompatibilityMessages: [IncompatibilityMessage]?

    public init (
        compatible: Bool? = nil,
        device: Device? = nil,
        incompatibilityMessages: [IncompatibilityMessage]? = nil
    )
    {
        self.compatible = compatible
        self.device = device
        self.incompatibilityMessages = incompatibilityMessages
    }
}

public enum DevicePoolType {
    case curated
    case `private`
    case sdkUnknown(String)
}

extension DevicePoolType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DevicePoolType] {
        return [
            .curated,
            .private,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .curated: return "CURATED"
        case .private: return "PRIVATE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DevicePoolType(rawValue: rawValue) ?? DevicePoolType.sdkUnknown(rawValue)
    }
}

extension DeviceSelectionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxDevices
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for devicefilters0 in filters {
                try filtersContainer.encode(devicefilters0)
            }
        }
        if let maxDevices = maxDevices {
            try encodeContainer.encode(maxDevices, forKey: .maxDevices)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DeviceFilter?].self, forKey: .filters)
        var filtersDecoded0:[DeviceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DeviceFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxDevicesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxDevices)
        maxDevices = maxDevicesDecoded
    }
}

extension DeviceSelectionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceSelectionConfiguration(filters: \(String(describing: filters)), maxDevices: \(String(describing: maxDevices)))"}
}

/// <p>Represents the device filters used in a test run and the maximum number of devices to be included in the
///             run. It is passed in as the <code>deviceSelectionConfiguration</code> request parameter in <a>ScheduleRun</a>.</p>
public struct DeviceSelectionConfiguration: Equatable {
    /// <p>Used to dynamically select a set of devices for a test run. A filter is made up of an
    ///             attribute, an operator, and one or more values.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <b>Attribute</b>
    ///                </p>
    ///                 <p>The aspect of a device such as platform or model used as the selection
    ///                     criteria in a device filter.</p>
    ///                 <p>Allowed values include:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>ARN: The Amazon Resource Name (ARN) of the device (for example,
    ///                                 <code>arn:aws:devicefarm:us-west-2::device:12345Example</code>).</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>PLATFORM: The device platform. Valid values are ANDROID or
    ///                             IOS.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>OS_VERSION: The operating system version (for example,
    ///                             10.3.2).</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>MODEL: The device model (for example, iPad 5th Gen).</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>AVAILABILITY: The current availability of the device. Valid values
    ///                             are AVAILABLE, HIGHLY_AVAILABLE, BUSY, or
    ///                             TEMPORARY_NOT_AVAILABLE.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>FORM_FACTOR: The device form factor. Valid values are PHONE or
    ///                             TABLET.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>MANUFACTURER: The device manufacturer (for example,
    ///                             Apple).</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>REMOTE_ACCESS_ENABLED: Whether the device is enabled for remote
    ///                             access. Valid values are TRUE or FALSE.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>REMOTE_DEBUG_ENABLED: Whether the device is enabled for remote debugging. Valid values
    ///                             are TRUE or FALSE. Because remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no
    ///                                 longer supported</a>, this filter is ignored.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>INSTANCE_ARN: The Amazon Resource Name (ARN) of the device
    ///                             instance.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>INSTANCE_LABELS: The label of the device instance.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>FLEET_TYPE: The fleet type. Valid values are PUBLIC or PRIVATE.</p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>Operator</b>
    ///                </p>
    ///                 <p>The filter operator.</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>The EQUALS operator is available for every attribute except
    ///                             INSTANCE_LABELS.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>The CONTAINS operator is available for the INSTANCE_LABELS and MODEL
    ///                             attributes.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>The IN and NOT_IN operators are available for the ARN, OS_VERSION,
    ///                             MODEL, MANUFACTURER, and INSTANCE_ARN attributes.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>The LESS_THAN, GREATER_THAN, LESS_THAN_OR_EQUALS, and
    ///                             GREATER_THAN_OR_EQUALS operators are also available for the OS_VERSION
    ///                             attribute.</p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>Values</b>
    ///                </p>
    ///                 <p>An array of one or more filter values.</p>
    ///                 <p class="title">
    ///                   <b>Operator Values</b>
    ///                </p>
    ///                <ul>
    ///                   <li>
    ///                         <p>The IN and NOT_IN operators can take a values array that has more than
    ///                             one element.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>The other operators require an array with a single element.</p>
    ///                     </li>
    ///                </ul>
    ///                 <p class="title">
    ///                   <b>Attribute Values</b>
    ///                </p>
    ///                <ul>
    ///                   <li>
    ///                         <p>The PLATFORM attribute can be set to ANDROID or IOS.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>The AVAILABILITY attribute can be set to AVAILABLE, HIGHLY_AVAILABLE, BUSY, or
    ///                             TEMPORARY_NOT_AVAILABLE.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>The FORM_FACTOR attribute can be set to PHONE or TABLET.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>The FLEET_TYPE attribute can be set to PUBLIC or PRIVATE.</p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let filters: [DeviceFilter]?
    /// <p>The maximum number of devices to be included in a test run.</p>
    public let maxDevices: Int?

    public init (
        filters: [DeviceFilter]? = nil,
        maxDevices: Int? = nil
    )
    {
        self.filters = filters
        self.maxDevices = maxDevices
    }
}

extension DeviceSelectionResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case matchedDevicesCount
        case maxDevices
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for devicefilters0 in filters {
                try filtersContainer.encode(devicefilters0)
            }
        }
        if let matchedDevicesCount = matchedDevicesCount {
            try encodeContainer.encode(matchedDevicesCount, forKey: .matchedDevicesCount)
        }
        if let maxDevices = maxDevices {
            try encodeContainer.encode(maxDevices, forKey: .maxDevices)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DeviceFilter?].self, forKey: .filters)
        var filtersDecoded0:[DeviceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DeviceFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let matchedDevicesCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .matchedDevicesCount)
        matchedDevicesCount = matchedDevicesCountDecoded
        let maxDevicesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxDevices)
        maxDevices = maxDevicesDecoded
    }
}

extension DeviceSelectionResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceSelectionResult(filters: \(String(describing: filters)), matchedDevicesCount: \(String(describing: matchedDevicesCount)), maxDevices: \(String(describing: maxDevices)))"}
}

/// <p>Contains the run results requested by the device selection configuration and how many devices were
///             returned. For an example of the JSON response syntax, see <a>ScheduleRun</a>.</p>
public struct DeviceSelectionResult: Equatable {
    /// <p>The filters in a device selection result.</p>
    public let filters: [DeviceFilter]?
    /// <p>The number of devices that matched the device filter selection criteria.</p>
    public let matchedDevicesCount: Int?
    /// <p>The maximum number of devices to be selected by a device filter and included in a test
    ///             run.</p>
    public let maxDevices: Int?

    public init (
        filters: [DeviceFilter]? = nil,
        matchedDevicesCount: Int? = nil,
        maxDevices: Int? = nil
    )
    {
        self.filters = filters
        self.matchedDevicesCount = matchedDevicesCount
        self.maxDevices = maxDevices
    }
}

extension ExecutionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountsCleanup
        case appPackagesCleanup
        case jobTimeoutMinutes
        case skipAppResign
        case videoCapture
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountsCleanup = accountsCleanup {
            try encodeContainer.encode(accountsCleanup, forKey: .accountsCleanup)
        }
        if let appPackagesCleanup = appPackagesCleanup {
            try encodeContainer.encode(appPackagesCleanup, forKey: .appPackagesCleanup)
        }
        if let jobTimeoutMinutes = jobTimeoutMinutes {
            try encodeContainer.encode(jobTimeoutMinutes, forKey: .jobTimeoutMinutes)
        }
        if let skipAppResign = skipAppResign {
            try encodeContainer.encode(skipAppResign, forKey: .skipAppResign)
        }
        if let videoCapture = videoCapture {
            try encodeContainer.encode(videoCapture, forKey: .videoCapture)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .jobTimeoutMinutes)
        jobTimeoutMinutes = jobTimeoutMinutesDecoded
        let accountsCleanupDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .accountsCleanup)
        accountsCleanup = accountsCleanupDecoded
        let appPackagesCleanupDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .appPackagesCleanup)
        appPackagesCleanup = appPackagesCleanupDecoded
        let videoCaptureDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .videoCapture)
        videoCapture = videoCaptureDecoded
        let skipAppResignDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .skipAppResign)
        skipAppResign = skipAppResignDecoded
    }
}

extension ExecutionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecutionConfiguration(accountsCleanup: \(String(describing: accountsCleanup)), appPackagesCleanup: \(String(describing: appPackagesCleanup)), jobTimeoutMinutes: \(String(describing: jobTimeoutMinutes)), skipAppResign: \(String(describing: skipAppResign)), videoCapture: \(String(describing: videoCapture)))"}
}

/// <p>Represents configuration information about a test run, such as the execution
///             timeout (in minutes).</p>
public struct ExecutionConfiguration: Equatable {
    /// <p>True if account cleanup is enabled at the beginning of the test. Otherwise, false.</p>
    public let accountsCleanup: Bool?
    /// <p>True if app package cleanup is enabled at the beginning of the test. Otherwise, false.</p>
    public let appPackagesCleanup: Bool?
    /// <p>The number of minutes a test run executes before it times out.</p>
    public let jobTimeoutMinutes: Int?
    /// <p>When set to <code>true</code>, for private devices, Device Farm does not sign your app again. For public
    ///             devices, Device Farm always signs your apps again.</p>
    ///         <p>For more information about how Device Farm re-signs your apps, see <a href="https://aws.amazon.com/device-farm/faq/">Do you modify my app?</a> in the <i>AWS Device
    ///                 Farm FAQs</i>.</p>
    public let skipAppResign: Bool?
    /// <p>Set to true to enable video capture. Otherwise, set to false. The default is true.</p>
    public let videoCapture: Bool?

    public init (
        accountsCleanup: Bool? = nil,
        appPackagesCleanup: Bool? = nil,
        jobTimeoutMinutes: Int? = nil,
        skipAppResign: Bool? = nil,
        videoCapture: Bool? = nil
    )
    {
        self.accountsCleanup = accountsCleanup
        self.appPackagesCleanup = appPackagesCleanup
        self.jobTimeoutMinutes = jobTimeoutMinutes
        self.skipAppResign = skipAppResign
        self.videoCapture = videoCapture
    }
}

public enum ExecutionResult {
    case errored
    case failed
    case passed
    case pending
    case skipped
    case stopped
    case warned
    case sdkUnknown(String)
}

extension ExecutionResult : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExecutionResult] {
        return [
            .errored,
            .failed,
            .passed,
            .pending,
            .skipped,
            .stopped,
            .warned,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .errored: return "ERRORED"
        case .failed: return "FAILED"
        case .passed: return "PASSED"
        case .pending: return "PENDING"
        case .skipped: return "SKIPPED"
        case .stopped: return "STOPPED"
        case .warned: return "WARNED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExecutionResult(rawValue: rawValue) ?? ExecutionResult.sdkUnknown(rawValue)
    }
}

public enum ExecutionResultCode {
    case parsingFailed
    case vpcEndpointSetupFailed
    case sdkUnknown(String)
}

extension ExecutionResultCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExecutionResultCode] {
        return [
            .parsingFailed,
            .vpcEndpointSetupFailed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .parsingFailed: return "PARSING_FAILED"
        case .vpcEndpointSetupFailed: return "VPC_ENDPOINT_SETUP_FAILED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExecutionResultCode(rawValue: rawValue) ?? ExecutionResultCode.sdkUnknown(rawValue)
    }
}

public enum ExecutionStatus {
    case completed
    case pending
    case pendingConcurrnecy
    case pendingDevice
    case preparing
    case processing
    case running
    case scheduling
    case stopping
    case sdkUnknown(String)
}

extension ExecutionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExecutionStatus] {
        return [
            .completed,
            .pending,
            .pendingConcurrnecy,
            .pendingDevice,
            .preparing,
            .processing,
            .running,
            .scheduling,
            .stopping,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .pending: return "PENDING"
        case .pendingConcurrnecy: return "PENDING_CONCURRENCY"
        case .pendingDevice: return "PENDING_DEVICE"
        case .preparing: return "PREPARING"
        case .processing: return "PROCESSING"
        case .running: return "RUNNING"
        case .scheduling: return "SCHEDULING"
        case .stopping: return "STOPPING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExecutionStatus(rawValue: rawValue) ?? ExecutionStatus.sdkUnknown(rawValue)
    }
}

extension GetAccountSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccountSettingsInput()"}
}

extension GetAccountSettingsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAccountSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "GetAccountSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountSettingsInput>
    public typealias MOutput = OperationOutput<GetAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountSettingsOutputError>
}

public struct GetAccountSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAccountSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountSettingsInput>
    public typealias MOutput = OperationOutput<GetAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountSettingsOutputError>
}

/// <p>Represents the request sent to retrieve the account settings.</p>
public struct GetAccountSettingsInput: Equatable {

    public init() {}
}

struct GetAccountSettingsInputBody: Equatable {
}

extension GetAccountSettingsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAccountSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccountSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccountSettingsOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccountSettingsOutputResponse(accountSettings: \(String(describing: accountSettings)))"}
}

extension GetAccountSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAccountSettingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountSettings = output.accountSettings
        } else {
            self.accountSettings = nil
        }
    }
}

/// <p>Represents the account settings return values from the
///                 <code>GetAccountSettings</code> request.</p>
public struct GetAccountSettingsOutputResponse: Equatable {
    /// <p>The account settings.</p>
    public let accountSettings: AccountSettings?

    public init (
        accountSettings: AccountSettings? = nil
    )
    {
        self.accountSettings = accountSettings
    }
}

struct GetAccountSettingsOutputResponseBody: Equatable {
    public let accountSettings: AccountSettings?
}

extension GetAccountSettingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountSettings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountSettingsDecoded = try containerValues.decodeIfPresent(AccountSettings.self, forKey: .accountSettings)
        accountSettings = accountSettingsDecoded
    }
}

public struct GetDeviceInputBodyMiddleware: Middleware {
    public let id: String = "GetDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeviceInput>
    public typealias MOutput = OperationOutput<GetDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeviceOutputError>
}

extension GetDeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeviceInput(arn: \(String(describing: arn)))"}
}

extension GetDeviceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetDeviceInputHeadersMiddleware: Middleware {
    public let id: String = "GetDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeviceInput>
    public typealias MOutput = OperationOutput<GetDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeviceOutputError>
}

public struct GetDeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeviceInput>
    public typealias MOutput = OperationOutput<GetDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeviceOutputError>
}

/// <p>Represents a request to the get device request.</p>
public struct GetDeviceInput: Equatable {
    /// <p>The device type's ARN.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetDeviceInputBody: Equatable {
    public let arn: String?
}

extension GetDeviceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct GetDeviceInstanceInputBodyMiddleware: Middleware {
    public let id: String = "GetDeviceInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeviceInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeviceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeviceInstanceInput>
    public typealias MOutput = OperationOutput<GetDeviceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeviceInstanceOutputError>
}

extension GetDeviceInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeviceInstanceInput(arn: \(String(describing: arn)))"}
}

extension GetDeviceInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetDeviceInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "GetDeviceInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeviceInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeviceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeviceInstanceInput>
    public typealias MOutput = OperationOutput<GetDeviceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeviceInstanceOutputError>
}

public struct GetDeviceInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDeviceInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeviceInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeviceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeviceInstanceInput>
    public typealias MOutput = OperationOutput<GetDeviceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeviceInstanceOutputError>
}

public struct GetDeviceInstanceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the instance you're requesting information
    ///             about.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetDeviceInstanceInputBody: Equatable {
    public let arn: String?
}

extension GetDeviceInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetDeviceInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeviceInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeviceInstanceOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeviceInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeviceInstanceOutputResponse(deviceInstance: \(String(describing: deviceInstance)))"}
}

extension GetDeviceInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDeviceInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deviceInstance = output.deviceInstance
        } else {
            self.deviceInstance = nil
        }
    }
}

public struct GetDeviceInstanceOutputResponse: Equatable {
    /// <p>An object that contains information about your device instance.</p>
    public let deviceInstance: DeviceInstance?

    public init (
        deviceInstance: DeviceInstance? = nil
    )
    {
        self.deviceInstance = deviceInstance
    }
}

struct GetDeviceInstanceOutputResponseBody: Equatable {
    public let deviceInstance: DeviceInstance?
}

extension GetDeviceInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceInstance
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceInstanceDecoded = try containerValues.decodeIfPresent(DeviceInstance.self, forKey: .deviceInstance)
        deviceInstance = deviceInstanceDecoded
    }
}

extension GetDeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeviceOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeviceOutputResponse(device: \(String(describing: device)))"}
}

extension GetDeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDeviceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.device = output.device
        } else {
            self.device = nil
        }
    }
}

/// <p>Represents the result of a get device request.</p>
public struct GetDeviceOutputResponse: Equatable {
    /// <p>An object that contains information about the requested device.</p>
    public let device: Device?

    public init (
        device: Device? = nil
    )
    {
        self.device = device
    }
}

struct GetDeviceOutputResponseBody: Equatable {
    public let device: Device?
}

extension GetDeviceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case device
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(Device.self, forKey: .device)
        device = deviceDecoded
    }
}

public struct GetDevicePoolCompatibilityInputBodyMiddleware: Middleware {
    public let id: String = "GetDevicePoolCompatibilityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDevicePoolCompatibilityInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDevicePoolCompatibilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDevicePoolCompatibilityInput>
    public typealias MOutput = OperationOutput<GetDevicePoolCompatibilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDevicePoolCompatibilityOutputError>
}

extension GetDevicePoolCompatibilityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDevicePoolCompatibilityInput(appArn: \(String(describing: appArn)), configuration: \(String(describing: configuration)), devicePoolArn: \(String(describing: devicePoolArn)), test: \(String(describing: test)), testType: \(String(describing: testType)))"}
}

extension GetDevicePoolCompatibilityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appArn
        case configuration
        case devicePoolArn
        case test
        case testType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let devicePoolArn = devicePoolArn {
            try encodeContainer.encode(devicePoolArn, forKey: .devicePoolArn)
        }
        if let test = test {
            try encodeContainer.encode(test, forKey: .test)
        }
        if let testType = testType {
            try encodeContainer.encode(testType.rawValue, forKey: .testType)
        }
    }
}

public struct GetDevicePoolCompatibilityInputHeadersMiddleware: Middleware {
    public let id: String = "GetDevicePoolCompatibilityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDevicePoolCompatibilityInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDevicePoolCompatibilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDevicePoolCompatibilityInput>
    public typealias MOutput = OperationOutput<GetDevicePoolCompatibilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDevicePoolCompatibilityOutputError>
}

public struct GetDevicePoolCompatibilityInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDevicePoolCompatibilityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDevicePoolCompatibilityInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDevicePoolCompatibilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDevicePoolCompatibilityInput>
    public typealias MOutput = OperationOutput<GetDevicePoolCompatibilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDevicePoolCompatibilityOutputError>
}

/// <p>Represents a request to the get device pool compatibility operation.</p>
public struct GetDevicePoolCompatibilityInput: Equatable {
    /// <p>The ARN of the app that is associated with the specified device pool.</p>
    public let appArn: String?
    /// <p>An object that contains information about the settings for a run.</p>
    public let configuration: ScheduleRunConfiguration?
    /// <p>The device pool's ARN.</p>
    public let devicePoolArn: String?
    /// <p>Information about the uploaded test to be run against the device pool.</p>
    public let test: ScheduleRunTest?
    /// <p>The test type for the specified device pool.</p>
    ///         <p>Allowed values include the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>BUILTIN_FUZZ.</p>
    ///             </li>
    ///             <li>
    ///                 <p>BUILTIN_EXPLORER. For Android, an app explorer that traverses an Android app, interacting with
    ///                     it and capturing screenshots at the same time.</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_JUNIT.</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_TESTNG.</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_PYTHON.</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_NODE.</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_RUBY.</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_JAVA_JUNIT.</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_JAVA_TESTNG.</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_PYTHON.</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_NODE.</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_RUBY.</p>
    ///             </li>
    ///             <li>
    ///                 <p>CALABASH.</p>
    ///             </li>
    ///             <li>
    ///                 <p>INSTRUMENTATION.</p>
    ///             </li>
    ///             <li>
    ///                 <p>UIAUTOMATION.</p>
    ///             </li>
    ///             <li>
    ///                 <p>UIAUTOMATOR.</p>
    ///             </li>
    ///             <li>
    ///                 <p>XCTEST.</p>
    ///             </li>
    ///             <li>
    ///                 <p>XCTEST_UI.</p>
    ///             </li>
    ///          </ul>
    public let testType: TestType?

    public init (
        appArn: String? = nil,
        configuration: ScheduleRunConfiguration? = nil,
        devicePoolArn: String? = nil,
        test: ScheduleRunTest? = nil,
        testType: TestType? = nil
    )
    {
        self.appArn = appArn
        self.configuration = configuration
        self.devicePoolArn = devicePoolArn
        self.test = test
        self.testType = testType
    }
}

struct GetDevicePoolCompatibilityInputBody: Equatable {
    public let devicePoolArn: String?
    public let appArn: String?
    public let testType: TestType?
    public let test: ScheduleRunTest?
    public let configuration: ScheduleRunConfiguration?
}

extension GetDevicePoolCompatibilityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appArn
        case configuration
        case devicePoolArn
        case test
        case testType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicePoolArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .devicePoolArn)
        devicePoolArn = devicePoolArnDecoded
        let appArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appArn)
        appArn = appArnDecoded
        let testTypeDecoded = try containerValues.decodeIfPresent(TestType.self, forKey: .testType)
        testType = testTypeDecoded
        let testDecoded = try containerValues.decodeIfPresent(ScheduleRunTest.self, forKey: .test)
        test = testDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(ScheduleRunConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension GetDevicePoolCompatibilityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDevicePoolCompatibilityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDevicePoolCompatibilityOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDevicePoolCompatibilityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDevicePoolCompatibilityOutputResponse(compatibleDevices: \(String(describing: compatibleDevices)), incompatibleDevices: \(String(describing: incompatibleDevices)))"}
}

extension GetDevicePoolCompatibilityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDevicePoolCompatibilityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.compatibleDevices = output.compatibleDevices
            self.incompatibleDevices = output.incompatibleDevices
        } else {
            self.compatibleDevices = nil
            self.incompatibleDevices = nil
        }
    }
}

/// <p>Represents the result of describe device pool compatibility request.</p>
public struct GetDevicePoolCompatibilityOutputResponse: Equatable {
    /// <p>Information about compatible devices.</p>
    public let compatibleDevices: [DevicePoolCompatibilityResult]?
    /// <p>Information about incompatible devices.</p>
    public let incompatibleDevices: [DevicePoolCompatibilityResult]?

    public init (
        compatibleDevices: [DevicePoolCompatibilityResult]? = nil,
        incompatibleDevices: [DevicePoolCompatibilityResult]? = nil
    )
    {
        self.compatibleDevices = compatibleDevices
        self.incompatibleDevices = incompatibleDevices
    }
}

struct GetDevicePoolCompatibilityOutputResponseBody: Equatable {
    public let compatibleDevices: [DevicePoolCompatibilityResult]?
    public let incompatibleDevices: [DevicePoolCompatibilityResult]?
}

extension GetDevicePoolCompatibilityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case compatibleDevices
        case incompatibleDevices
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compatibleDevicesContainer = try containerValues.decodeIfPresent([DevicePoolCompatibilityResult?].self, forKey: .compatibleDevices)
        var compatibleDevicesDecoded0:[DevicePoolCompatibilityResult]? = nil
        if let compatibleDevicesContainer = compatibleDevicesContainer {
            compatibleDevicesDecoded0 = [DevicePoolCompatibilityResult]()
            for structure0 in compatibleDevicesContainer {
                if let structure0 = structure0 {
                    compatibleDevicesDecoded0?.append(structure0)
                }
            }
        }
        compatibleDevices = compatibleDevicesDecoded0
        let incompatibleDevicesContainer = try containerValues.decodeIfPresent([DevicePoolCompatibilityResult?].self, forKey: .incompatibleDevices)
        var incompatibleDevicesDecoded0:[DevicePoolCompatibilityResult]? = nil
        if let incompatibleDevicesContainer = incompatibleDevicesContainer {
            incompatibleDevicesDecoded0 = [DevicePoolCompatibilityResult]()
            for structure0 in incompatibleDevicesContainer {
                if let structure0 = structure0 {
                    incompatibleDevicesDecoded0?.append(structure0)
                }
            }
        }
        incompatibleDevices = incompatibleDevicesDecoded0
    }
}

public struct GetDevicePoolInputBodyMiddleware: Middleware {
    public let id: String = "GetDevicePoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDevicePoolInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDevicePoolInput>
    public typealias MOutput = OperationOutput<GetDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDevicePoolOutputError>
}

extension GetDevicePoolInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDevicePoolInput(arn: \(String(describing: arn)))"}
}

extension GetDevicePoolInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetDevicePoolInputHeadersMiddleware: Middleware {
    public let id: String = "GetDevicePoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDevicePoolInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDevicePoolInput>
    public typealias MOutput = OperationOutput<GetDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDevicePoolOutputError>
}

public struct GetDevicePoolInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDevicePoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDevicePoolInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDevicePoolInput>
    public typealias MOutput = OperationOutput<GetDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDevicePoolOutputError>
}

/// <p>Represents a request to the get device pool operation.</p>
public struct GetDevicePoolInput: Equatable {
    /// <p>The device pool's ARN.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetDevicePoolInputBody: Equatable {
    public let arn: String?
}

extension GetDevicePoolInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetDevicePoolOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDevicePoolOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDevicePoolOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDevicePoolOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDevicePoolOutputResponse(devicePool: \(String(describing: devicePool)))"}
}

extension GetDevicePoolOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDevicePoolOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.devicePool = output.devicePool
        } else {
            self.devicePool = nil
        }
    }
}

/// <p>Represents the result of a get device pool request.</p>
public struct GetDevicePoolOutputResponse: Equatable {
    /// <p>An object that contains information about the requested device pool.</p>
    public let devicePool: DevicePool?

    public init (
        devicePool: DevicePool? = nil
    )
    {
        self.devicePool = devicePool
    }
}

struct GetDevicePoolOutputResponseBody: Equatable {
    public let devicePool: DevicePool?
}

extension GetDevicePoolOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case devicePool
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicePoolDecoded = try containerValues.decodeIfPresent(DevicePool.self, forKey: .devicePool)
        devicePool = devicePoolDecoded
    }
}

public struct GetInstanceProfileInputBodyMiddleware: Middleware {
    public let id: String = "GetInstanceProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInstanceProfileInput>
    public typealias MOutput = OperationOutput<GetInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInstanceProfileOutputError>
}

extension GetInstanceProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInstanceProfileInput(arn: \(String(describing: arn)))"}
}

extension GetInstanceProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetInstanceProfileInputHeadersMiddleware: Middleware {
    public let id: String = "GetInstanceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInstanceProfileInput>
    public typealias MOutput = OperationOutput<GetInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInstanceProfileOutputError>
}

public struct GetInstanceProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "GetInstanceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInstanceProfileInput>
    public typealias MOutput = OperationOutput<GetInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInstanceProfileOutputError>
}

public struct GetInstanceProfileInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of an instance profile.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetInstanceProfileInputBody: Equatable {
    public let arn: String?
}

extension GetInstanceProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetInstanceProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInstanceProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInstanceProfileOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInstanceProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInstanceProfileOutputResponse(instanceProfile: \(String(describing: instanceProfile)))"}
}

extension GetInstanceProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetInstanceProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instanceProfile = output.instanceProfile
        } else {
            self.instanceProfile = nil
        }
    }
}

public struct GetInstanceProfileOutputResponse: Equatable {
    /// <p>An object that contains information about an instance profile.</p>
    public let instanceProfile: InstanceProfile?

    public init (
        instanceProfile: InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

struct GetInstanceProfileOutputResponseBody: Equatable {
    public let instanceProfile: InstanceProfile?
}

extension GetInstanceProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceProfile
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileDecoded = try containerValues.decodeIfPresent(InstanceProfile.self, forKey: .instanceProfile)
        instanceProfile = instanceProfileDecoded
    }
}

public struct GetJobInputBodyMiddleware: Middleware {
    public let id: String = "GetJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobInput>
    public typealias MOutput = OperationOutput<GetJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobOutputError>
}

extension GetJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobInput(arn: \(String(describing: arn)))"}
}

extension GetJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetJobInputHeadersMiddleware: Middleware {
    public let id: String = "GetJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobInput>
    public typealias MOutput = OperationOutput<GetJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobOutputError>
}

public struct GetJobInputQueryItemMiddleware: Middleware {
    public let id: String = "GetJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobInput>
    public typealias MOutput = OperationOutput<GetJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobOutputError>
}

/// <p>Represents a request to the get job operation.</p>
public struct GetJobInput: Equatable {
    /// <p>The job's ARN.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetJobInputBody: Equatable {
    public let arn: String?
}

extension GetJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJobOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobOutputResponse(job: \(String(describing: job)))"}
}

extension GetJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

/// <p>Represents the result of a get job request.</p>
public struct GetJobOutputResponse: Equatable {
    /// <p>An object that contains information about the requested job.</p>
    public let job: Job?

    public init (
        job: Job? = nil
    )
    {
        self.job = job
    }
}

struct GetJobOutputResponseBody: Equatable {
    public let job: Job?
}

extension GetJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case job
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Job.self, forKey: .job)
        job = jobDecoded
    }
}

public struct GetNetworkProfileInputBodyMiddleware: Middleware {
    public let id: String = "GetNetworkProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetNetworkProfileInput>
    public typealias MOutput = OperationOutput<GetNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetNetworkProfileOutputError>
}

extension GetNetworkProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetNetworkProfileInput(arn: \(String(describing: arn)))"}
}

extension GetNetworkProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetNetworkProfileInputHeadersMiddleware: Middleware {
    public let id: String = "GetNetworkProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetNetworkProfileInput>
    public typealias MOutput = OperationOutput<GetNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetNetworkProfileOutputError>
}

public struct GetNetworkProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "GetNetworkProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetNetworkProfileInput>
    public typealias MOutput = OperationOutput<GetNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetNetworkProfileOutputError>
}

public struct GetNetworkProfileInput: Equatable {
    /// <p>The ARN of the network profile to return information about.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetNetworkProfileInputBody: Equatable {
    public let arn: String?
}

extension GetNetworkProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetNetworkProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNetworkProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetNetworkProfileOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNetworkProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetNetworkProfileOutputResponse(networkProfile: \(String(describing: networkProfile)))"}
}

extension GetNetworkProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetNetworkProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.networkProfile = output.networkProfile
        } else {
            self.networkProfile = nil
        }
    }
}

public struct GetNetworkProfileOutputResponse: Equatable {
    /// <p>The network profile.</p>
    public let networkProfile: NetworkProfile?

    public init (
        networkProfile: NetworkProfile? = nil
    )
    {
        self.networkProfile = networkProfile
    }
}

struct GetNetworkProfileOutputResponseBody: Equatable {
    public let networkProfile: NetworkProfile?
}

extension GetNetworkProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case networkProfile
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileDecoded = try containerValues.decodeIfPresent(NetworkProfile.self, forKey: .networkProfile)
        networkProfile = networkProfileDecoded
    }
}

public struct GetOfferingStatusInputBodyMiddleware: Middleware {
    public let id: String = "GetOfferingStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOfferingStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOfferingStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOfferingStatusInput>
    public typealias MOutput = OperationOutput<GetOfferingStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOfferingStatusOutputError>
}

extension GetOfferingStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOfferingStatusInput(nextToken: \(String(describing: nextToken)))"}
}

extension GetOfferingStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetOfferingStatusInputHeadersMiddleware: Middleware {
    public let id: String = "GetOfferingStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOfferingStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOfferingStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOfferingStatusInput>
    public typealias MOutput = OperationOutput<GetOfferingStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOfferingStatusOutputError>
}

public struct GetOfferingStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "GetOfferingStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOfferingStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOfferingStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOfferingStatusInput>
    public typealias MOutput = OperationOutput<GetOfferingStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOfferingStatusOutputError>
}

/// <p>Represents the request to retrieve the offering status for the specified customer
///             or account.</p>
public struct GetOfferingStatusInput: Equatable {
    /// <p>An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.</p>
    public let nextToken: String?

    public init (
        nextToken: String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct GetOfferingStatusInputBody: Equatable {
    public let nextToken: String?
}

extension GetOfferingStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetOfferingStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOfferingStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotEligibleException" : self = .notEligibleException(try NotEligibleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOfferingStatusOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notEligibleException(NotEligibleException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOfferingStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOfferingStatusOutputResponse(current: \(String(describing: current)), nextPeriod: \(String(describing: nextPeriod)), nextToken: \(String(describing: nextToken)))"}
}

extension GetOfferingStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetOfferingStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.current = output.current
            self.nextPeriod = output.nextPeriod
            self.nextToken = output.nextToken
        } else {
            self.current = nil
            self.nextPeriod = nil
            self.nextToken = nil
        }
    }
}

/// <p>Returns the status result for a device offering.</p>
public struct GetOfferingStatusOutputResponse: Equatable {
    /// <p>When specified, gets the offering status for the current period.</p>
    public let current: [String:OfferingStatus]?
    /// <p>When specified, gets the offering status for the next period.</p>
    public let nextPeriod: [String:OfferingStatus]?
    /// <p>An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.</p>
    public let nextToken: String?

    public init (
        current: [String:OfferingStatus]? = nil,
        nextPeriod: [String:OfferingStatus]? = nil,
        nextToken: String? = nil
    )
    {
        self.current = current
        self.nextPeriod = nextPeriod
        self.nextToken = nextToken
    }
}

struct GetOfferingStatusOutputResponseBody: Equatable {
    public let current: [String:OfferingStatus]?
    public let nextPeriod: [String:OfferingStatus]?
    public let nextToken: String?
}

extension GetOfferingStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case current
        case nextPeriod
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentContainer = try containerValues.decodeIfPresent([String: OfferingStatus?].self, forKey: .current)
        var currentDecoded0: [String:OfferingStatus]? = nil
        if let currentContainer = currentContainer {
            currentDecoded0 = [String:OfferingStatus]()
            for (key0, offeringstatus0) in currentContainer {
                if let offeringstatus0 = offeringstatus0 {
                    currentDecoded0?[key0] = offeringstatus0
                }
            }
        }
        current = currentDecoded0
        let nextPeriodContainer = try containerValues.decodeIfPresent([String: OfferingStatus?].self, forKey: .nextPeriod)
        var nextPeriodDecoded0: [String:OfferingStatus]? = nil
        if let nextPeriodContainer = nextPeriodContainer {
            nextPeriodDecoded0 = [String:OfferingStatus]()
            for (key0, offeringstatus0) in nextPeriodContainer {
                if let offeringstatus0 = offeringstatus0 {
                    nextPeriodDecoded0?[key0] = offeringstatus0
                }
            }
        }
        nextPeriod = nextPeriodDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetProjectInputBodyMiddleware: Middleware {
    public let id: String = "GetProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProjectInput>
    public typealias MOutput = OperationOutput<GetProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProjectOutputError>
}

extension GetProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetProjectInput(arn: \(String(describing: arn)))"}
}

extension GetProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetProjectInputHeadersMiddleware: Middleware {
    public let id: String = "GetProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProjectInput>
    public typealias MOutput = OperationOutput<GetProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProjectOutputError>
}

public struct GetProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "GetProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProjectInput>
    public typealias MOutput = OperationOutput<GetProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProjectOutputError>
}

/// <p>Represents a request to the get project operation.</p>
public struct GetProjectInput: Equatable {
    /// <p>The project's ARN.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetProjectInputBody: Equatable {
    public let arn: String?
}

extension GetProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetProjectOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetProjectOutputResponse(project: \(String(describing: project)))"}
}

extension GetProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.project = output.project
        } else {
            self.project = nil
        }
    }
}

/// <p>Represents the result of a get project request.</p>
public struct GetProjectOutputResponse: Equatable {
    /// <p>The project to get information about.</p>
    public let project: Project?

    public init (
        project: Project? = nil
    )
    {
        self.project = project
    }
}

struct GetProjectOutputResponseBody: Equatable {
    public let project: Project?
}

extension GetProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case project
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(Project.self, forKey: .project)
        project = projectDecoded
    }
}

public struct GetRemoteAccessSessionInputBodyMiddleware: Middleware {
    public let id: String = "GetRemoteAccessSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRemoteAccessSessionInput>
    public typealias MOutput = OperationOutput<GetRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRemoteAccessSessionOutputError>
}

extension GetRemoteAccessSessionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRemoteAccessSessionInput(arn: \(String(describing: arn)))"}
}

extension GetRemoteAccessSessionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetRemoteAccessSessionInputHeadersMiddleware: Middleware {
    public let id: String = "GetRemoteAccessSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRemoteAccessSessionInput>
    public typealias MOutput = OperationOutput<GetRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRemoteAccessSessionOutputError>
}

public struct GetRemoteAccessSessionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRemoteAccessSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRemoteAccessSessionInput>
    public typealias MOutput = OperationOutput<GetRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRemoteAccessSessionOutputError>
}

/// <p>Represents the request to get information about the specified remote access
///             session.</p>
public struct GetRemoteAccessSessionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the remote access session about which you want to
    ///             get session information.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetRemoteAccessSessionInputBody: Equatable {
    public let arn: String?
}

extension GetRemoteAccessSessionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetRemoteAccessSessionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRemoteAccessSessionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRemoteAccessSessionOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRemoteAccessSessionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRemoteAccessSessionOutputResponse(remoteAccessSession: \(String(describing: remoteAccessSession)))"}
}

extension GetRemoteAccessSessionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRemoteAccessSessionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.remoteAccessSession = output.remoteAccessSession
        } else {
            self.remoteAccessSession = nil
        }
    }
}

/// <p>Represents the response from the server that lists detailed information about the
///             remote access session.</p>
public struct GetRemoteAccessSessionOutputResponse: Equatable {
    /// <p>A container that lists detailed information about the remote access
    ///             session.</p>
    public let remoteAccessSession: RemoteAccessSession?

    public init (
        remoteAccessSession: RemoteAccessSession? = nil
    )
    {
        self.remoteAccessSession = remoteAccessSession
    }
}

struct GetRemoteAccessSessionOutputResponseBody: Equatable {
    public let remoteAccessSession: RemoteAccessSession?
}

extension GetRemoteAccessSessionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case remoteAccessSession
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remoteAccessSessionDecoded = try containerValues.decodeIfPresent(RemoteAccessSession.self, forKey: .remoteAccessSession)
        remoteAccessSession = remoteAccessSessionDecoded
    }
}

public struct GetRunInputBodyMiddleware: Middleware {
    public let id: String = "GetRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRunInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRunInput>
    public typealias MOutput = OperationOutput<GetRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRunOutputError>
}

extension GetRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRunInput(arn: \(String(describing: arn)))"}
}

extension GetRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetRunInputHeadersMiddleware: Middleware {
    public let id: String = "GetRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRunInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRunInput>
    public typealias MOutput = OperationOutput<GetRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRunOutputError>
}

public struct GetRunInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRunInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRunInput>
    public typealias MOutput = OperationOutput<GetRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRunOutputError>
}

/// <p>Represents a request to the get run operation.</p>
public struct GetRunInput: Equatable {
    /// <p>The run's ARN.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetRunInputBody: Equatable {
    public let arn: String?
}

extension GetRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRunOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRunOutputResponse(run: \(String(describing: run)))"}
}

extension GetRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.run = output.run
        } else {
            self.run = nil
        }
    }
}

/// <p>Represents the result of a get run request.</p>
public struct GetRunOutputResponse: Equatable {
    /// <p>The run to get results from.</p>
    public let run: Run?

    public init (
        run: Run? = nil
    )
    {
        self.run = run
    }
}

struct GetRunOutputResponseBody: Equatable {
    public let run: Run?
}

extension GetRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case run
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runDecoded = try containerValues.decodeIfPresent(Run.self, forKey: .run)
        run = runDecoded
    }
}

public struct GetSuiteInputBodyMiddleware: Middleware {
    public let id: String = "GetSuiteInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSuiteInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSuiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSuiteInput>
    public typealias MOutput = OperationOutput<GetSuiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSuiteOutputError>
}

extension GetSuiteInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSuiteInput(arn: \(String(describing: arn)))"}
}

extension GetSuiteInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetSuiteInputHeadersMiddleware: Middleware {
    public let id: String = "GetSuiteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSuiteInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSuiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSuiteInput>
    public typealias MOutput = OperationOutput<GetSuiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSuiteOutputError>
}

public struct GetSuiteInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSuiteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSuiteInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSuiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSuiteInput>
    public typealias MOutput = OperationOutput<GetSuiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSuiteOutputError>
}

/// <p>Represents a request to the get suite operation.</p>
public struct GetSuiteInput: Equatable {
    /// <p>The suite's ARN.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetSuiteInputBody: Equatable {
    public let arn: String?
}

extension GetSuiteInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetSuiteOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSuiteOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSuiteOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSuiteOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSuiteOutputResponse(suite: \(String(describing: suite)))"}
}

extension GetSuiteOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSuiteOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.suite = output.suite
        } else {
            self.suite = nil
        }
    }
}

/// <p>Represents the result of a get suite request.</p>
public struct GetSuiteOutputResponse: Equatable {
    /// <p>A collection of one or more tests.</p>
    public let suite: Suite?

    public init (
        suite: Suite? = nil
    )
    {
        self.suite = suite
    }
}

struct GetSuiteOutputResponseBody: Equatable {
    public let suite: Suite?
}

extension GetSuiteOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case suite
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDecoded = try containerValues.decodeIfPresent(Suite.self, forKey: .suite)
        suite = suiteDecoded
    }
}

public struct GetTestGridProjectInputBodyMiddleware: Middleware {
    public let id: String = "GetTestGridProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTestGridProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTestGridProjectInput>
    public typealias MOutput = OperationOutput<GetTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTestGridProjectOutputError>
}

extension GetTestGridProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTestGridProjectInput(projectArn: \(String(describing: projectArn)))"}
}

extension GetTestGridProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case projectArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
    }
}

public struct GetTestGridProjectInputHeadersMiddleware: Middleware {
    public let id: String = "GetTestGridProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTestGridProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTestGridProjectInput>
    public typealias MOutput = OperationOutput<GetTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTestGridProjectOutputError>
}

public struct GetTestGridProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTestGridProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTestGridProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTestGridProjectInput>
    public typealias MOutput = OperationOutput<GetTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTestGridProjectOutputError>
}

public struct GetTestGridProjectInput: Equatable {
    /// <p>The ARN of the Selenium testing project, from either <a>CreateTestGridProject</a> or <a>ListTestGridProjects</a>.</p>
    public let projectArn: String?

    public init (
        projectArn: String? = nil
    )
    {
        self.projectArn = projectArn
    }
}

struct GetTestGridProjectInputBody: Equatable {
    public let projectArn: String?
}

extension GetTestGridProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case projectArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
    }
}

extension GetTestGridProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTestGridProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTestGridProjectOutputError: Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTestGridProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTestGridProjectOutputResponse(testGridProject: \(String(describing: testGridProject)))"}
}

extension GetTestGridProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTestGridProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.testGridProject = output.testGridProject
        } else {
            self.testGridProject = nil
        }
    }
}

public struct GetTestGridProjectOutputResponse: Equatable {
    /// <p>A <a>TestGridProject</a>.</p>
    public let testGridProject: TestGridProject?

    public init (
        testGridProject: TestGridProject? = nil
    )
    {
        self.testGridProject = testGridProject
    }
}

struct GetTestGridProjectOutputResponseBody: Equatable {
    public let testGridProject: TestGridProject?
}

extension GetTestGridProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case testGridProject
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testGridProjectDecoded = try containerValues.decodeIfPresent(TestGridProject.self, forKey: .testGridProject)
        testGridProject = testGridProjectDecoded
    }
}

public struct GetTestGridSessionInputBodyMiddleware: Middleware {
    public let id: String = "GetTestGridSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTestGridSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTestGridSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTestGridSessionInput>
    public typealias MOutput = OperationOutput<GetTestGridSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTestGridSessionOutputError>
}

extension GetTestGridSessionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTestGridSessionInput(projectArn: \(String(describing: projectArn)), sessionArn: \(String(describing: sessionArn)), sessionId: \(String(describing: sessionId)))"}
}

extension GetTestGridSessionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case projectArn
        case sessionArn
        case sessionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let sessionArn = sessionArn {
            try encodeContainer.encode(sessionArn, forKey: .sessionArn)
        }
        if let sessionId = sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

public struct GetTestGridSessionInputHeadersMiddleware: Middleware {
    public let id: String = "GetTestGridSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTestGridSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTestGridSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTestGridSessionInput>
    public typealias MOutput = OperationOutput<GetTestGridSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTestGridSessionOutputError>
}

public struct GetTestGridSessionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTestGridSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTestGridSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTestGridSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTestGridSessionInput>
    public typealias MOutput = OperationOutput<GetTestGridSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTestGridSessionOutputError>
}

public struct GetTestGridSessionInput: Equatable {
    /// <p>The ARN for the project that this session belongs to. See <a>CreateTestGridProject</a> and <a>ListTestGridProjects</a>.</p>
    public let projectArn: String?
    /// <p>An ARN that uniquely identifies a <a>TestGridSession</a>.</p>
    public let sessionArn: String?
    /// <p>An ID associated with this session.</p>
    public let sessionId: String?

    public init (
        projectArn: String? = nil,
        sessionArn: String? = nil,
        sessionId: String? = nil
    )
    {
        self.projectArn = projectArn
        self.sessionArn = sessionArn
        self.sessionId = sessionId
    }
}

struct GetTestGridSessionInputBody: Equatable {
    public let projectArn: String?
    public let sessionId: String?
    public let sessionArn: String?
}

extension GetTestGridSessionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case projectArn
        case sessionArn
        case sessionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let sessionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionArn)
        sessionArn = sessionArnDecoded
    }
}

extension GetTestGridSessionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTestGridSessionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTestGridSessionOutputError: Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTestGridSessionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTestGridSessionOutputResponse(testGridSession: \(String(describing: testGridSession)))"}
}

extension GetTestGridSessionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTestGridSessionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.testGridSession = output.testGridSession
        } else {
            self.testGridSession = nil
        }
    }
}

public struct GetTestGridSessionOutputResponse: Equatable {
    /// <p>The <a>TestGridSession</a> that was requested.</p>
    public let testGridSession: TestGridSession?

    public init (
        testGridSession: TestGridSession? = nil
    )
    {
        self.testGridSession = testGridSession
    }
}

struct GetTestGridSessionOutputResponseBody: Equatable {
    public let testGridSession: TestGridSession?
}

extension GetTestGridSessionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case testGridSession
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testGridSessionDecoded = try containerValues.decodeIfPresent(TestGridSession.self, forKey: .testGridSession)
        testGridSession = testGridSessionDecoded
    }
}

public struct GetTestInputBodyMiddleware: Middleware {
    public let id: String = "GetTestInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTestInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTestInput>
    public typealias MOutput = OperationOutput<GetTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTestOutputError>
}

extension GetTestInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTestInput(arn: \(String(describing: arn)))"}
}

extension GetTestInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetTestInputHeadersMiddleware: Middleware {
    public let id: String = "GetTestInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTestInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTestInput>
    public typealias MOutput = OperationOutput<GetTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTestOutputError>
}

public struct GetTestInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTestInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTestInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTestInput>
    public typealias MOutput = OperationOutput<GetTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTestOutputError>
}

/// <p>Represents a request to the get test operation.</p>
public struct GetTestInput: Equatable {
    /// <p>The test's ARN.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetTestInputBody: Equatable {
    public let arn: String?
}

extension GetTestInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetTestOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTestOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTestOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTestOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTestOutputResponse(test: \(String(describing: test)))"}
}

extension GetTestOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTestOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.test = output.test
        } else {
            self.test = nil
        }
    }
}

/// <p>Represents the result of a get test request.</p>
public struct GetTestOutputResponse: Equatable {
    /// <p>A test condition that is evaluated.</p>
    public let test: Test?

    public init (
        test: Test? = nil
    )
    {
        self.test = test
    }
}

struct GetTestOutputResponseBody: Equatable {
    public let test: Test?
}

extension GetTestOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case test
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testDecoded = try containerValues.decodeIfPresent(Test.self, forKey: .test)
        test = testDecoded
    }
}

public struct GetUploadInputBodyMiddleware: Middleware {
    public let id: String = "GetUploadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUploadInput>
    public typealias MOutput = OperationOutput<GetUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUploadOutputError>
}

extension GetUploadInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUploadInput(arn: \(String(describing: arn)))"}
}

extension GetUploadInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetUploadInputHeadersMiddleware: Middleware {
    public let id: String = "GetUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUploadInput>
    public typealias MOutput = OperationOutput<GetUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUploadOutputError>
}

public struct GetUploadInputQueryItemMiddleware: Middleware {
    public let id: String = "GetUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUploadInput>
    public typealias MOutput = OperationOutput<GetUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUploadOutputError>
}

/// <p>Represents a request to the get upload operation.</p>
public struct GetUploadInput: Equatable {
    /// <p>The upload's ARN.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetUploadInputBody: Equatable {
    public let arn: String?
}

extension GetUploadInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetUploadOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUploadOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUploadOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUploadOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUploadOutputResponse(upload: \(String(describing: upload)))"}
}

extension GetUploadOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetUploadOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.upload = output.upload
        } else {
            self.upload = nil
        }
    }
}

/// <p>Represents the result of a get upload request.</p>
public struct GetUploadOutputResponse: Equatable {
    /// <p>An app or a set of one or more tests to upload or that have been
    ///             uploaded.</p>
    public let upload: Upload?

    public init (
        upload: Upload? = nil
    )
    {
        self.upload = upload
    }
}

struct GetUploadOutputResponseBody: Equatable {
    public let upload: Upload?
}

extension GetUploadOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case upload
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadDecoded = try containerValues.decodeIfPresent(Upload.self, forKey: .upload)
        upload = uploadDecoded
    }
}

public struct GetVPCEConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "GetVPCEConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetVPCEConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetVPCEConfigurationInput>
    public typealias MOutput = OperationOutput<GetVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetVPCEConfigurationOutputError>
}

extension GetVPCEConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetVPCEConfigurationInput(arn: \(String(describing: arn)))"}
}

extension GetVPCEConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetVPCEConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetVPCEConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetVPCEConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetVPCEConfigurationInput>
    public typealias MOutput = OperationOutput<GetVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetVPCEConfigurationOutputError>
}

public struct GetVPCEConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetVPCEConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetVPCEConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetVPCEConfigurationInput>
    public typealias MOutput = OperationOutput<GetVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetVPCEConfigurationOutputError>
}

public struct GetVPCEConfigurationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the VPC endpoint configuration you want to
    ///             describe.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetVPCEConfigurationInputBody: Equatable {
    public let arn: String?
}

extension GetVPCEConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetVPCEConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVPCEConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVPCEConfigurationOutputError: Equatable {
    case argumentException(ArgumentException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVPCEConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetVPCEConfigurationOutputResponse(vpceConfiguration: \(String(describing: vpceConfiguration)))"}
}

extension GetVPCEConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetVPCEConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.vpceConfiguration = output.vpceConfiguration
        } else {
            self.vpceConfiguration = nil
        }
    }
}

public struct GetVPCEConfigurationOutputResponse: Equatable {
    /// <p>An object that contains information about your VPC endpoint configuration.</p>
    public let vpceConfiguration: VPCEConfiguration?

    public init (
        vpceConfiguration: VPCEConfiguration? = nil
    )
    {
        self.vpceConfiguration = vpceConfiguration
    }
}

struct GetVPCEConfigurationOutputResponseBody: Equatable {
    public let vpceConfiguration: VPCEConfiguration?
}

extension GetVPCEConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case vpceConfiguration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpceConfigurationDecoded = try containerValues.decodeIfPresent(VPCEConfiguration.self, forKey: .vpceConfiguration)
        vpceConfiguration = vpceConfigurationDecoded
    }
}

extension IdempotencyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IdempotencyException(message: \(String(describing: message)))"}
}

extension IdempotencyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IdempotencyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An entity with the same name already exists.</p>
public struct IdempotencyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any additional information about the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IdempotencyExceptionBody: Equatable {
    public let message: String?
}

extension IdempotencyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IncompatibilityMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DeviceAttribute.self, forKey: .type)
        type = typeDecoded
    }
}

extension IncompatibilityMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IncompatibilityMessage(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

/// <p>Represents information about incompatibility.</p>
public struct IncompatibilityMessage: Equatable {
    /// <p>A message about the incompatibility.</p>
    public let message: String?
    /// <p>The type of incompatibility.</p>
    ///         <p>Allowed values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>ARN</p>
    ///             </li>
    ///             <li>
    ///                 <p>FORM_FACTOR (for example, phone or tablet)</p>
    ///             </li>
    ///             <li>
    ///                 <p>MANUFACTURER</p>
    ///             </li>
    ///             <li>
    ///                 <p>PLATFORM (for example, Android or iOS)</p>
    ///             </li>
    ///             <li>
    ///                 <p>REMOTE_ACCESS_ENABLED</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_VERSION</p>
    ///             </li>
    ///          </ul>
    public let type: DeviceAttribute?

    public init (
        message: String? = nil,
        type: DeviceAttribute? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

public struct InstallToRemoteAccessSessionInputBodyMiddleware: Middleware {
    public let id: String = "InstallToRemoteAccessSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InstallToRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<InstallToRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InstallToRemoteAccessSessionInput>
    public typealias MOutput = OperationOutput<InstallToRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InstallToRemoteAccessSessionOutputError>
}

extension InstallToRemoteAccessSessionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstallToRemoteAccessSessionInput(appArn: \(String(describing: appArn)), remoteAccessSessionArn: \(String(describing: remoteAccessSessionArn)))"}
}

extension InstallToRemoteAccessSessionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appArn
        case remoteAccessSessionArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let remoteAccessSessionArn = remoteAccessSessionArn {
            try encodeContainer.encode(remoteAccessSessionArn, forKey: .remoteAccessSessionArn)
        }
    }
}

public struct InstallToRemoteAccessSessionInputHeadersMiddleware: Middleware {
    public let id: String = "InstallToRemoteAccessSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InstallToRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<InstallToRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InstallToRemoteAccessSessionInput>
    public typealias MOutput = OperationOutput<InstallToRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InstallToRemoteAccessSessionOutputError>
}

public struct InstallToRemoteAccessSessionInputQueryItemMiddleware: Middleware {
    public let id: String = "InstallToRemoteAccessSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InstallToRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<InstallToRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InstallToRemoteAccessSessionInput>
    public typealias MOutput = OperationOutput<InstallToRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InstallToRemoteAccessSessionOutputError>
}

/// <p>Represents the request to install an Android application (in .apk format) or an iOS
///             application (in .ipa format) as part of a remote access session.</p>
public struct InstallToRemoteAccessSessionInput: Equatable {
    /// <p>The ARN of the app about which you are requesting information.</p>
    public let appArn: String?
    /// <p>The Amazon Resource Name (ARN) of the remote access session about which you are
    ///             requesting information.</p>
    public let remoteAccessSessionArn: String?

    public init (
        appArn: String? = nil,
        remoteAccessSessionArn: String? = nil
    )
    {
        self.appArn = appArn
        self.remoteAccessSessionArn = remoteAccessSessionArn
    }
}

struct InstallToRemoteAccessSessionInputBody: Equatable {
    public let remoteAccessSessionArn: String?
    public let appArn: String?
}

extension InstallToRemoteAccessSessionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appArn
        case remoteAccessSessionArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remoteAccessSessionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .remoteAccessSessionArn)
        remoteAccessSessionArn = remoteAccessSessionArnDecoded
        let appArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appArn)
        appArn = appArnDecoded
    }
}

extension InstallToRemoteAccessSessionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InstallToRemoteAccessSessionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InstallToRemoteAccessSessionOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InstallToRemoteAccessSessionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstallToRemoteAccessSessionOutputResponse(appUpload: \(String(describing: appUpload)))"}
}

extension InstallToRemoteAccessSessionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InstallToRemoteAccessSessionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appUpload = output.appUpload
        } else {
            self.appUpload = nil
        }
    }
}

/// <p>Represents the response from the server after AWS Device Farm makes a request to
///             install to a remote access session.</p>
public struct InstallToRemoteAccessSessionOutputResponse: Equatable {
    /// <p>An app to upload or that has been uploaded.</p>
    public let appUpload: Upload?

    public init (
        appUpload: Upload? = nil
    )
    {
        self.appUpload = appUpload
    }
}

struct InstallToRemoteAccessSessionOutputResponseBody: Equatable {
    public let appUpload: Upload?
}

extension InstallToRemoteAccessSessionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appUpload
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appUploadDecoded = try containerValues.decodeIfPresent(Upload.self, forKey: .appUpload)
        appUpload = appUploadDecoded
    }
}

extension InstanceProfile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case description
        case excludeAppPackagesFromCleanup
        case name
        case packageCleanup
        case rebootAfterUse
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup {
            var excludeAppPackagesFromCleanupContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeAppPackagesFromCleanup)
            for packageids0 in excludeAppPackagesFromCleanup {
                try excludeAppPackagesFromCleanupContainer.encode(packageids0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packageCleanup = packageCleanup {
            try encodeContainer.encode(packageCleanup, forKey: .packageCleanup)
        }
        if let rebootAfterUse = rebootAfterUse {
            try encodeContainer.encode(rebootAfterUse, forKey: .rebootAfterUse)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let packageCleanupDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .packageCleanup)
        packageCleanup = packageCleanupDecoded
        let excludeAppPackagesFromCleanupContainer = try containerValues.decodeIfPresent([String?].self, forKey: .excludeAppPackagesFromCleanup)
        var excludeAppPackagesFromCleanupDecoded0:[String]? = nil
        if let excludeAppPackagesFromCleanupContainer = excludeAppPackagesFromCleanupContainer {
            excludeAppPackagesFromCleanupDecoded0 = [String]()
            for string0 in excludeAppPackagesFromCleanupContainer {
                if let string0 = string0 {
                    excludeAppPackagesFromCleanupDecoded0?.append(string0)
                }
            }
        }
        excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanupDecoded0
        let rebootAfterUseDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .rebootAfterUse)
        rebootAfterUse = rebootAfterUseDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension InstanceProfile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceProfile(arn: \(String(describing: arn)), description: \(String(describing: description)), excludeAppPackagesFromCleanup: \(String(describing: excludeAppPackagesFromCleanup)), name: \(String(describing: name)), packageCleanup: \(String(describing: packageCleanup)), rebootAfterUse: \(String(describing: rebootAfterUse)))"}
}

/// <p>Represents the instance profile.</p>
public struct InstanceProfile: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the instance profile.</p>
    public let arn: String?
    /// <p>The description of the instance profile.</p>
    public let description: String?
    /// <p>An array of strings containing the list of app packages that should not be cleaned up from the device
    ///             after a test run completes.</p>
    ///         <p>The list of packages is considered only if you set <code>packageCleanup</code> to
    ///             <code>true</code>.</p>
    public let excludeAppPackagesFromCleanup: [String]?
    /// <p>The name of the instance profile.</p>
    public let name: String?
    /// <p>When set to <code>true</code>, Device Farm removes app packages after a test run. The default value is
    ///                 <code>false</code> for private devices.</p>
    public let packageCleanup: Bool?
    /// <p>When set to <code>true</code>, Device Farm reboots the instance after a test run. The default value is
    ///                 <code>true</code>.</p>
    public let rebootAfterUse: Bool?

    public init (
        arn: String? = nil,
        description: String? = nil,
        excludeAppPackagesFromCleanup: [String]? = nil,
        name: String? = nil,
        packageCleanup: Bool? = nil,
        rebootAfterUse: Bool? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup
        self.name = name
        self.packageCleanup = packageCleanup
        self.rebootAfterUse = rebootAfterUse
    }
}

public enum InstanceStatus {
    case available
    case inUse
    case notAvailable
    case preparing
    case sdkUnknown(String)
}

extension InstanceStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InstanceStatus] {
        return [
            .available,
            .inUse,
            .notAvailable,
            .preparing,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .inUse: return "IN_USE"
        case .notAvailable: return "NOT_AVAILABLE"
        case .preparing: return "PREPARING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InstanceStatus(rawValue: rawValue) ?? InstanceStatus.sdkUnknown(rawValue)
    }
}

public enum InteractionMode {
    case interactive
    case noVideo
    case videoOnly
    case sdkUnknown(String)
}

extension InteractionMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InteractionMode] {
        return [
            .interactive,
            .noVideo,
            .videoOnly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .interactive: return "INTERACTIVE"
        case .noVideo: return "NO_VIDEO"
        case .videoOnly: return "VIDEO_ONLY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InteractionMode(rawValue: rawValue) ?? InteractionMode.sdkUnknown(rawValue)
    }
}

extension InternalServiceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServiceException(message: \(String(describing: message)))"}
}

extension InternalServiceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal exception was raised in the service. Contact <a href="mailto:aws-devicefarm-support@amazon.com">aws-devicefarm-support@amazon.com</a> if you see this
///          error. </p>
public struct InternalServiceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceExceptionBody: Equatable {
    public let message: String?
}

extension InternalServiceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidOperationException(message: \(String(describing: message)))"}
}

extension InvalidOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidOperationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There was an error with the update request, or you do not have sufficient permissions
///             to update this VPC endpoint configuration.</p>
public struct InvalidOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOperationExceptionBody: Equatable {
    public let message: String?
}

extension InvalidOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Job: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case counters
        case created
        case device
        case deviceMinutes
        case instanceArn
        case message
        case name
        case result
        case started
        case status
        case stopped
        case type
        case videoCapture
        case videoEndpoint
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let counters = counters {
            try encodeContainer.encode(counters, forKey: .counters)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let device = device {
            try encodeContainer.encode(device, forKey: .device)
        }
        if let deviceMinutes = deviceMinutes {
            try encodeContainer.encode(deviceMinutes, forKey: .deviceMinutes)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let result = result {
            try encodeContainer.encode(result.rawValue, forKey: .result)
        }
        if let started = started {
            try encodeContainer.encode(started.timeIntervalSince1970, forKey: .started)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stopped = stopped {
            try encodeContainer.encode(stopped.timeIntervalSince1970, forKey: .stopped)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let videoCapture = videoCapture {
            try encodeContainer.encode(videoCapture, forKey: .videoCapture)
        }
        if let videoEndpoint = videoEndpoint {
            try encodeContainer.encode(videoEndpoint, forKey: .videoEndpoint)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TestType.self, forKey: .type)
        type = typeDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let resultDecoded = try containerValues.decodeIfPresent(ExecutionResult.self, forKey: .result)
        result = resultDecoded
        let startedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .started)
        started = startedDecoded
        let stoppedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .stopped)
        stopped = stoppedDecoded
        let countersDecoded = try containerValues.decodeIfPresent(Counters.self, forKey: .counters)
        counters = countersDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let deviceDecoded = try containerValues.decodeIfPresent(Device.self, forKey: .device)
        device = deviceDecoded
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let deviceMinutesDecoded = try containerValues.decodeIfPresent(DeviceMinutes.self, forKey: .deviceMinutes)
        deviceMinutes = deviceMinutesDecoded
        let videoEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .videoEndpoint)
        videoEndpoint = videoEndpointDecoded
        let videoCaptureDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .videoCapture)
        videoCapture = videoCaptureDecoded
    }
}

extension Job: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Job(arn: \(String(describing: arn)), counters: \(String(describing: counters)), created: \(String(describing: created)), device: \(String(describing: device)), deviceMinutes: \(String(describing: deviceMinutes)), instanceArn: \(String(describing: instanceArn)), message: \(String(describing: message)), name: \(String(describing: name)), result: \(String(describing: result)), started: \(String(describing: started)), status: \(String(describing: status)), stopped: \(String(describing: stopped)), type: \(String(describing: type)), videoCapture: \(String(describing: videoCapture)), videoEndpoint: \(String(describing: videoEndpoint)))"}
}

/// <p>Represents a device.</p>
public struct Job: Equatable {
    /// <p>The job's ARN.</p>
    public let arn: String?
    /// <p>The job's result counters.</p>
    public let counters: Counters?
    /// <p>When the job was created.</p>
    public let created: Date?
    /// <p>The device (phone or tablet).</p>
    public let device: Device?
    /// <p>Represents the total (metered or unmetered) minutes used by the job.</p>
    public let deviceMinutes: DeviceMinutes?
    /// <p>The ARN of the instance.</p>
    public let instanceArn: String?
    /// <p>A message about the job's result.</p>
    public let message: String?
    /// <p>The job's name.</p>
    public let name: String?
    /// <p>The job's result.</p>
    ///         <p>Allowed values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>PENDING</p>
    ///             </li>
    ///             <li>
    ///                 <p>PASSED</p>
    ///             </li>
    ///             <li>
    ///                 <p>WARNED</p>
    ///             </li>
    ///             <li>
    ///                 <p>FAILED</p>
    ///             </li>
    ///             <li>
    ///                 <p>SKIPPED</p>
    ///             </li>
    ///             <li>
    ///                 <p>ERRORED</p>
    ///             </li>
    ///             <li>
    ///                 <p>STOPPED</p>
    ///             </li>
    ///          </ul>
    public let result: ExecutionResult?
    /// <p>The job's start time.</p>
    public let started: Date?
    /// <p>The job's status.</p>
    ///         <p>Allowed values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>PENDING</p>
    ///             </li>
    ///             <li>
    ///                 <p>PENDING_CONCURRENCY</p>
    ///             </li>
    ///             <li>
    ///                 <p>PENDING_DEVICE</p>
    ///             </li>
    ///             <li>
    ///                 <p>PROCESSING</p>
    ///             </li>
    ///             <li>
    ///                 <p>SCHEDULING</p>
    ///             </li>
    ///             <li>
    ///                 <p>PREPARING</p>
    ///             </li>
    ///             <li>
    ///                 <p>RUNNING</p>
    ///             </li>
    ///             <li>
    ///                 <p>COMPLETED</p>
    ///             </li>
    ///             <li>
    ///                 <p>STOPPING</p>
    ///             </li>
    ///          </ul>
    public let status: ExecutionStatus?
    /// <p>The job's stop time.</p>
    public let stopped: Date?
    /// <p>The job's type.</p>
    ///         <p>Allowed values include the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>BUILTIN_FUZZ</p>
    ///             </li>
    ///             <li>
    ///                 <p>BUILTIN_EXPLORER. For Android, an app explorer that traverses an Android app, interacting with
    ///                     it and capturing screenshots at the same time.</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_JUNIT</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_TESTNG</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_PYTHON</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_NODE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_RUBY</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_JAVA_JUNIT</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_JAVA_TESTNG</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_PYTHON</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_NODE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_RUBY</p>
    ///             </li>
    ///             <li>
    ///                 <p>CALABASH</p>
    ///             </li>
    ///             <li>
    ///                 <p>INSTRUMENTATION</p>
    ///             </li>
    ///             <li>
    ///                 <p>UIAUTOMATION</p>
    ///             </li>
    ///             <li>
    ///                 <p>UIAUTOMATOR</p>
    ///             </li>
    ///             <li>
    ///                 <p>XCTEST</p>
    ///             </li>
    ///             <li>
    ///                 <p>XCTEST_UI</p>
    ///             </li>
    ///          </ul>
    public let type: TestType?
    /// <p>This value is set to true if video capture is enabled. Otherwise, it is set to false.</p>
    public let videoCapture: Bool?
    /// <p>The endpoint for streaming device video.</p>
    public let videoEndpoint: String?

    public init (
        arn: String? = nil,
        counters: Counters? = nil,
        created: Date? = nil,
        device: Device? = nil,
        deviceMinutes: DeviceMinutes? = nil,
        instanceArn: String? = nil,
        message: String? = nil,
        name: String? = nil,
        result: ExecutionResult? = nil,
        started: Date? = nil,
        status: ExecutionStatus? = nil,
        stopped: Date? = nil,
        type: TestType? = nil,
        videoCapture: Bool? = nil,
        videoEndpoint: String? = nil
    )
    {
        self.arn = arn
        self.counters = counters
        self.created = created
        self.device = device
        self.deviceMinutes = deviceMinutes
        self.instanceArn = instanceArn
        self.message = message
        self.name = name
        self.result = result
        self.started = started
        self.status = status
        self.stopped = stopped
        self.type = type
        self.videoCapture = videoCapture
        self.videoEndpoint = videoEndpoint
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A limit was exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any additional information about the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListArtifactsInputBodyMiddleware: Middleware {
    public let id: String = "ListArtifactsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListArtifactsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListArtifactsInput>
    public typealias MOutput = OperationOutput<ListArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListArtifactsOutputError>
}

extension ListArtifactsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListArtifactsInput(arn: \(String(describing: arn)), nextToken: \(String(describing: nextToken)), type: \(String(describing: type)))"}
}

extension ListArtifactsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case nextToken
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct ListArtifactsInputHeadersMiddleware: Middleware {
    public let id: String = "ListArtifactsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListArtifactsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListArtifactsInput>
    public typealias MOutput = OperationOutput<ListArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListArtifactsOutputError>
}

public struct ListArtifactsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListArtifactsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListArtifactsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListArtifactsInput>
    public typealias MOutput = OperationOutput<ListArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListArtifactsOutputError>
}

/// <p>Represents a request to the list artifacts operation.</p>
public struct ListArtifactsInput: Equatable {
    /// <p>The run, job, suite, or test ARN.</p>
    public let arn: String?
    /// <p>An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.</p>
    public let nextToken: String?
    /// <p>The artifacts' type.</p>
    ///         <p>Allowed values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>FILE</p>
    ///             </li>
    ///             <li>
    ///                 <p>LOG</p>
    ///             </li>
    ///             <li>
    ///                 <p>SCREENSHOT</p>
    ///             </li>
    ///          </ul>
    public let type: ArtifactCategory?

    public init (
        arn: String? = nil,
        nextToken: String? = nil,
        type: ArtifactCategory? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListArtifactsInputBody: Equatable {
    public let arn: String?
    public let type: ArtifactCategory?
    public let nextToken: String?
}

extension ListArtifactsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case nextToken
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ArtifactCategory.self, forKey: .type)
        type = typeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListArtifactsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListArtifactsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListArtifactsOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListArtifactsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListArtifactsOutputResponse(artifacts: \(String(describing: artifacts)), nextToken: \(String(describing: nextToken)))"}
}

extension ListArtifactsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListArtifactsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.artifacts = output.artifacts
            self.nextToken = output.nextToken
        } else {
            self.artifacts = nil
            self.nextToken = nil
        }
    }
}

/// <p>Represents the result of a list artifacts operation.</p>
public struct ListArtifactsOutputResponse: Equatable {
    /// <p>Information about the artifacts.</p>
    public let artifacts: [Artifact]?
    /// <p>If the number of items that are returned is significantly large, this is an identifier that is also
    ///             returned. It can be used in a subsequent call to this operation to return the next set of items in the
    ///             list.</p>
    public let nextToken: String?

    public init (
        artifacts: [Artifact]? = nil,
        nextToken: String? = nil
    )
    {
        self.artifacts = artifacts
        self.nextToken = nextToken
    }
}

struct ListArtifactsOutputResponseBody: Equatable {
    public let artifacts: [Artifact]?
    public let nextToken: String?
}

extension ListArtifactsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case artifacts
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let artifactsContainer = try containerValues.decodeIfPresent([Artifact?].self, forKey: .artifacts)
        var artifactsDecoded0:[Artifact]? = nil
        if let artifactsContainer = artifactsContainer {
            artifactsDecoded0 = [Artifact]()
            for structure0 in artifactsContainer {
                if let structure0 = structure0 {
                    artifactsDecoded0?.append(structure0)
                }
            }
        }
        artifacts = artifactsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDeviceInstancesInputBodyMiddleware: Middleware {
    public let id: String = "ListDeviceInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeviceInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeviceInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeviceInstancesInput>
    public typealias MOutput = OperationOutput<ListDeviceInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeviceInstancesOutputError>
}

extension ListDeviceInstancesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDeviceInstancesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDeviceInstancesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDeviceInstancesInputHeadersMiddleware: Middleware {
    public let id: String = "ListDeviceInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeviceInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeviceInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeviceInstancesInput>
    public typealias MOutput = OperationOutput<ListDeviceInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeviceInstancesOutputError>
}

public struct ListDeviceInstancesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDeviceInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeviceInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeviceInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeviceInstancesInput>
    public typealias MOutput = OperationOutput<ListDeviceInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeviceInstancesOutputError>
}

public struct ListDeviceInstancesInput: Equatable {
    /// <p>An integer that specifies the maximum number of items you want to return in the API response.</p>
    public let maxResults: Int?
    /// <p>An identifier that was returned from the previous call to this operation, which can be
    ///             used to return the next set of items in the list.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeviceInstancesInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListDeviceInstancesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDeviceInstancesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeviceInstancesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDeviceInstancesOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeviceInstancesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDeviceInstancesOutputResponse(deviceInstances: \(String(describing: deviceInstances)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDeviceInstancesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDeviceInstancesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deviceInstances = output.deviceInstances
            self.nextToken = output.nextToken
        } else {
            self.deviceInstances = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeviceInstancesOutputResponse: Equatable {
    /// <p>An object that contains information about your device instances.</p>
    public let deviceInstances: [DeviceInstance]?
    /// <p>An identifier that can be used in the next call to this operation to return the next
    ///             set of items in the list.</p>
    public let nextToken: String?

    public init (
        deviceInstances: [DeviceInstance]? = nil,
        nextToken: String? = nil
    )
    {
        self.deviceInstances = deviceInstances
        self.nextToken = nextToken
    }
}

struct ListDeviceInstancesOutputResponseBody: Equatable {
    public let deviceInstances: [DeviceInstance]?
    public let nextToken: String?
}

extension ListDeviceInstancesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceInstances
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceInstancesContainer = try containerValues.decodeIfPresent([DeviceInstance?].self, forKey: .deviceInstances)
        var deviceInstancesDecoded0:[DeviceInstance]? = nil
        if let deviceInstancesContainer = deviceInstancesContainer {
            deviceInstancesDecoded0 = [DeviceInstance]()
            for structure0 in deviceInstancesContainer {
                if let structure0 = structure0 {
                    deviceInstancesDecoded0?.append(structure0)
                }
            }
        }
        deviceInstances = deviceInstancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDevicePoolsInputBodyMiddleware: Middleware {
    public let id: String = "ListDevicePoolsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDevicePoolsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDevicePoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDevicePoolsInput>
    public typealias MOutput = OperationOutput<ListDevicePoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDevicePoolsOutputError>
}

extension ListDevicePoolsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDevicePoolsInput(arn: \(String(describing: arn)), nextToken: \(String(describing: nextToken)), type: \(String(describing: type)))"}
}

extension ListDevicePoolsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case nextToken
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct ListDevicePoolsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDevicePoolsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDevicePoolsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDevicePoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDevicePoolsInput>
    public typealias MOutput = OperationOutput<ListDevicePoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDevicePoolsOutputError>
}

public struct ListDevicePoolsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDevicePoolsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDevicePoolsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDevicePoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDevicePoolsInput>
    public typealias MOutput = OperationOutput<ListDevicePoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDevicePoolsOutputError>
}

/// <p>Represents the result of a list device pools request.</p>
public struct ListDevicePoolsInput: Equatable {
    /// <p>The project ARN.</p>
    public let arn: String?
    /// <p>An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.</p>
    public let nextToken: String?
    /// <p>The device pools' type.</p>
    ///         <p>Allowed values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>CURATED: A device pool that is created and managed by AWS Device
    ///                     Farm.</p>
    ///             </li>
    ///             <li>
    ///                 <p>PRIVATE: A device pool that is created and managed by the device pool
    ///                     developer.</p>
    ///             </li>
    ///          </ul>
    public let type: DevicePoolType?

    public init (
        arn: String? = nil,
        nextToken: String? = nil,
        type: DevicePoolType? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListDevicePoolsInputBody: Equatable {
    public let arn: String?
    public let type: DevicePoolType?
    public let nextToken: String?
}

extension ListDevicePoolsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case nextToken
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DevicePoolType.self, forKey: .type)
        type = typeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDevicePoolsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDevicePoolsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDevicePoolsOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDevicePoolsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDevicePoolsOutputResponse(devicePools: \(String(describing: devicePools)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDevicePoolsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDevicePoolsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.devicePools = output.devicePools
            self.nextToken = output.nextToken
        } else {
            self.devicePools = nil
            self.nextToken = nil
        }
    }
}

/// <p>Represents the result of a list device pools request.</p>
public struct ListDevicePoolsOutputResponse: Equatable {
    /// <p>Information about the device pools.</p>
    public let devicePools: [DevicePool]?
    /// <p>If the number of items that are returned is significantly large, this is an identifier that is also
    ///             returned. It can be used in a subsequent call to this operation to return the next set of items in the
    ///             list.</p>
    public let nextToken: String?

    public init (
        devicePools: [DevicePool]? = nil,
        nextToken: String? = nil
    )
    {
        self.devicePools = devicePools
        self.nextToken = nextToken
    }
}

struct ListDevicePoolsOutputResponseBody: Equatable {
    public let devicePools: [DevicePool]?
    public let nextToken: String?
}

extension ListDevicePoolsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case devicePools
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicePoolsContainer = try containerValues.decodeIfPresent([DevicePool?].self, forKey: .devicePools)
        var devicePoolsDecoded0:[DevicePool]? = nil
        if let devicePoolsContainer = devicePoolsContainer {
            devicePoolsDecoded0 = [DevicePool]()
            for structure0 in devicePoolsContainer {
                if let structure0 = structure0 {
                    devicePoolsDecoded0?.append(structure0)
                }
            }
        }
        devicePools = devicePoolsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDevicesInputBodyMiddleware: Middleware {
    public let id: String = "ListDevicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDevicesInput>
    public typealias MOutput = OperationOutput<ListDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDevicesOutputError>
}

extension ListDevicesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDevicesInput(arn: \(String(describing: arn)), filters: \(String(describing: filters)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDevicesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case filters
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for devicefilters0 in filters {
                try filtersContainer.encode(devicefilters0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDevicesInputHeadersMiddleware: Middleware {
    public let id: String = "ListDevicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDevicesInput>
    public typealias MOutput = OperationOutput<ListDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDevicesOutputError>
}

public struct ListDevicesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDevicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDevicesInput>
    public typealias MOutput = OperationOutput<ListDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDevicesOutputError>
}

/// <p>Represents the result of a list devices request.</p>
public struct ListDevicesInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the project.</p>
    public let arn: String?
    /// <p>Used to select a set of devices. A filter is made up of an attribute, an operator, and
    ///             one or more values.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Attribute: The aspect of a device such as platform or model used as the
    ///                     selection criteria in a device filter.</p>
    ///                 <p>Allowed values include:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>ARN: The Amazon Resource Name (ARN) of the device (for example,
    ///                                 <code>arn:aws:devicefarm:us-west-2::device:12345Example</code>).</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>PLATFORM: The device platform. Valid values are ANDROID or IOS.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>OS_VERSION: The operating system version (for example, 10.3.2).</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>MODEL: The device model (for example, iPad 5th Gen).</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>AVAILABILITY: The current availability of the device. Valid values are AVAILABLE,
    ///                             HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>FORM_FACTOR: The device form factor. Valid values are PHONE or TABLET.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>MANUFACTURER: The device manufacturer (for example, Apple).</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>REMOTE_ACCESS_ENABLED: Whether the device is enabled for remote access. Valid values
    ///                             are TRUE or FALSE.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>REMOTE_DEBUG_ENABLED: Whether the device is enabled for remote debugging. Valid values
    ///                             are TRUE or FALSE. Because remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no
    ///                                 longer supported</a>, this attribute is ignored.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>INSTANCE_ARN: The Amazon Resource Name (ARN) of the device
    ///                             instance.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>INSTANCE_LABELS: The label of the device instance.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>FLEET_TYPE: The fleet type. Valid values are PUBLIC or PRIVATE.</p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                 <p>Operator: The filter operator.</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>The EQUALS operator is available for every attribute except
    ///                             INSTANCE_LABELS.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>The CONTAINS operator is available for the INSTANCE_LABELS and MODEL
    ///                             attributes.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>The IN and NOT_IN operators are available for the ARN, OS_VERSION,
    ///                             MODEL, MANUFACTURER, and INSTANCE_ARN attributes.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>The LESS_THAN, GREATER_THAN, LESS_THAN_OR_EQUALS, and
    ///                             GREATER_THAN_OR_EQUALS operators are also available for the OS_VERSION
    ///                             attribute.</p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                 <p>Values: An array of one or more filter values.</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>The IN and NOT_IN operators take a values array that has one or more
    ///                             elements.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>The other operators require an array with a single element.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>In a request, the AVAILABILITY attribute takes the following values: AVAILABLE,
    ///                             HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE.</p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let filters: [DeviceFilter]?
    /// <p>An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.</p>
    public let nextToken: String?

    public init (
        arn: String? = nil,
        filters: [DeviceFilter]? = nil,
        nextToken: String? = nil
    )
    {
        self.arn = arn
        self.filters = filters
        self.nextToken = nextToken
    }
}

struct ListDevicesInputBody: Equatable {
    public let arn: String?
    public let nextToken: String?
    public let filters: [DeviceFilter]?
}

extension ListDevicesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case filters
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([DeviceFilter?].self, forKey: .filters)
        var filtersDecoded0:[DeviceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DeviceFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListDevicesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDevicesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDevicesOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDevicesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDevicesOutputResponse(devices: \(String(describing: devices)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDevicesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDevicesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.devices = output.devices
            self.nextToken = output.nextToken
        } else {
            self.devices = nil
            self.nextToken = nil
        }
    }
}

/// <p>Represents the result of a list devices operation.</p>
public struct ListDevicesOutputResponse: Equatable {
    /// <p>Information about the devices.</p>
    public let devices: [Device]?
    /// <p>If the number of items that are returned is significantly large, this is an identifier that is also
    ///             returned. It can be used in a subsequent call to this operation to return the next set of items in the
    ///             list.</p>
    public let nextToken: String?

    public init (
        devices: [Device]? = nil,
        nextToken: String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

struct ListDevicesOutputResponseBody: Equatable {
    public let devices: [Device]?
    public let nextToken: String?
}

extension ListDevicesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case devices
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([Device?].self, forKey: .devices)
        var devicesDecoded0:[Device]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [Device]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListInstanceProfilesInputBodyMiddleware: Middleware {
    public let id: String = "ListInstanceProfilesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstanceProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstanceProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstanceProfilesInput>
    public typealias MOutput = OperationOutput<ListInstanceProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstanceProfilesOutputError>
}

extension ListInstanceProfilesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInstanceProfilesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInstanceProfilesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListInstanceProfilesInputHeadersMiddleware: Middleware {
    public let id: String = "ListInstanceProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstanceProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstanceProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstanceProfilesInput>
    public typealias MOutput = OperationOutput<ListInstanceProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstanceProfilesOutputError>
}

public struct ListInstanceProfilesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListInstanceProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInstanceProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInstanceProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInstanceProfilesInput>
    public typealias MOutput = OperationOutput<ListInstanceProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInstanceProfilesOutputError>
}

public struct ListInstanceProfilesInput: Equatable {
    /// <p>An integer that specifies the maximum number of items you want to return in the API response.</p>
    public let maxResults: Int?
    /// <p>An identifier that was returned from the previous call to this operation, which can be
    ///             used to return the next set of items in the list.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInstanceProfilesInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListInstanceProfilesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInstanceProfilesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInstanceProfilesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInstanceProfilesOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInstanceProfilesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInstanceProfilesOutputResponse(instanceProfiles: \(String(describing: instanceProfiles)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInstanceProfilesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListInstanceProfilesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instanceProfiles = output.instanceProfiles
            self.nextToken = output.nextToken
        } else {
            self.instanceProfiles = nil
            self.nextToken = nil
        }
    }
}

public struct ListInstanceProfilesOutputResponse: Equatable {
    /// <p>An object that contains information about your instance profiles.</p>
    public let instanceProfiles: [InstanceProfile]?
    /// <p>An identifier that can be used in the next call to this operation to return the next
    ///             set of items in the list.</p>
    public let nextToken: String?

    public init (
        instanceProfiles: [InstanceProfile]? = nil,
        nextToken: String? = nil
    )
    {
        self.instanceProfiles = instanceProfiles
        self.nextToken = nextToken
    }
}

struct ListInstanceProfilesOutputResponseBody: Equatable {
    public let instanceProfiles: [InstanceProfile]?
    public let nextToken: String?
}

extension ListInstanceProfilesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceProfiles
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfilesContainer = try containerValues.decodeIfPresent([InstanceProfile?].self, forKey: .instanceProfiles)
        var instanceProfilesDecoded0:[InstanceProfile]? = nil
        if let instanceProfilesContainer = instanceProfilesContainer {
            instanceProfilesDecoded0 = [InstanceProfile]()
            for structure0 in instanceProfilesContainer {
                if let structure0 = structure0 {
                    instanceProfilesDecoded0?.append(structure0)
                }
            }
        }
        instanceProfiles = instanceProfilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobsInput>
    public typealias MOutput = OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobsOutputError>
}

extension ListJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobsInput(arn: \(String(describing: arn)), nextToken: \(String(describing: nextToken)))"}
}

extension ListJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobsInput>
    public typealias MOutput = OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobsOutputError>
}

public struct ListJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobsInput>
    public typealias MOutput = OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobsOutputError>
}

/// <p>Represents a request to the list jobs operation.</p>
public struct ListJobsInput: Equatable {
    /// <p>The run's Amazon Resource Name (ARN).</p>
    public let arn: String?
    /// <p>An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.</p>
    public let nextToken: String?

    public init (
        arn: String? = nil,
        nextToken: String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

struct ListJobsInputBody: Equatable {
    public let arn: String?
    public let nextToken: String?
}

extension ListJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJobsOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobsOutputResponse(jobs: \(String(describing: jobs)), nextToken: \(String(describing: nextToken)))"}
}

extension ListJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

/// <p>Represents the result of a list jobs request.</p>
public struct ListJobsOutputResponse: Equatable {
    /// <p>Information about the jobs.</p>
    public let jobs: [Job]?
    /// <p>If the number of items that are returned is significantly large, this is an identifier that is also
    ///             returned. It can be used in a subsequent call to this operation to return the next set of items in the
    ///             list.</p>
    public let nextToken: String?

    public init (
        jobs: [Job]? = nil,
        nextToken: String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListJobsOutputResponseBody: Equatable {
    public let jobs: [Job]?
    public let nextToken: String?
}

extension ListJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobs
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([Job?].self, forKey: .jobs)
        var jobsDecoded0:[Job]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [Job]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListNetworkProfilesInputBodyMiddleware: Middleware {
    public let id: String = "ListNetworkProfilesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListNetworkProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListNetworkProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListNetworkProfilesInput>
    public typealias MOutput = OperationOutput<ListNetworkProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListNetworkProfilesOutputError>
}

extension ListNetworkProfilesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListNetworkProfilesInput(arn: \(String(describing: arn)), nextToken: \(String(describing: nextToken)), type: \(String(describing: type)))"}
}

extension ListNetworkProfilesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case nextToken
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct ListNetworkProfilesInputHeadersMiddleware: Middleware {
    public let id: String = "ListNetworkProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListNetworkProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListNetworkProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListNetworkProfilesInput>
    public typealias MOutput = OperationOutput<ListNetworkProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListNetworkProfilesOutputError>
}

public struct ListNetworkProfilesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListNetworkProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListNetworkProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListNetworkProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListNetworkProfilesInput>
    public typealias MOutput = OperationOutput<ListNetworkProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListNetworkProfilesOutputError>
}

public struct ListNetworkProfilesInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the project for which you want to list network
    ///             profiles.</p>
    public let arn: String?
    /// <p>An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.</p>
    public let nextToken: String?
    /// <p>The type of network profile to return information about. Valid values are listed here.</p>
    public let type: NetworkProfileType?

    public init (
        arn: String? = nil,
        nextToken: String? = nil,
        type: NetworkProfileType? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListNetworkProfilesInputBody: Equatable {
    public let arn: String?
    public let type: NetworkProfileType?
    public let nextToken: String?
}

extension ListNetworkProfilesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case nextToken
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(NetworkProfileType.self, forKey: .type)
        type = typeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListNetworkProfilesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNetworkProfilesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListNetworkProfilesOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNetworkProfilesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListNetworkProfilesOutputResponse(networkProfiles: \(String(describing: networkProfiles)), nextToken: \(String(describing: nextToken)))"}
}

extension ListNetworkProfilesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListNetworkProfilesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.networkProfiles = output.networkProfiles
            self.nextToken = output.nextToken
        } else {
            self.networkProfiles = nil
            self.nextToken = nil
        }
    }
}

public struct ListNetworkProfilesOutputResponse: Equatable {
    /// <p>A list of the available network profiles.</p>
    public let networkProfiles: [NetworkProfile]?
    /// <p>An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.</p>
    public let nextToken: String?

    public init (
        networkProfiles: [NetworkProfile]? = nil,
        nextToken: String? = nil
    )
    {
        self.networkProfiles = networkProfiles
        self.nextToken = nextToken
    }
}

struct ListNetworkProfilesOutputResponseBody: Equatable {
    public let networkProfiles: [NetworkProfile]?
    public let nextToken: String?
}

extension ListNetworkProfilesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case networkProfiles
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfilesContainer = try containerValues.decodeIfPresent([NetworkProfile?].self, forKey: .networkProfiles)
        var networkProfilesDecoded0:[NetworkProfile]? = nil
        if let networkProfilesContainer = networkProfilesContainer {
            networkProfilesDecoded0 = [NetworkProfile]()
            for structure0 in networkProfilesContainer {
                if let structure0 = structure0 {
                    networkProfilesDecoded0?.append(structure0)
                }
            }
        }
        networkProfiles = networkProfilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListOfferingPromotionsInputBodyMiddleware: Middleware {
    public let id: String = "ListOfferingPromotionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOfferingPromotionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOfferingPromotionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOfferingPromotionsInput>
    public typealias MOutput = OperationOutput<ListOfferingPromotionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOfferingPromotionsOutputError>
}

extension ListOfferingPromotionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOfferingPromotionsInput(nextToken: \(String(describing: nextToken)))"}
}

extension ListOfferingPromotionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListOfferingPromotionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListOfferingPromotionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOfferingPromotionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOfferingPromotionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOfferingPromotionsInput>
    public typealias MOutput = OperationOutput<ListOfferingPromotionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOfferingPromotionsOutputError>
}

public struct ListOfferingPromotionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListOfferingPromotionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOfferingPromotionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOfferingPromotionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOfferingPromotionsInput>
    public typealias MOutput = OperationOutput<ListOfferingPromotionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOfferingPromotionsOutputError>
}

public struct ListOfferingPromotionsInput: Equatable {
    /// <p>An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.</p>
    public let nextToken: String?

    public init (
        nextToken: String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListOfferingPromotionsInputBody: Equatable {
    public let nextToken: String?
}

extension ListOfferingPromotionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOfferingPromotionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOfferingPromotionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotEligibleException" : self = .notEligibleException(try NotEligibleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOfferingPromotionsOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notEligibleException(NotEligibleException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOfferingPromotionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOfferingPromotionsOutputResponse(nextToken: \(String(describing: nextToken)), offeringPromotions: \(String(describing: offeringPromotions)))"}
}

extension ListOfferingPromotionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListOfferingPromotionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.offeringPromotions = output.offeringPromotions
        } else {
            self.nextToken = nil
            self.offeringPromotions = nil
        }
    }
}

public struct ListOfferingPromotionsOutputResponse: Equatable {
    /// <p>An identifier to be used in the next call to this operation, to return the next set
    ///             of items in the list.</p>
    public let nextToken: String?
    /// <p>Information about the offering promotions.</p>
    public let offeringPromotions: [OfferingPromotion]?

    public init (
        nextToken: String? = nil,
        offeringPromotions: [OfferingPromotion]? = nil
    )
    {
        self.nextToken = nextToken
        self.offeringPromotions = offeringPromotions
    }
}

struct ListOfferingPromotionsOutputResponseBody: Equatable {
    public let offeringPromotions: [OfferingPromotion]?
    public let nextToken: String?
}

extension ListOfferingPromotionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case offeringPromotions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringPromotionsContainer = try containerValues.decodeIfPresent([OfferingPromotion?].self, forKey: .offeringPromotions)
        var offeringPromotionsDecoded0:[OfferingPromotion]? = nil
        if let offeringPromotionsContainer = offeringPromotionsContainer {
            offeringPromotionsDecoded0 = [OfferingPromotion]()
            for structure0 in offeringPromotionsContainer {
                if let structure0 = structure0 {
                    offeringPromotionsDecoded0?.append(structure0)
                }
            }
        }
        offeringPromotions = offeringPromotionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListOfferingTransactionsInputBodyMiddleware: Middleware {
    public let id: String = "ListOfferingTransactionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOfferingTransactionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOfferingTransactionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOfferingTransactionsInput>
    public typealias MOutput = OperationOutput<ListOfferingTransactionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOfferingTransactionsOutputError>
}

extension ListOfferingTransactionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOfferingTransactionsInput(nextToken: \(String(describing: nextToken)))"}
}

extension ListOfferingTransactionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListOfferingTransactionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListOfferingTransactionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOfferingTransactionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOfferingTransactionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOfferingTransactionsInput>
    public typealias MOutput = OperationOutput<ListOfferingTransactionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOfferingTransactionsOutputError>
}

public struct ListOfferingTransactionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListOfferingTransactionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOfferingTransactionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOfferingTransactionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOfferingTransactionsInput>
    public typealias MOutput = OperationOutput<ListOfferingTransactionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOfferingTransactionsOutputError>
}

/// <p>Represents the request to list the offering transaction history.</p>
public struct ListOfferingTransactionsInput: Equatable {
    /// <p>An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.</p>
    public let nextToken: String?

    public init (
        nextToken: String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListOfferingTransactionsInputBody: Equatable {
    public let nextToken: String?
}

extension ListOfferingTransactionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOfferingTransactionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOfferingTransactionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotEligibleException" : self = .notEligibleException(try NotEligibleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOfferingTransactionsOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notEligibleException(NotEligibleException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOfferingTransactionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOfferingTransactionsOutputResponse(nextToken: \(String(describing: nextToken)), offeringTransactions: \(String(describing: offeringTransactions)))"}
}

extension ListOfferingTransactionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListOfferingTransactionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.offeringTransactions = output.offeringTransactions
        } else {
            self.nextToken = nil
            self.offeringTransactions = nil
        }
    }
}

/// <p>Returns the transaction log of the specified offerings.</p>
public struct ListOfferingTransactionsOutputResponse: Equatable {
    /// <p>An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.</p>
    public let nextToken: String?
    /// <p>The audit log of subscriptions you have purchased and modified through AWS Device
    ///             Farm.</p>
    public let offeringTransactions: [OfferingTransaction]?

    public init (
        nextToken: String? = nil,
        offeringTransactions: [OfferingTransaction]? = nil
    )
    {
        self.nextToken = nextToken
        self.offeringTransactions = offeringTransactions
    }
}

struct ListOfferingTransactionsOutputResponseBody: Equatable {
    public let offeringTransactions: [OfferingTransaction]?
    public let nextToken: String?
}

extension ListOfferingTransactionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case offeringTransactions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringTransactionsContainer = try containerValues.decodeIfPresent([OfferingTransaction?].self, forKey: .offeringTransactions)
        var offeringTransactionsDecoded0:[OfferingTransaction]? = nil
        if let offeringTransactionsContainer = offeringTransactionsContainer {
            offeringTransactionsDecoded0 = [OfferingTransaction]()
            for structure0 in offeringTransactionsContainer {
                if let structure0 = structure0 {
                    offeringTransactionsDecoded0?.append(structure0)
                }
            }
        }
        offeringTransactions = offeringTransactionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListOfferingsInputBodyMiddleware: Middleware {
    public let id: String = "ListOfferingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOfferingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOfferingsInput>
    public typealias MOutput = OperationOutput<ListOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOfferingsOutputError>
}

extension ListOfferingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOfferingsInput(nextToken: \(String(describing: nextToken)))"}
}

extension ListOfferingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListOfferingsInputHeadersMiddleware: Middleware {
    public let id: String = "ListOfferingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOfferingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOfferingsInput>
    public typealias MOutput = OperationOutput<ListOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOfferingsOutputError>
}

public struct ListOfferingsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListOfferingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOfferingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOfferingsInput>
    public typealias MOutput = OperationOutput<ListOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOfferingsOutputError>
}

/// <p>Represents the request to list all offerings.</p>
public struct ListOfferingsInput: Equatable {
    /// <p>An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.</p>
    public let nextToken: String?

    public init (
        nextToken: String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListOfferingsInputBody: Equatable {
    public let nextToken: String?
}

extension ListOfferingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOfferingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOfferingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotEligibleException" : self = .notEligibleException(try NotEligibleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOfferingsOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notEligibleException(NotEligibleException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOfferingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOfferingsOutputResponse(nextToken: \(String(describing: nextToken)), offerings: \(String(describing: offerings)))"}
}

extension ListOfferingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListOfferingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.offerings = output.offerings
        } else {
            self.nextToken = nil
            self.offerings = nil
        }
    }
}

/// <p>Represents the return values of the list of offerings.</p>
public struct ListOfferingsOutputResponse: Equatable {
    /// <p>An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.</p>
    public let nextToken: String?
    /// <p>A value that represents the list offering results.</p>
    public let offerings: [Offering]?

    public init (
        nextToken: String? = nil,
        offerings: [Offering]? = nil
    )
    {
        self.nextToken = nextToken
        self.offerings = offerings
    }
}

struct ListOfferingsOutputResponseBody: Equatable {
    public let offerings: [Offering]?
    public let nextToken: String?
}

extension ListOfferingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case offerings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringsContainer = try containerValues.decodeIfPresent([Offering?].self, forKey: .offerings)
        var offeringsDecoded0:[Offering]? = nil
        if let offeringsContainer = offeringsContainer {
            offeringsDecoded0 = [Offering]()
            for structure0 in offeringsContainer {
                if let structure0 = structure0 {
                    offeringsDecoded0?.append(structure0)
                }
            }
        }
        offerings = offeringsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListProjectsInputBodyMiddleware: Middleware {
    public let id: String = "ListProjectsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProjectsInput>
    public typealias MOutput = OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProjectsOutputError>
}

extension ListProjectsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProjectsInput(arn: \(String(describing: arn)), nextToken: \(String(describing: nextToken)))"}
}

extension ListProjectsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListProjectsInputHeadersMiddleware: Middleware {
    public let id: String = "ListProjectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProjectsInput>
    public typealias MOutput = OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProjectsOutputError>
}

public struct ListProjectsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProjectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProjectsInput>
    public typealias MOutput = OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProjectsOutputError>
}

/// <p>Represents a request to the list projects operation.</p>
public struct ListProjectsInput: Equatable {
    /// <p>Optional. If no Amazon Resource Name (ARN) is specified, then AWS Device Farm
    ///             returns a list of all projects for the AWS account. You can also specify a project
    ///             ARN.</p>
    public let arn: String?
    /// <p>An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.</p>
    public let nextToken: String?

    public init (
        arn: String? = nil,
        nextToken: String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

struct ListProjectsInputBody: Equatable {
    public let arn: String?
    public let nextToken: String?
}

extension ListProjectsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProjectsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProjectsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProjectsOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProjectsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProjectsOutputResponse(nextToken: \(String(describing: nextToken)), projects: \(String(describing: projects)))"}
}

extension ListProjectsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProjectsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.projects = output.projects
        } else {
            self.nextToken = nil
            self.projects = nil
        }
    }
}

/// <p>Represents the result of a list projects request.</p>
public struct ListProjectsOutputResponse: Equatable {
    /// <p>If the number of items that are returned is significantly large, this is an identifier that is also
    ///             returned. It can be used in a subsequent call to this operation to return the next set of items in the
    ///             list.</p>
    public let nextToken: String?
    /// <p>Information about the projects.</p>
    public let projects: [Project]?

    public init (
        nextToken: String? = nil,
        projects: [Project]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

struct ListProjectsOutputResponseBody: Equatable {
    public let projects: [Project]?
    public let nextToken: String?
}

extension ListProjectsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case projects
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectsContainer = try containerValues.decodeIfPresent([Project?].self, forKey: .projects)
        var projectsDecoded0:[Project]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [Project]()
            for structure0 in projectsContainer {
                if let structure0 = structure0 {
                    projectsDecoded0?.append(structure0)
                }
            }
        }
        projects = projectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListRemoteAccessSessionsInputBodyMiddleware: Middleware {
    public let id: String = "ListRemoteAccessSessionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRemoteAccessSessionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRemoteAccessSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRemoteAccessSessionsInput>
    public typealias MOutput = OperationOutput<ListRemoteAccessSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRemoteAccessSessionsOutputError>
}

extension ListRemoteAccessSessionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRemoteAccessSessionsInput(arn: \(String(describing: arn)), nextToken: \(String(describing: nextToken)))"}
}

extension ListRemoteAccessSessionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListRemoteAccessSessionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListRemoteAccessSessionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRemoteAccessSessionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRemoteAccessSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRemoteAccessSessionsInput>
    public typealias MOutput = OperationOutput<ListRemoteAccessSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRemoteAccessSessionsOutputError>
}

public struct ListRemoteAccessSessionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRemoteAccessSessionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRemoteAccessSessionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRemoteAccessSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRemoteAccessSessionsInput>
    public typealias MOutput = OperationOutput<ListRemoteAccessSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRemoteAccessSessionsOutputError>
}

/// <p>Represents the request to return information about the remote access
///             session.</p>
public struct ListRemoteAccessSessionsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the project about which you are requesting
    ///             information.</p>
    public let arn: String?
    /// <p>An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.</p>
    public let nextToken: String?

    public init (
        arn: String? = nil,
        nextToken: String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

struct ListRemoteAccessSessionsInputBody: Equatable {
    public let arn: String?
    public let nextToken: String?
}

extension ListRemoteAccessSessionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRemoteAccessSessionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRemoteAccessSessionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRemoteAccessSessionsOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRemoteAccessSessionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRemoteAccessSessionsOutputResponse(nextToken: \(String(describing: nextToken)), remoteAccessSessions: \(String(describing: remoteAccessSessions)))"}
}

extension ListRemoteAccessSessionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRemoteAccessSessionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.remoteAccessSessions = output.remoteAccessSessions
        } else {
            self.nextToken = nil
            self.remoteAccessSessions = nil
        }
    }
}

/// <p>Represents the response from the server after AWS Device Farm makes a request to
///             return information about the remote access session.</p>
public struct ListRemoteAccessSessionsOutputResponse: Equatable {
    /// <p>An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.</p>
    public let nextToken: String?
    /// <p>A container that represents the metadata from the service about each remote access session you are
    ///             requesting.</p>
    public let remoteAccessSessions: [RemoteAccessSession]?

    public init (
        nextToken: String? = nil,
        remoteAccessSessions: [RemoteAccessSession]? = nil
    )
    {
        self.nextToken = nextToken
        self.remoteAccessSessions = remoteAccessSessions
    }
}

struct ListRemoteAccessSessionsOutputResponseBody: Equatable {
    public let remoteAccessSessions: [RemoteAccessSession]?
    public let nextToken: String?
}

extension ListRemoteAccessSessionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case remoteAccessSessions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remoteAccessSessionsContainer = try containerValues.decodeIfPresent([RemoteAccessSession?].self, forKey: .remoteAccessSessions)
        var remoteAccessSessionsDecoded0:[RemoteAccessSession]? = nil
        if let remoteAccessSessionsContainer = remoteAccessSessionsContainer {
            remoteAccessSessionsDecoded0 = [RemoteAccessSession]()
            for structure0 in remoteAccessSessionsContainer {
                if let structure0 = structure0 {
                    remoteAccessSessionsDecoded0?.append(structure0)
                }
            }
        }
        remoteAccessSessions = remoteAccessSessionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListRunsInputBodyMiddleware: Middleware {
    public let id: String = "ListRunsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRunsInput>
    public typealias MOutput = OperationOutput<ListRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRunsOutputError>
}

extension ListRunsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRunsInput(arn: \(String(describing: arn)), nextToken: \(String(describing: nextToken)))"}
}

extension ListRunsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListRunsInputHeadersMiddleware: Middleware {
    public let id: String = "ListRunsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRunsInput>
    public typealias MOutput = OperationOutput<ListRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRunsOutputError>
}

public struct ListRunsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRunsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRunsInput>
    public typealias MOutput = OperationOutput<ListRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRunsOutputError>
}

/// <p>Represents a request to the list runs operation.</p>
public struct ListRunsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the project for which you want to list
    ///             runs.</p>
    public let arn: String?
    /// <p>An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.</p>
    public let nextToken: String?

    public init (
        arn: String? = nil,
        nextToken: String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

struct ListRunsInputBody: Equatable {
    public let arn: String?
    public let nextToken: String?
}

extension ListRunsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRunsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRunsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRunsOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRunsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRunsOutputResponse(nextToken: \(String(describing: nextToken)), runs: \(String(describing: runs)))"}
}

extension ListRunsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRunsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.runs = output.runs
        } else {
            self.nextToken = nil
            self.runs = nil
        }
    }
}

/// <p>Represents the result of a list runs request.</p>
public struct ListRunsOutputResponse: Equatable {
    /// <p>If the number of items that are returned is significantly large, this is an identifier that is also
    ///             returned. It can be used in a subsequent call to this operation to return the next set of items in the
    ///             list.</p>
    public let nextToken: String?
    /// <p>Information about the runs.</p>
    public let runs: [Run]?

    public init (
        nextToken: String? = nil,
        runs: [Run]? = nil
    )
    {
        self.nextToken = nextToken
        self.runs = runs
    }
}

struct ListRunsOutputResponseBody: Equatable {
    public let runs: [Run]?
    public let nextToken: String?
}

extension ListRunsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case runs
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runsContainer = try containerValues.decodeIfPresent([Run?].self, forKey: .runs)
        var runsDecoded0:[Run]? = nil
        if let runsContainer = runsContainer {
            runsDecoded0 = [Run]()
            for structure0 in runsContainer {
                if let structure0 = structure0 {
                    runsDecoded0?.append(structure0)
                }
            }
        }
        runs = runsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSamplesInputBodyMiddleware: Middleware {
    public let id: String = "ListSamplesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSamplesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSamplesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSamplesInput>
    public typealias MOutput = OperationOutput<ListSamplesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSamplesOutputError>
}

extension ListSamplesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSamplesInput(arn: \(String(describing: arn)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSamplesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListSamplesInputHeadersMiddleware: Middleware {
    public let id: String = "ListSamplesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSamplesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSamplesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSamplesInput>
    public typealias MOutput = OperationOutput<ListSamplesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSamplesOutputError>
}

public struct ListSamplesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSamplesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSamplesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSamplesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSamplesInput>
    public typealias MOutput = OperationOutput<ListSamplesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSamplesOutputError>
}

/// <p>Represents a request to the list samples operation.</p>
public struct ListSamplesInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the job used to list samples.</p>
    public let arn: String?
    /// <p>An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.</p>
    public let nextToken: String?

    public init (
        arn: String? = nil,
        nextToken: String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

struct ListSamplesInputBody: Equatable {
    public let arn: String?
    public let nextToken: String?
}

extension ListSamplesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSamplesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSamplesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSamplesOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSamplesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSamplesOutputResponse(nextToken: \(String(describing: nextToken)), samples: \(String(describing: samples)))"}
}

extension ListSamplesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSamplesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.samples = output.samples
        } else {
            self.nextToken = nil
            self.samples = nil
        }
    }
}

/// <p>Represents the result of a list samples request.</p>
public struct ListSamplesOutputResponse: Equatable {
    /// <p>If the number of items that are returned is significantly large, this is an identifier that is also
    ///             returned. It can be used in a subsequent call to this operation to return the next set of items in the
    ///             list.</p>
    public let nextToken: String?
    /// <p>Information about the samples.</p>
    public let samples: [Sample]?

    public init (
        nextToken: String? = nil,
        samples: [Sample]? = nil
    )
    {
        self.nextToken = nextToken
        self.samples = samples
    }
}

struct ListSamplesOutputResponseBody: Equatable {
    public let samples: [Sample]?
    public let nextToken: String?
}

extension ListSamplesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case samples
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samplesContainer = try containerValues.decodeIfPresent([Sample?].self, forKey: .samples)
        var samplesDecoded0:[Sample]? = nil
        if let samplesContainer = samplesContainer {
            samplesDecoded0 = [Sample]()
            for structure0 in samplesContainer {
                if let structure0 = structure0 {
                    samplesDecoded0?.append(structure0)
                }
            }
        }
        samples = samplesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSuitesInputBodyMiddleware: Middleware {
    public let id: String = "ListSuitesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSuitesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSuitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSuitesInput>
    public typealias MOutput = OperationOutput<ListSuitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSuitesOutputError>
}

extension ListSuitesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSuitesInput(arn: \(String(describing: arn)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSuitesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListSuitesInputHeadersMiddleware: Middleware {
    public let id: String = "ListSuitesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSuitesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSuitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSuitesInput>
    public typealias MOutput = OperationOutput<ListSuitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSuitesOutputError>
}

public struct ListSuitesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSuitesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSuitesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSuitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSuitesInput>
    public typealias MOutput = OperationOutput<ListSuitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSuitesOutputError>
}

/// <p>Represents a request to the list suites operation.</p>
public struct ListSuitesInput: Equatable {
    /// <p>The job's Amazon Resource Name (ARN).</p>
    public let arn: String?
    /// <p>An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.</p>
    public let nextToken: String?

    public init (
        arn: String? = nil,
        nextToken: String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

struct ListSuitesInputBody: Equatable {
    public let arn: String?
    public let nextToken: String?
}

extension ListSuitesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSuitesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSuitesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSuitesOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSuitesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSuitesOutputResponse(nextToken: \(String(describing: nextToken)), suites: \(String(describing: suites)))"}
}

extension ListSuitesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSuitesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.suites = output.suites
        } else {
            self.nextToken = nil
            self.suites = nil
        }
    }
}

/// <p>Represents the result of a list suites request.</p>
public struct ListSuitesOutputResponse: Equatable {
    /// <p>If the number of items that are returned is significantly large, this is an identifier that is also
    ///             returned. It can be used in a subsequent call to this operation to return the next set of items in the
    ///             list.</p>
    public let nextToken: String?
    /// <p>Information about the suites.</p>
    public let suites: [Suite]?

    public init (
        nextToken: String? = nil,
        suites: [Suite]? = nil
    )
    {
        self.nextToken = nextToken
        self.suites = suites
    }
}

struct ListSuitesOutputResponseBody: Equatable {
    public let suites: [Suite]?
    public let nextToken: String?
}

extension ListSuitesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case suites
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suitesContainer = try containerValues.decodeIfPresent([Suite?].self, forKey: .suites)
        var suitesDecoded0:[Suite]? = nil
        if let suitesContainer = suitesContainer {
            suitesDecoded0 = [Suite]()
            for structure0 in suitesContainer {
                if let structure0 = structure0 {
                    suitesDecoded0?.append(structure0)
                }
            }
        }
        suites = suitesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceARN: \(String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource or resources for which to list tags. You can associate tags
    ///             with the following Device Farm resources: <code>PROJECT</code>, <code>RUN</code>,
    ///                 <code>NETWORK_PROFILE</code>, <code>INSTANCE_PROFILE</code>, <code>DEVICE_INSTANCE</code>,
    ///                 <code>SESSION</code>, <code>DEVICE_POOL</code>, <code>DEVICE</code>, and
    ///             <code>VPCE_CONFIGURATION</code>.</p>
    public let resourceARN: String?

    public init (
        resourceARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceARN: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOperationException" : self = .tagOperationException(try TagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case argumentException(ArgumentException)
    case notFoundException(NotFoundException)
    case tagOperationException(TagOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum
    ///             character length of 128 characters. Tag values can have a maximum length of 256 characters.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct ListTestGridProjectsInputBodyMiddleware: Middleware {
    public let id: String = "ListTestGridProjectsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTestGridProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTestGridProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTestGridProjectsInput>
    public typealias MOutput = OperationOutput<ListTestGridProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTestGridProjectsOutputError>
}

extension ListTestGridProjectsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTestGridProjectsInput(maxResult: \(String(describing: maxResult)), nextToken: \(String(describing: nextToken)))"}
}

extension ListTestGridProjectsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResult
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResult = maxResult {
            try encodeContainer.encode(maxResult, forKey: .maxResult)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTestGridProjectsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTestGridProjectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTestGridProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTestGridProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTestGridProjectsInput>
    public typealias MOutput = OperationOutput<ListTestGridProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTestGridProjectsOutputError>
}

public struct ListTestGridProjectsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTestGridProjectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTestGridProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTestGridProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTestGridProjectsInput>
    public typealias MOutput = OperationOutput<ListTestGridProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTestGridProjectsOutputError>
}

public struct ListTestGridProjectsInput: Equatable {
    /// <p>Return no more than this number of results.</p>
    public let maxResult: Int?
    /// <p>From a response, used to continue a paginated listing. </p>
    public let nextToken: String?

    public init (
        maxResult: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResult = maxResult
        self.nextToken = nextToken
    }
}

struct ListTestGridProjectsInputBody: Equatable {
    public let maxResult: Int?
    public let nextToken: String?
}

extension ListTestGridProjectsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResult
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResult)
        maxResult = maxResultDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTestGridProjectsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTestGridProjectsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTestGridProjectsOutputError: Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTestGridProjectsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTestGridProjectsOutputResponse(nextToken: \(String(describing: nextToken)), testGridProjects: \(String(describing: testGridProjects)))"}
}

extension ListTestGridProjectsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTestGridProjectsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.testGridProjects = output.testGridProjects
        } else {
            self.nextToken = nil
            self.testGridProjects = nil
        }
    }
}

public struct ListTestGridProjectsOutputResponse: Equatable {
    /// <p>Used for pagination. Pass into <a>ListTestGridProjects</a> to get more results in a paginated
    ///          request.</p>
    public let nextToken: String?
    /// <p>The list of TestGridProjects, based on a <a>ListTestGridProjectsRequest</a>.</p>
    public let testGridProjects: [TestGridProject]?

    public init (
        nextToken: String? = nil,
        testGridProjects: [TestGridProject]? = nil
    )
    {
        self.nextToken = nextToken
        self.testGridProjects = testGridProjects
    }
}

struct ListTestGridProjectsOutputResponseBody: Equatable {
    public let testGridProjects: [TestGridProject]?
    public let nextToken: String?
}

extension ListTestGridProjectsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case testGridProjects
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testGridProjectsContainer = try containerValues.decodeIfPresent([TestGridProject?].self, forKey: .testGridProjects)
        var testGridProjectsDecoded0:[TestGridProject]? = nil
        if let testGridProjectsContainer = testGridProjectsContainer {
            testGridProjectsDecoded0 = [TestGridProject]()
            for structure0 in testGridProjectsContainer {
                if let structure0 = structure0 {
                    testGridProjectsDecoded0?.append(structure0)
                }
            }
        }
        testGridProjects = testGridProjectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTestGridSessionActionsInputBodyMiddleware: Middleware {
    public let id: String = "ListTestGridSessionActionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTestGridSessionActionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTestGridSessionActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTestGridSessionActionsInput>
    public typealias MOutput = OperationOutput<ListTestGridSessionActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTestGridSessionActionsOutputError>
}

extension ListTestGridSessionActionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTestGridSessionActionsInput(maxResult: \(String(describing: maxResult)), nextToken: \(String(describing: nextToken)), sessionArn: \(String(describing: sessionArn)))"}
}

extension ListTestGridSessionActionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResult
        case nextToken
        case sessionArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResult = maxResult {
            try encodeContainer.encode(maxResult, forKey: .maxResult)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sessionArn = sessionArn {
            try encodeContainer.encode(sessionArn, forKey: .sessionArn)
        }
    }
}

public struct ListTestGridSessionActionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTestGridSessionActionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTestGridSessionActionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTestGridSessionActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTestGridSessionActionsInput>
    public typealias MOutput = OperationOutput<ListTestGridSessionActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTestGridSessionActionsOutputError>
}

public struct ListTestGridSessionActionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTestGridSessionActionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTestGridSessionActionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTestGridSessionActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTestGridSessionActionsInput>
    public typealias MOutput = OperationOutput<ListTestGridSessionActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTestGridSessionActionsOutputError>
}

public struct ListTestGridSessionActionsInput: Equatable {
    /// <p>The maximum number of sessions to return per response.</p>
    public let maxResult: Int?
    /// <p>Pagination token.</p>
    public let nextToken: String?
    /// <p>The ARN of the session to retrieve.</p>
    public let sessionArn: String?

    public init (
        maxResult: Int? = nil,
        nextToken: String? = nil,
        sessionArn: String? = nil
    )
    {
        self.maxResult = maxResult
        self.nextToken = nextToken
        self.sessionArn = sessionArn
    }
}

struct ListTestGridSessionActionsInputBody: Equatable {
    public let sessionArn: String?
    public let maxResult: Int?
    public let nextToken: String?
}

extension ListTestGridSessionActionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResult
        case nextToken
        case sessionArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionArn)
        sessionArn = sessionArnDecoded
        let maxResultDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResult)
        maxResult = maxResultDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTestGridSessionActionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTestGridSessionActionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTestGridSessionActionsOutputError: Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTestGridSessionActionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTestGridSessionActionsOutputResponse(actions: \(String(describing: actions)), nextToken: \(String(describing: nextToken)))"}
}

extension ListTestGridSessionActionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTestGridSessionActionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.actions = output.actions
            self.nextToken = output.nextToken
        } else {
            self.actions = nil
            self.nextToken = nil
        }
    }
}

public struct ListTestGridSessionActionsOutputResponse: Equatable {
    /// <p>The action taken by the session.</p>
    public let actions: [TestGridSessionAction]?
    /// <p>Pagination token.</p>
    public let nextToken: String?

    public init (
        actions: [TestGridSessionAction]? = nil,
        nextToken: String? = nil
    )
    {
        self.actions = actions
        self.nextToken = nextToken
    }
}

struct ListTestGridSessionActionsOutputResponseBody: Equatable {
    public let actions: [TestGridSessionAction]?
    public let nextToken: String?
}

extension ListTestGridSessionActionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actions
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsContainer = try containerValues.decodeIfPresent([TestGridSessionAction?].self, forKey: .actions)
        var actionsDecoded0:[TestGridSessionAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [TestGridSessionAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTestGridSessionArtifactsInputBodyMiddleware: Middleware {
    public let id: String = "ListTestGridSessionArtifactsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTestGridSessionArtifactsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTestGridSessionArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTestGridSessionArtifactsInput>
    public typealias MOutput = OperationOutput<ListTestGridSessionArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTestGridSessionArtifactsOutputError>
}

extension ListTestGridSessionArtifactsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTestGridSessionArtifactsInput(maxResult: \(String(describing: maxResult)), nextToken: \(String(describing: nextToken)), sessionArn: \(String(describing: sessionArn)), type: \(String(describing: type)))"}
}

extension ListTestGridSessionArtifactsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResult
        case nextToken
        case sessionArn
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResult = maxResult {
            try encodeContainer.encode(maxResult, forKey: .maxResult)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sessionArn = sessionArn {
            try encodeContainer.encode(sessionArn, forKey: .sessionArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct ListTestGridSessionArtifactsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTestGridSessionArtifactsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTestGridSessionArtifactsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTestGridSessionArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTestGridSessionArtifactsInput>
    public typealias MOutput = OperationOutput<ListTestGridSessionArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTestGridSessionArtifactsOutputError>
}

public struct ListTestGridSessionArtifactsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTestGridSessionArtifactsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTestGridSessionArtifactsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTestGridSessionArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTestGridSessionArtifactsInput>
    public typealias MOutput = OperationOutput<ListTestGridSessionArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTestGridSessionArtifactsOutputError>
}

public struct ListTestGridSessionArtifactsInput: Equatable {
    /// <p>The maximum number of results to be returned by a request.</p>
    public let maxResult: Int?
    /// <p>Pagination token.</p>
    public let nextToken: String?
    /// <p>The ARN of a <a>TestGridSession</a>. </p>
    public let sessionArn: String?
    /// <p>Limit results to a specified type of artifact.</p>
    public let type: TestGridSessionArtifactCategory?

    public init (
        maxResult: Int? = nil,
        nextToken: String? = nil,
        sessionArn: String? = nil,
        type: TestGridSessionArtifactCategory? = nil
    )
    {
        self.maxResult = maxResult
        self.nextToken = nextToken
        self.sessionArn = sessionArn
        self.type = type
    }
}

struct ListTestGridSessionArtifactsInputBody: Equatable {
    public let sessionArn: String?
    public let type: TestGridSessionArtifactCategory?
    public let maxResult: Int?
    public let nextToken: String?
}

extension ListTestGridSessionArtifactsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResult
        case nextToken
        case sessionArn
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionArn)
        sessionArn = sessionArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TestGridSessionArtifactCategory.self, forKey: .type)
        type = typeDecoded
        let maxResultDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResult)
        maxResult = maxResultDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTestGridSessionArtifactsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTestGridSessionArtifactsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTestGridSessionArtifactsOutputError: Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTestGridSessionArtifactsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTestGridSessionArtifactsOutputResponse(artifacts: \(String(describing: artifacts)), nextToken: \(String(describing: nextToken)))"}
}

extension ListTestGridSessionArtifactsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTestGridSessionArtifactsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.artifacts = output.artifacts
            self.nextToken = output.nextToken
        } else {
            self.artifacts = nil
            self.nextToken = nil
        }
    }
}

public struct ListTestGridSessionArtifactsOutputResponse: Equatable {
    /// <p>A list of test grid session artifacts for a <a>TestGridSession</a>.</p>
    public let artifacts: [TestGridSessionArtifact]?
    /// <p>Pagination token.</p>
    public let nextToken: String?

    public init (
        artifacts: [TestGridSessionArtifact]? = nil,
        nextToken: String? = nil
    )
    {
        self.artifacts = artifacts
        self.nextToken = nextToken
    }
}

struct ListTestGridSessionArtifactsOutputResponseBody: Equatable {
    public let artifacts: [TestGridSessionArtifact]?
    public let nextToken: String?
}

extension ListTestGridSessionArtifactsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case artifacts
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let artifactsContainer = try containerValues.decodeIfPresent([TestGridSessionArtifact?].self, forKey: .artifacts)
        var artifactsDecoded0:[TestGridSessionArtifact]? = nil
        if let artifactsContainer = artifactsContainer {
            artifactsDecoded0 = [TestGridSessionArtifact]()
            for structure0 in artifactsContainer {
                if let structure0 = structure0 {
                    artifactsDecoded0?.append(structure0)
                }
            }
        }
        artifacts = artifactsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTestGridSessionsInputBodyMiddleware: Middleware {
    public let id: String = "ListTestGridSessionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTestGridSessionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTestGridSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTestGridSessionsInput>
    public typealias MOutput = OperationOutput<ListTestGridSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTestGridSessionsOutputError>
}

extension ListTestGridSessionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTestGridSessionsInput(creationTimeAfter: \(String(describing: creationTimeAfter)), creationTimeBefore: \(String(describing: creationTimeBefore)), endTimeAfter: \(String(describing: endTimeAfter)), endTimeBefore: \(String(describing: endTimeBefore)), maxResult: \(String(describing: maxResult)), nextToken: \(String(describing: nextToken)), projectArn: \(String(describing: projectArn)), status: \(String(describing: status)))"}
}

extension ListTestGridSessionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTimeAfter
        case creationTimeBefore
        case endTimeAfter
        case endTimeBefore
        case maxResult
        case nextToken
        case projectArn
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimeAfter = creationTimeAfter {
            try encodeContainer.encode(creationTimeAfter.timeIntervalSince1970, forKey: .creationTimeAfter)
        }
        if let creationTimeBefore = creationTimeBefore {
            try encodeContainer.encode(creationTimeBefore.timeIntervalSince1970, forKey: .creationTimeBefore)
        }
        if let endTimeAfter = endTimeAfter {
            try encodeContainer.encode(endTimeAfter.timeIntervalSince1970, forKey: .endTimeAfter)
        }
        if let endTimeBefore = endTimeBefore {
            try encodeContainer.encode(endTimeBefore.timeIntervalSince1970, forKey: .endTimeBefore)
        }
        if let maxResult = maxResult {
            try encodeContainer.encode(maxResult, forKey: .maxResult)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct ListTestGridSessionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTestGridSessionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTestGridSessionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTestGridSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTestGridSessionsInput>
    public typealias MOutput = OperationOutput<ListTestGridSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTestGridSessionsOutputError>
}

public struct ListTestGridSessionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTestGridSessionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTestGridSessionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTestGridSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTestGridSessionsInput>
    public typealias MOutput = OperationOutput<ListTestGridSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTestGridSessionsOutputError>
}

public struct ListTestGridSessionsInput: Equatable {
    /// <p>Return only sessions created after this time.</p>
    public let creationTimeAfter: Date?
    /// <p>Return only  sessions created before this time.</p>
    public let creationTimeBefore: Date?
    /// <p>Return only sessions that ended after this time.</p>
    public let endTimeAfter: Date?
    /// <p>Return only sessions that ended before this time.</p>
    public let endTimeBefore: Date?
    /// <p>Return only this many results at a time.</p>
    public let maxResult: Int?
    /// <p>Pagination token.</p>
    public let nextToken: String?
    /// <p>ARN of a <a>TestGridProject</a>.</p>
    public let projectArn: String?
    /// <p>Return only sessions in this state.</p>
    public let status: TestGridSessionStatus?

    public init (
        creationTimeAfter: Date? = nil,
        creationTimeBefore: Date? = nil,
        endTimeAfter: Date? = nil,
        endTimeBefore: Date? = nil,
        maxResult: Int? = nil,
        nextToken: String? = nil,
        projectArn: String? = nil,
        status: TestGridSessionStatus? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.endTimeAfter = endTimeAfter
        self.endTimeBefore = endTimeBefore
        self.maxResult = maxResult
        self.nextToken = nextToken
        self.projectArn = projectArn
        self.status = status
    }
}

struct ListTestGridSessionsInputBody: Equatable {
    public let projectArn: String?
    public let status: TestGridSessionStatus?
    public let creationTimeAfter: Date?
    public let creationTimeBefore: Date?
    public let endTimeAfter: Date?
    public let endTimeBefore: Date?
    public let maxResult: Int?
    public let nextToken: String?
}

extension ListTestGridSessionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationTimeAfter
        case creationTimeBefore
        case endTimeAfter
        case endTimeBefore
        case maxResult
        case nextToken
        case projectArn
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TestGridSessionStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeAfterDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTimeAfter)
        creationTimeAfter = creationTimeAfterDecoded
        let creationTimeBeforeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTimeBefore)
        creationTimeBefore = creationTimeBeforeDecoded
        let endTimeAfterDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTimeAfter)
        endTimeAfter = endTimeAfterDecoded
        let endTimeBeforeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTimeBefore)
        endTimeBefore = endTimeBeforeDecoded
        let maxResultDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResult)
        maxResult = maxResultDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTestGridSessionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTestGridSessionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTestGridSessionsOutputError: Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTestGridSessionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTestGridSessionsOutputResponse(nextToken: \(String(describing: nextToken)), testGridSessions: \(String(describing: testGridSessions)))"}
}

extension ListTestGridSessionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTestGridSessionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.testGridSessions = output.testGridSessions
        } else {
            self.nextToken = nil
            self.testGridSessions = nil
        }
    }
}

public struct ListTestGridSessionsOutputResponse: Equatable {
    /// <p>Pagination token.</p>
    public let nextToken: String?
    /// <p>The sessions that match the criteria in a <a>ListTestGridSessionsRequest</a>. </p>
    public let testGridSessions: [TestGridSession]?

    public init (
        nextToken: String? = nil,
        testGridSessions: [TestGridSession]? = nil
    )
    {
        self.nextToken = nextToken
        self.testGridSessions = testGridSessions
    }
}

struct ListTestGridSessionsOutputResponseBody: Equatable {
    public let testGridSessions: [TestGridSession]?
    public let nextToken: String?
}

extension ListTestGridSessionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case testGridSessions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testGridSessionsContainer = try containerValues.decodeIfPresent([TestGridSession?].self, forKey: .testGridSessions)
        var testGridSessionsDecoded0:[TestGridSession]? = nil
        if let testGridSessionsContainer = testGridSessionsContainer {
            testGridSessionsDecoded0 = [TestGridSession]()
            for structure0 in testGridSessionsContainer {
                if let structure0 = structure0 {
                    testGridSessionsDecoded0?.append(structure0)
                }
            }
        }
        testGridSessions = testGridSessionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTestsInputBodyMiddleware: Middleware {
    public let id: String = "ListTestsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTestsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTestsInput>
    public typealias MOutput = OperationOutput<ListTestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTestsOutputError>
}

extension ListTestsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTestsInput(arn: \(String(describing: arn)), nextToken: \(String(describing: nextToken)))"}
}

extension ListTestsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTestsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTestsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTestsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTestsInput>
    public typealias MOutput = OperationOutput<ListTestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTestsOutputError>
}

public struct ListTestsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTestsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTestsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTestsInput>
    public typealias MOutput = OperationOutput<ListTestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTestsOutputError>
}

/// <p>Represents a request to the list tests operation.</p>
public struct ListTestsInput: Equatable {
    /// <p>The test suite's Amazon Resource Name (ARN).</p>
    public let arn: String?
    /// <p>An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.</p>
    public let nextToken: String?

    public init (
        arn: String? = nil,
        nextToken: String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

struct ListTestsInputBody: Equatable {
    public let arn: String?
    public let nextToken: String?
}

extension ListTestsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTestsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTestsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTestsOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTestsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTestsOutputResponse(nextToken: \(String(describing: nextToken)), tests: \(String(describing: tests)))"}
}

extension ListTestsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTestsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tests = output.tests
        } else {
            self.nextToken = nil
            self.tests = nil
        }
    }
}

/// <p>Represents the result of a list tests request.</p>
public struct ListTestsOutputResponse: Equatable {
    /// <p>If the number of items that are returned is significantly large, this is an identifier that is also
    ///             returned. It can be used in a subsequent call to this operation to return the next set of items in the
    ///             list.</p>
    public let nextToken: String?
    /// <p>Information about the tests.</p>
    public let tests: [Test]?

    public init (
        nextToken: String? = nil,
        tests: [Test]? = nil
    )
    {
        self.nextToken = nextToken
        self.tests = tests
    }
}

struct ListTestsOutputResponseBody: Equatable {
    public let tests: [Test]?
    public let nextToken: String?
}

extension ListTestsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case tests
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testsContainer = try containerValues.decodeIfPresent([Test?].self, forKey: .tests)
        var testsDecoded0:[Test]? = nil
        if let testsContainer = testsContainer {
            testsDecoded0 = [Test]()
            for structure0 in testsContainer {
                if let structure0 = structure0 {
                    testsDecoded0?.append(structure0)
                }
            }
        }
        tests = testsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListUniqueProblemsInputBodyMiddleware: Middleware {
    public let id: String = "ListUniqueProblemsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUniqueProblemsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUniqueProblemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUniqueProblemsInput>
    public typealias MOutput = OperationOutput<ListUniqueProblemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUniqueProblemsOutputError>
}

extension ListUniqueProblemsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUniqueProblemsInput(arn: \(String(describing: arn)), nextToken: \(String(describing: nextToken)))"}
}

extension ListUniqueProblemsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListUniqueProblemsInputHeadersMiddleware: Middleware {
    public let id: String = "ListUniqueProblemsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUniqueProblemsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUniqueProblemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUniqueProblemsInput>
    public typealias MOutput = OperationOutput<ListUniqueProblemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUniqueProblemsOutputError>
}

public struct ListUniqueProblemsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListUniqueProblemsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUniqueProblemsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUniqueProblemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUniqueProblemsInput>
    public typealias MOutput = OperationOutput<ListUniqueProblemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUniqueProblemsOutputError>
}

/// <p>Represents a request to the list unique problems operation.</p>
public struct ListUniqueProblemsInput: Equatable {
    /// <p>The unique problems' ARNs.</p>
    public let arn: String?
    /// <p>An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.</p>
    public let nextToken: String?

    public init (
        arn: String? = nil,
        nextToken: String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

struct ListUniqueProblemsInputBody: Equatable {
    public let arn: String?
    public let nextToken: String?
}

extension ListUniqueProblemsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUniqueProblemsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUniqueProblemsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUniqueProblemsOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUniqueProblemsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUniqueProblemsOutputResponse(nextToken: \(String(describing: nextToken)), uniqueProblems: \(String(describing: uniqueProblems)))"}
}

extension ListUniqueProblemsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListUniqueProblemsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.uniqueProblems = output.uniqueProblems
        } else {
            self.nextToken = nil
            self.uniqueProblems = nil
        }
    }
}

/// <p>Represents the result of a list unique problems request.</p>
public struct ListUniqueProblemsOutputResponse: Equatable {
    /// <p>If the number of items that are returned is significantly large, this is an identifier that is also
    ///             returned. It can be used in a subsequent call to this operation to return the next set of items in the
    ///             list.</p>
    public let nextToken: String?
    /// <p>Information about the unique problems.</p>
    ///         <p>Allowed values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>PENDING</p>
    ///             </li>
    ///             <li>
    ///                 <p>PASSED</p>
    ///             </li>
    ///             <li>
    ///                 <p>WARNED</p>
    ///             </li>
    ///             <li>
    ///                 <p>FAILED</p>
    ///             </li>
    ///             <li>
    ///                 <p>SKIPPED</p>
    ///             </li>
    ///             <li>
    ///                 <p>ERRORED</p>
    ///             </li>
    ///             <li>
    ///                 <p>STOPPED</p>
    ///             </li>
    ///          </ul>
    public let uniqueProblems: [String:[UniqueProblem]]?

    public init (
        nextToken: String? = nil,
        uniqueProblems: [String:[UniqueProblem]]? = nil
    )
    {
        self.nextToken = nextToken
        self.uniqueProblems = uniqueProblems
    }
}

struct ListUniqueProblemsOutputResponseBody: Equatable {
    public let uniqueProblems: [String:[UniqueProblem]]?
    public let nextToken: String?
}

extension ListUniqueProblemsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case uniqueProblems
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uniqueProblemsContainer = try containerValues.decodeIfPresent([String: [UniqueProblem?]?].self, forKey: .uniqueProblems)
        var uniqueProblemsDecoded0: [String:[UniqueProblem]]? = nil
        if let uniqueProblemsContainer = uniqueProblemsContainer {
            uniqueProblemsDecoded0 = [String:[UniqueProblem]]()
            for (key0, uniqueproblems0) in uniqueProblemsContainer {
                var uniqueproblems0Decoded0: [UniqueProblem]? = nil
                if let uniqueproblems0 = uniqueproblems0 {
                    uniqueproblems0Decoded0 = [UniqueProblem]()
                    for structure1 in uniqueproblems0 {
                        if let structure1 = structure1 {
                            uniqueproblems0Decoded0?.append(structure1)
                        }
                    }
                }
                uniqueProblemsDecoded0?[key0] = uniqueproblems0Decoded0
            }
        }
        uniqueProblems = uniqueProblemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListUploadsInputBodyMiddleware: Middleware {
    public let id: String = "ListUploadsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUploadsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUploadsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUploadsInput>
    public typealias MOutput = OperationOutput<ListUploadsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUploadsOutputError>
}

extension ListUploadsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUploadsInput(arn: \(String(describing: arn)), nextToken: \(String(describing: nextToken)), type: \(String(describing: type)))"}
}

extension ListUploadsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case nextToken
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct ListUploadsInputHeadersMiddleware: Middleware {
    public let id: String = "ListUploadsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUploadsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUploadsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUploadsInput>
    public typealias MOutput = OperationOutput<ListUploadsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUploadsOutputError>
}

public struct ListUploadsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListUploadsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUploadsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUploadsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUploadsInput>
    public typealias MOutput = OperationOutput<ListUploadsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUploadsOutputError>
}

/// <p>Represents a request to the list uploads operation.</p>
public struct ListUploadsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the project for which you want to list
    ///             uploads.</p>
    public let arn: String?
    /// <p>An identifier that was returned from the previous call to this operation, which can
    ///             be used to return the next set of items in the list.</p>
    public let nextToken: String?
    /// <p>The type of upload.</p>
    ///         <p>Must be one of the following values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>ANDROID_APP</p>
    ///             </li>
    ///             <li>
    ///                 <p>IOS_APP</p>
    ///             </li>
    ///             <li>
    ///                 <p>WEB_APP</p>
    ///             </li>
    ///             <li>
    ///                 <p>EXTERNAL_DATA</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_JUNIT_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_TESTNG_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_PYTHON_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_NODE_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_RUBY_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_PYTHON_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_NODE_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_RUBY_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>CALABASH_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>INSTRUMENTATION_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>UIAUTOMATION_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>UIAUTOMATOR_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>XCTEST_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>XCTEST_UI_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_JUNIT_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_TESTNG_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_PYTHON_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_NODE_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p> APPIUM_RUBY_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_JAVA_JUNIT_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_JAVA_TESTNG_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_PYTHON_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_NODE_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_RUBY_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>INSTRUMENTATION_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>XCTEST_UI_TEST_SPEC</p>
    ///             </li>
    ///          </ul>
    public let type: UploadType?

    public init (
        arn: String? = nil,
        nextToken: String? = nil,
        type: UploadType? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListUploadsInputBody: Equatable {
    public let arn: String?
    public let type: UploadType?
    public let nextToken: String?
}

extension ListUploadsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case nextToken
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(UploadType.self, forKey: .type)
        type = typeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUploadsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUploadsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUploadsOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUploadsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUploadsOutputResponse(nextToken: \(String(describing: nextToken)), uploads: \(String(describing: uploads)))"}
}

extension ListUploadsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListUploadsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.uploads = output.uploads
        } else {
            self.nextToken = nil
            self.uploads = nil
        }
    }
}

/// <p>Represents the result of a list uploads request.</p>
public struct ListUploadsOutputResponse: Equatable {
    /// <p>If the number of items that are returned is significantly large, this is an identifier that is also
    ///             returned. It can be used in a subsequent call to this operation to return the next set of items in the
    ///             list.</p>
    public let nextToken: String?
    /// <p>Information about the uploads.</p>
    public let uploads: [Upload]?

    public init (
        nextToken: String? = nil,
        uploads: [Upload]? = nil
    )
    {
        self.nextToken = nextToken
        self.uploads = uploads
    }
}

struct ListUploadsOutputResponseBody: Equatable {
    public let uploads: [Upload]?
    public let nextToken: String?
}

extension ListUploadsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case uploads
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadsContainer = try containerValues.decodeIfPresent([Upload?].self, forKey: .uploads)
        var uploadsDecoded0:[Upload]? = nil
        if let uploadsContainer = uploadsContainer {
            uploadsDecoded0 = [Upload]()
            for structure0 in uploadsContainer {
                if let structure0 = structure0 {
                    uploadsDecoded0?.append(structure0)
                }
            }
        }
        uploads = uploadsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListVPCEConfigurationsInputBodyMiddleware: Middleware {
    public let id: String = "ListVPCEConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVPCEConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVPCEConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVPCEConfigurationsInput>
    public typealias MOutput = OperationOutput<ListVPCEConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVPCEConfigurationsOutputError>
}

extension ListVPCEConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVPCEConfigurationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListVPCEConfigurationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListVPCEConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListVPCEConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVPCEConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVPCEConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVPCEConfigurationsInput>
    public typealias MOutput = OperationOutput<ListVPCEConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVPCEConfigurationsOutputError>
}

public struct ListVPCEConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListVPCEConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVPCEConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVPCEConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVPCEConfigurationsInput>
    public typealias MOutput = OperationOutput<ListVPCEConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVPCEConfigurationsOutputError>
}

public struct ListVPCEConfigurationsInput: Equatable {
    /// <p>An integer that specifies the maximum number of items you want to return in the API response.</p>
    public let maxResults: Int?
    /// <p>An identifier that was returned from the previous call to this operation, which can be
    ///             used to return the next set of items in the list.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVPCEConfigurationsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListVPCEConfigurationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListVPCEConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVPCEConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVPCEConfigurationsOutputError: Equatable {
    case argumentException(ArgumentException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVPCEConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVPCEConfigurationsOutputResponse(nextToken: \(String(describing: nextToken)), vpceConfigurations: \(String(describing: vpceConfigurations)))"}
}

extension ListVPCEConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListVPCEConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.vpceConfigurations = output.vpceConfigurations
        } else {
            self.nextToken = nil
            self.vpceConfigurations = nil
        }
    }
}

public struct ListVPCEConfigurationsOutputResponse: Equatable {
    /// <p>An identifier that was returned from the previous call to this operation, which can be
    ///             used to return the next set of items in the list.</p>
    public let nextToken: String?
    /// <p>An array of <code>VPCEConfiguration</code> objects that contain information about your VPC endpoint
    ///             configuration.</p>
    public let vpceConfigurations: [VPCEConfiguration]?

    public init (
        nextToken: String? = nil,
        vpceConfigurations: [VPCEConfiguration]? = nil
    )
    {
        self.nextToken = nextToken
        self.vpceConfigurations = vpceConfigurations
    }
}

struct ListVPCEConfigurationsOutputResponseBody: Equatable {
    public let vpceConfigurations: [VPCEConfiguration]?
    public let nextToken: String?
}

extension ListVPCEConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case vpceConfigurations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpceConfigurationsContainer = try containerValues.decodeIfPresent([VPCEConfiguration?].self, forKey: .vpceConfigurations)
        var vpceConfigurationsDecoded0:[VPCEConfiguration]? = nil
        if let vpceConfigurationsContainer = vpceConfigurationsContainer {
            vpceConfigurationsDecoded0 = [VPCEConfiguration]()
            for structure0 in vpceConfigurationsContainer {
                if let structure0 = structure0 {
                    vpceConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        vpceConfigurations = vpceConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension Location: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case latitude
        case longitude
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let latitude = latitude {
            try encodeContainer.encode(latitude, forKey: .latitude)
        }
        if let longitude = longitude {
            try encodeContainer.encode(longitude, forKey: .longitude)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latitudeDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .latitude)
        latitude = latitudeDecoded
        let longitudeDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .longitude)
        longitude = longitudeDecoded
    }
}

extension Location: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Location(latitude: \(String(describing: latitude)), longitude: \(String(describing: longitude)))"}
}

/// <p>Represents a latitude and longitude pair, expressed in geographic coordinate system degrees (for
///             example, 47.6204, -122.3491).</p>
///         <p>Elevation is currently not supported.</p>
public struct Location: Equatable {
    /// <p>The latitude.</p>
    public let latitude: Double?
    /// <p>The longitude.</p>
    public let longitude: Double?

    public init (
        latitude: Double? = nil,
        longitude: Double? = nil
    )
    {
        self.latitude = latitude
        self.longitude = longitude
    }
}

extension MonetaryAmount: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amount
        case currencyCode
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amount = amount {
            try encodeContainer.encode(amount, forKey: .amount)
        }
        if let currencyCode = currencyCode {
            try encodeContainer.encode(currencyCode.rawValue, forKey: .currencyCode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amountDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .amount)
        amount = amountDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(CurrencyCode.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
    }
}

extension MonetaryAmount: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MonetaryAmount(amount: \(String(describing: amount)), currencyCode: \(String(describing: currencyCode)))"}
}

/// <p>A number that represents the monetary amount for an offering or transaction.</p>
public struct MonetaryAmount: Equatable {
    /// <p>The numerical amount of an offering or transaction.</p>
    public let amount: Double?
    /// <p>The currency code of a monetary amount. For example, <code>USD</code> means U.S. dollars.</p>
    public let currencyCode: CurrencyCode?

    public init (
        amount: Double? = nil,
        currencyCode: CurrencyCode? = nil
    )
    {
        self.amount = amount
        self.currencyCode = currencyCode
    }
}

extension NetworkProfile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case description
        case downlinkBandwidthBits
        case downlinkDelayMs
        case downlinkJitterMs
        case downlinkLossPercent
        case name
        case type
        case uplinkBandwidthBits
        case uplinkDelayMs
        case uplinkJitterMs
        case uplinkLossPercent
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let downlinkBandwidthBits = downlinkBandwidthBits {
            try encodeContainer.encode(downlinkBandwidthBits, forKey: .downlinkBandwidthBits)
        }
        if let downlinkDelayMs = downlinkDelayMs {
            try encodeContainer.encode(downlinkDelayMs, forKey: .downlinkDelayMs)
        }
        if let downlinkJitterMs = downlinkJitterMs {
            try encodeContainer.encode(downlinkJitterMs, forKey: .downlinkJitterMs)
        }
        if downlinkLossPercent != 0 {
            try encodeContainer.encode(downlinkLossPercent, forKey: .downlinkLossPercent)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uplinkBandwidthBits = uplinkBandwidthBits {
            try encodeContainer.encode(uplinkBandwidthBits, forKey: .uplinkBandwidthBits)
        }
        if let uplinkDelayMs = uplinkDelayMs {
            try encodeContainer.encode(uplinkDelayMs, forKey: .uplinkDelayMs)
        }
        if let uplinkJitterMs = uplinkJitterMs {
            try encodeContainer.encode(uplinkJitterMs, forKey: .uplinkJitterMs)
        }
        if uplinkLossPercent != 0 {
            try encodeContainer.encode(uplinkLossPercent, forKey: .uplinkLossPercent)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(NetworkProfileType.self, forKey: .type)
        type = typeDecoded
        let uplinkBandwidthBitsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .uplinkBandwidthBits)
        uplinkBandwidthBits = uplinkBandwidthBitsDecoded
        let downlinkBandwidthBitsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .downlinkBandwidthBits)
        downlinkBandwidthBits = downlinkBandwidthBitsDecoded
        let uplinkDelayMsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .uplinkDelayMs)
        uplinkDelayMs = uplinkDelayMsDecoded
        let downlinkDelayMsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .downlinkDelayMs)
        downlinkDelayMs = downlinkDelayMsDecoded
        let uplinkJitterMsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .uplinkJitterMs)
        uplinkJitterMs = uplinkJitterMsDecoded
        let downlinkJitterMsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .downlinkJitterMs)
        downlinkJitterMs = downlinkJitterMsDecoded
        let uplinkLossPercentDecoded = try containerValues.decode(Int.self, forKey: .uplinkLossPercent)
        uplinkLossPercent = uplinkLossPercentDecoded
        let downlinkLossPercentDecoded = try containerValues.decode(Int.self, forKey: .downlinkLossPercent)
        downlinkLossPercent = downlinkLossPercentDecoded
    }
}

extension NetworkProfile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NetworkProfile(arn: \(String(describing: arn)), description: \(String(describing: description)), downlinkBandwidthBits: \(String(describing: downlinkBandwidthBits)), downlinkDelayMs: \(String(describing: downlinkDelayMs)), downlinkJitterMs: \(String(describing: downlinkJitterMs)), downlinkLossPercent: \(String(describing: downlinkLossPercent)), name: \(String(describing: name)), type: \(String(describing: type)), uplinkBandwidthBits: \(String(describing: uplinkBandwidthBits)), uplinkDelayMs: \(String(describing: uplinkDelayMs)), uplinkJitterMs: \(String(describing: uplinkJitterMs)), uplinkLossPercent: \(String(describing: uplinkLossPercent)))"}
}

/// <p>An array of settings that describes characteristics of a network profile.</p>
public struct NetworkProfile: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the network profile.</p>
    public let arn: String?
    /// <p>The description of the network profile.</p>
    public let description: String?
    /// <p>The data throughput rate in bits per second, as an integer from 0 to
    ///             104857600.</p>
    public let downlinkBandwidthBits: Int?
    /// <p>Delay time for all packets to destination in milliseconds as an integer from 0 to
    ///             2000.</p>
    public let downlinkDelayMs: Int?
    /// <p>Time variation in the delay of received packets in milliseconds as an integer from
    ///             0 to 2000.</p>
    public let downlinkJitterMs: Int?
    /// <p>Proportion of received packets that fail to arrive from 0 to 100 percent.</p>
    public let downlinkLossPercent: Int
    /// <p>The name of the network profile.</p>
    public let name: String?
    /// <p>The type of network profile. Valid values are listed here.</p>
    public let type: NetworkProfileType?
    /// <p>The data throughput rate in bits per second, as an integer from 0 to
    ///             104857600.</p>
    public let uplinkBandwidthBits: Int?
    /// <p>Delay time for all packets to destination in milliseconds as an integer from 0 to
    ///             2000.</p>
    public let uplinkDelayMs: Int?
    /// <p>Time variation in the delay of received packets in milliseconds as an integer from
    ///             0 to 2000.</p>
    public let uplinkJitterMs: Int?
    /// <p>Proportion of transmitted packets that fail to arrive from 0 to 100
    ///             percent.</p>
    public let uplinkLossPercent: Int

    public init (
        arn: String? = nil,
        description: String? = nil,
        downlinkBandwidthBits: Int? = nil,
        downlinkDelayMs: Int? = nil,
        downlinkJitterMs: Int? = nil,
        downlinkLossPercent: Int = 0,
        name: String? = nil,
        type: NetworkProfileType? = nil,
        uplinkBandwidthBits: Int? = nil,
        uplinkDelayMs: Int? = nil,
        uplinkJitterMs: Int? = nil,
        uplinkLossPercent: Int = 0
    )
    {
        self.arn = arn
        self.description = description
        self.downlinkBandwidthBits = downlinkBandwidthBits
        self.downlinkDelayMs = downlinkDelayMs
        self.downlinkJitterMs = downlinkJitterMs
        self.downlinkLossPercent = downlinkLossPercent
        self.name = name
        self.type = type
        self.uplinkBandwidthBits = uplinkBandwidthBits
        self.uplinkDelayMs = uplinkDelayMs
        self.uplinkJitterMs = uplinkJitterMs
        self.uplinkLossPercent = uplinkLossPercent
    }
}

public enum NetworkProfileType {
    case curated
    case `private`
    case sdkUnknown(String)
}

extension NetworkProfileType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NetworkProfileType] {
        return [
            .curated,
            .private,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .curated: return "CURATED"
        case .private: return "PRIVATE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NetworkProfileType(rawValue: rawValue) ?? NetworkProfileType.sdkUnknown(rawValue)
    }
}

extension NotEligibleException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotEligibleException(message: \(String(describing: message)))"}
}

extension NotEligibleException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotEligibleExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exception gets thrown when a user is not eligible to perform the specified
///             transaction.</p>
public struct NotEligibleException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The HTTP response code of a Not Eligible exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotEligibleExceptionBody: Equatable {
    public let message: String?
}

extension NotEligibleExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified entity was not found.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any additional information about the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Offering: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case id
        case platform
        case recurringCharges
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let recurringCharges = recurringCharges {
            var recurringChargesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recurringCharges)
            for recurringcharges0 in recurringCharges {
                try recurringChargesContainer.encode(recurringcharges0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OfferingType.self, forKey: .type)
        type = typeDecoded
        let platformDecoded = try containerValues.decodeIfPresent(DevicePlatform.self, forKey: .platform)
        platform = platformDecoded
        let recurringChargesContainer = try containerValues.decodeIfPresent([RecurringCharge?].self, forKey: .recurringCharges)
        var recurringChargesDecoded0:[RecurringCharge]? = nil
        if let recurringChargesContainer = recurringChargesContainer {
            recurringChargesDecoded0 = [RecurringCharge]()
            for structure0 in recurringChargesContainer {
                if let structure0 = structure0 {
                    recurringChargesDecoded0?.append(structure0)
                }
            }
        }
        recurringCharges = recurringChargesDecoded0
    }
}

extension Offering: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Offering(description: \(String(describing: description)), id: \(String(describing: id)), platform: \(String(describing: platform)), recurringCharges: \(String(describing: recurringCharges)), type: \(String(describing: type)))"}
}

/// <p>Represents the metadata of a device offering.</p>
public struct Offering: Equatable {
    /// <p>A string that describes the offering.</p>
    public let description: String?
    /// <p>The ID that corresponds to a device offering.</p>
    public let id: String?
    /// <p>The platform of the device (for example, <code>ANDROID</code> or <code>IOS</code>).</p>
    public let platform: DevicePlatform?
    /// <p>Specifies whether there are recurring charges for the offering.</p>
    public let recurringCharges: [RecurringCharge]?
    /// <p>The type of offering (for example, <code>RECURRING</code>) for a device.</p>
    public let type: OfferingType?

    public init (
        description: String? = nil,
        id: String? = nil,
        platform: DevicePlatform? = nil,
        recurringCharges: [RecurringCharge]? = nil,
        type: OfferingType? = nil
    )
    {
        self.description = description
        self.id = id
        self.platform = platform
        self.recurringCharges = recurringCharges
        self.type = type
    }
}

extension OfferingPromotion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension OfferingPromotion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OfferingPromotion(description: \(String(describing: description)), id: \(String(describing: id)))"}
}

/// <p>Represents information about an offering promotion.</p>
public struct OfferingPromotion: Equatable {
    /// <p>A string that describes the offering promotion.</p>
    public let description: String?
    /// <p>The ID of the offering promotion.</p>
    public let id: String?

    public init (
        description: String? = nil,
        id: String? = nil
    )
    {
        self.description = description
        self.id = id
    }
}

extension OfferingStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case effectiveOn
        case offering
        case quantity
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let effectiveOn = effectiveOn {
            try encodeContainer.encode(effectiveOn.timeIntervalSince1970, forKey: .effectiveOn)
        }
        if let offering = offering {
            try encodeContainer.encode(offering, forKey: .offering)
        }
        if let quantity = quantity {
            try encodeContainer.encode(quantity, forKey: .quantity)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OfferingTransactionType.self, forKey: .type)
        type = typeDecoded
        let offeringDecoded = try containerValues.decodeIfPresent(Offering.self, forKey: .offering)
        offering = offeringDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        let effectiveOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .effectiveOn)
        effectiveOn = effectiveOnDecoded
    }
}

extension OfferingStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OfferingStatus(effectiveOn: \(String(describing: effectiveOn)), offering: \(String(describing: offering)), quantity: \(String(describing: quantity)), type: \(String(describing: type)))"}
}

/// <p>The status of the offering.</p>
public struct OfferingStatus: Equatable {
    /// <p>The date on which the offering is effective.</p>
    public let effectiveOn: Date?
    /// <p>Represents the metadata of an offering status.</p>
    public let offering: Offering?
    /// <p>The number of available devices in the offering.</p>
    public let quantity: Int?
    /// <p>The type specified for the offering status.</p>
    public let type: OfferingTransactionType?

    public init (
        effectiveOn: Date? = nil,
        offering: Offering? = nil,
        quantity: Int? = nil,
        type: OfferingTransactionType? = nil
    )
    {
        self.effectiveOn = effectiveOn
        self.offering = offering
        self.quantity = quantity
        self.type = type
    }
}

extension OfferingTransaction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cost
        case createdOn
        case offeringPromotionId
        case offeringStatus
        case transactionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cost = cost {
            try encodeContainer.encode(cost, forKey: .cost)
        }
        if let createdOn = createdOn {
            try encodeContainer.encode(createdOn.timeIntervalSince1970, forKey: .createdOn)
        }
        if let offeringPromotionId = offeringPromotionId {
            try encodeContainer.encode(offeringPromotionId, forKey: .offeringPromotionId)
        }
        if let offeringStatus = offeringStatus {
            try encodeContainer.encode(offeringStatus, forKey: .offeringStatus)
        }
        if let transactionId = transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringStatusDecoded = try containerValues.decodeIfPresent(OfferingStatus.self, forKey: .offeringStatus)
        offeringStatus = offeringStatusDecoded
        let transactionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let offeringPromotionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .offeringPromotionId)
        offeringPromotionId = offeringPromotionIdDecoded
        let createdOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdOn)
        createdOn = createdOnDecoded
        let costDecoded = try containerValues.decodeIfPresent(MonetaryAmount.self, forKey: .cost)
        cost = costDecoded
    }
}

extension OfferingTransaction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OfferingTransaction(cost: \(String(describing: cost)), createdOn: \(String(describing: createdOn)), offeringPromotionId: \(String(describing: offeringPromotionId)), offeringStatus: \(String(describing: offeringStatus)), transactionId: \(String(describing: transactionId)))"}
}

/// <p>Represents the metadata of an offering transaction.</p>
public struct OfferingTransaction: Equatable {
    /// <p>The cost of an offering transaction.</p>
    public let cost: MonetaryAmount?
    /// <p>The date on which an offering transaction was created.</p>
    public let createdOn: Date?
    /// <p>The ID that corresponds to a device offering promotion.</p>
    public let offeringPromotionId: String?
    /// <p>The status of an offering transaction.</p>
    public let offeringStatus: OfferingStatus?
    /// <p>The transaction ID of the offering transaction.</p>
    public let transactionId: String?

    public init (
        cost: MonetaryAmount? = nil,
        createdOn: Date? = nil,
        offeringPromotionId: String? = nil,
        offeringStatus: OfferingStatus? = nil,
        transactionId: String? = nil
    )
    {
        self.cost = cost
        self.createdOn = createdOn
        self.offeringPromotionId = offeringPromotionId
        self.offeringStatus = offeringStatus
        self.transactionId = transactionId
    }
}

public enum OfferingTransactionType {
    case purchase
    case renew
    case system
    case sdkUnknown(String)
}

extension OfferingTransactionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OfferingTransactionType] {
        return [
            .purchase,
            .renew,
            .system,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .purchase: return "PURCHASE"
        case .renew: return "RENEW"
        case .system: return "SYSTEM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OfferingTransactionType(rawValue: rawValue) ?? OfferingTransactionType.sdkUnknown(rawValue)
    }
}

public enum OfferingType {
    case recurring
    case sdkUnknown(String)
}

extension OfferingType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OfferingType] {
        return [
            .recurring,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .recurring: return "RECURRING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OfferingType(rawValue: rawValue) ?? OfferingType.sdkUnknown(rawValue)
    }
}

extension Problem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case device
        case job
        case message
        case result
        case run
        case suite
        case test
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let device = device {
            try encodeContainer.encode(device, forKey: .device)
        }
        if let job = job {
            try encodeContainer.encode(job, forKey: .job)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let result = result {
            try encodeContainer.encode(result.rawValue, forKey: .result)
        }
        if let run = run {
            try encodeContainer.encode(run, forKey: .run)
        }
        if let suite = suite {
            try encodeContainer.encode(suite, forKey: .suite)
        }
        if let test = test {
            try encodeContainer.encode(test, forKey: .test)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runDecoded = try containerValues.decodeIfPresent(ProblemDetail.self, forKey: .run)
        run = runDecoded
        let jobDecoded = try containerValues.decodeIfPresent(ProblemDetail.self, forKey: .job)
        job = jobDecoded
        let suiteDecoded = try containerValues.decodeIfPresent(ProblemDetail.self, forKey: .suite)
        suite = suiteDecoded
        let testDecoded = try containerValues.decodeIfPresent(ProblemDetail.self, forKey: .test)
        test = testDecoded
        let deviceDecoded = try containerValues.decodeIfPresent(Device.self, forKey: .device)
        device = deviceDecoded
        let resultDecoded = try containerValues.decodeIfPresent(ExecutionResult.self, forKey: .result)
        result = resultDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Problem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Problem(device: \(String(describing: device)), job: \(String(describing: job)), message: \(String(describing: message)), result: \(String(describing: result)), run: \(String(describing: run)), suite: \(String(describing: suite)), test: \(String(describing: test)))"}
}

/// <p>Represents a specific warning or failure.</p>
public struct Problem: Equatable {
    /// <p>Information about the associated device.</p>
    public let device: Device?
    /// <p>Information about the associated job.</p>
    public let job: ProblemDetail?
    /// <p>A message about the problem's result.</p>
    public let message: String?
    /// <p>The problem's result.</p>
    ///         <p>Allowed values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>PENDING</p>
    ///             </li>
    ///             <li>
    ///                 <p>PASSED</p>
    ///             </li>
    ///             <li>
    ///                 <p>WARNED</p>
    ///             </li>
    ///             <li>
    ///                 <p>FAILED</p>
    ///             </li>
    ///             <li>
    ///                 <p>SKIPPED</p>
    ///             </li>
    ///             <li>
    ///                 <p>ERRORED</p>
    ///             </li>
    ///             <li>
    ///                 <p>STOPPED</p>
    ///             </li>
    ///          </ul>
    public let result: ExecutionResult?
    /// <p>Information about the associated run.</p>
    public let run: ProblemDetail?
    /// <p>Information about the associated suite.</p>
    public let suite: ProblemDetail?
    /// <p>Information about the associated test.</p>
    public let test: ProblemDetail?

    public init (
        device: Device? = nil,
        job: ProblemDetail? = nil,
        message: String? = nil,
        result: ExecutionResult? = nil,
        run: ProblemDetail? = nil,
        suite: ProblemDetail? = nil,
        test: ProblemDetail? = nil
    )
    {
        self.device = device
        self.job = job
        self.message = message
        self.result = result
        self.run = run
        self.suite = suite
        self.test = test
    }
}

extension ProblemDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ProblemDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProblemDetail(arn: \(String(describing: arn)), name: \(String(describing: name)))"}
}

/// <p>Information about a problem detail.</p>
public struct ProblemDetail: Equatable {
    /// <p>The problem detail's ARN.</p>
    public let arn: String?
    /// <p>The problem detail's name.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

extension Project: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case created
        case defaultJobTimeoutMinutes
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let defaultJobTimeoutMinutes = defaultJobTimeoutMinutes {
            try encodeContainer.encode(defaultJobTimeoutMinutes, forKey: .defaultJobTimeoutMinutes)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let defaultJobTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .defaultJobTimeoutMinutes)
        defaultJobTimeoutMinutes = defaultJobTimeoutMinutesDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
    }
}

extension Project: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Project(arn: \(String(describing: arn)), created: \(String(describing: created)), defaultJobTimeoutMinutes: \(String(describing: defaultJobTimeoutMinutes)), name: \(String(describing: name)))"}
}

/// <p>Represents an operating-system neutral workspace for running and managing
///             tests.</p>
public struct Project: Equatable {
    /// <p>The project's ARN.</p>
    public let arn: String?
    /// <p>When the project was created.</p>
    public let created: Date?
    /// <p>The default number of minutes (at the project level) a test run executes before it times out. The
    ///             default value is 150 minutes.</p>
    public let defaultJobTimeoutMinutes: Int?
    /// <p>The project's name.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        created: Date? = nil,
        defaultJobTimeoutMinutes: Int? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.created = created
        self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
        self.name = name
    }
}

public struct PurchaseOfferingInputBodyMiddleware: Middleware {
    public let id: String = "PurchaseOfferingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PurchaseOfferingInput>,
                  next: H) -> Swift.Result<OperationOutput<PurchaseOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PurchaseOfferingInput>
    public typealias MOutput = OperationOutput<PurchaseOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PurchaseOfferingOutputError>
}

extension PurchaseOfferingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PurchaseOfferingInput(offeringId: \(String(describing: offeringId)), offeringPromotionId: \(String(describing: offeringPromotionId)), quantity: \(String(describing: quantity)))"}
}

extension PurchaseOfferingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case offeringId
        case offeringPromotionId
        case quantity
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let offeringId = offeringId {
            try encodeContainer.encode(offeringId, forKey: .offeringId)
        }
        if let offeringPromotionId = offeringPromotionId {
            try encodeContainer.encode(offeringPromotionId, forKey: .offeringPromotionId)
        }
        if let quantity = quantity {
            try encodeContainer.encode(quantity, forKey: .quantity)
        }
    }
}

public struct PurchaseOfferingInputHeadersMiddleware: Middleware {
    public let id: String = "PurchaseOfferingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PurchaseOfferingInput>,
                  next: H) -> Swift.Result<OperationOutput<PurchaseOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PurchaseOfferingInput>
    public typealias MOutput = OperationOutput<PurchaseOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PurchaseOfferingOutputError>
}

public struct PurchaseOfferingInputQueryItemMiddleware: Middleware {
    public let id: String = "PurchaseOfferingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PurchaseOfferingInput>,
                  next: H) -> Swift.Result<OperationOutput<PurchaseOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PurchaseOfferingInput>
    public typealias MOutput = OperationOutput<PurchaseOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PurchaseOfferingOutputError>
}

/// <p>Represents a request for a purchase offering.</p>
public struct PurchaseOfferingInput: Equatable {
    /// <p>The ID of the offering.</p>
    public let offeringId: String?
    /// <p>The ID of the offering promotion to be applied to the purchase.</p>
    public let offeringPromotionId: String?
    /// <p>The number of device slots to purchase in an offering request.</p>
    public let quantity: Int?

    public init (
        offeringId: String? = nil,
        offeringPromotionId: String? = nil,
        quantity: Int? = nil
    )
    {
        self.offeringId = offeringId
        self.offeringPromotionId = offeringPromotionId
        self.quantity = quantity
    }
}

struct PurchaseOfferingInputBody: Equatable {
    public let offeringId: String?
    public let quantity: Int?
    public let offeringPromotionId: String?
}

extension PurchaseOfferingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case offeringId
        case offeringPromotionId
        case quantity
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .offeringId)
        offeringId = offeringIdDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        let offeringPromotionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .offeringPromotionId)
        offeringPromotionId = offeringPromotionIdDecoded
    }
}

extension PurchaseOfferingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PurchaseOfferingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotEligibleException" : self = .notEligibleException(try NotEligibleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PurchaseOfferingOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notEligibleException(NotEligibleException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PurchaseOfferingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PurchaseOfferingOutputResponse(offeringTransaction: \(String(describing: offeringTransaction)))"}
}

extension PurchaseOfferingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PurchaseOfferingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.offeringTransaction = output.offeringTransaction
        } else {
            self.offeringTransaction = nil
        }
    }
}

/// <p>The result of the purchase offering (for example, success or failure).</p>
public struct PurchaseOfferingOutputResponse: Equatable {
    /// <p>Represents the offering transaction for the purchase result.</p>
    public let offeringTransaction: OfferingTransaction?

    public init (
        offeringTransaction: OfferingTransaction? = nil
    )
    {
        self.offeringTransaction = offeringTransaction
    }
}

struct PurchaseOfferingOutputResponseBody: Equatable {
    public let offeringTransaction: OfferingTransaction?
}

extension PurchaseOfferingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case offeringTransaction
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringTransactionDecoded = try containerValues.decodeIfPresent(OfferingTransaction.self, forKey: .offeringTransaction)
        offeringTransaction = offeringTransactionDecoded
    }
}

extension Radios: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bluetooth
        case gps
        case nfc
        case wifi
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bluetooth = bluetooth {
            try encodeContainer.encode(bluetooth, forKey: .bluetooth)
        }
        if let gps = gps {
            try encodeContainer.encode(gps, forKey: .gps)
        }
        if let nfc = nfc {
            try encodeContainer.encode(nfc, forKey: .nfc)
        }
        if let wifi = wifi {
            try encodeContainer.encode(wifi, forKey: .wifi)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wifiDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .wifi)
        wifi = wifiDecoded
        let bluetoothDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .bluetooth)
        bluetooth = bluetoothDecoded
        let nfcDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .nfc)
        nfc = nfcDecoded
        let gpsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .gps)
        gps = gpsDecoded
    }
}

extension Radios: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Radios(bluetooth: \(String(describing: bluetooth)), gps: \(String(describing: gps)), nfc: \(String(describing: nfc)), wifi: \(String(describing: wifi)))"}
}

/// <p>Represents the set of radios and their states on a device. Examples of radios
///             include Wi-Fi, GPS, Bluetooth, and NFC.</p>
public struct Radios: Equatable {
    /// <p>True if Bluetooth is enabled at the beginning of the test. Otherwise, false.</p>
    public let bluetooth: Bool?
    /// <p>True if GPS is enabled at the beginning of the test. Otherwise, false.</p>
    public let gps: Bool?
    /// <p>True if NFC is enabled at the beginning of the test. Otherwise, false.</p>
    public let nfc: Bool?
    /// <p>True if Wi-Fi is enabled at the beginning of the test. Otherwise, false.</p>
    public let wifi: Bool?

    public init (
        bluetooth: Bool? = nil,
        gps: Bool? = nil,
        nfc: Bool? = nil,
        wifi: Bool? = nil
    )
    {
        self.bluetooth = bluetooth
        self.gps = gps
        self.nfc = nfc
        self.wifi = wifi
    }
}

extension RecurringCharge: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cost
        case frequency
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cost = cost {
            try encodeContainer.encode(cost, forKey: .cost)
        }
        if let frequency = frequency {
            try encodeContainer.encode(frequency.rawValue, forKey: .frequency)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costDecoded = try containerValues.decodeIfPresent(MonetaryAmount.self, forKey: .cost)
        cost = costDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(RecurringChargeFrequency.self, forKey: .frequency)
        frequency = frequencyDecoded
    }
}

extension RecurringCharge: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecurringCharge(cost: \(String(describing: cost)), frequency: \(String(describing: frequency)))"}
}

/// <p>Specifies whether charges for devices are recurring.</p>
public struct RecurringCharge: Equatable {
    /// <p>The cost of the recurring charge.</p>
    public let cost: MonetaryAmount?
    /// <p>The frequency in which charges recur.</p>
    public let frequency: RecurringChargeFrequency?

    public init (
        cost: MonetaryAmount? = nil,
        frequency: RecurringChargeFrequency? = nil
    )
    {
        self.cost = cost
        self.frequency = frequency
    }
}

public enum RecurringChargeFrequency {
    case monthly
    case sdkUnknown(String)
}

extension RecurringChargeFrequency : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RecurringChargeFrequency] {
        return [
            .monthly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .monthly: return "MONTHLY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RecurringChargeFrequency(rawValue: rawValue) ?? RecurringChargeFrequency.sdkUnknown(rawValue)
    }
}

extension RemoteAccessSession: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case billingMethod
        case clientId
        case created
        case device
        case deviceMinutes
        case deviceUdid
        case endpoint
        case hostAddress
        case instanceArn
        case interactionMode
        case message
        case name
        case remoteDebugEnabled
        case remoteRecordAppArn
        case remoteRecordEnabled
        case result
        case skipAppResign
        case started
        case status
        case stopped
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let billingMethod = billingMethod {
            try encodeContainer.encode(billingMethod.rawValue, forKey: .billingMethod)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let device = device {
            try encodeContainer.encode(device, forKey: .device)
        }
        if let deviceMinutes = deviceMinutes {
            try encodeContainer.encode(deviceMinutes, forKey: .deviceMinutes)
        }
        if let deviceUdid = deviceUdid {
            try encodeContainer.encode(deviceUdid, forKey: .deviceUdid)
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let hostAddress = hostAddress {
            try encodeContainer.encode(hostAddress, forKey: .hostAddress)
        }
        if let instanceArn = instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let interactionMode = interactionMode {
            try encodeContainer.encode(interactionMode.rawValue, forKey: .interactionMode)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let remoteDebugEnabled = remoteDebugEnabled {
            try encodeContainer.encode(remoteDebugEnabled, forKey: .remoteDebugEnabled)
        }
        if let remoteRecordAppArn = remoteRecordAppArn {
            try encodeContainer.encode(remoteRecordAppArn, forKey: .remoteRecordAppArn)
        }
        if let remoteRecordEnabled = remoteRecordEnabled {
            try encodeContainer.encode(remoteRecordEnabled, forKey: .remoteRecordEnabled)
        }
        if let result = result {
            try encodeContainer.encode(result.rawValue, forKey: .result)
        }
        if let skipAppResign = skipAppResign {
            try encodeContainer.encode(skipAppResign, forKey: .skipAppResign)
        }
        if let started = started {
            try encodeContainer.encode(started.timeIntervalSince1970, forKey: .started)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stopped = stopped {
            try encodeContainer.encode(stopped.timeIntervalSince1970, forKey: .stopped)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let resultDecoded = try containerValues.decodeIfPresent(ExecutionResult.self, forKey: .result)
        result = resultDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let startedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .started)
        started = startedDecoded
        let stoppedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .stopped)
        stopped = stoppedDecoded
        let deviceDecoded = try containerValues.decodeIfPresent(Device.self, forKey: .device)
        device = deviceDecoded
        let instanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let remoteDebugEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .remoteDebugEnabled)
        remoteDebugEnabled = remoteDebugEnabledDecoded
        let remoteRecordEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .remoteRecordEnabled)
        remoteRecordEnabled = remoteRecordEnabledDecoded
        let remoteRecordAppArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .remoteRecordAppArn)
        remoteRecordAppArn = remoteRecordAppArnDecoded
        let hostAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostAddress)
        hostAddress = hostAddressDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let billingMethodDecoded = try containerValues.decodeIfPresent(BillingMethod.self, forKey: .billingMethod)
        billingMethod = billingMethodDecoded
        let deviceMinutesDecoded = try containerValues.decodeIfPresent(DeviceMinutes.self, forKey: .deviceMinutes)
        deviceMinutes = deviceMinutesDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let deviceUdidDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceUdid)
        deviceUdid = deviceUdidDecoded
        let interactionModeDecoded = try containerValues.decodeIfPresent(InteractionMode.self, forKey: .interactionMode)
        interactionMode = interactionModeDecoded
        let skipAppResignDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .skipAppResign)
        skipAppResign = skipAppResignDecoded
    }
}

extension RemoteAccessSession: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoteAccessSession(arn: \(String(describing: arn)), billingMethod: \(String(describing: billingMethod)), clientId: \(String(describing: clientId)), created: \(String(describing: created)), device: \(String(describing: device)), deviceMinutes: \(String(describing: deviceMinutes)), deviceUdid: \(String(describing: deviceUdid)), endpoint: \(String(describing: endpoint)), hostAddress: \(String(describing: hostAddress)), instanceArn: \(String(describing: instanceArn)), interactionMode: \(String(describing: interactionMode)), message: \(String(describing: message)), name: \(String(describing: name)), remoteDebugEnabled: \(String(describing: remoteDebugEnabled)), remoteRecordAppArn: \(String(describing: remoteRecordAppArn)), remoteRecordEnabled: \(String(describing: remoteRecordEnabled)), result: \(String(describing: result)), skipAppResign: \(String(describing: skipAppResign)), started: \(String(describing: started)), status: \(String(describing: status)), stopped: \(String(describing: stopped)))"}
}

/// <p>Represents information about the remote access session.</p>
public struct RemoteAccessSession: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the remote access session.</p>
    public let arn: String?
    /// <p>The billing method of the remote access session. Possible values include <code>METERED</code> or
    ///                 <code>UNMETERED</code>. For more information about metered devices, see <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/welcome.html#welcome-terminology">AWS Device Farm
    ///                 terminology</a>.</p>
    public let billingMethod: BillingMethod?
    /// <p>Unique identifier of your client for the remote access session. Only returned if
    ///             remote debugging is enabled for the remote access session.</p>
    ///         <p>Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no
    ///                 longer supported</a>.</p>
    public let clientId: String?
    /// <p>The date and time the remote access session was created.</p>
    public let created: Date?
    /// <p>The device (phone or tablet) used in the remote access session.</p>
    public let device: Device?
    /// <p>The number of minutes a device is used in a remote access session (including setup
    ///             and teardown minutes).</p>
    public let deviceMinutes: DeviceMinutes?
    /// <p>Unique device identifier for the remote device. Only returned if remote debugging
    ///             is enabled for the remote access session.</p>
    ///         <p>Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no
    ///                 longer supported</a>.</p>
    public let deviceUdid: String?
    /// <p>The endpoint for the remote access sesssion.</p>
    public let endpoint: String?
    /// <p>IP address of the EC2 host where you need to connect to remotely debug devices.
    ///             Only returned if remote debugging is enabled for the remote access session.</p>
    ///         <p>Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no
    ///                 longer supported</a>.</p>
    public let hostAddress: String?
    /// <p>The ARN of the instance.</p>
    public let instanceArn: String?
    /// <p>The interaction mode of the remote access session. Valid values are:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>INTERACTIVE: You can interact with the iOS device by viewing, touching, and
    ///                     rotating the screen. You cannot run XCUITest framework-based tests in this
    ///                     mode.</p>
    ///             </li>
    ///             <li>
    ///                 <p>NO_VIDEO: You are connected to the device, but cannot interact with it or view the screen. This
    ///                     mode has the fastest test execution speed. You can run XCUITest framework-based tests in this
    ///                     mode.</p>
    ///             </li>
    ///             <li>
    ///                 <p>VIDEO_ONLY: You can view the screen, but cannot touch or rotate it. You can run XCUITest
    ///                     framework-based tests and watch the screen in this mode.</p>
    ///             </li>
    ///          </ul>
    public let interactionMode: InteractionMode?
    /// <p>A message about the remote access session.</p>
    public let message: String?
    /// <p>The name of the remote access session.</p>
    public let name: String?
    /// <p>This flag is set to <code>true</code> if remote debugging is enabled for the remote
    ///             access session.</p>
    ///         <p>Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no
    ///                 longer supported</a>.</p>
    public let remoteDebugEnabled: Bool?
    /// <p>The ARN for the app to be recorded in the remote access session.</p>
    public let remoteRecordAppArn: String?
    /// <p>This flag is set to <code>true</code> if remote recording is enabled for the remote
    ///             access session.</p>
    public let remoteRecordEnabled: Bool?
    /// <p>The result of the remote access session. Can be any of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>PENDING.</p>
    ///             </li>
    ///             <li>
    ///                 <p>PASSED.</p>
    ///             </li>
    ///             <li>
    ///                 <p>WARNED.</p>
    ///             </li>
    ///             <li>
    ///                 <p>FAILED.</p>
    ///             </li>
    ///             <li>
    ///                 <p>SKIPPED.</p>
    ///             </li>
    ///             <li>
    ///                 <p>ERRORED.</p>
    ///             </li>
    ///             <li>
    ///                 <p>STOPPED.</p>
    ///             </li>
    ///          </ul>
    public let result: ExecutionResult?
    /// <p>When set to <code>true</code>, for private devices, Device Farm does not sign your app again. For public
    ///             devices, Device Farm always signs your apps again.</p>
    ///         <p>For more information about how Device Farm re-signs your apps, see <a href="https://aws.amazon.com/device-farm/faq/">Do you modify my app?</a> in the <i>AWS Device
    ///                 Farm FAQs</i>.</p>
    public let skipAppResign: Bool?
    /// <p>The date and time the remote access session was started.</p>
    public let started: Date?
    /// <p>The status of the remote access session. Can be any of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>PENDING.</p>
    ///             </li>
    ///             <li>
    ///                 <p>PENDING_CONCURRENCY.</p>
    ///             </li>
    ///             <li>
    ///                 <p>PENDING_DEVICE.</p>
    ///             </li>
    ///             <li>
    ///                 <p>PROCESSING.</p>
    ///             </li>
    ///             <li>
    ///                 <p>SCHEDULING.</p>
    ///             </li>
    ///             <li>
    ///                 <p>PREPARING.</p>
    ///             </li>
    ///             <li>
    ///                 <p>RUNNING.</p>
    ///             </li>
    ///             <li>
    ///                 <p>COMPLETED.</p>
    ///             </li>
    ///             <li>
    ///                 <p>STOPPING.</p>
    ///             </li>
    ///          </ul>
    public let status: ExecutionStatus?
    /// <p>The date and time the remote access session was stopped.</p>
    public let stopped: Date?

    public init (
        arn: String? = nil,
        billingMethod: BillingMethod? = nil,
        clientId: String? = nil,
        created: Date? = nil,
        device: Device? = nil,
        deviceMinutes: DeviceMinutes? = nil,
        deviceUdid: String? = nil,
        endpoint: String? = nil,
        hostAddress: String? = nil,
        instanceArn: String? = nil,
        interactionMode: InteractionMode? = nil,
        message: String? = nil,
        name: String? = nil,
        remoteDebugEnabled: Bool? = nil,
        remoteRecordAppArn: String? = nil,
        remoteRecordEnabled: Bool? = nil,
        result: ExecutionResult? = nil,
        skipAppResign: Bool? = nil,
        started: Date? = nil,
        status: ExecutionStatus? = nil,
        stopped: Date? = nil
    )
    {
        self.arn = arn
        self.billingMethod = billingMethod
        self.clientId = clientId
        self.created = created
        self.device = device
        self.deviceMinutes = deviceMinutes
        self.deviceUdid = deviceUdid
        self.endpoint = endpoint
        self.hostAddress = hostAddress
        self.instanceArn = instanceArn
        self.interactionMode = interactionMode
        self.message = message
        self.name = name
        self.remoteDebugEnabled = remoteDebugEnabled
        self.remoteRecordAppArn = remoteRecordAppArn
        self.remoteRecordEnabled = remoteRecordEnabled
        self.result = result
        self.skipAppResign = skipAppResign
        self.started = started
        self.status = status
        self.stopped = stopped
    }
}

public struct RenewOfferingInputBodyMiddleware: Middleware {
    public let id: String = "RenewOfferingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RenewOfferingInput>,
                  next: H) -> Swift.Result<OperationOutput<RenewOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RenewOfferingInput>
    public typealias MOutput = OperationOutput<RenewOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RenewOfferingOutputError>
}

extension RenewOfferingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RenewOfferingInput(offeringId: \(String(describing: offeringId)), quantity: \(String(describing: quantity)))"}
}

extension RenewOfferingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case offeringId
        case quantity
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let offeringId = offeringId {
            try encodeContainer.encode(offeringId, forKey: .offeringId)
        }
        if let quantity = quantity {
            try encodeContainer.encode(quantity, forKey: .quantity)
        }
    }
}

public struct RenewOfferingInputHeadersMiddleware: Middleware {
    public let id: String = "RenewOfferingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RenewOfferingInput>,
                  next: H) -> Swift.Result<OperationOutput<RenewOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RenewOfferingInput>
    public typealias MOutput = OperationOutput<RenewOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RenewOfferingOutputError>
}

public struct RenewOfferingInputQueryItemMiddleware: Middleware {
    public let id: String = "RenewOfferingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RenewOfferingInput>,
                  next: H) -> Swift.Result<OperationOutput<RenewOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RenewOfferingInput>
    public typealias MOutput = OperationOutput<RenewOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RenewOfferingOutputError>
}

/// <p>A request that represents an offering renewal.</p>
public struct RenewOfferingInput: Equatable {
    /// <p>The ID of a request to renew an offering.</p>
    public let offeringId: String?
    /// <p>The quantity requested in an offering renewal.</p>
    public let quantity: Int?

    public init (
        offeringId: String? = nil,
        quantity: Int? = nil
    )
    {
        self.offeringId = offeringId
        self.quantity = quantity
    }
}

struct RenewOfferingInputBody: Equatable {
    public let offeringId: String?
    public let quantity: Int?
}

extension RenewOfferingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case offeringId
        case quantity
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .offeringId)
        offeringId = offeringIdDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
    }
}

extension RenewOfferingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RenewOfferingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotEligibleException" : self = .notEligibleException(try NotEligibleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RenewOfferingOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notEligibleException(NotEligibleException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RenewOfferingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RenewOfferingOutputResponse(offeringTransaction: \(String(describing: offeringTransaction)))"}
}

extension RenewOfferingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RenewOfferingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.offeringTransaction = output.offeringTransaction
        } else {
            self.offeringTransaction = nil
        }
    }
}

/// <p>The result of a renewal offering.</p>
public struct RenewOfferingOutputResponse: Equatable {
    /// <p>Represents the status of the offering transaction for the renewal.</p>
    public let offeringTransaction: OfferingTransaction?

    public init (
        offeringTransaction: OfferingTransaction? = nil
    )
    {
        self.offeringTransaction = offeringTransaction
    }
}

struct RenewOfferingOutputResponseBody: Equatable {
    public let offeringTransaction: OfferingTransaction?
}

extension RenewOfferingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case offeringTransaction
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringTransactionDecoded = try containerValues.decodeIfPresent(OfferingTransaction.self, forKey: .offeringTransaction)
        offeringTransaction = offeringTransactionDecoded
    }
}

extension Resolution: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case height
        case width
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let height = height {
            try encodeContainer.encode(height, forKey: .height)
        }
        if let width = width {
            try encodeContainer.encode(width, forKey: .width)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let widthDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .width)
        width = widthDecoded
        let heightDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .height)
        height = heightDecoded
    }
}

extension Resolution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Resolution(height: \(String(describing: height)), width: \(String(describing: width)))"}
}

/// <p>Represents the screen resolution of a device in height and width, expressed in
///             pixels.</p>
public struct Resolution: Equatable {
    /// <p>The screen resolution's height, expressed in pixels.</p>
    public let height: Int?
    /// <p>The screen resolution's width, expressed in pixels.</p>
    public let width: Int?

    public init (
        height: Int? = nil,
        width: Int? = nil
    )
    {
        self.height = height
        self.width = width
    }
}

extension Rule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attribute
        case `operator` = "operator"
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(DeviceAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(RuleOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Rule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Rule(attribute: \(String(describing: attribute)), operator: \(String(describing: `operator`)), value: \(String(describing: value)))"}
}

/// <p>Represents a condition for a device pool.</p>
public struct Rule: Equatable {
    /// <p>Specifies how Device Farm compares the rule's attribute to the value. For the
    ///             operators that are supported by each attribute, see the attribute
    ///             descriptions.</p>
    public let `operator`: RuleOperator?
    /// <p>The rule's stringified attribute. For example, specify the value as
    ///                 <code>"\"abc\""</code>.</p>
    ///         <p>The supported operators for each attribute are provided in the following
    ///             list.</p>
    ///         <dl>
    ///             <dt>APPIUM_VERSION</dt>
    ///             <dd>
    ///                     <p>The Appium version for the test.</p>
    ///                     <p>Supported operators: <code>CONTAINS</code>
    ///                </p>
    ///                 </dd>
    ///             <dt>ARN</dt>
    ///             <dd>
    ///                     <p>The Amazon Resource Name (ARN) of the device (for example,
    ///                         <code>arn:aws:devicefarm:us-west-2::device:12345Example</code>.</p>
    ///                     <p>Supported operators: <code>EQUALS</code>,
    ///                             <code>IN</code>, <code>NOT_IN</code>
    ///                </p>
    ///                 </dd>
    ///             <dt>AVAILABILITY</dt>
    ///             <dd>
    ///                     <p>The current availability of the device. Valid values are AVAILABLE,
    ///                         HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE.</p>
    ///                     <p>Supported operators: <code>EQUALS</code>
    ///                </p>
    ///                 </dd>
    ///             <dt>FLEET_TYPE</dt>
    ///             <dd>
    ///                     <p>The fleet type. Valid values are PUBLIC or PRIVATE.</p>
    ///                     <p>Supported operators: <code>EQUALS</code>
    ///                </p>
    ///                 </dd>
    ///             <dt>FORM_FACTOR</dt>
    ///             <dd>
    ///                     <p>The device form factor. Valid values are PHONE or TABLET.</p>
    ///                     <p>Supported operators: <code>EQUALS</code>,
    ///                             <code>IN</code>, <code>NOT_IN</code>
    ///                </p>
    ///                 </dd>
    ///             <dt>INSTANCE_ARN</dt>
    ///             <dd>
    ///                     <p>The Amazon Resource Name (ARN) of the device instance.</p>
    ///                     <p>Supported operators: <code>IN</code>,
    ///                             <code>NOT_IN</code>
    ///                </p>
    ///                 </dd>
    ///             <dt>INSTANCE_LABELS</dt>
    ///             <dd>
    ///                     <p>The label of the device instance.</p>
    ///                     <p>Supported operators: <code>CONTAINS</code>
    ///                </p>
    ///                 </dd>
    ///             <dt>MANUFACTURER</dt>
    ///             <dd>
    ///                     <p>The device manufacturer (for example, Apple).</p>
    ///                     <p>Supported operators: <code>EQUALS</code>,
    ///                             <code>IN</code>, <code>NOT_IN</code>
    ///                </p>
    ///                 </dd>
    ///             <dt>MODEL</dt>
    ///             <dd>
    ///                     <p>The device model, such as Apple iPad Air 2 or Google Pixel.</p>
    ///                     <p>Supported operators: <code>CONTAINS</code>,
    ///                             <code>EQUALS</code>, <code>IN</code>, <code>NOT_IN</code>
    ///                </p>
    ///                 </dd>
    ///             <dt>OS_VERSION</dt>
    ///             <dd>
    ///                     <p>The operating system version (for example, 10.3.2).</p>
    ///                     <p>Supported operators: <code>EQUALS</code>,
    ///                             <code>GREATER_THAN</code>, <code>GREATER_THAN_OR_EQUALS</code>,
    ///                             <code>IN</code>, <code>LESS_THAN</code>,
    ///                             <code>LESS_THAN_OR_EQUALS</code>, <code>NOT_IN</code>
    ///                </p>
    ///                 </dd>
    ///             <dt>PLATFORM</dt>
    ///             <dd>
    ///                     <p>The device platform. Valid values are ANDROID or IOS.</p>
    ///                     <p>Supported operators: <code>EQUALS</code>,
    ///                             <code>IN</code>, <code>NOT_IN</code>
    ///                </p>
    ///                 </dd>
    ///             <dt>REMOTE_ACCESS_ENABLED</dt>
    ///             <dd>
    ///                     <p>Whether the device is enabled for remote access. Valid values are TRUE
    ///                         or FALSE.</p>
    ///                     <p>Supported operators: <code>EQUALS</code>
    ///                </p>
    ///                 </dd>
    ///             <dt>REMOTE_DEBUG_ENABLED</dt>
    ///             <dd>
    ///                     <p>Whether the device is enabled for remote debugging. Valid values are
    ///                         TRUE or FALSE.</p>
    ///                     <p>Supported operators: <code>EQUALS</code>
    ///                </p>
    ///                     <p>Because remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no longer
    ///                             supported</a>, this filter is ignored.</p>
    ///                 </dd>
    ///          </dl>
    public let attribute: DeviceAttribute?
    /// <p>The rule's value.</p>
    public let value: String?

    public init (
        `operator`: RuleOperator? = nil,
        attribute: DeviceAttribute? = nil,
        value: String? = nil
    )
    {
        self.`operator` = `operator`
        self.attribute = attribute
        self.value = value
    }
}

public enum RuleOperator {
    case contains
    case equals
    case greaterThan
    case greaterThanOrEquals
    case `in`
    case lessThan
    case lessThanOrEquals
    case notIn
    case sdkUnknown(String)
}

extension RuleOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RuleOperator] {
        return [
            .contains,
            .equals,
            .greaterThan,
            .greaterThanOrEquals,
            .in,
            .lessThan,
            .lessThanOrEquals,
            .notIn,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .contains: return "CONTAINS"
        case .equals: return "EQUALS"
        case .greaterThan: return "GREATER_THAN"
        case .greaterThanOrEquals: return "GREATER_THAN_OR_EQUALS"
        case .in: return "IN"
        case .lessThan: return "LESS_THAN"
        case .lessThanOrEquals: return "LESS_THAN_OR_EQUALS"
        case .notIn: return "NOT_IN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RuleOperator(rawValue: rawValue) ?? RuleOperator.sdkUnknown(rawValue)
    }
}

extension Run: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appUpload
        case arn
        case billingMethod
        case completedJobs
        case counters
        case created
        case customerArtifactPaths
        case deviceMinutes
        case devicePoolArn
        case deviceSelectionResult
        case eventCount
        case jobTimeoutMinutes
        case locale
        case location
        case message
        case name
        case networkProfile
        case parsingResultUrl
        case platform
        case radios
        case result
        case resultCode
        case seed
        case skipAppResign
        case started
        case status
        case stopped
        case testSpecArn
        case totalJobs
        case type
        case webUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appUpload = appUpload {
            try encodeContainer.encode(appUpload, forKey: .appUpload)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let billingMethod = billingMethod {
            try encodeContainer.encode(billingMethod.rawValue, forKey: .billingMethod)
        }
        if let completedJobs = completedJobs {
            try encodeContainer.encode(completedJobs, forKey: .completedJobs)
        }
        if let counters = counters {
            try encodeContainer.encode(counters, forKey: .counters)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let customerArtifactPaths = customerArtifactPaths {
            try encodeContainer.encode(customerArtifactPaths, forKey: .customerArtifactPaths)
        }
        if let deviceMinutes = deviceMinutes {
            try encodeContainer.encode(deviceMinutes, forKey: .deviceMinutes)
        }
        if let devicePoolArn = devicePoolArn {
            try encodeContainer.encode(devicePoolArn, forKey: .devicePoolArn)
        }
        if let deviceSelectionResult = deviceSelectionResult {
            try encodeContainer.encode(deviceSelectionResult, forKey: .deviceSelectionResult)
        }
        if let eventCount = eventCount {
            try encodeContainer.encode(eventCount, forKey: .eventCount)
        }
        if let jobTimeoutMinutes = jobTimeoutMinutes {
            try encodeContainer.encode(jobTimeoutMinutes, forKey: .jobTimeoutMinutes)
        }
        if let locale = locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkProfile = networkProfile {
            try encodeContainer.encode(networkProfile, forKey: .networkProfile)
        }
        if let parsingResultUrl = parsingResultUrl {
            try encodeContainer.encode(parsingResultUrl, forKey: .parsingResultUrl)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let radios = radios {
            try encodeContainer.encode(radios, forKey: .radios)
        }
        if let result = result {
            try encodeContainer.encode(result.rawValue, forKey: .result)
        }
        if let resultCode = resultCode {
            try encodeContainer.encode(resultCode.rawValue, forKey: .resultCode)
        }
        if let seed = seed {
            try encodeContainer.encode(seed, forKey: .seed)
        }
        if let skipAppResign = skipAppResign {
            try encodeContainer.encode(skipAppResign, forKey: .skipAppResign)
        }
        if let started = started {
            try encodeContainer.encode(started.timeIntervalSince1970, forKey: .started)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stopped = stopped {
            try encodeContainer.encode(stopped.timeIntervalSince1970, forKey: .stopped)
        }
        if let testSpecArn = testSpecArn {
            try encodeContainer.encode(testSpecArn, forKey: .testSpecArn)
        }
        if let totalJobs = totalJobs {
            try encodeContainer.encode(totalJobs, forKey: .totalJobs)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let webUrl = webUrl {
            try encodeContainer.encode(webUrl, forKey: .webUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TestType.self, forKey: .type)
        type = typeDecoded
        let platformDecoded = try containerValues.decodeIfPresent(DevicePlatform.self, forKey: .platform)
        platform = platformDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let resultDecoded = try containerValues.decodeIfPresent(ExecutionResult.self, forKey: .result)
        result = resultDecoded
        let startedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .started)
        started = startedDecoded
        let stoppedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .stopped)
        stopped = stoppedDecoded
        let countersDecoded = try containerValues.decodeIfPresent(Counters.self, forKey: .counters)
        counters = countersDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let totalJobsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalJobs)
        totalJobs = totalJobsDecoded
        let completedJobsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .completedJobs)
        completedJobs = completedJobsDecoded
        let billingMethodDecoded = try containerValues.decodeIfPresent(BillingMethod.self, forKey: .billingMethod)
        billingMethod = billingMethodDecoded
        let deviceMinutesDecoded = try containerValues.decodeIfPresent(DeviceMinutes.self, forKey: .deviceMinutes)
        deviceMinutes = deviceMinutesDecoded
        let networkProfileDecoded = try containerValues.decodeIfPresent(NetworkProfile.self, forKey: .networkProfile)
        networkProfile = networkProfileDecoded
        let parsingResultUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parsingResultUrl)
        parsingResultUrl = parsingResultUrlDecoded
        let resultCodeDecoded = try containerValues.decodeIfPresent(ExecutionResultCode.self, forKey: .resultCode)
        resultCode = resultCodeDecoded
        let seedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .seed)
        seed = seedDecoded
        let appUploadDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appUpload)
        appUpload = appUploadDecoded
        let eventCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .eventCount)
        eventCount = eventCountDecoded
        let jobTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .jobTimeoutMinutes)
        jobTimeoutMinutes = jobTimeoutMinutesDecoded
        let devicePoolArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .devicePoolArn)
        devicePoolArn = devicePoolArnDecoded
        let localeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locale)
        locale = localeDecoded
        let radiosDecoded = try containerValues.decodeIfPresent(Radios.self, forKey: .radios)
        radios = radiosDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Location.self, forKey: .location)
        location = locationDecoded
        let customerArtifactPathsDecoded = try containerValues.decodeIfPresent(CustomerArtifactPaths.self, forKey: .customerArtifactPaths)
        customerArtifactPaths = customerArtifactPathsDecoded
        let webUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webUrl)
        webUrl = webUrlDecoded
        let skipAppResignDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .skipAppResign)
        skipAppResign = skipAppResignDecoded
        let testSpecArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .testSpecArn)
        testSpecArn = testSpecArnDecoded
        let deviceSelectionResultDecoded = try containerValues.decodeIfPresent(DeviceSelectionResult.self, forKey: .deviceSelectionResult)
        deviceSelectionResult = deviceSelectionResultDecoded
    }
}

extension Run: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Run(appUpload: \(String(describing: appUpload)), arn: \(String(describing: arn)), billingMethod: \(String(describing: billingMethod)), completedJobs: \(String(describing: completedJobs)), counters: \(String(describing: counters)), created: \(String(describing: created)), customerArtifactPaths: \(String(describing: customerArtifactPaths)), deviceMinutes: \(String(describing: deviceMinutes)), devicePoolArn: \(String(describing: devicePoolArn)), deviceSelectionResult: \(String(describing: deviceSelectionResult)), eventCount: \(String(describing: eventCount)), jobTimeoutMinutes: \(String(describing: jobTimeoutMinutes)), locale: \(String(describing: locale)), location: \(String(describing: location)), message: \(String(describing: message)), name: \(String(describing: name)), networkProfile: \(String(describing: networkProfile)), parsingResultUrl: \(String(describing: parsingResultUrl)), platform: \(String(describing: platform)), radios: \(String(describing: radios)), result: \(String(describing: result)), resultCode: \(String(describing: resultCode)), seed: \(String(describing: seed)), skipAppResign: \(String(describing: skipAppResign)), started: \(String(describing: started)), status: \(String(describing: status)), stopped: \(String(describing: stopped)), testSpecArn: \(String(describing: testSpecArn)), totalJobs: \(String(describing: totalJobs)), type: \(String(describing: type)), webUrl: \(String(describing: webUrl)))"}
}

/// <p>Represents a test run on a set of devices with a given app package, test parameters, and so
///             on.</p>
public struct Run: Equatable {
    /// <p>An app to upload or that has been uploaded.</p>
    public let appUpload: String?
    /// <p>The run's ARN.</p>
    public let arn: String?
    /// <p>Specifies the billing method for a test run: <code>metered</code> or
    ///                 <code>unmetered</code>. If the parameter is not specified, the default value is
    ///                 <code>metered</code>.</p>
    ///         <note>
    ///             <p>If you have unmetered device slots, you must set this to <code>unmetered</code> to use them.
    ///                 Otherwise, the run is counted toward metered device minutes.</p>
    ///         </note>
    public let billingMethod: BillingMethod?
    /// <p>The total number of completed jobs.</p>
    public let completedJobs: Int?
    /// <p>The run's result counters.</p>
    public let counters: Counters?
    /// <p>When the run was created.</p>
    public let created: Date?
    /// <p>Output <code>CustomerArtifactPaths</code> object for the test run.</p>
    public let customerArtifactPaths: CustomerArtifactPaths?
    /// <p>Represents the total (metered or unmetered) minutes used by the test run.</p>
    public let deviceMinutes: DeviceMinutes?
    /// <p>The ARN of the device pool for the run.</p>
    public let devicePoolArn: String?
    /// <p>The results of a device filter used to select the devices for a test run.</p>
    public let deviceSelectionResult: DeviceSelectionResult?
    /// <p>For fuzz tests, this is the number of events, between 1 and 10000, that the UI fuzz
    ///             test should perform.</p>
    public let eventCount: Int?
    /// <p>The number of minutes the job executes before it times out.</p>
    public let jobTimeoutMinutes: Int?
    /// <p>Information about the locale that is used for the run.</p>
    public let locale: String?
    /// <p>Information about the location that is used for the run.</p>
    public let location: Location?
    /// <p>A message about the run's result.</p>
    public let message: String?
    /// <p>The run's name.</p>
    public let name: String?
    /// <p>The network profile being used for a test run.</p>
    public let networkProfile: NetworkProfile?
    /// <p>Read-only URL for an object in an S3 bucket where you can get the parsing results of the test package.
    ///             If the test package doesn't parse, the reason why it doesn't parse appears in the file that this URL points
    ///             to.</p>
    public let parsingResultUrl: String?
    /// <p>The run's platform.</p>
    ///         <p>Allowed values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>ANDROID</p>
    ///             </li>
    ///             <li>
    ///                 <p>IOS</p>
    ///             </li>
    ///          </ul>
    public let platform: DevicePlatform?
    /// <p>Information about the radio states for the run.</p>
    public let radios: Radios?
    /// <p>The run's result.</p>
    ///         <p>Allowed values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>PENDING</p>
    ///             </li>
    ///             <li>
    ///                 <p>PASSED</p>
    ///             </li>
    ///             <li>
    ///                 <p>WARNED</p>
    ///             </li>
    ///             <li>
    ///                 <p>FAILED</p>
    ///             </li>
    ///             <li>
    ///                 <p>SKIPPED</p>
    ///             </li>
    ///             <li>
    ///                 <p>ERRORED</p>
    ///             </li>
    ///             <li>
    ///                 <p>STOPPED</p>
    ///             </li>
    ///          </ul>
    public let result: ExecutionResult?
    /// <p>Supporting field for the result field. Set only if <code>result</code> is <code>SKIPPED</code>.
    ///                 <code>PARSING_FAILED</code> if the result is skipped because of test package parsing failure.</p>
    public let resultCode: ExecutionResultCode?
    /// <p>For fuzz tests, this is a seed to use for randomizing the UI fuzz test. Using the same
    ///             seed value between tests ensures identical event sequences.</p>
    public let seed: Int?
    /// <p>When set to <code>true</code>, for private devices, Device Farm does not sign your app again. For public
    ///             devices, Device Farm always signs your apps again.</p>
    ///         <p>For more information about how Device Farm re-signs your apps, see <a href="https://aws.amazon.com/device-farm/faq/">Do you modify my app?</a> in the <i>AWS Device
    ///                 Farm FAQs</i>.</p>
    public let skipAppResign: Bool?
    /// <p>The run's start time.</p>
    public let started: Date?
    /// <p>The run's status.</p>
    ///         <p>Allowed values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>PENDING</p>
    ///             </li>
    ///             <li>
    ///                 <p>PENDING_CONCURRENCY</p>
    ///             </li>
    ///             <li>
    ///                 <p>PENDING_DEVICE</p>
    ///             </li>
    ///             <li>
    ///                 <p>PROCESSING</p>
    ///             </li>
    ///             <li>
    ///                 <p>SCHEDULING</p>
    ///             </li>
    ///             <li>
    ///                 <p>PREPARING</p>
    ///             </li>
    ///             <li>
    ///                 <p>RUNNING</p>
    ///             </li>
    ///             <li>
    ///                 <p>COMPLETED</p>
    ///             </li>
    ///             <li>
    ///                 <p>STOPPING</p>
    ///             </li>
    ///          </ul>
    public let status: ExecutionStatus?
    /// <p>The run's stop time.</p>
    public let stopped: Date?
    /// <p>The ARN of the YAML-formatted test specification for the run.</p>
    public let testSpecArn: String?
    /// <p>The total number of jobs for the run.</p>
    public let totalJobs: Int?
    /// <p>The run's type.</p>
    ///         <p>Must be one of the following values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>BUILTIN_FUZZ</p>
    ///             </li>
    ///             <li>
    ///                 <p>BUILTIN_EXPLORER</p>
    ///                 <note>
    ///                     <p>For Android, an app explorer that traverses an Android app, interacting with it and capturing
    ///                         screenshots at the same time.</p>
    ///                 </note>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_JUNIT</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_TESTNG</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_PYTHON</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_NODE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_RUBY</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_JAVA_JUNIT</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_JAVA_TESTNG</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_PYTHON</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_NODE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_RUBY</p>
    ///             </li>
    ///             <li>
    ///                 <p>CALABASH</p>
    ///             </li>
    ///             <li>
    ///                 <p>INSTRUMENTATION</p>
    ///             </li>
    ///             <li>
    ///                 <p>UIAUTOMATION</p>
    ///             </li>
    ///             <li>
    ///                 <p>UIAUTOMATOR</p>
    ///             </li>
    ///             <li>
    ///                 <p>XCTEST</p>
    ///             </li>
    ///             <li>
    ///                 <p>XCTEST_UI</p>
    ///             </li>
    ///          </ul>
    public let type: TestType?
    /// <p>The Device Farm console URL for the recording of the run.</p>
    public let webUrl: String?

    public init (
        appUpload: String? = nil,
        arn: String? = nil,
        billingMethod: BillingMethod? = nil,
        completedJobs: Int? = nil,
        counters: Counters? = nil,
        created: Date? = nil,
        customerArtifactPaths: CustomerArtifactPaths? = nil,
        deviceMinutes: DeviceMinutes? = nil,
        devicePoolArn: String? = nil,
        deviceSelectionResult: DeviceSelectionResult? = nil,
        eventCount: Int? = nil,
        jobTimeoutMinutes: Int? = nil,
        locale: String? = nil,
        location: Location? = nil,
        message: String? = nil,
        name: String? = nil,
        networkProfile: NetworkProfile? = nil,
        parsingResultUrl: String? = nil,
        platform: DevicePlatform? = nil,
        radios: Radios? = nil,
        result: ExecutionResult? = nil,
        resultCode: ExecutionResultCode? = nil,
        seed: Int? = nil,
        skipAppResign: Bool? = nil,
        started: Date? = nil,
        status: ExecutionStatus? = nil,
        stopped: Date? = nil,
        testSpecArn: String? = nil,
        totalJobs: Int? = nil,
        type: TestType? = nil,
        webUrl: String? = nil
    )
    {
        self.appUpload = appUpload
        self.arn = arn
        self.billingMethod = billingMethod
        self.completedJobs = completedJobs
        self.counters = counters
        self.created = created
        self.customerArtifactPaths = customerArtifactPaths
        self.deviceMinutes = deviceMinutes
        self.devicePoolArn = devicePoolArn
        self.deviceSelectionResult = deviceSelectionResult
        self.eventCount = eventCount
        self.jobTimeoutMinutes = jobTimeoutMinutes
        self.locale = locale
        self.location = location
        self.message = message
        self.name = name
        self.networkProfile = networkProfile
        self.parsingResultUrl = parsingResultUrl
        self.platform = platform
        self.radios = radios
        self.result = result
        self.resultCode = resultCode
        self.seed = seed
        self.skipAppResign = skipAppResign
        self.started = started
        self.status = status
        self.stopped = stopped
        self.testSpecArn = testSpecArn
        self.totalJobs = totalJobs
        self.type = type
        self.webUrl = webUrl
    }
}

extension Sample: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case type
        case url
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SampleType.self, forKey: .type)
        type = typeDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension Sample: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Sample(arn: \(String(describing: arn)), type: \(String(describing: type)), url: \(String(describing: url)))"}
}

/// <p>Represents a sample of performance data.</p>
public struct Sample: Equatable {
    /// <p>The sample's ARN.</p>
    public let arn: String?
    /// <p>The sample's type.</p>
    ///         <p>Must be one of the following values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>CPU: A CPU sample type. This is expressed as the app processing CPU time
    ///                     (including child processes) as reported by process, as a percentage.</p>
    ///             </li>
    ///             <li>
    ///                 <p>MEMORY: A memory usage sample type. This is expressed as the total
    ///                     proportional set size of an app process, in kilobytes.</p>
    ///             </li>
    ///             <li>
    ///                 <p>NATIVE_AVG_DRAWTIME</p>
    ///             </li>
    ///             <li>
    ///                 <p>NATIVE_FPS</p>
    ///             </li>
    ///             <li>
    ///                 <p>NATIVE_FRAMES</p>
    ///             </li>
    ///             <li>
    ///                 <p>NATIVE_MAX_DRAWTIME</p>
    ///             </li>
    ///             <li>
    ///                 <p>NATIVE_MIN_DRAWTIME</p>
    ///             </li>
    ///             <li>
    ///                 <p>OPENGL_AVG_DRAWTIME</p>
    ///             </li>
    ///             <li>
    ///                 <p>OPENGL_FPS</p>
    ///             </li>
    ///             <li>
    ///                 <p>OPENGL_FRAMES</p>
    ///             </li>
    ///             <li>
    ///                 <p>OPENGL_MAX_DRAWTIME</p>
    ///             </li>
    ///             <li>
    ///                 <p>OPENGL_MIN_DRAWTIME</p>
    ///             </li>
    ///             <li>
    ///                 <p>RX</p>
    ///             </li>
    ///             <li>
    ///                 <p>RX_RATE: The total number of bytes per second (TCP and UDP) that are sent,
    ///                     by app process.</p>
    ///             </li>
    ///             <li>
    ///                 <p>THREADS: A threads sample type. This is expressed as the total number of
    ///                     threads per app process.</p>
    ///             </li>
    ///             <li>
    ///                 <p>TX</p>
    ///             </li>
    ///             <li>
    ///                 <p>TX_RATE: The total number of bytes per second (TCP and UDP) that are
    ///                     received, by app process.</p>
    ///             </li>
    ///          </ul>
    public let type: SampleType?
    /// <p>The presigned Amazon S3 URL that can be used with a GET request to download the sample's
    ///             file.</p>
    public let url: String?

    public init (
        arn: String? = nil,
        type: SampleType? = nil,
        url: String? = nil
    )
    {
        self.arn = arn
        self.type = type
        self.url = url
    }
}

public enum SampleType {
    case cpu
    case memory
    case nativeAvgDrawtime
    case nativeFps
    case nativeFrames
    case nativeMaxDrawtime
    case nativeMinDrawtime
    case openglAvgDrawtime
    case openglFps
    case openglFrames
    case openglMaxDrawtime
    case openglMinDrawtime
    case rx
    case rxRate
    case threads
    case tx
    case txRate
    case sdkUnknown(String)
}

extension SampleType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SampleType] {
        return [
            .cpu,
            .memory,
            .nativeAvgDrawtime,
            .nativeFps,
            .nativeFrames,
            .nativeMaxDrawtime,
            .nativeMinDrawtime,
            .openglAvgDrawtime,
            .openglFps,
            .openglFrames,
            .openglMaxDrawtime,
            .openglMinDrawtime,
            .rx,
            .rxRate,
            .threads,
            .tx,
            .txRate,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cpu: return "CPU"
        case .memory: return "MEMORY"
        case .nativeAvgDrawtime: return "NATIVE_AVG_DRAWTIME"
        case .nativeFps: return "NATIVE_FPS"
        case .nativeFrames: return "NATIVE_FRAMES"
        case .nativeMaxDrawtime: return "NATIVE_MAX_DRAWTIME"
        case .nativeMinDrawtime: return "NATIVE_MIN_DRAWTIME"
        case .openglAvgDrawtime: return "OPENGL_AVG_DRAWTIME"
        case .openglFps: return "OPENGL_FPS"
        case .openglFrames: return "OPENGL_FRAMES"
        case .openglMaxDrawtime: return "OPENGL_MAX_DRAWTIME"
        case .openglMinDrawtime: return "OPENGL_MIN_DRAWTIME"
        case .rx: return "RX"
        case .rxRate: return "RX_RATE"
        case .threads: return "THREADS"
        case .tx: return "TX"
        case .txRate: return "TX_RATE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SampleType(rawValue: rawValue) ?? SampleType.sdkUnknown(rawValue)
    }
}

extension ScheduleRunConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case auxiliaryApps
        case billingMethod
        case customerArtifactPaths
        case extraDataPackageArn
        case locale
        case location
        case networkProfileArn
        case radios
        case vpceConfigurationArns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auxiliaryApps = auxiliaryApps {
            var auxiliaryAppsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .auxiliaryApps)
            for amazonresourcenames0 in auxiliaryApps {
                try auxiliaryAppsContainer.encode(amazonresourcenames0)
            }
        }
        if let billingMethod = billingMethod {
            try encodeContainer.encode(billingMethod.rawValue, forKey: .billingMethod)
        }
        if let customerArtifactPaths = customerArtifactPaths {
            try encodeContainer.encode(customerArtifactPaths, forKey: .customerArtifactPaths)
        }
        if let extraDataPackageArn = extraDataPackageArn {
            try encodeContainer.encode(extraDataPackageArn, forKey: .extraDataPackageArn)
        }
        if let locale = locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let networkProfileArn = networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
        if let radios = radios {
            try encodeContainer.encode(radios, forKey: .radios)
        }
        if let vpceConfigurationArns = vpceConfigurationArns {
            var vpceConfigurationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpceConfigurationArns)
            for amazonresourcenames0 in vpceConfigurationArns {
                try vpceConfigurationArnsContainer.encode(amazonresourcenames0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let extraDataPackageArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .extraDataPackageArn)
        extraDataPackageArn = extraDataPackageArnDecoded
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
        let localeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locale)
        locale = localeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Location.self, forKey: .location)
        location = locationDecoded
        let vpceConfigurationArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .vpceConfigurationArns)
        var vpceConfigurationArnsDecoded0:[String]? = nil
        if let vpceConfigurationArnsContainer = vpceConfigurationArnsContainer {
            vpceConfigurationArnsDecoded0 = [String]()
            for string0 in vpceConfigurationArnsContainer {
                if let string0 = string0 {
                    vpceConfigurationArnsDecoded0?.append(string0)
                }
            }
        }
        vpceConfigurationArns = vpceConfigurationArnsDecoded0
        let customerArtifactPathsDecoded = try containerValues.decodeIfPresent(CustomerArtifactPaths.self, forKey: .customerArtifactPaths)
        customerArtifactPaths = customerArtifactPathsDecoded
        let radiosDecoded = try containerValues.decodeIfPresent(Radios.self, forKey: .radios)
        radios = radiosDecoded
        let auxiliaryAppsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .auxiliaryApps)
        var auxiliaryAppsDecoded0:[String]? = nil
        if let auxiliaryAppsContainer = auxiliaryAppsContainer {
            auxiliaryAppsDecoded0 = [String]()
            for string0 in auxiliaryAppsContainer {
                if let string0 = string0 {
                    auxiliaryAppsDecoded0?.append(string0)
                }
            }
        }
        auxiliaryApps = auxiliaryAppsDecoded0
        let billingMethodDecoded = try containerValues.decodeIfPresent(BillingMethod.self, forKey: .billingMethod)
        billingMethod = billingMethodDecoded
    }
}

extension ScheduleRunConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScheduleRunConfiguration(auxiliaryApps: \(String(describing: auxiliaryApps)), billingMethod: \(String(describing: billingMethod)), customerArtifactPaths: \(String(describing: customerArtifactPaths)), extraDataPackageArn: \(String(describing: extraDataPackageArn)), locale: \(String(describing: locale)), location: \(String(describing: location)), networkProfileArn: \(String(describing: networkProfileArn)), radios: \(String(describing: radios)), vpceConfigurationArns: \(String(describing: vpceConfigurationArns)))"}
}

/// <p>Represents the settings for a run. Includes things like location, radio states,
///             auxiliary apps, and network profiles.</p>
public struct ScheduleRunConfiguration: Equatable {
    /// <p>A list of upload ARNs for app packages to be installed with your app.</p>
    public let auxiliaryApps: [String]?
    /// <p>Specifies the billing method for a test run: <code>metered</code> or
    ///                 <code>unmetered</code>. If the parameter is not specified, the default value is
    ///                 <code>metered</code>.</p>
    ///         <note>
    ///             <p>If you have purchased unmetered device slots, you must set this parameter to <code>unmetered</code> to
    ///                 make use of them. Otherwise, your run counts against your metered time.</p>
    ///         </note>
    public let billingMethod: BillingMethod?
    /// <p>Input <code>CustomerArtifactPaths</code> object for the scheduled run
    ///             configuration.</p>
    public let customerArtifactPaths: CustomerArtifactPaths?
    /// <p>The ARN of the extra data for the run. The extra data is a .zip file that AWS Device Farm extracts to
    ///             external data for Android or the app's sandbox for iOS.</p>
    public let extraDataPackageArn: String?
    /// <p>Information about the locale that is used for the run.</p>
    public let locale: String?
    /// <p>Information about the location that is used for the run.</p>
    public let location: Location?
    /// <p>Reserved for internal use.</p>
    public let networkProfileArn: String?
    /// <p>Information about the radio states for the run.</p>
    public let radios: Radios?
    /// <p>An array of ARNs for your VPC endpoint configurations.</p>
    public let vpceConfigurationArns: [String]?

    public init (
        auxiliaryApps: [String]? = nil,
        billingMethod: BillingMethod? = nil,
        customerArtifactPaths: CustomerArtifactPaths? = nil,
        extraDataPackageArn: String? = nil,
        locale: String? = nil,
        location: Location? = nil,
        networkProfileArn: String? = nil,
        radios: Radios? = nil,
        vpceConfigurationArns: [String]? = nil
    )
    {
        self.auxiliaryApps = auxiliaryApps
        self.billingMethod = billingMethod
        self.customerArtifactPaths = customerArtifactPaths
        self.extraDataPackageArn = extraDataPackageArn
        self.locale = locale
        self.location = location
        self.networkProfileArn = networkProfileArn
        self.radios = radios
        self.vpceConfigurationArns = vpceConfigurationArns
    }
}

public struct ScheduleRunInputBodyMiddleware: Middleware {
    public let id: String = "ScheduleRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ScheduleRunInput>,
                  next: H) -> Swift.Result<OperationOutput<ScheduleRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ScheduleRunInput>
    public typealias MOutput = OperationOutput<ScheduleRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ScheduleRunOutputError>
}

extension ScheduleRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScheduleRunInput(appArn: \(String(describing: appArn)), configuration: \(String(describing: configuration)), devicePoolArn: \(String(describing: devicePoolArn)), deviceSelectionConfiguration: \(String(describing: deviceSelectionConfiguration)), executionConfiguration: \(String(describing: executionConfiguration)), name: \(String(describing: name)), projectArn: \(String(describing: projectArn)), test: \(String(describing: test)))"}
}

extension ScheduleRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appArn
        case configuration
        case devicePoolArn
        case deviceSelectionConfiguration
        case executionConfiguration
        case name
        case projectArn
        case test
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let devicePoolArn = devicePoolArn {
            try encodeContainer.encode(devicePoolArn, forKey: .devicePoolArn)
        }
        if let deviceSelectionConfiguration = deviceSelectionConfiguration {
            try encodeContainer.encode(deviceSelectionConfiguration, forKey: .deviceSelectionConfiguration)
        }
        if let executionConfiguration = executionConfiguration {
            try encodeContainer.encode(executionConfiguration, forKey: .executionConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let test = test {
            try encodeContainer.encode(test, forKey: .test)
        }
    }
}

public struct ScheduleRunInputHeadersMiddleware: Middleware {
    public let id: String = "ScheduleRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ScheduleRunInput>,
                  next: H) -> Swift.Result<OperationOutput<ScheduleRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ScheduleRunInput>
    public typealias MOutput = OperationOutput<ScheduleRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ScheduleRunOutputError>
}

public struct ScheduleRunInputQueryItemMiddleware: Middleware {
    public let id: String = "ScheduleRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ScheduleRunInput>,
                  next: H) -> Swift.Result<OperationOutput<ScheduleRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ScheduleRunInput>
    public typealias MOutput = OperationOutput<ScheduleRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ScheduleRunOutputError>
}

/// <p>Represents a request to the schedule run operation.</p>
public struct ScheduleRunInput: Equatable {
    /// <p>The ARN of an application package to run tests against, created with <a>CreateUpload</a>.
    ///             See <a>ListUploads</a>.</p>
    public let appArn: String?
    /// <p>Information about the settings for the run to be scheduled.</p>
    public let configuration: ScheduleRunConfiguration?
    /// <p>The ARN of the device pool for the run to be scheduled.</p>
    public let devicePoolArn: String?
    /// <p>The filter criteria used to dynamically select a set of devices for a test run and the maximum number of
    ///             devices to be included in the run.</p>
    ///         <p>Either <b>
    ///                <code>devicePoolArn</code>
    ///             </b> or <b>
    ///                <code>deviceSelectionConfiguration</code>
    ///             </b> is required in a
    ///             request.</p>
    public let deviceSelectionConfiguration: DeviceSelectionConfiguration?
    /// <p>Specifies configuration information about a test run, such as the execution timeout
    ///             (in minutes).</p>
    public let executionConfiguration: ExecutionConfiguration?
    /// <p>The name for the run to be scheduled.</p>
    public let name: String?
    /// <p>The ARN of the project for the run to be scheduled.</p>
    public let projectArn: String?
    /// <p>Information about the test for the run to be scheduled.</p>
    public let test: ScheduleRunTest?

    public init (
        appArn: String? = nil,
        configuration: ScheduleRunConfiguration? = nil,
        devicePoolArn: String? = nil,
        deviceSelectionConfiguration: DeviceSelectionConfiguration? = nil,
        executionConfiguration: ExecutionConfiguration? = nil,
        name: String? = nil,
        projectArn: String? = nil,
        test: ScheduleRunTest? = nil
    )
    {
        self.appArn = appArn
        self.configuration = configuration
        self.devicePoolArn = devicePoolArn
        self.deviceSelectionConfiguration = deviceSelectionConfiguration
        self.executionConfiguration = executionConfiguration
        self.name = name
        self.projectArn = projectArn
        self.test = test
    }
}

struct ScheduleRunInputBody: Equatable {
    public let projectArn: String?
    public let appArn: String?
    public let devicePoolArn: String?
    public let deviceSelectionConfiguration: DeviceSelectionConfiguration?
    public let name: String?
    public let test: ScheduleRunTest?
    public let configuration: ScheduleRunConfiguration?
    public let executionConfiguration: ExecutionConfiguration?
}

extension ScheduleRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appArn
        case configuration
        case devicePoolArn
        case deviceSelectionConfiguration
        case executionConfiguration
        case name
        case projectArn
        case test
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let appArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appArn)
        appArn = appArnDecoded
        let devicePoolArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .devicePoolArn)
        devicePoolArn = devicePoolArnDecoded
        let deviceSelectionConfigurationDecoded = try containerValues.decodeIfPresent(DeviceSelectionConfiguration.self, forKey: .deviceSelectionConfiguration)
        deviceSelectionConfiguration = deviceSelectionConfigurationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let testDecoded = try containerValues.decodeIfPresent(ScheduleRunTest.self, forKey: .test)
        test = testDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(ScheduleRunConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let executionConfigurationDecoded = try containerValues.decodeIfPresent(ExecutionConfiguration.self, forKey: .executionConfiguration)
        executionConfiguration = executionConfigurationDecoded
    }
}

extension ScheduleRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ScheduleRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotencyException" : self = .idempotencyException(try IdempotencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ScheduleRunOutputError: Equatable {
    case argumentException(ArgumentException)
    case idempotencyException(IdempotencyException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ScheduleRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScheduleRunOutputResponse(run: \(String(describing: run)))"}
}

extension ScheduleRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ScheduleRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.run = output.run
        } else {
            self.run = nil
        }
    }
}

/// <p>Represents the result of a schedule run request.</p>
public struct ScheduleRunOutputResponse: Equatable {
    /// <p>Information about the scheduled run.</p>
    public let run: Run?

    public init (
        run: Run? = nil
    )
    {
        self.run = run
    }
}

struct ScheduleRunOutputResponseBody: Equatable {
    public let run: Run?
}

extension ScheduleRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case run
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runDecoded = try containerValues.decodeIfPresent(Run.self, forKey: .run)
        run = runDecoded
    }
}

extension ScheduleRunTest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter
        case parameters
        case testPackageArn
        case testSpecArn
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, testparameters0) in parameters {
                try parametersContainer.encode(testparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let testPackageArn = testPackageArn {
            try encodeContainer.encode(testPackageArn, forKey: .testPackageArn)
        }
        if let testSpecArn = testSpecArn {
            try encodeContainer.encode(testSpecArn, forKey: .testSpecArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(TestType.self, forKey: .type)
        type = typeDecoded
        let testPackageArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .testPackageArn)
        testPackageArn = testPackageArnDecoded
        let testSpecArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .testSpecArn)
        testSpecArn = testSpecArnDecoded
        let filterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filter)
        filter = filterDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, string0) in parametersContainer {
                if let string0 = string0 {
                    parametersDecoded0?[key0] = string0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension ScheduleRunTest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScheduleRunTest(filter: \(String(describing: filter)), parameters: \(String(describing: parameters)), testPackageArn: \(String(describing: testPackageArn)), testSpecArn: \(String(describing: testSpecArn)), type: \(String(describing: type)))"}
}

/// <p>Represents test settings. This data structure is passed in as the test parameter to ScheduleRun. For an
///             example of the JSON request syntax, see <a>ScheduleRun</a>.</p>
public struct ScheduleRunTest: Equatable {
    /// <p>The test's filter.</p>
    public let filter: String?
    /// <p>The test's parameters, such as test framework parameters and fixture settings.
    ///             Parameters are represented by name-value pairs of strings.</p>
    ///         <p>For all tests:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>app_performance_monitoring</code>: Performance monitoring is enabled by default.
    ///                     Set this parameter to false to disable it.</p>
    ///             </li>
    ///          </ul>
    ///         <p>For Calabash tests:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>profile: A cucumber profile (for example, <code>my_profile_name</code>).</p>
    ///             </li>
    ///             <li>
    ///                 <p>tags: You can limit execution to features or scenarios that have (or don't
    ///                     have) certain tags (for example, @smoke or @smoke,~@wip).</p>
    ///             </li>
    ///          </ul>
    ///         <p>For Appium tests (all types):</p>
    ///         <ul>
    ///             <li>
    ///                 <p>appium_version: The Appium version. Currently supported values are 1.6.5
    ///                     (and later), latest, and default.</p>
    ///                 <ul>
    ///                   <li>
    ///
    ///                         <p>latest runs the latest Appium version supported by Device
    ///                             Farm (1.9.1).</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>For default, Device Farm selects a compatible version of
    ///                             Appium for the device. The current behavior is to run 1.7.2 on Android
    ///                             devices and iOS 9 and earlier and 1.7.2 for iOS 10 and later.</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>This behavior is subject to change.</p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    ///         <p>For fuzz tests (Android only):</p>
    ///         <ul>
    ///             <li>
    ///                 <p>event_count: The number of events, between 1 and 10000, that the UI fuzz
    ///                     test should perform.</p>
    ///             </li>
    ///             <li>
    ///                 <p>throttle: The time, in ms, between 0 and 1000, that the UI fuzz test should
    ///                     wait between events.</p>
    ///             </li>
    ///             <li>
    ///                 <p>seed: A seed to use for randomizing the UI fuzz test. Using the same seed
    ///                     value between tests ensures identical event sequences.</p>
    ///             </li>
    ///          </ul>
    ///         <p>For Explorer tests:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>username: A user name to use if the Explorer encounters a login form. If not supplied, no user
    ///                     name is inserted.</p>
    ///             </li>
    ///             <li>
    ///                 <p>password: A password to use if the Explorer encounters a login form. If not supplied, no
    ///                     password is inserted.</p>
    ///             </li>
    ///          </ul>
    ///         <p>For Instrumentation:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>filter: A test filter string. Examples:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>Running a single test case: <code>com.android.abc.Test1</code>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>Running a single test: <code>com.android.abc.Test1#smoke</code>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>Running multiple tests:
    ///                             <code>com.android.abc.Test1,com.android.abc.Test2</code>
    ///                      </p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    ///         <p>For XCTest and XCTestUI:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>filter: A test filter string. Examples:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>Running a single test class: <code>LoginTests</code>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>Running a multiple test classes: <code>LoginTests,SmokeTests</code>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>Running a single test: <code>LoginTests/testValid</code>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>Running multiple tests:
    ///                             <code>LoginTests/testValid,LoginTests/testInvalid</code>
    ///                      </p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    ///         <p>For UIAutomator:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>filter: A test filter string. Examples:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>Running a single test case: <code>com.android.abc.Test1</code>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>Running a single test: <code>com.android.abc.Test1#smoke</code>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>Running multiple tests:
    ///                             <code>com.android.abc.Test1,com.android.abc.Test2</code>
    ///                      </p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let parameters: [String:String]?
    /// <p>The ARN of the uploaded test to be run.</p>
    public let testPackageArn: String?
    /// <p>The ARN of the YAML-formatted test specification.</p>
    public let testSpecArn: String?
    /// <p>The test's type.</p>
    ///         <p>Must be one of the following values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>BUILTIN_FUZZ</p>
    ///             </li>
    ///             <li>
    ///                 <p>BUILTIN_EXPLORER. For Android, an app explorer that traverses an
    ///                     Android app, interacting with it and capturing screenshots at the same
    ///                     time.</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_JUNIT</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_TESTNG</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_PYTHON</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_NODE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_RUBY</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_JAVA_JUNIT</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_JAVA_TESTNG</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_PYTHON</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_NODE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_RUBY</p>
    ///             </li>
    ///             <li>
    ///                 <p>CALABASH</p>
    ///             </li>
    ///             <li>
    ///                 <p>INSTRUMENTATION</p>
    ///             </li>
    ///             <li>
    ///                 <p>UIAUTOMATION</p>
    ///             </li>
    ///             <li>
    ///                 <p>UIAUTOMATOR</p>
    ///             </li>
    ///             <li>
    ///                 <p>XCTEST</p>
    ///             </li>
    ///             <li>
    ///                 <p>XCTEST_UI</p>
    ///             </li>
    ///          </ul>
    public let type: TestType?

    public init (
        filter: String? = nil,
        parameters: [String:String]? = nil,
        testPackageArn: String? = nil,
        testSpecArn: String? = nil,
        type: TestType? = nil
    )
    {
        self.filter = filter
        self.parameters = parameters
        self.testPackageArn = testPackageArn
        self.testSpecArn = testSpecArn
        self.type = type
    }
}

extension ServiceAccountException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceAccountException(message: \(String(describing: message)))"}
}

extension ServiceAccountException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceAccountExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There was a problem with the service account.</p>
public struct ServiceAccountException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any additional information about the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceAccountExceptionBody: Equatable {
    public let message: String?
}

extension ServiceAccountExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct StopJobInputBodyMiddleware: Middleware {
    public let id: String = "StopJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopJobInput>
    public typealias MOutput = OperationOutput<StopJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopJobOutputError>
}

extension StopJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopJobInput(arn: \(String(describing: arn)))"}
}

extension StopJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct StopJobInputHeadersMiddleware: Middleware {
    public let id: String = "StopJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopJobInput>
    public typealias MOutput = OperationOutput<StopJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopJobOutputError>
}

public struct StopJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StopJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopJobInput>
    public typealias MOutput = OperationOutput<StopJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopJobOutputError>
}

public struct StopJobInput: Equatable {
    /// <p>Represents the Amazon Resource Name (ARN) of the Device Farm job to stop.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct StopJobInputBody: Equatable {
    public let arn: String?
}

extension StopJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension StopJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopJobOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopJobOutputResponse(job: \(String(describing: job)))"}
}

extension StopJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct StopJobOutputResponse: Equatable {
    /// <p>The job that was stopped.</p>
    public let job: Job?

    public init (
        job: Job? = nil
    )
    {
        self.job = job
    }
}

struct StopJobOutputResponseBody: Equatable {
    public let job: Job?
}

extension StopJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case job
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Job.self, forKey: .job)
        job = jobDecoded
    }
}

public struct StopRemoteAccessSessionInputBodyMiddleware: Middleware {
    public let id: String = "StopRemoteAccessSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<StopRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopRemoteAccessSessionInput>
    public typealias MOutput = OperationOutput<StopRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopRemoteAccessSessionOutputError>
}

extension StopRemoteAccessSessionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopRemoteAccessSessionInput(arn: \(String(describing: arn)))"}
}

extension StopRemoteAccessSessionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct StopRemoteAccessSessionInputHeadersMiddleware: Middleware {
    public let id: String = "StopRemoteAccessSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<StopRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopRemoteAccessSessionInput>
    public typealias MOutput = OperationOutput<StopRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopRemoteAccessSessionOutputError>
}

public struct StopRemoteAccessSessionInputQueryItemMiddleware: Middleware {
    public let id: String = "StopRemoteAccessSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopRemoteAccessSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<StopRemoteAccessSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopRemoteAccessSessionInput>
    public typealias MOutput = OperationOutput<StopRemoteAccessSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopRemoteAccessSessionOutputError>
}

/// <p>Represents the request to stop the remote access session.</p>
public struct StopRemoteAccessSessionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the remote access session to stop.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct StopRemoteAccessSessionInputBody: Equatable {
    public let arn: String?
}

extension StopRemoteAccessSessionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension StopRemoteAccessSessionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopRemoteAccessSessionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopRemoteAccessSessionOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopRemoteAccessSessionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopRemoteAccessSessionOutputResponse(remoteAccessSession: \(String(describing: remoteAccessSession)))"}
}

extension StopRemoteAccessSessionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopRemoteAccessSessionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.remoteAccessSession = output.remoteAccessSession
        } else {
            self.remoteAccessSession = nil
        }
    }
}

/// <p>Represents the response from the server that describes the remote access session
///             when AWS Device Farm stops the session.</p>
public struct StopRemoteAccessSessionOutputResponse: Equatable {
    /// <p>A container that represents the metadata from the service about the remote access session you are
    ///             stopping.</p>
    public let remoteAccessSession: RemoteAccessSession?

    public init (
        remoteAccessSession: RemoteAccessSession? = nil
    )
    {
        self.remoteAccessSession = remoteAccessSession
    }
}

struct StopRemoteAccessSessionOutputResponseBody: Equatable {
    public let remoteAccessSession: RemoteAccessSession?
}

extension StopRemoteAccessSessionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case remoteAccessSession
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remoteAccessSessionDecoded = try containerValues.decodeIfPresent(RemoteAccessSession.self, forKey: .remoteAccessSession)
        remoteAccessSession = remoteAccessSessionDecoded
    }
}

public struct StopRunInputBodyMiddleware: Middleware {
    public let id: String = "StopRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StopRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopRunInput>
    public typealias MOutput = OperationOutput<StopRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopRunOutputError>
}

extension StopRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopRunInput(arn: \(String(describing: arn)))"}
}

extension StopRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct StopRunInputHeadersMiddleware: Middleware {
    public let id: String = "StopRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StopRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopRunInput>
    public typealias MOutput = OperationOutput<StopRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopRunOutputError>
}

public struct StopRunInputQueryItemMiddleware: Middleware {
    public let id: String = "StopRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StopRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopRunInput>
    public typealias MOutput = OperationOutput<StopRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopRunOutputError>
}

/// <p>Represents the request to stop a specific run.</p>
public struct StopRunInput: Equatable {
    /// <p>Represents the Amazon Resource Name (ARN) of the Device Farm run to stop.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct StopRunInputBody: Equatable {
    public let arn: String?
}

extension StopRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension StopRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopRunOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopRunOutputResponse(run: \(String(describing: run)))"}
}

extension StopRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.run = output.run
        } else {
            self.run = nil
        }
    }
}

/// <p>Represents the results of your stop run attempt.</p>
public struct StopRunOutputResponse: Equatable {
    /// <p>The run that was stopped.</p>
    public let run: Run?

    public init (
        run: Run? = nil
    )
    {
        self.run = run
    }
}

struct StopRunOutputResponseBody: Equatable {
    public let run: Run?
}

extension StopRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case run
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runDecoded = try containerValues.decodeIfPresent(Run.self, forKey: .run)
        run = runDecoded
    }
}

extension Suite: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case counters
        case created
        case deviceMinutes
        case message
        case name
        case result
        case started
        case status
        case stopped
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let counters = counters {
            try encodeContainer.encode(counters, forKey: .counters)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let deviceMinutes = deviceMinutes {
            try encodeContainer.encode(deviceMinutes, forKey: .deviceMinutes)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let result = result {
            try encodeContainer.encode(result.rawValue, forKey: .result)
        }
        if let started = started {
            try encodeContainer.encode(started.timeIntervalSince1970, forKey: .started)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stopped = stopped {
            try encodeContainer.encode(stopped.timeIntervalSince1970, forKey: .stopped)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TestType.self, forKey: .type)
        type = typeDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let resultDecoded = try containerValues.decodeIfPresent(ExecutionResult.self, forKey: .result)
        result = resultDecoded
        let startedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .started)
        started = startedDecoded
        let stoppedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .stopped)
        stopped = stoppedDecoded
        let countersDecoded = try containerValues.decodeIfPresent(Counters.self, forKey: .counters)
        counters = countersDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let deviceMinutesDecoded = try containerValues.decodeIfPresent(DeviceMinutes.self, forKey: .deviceMinutes)
        deviceMinutes = deviceMinutesDecoded
    }
}

extension Suite: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Suite(arn: \(String(describing: arn)), counters: \(String(describing: counters)), created: \(String(describing: created)), deviceMinutes: \(String(describing: deviceMinutes)), message: \(String(describing: message)), name: \(String(describing: name)), result: \(String(describing: result)), started: \(String(describing: started)), status: \(String(describing: status)), stopped: \(String(describing: stopped)), type: \(String(describing: type)))"}
}

/// <p>Represents a collection of one or more tests.</p>
public struct Suite: Equatable {
    /// <p>The suite's ARN.</p>
    public let arn: String?
    /// <p>The suite's result counters.</p>
    public let counters: Counters?
    /// <p>When the suite was created.</p>
    public let created: Date?
    /// <p>Represents the total (metered or unmetered) minutes used by the test
    ///             suite.</p>
    public let deviceMinutes: DeviceMinutes?
    /// <p>A message about the suite's result.</p>
    public let message: String?
    /// <p>The suite's name.</p>
    public let name: String?
    /// <p>The suite's result.</p>
    ///         <p>Allowed values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>PENDING</p>
    ///             </li>
    ///             <li>
    ///                 <p>PASSED</p>
    ///             </li>
    ///             <li>
    ///                 <p>WARNED</p>
    ///             </li>
    ///             <li>
    ///                 <p>FAILED</p>
    ///             </li>
    ///             <li>
    ///                 <p>SKIPPED</p>
    ///             </li>
    ///             <li>
    ///                 <p>ERRORED</p>
    ///             </li>
    ///             <li>
    ///                 <p>STOPPED</p>
    ///             </li>
    ///          </ul>
    public let result: ExecutionResult?
    /// <p>The suite's start time.</p>
    public let started: Date?
    /// <p>The suite's status.</p>
    ///         <p>Allowed values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>PENDING</p>
    ///             </li>
    ///             <li>
    ///                 <p>PENDING_CONCURRENCY</p>
    ///             </li>
    ///             <li>
    ///                 <p>PENDING_DEVICE</p>
    ///             </li>
    ///             <li>
    ///                 <p>PROCESSING</p>
    ///             </li>
    ///             <li>
    ///                 <p>SCHEDULING</p>
    ///             </li>
    ///             <li>
    ///                 <p>PREPARING</p>
    ///             </li>
    ///             <li>
    ///                 <p>RUNNING</p>
    ///             </li>
    ///             <li>
    ///                 <p>COMPLETED</p>
    ///             </li>
    ///             <li>
    ///                 <p>STOPPING</p>
    ///             </li>
    ///          </ul>
    public let status: ExecutionStatus?
    /// <p>The suite's stop time.</p>
    public let stopped: Date?
    /// <p>The suite's type.</p>
    ///         <p>Must be one of the following values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>BUILTIN_FUZZ</p>
    ///             </li>
    ///             <li>
    ///                 <p>BUILTIN_EXPLORER </p>
    ///                 <note>
    ///                     <p>Only available for Android; an app explorer that traverses an Android app, interacting with it
    ///                         and capturing screenshots at the same time.</p>
    ///                 </note>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_JUNIT</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_TESTNG</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_PYTHON</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_NODE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_RUBY</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_JAVA_JUNIT</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_JAVA_TESTNG</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_PYTHON</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_NODE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_RUBY</p>
    ///             </li>
    ///             <li>
    ///                 <p>CALABASH</p>
    ///             </li>
    ///             <li>
    ///                 <p>INSTRUMENTATION</p>
    ///             </li>
    ///             <li>
    ///                 <p>UIAUTOMATION</p>
    ///             </li>
    ///             <li>
    ///                 <p>UIAUTOMATOR</p>
    ///             </li>
    ///             <li>
    ///                 <p>XCTEST</p>
    ///             </li>
    ///             <li>
    ///                 <p>XCTEST_UI</p>
    ///             </li>
    ///          </ul>
    public let type: TestType?

    public init (
        arn: String? = nil,
        counters: Counters? = nil,
        created: Date? = nil,
        deviceMinutes: DeviceMinutes? = nil,
        message: String? = nil,
        name: String? = nil,
        result: ExecutionResult? = nil,
        started: Date? = nil,
        status: ExecutionStatus? = nil,
        stopped: Date? = nil,
        type: TestType? = nil
    )
    {
        self.arn = arn
        self.counters = counters
        self.created = created
        self.deviceMinutes = deviceMinutes
        self.message = message
        self.name = name
        self.result = result
        self.started = started
        self.status = status
        self.stopped = stopped
        self.type = type
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>The metadata that you apply to a resource to help you categorize and organize it. Each tag consists of a
///             key and an optional value, both of which you define. Tag keys can have a maximum character length of 128
///             characters. Tag values can have a maximum length of 256 characters. </p>
public struct Tag: Equatable {
    /// <p>One part of a key-value pair that makes up a tag. A <code>key</code> is a general label that acts like a
    ///             category for more specific tag values.</p>
    public let key: String?
    /// <p>The optional part of a key-value pair that makes up a tag. A <code>value</code> acts as a descriptor in a
    ///             tag category (key).</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension TagOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagOperationException(message: \(String(describing: message)), resourceName: \(String(describing: resourceName)))"}
}

extension TagOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TagOperationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation was not successful. Try again.</p>
public struct TagOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var resourceName: String?

    public init (
        message: String? = nil,
        resourceName: String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TagOperationExceptionBody: Equatable {
    public let message: String?
    public let resourceName: String?
}

extension TagOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension TagPolicyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagPolicyException(message: \(String(describing: message)), resourceName: \(String(describing: resourceName)))"}
}

extension TagPolicyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TagPolicyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request doesn't comply with the AWS Identity and Access Management (IAM) tag
///             policy. Correct your request and then retry it.</p>
public struct TagPolicyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var resourceName: String?

    public init (
        message: String? = nil,
        resourceName: String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TagPolicyExceptionBody: Equatable {
    public let message: String?
    public let resourceName: String?
}

extension TagPolicyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceARN: \(String(describing: resourceARN)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource or resources to which to add tags. You can associate tags
    ///             with the following Device Farm resources: <code>PROJECT</code>, <code>RUN</code>,
    ///                 <code>NETWORK_PROFILE</code>, <code>INSTANCE_PROFILE</code>, <code>DEVICE_INSTANCE</code>,
    ///                 <code>SESSION</code>, <code>DEVICE_POOL</code>, <code>DEVICE</code>, and
    ///             <code>VPCE_CONFIGURATION</code>.</p>
    public let resourceARN: String?
    /// <p>The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum
    ///             character length of 128 characters. Tag values can have a maximum length of 256 characters.</p>
    public let tags: [Tag]?

    public init (
        resourceARN: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOperationException" : self = .tagOperationException(try TagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyException" : self = .tagPolicyException(try TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case argumentException(ArgumentException)
    case notFoundException(NotFoundException)
    case tagOperationException(TagOperationException)
    case tagPolicyException(TagPolicyException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Test: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case counters
        case created
        case deviceMinutes
        case message
        case name
        case result
        case started
        case status
        case stopped
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let counters = counters {
            try encodeContainer.encode(counters, forKey: .counters)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let deviceMinutes = deviceMinutes {
            try encodeContainer.encode(deviceMinutes, forKey: .deviceMinutes)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let result = result {
            try encodeContainer.encode(result.rawValue, forKey: .result)
        }
        if let started = started {
            try encodeContainer.encode(started.timeIntervalSince1970, forKey: .started)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stopped = stopped {
            try encodeContainer.encode(stopped.timeIntervalSince1970, forKey: .stopped)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TestType.self, forKey: .type)
        type = typeDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let resultDecoded = try containerValues.decodeIfPresent(ExecutionResult.self, forKey: .result)
        result = resultDecoded
        let startedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .started)
        started = startedDecoded
        let stoppedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .stopped)
        stopped = stoppedDecoded
        let countersDecoded = try containerValues.decodeIfPresent(Counters.self, forKey: .counters)
        counters = countersDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let deviceMinutesDecoded = try containerValues.decodeIfPresent(DeviceMinutes.self, forKey: .deviceMinutes)
        deviceMinutes = deviceMinutesDecoded
    }
}

extension Test: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Test(arn: \(String(describing: arn)), counters: \(String(describing: counters)), created: \(String(describing: created)), deviceMinutes: \(String(describing: deviceMinutes)), message: \(String(describing: message)), name: \(String(describing: name)), result: \(String(describing: result)), started: \(String(describing: started)), status: \(String(describing: status)), stopped: \(String(describing: stopped)), type: \(String(describing: type)))"}
}

/// <p>Represents a condition that is evaluated.</p>
public struct Test: Equatable {
    /// <p>The test's ARN.</p>
    public let arn: String?
    /// <p>The test's result counters.</p>
    public let counters: Counters?
    /// <p>When the test was created.</p>
    public let created: Date?
    /// <p>Represents the total (metered or unmetered) minutes used by the test.</p>
    public let deviceMinutes: DeviceMinutes?
    /// <p>A message about the test's result.</p>
    public let message: String?
    /// <p>The test's name.</p>
    public let name: String?
    /// <p>The test's result.</p>
    ///         <p>Allowed values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>PENDING</p>
    ///             </li>
    ///             <li>
    ///                 <p>PASSED</p>
    ///             </li>
    ///             <li>
    ///                 <p>WARNED</p>
    ///             </li>
    ///             <li>
    ///                 <p>FAILED</p>
    ///             </li>
    ///             <li>
    ///                 <p>SKIPPED</p>
    ///             </li>
    ///             <li>
    ///                 <p>ERRORED</p>
    ///             </li>
    ///             <li>
    ///                 <p>STOPPED</p>
    ///             </li>
    ///          </ul>
    public let result: ExecutionResult?
    /// <p>The test's start time.</p>
    public let started: Date?
    /// <p>The test's status.</p>
    ///         <p>Allowed values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>PENDING</p>
    ///             </li>
    ///             <li>
    ///                 <p>PENDING_CONCURRENCY</p>
    ///             </li>
    ///             <li>
    ///                 <p>PENDING_DEVICE</p>
    ///             </li>
    ///             <li>
    ///                 <p>PROCESSING</p>
    ///             </li>
    ///             <li>
    ///                 <p>SCHEDULING</p>
    ///             </li>
    ///             <li>
    ///                 <p>PREPARING</p>
    ///             </li>
    ///             <li>
    ///                 <p>RUNNING</p>
    ///             </li>
    ///             <li>
    ///                 <p>COMPLETED</p>
    ///             </li>
    ///             <li>
    ///                 <p>STOPPING</p>
    ///             </li>
    ///          </ul>
    public let status: ExecutionStatus?
    /// <p>The test's stop time.</p>
    public let stopped: Date?
    /// <p>The test's type.</p>
    ///         <p>Must be one of the following values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>BUILTIN_FUZZ</p>
    ///             </li>
    ///             <li>
    ///                 <p>BUILTIN_EXPLORER</p>
    ///                 <note>
    ///                     <p>For Android, an app explorer that traverses an Android app, interacting with it and capturing
    ///                         screenshots at the same time.</p>
    ///                 </note>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_JUNIT</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_TESTNG</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_PYTHON</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_NODE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_RUBY</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_JAVA_JUNIT</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_JAVA_TESTNG</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_PYTHON</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_NODE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_RUBY</p>
    ///             </li>
    ///             <li>
    ///                 <p>CALABASH</p>
    ///             </li>
    ///             <li>
    ///                 <p>INSTRUMENTATION</p>
    ///             </li>
    ///             <li>
    ///                 <p>UIAUTOMATION</p>
    ///             </li>
    ///             <li>
    ///                 <p>UIAUTOMATOR</p>
    ///             </li>
    ///             <li>
    ///                 <p>XCTEST</p>
    ///             </li>
    ///             <li>
    ///                 <p>XCTEST_UI</p>
    ///             </li>
    ///          </ul>
    public let type: TestType?

    public init (
        arn: String? = nil,
        counters: Counters? = nil,
        created: Date? = nil,
        deviceMinutes: DeviceMinutes? = nil,
        message: String? = nil,
        name: String? = nil,
        result: ExecutionResult? = nil,
        started: Date? = nil,
        status: ExecutionStatus? = nil,
        stopped: Date? = nil,
        type: TestType? = nil
    )
    {
        self.arn = arn
        self.counters = counters
        self.created = created
        self.deviceMinutes = deviceMinutes
        self.message = message
        self.name = name
        self.result = result
        self.started = started
        self.status = status
        self.stopped = stopped
        self.type = type
    }
}

extension TestGridProject: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case created
        case description
        case name
        case vpcConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(TestGridVpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
    }
}

extension TestGridProject: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestGridProject(arn: \(String(describing: arn)), created: \(String(describing: created)), description: \(String(describing: description)), name: \(String(describing: name)), vpcConfig: \(String(describing: vpcConfig)))"}
}

/// <p>A Selenium testing project. Projects are used to collect and collate sessions.</p>
public struct TestGridProject: Equatable {
    /// <p>The ARN for the project.</p>
    public let arn: String?
    /// <p>When the project was created.</p>
    public let created: Date?
    /// <p>A human-readable description for the project.</p>
    public let description: String?
    /// <p>A human-readable name for the project.</p>
    public let name: String?
    /// <p>The VPC security groups and subnets that are attached to a project.</p>
    public let vpcConfig: TestGridVpcConfig?

    public init (
        arn: String? = nil,
        created: Date? = nil,
        description: String? = nil,
        name: String? = nil,
        vpcConfig: TestGridVpcConfig? = nil
    )
    {
        self.arn = arn
        self.created = created
        self.description = description
        self.name = name
        self.vpcConfig = vpcConfig
    }
}

extension TestGridSession: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case billingMinutes
        case created
        case ended
        case seleniumProperties
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let billingMinutes = billingMinutes {
            try encodeContainer.encode(billingMinutes, forKey: .billingMinutes)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let ended = ended {
            try encodeContainer.encode(ended.timeIntervalSince1970, forKey: .ended)
        }
        if let seleniumProperties = seleniumProperties {
            try encodeContainer.encode(seleniumProperties, forKey: .seleniumProperties)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TestGridSessionStatus.self, forKey: .status)
        status = statusDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let endedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .ended)
        ended = endedDecoded
        let billingMinutesDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .billingMinutes)
        billingMinutes = billingMinutesDecoded
        let seleniumPropertiesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .seleniumProperties)
        seleniumProperties = seleniumPropertiesDecoded
    }
}

extension TestGridSession: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestGridSession(arn: \(String(describing: arn)), billingMinutes: \(String(describing: billingMinutes)), created: \(String(describing: created)), ended: \(String(describing: ended)), seleniumProperties: \(String(describing: seleniumProperties)), status: \(String(describing: status)))"}
}

/// <p>A <a>TestGridSession</a> is a single instance of a browser launched from the URL provided by a
///          call to <a>CreateTestGridUrl</a>.</p>
public struct TestGridSession: Equatable {
    /// <p>The ARN of the session.</p>
    public let arn: String?
    /// <p>The number of billed minutes that were used for this session. </p>
    public let billingMinutes: Double?
    /// <p>The time that the session was started.</p>
    public let created: Date?
    /// <p>The time the session ended.</p>
    public let ended: Date?
    /// <p>A JSON object of options and parameters passed to the Selenium WebDriver.</p>
    public let seleniumProperties: String?
    /// <p>The state of the session.</p>
    public let status: TestGridSessionStatus?

    public init (
        arn: String? = nil,
        billingMinutes: Double? = nil,
        created: Date? = nil,
        ended: Date? = nil,
        seleniumProperties: String? = nil,
        status: TestGridSessionStatus? = nil
    )
    {
        self.arn = arn
        self.billingMinutes = billingMinutes
        self.created = created
        self.ended = ended
        self.seleniumProperties = seleniumProperties
        self.status = status
    }
}

extension TestGridSessionAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action
        case duration
        case requestMethod
        case started
        case statusCode
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let duration = duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let requestMethod = requestMethod {
            try encodeContainer.encode(requestMethod, forKey: .requestMethod)
        }
        if let started = started {
            try encodeContainer.encode(started.timeIntervalSince1970, forKey: .started)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .action)
        action = actionDecoded
        let startedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .started)
        started = startedDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .duration)
        duration = durationDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let requestMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestMethod)
        requestMethod = requestMethodDecoded
    }
}

extension TestGridSessionAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestGridSessionAction(action: \(String(describing: action)), duration: \(String(describing: duration)), requestMethod: \(String(describing: requestMethod)), started: \(String(describing: started)), statusCode: \(String(describing: statusCode)))"}
}

/// <p>An action taken by a <a>TestGridSession</a> browser instance.</p>
public struct TestGridSessionAction: Equatable {
    /// <p>The action taken by the session.</p>
    public let action: String?
    /// <p>The time, in milliseconds, that the action took to complete in the browser.</p>
    public let duration: Int?
    /// <p>HTTP method that the browser used to make the request.</p>
    public let requestMethod: String?
    /// <p>The time that the session invoked the action.</p>
    public let started: Date?
    /// <p>HTTP status code returned to the browser when the action was taken.</p>
    public let statusCode: String?

    public init (
        action: String? = nil,
        duration: Int? = nil,
        requestMethod: String? = nil,
        started: Date? = nil,
        statusCode: String? = nil
    )
    {
        self.action = action
        self.duration = duration
        self.requestMethod = requestMethod
        self.started = started
        self.statusCode = statusCode
    }
}

extension TestGridSessionArtifact: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filename
        case type
        case url
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filename = filename {
            try encodeContainer.encode(filename, forKey: .filename)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filenameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filename)
        filename = filenameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TestGridSessionArtifactType.self, forKey: .type)
        type = typeDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension TestGridSessionArtifact: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestGridSessionArtifact(filename: \(String(describing: filename)), type: \(String(describing: type)), url: \(String(describing: url)))"}
}

/// <p>Artifacts are video and other files that are produced in the process of running a browser in an automated
///          context. </p>
///          <note>
///             <p>Video elements might be broken up into multiple artifacts as they grow in size during creation. </p>
///          </note>
public struct TestGridSessionArtifact: Equatable {
    /// <p>The file name of the artifact.</p>
    public let filename: String?
    /// <p>The kind of artifact.</p>
    public let type: TestGridSessionArtifactType?
    /// <p>A semi-stable URL to the content of the object.</p>
    public let url: String?

    public init (
        filename: String? = nil,
        type: TestGridSessionArtifactType? = nil,
        url: String? = nil
    )
    {
        self.filename = filename
        self.type = type
        self.url = url
    }
}

public enum TestGridSessionArtifactCategory {
    case log
    case video
    case sdkUnknown(String)
}

extension TestGridSessionArtifactCategory : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TestGridSessionArtifactCategory] {
        return [
            .log,
            .video,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .log: return "LOG"
        case .video: return "VIDEO"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TestGridSessionArtifactCategory(rawValue: rawValue) ?? TestGridSessionArtifactCategory.sdkUnknown(rawValue)
    }
}

public enum TestGridSessionArtifactType {
    case seleniumLog
    case unknown
    case video
    case sdkUnknown(String)
}

extension TestGridSessionArtifactType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TestGridSessionArtifactType] {
        return [
            .seleniumLog,
            .unknown,
            .video,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .seleniumLog: return "SELENIUM_LOG"
        case .unknown: return "UNKNOWN"
        case .video: return "VIDEO"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TestGridSessionArtifactType(rawValue: rawValue) ?? TestGridSessionArtifactType.sdkUnknown(rawValue)
    }
}

public enum TestGridSessionStatus {
    case active
    case closed
    case errored
    case sdkUnknown(String)
}

extension TestGridSessionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TestGridSessionStatus] {
        return [
            .active,
            .closed,
            .errored,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .closed: return "CLOSED"
        case .errored: return "ERRORED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TestGridSessionStatus(rawValue: rawValue) ?? TestGridSessionStatus.sdkUnknown(rawValue)
    }
}

extension TestGridVpcConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case securityGroupIds
        case subnetIds
        case vpcId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension TestGridVpcConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestGridVpcConfig(securityGroupIds: \(String(describing: securityGroupIds)), subnetIds: \(String(describing: subnetIds)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>The VPC security groups and subnets that are attached to a project.</p>
public struct TestGridVpcConfig: Equatable {
    /// <p>A list of VPC security group IDs in your Amazon VPC.</p>
    public let securityGroupIds: [String]?
    /// <p>A list of VPC subnet IDs in your Amazon VPC.</p>
    public let subnetIds: [String]?
    /// <p>The ID of the Amazon VPC.</p>
    public let vpcId: String?

    public init (
        securityGroupIds: [String]? = nil,
        subnetIds: [String]? = nil,
        vpcId: String? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

public enum TestType {
    case appiumJavaJunit
    case appiumJavaTestng
    case appiumNode
    case appiumPython
    case appiumRuby
    case appiumWebJavaJunit
    case appiumWebJavaTestng
    case appiumWebNode
    case appiumWebPython
    case appiumWebRuby
    case builtinExplorer
    case builtinFuzz
    case calabash
    case instrumentation
    case remoteAccessRecord
    case remoteAccessReplay
    case uiautomation
    case uiautomator
    case webPerformanceProfile
    case xctest
    case xctestUi
    case sdkUnknown(String)
}

extension TestType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TestType] {
        return [
            .appiumJavaJunit,
            .appiumJavaTestng,
            .appiumNode,
            .appiumPython,
            .appiumRuby,
            .appiumWebJavaJunit,
            .appiumWebJavaTestng,
            .appiumWebNode,
            .appiumWebPython,
            .appiumWebRuby,
            .builtinExplorer,
            .builtinFuzz,
            .calabash,
            .instrumentation,
            .remoteAccessRecord,
            .remoteAccessReplay,
            .uiautomation,
            .uiautomator,
            .webPerformanceProfile,
            .xctest,
            .xctestUi,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .appiumJavaJunit: return "APPIUM_JAVA_JUNIT"
        case .appiumJavaTestng: return "APPIUM_JAVA_TESTNG"
        case .appiumNode: return "APPIUM_NODE"
        case .appiumPython: return "APPIUM_PYTHON"
        case .appiumRuby: return "APPIUM_RUBY"
        case .appiumWebJavaJunit: return "APPIUM_WEB_JAVA_JUNIT"
        case .appiumWebJavaTestng: return "APPIUM_WEB_JAVA_TESTNG"
        case .appiumWebNode: return "APPIUM_WEB_NODE"
        case .appiumWebPython: return "APPIUM_WEB_PYTHON"
        case .appiumWebRuby: return "APPIUM_WEB_RUBY"
        case .builtinExplorer: return "BUILTIN_EXPLORER"
        case .builtinFuzz: return "BUILTIN_FUZZ"
        case .calabash: return "CALABASH"
        case .instrumentation: return "INSTRUMENTATION"
        case .remoteAccessRecord: return "REMOTE_ACCESS_RECORD"
        case .remoteAccessReplay: return "REMOTE_ACCESS_REPLAY"
        case .uiautomation: return "UIAUTOMATION"
        case .uiautomator: return "UIAUTOMATOR"
        case .webPerformanceProfile: return "WEB_PERFORMANCE_PROFILE"
        case .xctest: return "XCTEST"
        case .xctestUi: return "XCTEST_UI"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TestType(rawValue: rawValue) ?? TestType.sdkUnknown(rawValue)
    }
}

extension TooManyTagsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTagsException(message: \(String(describing: message)), resourceName: \(String(describing: resourceName)))"}
}

extension TooManyTagsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The list of tags on the repository is over the limit. The maximum number of tags that
///             can be applied to a repository is 50. </p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var resourceName: String?

    public init (
        message: String? = nil,
        resourceName: String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Equatable {
    public let message: String?
    public let resourceName: String?
}

extension TooManyTagsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension TrialMinutes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case remaining
        case total
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let remaining = remaining {
            try encodeContainer.encode(remaining, forKey: .remaining)
        }
        if let total = total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .total)
        total = totalDecoded
        let remainingDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .remaining)
        remaining = remainingDecoded
    }
}

extension TrialMinutes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrialMinutes(remaining: \(String(describing: remaining)), total: \(String(describing: total)))"}
}

/// <p>Represents information about free trial device minutes for an AWS
///             account.</p>
public struct TrialMinutes: Equatable {
    /// <p>The number of free trial minutes remaining in the account.</p>
    public let remaining: Double?
    /// <p>The total number of free trial minutes that the account started with.</p>
    public let total: Double?

    public init (
        remaining: Double? = nil,
        total: Double? = nil
    )
    {
        self.remaining = remaining
        self.total = total
    }
}

extension UniqueProblem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
        case problems
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let problems = problems {
            var problemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .problems)
            for problems0 in problems {
                try problemsContainer.encode(problems0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let problemsContainer = try containerValues.decodeIfPresent([Problem?].self, forKey: .problems)
        var problemsDecoded0:[Problem]? = nil
        if let problemsContainer = problemsContainer {
            problemsDecoded0 = [Problem]()
            for structure0 in problemsContainer {
                if let structure0 = structure0 {
                    problemsDecoded0?.append(structure0)
                }
            }
        }
        problems = problemsDecoded0
    }
}

extension UniqueProblem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UniqueProblem(message: \(String(describing: message)), problems: \(String(describing: problems)))"}
}

/// <p>A collection of one or more problems, grouped by their result.</p>
public struct UniqueProblem: Equatable {
    /// <p>A message about the unique problems' result.</p>
    public let message: String?
    /// <p>Information about the problems.</p>
    public let problems: [Problem]?

    public init (
        message: String? = nil,
        problems: [Problem]? = nil
    )
    {
        self.message = message
        self.problems = problems
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceARN: \(String(describing: resourceARN)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource or resources from which to delete tags. You can associate
    ///             tags with the following Device Farm resources: <code>PROJECT</code>, <code>RUN</code>,
    ///                 <code>NETWORK_PROFILE</code>, <code>INSTANCE_PROFILE</code>, <code>DEVICE_INSTANCE</code>,
    ///                 <code>SESSION</code>, <code>DEVICE_POOL</code>, <code>DEVICE</code>, and
    ///             <code>VPCE_CONFIGURATION</code>.</p>
    public let resourceARN: String?
    /// <p>The keys of the tags to be removed.</p>
    public let tagKeys: [String]?

    public init (
        resourceARN: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOperationException" : self = .tagOperationException(try TagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case argumentException(ArgumentException)
    case notFoundException(NotFoundException)
    case tagOperationException(TagOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDeviceInstanceInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDeviceInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeviceInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeviceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeviceInstanceInput>
    public typealias MOutput = OperationOutput<UpdateDeviceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeviceInstanceOutputError>
}

extension UpdateDeviceInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDeviceInstanceInput(arn: \(String(describing: arn)), labels: \(String(describing: labels)), profileArn: \(String(describing: profileArn)))"}
}

extension UpdateDeviceInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case labels
        case profileArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for instancelabels0 in labels {
                try labelsContainer.encode(instancelabels0)
            }
        }
        if let profileArn = profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
    }
}

public struct UpdateDeviceInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDeviceInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeviceInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeviceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeviceInstanceInput>
    public typealias MOutput = OperationOutput<UpdateDeviceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeviceInstanceOutputError>
}

public struct UpdateDeviceInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDeviceInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeviceInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeviceInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeviceInstanceInput>
    public typealias MOutput = OperationOutput<UpdateDeviceInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeviceInstanceOutputError>
}

public struct UpdateDeviceInstanceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the device instance.</p>
    public let arn: String?
    /// <p>An array of strings that you want to associate with the device instance.</p>
    public let labels: [String]?
    /// <p>The ARN of the profile that you want to associate with the device instance.</p>
    public let profileArn: String?

    public init (
        arn: String? = nil,
        labels: [String]? = nil,
        profileArn: String? = nil
    )
    {
        self.arn = arn
        self.labels = labels
        self.profileArn = profileArn
    }
}

struct UpdateDeviceInstanceInputBody: Equatable {
    public let arn: String?
    public let profileArn: String?
    public let labels: [String]?
}

extension UpdateDeviceInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case labels
        case profileArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let profileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let labelsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .labels)
        var labelsDecoded0:[String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
    }
}

extension UpdateDeviceInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDeviceInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDeviceInstanceOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDeviceInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDeviceInstanceOutputResponse(deviceInstance: \(String(describing: deviceInstance)))"}
}

extension UpdateDeviceInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDeviceInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deviceInstance = output.deviceInstance
        } else {
            self.deviceInstance = nil
        }
    }
}

public struct UpdateDeviceInstanceOutputResponse: Equatable {
    /// <p>An object that contains information about your device instance.</p>
    public let deviceInstance: DeviceInstance?

    public init (
        deviceInstance: DeviceInstance? = nil
    )
    {
        self.deviceInstance = deviceInstance
    }
}

struct UpdateDeviceInstanceOutputResponseBody: Equatable {
    public let deviceInstance: DeviceInstance?
}

extension UpdateDeviceInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceInstance
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceInstanceDecoded = try containerValues.decodeIfPresent(DeviceInstance.self, forKey: .deviceInstance)
        deviceInstance = deviceInstanceDecoded
    }
}

public struct UpdateDevicePoolInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDevicePoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDevicePoolInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDevicePoolInput>
    public typealias MOutput = OperationOutput<UpdateDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDevicePoolOutputError>
}

extension UpdateDevicePoolInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDevicePoolInput(arn: \(String(describing: arn)), clearMaxDevices: \(String(describing: clearMaxDevices)), description: \(String(describing: description)), maxDevices: \(String(describing: maxDevices)), name: \(String(describing: name)), rules: \(String(describing: rules)))"}
}

extension UpdateDevicePoolInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case clearMaxDevices
        case description
        case maxDevices
        case name
        case rules
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let clearMaxDevices = clearMaxDevices {
            try encodeContainer.encode(clearMaxDevices, forKey: .clearMaxDevices)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let maxDevices = maxDevices {
            try encodeContainer.encode(maxDevices, forKey: .maxDevices)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rules0 in rules {
                try rulesContainer.encode(rules0)
            }
        }
    }
}

public struct UpdateDevicePoolInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDevicePoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDevicePoolInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDevicePoolInput>
    public typealias MOutput = OperationOutput<UpdateDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDevicePoolOutputError>
}

public struct UpdateDevicePoolInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDevicePoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDevicePoolInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDevicePoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDevicePoolInput>
    public typealias MOutput = OperationOutput<UpdateDevicePoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDevicePoolOutputError>
}

/// <p>Represents a request to the update device pool operation.</p>
public struct UpdateDevicePoolInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Device Farm device pool to update.</p>
    public let arn: String?
    /// <p>Sets whether the <code>maxDevices</code> parameter applies to your device pool. If you set this parameter
    ///             to <code>true</code>, the <code>maxDevices</code> parameter does not apply, and Device Farm does not limit
    ///             the number of devices that it adds to your device pool. In this case, Device Farm adds all available devices
    ///             that meet the criteria specified in the <code>rules</code> parameter.</p>
    ///         <p>If you use this parameter in your request, you cannot use the <code>maxDevices</code>
    ///             parameter in the same request.</p>
    public let clearMaxDevices: Bool?
    /// <p>A description of the device pool to update.</p>
    public let description: String?
    /// <p>The number of devices that Device Farm can add to your device pool. Device Farm adds
    ///             devices that are available and that meet the criteria that you assign for the
    ///                 <code>rules</code> parameter. Depending on how many devices meet these constraints,
    ///             your device pool might contain fewer devices than the value for this parameter.</p>
    ///         <p>By specifying the maximum number of devices, you can control the costs that you incur
    ///             by running tests.</p>
    ///         <p>If you use this parameter in your request, you cannot use the
    ///                 <code>clearMaxDevices</code> parameter in the same request.</p>
    public let maxDevices: Int?
    /// <p>A string that represents the name of the device pool to update.</p>
    public let name: String?
    /// <p>Represents the rules to modify for the device pool. Updating rules is optional. If you update rules for
    ///             your request, the update replaces the existing rules.</p>
    public let rules: [Rule]?

    public init (
        arn: String? = nil,
        clearMaxDevices: Bool? = nil,
        description: String? = nil,
        maxDevices: Int? = nil,
        name: String? = nil,
        rules: [Rule]? = nil
    )
    {
        self.arn = arn
        self.clearMaxDevices = clearMaxDevices
        self.description = description
        self.maxDevices = maxDevices
        self.name = name
        self.rules = rules
    }
}

struct UpdateDevicePoolInputBody: Equatable {
    public let arn: String?
    public let name: String?
    public let description: String?
    public let rules: [Rule]?
    public let maxDevices: Int?
    public let clearMaxDevices: Bool?
}

extension UpdateDevicePoolInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case clearMaxDevices
        case description
        case maxDevices
        case name
        case rules
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([Rule?].self, forKey: .rules)
        var rulesDecoded0:[Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let maxDevicesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxDevices)
        maxDevices = maxDevicesDecoded
        let clearMaxDevicesDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .clearMaxDevices)
        clearMaxDevices = clearMaxDevicesDecoded
    }
}

extension UpdateDevicePoolOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDevicePoolOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDevicePoolOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDevicePoolOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDevicePoolOutputResponse(devicePool: \(String(describing: devicePool)))"}
}

extension UpdateDevicePoolOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDevicePoolOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.devicePool = output.devicePool
        } else {
            self.devicePool = nil
        }
    }
}

/// <p>Represents the result of an update device pool request.</p>
public struct UpdateDevicePoolOutputResponse: Equatable {
    /// <p>The device pool you just updated.</p>
    public let devicePool: DevicePool?

    public init (
        devicePool: DevicePool? = nil
    )
    {
        self.devicePool = devicePool
    }
}

struct UpdateDevicePoolOutputResponseBody: Equatable {
    public let devicePool: DevicePool?
}

extension UpdateDevicePoolOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case devicePool
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicePoolDecoded = try containerValues.decodeIfPresent(DevicePool.self, forKey: .devicePool)
        devicePool = devicePoolDecoded
    }
}

public struct UpdateInstanceProfileInputBodyMiddleware: Middleware {
    public let id: String = "UpdateInstanceProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInstanceProfileInput>
    public typealias MOutput = OperationOutput<UpdateInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInstanceProfileOutputError>
}

extension UpdateInstanceProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateInstanceProfileInput(arn: \(String(describing: arn)), description: \(String(describing: description)), excludeAppPackagesFromCleanup: \(String(describing: excludeAppPackagesFromCleanup)), name: \(String(describing: name)), packageCleanup: \(String(describing: packageCleanup)), rebootAfterUse: \(String(describing: rebootAfterUse)))"}
}

extension UpdateInstanceProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case description
        case excludeAppPackagesFromCleanup
        case name
        case packageCleanup
        case rebootAfterUse
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup {
            var excludeAppPackagesFromCleanupContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeAppPackagesFromCleanup)
            for packageids0 in excludeAppPackagesFromCleanup {
                try excludeAppPackagesFromCleanupContainer.encode(packageids0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packageCleanup = packageCleanup {
            try encodeContainer.encode(packageCleanup, forKey: .packageCleanup)
        }
        if let rebootAfterUse = rebootAfterUse {
            try encodeContainer.encode(rebootAfterUse, forKey: .rebootAfterUse)
        }
    }
}

public struct UpdateInstanceProfileInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateInstanceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInstanceProfileInput>
    public typealias MOutput = OperationOutput<UpdateInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInstanceProfileOutputError>
}

public struct UpdateInstanceProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateInstanceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInstanceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInstanceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInstanceProfileInput>
    public typealias MOutput = OperationOutput<UpdateInstanceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInstanceProfileOutputError>
}

public struct UpdateInstanceProfileInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the instance profile.</p>
    public let arn: String?
    /// <p>The updated description for your instance profile.</p>
    public let description: String?
    /// <p>An array of strings that specifies the list of app packages that should not be cleaned up from the device
    ///             after a test run is over.</p>
    ///         <p>The list of packages is only considered if you set <code>packageCleanup</code> to
    ///                 <code>true</code>.</p>
    public let excludeAppPackagesFromCleanup: [String]?
    /// <p>The updated name for your instance profile.</p>
    public let name: String?
    /// <p>The updated choice for whether you want to specify package cleanup. The default value
    ///             is <code>false</code> for private devices.</p>
    public let packageCleanup: Bool?
    /// <p>The updated choice for whether you want to reboot the device after use. The default
    ///             value is <code>true</code>.</p>
    public let rebootAfterUse: Bool?

    public init (
        arn: String? = nil,
        description: String? = nil,
        excludeAppPackagesFromCleanup: [String]? = nil,
        name: String? = nil,
        packageCleanup: Bool? = nil,
        rebootAfterUse: Bool? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup
        self.name = name
        self.packageCleanup = packageCleanup
        self.rebootAfterUse = rebootAfterUse
    }
}

struct UpdateInstanceProfileInputBody: Equatable {
    public let arn: String?
    public let name: String?
    public let description: String?
    public let packageCleanup: Bool?
    public let excludeAppPackagesFromCleanup: [String]?
    public let rebootAfterUse: Bool?
}

extension UpdateInstanceProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case description
        case excludeAppPackagesFromCleanup
        case name
        case packageCleanup
        case rebootAfterUse
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let packageCleanupDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .packageCleanup)
        packageCleanup = packageCleanupDecoded
        let excludeAppPackagesFromCleanupContainer = try containerValues.decodeIfPresent([String?].self, forKey: .excludeAppPackagesFromCleanup)
        var excludeAppPackagesFromCleanupDecoded0:[String]? = nil
        if let excludeAppPackagesFromCleanupContainer = excludeAppPackagesFromCleanupContainer {
            excludeAppPackagesFromCleanupDecoded0 = [String]()
            for string0 in excludeAppPackagesFromCleanupContainer {
                if let string0 = string0 {
                    excludeAppPackagesFromCleanupDecoded0?.append(string0)
                }
            }
        }
        excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanupDecoded0
        let rebootAfterUseDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .rebootAfterUse)
        rebootAfterUse = rebootAfterUseDecoded
    }
}

extension UpdateInstanceProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateInstanceProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateInstanceProfileOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateInstanceProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateInstanceProfileOutputResponse(instanceProfile: \(String(describing: instanceProfile)))"}
}

extension UpdateInstanceProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateInstanceProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instanceProfile = output.instanceProfile
        } else {
            self.instanceProfile = nil
        }
    }
}

public struct UpdateInstanceProfileOutputResponse: Equatable {
    /// <p>An object that contains information about your instance profile.</p>
    public let instanceProfile: InstanceProfile?

    public init (
        instanceProfile: InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

struct UpdateInstanceProfileOutputResponseBody: Equatable {
    public let instanceProfile: InstanceProfile?
}

extension UpdateInstanceProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceProfile
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileDecoded = try containerValues.decodeIfPresent(InstanceProfile.self, forKey: .instanceProfile)
        instanceProfile = instanceProfileDecoded
    }
}

public struct UpdateNetworkProfileInputBodyMiddleware: Middleware {
    public let id: String = "UpdateNetworkProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateNetworkProfileInput>
    public typealias MOutput = OperationOutput<UpdateNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateNetworkProfileOutputError>
}

extension UpdateNetworkProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateNetworkProfileInput(arn: \(String(describing: arn)), description: \(String(describing: description)), downlinkBandwidthBits: \(String(describing: downlinkBandwidthBits)), downlinkDelayMs: \(String(describing: downlinkDelayMs)), downlinkJitterMs: \(String(describing: downlinkJitterMs)), downlinkLossPercent: \(String(describing: downlinkLossPercent)), name: \(String(describing: name)), type: \(String(describing: type)), uplinkBandwidthBits: \(String(describing: uplinkBandwidthBits)), uplinkDelayMs: \(String(describing: uplinkDelayMs)), uplinkJitterMs: \(String(describing: uplinkJitterMs)), uplinkLossPercent: \(String(describing: uplinkLossPercent)))"}
}

extension UpdateNetworkProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case description
        case downlinkBandwidthBits
        case downlinkDelayMs
        case downlinkJitterMs
        case downlinkLossPercent
        case name
        case type
        case uplinkBandwidthBits
        case uplinkDelayMs
        case uplinkJitterMs
        case uplinkLossPercent
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let downlinkBandwidthBits = downlinkBandwidthBits {
            try encodeContainer.encode(downlinkBandwidthBits, forKey: .downlinkBandwidthBits)
        }
        if let downlinkDelayMs = downlinkDelayMs {
            try encodeContainer.encode(downlinkDelayMs, forKey: .downlinkDelayMs)
        }
        if let downlinkJitterMs = downlinkJitterMs {
            try encodeContainer.encode(downlinkJitterMs, forKey: .downlinkJitterMs)
        }
        if downlinkLossPercent != 0 {
            try encodeContainer.encode(downlinkLossPercent, forKey: .downlinkLossPercent)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uplinkBandwidthBits = uplinkBandwidthBits {
            try encodeContainer.encode(uplinkBandwidthBits, forKey: .uplinkBandwidthBits)
        }
        if let uplinkDelayMs = uplinkDelayMs {
            try encodeContainer.encode(uplinkDelayMs, forKey: .uplinkDelayMs)
        }
        if let uplinkJitterMs = uplinkJitterMs {
            try encodeContainer.encode(uplinkJitterMs, forKey: .uplinkJitterMs)
        }
        if uplinkLossPercent != 0 {
            try encodeContainer.encode(uplinkLossPercent, forKey: .uplinkLossPercent)
        }
    }
}

public struct UpdateNetworkProfileInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateNetworkProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateNetworkProfileInput>
    public typealias MOutput = OperationOutput<UpdateNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateNetworkProfileOutputError>
}

public struct UpdateNetworkProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateNetworkProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateNetworkProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateNetworkProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateNetworkProfileInput>
    public typealias MOutput = OperationOutput<UpdateNetworkProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateNetworkProfileOutputError>
}

public struct UpdateNetworkProfileInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the project for which you want to update network
    ///             profile settings.</p>
    public let arn: String?
    /// <p>The description of the network profile about which you are returning
    ///             information.</p>
    public let description: String?
    /// <p>The data throughput rate in bits per second, as an integer from 0 to
    ///             104857600.</p>
    public let downlinkBandwidthBits: Int?
    /// <p>Delay time for all packets to destination in milliseconds as an integer from 0 to
    ///             2000.</p>
    public let downlinkDelayMs: Int?
    /// <p>Time variation in the delay of received packets in milliseconds as an integer from
    ///             0 to 2000.</p>
    public let downlinkJitterMs: Int?
    /// <p>Proportion of received packets that fail to arrive from 0 to 100 percent.</p>
    public let downlinkLossPercent: Int
    /// <p>The name of the network profile about which you are returning
    ///             information.</p>
    public let name: String?
    /// <p>The type of network profile to return information about. Valid values are listed here.</p>
    public let type: NetworkProfileType?
    /// <p>The data throughput rate in bits per second, as an integer from 0 to
    ///             104857600.</p>
    public let uplinkBandwidthBits: Int?
    /// <p>Delay time for all packets to destination in milliseconds as an integer from 0 to
    ///             2000.</p>
    public let uplinkDelayMs: Int?
    /// <p>Time variation in the delay of received packets in milliseconds as an integer from
    ///             0 to 2000.</p>
    public let uplinkJitterMs: Int?
    /// <p>Proportion of transmitted packets that fail to arrive from 0 to 100
    ///             percent.</p>
    public let uplinkLossPercent: Int

    public init (
        arn: String? = nil,
        description: String? = nil,
        downlinkBandwidthBits: Int? = nil,
        downlinkDelayMs: Int? = nil,
        downlinkJitterMs: Int? = nil,
        downlinkLossPercent: Int = 0,
        name: String? = nil,
        type: NetworkProfileType? = nil,
        uplinkBandwidthBits: Int? = nil,
        uplinkDelayMs: Int? = nil,
        uplinkJitterMs: Int? = nil,
        uplinkLossPercent: Int = 0
    )
    {
        self.arn = arn
        self.description = description
        self.downlinkBandwidthBits = downlinkBandwidthBits
        self.downlinkDelayMs = downlinkDelayMs
        self.downlinkJitterMs = downlinkJitterMs
        self.downlinkLossPercent = downlinkLossPercent
        self.name = name
        self.type = type
        self.uplinkBandwidthBits = uplinkBandwidthBits
        self.uplinkDelayMs = uplinkDelayMs
        self.uplinkJitterMs = uplinkJitterMs
        self.uplinkLossPercent = uplinkLossPercent
    }
}

struct UpdateNetworkProfileInputBody: Equatable {
    public let arn: String?
    public let name: String?
    public let description: String?
    public let type: NetworkProfileType?
    public let uplinkBandwidthBits: Int?
    public let downlinkBandwidthBits: Int?
    public let uplinkDelayMs: Int?
    public let downlinkDelayMs: Int?
    public let uplinkJitterMs: Int?
    public let downlinkJitterMs: Int?
    public let uplinkLossPercent: Int
    public let downlinkLossPercent: Int
}

extension UpdateNetworkProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case description
        case downlinkBandwidthBits
        case downlinkDelayMs
        case downlinkJitterMs
        case downlinkLossPercent
        case name
        case type
        case uplinkBandwidthBits
        case uplinkDelayMs
        case uplinkJitterMs
        case uplinkLossPercent
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(NetworkProfileType.self, forKey: .type)
        type = typeDecoded
        let uplinkBandwidthBitsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .uplinkBandwidthBits)
        uplinkBandwidthBits = uplinkBandwidthBitsDecoded
        let downlinkBandwidthBitsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .downlinkBandwidthBits)
        downlinkBandwidthBits = downlinkBandwidthBitsDecoded
        let uplinkDelayMsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .uplinkDelayMs)
        uplinkDelayMs = uplinkDelayMsDecoded
        let downlinkDelayMsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .downlinkDelayMs)
        downlinkDelayMs = downlinkDelayMsDecoded
        let uplinkJitterMsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .uplinkJitterMs)
        uplinkJitterMs = uplinkJitterMsDecoded
        let downlinkJitterMsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .downlinkJitterMs)
        downlinkJitterMs = downlinkJitterMsDecoded
        let uplinkLossPercentDecoded = try containerValues.decode(Int.self, forKey: .uplinkLossPercent)
        uplinkLossPercent = uplinkLossPercentDecoded
        let downlinkLossPercentDecoded = try containerValues.decode(Int.self, forKey: .downlinkLossPercent)
        downlinkLossPercent = downlinkLossPercentDecoded
    }
}

extension UpdateNetworkProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNetworkProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateNetworkProfileOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNetworkProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateNetworkProfileOutputResponse(networkProfile: \(String(describing: networkProfile)))"}
}

extension UpdateNetworkProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateNetworkProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.networkProfile = output.networkProfile
        } else {
            self.networkProfile = nil
        }
    }
}

public struct UpdateNetworkProfileOutputResponse: Equatable {
    /// <p>A list of the available network profiles.</p>
    public let networkProfile: NetworkProfile?

    public init (
        networkProfile: NetworkProfile? = nil
    )
    {
        self.networkProfile = networkProfile
    }
}

struct UpdateNetworkProfileOutputResponseBody: Equatable {
    public let networkProfile: NetworkProfile?
}

extension UpdateNetworkProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case networkProfile
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileDecoded = try containerValues.decodeIfPresent(NetworkProfile.self, forKey: .networkProfile)
        networkProfile = networkProfileDecoded
    }
}

public struct UpdateProjectInputBodyMiddleware: Middleware {
    public let id: String = "UpdateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProjectOutputError>
}

extension UpdateProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProjectInput(arn: \(String(describing: arn)), defaultJobTimeoutMinutes: \(String(describing: defaultJobTimeoutMinutes)), name: \(String(describing: name)))"}
}

extension UpdateProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case defaultJobTimeoutMinutes
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let defaultJobTimeoutMinutes = defaultJobTimeoutMinutes {
            try encodeContainer.encode(defaultJobTimeoutMinutes, forKey: .defaultJobTimeoutMinutes)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateProjectInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProjectOutputError>
}

/// <p>Represents a request to the update project operation.</p>
public struct UpdateProjectInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the project whose name to update.</p>
    public let arn: String?
    /// <p>The number of minutes a test run in the project executes before it times out.</p>
    public let defaultJobTimeoutMinutes: Int?
    /// <p>A string that represents the new name of the project that you are updating.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        defaultJobTimeoutMinutes: Int? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
        self.name = name
    }
}

struct UpdateProjectInputBody: Equatable {
    public let arn: String?
    public let name: String?
    public let defaultJobTimeoutMinutes: Int?
}

extension UpdateProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case defaultJobTimeoutMinutes
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let defaultJobTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .defaultJobTimeoutMinutes)
        defaultJobTimeoutMinutes = defaultJobTimeoutMinutesDecoded
    }
}

extension UpdateProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProjectOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProjectOutputResponse(project: \(String(describing: project)))"}
}

extension UpdateProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.project = output.project
        } else {
            self.project = nil
        }
    }
}

/// <p>Represents the result of an update project request.</p>
public struct UpdateProjectOutputResponse: Equatable {
    /// <p>The project to update.</p>
    public let project: Project?

    public init (
        project: Project? = nil
    )
    {
        self.project = project
    }
}

struct UpdateProjectOutputResponseBody: Equatable {
    public let project: Project?
}

extension UpdateProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case project
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDecoded = try containerValues.decodeIfPresent(Project.self, forKey: .project)
        project = projectDecoded
    }
}

public struct UpdateTestGridProjectInputBodyMiddleware: Middleware {
    public let id: String = "UpdateTestGridProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTestGridProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTestGridProjectInput>
    public typealias MOutput = OperationOutput<UpdateTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTestGridProjectOutputError>
}

extension UpdateTestGridProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTestGridProjectInput(description: \(String(describing: description)), name: \(String(describing: name)), projectArn: \(String(describing: projectArn)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension UpdateTestGridProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case name
        case projectArn
        case vpcConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct UpdateTestGridProjectInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateTestGridProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTestGridProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTestGridProjectInput>
    public typealias MOutput = OperationOutput<UpdateTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTestGridProjectOutputError>
}

public struct UpdateTestGridProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateTestGridProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTestGridProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTestGridProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTestGridProjectInput>
    public typealias MOutput = OperationOutput<UpdateTestGridProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTestGridProjectOutputError>
}

public struct UpdateTestGridProjectInput: Equatable {
    /// <p>Human-readable description for the project.</p>
    public let description: String?
    /// <p>Human-readable name for the project.</p>
    public let name: String?
    /// <p>ARN of the project to update.</p>
    public let projectArn: String?
    /// <p>The VPC security groups and subnets that are attached to a project.</p>
    public let vpcConfig: TestGridVpcConfig?

    public init (
        description: String? = nil,
        name: String? = nil,
        projectArn: String? = nil,
        vpcConfig: TestGridVpcConfig? = nil
    )
    {
        self.description = description
        self.name = name
        self.projectArn = projectArn
        self.vpcConfig = vpcConfig
    }
}

struct UpdateTestGridProjectInputBody: Equatable {
    public let projectArn: String?
    public let name: String?
    public let description: String?
    public let vpcConfig: TestGridVpcConfig?
}

extension UpdateTestGridProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case name
        case projectArn
        case vpcConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(TestGridVpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension UpdateTestGridProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTestGridProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTestGridProjectOutputError: Equatable {
    case argumentException(ArgumentException)
    case internalServiceException(InternalServiceException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTestGridProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTestGridProjectOutputResponse(testGridProject: \(String(describing: testGridProject)))"}
}

extension UpdateTestGridProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateTestGridProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.testGridProject = output.testGridProject
        } else {
            self.testGridProject = nil
        }
    }
}

public struct UpdateTestGridProjectOutputResponse: Equatable {
    /// <p>The project, including updated information.</p>
    public let testGridProject: TestGridProject?

    public init (
        testGridProject: TestGridProject? = nil
    )
    {
        self.testGridProject = testGridProject
    }
}

struct UpdateTestGridProjectOutputResponseBody: Equatable {
    public let testGridProject: TestGridProject?
}

extension UpdateTestGridProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case testGridProject
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testGridProjectDecoded = try containerValues.decodeIfPresent(TestGridProject.self, forKey: .testGridProject)
        testGridProject = testGridProjectDecoded
    }
}

public struct UpdateUploadInputBodyMiddleware: Middleware {
    public let id: String = "UpdateUploadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUploadInput>
    public typealias MOutput = OperationOutput<UpdateUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUploadOutputError>
}

extension UpdateUploadInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUploadInput(arn: \(String(describing: arn)), contentType: \(String(describing: contentType)), editContent: \(String(describing: editContent)), name: \(String(describing: name)))"}
}

extension UpdateUploadInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case contentType
        case editContent
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let editContent = editContent {
            try encodeContainer.encode(editContent, forKey: .editContent)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateUploadInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUploadInput>
    public typealias MOutput = OperationOutput<UpdateUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUploadOutputError>
}

public struct UpdateUploadInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUploadInput>
    public typealias MOutput = OperationOutput<UpdateUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUploadOutputError>
}

public struct UpdateUploadInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the uploaded test spec.</p>
    public let arn: String?
    /// <p>The upload's content type (for example, <code>application/x-yaml</code>).</p>
    public let contentType: String?
    /// <p>Set to true if the YAML file has changed and must be updated. Otherwise, set to false.</p>
    public let editContent: Bool?
    /// <p>The upload's test spec file name. The name must not contain any forward slashes (/). The test spec file
    ///             name must end with the <code>.yaml</code> or <code>.yml</code> file extension.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        contentType: String? = nil,
        editContent: Bool? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.contentType = contentType
        self.editContent = editContent
        self.name = name
    }
}

struct UpdateUploadInputBody: Equatable {
    public let arn: String?
    public let name: String?
    public let contentType: String?
    public let editContent: Bool?
}

extension UpdateUploadInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case contentType
        case editContent
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let editContentDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .editContent)
        editContent = editContentDecoded
    }
}

extension UpdateUploadOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUploadOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUploadOutputError: Equatable {
    case argumentException(ArgumentException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUploadOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUploadOutputResponse(upload: \(String(describing: upload)))"}
}

extension UpdateUploadOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateUploadOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.upload = output.upload
        } else {
            self.upload = nil
        }
    }
}

public struct UpdateUploadOutputResponse: Equatable {
    /// <p>A test spec uploaded to Device Farm.</p>
    public let upload: Upload?

    public init (
        upload: Upload? = nil
    )
    {
        self.upload = upload
    }
}

struct UpdateUploadOutputResponseBody: Equatable {
    public let upload: Upload?
}

extension UpdateUploadOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case upload
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadDecoded = try containerValues.decodeIfPresent(Upload.self, forKey: .upload)
        upload = uploadDecoded
    }
}

public struct UpdateVPCEConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateVPCEConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVPCEConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVPCEConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVPCEConfigurationOutputError>
}

extension UpdateVPCEConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVPCEConfigurationInput(arn: \(String(describing: arn)), serviceDnsName: \(String(describing: serviceDnsName)), vpceConfigurationDescription: \(String(describing: vpceConfigurationDescription)), vpceConfigurationName: \(String(describing: vpceConfigurationName)), vpceServiceName: \(String(describing: vpceServiceName)))"}
}

extension UpdateVPCEConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case serviceDnsName
        case vpceConfigurationDescription
        case vpceConfigurationName
        case vpceServiceName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let serviceDnsName = serviceDnsName {
            try encodeContainer.encode(serviceDnsName, forKey: .serviceDnsName)
        }
        if let vpceConfigurationDescription = vpceConfigurationDescription {
            try encodeContainer.encode(vpceConfigurationDescription, forKey: .vpceConfigurationDescription)
        }
        if let vpceConfigurationName = vpceConfigurationName {
            try encodeContainer.encode(vpceConfigurationName, forKey: .vpceConfigurationName)
        }
        if let vpceServiceName = vpceServiceName {
            try encodeContainer.encode(vpceServiceName, forKey: .vpceServiceName)
        }
    }
}

public struct UpdateVPCEConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateVPCEConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVPCEConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVPCEConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVPCEConfigurationOutputError>
}

public struct UpdateVPCEConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateVPCEConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVPCEConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVPCEConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVPCEConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateVPCEConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVPCEConfigurationOutputError>
}

public struct UpdateVPCEConfigurationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the VPC endpoint configuration you want to
    ///             update.</p>
    public let arn: String?
    /// <p>The DNS (domain) name used to connect to your private service in your VPC. The DNS name must not already
    ///             be in use on the internet.</p>
    public let serviceDnsName: String?
    /// <p>An optional description that provides details about your VPC endpoint configuration.</p>
    public let vpceConfigurationDescription: String?
    /// <p>The friendly name you give to your VPC endpoint configuration to manage your configurations more
    ///             easily.</p>
    public let vpceConfigurationName: String?
    /// <p>The name of the VPC endpoint service running in your AWS account that you want Device Farm to test.</p>
    public let vpceServiceName: String?

    public init (
        arn: String? = nil,
        serviceDnsName: String? = nil,
        vpceConfigurationDescription: String? = nil,
        vpceConfigurationName: String? = nil,
        vpceServiceName: String? = nil
    )
    {
        self.arn = arn
        self.serviceDnsName = serviceDnsName
        self.vpceConfigurationDescription = vpceConfigurationDescription
        self.vpceConfigurationName = vpceConfigurationName
        self.vpceServiceName = vpceServiceName
    }
}

struct UpdateVPCEConfigurationInputBody: Equatable {
    public let arn: String?
    public let vpceConfigurationName: String?
    public let vpceServiceName: String?
    public let serviceDnsName: String?
    public let vpceConfigurationDescription: String?
}

extension UpdateVPCEConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case serviceDnsName
        case vpceConfigurationDescription
        case vpceConfigurationName
        case vpceServiceName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let vpceConfigurationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpceConfigurationName)
        vpceConfigurationName = vpceConfigurationNameDecoded
        let vpceServiceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpceServiceName)
        vpceServiceName = vpceServiceNameDecoded
        let serviceDnsNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceDnsName)
        serviceDnsName = serviceDnsNameDecoded
        let vpceConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpceConfigurationDescription)
        vpceConfigurationDescription = vpceConfigurationDescriptionDecoded
    }
}

extension UpdateVPCEConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVPCEConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ArgumentException" : self = .argumentException(try ArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceAccountException" : self = .serviceAccountException(try ServiceAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateVPCEConfigurationOutputError: Equatable {
    case argumentException(ArgumentException)
    case invalidOperationException(InvalidOperationException)
    case notFoundException(NotFoundException)
    case serviceAccountException(ServiceAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVPCEConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVPCEConfigurationOutputResponse(vpceConfiguration: \(String(describing: vpceConfiguration)))"}
}

extension UpdateVPCEConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateVPCEConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.vpceConfiguration = output.vpceConfiguration
        } else {
            self.vpceConfiguration = nil
        }
    }
}

public struct UpdateVPCEConfigurationOutputResponse: Equatable {
    /// <p>An object that contains information about your VPC endpoint configuration.</p>
    public let vpceConfiguration: VPCEConfiguration?

    public init (
        vpceConfiguration: VPCEConfiguration? = nil
    )
    {
        self.vpceConfiguration = vpceConfiguration
    }
}

struct UpdateVPCEConfigurationOutputResponseBody: Equatable {
    public let vpceConfiguration: VPCEConfiguration?
}

extension UpdateVPCEConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case vpceConfiguration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpceConfigurationDecoded = try containerValues.decodeIfPresent(VPCEConfiguration.self, forKey: .vpceConfiguration)
        vpceConfiguration = vpceConfigurationDecoded
    }
}

extension Upload: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case category
        case contentType
        case created
        case message
        case metadata
        case name
        case status
        case type
        case url
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(UploadType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(UploadStatus.self, forKey: .status)
        status = statusDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metadata)
        metadata = metadataDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(UploadCategory.self, forKey: .category)
        category = categoryDecoded
    }
}

extension Upload: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Upload(arn: \(String(describing: arn)), category: \(String(describing: category)), contentType: \(String(describing: contentType)), created: \(String(describing: created)), message: \(String(describing: message)), metadata: \(String(describing: metadata)), name: \(String(describing: name)), status: \(String(describing: status)), type: \(String(describing: type)), url: \(String(describing: url)))"}
}

/// <p>An app or a set of one or more tests to upload or that have been
///             uploaded.</p>
public struct Upload: Equatable {
    /// <p>The upload's ARN.</p>
    public let arn: String?
    /// <p>The upload's category. Allowed values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>CURATED: An upload managed by AWS Device Farm.</p>
    ///             </li>
    ///             <li>
    ///                 <p>PRIVATE: An upload managed by the AWS Device Farm customer.</p>
    ///             </li>
    ///          </ul>
    public let category: UploadCategory?
    /// <p>The upload's content type (for example, <code>application/octet-stream</code>).</p>
    public let contentType: String?
    /// <p>When the upload was created.</p>
    public let created: Date?
    /// <p>A message about the upload's result.</p>
    public let message: String?
    /// <p>The upload's metadata. For example, for Android, this contains information that is
    ///             parsed from the manifest and is displayed in the AWS Device Farm console after the
    ///             associated app is uploaded.</p>
    public let metadata: String?
    /// <p>The upload's file name.</p>
    public let name: String?
    /// <p>The upload's status.</p>
    ///         <p>Must be one of the following values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>FAILED</p>
    ///             </li>
    ///             <li>
    ///                 <p>INITIALIZED</p>
    ///             </li>
    ///             <li>
    ///                 <p>PROCESSING</p>
    ///             </li>
    ///             <li>
    ///                 <p>SUCCEEDED</p>
    ///             </li>
    ///          </ul>
    public let status: UploadStatus?
    /// <p>The upload's type.</p>
    ///         <p>Must be one of the following values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>ANDROID_APP</p>
    ///             </li>
    ///             <li>
    ///                 <p>IOS_APP</p>
    ///             </li>
    ///             <li>
    ///                 <p>WEB_APP</p>
    ///             </li>
    ///             <li>
    ///                 <p>EXTERNAL_DATA</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_JUNIT_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_TESTNG_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_PYTHON_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_NODE_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_RUBY_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_PYTHON_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_NODE_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_RUBY_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>CALABASH_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>INSTRUMENTATION_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>UIAUTOMATION_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>UIAUTOMATOR_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>XCTEST_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>XCTEST_UI_TEST_PACKAGE</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_JUNIT_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_JAVA_TESTNG_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_PYTHON_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_NODE_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_RUBY_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_JAVA_JUNIT_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_JAVA_TESTNG_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_PYTHON_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_NODE_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>APPIUM_WEB_RUBY_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>INSTRUMENTATION_TEST_SPEC</p>
    ///             </li>
    ///             <li>
    ///                 <p>XCTEST_UI_TEST_SPEC</p>
    ///             </li>
    ///          </ul>
    public let type: UploadType?
    /// <p>The presigned Amazon S3 URL that was used to store a file using a PUT request.</p>
    public let url: String?

    public init (
        arn: String? = nil,
        category: UploadCategory? = nil,
        contentType: String? = nil,
        created: Date? = nil,
        message: String? = nil,
        metadata: String? = nil,
        name: String? = nil,
        status: UploadStatus? = nil,
        type: UploadType? = nil,
        url: String? = nil
    )
    {
        self.arn = arn
        self.category = category
        self.contentType = contentType
        self.created = created
        self.message = message
        self.metadata = metadata
        self.name = name
        self.status = status
        self.type = type
        self.url = url
    }
}

public enum UploadCategory {
    case curated
    case `private`
    case sdkUnknown(String)
}

extension UploadCategory : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UploadCategory] {
        return [
            .curated,
            .private,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .curated: return "CURATED"
        case .private: return "PRIVATE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UploadCategory(rawValue: rawValue) ?? UploadCategory.sdkUnknown(rawValue)
    }
}

public enum UploadStatus {
    case failed
    case initialized
    case processing
    case succeeded
    case sdkUnknown(String)
}

extension UploadStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UploadStatus] {
        return [
            .failed,
            .initialized,
            .processing,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .initialized: return "INITIALIZED"
        case .processing: return "PROCESSING"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UploadStatus(rawValue: rawValue) ?? UploadStatus.sdkUnknown(rawValue)
    }
}

public enum UploadType {
    case androidApp
    case appiumJavaJunitTestPackage
    case appiumJavaJunitTestSpec
    case appiumJavaTestngTestPackage
    case appiumJavaTestngTestSpec
    case appiumNodeTestPackage
    case appiumNodeTestSpec
    case appiumPythonTestPackage
    case appiumPythonTestSpec
    case appiumRubyTestPackage
    case appiumRubyTestSpec
    case appiumWebJavaJunitTestPackage
    case appiumWebJavaJunitTestSpec
    case appiumWebJavaTestngTestPackage
    case appiumWebJavaTestngTestSpec
    case appiumWebNodeTestPackage
    case appiumWebNodeTestSpec
    case appiumWebPythonTestPackage
    case appiumWebPythonTestSpec
    case appiumWebRubyTestPackage
    case appiumWebRubyTestSpec
    case calabashTestPackage
    case externalData
    case instrumentationTestPackage
    case instrumentationTestSpec
    case iosApp
    case uiautomationTestPackage
    case uiautomatorTestPackage
    case webApp
    case xctestTestPackage
    case xctestUiTestPackage
    case xctestUiTestSpec
    case sdkUnknown(String)
}

extension UploadType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UploadType] {
        return [
            .androidApp,
            .appiumJavaJunitTestPackage,
            .appiumJavaJunitTestSpec,
            .appiumJavaTestngTestPackage,
            .appiumJavaTestngTestSpec,
            .appiumNodeTestPackage,
            .appiumNodeTestSpec,
            .appiumPythonTestPackage,
            .appiumPythonTestSpec,
            .appiumRubyTestPackage,
            .appiumRubyTestSpec,
            .appiumWebJavaJunitTestPackage,
            .appiumWebJavaJunitTestSpec,
            .appiumWebJavaTestngTestPackage,
            .appiumWebJavaTestngTestSpec,
            .appiumWebNodeTestPackage,
            .appiumWebNodeTestSpec,
            .appiumWebPythonTestPackage,
            .appiumWebPythonTestSpec,
            .appiumWebRubyTestPackage,
            .appiumWebRubyTestSpec,
            .calabashTestPackage,
            .externalData,
            .instrumentationTestPackage,
            .instrumentationTestSpec,
            .iosApp,
            .uiautomationTestPackage,
            .uiautomatorTestPackage,
            .webApp,
            .xctestTestPackage,
            .xctestUiTestPackage,
            .xctestUiTestSpec,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .androidApp: return "ANDROID_APP"
        case .appiumJavaJunitTestPackage: return "APPIUM_JAVA_JUNIT_TEST_PACKAGE"
        case .appiumJavaJunitTestSpec: return "APPIUM_JAVA_JUNIT_TEST_SPEC"
        case .appiumJavaTestngTestPackage: return "APPIUM_JAVA_TESTNG_TEST_PACKAGE"
        case .appiumJavaTestngTestSpec: return "APPIUM_JAVA_TESTNG_TEST_SPEC"
        case .appiumNodeTestPackage: return "APPIUM_NODE_TEST_PACKAGE"
        case .appiumNodeTestSpec: return "APPIUM_NODE_TEST_SPEC"
        case .appiumPythonTestPackage: return "APPIUM_PYTHON_TEST_PACKAGE"
        case .appiumPythonTestSpec: return "APPIUM_PYTHON_TEST_SPEC"
        case .appiumRubyTestPackage: return "APPIUM_RUBY_TEST_PACKAGE"
        case .appiumRubyTestSpec: return "APPIUM_RUBY_TEST_SPEC"
        case .appiumWebJavaJunitTestPackage: return "APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE"
        case .appiumWebJavaJunitTestSpec: return "APPIUM_WEB_JAVA_JUNIT_TEST_SPEC"
        case .appiumWebJavaTestngTestPackage: return "APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE"
        case .appiumWebJavaTestngTestSpec: return "APPIUM_WEB_JAVA_TESTNG_TEST_SPEC"
        case .appiumWebNodeTestPackage: return "APPIUM_WEB_NODE_TEST_PACKAGE"
        case .appiumWebNodeTestSpec: return "APPIUM_WEB_NODE_TEST_SPEC"
        case .appiumWebPythonTestPackage: return "APPIUM_WEB_PYTHON_TEST_PACKAGE"
        case .appiumWebPythonTestSpec: return "APPIUM_WEB_PYTHON_TEST_SPEC"
        case .appiumWebRubyTestPackage: return "APPIUM_WEB_RUBY_TEST_PACKAGE"
        case .appiumWebRubyTestSpec: return "APPIUM_WEB_RUBY_TEST_SPEC"
        case .calabashTestPackage: return "CALABASH_TEST_PACKAGE"
        case .externalData: return "EXTERNAL_DATA"
        case .instrumentationTestPackage: return "INSTRUMENTATION_TEST_PACKAGE"
        case .instrumentationTestSpec: return "INSTRUMENTATION_TEST_SPEC"
        case .iosApp: return "IOS_APP"
        case .uiautomationTestPackage: return "UIAUTOMATION_TEST_PACKAGE"
        case .uiautomatorTestPackage: return "UIAUTOMATOR_TEST_PACKAGE"
        case .webApp: return "WEB_APP"
        case .xctestTestPackage: return "XCTEST_TEST_PACKAGE"
        case .xctestUiTestPackage: return "XCTEST_UI_TEST_PACKAGE"
        case .xctestUiTestSpec: return "XCTEST_UI_TEST_SPEC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UploadType(rawValue: rawValue) ?? UploadType.sdkUnknown(rawValue)
    }
}

extension VPCEConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case serviceDnsName
        case vpceConfigurationDescription
        case vpceConfigurationName
        case vpceServiceName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let serviceDnsName = serviceDnsName {
            try encodeContainer.encode(serviceDnsName, forKey: .serviceDnsName)
        }
        if let vpceConfigurationDescription = vpceConfigurationDescription {
            try encodeContainer.encode(vpceConfigurationDescription, forKey: .vpceConfigurationDescription)
        }
        if let vpceConfigurationName = vpceConfigurationName {
            try encodeContainer.encode(vpceConfigurationName, forKey: .vpceConfigurationName)
        }
        if let vpceServiceName = vpceServiceName {
            try encodeContainer.encode(vpceServiceName, forKey: .vpceServiceName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let vpceConfigurationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpceConfigurationName)
        vpceConfigurationName = vpceConfigurationNameDecoded
        let vpceServiceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpceServiceName)
        vpceServiceName = vpceServiceNameDecoded
        let serviceDnsNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceDnsName)
        serviceDnsName = serviceDnsNameDecoded
        let vpceConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpceConfigurationDescription)
        vpceConfigurationDescription = vpceConfigurationDescriptionDecoded
    }
}

extension VPCEConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VPCEConfiguration(arn: \(String(describing: arn)), serviceDnsName: \(String(describing: serviceDnsName)), vpceConfigurationDescription: \(String(describing: vpceConfigurationDescription)), vpceConfigurationName: \(String(describing: vpceConfigurationName)), vpceServiceName: \(String(describing: vpceServiceName)))"}
}

/// <p>Represents an Amazon Virtual Private Cloud (VPC) endpoint configuration.</p>
public struct VPCEConfiguration: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the VPC endpoint configuration.</p>
    public let arn: String?
    /// <p>The DNS name that maps to the private IP address of the service you want to
    ///             access.</p>
    public let serviceDnsName: String?
    /// <p>An optional description that provides details about your VPC endpoint configuration.</p>
    public let vpceConfigurationDescription: String?
    /// <p>The friendly name you give to your VPC endpoint configuration to manage your configurations more
    ///             easily.</p>
    public let vpceConfigurationName: String?
    /// <p>The name of the VPC endpoint service running in your AWS account that you want Device Farm to test.</p>
    public let vpceServiceName: String?

    public init (
        arn: String? = nil,
        serviceDnsName: String? = nil,
        vpceConfigurationDescription: String? = nil,
        vpceConfigurationName: String? = nil,
        vpceServiceName: String? = nil
    )
    {
        self.arn = arn
        self.serviceDnsName = serviceDnsName
        self.vpceConfigurationDescription = vpceConfigurationDescription
        self.vpceConfigurationName = vpceConfigurationName
        self.vpceServiceName = vpceServiceName
    }
}
