// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AddAttributesActivity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes
        case name
        case next
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, attributenamemapping0) in attributes {
                try attributesContainer.encode(attributenamemapping0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            try encodeContainer.encode(next, forKey: .next)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attributename0) in attributesContainer {
                if let attributename0 = attributename0 {
                    attributesDecoded0?[key0] = attributename0
                }
            }
        }
        attributes = attributesDecoded0
        let nextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .next)
        next = nextDecoded
    }
}

extension AddAttributesActivity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddAttributesActivity(attributes: \(String(describing: attributes)), name: \(String(describing: name)), next: \(String(describing: next)))"}
}

/// <p>An activity that adds other attributes based on existing attributes in the message.</p>
public struct AddAttributesActivity: Equatable {
    /// <p>A list of 1-50 <code>AttributeNameMapping</code> objects that map an existing attribute to
    ///       a new attribute.</p>
    ///          <note>
    ///             <p>The existing attributes remain in the message, so if you want to remove the originals,
    ///         use <code>RemoveAttributeActivity</code>.</p>
    ///          </note>
    public let attributes: [String:String]?
    /// <p>The name of the addAttributes activity.</p>
    public let name: String?
    /// <p>The next activity in the pipeline.</p>
    public let next: String?

    public init (
        attributes: [String:String]? = nil,
        name: String? = nil,
        next: String? = nil
    )
    {
        self.attributes = attributes
        self.name = name
        self.next = next
    }
}

extension BatchPutMessageErrorEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode
        case errorMessage
        case messageId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let messageId = messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension BatchPutMessageErrorEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchPutMessageErrorEntry(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), messageId: \(String(describing: messageId)))"}
}

/// <p>Contains informations about errors.</p>
public struct BatchPutMessageErrorEntry: Equatable {
    /// <p>The code associated with the error.</p>
    public let errorCode: String?
    /// <p>The message associated with the error.</p>
    public let errorMessage: String?
    /// <p>The ID of the message that caused the error. See the value corresponding to the
    ///             <code>messageId</code> key in the message object.</p>
    public let messageId: String?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil,
        messageId: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.messageId = messageId
    }
}

public struct BatchPutMessageInputBodyMiddleware: Middleware {
    public let id: String = "BatchPutMessageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchPutMessageInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchPutMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchPutMessageInput>
    public typealias MOutput = OperationOutput<BatchPutMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchPutMessageOutputError>
}

extension BatchPutMessageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchPutMessageInput(channelName: \(String(describing: channelName)), messages: \(String(describing: messages)))"}
}

extension BatchPutMessageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelName
        case messages
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelName = channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let messages = messages {
            var messagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messages)
            for messages0 in messages {
                try messagesContainer.encode(messages0)
            }
        }
    }
}

public struct BatchPutMessageInputHeadersMiddleware: Middleware {
    public let id: String = "BatchPutMessageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchPutMessageInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchPutMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchPutMessageInput>
    public typealias MOutput = OperationOutput<BatchPutMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchPutMessageOutputError>
}

public struct BatchPutMessageInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchPutMessageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchPutMessageInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchPutMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchPutMessageInput>
    public typealias MOutput = OperationOutput<BatchPutMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchPutMessageOutputError>
}

public struct BatchPutMessageInput: Equatable {
    /// <p>The name of the channel where the messages are sent.</p>
    public let channelName: String?
    /// <p>The list of messages to be sent. Each message has the format: { "messageId": "string",
    ///          "payload": "string"}.</p>
    ///          <p>The field names of message payloads (data) that you send to AWS IoT Analytics:</p>
    ///         <ul>
    ///             <li>
    ///                <p>Must contain only alphanumeric characters and undescores (_). No other special characters are
    ///                allowed.</p>
    ///             </li>
    ///             <li>
    ///                <p>Must begin with an alphabetic character or single underscore (_).</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot contain hyphens (-).</p>
    ///             </li>
    ///             <li>
    ///                <p>In regular expression terms: "^[A-Za-z_]([A-Za-z0-9]*|[A-Za-z0-9][A-Za-z0-9_]*)$".
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot be more than 255 characters.</p>
    ///             </li>
    ///             <li>
    ///                <p>Are case insensitive. (Fields named foo and FOO in the same payload are considered
    ///                duplicates.)</p>
    ///             </li>
    ///          </ul>
    ///          <p>For example, {"temp_01": 29} or {"_temp_01": 29} are valid, but {"temp-01": 29},
    ///  {"01_temp": 29} or {"__temp_01": 29} are invalid in message payloads.  </p>
    public let messages: [Message]?

    public init (
        channelName: String? = nil,
        messages: [Message]? = nil
    )
    {
        self.channelName = channelName
        self.messages = messages
    }
}

struct BatchPutMessageInputBody: Equatable {
    public let channelName: String?
    public let messages: [Message]?
}

extension BatchPutMessageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channelName
        case messages
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let messagesContainer = try containerValues.decodeIfPresent([Message?].self, forKey: .messages)
        var messagesDecoded0:[Message]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [Message]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
    }
}

extension BatchPutMessageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchPutMessageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchPutMessageOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchPutMessageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchPutMessageOutputResponse(batchPutMessageErrorEntries: \(String(describing: batchPutMessageErrorEntries)))"}
}

extension BatchPutMessageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchPutMessageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.batchPutMessageErrorEntries = output.batchPutMessageErrorEntries
        } else {
            self.batchPutMessageErrorEntries = nil
        }
    }
}

public struct BatchPutMessageOutputResponse: Equatable {
    /// <p>A list of any errors encountered when sending the messages to the channel.</p>
    public let batchPutMessageErrorEntries: [BatchPutMessageErrorEntry]?

    public init (
        batchPutMessageErrorEntries: [BatchPutMessageErrorEntry]? = nil
    )
    {
        self.batchPutMessageErrorEntries = batchPutMessageErrorEntries
    }
}

struct BatchPutMessageOutputResponseBody: Equatable {
    public let batchPutMessageErrorEntries: [BatchPutMessageErrorEntry]?
}

extension BatchPutMessageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case batchPutMessageErrorEntries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchPutMessageErrorEntriesContainer = try containerValues.decodeIfPresent([BatchPutMessageErrorEntry?].self, forKey: .batchPutMessageErrorEntries)
        var batchPutMessageErrorEntriesDecoded0:[BatchPutMessageErrorEntry]? = nil
        if let batchPutMessageErrorEntriesContainer = batchPutMessageErrorEntriesContainer {
            batchPutMessageErrorEntriesDecoded0 = [BatchPutMessageErrorEntry]()
            for structure0 in batchPutMessageErrorEntriesContainer {
                if let structure0 = structure0 {
                    batchPutMessageErrorEntriesDecoded0?.append(structure0)
                }
            }
        }
        batchPutMessageErrorEntries = batchPutMessageErrorEntriesDecoded0
    }
}

extension CancelPipelineReprocessingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelPipelineReprocessingInput(pipelineName: \(String(describing: pipelineName)), reprocessingId: \(String(describing: reprocessingId)))"}
}

extension CancelPipelineReprocessingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CancelPipelineReprocessingInputHeadersMiddleware: Middleware {
    public let id: String = "CancelPipelineReprocessingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelPipelineReprocessingInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelPipelineReprocessingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelPipelineReprocessingInput>
    public typealias MOutput = OperationOutput<CancelPipelineReprocessingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelPipelineReprocessingOutputError>
}

public struct CancelPipelineReprocessingInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelPipelineReprocessingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelPipelineReprocessingInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelPipelineReprocessingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelPipelineReprocessingInput>
    public typealias MOutput = OperationOutput<CancelPipelineReprocessingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelPipelineReprocessingOutputError>
}

public struct CancelPipelineReprocessingInput: Equatable {
    /// <p>The name of pipeline for which data reprocessing is canceled.</p>
    public let pipelineName: String?
    /// <p>The ID of the reprocessing task (returned by
    ///       <code>StartPipelineReprocessing</code>).</p>
    public let reprocessingId: String?

    public init (
        pipelineName: String? = nil,
        reprocessingId: String? = nil
    )
    {
        self.pipelineName = pipelineName
        self.reprocessingId = reprocessingId
    }
}

struct CancelPipelineReprocessingInputBody: Equatable {
}

extension CancelPipelineReprocessingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CancelPipelineReprocessingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelPipelineReprocessingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelPipelineReprocessingOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelPipelineReprocessingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelPipelineReprocessingOutputResponse()"}
}

extension CancelPipelineReprocessingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CancelPipelineReprocessingOutputResponse: Equatable {

    public init() {}
}

struct CancelPipelineReprocessingOutputResponseBody: Equatable {
}

extension CancelPipelineReprocessingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Channel: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case creationTime
        case lastMessageArrivalTime
        case lastUpdateTime
        case name
        case retentionPeriod
        case status
        case storage
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastMessageArrivalTime = lastMessageArrivalTime {
            try encodeContainer.encode(lastMessageArrivalTime.timeIntervalSince1970, forKey: .lastMessageArrivalTime)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let retentionPeriod = retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let storage = storage {
            try encodeContainer.encode(storage, forKey: .storage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let storageDecoded = try containerValues.decodeIfPresent(ChannelStorage.self, forKey: .storage)
        storage = storageDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChannelStatus.self, forKey: .status)
        status = statusDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let lastMessageArrivalTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastMessageArrivalTime)
        lastMessageArrivalTime = lastMessageArrivalTimeDecoded
    }
}

extension Channel: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Channel(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), lastMessageArrivalTime: \(String(describing: lastMessageArrivalTime)), lastUpdateTime: \(String(describing: lastUpdateTime)), name: \(String(describing: name)), retentionPeriod: \(String(describing: retentionPeriod)), status: \(String(describing: status)), storage: \(String(describing: storage)))"}
}

/// <p>A collection of data from an MQTT topic. Channels archive the raw, unprocessed messages
///       before publishing the data to a pipeline.</p>
public struct Channel: Equatable {
    /// <p>The ARN of the channel.</p>
    public let arn: String?
    /// <p>When the channel was created.</p>
    public let creationTime: Date?
    /// <p>The last time when a new message arrived in the channel.</p>
    ///          <p>AWS IoT Analytics updates this value at most once per minute for one channel.
    ///   Hence, the <code>lastMessageArrivalTime</code> value is an approximation.</p>
    ///          <p>This feature only applies to messages that arrived in the data store after October 23, 2020. </p>
    public let lastMessageArrivalTime: Date?
    /// <p>When the channel was last updated.</p>
    public let lastUpdateTime: Date?
    /// <p>The name of the channel.</p>
    public let name: String?
    /// <p>How long, in days, message data is kept for the channel.</p>
    public let retentionPeriod: RetentionPeriod?
    /// <p>The status of the channel.</p>
    public let status: ChannelStatus?
    /// <p>Where channel data is stored. You can choose one of <code>serviceManagedS3</code> or
    ///         <code>customerManagedS3</code> storage. If not specified, the default is
    ///         <code>serviceManagedS3</code>. You cannot change this storage option after the channel is
    ///       created.</p>
    public let storage: ChannelStorage?

    public init (
        arn: String? = nil,
        creationTime: Date? = nil,
        lastMessageArrivalTime: Date? = nil,
        lastUpdateTime: Date? = nil,
        name: String? = nil,
        retentionPeriod: RetentionPeriod? = nil,
        status: ChannelStatus? = nil,
        storage: ChannelStorage? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.lastMessageArrivalTime = lastMessageArrivalTime
        self.lastUpdateTime = lastUpdateTime
        self.name = name
        self.retentionPeriod = retentionPeriod
        self.status = status
        self.storage = storage
    }
}

extension ChannelActivity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelName
        case name
        case next
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelName = channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            try encodeContainer.encode(next, forKey: .next)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let nextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .next)
        next = nextDecoded
    }
}

extension ChannelActivity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChannelActivity(channelName: \(String(describing: channelName)), name: \(String(describing: name)), next: \(String(describing: next)))"}
}

/// <p>The activity that determines the source of the messages to be processed.</p>
public struct ChannelActivity: Equatable {
    /// <p>The name of the channel from which the messages are processed.</p>
    public let channelName: String?
    /// <p>The name of the channel activity.</p>
    public let name: String?
    /// <p>The next activity in the pipeline.</p>
    public let next: String?

    public init (
        channelName: String? = nil,
        name: String? = nil,
        next: String? = nil
    )
    {
        self.channelName = channelName
        self.name = name
        self.next = next
    }
}

extension ChannelMessages: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Paths
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Paths = s3Paths {
            var s3PathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Paths)
            for s3pathchannelmessages0 in s3Paths {
                try s3PathsContainer.encode(s3pathchannelmessages0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3PathsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .s3Paths)
        var s3PathsDecoded0:[String]? = nil
        if let s3PathsContainer = s3PathsContainer {
            s3PathsDecoded0 = [String]()
            for string0 in s3PathsContainer {
                if let string0 = string0 {
                    s3PathsDecoded0?.append(string0)
                }
            }
        }
        s3Paths = s3PathsDecoded0
    }
}

extension ChannelMessages: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChannelMessages(s3Paths: \(String(describing: s3Paths)))"}
}

/// <p>Specifies one or more sets of channel messages.</p>
public struct ChannelMessages: Equatable {
    /// <p>Specifies one or more keys that identify the Amazon Simple Storage Service (Amazon S3) objects that save your
    ///       channel messages.</p>
    public let s3Paths: [String]?

    public init (
        s3Paths: [String]? = nil
    )
    {
        self.s3Paths = s3Paths
    }
}

extension ChannelStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case size
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let size = size {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeDecoded = try containerValues.decodeIfPresent(EstimatedResourceSize.self, forKey: .size)
        size = sizeDecoded
    }
}

extension ChannelStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChannelStatistics(size: \(String(describing: size)))"}
}

/// <p>Statistics information about the channel.</p>
public struct ChannelStatistics: Equatable {
    /// <p>The estimated size of the channel.</p>
    public let size: EstimatedResourceSize?

    public init (
        size: EstimatedResourceSize? = nil
    )
    {
        self.size = size
    }
}

public enum ChannelStatus {
    case active
    case creating
    case deleting
    case sdkUnknown(String)
}

extension ChannelStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChannelStatus] {
        return [
            .active,
            .creating,
            .deleting,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChannelStatus(rawValue: rawValue) ?? ChannelStatus.sdkUnknown(rawValue)
    }
}

extension ChannelStorage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customerManagedS3
        case serviceManagedS3
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerManagedS3 = customerManagedS3 {
            try encodeContainer.encode(customerManagedS3, forKey: .customerManagedS3)
        }
        if let serviceManagedS3 = serviceManagedS3 {
            try encodeContainer.encode(serviceManagedS3, forKey: .serviceManagedS3)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceManagedS3Decoded = try containerValues.decodeIfPresent(ServiceManagedChannelS3Storage.self, forKey: .serviceManagedS3)
        serviceManagedS3 = serviceManagedS3Decoded
        let customerManagedS3Decoded = try containerValues.decodeIfPresent(CustomerManagedChannelS3Storage.self, forKey: .customerManagedS3)
        customerManagedS3 = customerManagedS3Decoded
    }
}

extension ChannelStorage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChannelStorage(customerManagedS3: \(String(describing: customerManagedS3)), serviceManagedS3: \(String(describing: serviceManagedS3)))"}
}

/// <p>Where channel data is stored. You may choose one of <code>serviceManagedS3</code> or
///         <code>customerManagedS3</code> storage. If not specified, the default is
///         <code>serviceManagedS3</code>. This cannot be changed after creation of the channel.</p>
public struct ChannelStorage: Equatable {
    /// <p>Use this to store channel data in an S3 bucket that you manage. If customer managed
    ///       storage is selected, the <code>retentionPeriod</code> parameter is ignored. You cannot change
    ///       the choice of service-managed or customer-managed S3 storage after the channel is
    ///       created.</p>
    public let customerManagedS3: CustomerManagedChannelS3Storage?
    /// <p>Use this to store channel data in an S3 bucket managed by AWS IoT Analytics. You cannot
    ///       change the choice of service-managed or customer-managed S3 storage after the channel is
    ///       created.</p>
    public let serviceManagedS3: ServiceManagedChannelS3Storage?

    public init (
        customerManagedS3: CustomerManagedChannelS3Storage? = nil,
        serviceManagedS3: ServiceManagedChannelS3Storage? = nil
    )
    {
        self.customerManagedS3 = customerManagedS3
        self.serviceManagedS3 = serviceManagedS3
    }
}

extension ChannelStorageSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customerManagedS3
        case serviceManagedS3
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerManagedS3 = customerManagedS3 {
            try encodeContainer.encode(customerManagedS3, forKey: .customerManagedS3)
        }
        if let serviceManagedS3 = serviceManagedS3 {
            try encodeContainer.encode(serviceManagedS3, forKey: .serviceManagedS3)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceManagedS3Decoded = try containerValues.decodeIfPresent(ServiceManagedChannelS3StorageSummary.self, forKey: .serviceManagedS3)
        serviceManagedS3 = serviceManagedS3Decoded
        let customerManagedS3Decoded = try containerValues.decodeIfPresent(CustomerManagedChannelS3StorageSummary.self, forKey: .customerManagedS3)
        customerManagedS3 = customerManagedS3Decoded
    }
}

extension ChannelStorageSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChannelStorageSummary(customerManagedS3: \(String(describing: customerManagedS3)), serviceManagedS3: \(String(describing: serviceManagedS3)))"}
}

/// <p>Where channel data is stored.</p>
public struct ChannelStorageSummary: Equatable {
    /// <p>Used to store channel data in an S3 bucket that you manage.</p>
    public let customerManagedS3: CustomerManagedChannelS3StorageSummary?
    /// <p>Used to store channel data in an S3 bucket managed by AWS IoT Analytics.</p>
    public let serviceManagedS3: ServiceManagedChannelS3StorageSummary?

    public init (
        customerManagedS3: CustomerManagedChannelS3StorageSummary? = nil,
        serviceManagedS3: ServiceManagedChannelS3StorageSummary? = nil
    )
    {
        self.customerManagedS3 = customerManagedS3
        self.serviceManagedS3 = serviceManagedS3
    }
}

extension ChannelSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelName
        case channelStorage
        case creationTime
        case lastMessageArrivalTime
        case lastUpdateTime
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelName = channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let channelStorage = channelStorage {
            try encodeContainer.encode(channelStorage, forKey: .channelStorage)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastMessageArrivalTime = lastMessageArrivalTime {
            try encodeContainer.encode(lastMessageArrivalTime.timeIntervalSince1970, forKey: .lastMessageArrivalTime)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelStorageDecoded = try containerValues.decodeIfPresent(ChannelStorageSummary.self, forKey: .channelStorage)
        channelStorage = channelStorageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChannelStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let lastMessageArrivalTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastMessageArrivalTime)
        lastMessageArrivalTime = lastMessageArrivalTimeDecoded
    }
}

extension ChannelSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChannelSummary(channelName: \(String(describing: channelName)), channelStorage: \(String(describing: channelStorage)), creationTime: \(String(describing: creationTime)), lastMessageArrivalTime: \(String(describing: lastMessageArrivalTime)), lastUpdateTime: \(String(describing: lastUpdateTime)), status: \(String(describing: status)))"}
}

/// <p>A summary of information about a channel.</p>
public struct ChannelSummary: Equatable {
    /// <p>The name of the channel.</p>
    public let channelName: String?
    /// <p>Where channel data is stored.</p>
    public let channelStorage: ChannelStorageSummary?
    /// <p>When the channel was created.</p>
    public let creationTime: Date?
    /// <p>The last time when a new message arrived in the channel.</p>
    ///          <p>AWS IoT Analytics updates this value at most once per minute for one channel.
    ///   Hence, the <code>lastMessageArrivalTime</code> value is an approximation.</p>
    ///          <p>This feature only applies to messages that arrived in the data store after October 23, 2020. </p>
    public let lastMessageArrivalTime: Date?
    /// <p>The last time the channel was updated.</p>
    public let lastUpdateTime: Date?
    /// <p>The status of the channel.</p>
    public let status: ChannelStatus?

    public init (
        channelName: String? = nil,
        channelStorage: ChannelStorageSummary? = nil,
        creationTime: Date? = nil,
        lastMessageArrivalTime: Date? = nil,
        lastUpdateTime: Date? = nil,
        status: ChannelStatus? = nil
    )
    {
        self.channelName = channelName
        self.channelStorage = channelStorage
        self.creationTime = creationTime
        self.lastMessageArrivalTime = lastMessageArrivalTime
        self.lastUpdateTime = lastUpdateTime
        self.status = status
    }
}

extension Column: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension Column: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Column(name: \(String(describing: name)), type: \(String(describing: type)))"}
}

/// <p>Contains information about a column that stores your data.</p>
public struct Column: Equatable {
    /// <p>The name of the column.</p>
    public let name: String?
    /// <p>The type of data. For more information about the supported data types, see <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-common.html">Common data types</a>
    ///       in the <i>AWS Glue Developer Guide</i>.</p>
    public let type: String?

    public init (
        name: String? = nil,
        type: String? = nil
    )
    {
        self.name = name
        self.type = type
    }
}

public enum ComputeType {
    case acu1
    case acu2
    case sdkUnknown(String)
}

extension ComputeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ComputeType] {
        return [
            .acu1,
            .acu2,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .acu1: return "ACU_1"
        case .acu2: return "ACU_2"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ComputeType(rawValue: rawValue) ?? ComputeType.sdkUnknown(rawValue)
    }
}

extension ContainerDatasetAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case executionRoleArn
        case image
        case resourceConfiguration
        case variables
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let image = image {
            try encodeContainer.encode(image, forKey: .image)
        }
        if let resourceConfiguration = resourceConfiguration {
            try encodeContainer.encode(resourceConfiguration, forKey: .resourceConfiguration)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variables)
            for variables0 in variables {
                try variablesContainer.encode(variables0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .image)
        image = imageDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let resourceConfigurationDecoded = try containerValues.decodeIfPresent(ResourceConfiguration.self, forKey: .resourceConfiguration)
        resourceConfiguration = resourceConfigurationDecoded
        let variablesContainer = try containerValues.decodeIfPresent([Variable?].self, forKey: .variables)
        var variablesDecoded0:[Variable]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Variable]()
            for structure0 in variablesContainer {
                if let structure0 = structure0 {
                    variablesDecoded0?.append(structure0)
                }
            }
        }
        variables = variablesDecoded0
    }
}

extension ContainerDatasetAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContainerDatasetAction(executionRoleArn: \(String(describing: executionRoleArn)), image: \(String(describing: image)), resourceConfiguration: \(String(describing: resourceConfiguration)), variables: \(String(describing: variables)))"}
}

/// <p>Information required to run the <code>containerAction</code> to produce dataset
///       contents.</p>
public struct ContainerDatasetAction: Equatable {
    /// <p>The ARN of the role that gives permission to the system to access required resources to
    ///       run the <code>containerAction</code>. This includes, at minimum, permission to retrieve the
    ///       dataset contents that are the input to the containerized application.</p>
    public let executionRoleArn: String?
    /// <p>The ARN of the Docker container stored in your account. The Docker container contains an
    ///       application and required support libraries and is used to generate dataset contents.</p>
    public let image: String?
    /// <p>Configuration of the resource that executes the <code>containerAction</code>.</p>
    public let resourceConfiguration: ResourceConfiguration?
    /// <p>The values of variables used in the context of the execution of the containerized
    ///       application (basically, parameters passed to the application). Each variable must have a name
    ///       and a value given by one of <code>stringValue</code>, <code>datasetContentVersionValue</code>,
    ///       or <code>outputFileUriValue</code>.</p>
    public let variables: [Variable]?

    public init (
        executionRoleArn: String? = nil,
        image: String? = nil,
        resourceConfiguration: ResourceConfiguration? = nil,
        variables: [Variable]? = nil
    )
    {
        self.executionRoleArn = executionRoleArn
        self.image = image
        self.resourceConfiguration = resourceConfiguration
        self.variables = variables
    }
}

public struct CreateChannelInputBodyMiddleware: Middleware {
    public let id: String = "CreateChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateChannelInput>
    public typealias MOutput = OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateChannelOutputError>
}

extension CreateChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateChannelInput(channelName: \(String(describing: channelName)), channelStorage: \(String(describing: channelStorage)), retentionPeriod: \(String(describing: retentionPeriod)), tags: \(String(describing: tags)))"}
}

extension CreateChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelName
        case channelStorage
        case retentionPeriod
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelName = channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let channelStorage = channelStorage {
            try encodeContainer.encode(channelStorage, forKey: .channelStorage)
        }
        if let retentionPeriod = retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateChannelInputHeadersMiddleware: Middleware {
    public let id: String = "CreateChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateChannelInput>
    public typealias MOutput = OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateChannelOutputError>
}

public struct CreateChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateChannelInput>
    public typealias MOutput = OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateChannelOutputError>
}

public struct CreateChannelInput: Equatable {
    /// <p>The name of the channel.</p>
    public let channelName: String?
    /// <p>Where channel data is stored. You can choose one of <code>serviceManagedS3</code> or
    ///         <code>customerManagedS3</code> storage. If not specified, the default is
    ///         <code>serviceManagedS3</code>. You cannot change this storage option after the channel is
    ///       created.</p>
    public let channelStorage: ChannelStorage?
    /// <p>How long, in days, message data is kept for the channel. When
    ///         <code>customerManagedS3</code> storage is selected, this parameter is ignored.</p>
    public let retentionPeriod: RetentionPeriod?
    /// <p>Metadata which can be used to manage the channel.</p>
    public let tags: [Tag]?

    public init (
        channelName: String? = nil,
        channelStorage: ChannelStorage? = nil,
        retentionPeriod: RetentionPeriod? = nil,
        tags: [Tag]? = nil
    )
    {
        self.channelName = channelName
        self.channelStorage = channelStorage
        self.retentionPeriod = retentionPeriod
        self.tags = tags
    }
}

struct CreateChannelInputBody: Equatable {
    public let channelName: String?
    public let channelStorage: ChannelStorage?
    public let retentionPeriod: RetentionPeriod?
    public let tags: [Tag]?
}

extension CreateChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channelName
        case channelStorage
        case retentionPeriod
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelStorageDecoded = try containerValues.decodeIfPresent(ChannelStorage.self, forKey: .channelStorage)
        channelStorage = channelStorageDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChannelOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateChannelOutputResponse(channelArn: \(String(describing: channelArn)), channelName: \(String(describing: channelName)), retentionPeriod: \(String(describing: retentionPeriod)))"}
}

extension CreateChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateChannelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.channelArn = output.channelArn
            self.channelName = output.channelName
            self.retentionPeriod = output.retentionPeriod
        } else {
            self.channelArn = nil
            self.channelName = nil
            self.retentionPeriod = nil
        }
    }
}

public struct CreateChannelOutputResponse: Equatable {
    /// <p>The ARN of the channel.</p>
    public let channelArn: String?
    /// <p>The name of the channel.</p>
    public let channelName: String?
    /// <p>How long, in days, message data is kept for the channel.</p>
    public let retentionPeriod: RetentionPeriod?

    public init (
        channelArn: String? = nil,
        channelName: String? = nil,
        retentionPeriod: RetentionPeriod? = nil
    )
    {
        self.channelArn = channelArn
        self.channelName = channelName
        self.retentionPeriod = retentionPeriod
    }
}

struct CreateChannelOutputResponseBody: Equatable {
    public let channelName: String?
    public let channelArn: String?
    public let retentionPeriod: RetentionPeriod?
}

extension CreateChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channelArn
        case channelName
        case retentionPeriod
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
    }
}

public struct CreateDatasetContentInputBodyMiddleware: Middleware {
    public let id: String = "CreateDatasetContentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetContentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetContentInput>
    public typealias MOutput = OperationOutput<CreateDatasetContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetContentOutputError>
}

extension CreateDatasetContentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatasetContentInput(datasetName: \(String(describing: datasetName)), versionId: \(String(describing: versionId)))"}
}

extension CreateDatasetContentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case versionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let versionId = versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }
}

public struct CreateDatasetContentInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDatasetContentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetContentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetContentInput>
    public typealias MOutput = OperationOutput<CreateDatasetContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetContentOutputError>
}

public struct CreateDatasetContentInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDatasetContentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetContentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetContentInput>
    public typealias MOutput = OperationOutput<CreateDatasetContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetContentOutputError>
}

public struct CreateDatasetContentInput: Equatable {
    /// <p>The name of the dataset.</p>
    public let datasetName: String?
    /// <p>The version ID of the dataset content. To specify <code>versionId</code> for a dataset
    ///       content, the dataset must use a <a href="https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_DeltaTime.html">DeltaTimer</a> filter.</p>
    public let versionId: String?

    public init (
        datasetName: String? = nil,
        versionId: String? = nil
    )
    {
        self.datasetName = datasetName
        self.versionId = versionId
    }
}

struct CreateDatasetContentInputBody: Equatable {
    public let versionId: String?
}

extension CreateDatasetContentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case versionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension CreateDatasetContentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetContentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetContentOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetContentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatasetContentOutputResponse(versionId: \(String(describing: versionId)))"}
}

extension CreateDatasetContentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDatasetContentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.versionId = output.versionId
        } else {
            self.versionId = nil
        }
    }
}

public struct CreateDatasetContentOutputResponse: Equatable {
    /// <p>The version ID of the dataset contents that are being created.</p>
    public let versionId: String?

    public init (
        versionId: String? = nil
    )
    {
        self.versionId = versionId
    }
}

struct CreateDatasetContentOutputResponseBody: Equatable {
    public let versionId: String?
}

extension CreateDatasetContentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case versionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

public struct CreateDatasetInputBodyMiddleware: Middleware {
    public let id: String = "CreateDatasetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetOutputError>
}

extension CreateDatasetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatasetInput(actions: \(String(describing: actions)), contentDeliveryRules: \(String(describing: contentDeliveryRules)), datasetName: \(String(describing: datasetName)), lateDataRules: \(String(describing: lateDataRules)), retentionPeriod: \(String(describing: retentionPeriod)), tags: \(String(describing: tags)), triggers: \(String(describing: triggers)), versioningConfiguration: \(String(describing: versioningConfiguration)))"}
}

extension CreateDatasetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions
        case contentDeliveryRules
        case datasetName
        case lateDataRules
        case retentionPeriod
        case tags
        case triggers
        case versioningConfiguration
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for datasetactions0 in actions {
                try actionsContainer.encode(datasetactions0)
            }
        }
        if let contentDeliveryRules = contentDeliveryRules {
            var contentDeliveryRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contentDeliveryRules)
            for datasetcontentdeliveryrules0 in contentDeliveryRules {
                try contentDeliveryRulesContainer.encode(datasetcontentdeliveryrules0)
            }
        }
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let lateDataRules = lateDataRules {
            var lateDataRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lateDataRules)
            for latedatarules0 in lateDataRules {
                try lateDataRulesContainer.encode(latedatarules0)
            }
        }
        if let retentionPeriod = retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let triggers = triggers {
            var triggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .triggers)
            for datasettriggers0 in triggers {
                try triggersContainer.encode(datasettriggers0)
            }
        }
        if let versioningConfiguration = versioningConfiguration {
            try encodeContainer.encode(versioningConfiguration, forKey: .versioningConfiguration)
        }
    }
}

public struct CreateDatasetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetOutputError>
}

public struct CreateDatasetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetOutputError>
}

public struct CreateDatasetInput: Equatable {
    /// <p>A list of actions that create the data set contents.</p>
    public let actions: [DatasetAction]?
    /// <p>When dataset contents are created, they are delivered to destinations specified
    ///       here.</p>
    public let contentDeliveryRules: [DatasetContentDeliveryRule]?
    /// <p>The name of the data set.</p>
    public let datasetName: String?
    /// <p>A list of data rules that send notifications to Amazon CloudWatch, when data arrives late. To
    ///   specify <code>lateDataRules</code>, the dataset must use a <a href="https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_DeltaTime.html">DeltaTimer</a>
    ///   filter.</p>
    public let lateDataRules: [LateDataRule]?
    /// <p>Optional. How long, in days, versions of dataset contents are kept for the dataset. If not
    ///       specified or set to <code>null</code>, versions of dataset contents are retained for at most
    ///       90 days. The number of versions of dataset contents retained is determined by the
    ///         <code>versioningConfiguration</code> parameter. For more information, see <a href="https://docs.aws.amazon.com/iotanalytics/latest/userguide/getting-started.html#aws-iot-analytics-dataset-versions">Keeping Multiple Versions of AWS IoT Analytics Data Sets</a> in the <i>AWS IoT
    ///         Analytics User Guide</i>.</p>
    public let retentionPeriod: RetentionPeriod?
    /// <p>Metadata which can be used to manage the data set.</p>
    public let tags: [Tag]?
    /// <p>A list of triggers. A trigger causes data set contents to be populated at a specified time
    ///       interval or when another data set's contents are created. The list of triggers can be empty or
    ///       contain up to five <code>DataSetTrigger</code> objects.</p>
    public let triggers: [DatasetTrigger]?
    /// <p>Optional. How many versions of dataset contents are kept. If not specified or set to null,
    ///       only the latest version plus the latest succeeded version (if they are different) are kept for
    ///       the time period specified by the <code>retentionPeriod</code> parameter. For more information,
    ///       see <a href="https://docs.aws.amazon.com/iotanalytics/latest/userguide/getting-started.html#aws-iot-analytics-dataset-versions">Keeping Multiple Versions of AWS IoT Analytics Data Sets</a> in the <i>AWS IoT
    ///         Analytics User Guide</i>.</p>
    public let versioningConfiguration: VersioningConfiguration?

    public init (
        actions: [DatasetAction]? = nil,
        contentDeliveryRules: [DatasetContentDeliveryRule]? = nil,
        datasetName: String? = nil,
        lateDataRules: [LateDataRule]? = nil,
        retentionPeriod: RetentionPeriod? = nil,
        tags: [Tag]? = nil,
        triggers: [DatasetTrigger]? = nil,
        versioningConfiguration: VersioningConfiguration? = nil
    )
    {
        self.actions = actions
        self.contentDeliveryRules = contentDeliveryRules
        self.datasetName = datasetName
        self.lateDataRules = lateDataRules
        self.retentionPeriod = retentionPeriod
        self.tags = tags
        self.triggers = triggers
        self.versioningConfiguration = versioningConfiguration
    }
}

struct CreateDatasetInputBody: Equatable {
    public let datasetName: String?
    public let actions: [DatasetAction]?
    public let triggers: [DatasetTrigger]?
    public let contentDeliveryRules: [DatasetContentDeliveryRule]?
    public let retentionPeriod: RetentionPeriod?
    public let versioningConfiguration: VersioningConfiguration?
    public let tags: [Tag]?
    public let lateDataRules: [LateDataRule]?
}

extension CreateDatasetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actions
        case contentDeliveryRules
        case datasetName
        case lateDataRules
        case retentionPeriod
        case tags
        case triggers
        case versioningConfiguration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let actionsContainer = try containerValues.decodeIfPresent([DatasetAction?].self, forKey: .actions)
        var actionsDecoded0:[DatasetAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [DatasetAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let triggersContainer = try containerValues.decodeIfPresent([DatasetTrigger?].self, forKey: .triggers)
        var triggersDecoded0:[DatasetTrigger]? = nil
        if let triggersContainer = triggersContainer {
            triggersDecoded0 = [DatasetTrigger]()
            for structure0 in triggersContainer {
                if let structure0 = structure0 {
                    triggersDecoded0?.append(structure0)
                }
            }
        }
        triggers = triggersDecoded0
        let contentDeliveryRulesContainer = try containerValues.decodeIfPresent([DatasetContentDeliveryRule?].self, forKey: .contentDeliveryRules)
        var contentDeliveryRulesDecoded0:[DatasetContentDeliveryRule]? = nil
        if let contentDeliveryRulesContainer = contentDeliveryRulesContainer {
            contentDeliveryRulesDecoded0 = [DatasetContentDeliveryRule]()
            for structure0 in contentDeliveryRulesContainer {
                if let structure0 = structure0 {
                    contentDeliveryRulesDecoded0?.append(structure0)
                }
            }
        }
        contentDeliveryRules = contentDeliveryRulesDecoded0
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let versioningConfigurationDecoded = try containerValues.decodeIfPresent(VersioningConfiguration.self, forKey: .versioningConfiguration)
        versioningConfiguration = versioningConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let lateDataRulesContainer = try containerValues.decodeIfPresent([LateDataRule?].self, forKey: .lateDataRules)
        var lateDataRulesDecoded0:[LateDataRule]? = nil
        if let lateDataRulesContainer = lateDataRulesContainer {
            lateDataRulesDecoded0 = [LateDataRule]()
            for structure0 in lateDataRulesContainer {
                if let structure0 = structure0 {
                    lateDataRulesDecoded0?.append(structure0)
                }
            }
        }
        lateDataRules = lateDataRulesDecoded0
    }
}

extension CreateDatasetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatasetOutputResponse(datasetArn: \(String(describing: datasetArn)), datasetName: \(String(describing: datasetName)), retentionPeriod: \(String(describing: retentionPeriod)))"}
}

extension CreateDatasetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDatasetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasetArn = output.datasetArn
            self.datasetName = output.datasetName
            self.retentionPeriod = output.retentionPeriod
        } else {
            self.datasetArn = nil
            self.datasetName = nil
            self.retentionPeriod = nil
        }
    }
}

public struct CreateDatasetOutputResponse: Equatable {
    /// <p>The ARN of the dataset.</p>
    public let datasetArn: String?
    /// <p>The name of the dataset.</p>
    public let datasetName: String?
    /// <p>How long, in days, dataset contents are kept for the dataset.</p>
    public let retentionPeriod: RetentionPeriod?

    public init (
        datasetArn: String? = nil,
        datasetName: String? = nil,
        retentionPeriod: RetentionPeriod? = nil
    )
    {
        self.datasetArn = datasetArn
        self.datasetName = datasetName
        self.retentionPeriod = retentionPeriod
    }
}

struct CreateDatasetOutputResponseBody: Equatable {
    public let datasetName: String?
    public let datasetArn: String?
    public let retentionPeriod: RetentionPeriod?
}

extension CreateDatasetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetArn
        case datasetName
        case retentionPeriod
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
    }
}

public struct CreateDatastoreInputBodyMiddleware: Middleware {
    public let id: String = "CreateDatastoreInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatastoreInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatastoreInput>
    public typealias MOutput = OperationOutput<CreateDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatastoreOutputError>
}

extension CreateDatastoreInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatastoreInput(datastoreName: \(String(describing: datastoreName)), datastoreStorage: \(String(describing: datastoreStorage)), fileFormatConfiguration: \(String(describing: fileFormatConfiguration)), retentionPeriod: \(String(describing: retentionPeriod)), tags: \(String(describing: tags)))"}
}

extension CreateDatastoreInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datastoreName
        case datastoreStorage
        case fileFormatConfiguration
        case retentionPeriod
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreName = datastoreName {
            try encodeContainer.encode(datastoreName, forKey: .datastoreName)
        }
        if let datastoreStorage = datastoreStorage {
            try encodeContainer.encode(datastoreStorage, forKey: .datastoreStorage)
        }
        if let fileFormatConfiguration = fileFormatConfiguration {
            try encodeContainer.encode(fileFormatConfiguration, forKey: .fileFormatConfiguration)
        }
        if let retentionPeriod = retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateDatastoreInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDatastoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatastoreInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatastoreInput>
    public typealias MOutput = OperationOutput<CreateDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatastoreOutputError>
}

public struct CreateDatastoreInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDatastoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatastoreInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatastoreInput>
    public typealias MOutput = OperationOutput<CreateDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatastoreOutputError>
}

public struct CreateDatastoreInput: Equatable {
    /// <p>The name of the data store.</p>
    public let datastoreName: String?
    /// <p>Where data store data is stored. You can choose one of <code>serviceManagedS3</code> or
    ///         <code>customerManagedS3</code> storage. If not specified, the default is
    ///         <code>serviceManagedS3</code>. You cannot change this storage option after the data store is
    ///       created.</p>
    public let datastoreStorage: DatastoreStorage?
    /// <p>Contains the configuration information of file formats. AWS IoT Analytics data stores support JSON
    ///       and <a href="https://parquet.apache.org/">Parquet</a>.</p>
    ///          <p>The default file format is JSON. You can specify only one format.</p>
    ///          <p>You can't change the file format after you create the data store.</p>
    public let fileFormatConfiguration: FileFormatConfiguration?
    /// <p>How long, in days, message data is kept for the data store. When
    ///         <code>customerManagedS3</code> storage is selected, this parameter is ignored.</p>
    public let retentionPeriod: RetentionPeriod?
    /// <p>Metadata which can be used to manage the data store.</p>
    public let tags: [Tag]?

    public init (
        datastoreName: String? = nil,
        datastoreStorage: DatastoreStorage? = nil,
        fileFormatConfiguration: FileFormatConfiguration? = nil,
        retentionPeriod: RetentionPeriod? = nil,
        tags: [Tag]? = nil
    )
    {
        self.datastoreName = datastoreName
        self.datastoreStorage = datastoreStorage
        self.fileFormatConfiguration = fileFormatConfiguration
        self.retentionPeriod = retentionPeriod
        self.tags = tags
    }
}

struct CreateDatastoreInputBody: Equatable {
    public let datastoreName: String?
    public let datastoreStorage: DatastoreStorage?
    public let retentionPeriod: RetentionPeriod?
    public let tags: [Tag]?
    public let fileFormatConfiguration: FileFormatConfiguration?
}

extension CreateDatastoreInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datastoreName
        case datastoreStorage
        case fileFormatConfiguration
        case retentionPeriod
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
        let datastoreStorageDecoded = try containerValues.decodeIfPresent(DatastoreStorage.self, forKey: .datastoreStorage)
        datastoreStorage = datastoreStorageDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let fileFormatConfigurationDecoded = try containerValues.decodeIfPresent(FileFormatConfiguration.self, forKey: .fileFormatConfiguration)
        fileFormatConfiguration = fileFormatConfigurationDecoded
    }
}

extension CreateDatastoreOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatastoreOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatastoreOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatastoreOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatastoreOutputResponse(datastoreArn: \(String(describing: datastoreArn)), datastoreName: \(String(describing: datastoreName)), retentionPeriod: \(String(describing: retentionPeriod)))"}
}

extension CreateDatastoreOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDatastoreOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datastoreArn = output.datastoreArn
            self.datastoreName = output.datastoreName
            self.retentionPeriod = output.retentionPeriod
        } else {
            self.datastoreArn = nil
            self.datastoreName = nil
            self.retentionPeriod = nil
        }
    }
}

public struct CreateDatastoreOutputResponse: Equatable {
    /// <p>The ARN of the data store.</p>
    public let datastoreArn: String?
    /// <p>The name of the data store.</p>
    public let datastoreName: String?
    /// <p>How long, in days, message data is kept for the data store.</p>
    public let retentionPeriod: RetentionPeriod?

    public init (
        datastoreArn: String? = nil,
        datastoreName: String? = nil,
        retentionPeriod: RetentionPeriod? = nil
    )
    {
        self.datastoreArn = datastoreArn
        self.datastoreName = datastoreName
        self.retentionPeriod = retentionPeriod
    }
}

struct CreateDatastoreOutputResponseBody: Equatable {
    public let datastoreName: String?
    public let datastoreArn: String?
    public let retentionPeriod: RetentionPeriod?
}

extension CreateDatastoreOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datastoreArn
        case datastoreName
        case retentionPeriod
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
        let datastoreArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreArn)
        datastoreArn = datastoreArnDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
    }
}

public struct CreatePipelineInputBodyMiddleware: Middleware {
    public let id: String = "CreatePipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePipelineInput>
    public typealias MOutput = OperationOutput<CreatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePipelineOutputError>
}

extension CreatePipelineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePipelineInput(pipelineActivities: \(String(describing: pipelineActivities)), pipelineName: \(String(describing: pipelineName)), tags: \(String(describing: tags)))"}
}

extension CreatePipelineInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pipelineActivities
        case pipelineName
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineActivities = pipelineActivities {
            var pipelineActivitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pipelineActivities)
            for pipelineactivities0 in pipelineActivities {
                try pipelineActivitiesContainer.encode(pipelineactivities0)
            }
        }
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreatePipelineInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePipelineInput>
    public typealias MOutput = OperationOutput<CreatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePipelineOutputError>
}

public struct CreatePipelineInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePipelineInput>
    public typealias MOutput = OperationOutput<CreatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePipelineOutputError>
}

public struct CreatePipelineInput: Equatable {
    /// <p>A list of <code>PipelineActivity</code> objects. Activities perform transformations on
    ///       your messages, such as removing, renaming or adding message attributes; filtering messages
    ///       based on attribute values; invoking your Lambda functions on messages for advanced processing;
    ///       or performing mathematical transformations to normalize device data.</p>
    ///          <p>The list can be 2-25 <code>PipelineActivity</code> objects and must contain both a
    ///         <code>channel</code> and a <code>datastore</code> activity. Each entry in the list must
    ///       contain only one activity. For example:</p>
    ///          <p>
    ///             <code>pipelineActivities = [ { "channel": { ... } }, { "lambda": { ... } }, ...
    ///       ]</code>
    ///          </p>
    public let pipelineActivities: [PipelineActivity]?
    /// <p>The name of the pipeline.</p>
    public let pipelineName: String?
    /// <p>Metadata which can be used to manage the pipeline.</p>
    public let tags: [Tag]?

    public init (
        pipelineActivities: [PipelineActivity]? = nil,
        pipelineName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.pipelineActivities = pipelineActivities
        self.pipelineName = pipelineName
        self.tags = tags
    }
}

struct CreatePipelineInputBody: Equatable {
    public let pipelineName: String?
    public let pipelineActivities: [PipelineActivity]?
    public let tags: [Tag]?
}

extension CreatePipelineInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipelineActivities
        case pipelineName
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let pipelineActivitiesContainer = try containerValues.decodeIfPresent([PipelineActivity?].self, forKey: .pipelineActivities)
        var pipelineActivitiesDecoded0:[PipelineActivity]? = nil
        if let pipelineActivitiesContainer = pipelineActivitiesContainer {
            pipelineActivitiesDecoded0 = [PipelineActivity]()
            for structure0 in pipelineActivitiesContainer {
                if let structure0 = structure0 {
                    pipelineActivitiesDecoded0?.append(structure0)
                }
            }
        }
        pipelineActivities = pipelineActivitiesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePipelineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePipelineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePipelineOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePipelineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePipelineOutputResponse(pipelineArn: \(String(describing: pipelineArn)), pipelineName: \(String(describing: pipelineName)))"}
}

extension CreatePipelineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreatePipelineOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.pipelineArn = output.pipelineArn
            self.pipelineName = output.pipelineName
        } else {
            self.pipelineArn = nil
            self.pipelineName = nil
        }
    }
}

public struct CreatePipelineOutputResponse: Equatable {
    /// <p>The ARN of the pipeline.</p>
    public let pipelineArn: String?
    /// <p>The name of the pipeline.</p>
    public let pipelineName: String?

    public init (
        pipelineArn: String? = nil,
        pipelineName: String? = nil
    )
    {
        self.pipelineArn = pipelineArn
        self.pipelineName = pipelineName
    }
}

struct CreatePipelineOutputResponseBody: Equatable {
    public let pipelineName: String?
    public let pipelineArn: String?
}

extension CreatePipelineOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipelineArn
        case pipelineName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let pipelineArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineArn)
        pipelineArn = pipelineArnDecoded
    }
}

extension CustomerManagedChannelS3Storage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket
        case keyPrefix
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let keyPrefix = keyPrefix {
            try encodeContainer.encode(keyPrefix, forKey: .keyPrefix)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyPrefix)
        keyPrefix = keyPrefixDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension CustomerManagedChannelS3Storage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomerManagedChannelS3Storage(bucket: \(String(describing: bucket)), keyPrefix: \(String(describing: keyPrefix)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Use this to store channel data in an S3 bucket that you manage. If customer managed
///       storage is selected, the <code>retentionPeriod</code> parameter is ignored. You cannot change
///       the choice of service-managed or customer-managed S3 storage after the channel is
///       created.</p>
public struct CustomerManagedChannelS3Storage: Equatable {
    /// <p>The name of the S3 bucket in which channel data is stored.</p>
    public let bucket: String?
    /// <p>Optional. The prefix used to create the keys of the channel data objects. Each object in
    ///       an S3 bucket has a key that is its unique identifier in the bucket. Each object in a bucket
    ///       has exactly one key. The prefix must end with a forward slash (/).</p>
    public let keyPrefix: String?
    /// <p>The ARN of the role that grants AWS IoT Analytics permission to interact with your Amazon
    ///       S3 resources.</p>
    public let roleArn: String?

    public init (
        bucket: String? = nil,
        keyPrefix: String? = nil,
        roleArn: String? = nil
    )
    {
        self.bucket = bucket
        self.keyPrefix = keyPrefix
        self.roleArn = roleArn
    }
}

extension CustomerManagedChannelS3StorageSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket
        case keyPrefix
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let keyPrefix = keyPrefix {
            try encodeContainer.encode(keyPrefix, forKey: .keyPrefix)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyPrefix)
        keyPrefix = keyPrefixDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension CustomerManagedChannelS3StorageSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomerManagedChannelS3StorageSummary(bucket: \(String(describing: bucket)), keyPrefix: \(String(describing: keyPrefix)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Used to store channel data in an S3 bucket that you manage.</p>
public struct CustomerManagedChannelS3StorageSummary: Equatable {
    /// <p>The name of the S3 bucket in which channel data is stored.</p>
    public let bucket: String?
    /// <p>Optional. The prefix used to create the keys of the channel data objects. Each object in
    ///       an S3 bucket has a key that is its unique identifier within the bucket (each object in a
    ///       bucket has exactly one key). The prefix must end with a forward slash (/).</p>
    public let keyPrefix: String?
    /// <p>The ARN of the role that grants AWS IoT Analytics permission to interact with your Amazon
    ///       S3 resources.</p>
    public let roleArn: String?

    public init (
        bucket: String? = nil,
        keyPrefix: String? = nil,
        roleArn: String? = nil
    )
    {
        self.bucket = bucket
        self.keyPrefix = keyPrefix
        self.roleArn = roleArn
    }
}

extension CustomerManagedDatastoreS3Storage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket
        case keyPrefix
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let keyPrefix = keyPrefix {
            try encodeContainer.encode(keyPrefix, forKey: .keyPrefix)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyPrefix)
        keyPrefix = keyPrefixDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension CustomerManagedDatastoreS3Storage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomerManagedDatastoreS3Storage(bucket: \(String(describing: bucket)), keyPrefix: \(String(describing: keyPrefix)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Use this to store data store data in an S3 bucket that you manage. When customer-managed
///       storage is selected, the <code>retentionPeriod</code> parameter is ignored. You cannot change
///       the choice of service-managed or customer-managed S3 storage after the data store is
///       created.</p>
public struct CustomerManagedDatastoreS3Storage: Equatable {
    /// <p>The name of the S3 bucket in which data store data is stored.</p>
    public let bucket: String?
    /// <p>Optional. The prefix used to create the keys of the data store data objects. Each object
    ///       in an S3 bucket has a key that is its unique identifier in the bucket. Each object in a bucket
    ///       has exactly one key. The prefix must end with a forward slash (/).</p>
    public let keyPrefix: String?
    /// <p>The ARN of the role that grants AWS IoT Analytics permission to interact with your Amazon
    ///       S3 resources.</p>
    public let roleArn: String?

    public init (
        bucket: String? = nil,
        keyPrefix: String? = nil,
        roleArn: String? = nil
    )
    {
        self.bucket = bucket
        self.keyPrefix = keyPrefix
        self.roleArn = roleArn
    }
}

extension CustomerManagedDatastoreS3StorageSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket
        case keyPrefix
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let keyPrefix = keyPrefix {
            try encodeContainer.encode(keyPrefix, forKey: .keyPrefix)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyPrefix)
        keyPrefix = keyPrefixDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension CustomerManagedDatastoreS3StorageSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomerManagedDatastoreS3StorageSummary(bucket: \(String(describing: bucket)), keyPrefix: \(String(describing: keyPrefix)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Used to store data store data in an S3 bucket that you manage.</p>
public struct CustomerManagedDatastoreS3StorageSummary: Equatable {
    /// <p>The name of the S3 bucket in which data store data is stored.</p>
    public let bucket: String?
    /// <p>Optional. The prefix used to create the keys of the data store data objects. Each object
    ///       in an S3 bucket has a key that is its unique identifier in the bucket. Each object in a bucket
    ///       has exactly one key. The prefix must end with a forward slash (/).</p>
    public let keyPrefix: String?
    /// <p>The ARN of the role that grants AWS IoT Analytics permission to interact with your Amazon
    ///       S3 resources.</p>
    public let roleArn: String?

    public init (
        bucket: String? = nil,
        keyPrefix: String? = nil,
        roleArn: String? = nil
    )
    {
        self.bucket = bucket
        self.keyPrefix = keyPrefix
        self.roleArn = roleArn
    }
}

extension Dataset: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions
        case arn
        case contentDeliveryRules
        case creationTime
        case lastUpdateTime
        case lateDataRules
        case name
        case retentionPeriod
        case status
        case triggers
        case versioningConfiguration
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for datasetactions0 in actions {
                try actionsContainer.encode(datasetactions0)
            }
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let contentDeliveryRules = contentDeliveryRules {
            var contentDeliveryRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contentDeliveryRules)
            for datasetcontentdeliveryrules0 in contentDeliveryRules {
                try contentDeliveryRulesContainer.encode(datasetcontentdeliveryrules0)
            }
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let lateDataRules = lateDataRules {
            var lateDataRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lateDataRules)
            for latedatarules0 in lateDataRules {
                try lateDataRulesContainer.encode(latedatarules0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let retentionPeriod = retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let triggers = triggers {
            var triggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .triggers)
            for datasettriggers0 in triggers {
                try triggersContainer.encode(datasettriggers0)
            }
        }
        if let versioningConfiguration = versioningConfiguration {
            try encodeContainer.encode(versioningConfiguration, forKey: .versioningConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let actionsContainer = try containerValues.decodeIfPresent([DatasetAction?].self, forKey: .actions)
        var actionsDecoded0:[DatasetAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [DatasetAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let triggersContainer = try containerValues.decodeIfPresent([DatasetTrigger?].self, forKey: .triggers)
        var triggersDecoded0:[DatasetTrigger]? = nil
        if let triggersContainer = triggersContainer {
            triggersDecoded0 = [DatasetTrigger]()
            for structure0 in triggersContainer {
                if let structure0 = structure0 {
                    triggersDecoded0?.append(structure0)
                }
            }
        }
        triggers = triggersDecoded0
        let contentDeliveryRulesContainer = try containerValues.decodeIfPresent([DatasetContentDeliveryRule?].self, forKey: .contentDeliveryRules)
        var contentDeliveryRulesDecoded0:[DatasetContentDeliveryRule]? = nil
        if let contentDeliveryRulesContainer = contentDeliveryRulesContainer {
            contentDeliveryRulesDecoded0 = [DatasetContentDeliveryRule]()
            for structure0 in contentDeliveryRulesContainer {
                if let structure0 = structure0 {
                    contentDeliveryRulesDecoded0?.append(structure0)
                }
            }
        }
        contentDeliveryRules = contentDeliveryRulesDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(DatasetStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let versioningConfigurationDecoded = try containerValues.decodeIfPresent(VersioningConfiguration.self, forKey: .versioningConfiguration)
        versioningConfiguration = versioningConfigurationDecoded
        let lateDataRulesContainer = try containerValues.decodeIfPresent([LateDataRule?].self, forKey: .lateDataRules)
        var lateDataRulesDecoded0:[LateDataRule]? = nil
        if let lateDataRulesContainer = lateDataRulesContainer {
            lateDataRulesDecoded0 = [LateDataRule]()
            for structure0 in lateDataRulesContainer {
                if let structure0 = structure0 {
                    lateDataRulesDecoded0?.append(structure0)
                }
            }
        }
        lateDataRules = lateDataRulesDecoded0
    }
}

extension Dataset: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Dataset(actions: \(String(describing: actions)), arn: \(String(describing: arn)), contentDeliveryRules: \(String(describing: contentDeliveryRules)), creationTime: \(String(describing: creationTime)), lastUpdateTime: \(String(describing: lastUpdateTime)), lateDataRules: \(String(describing: lateDataRules)), name: \(String(describing: name)), retentionPeriod: \(String(describing: retentionPeriod)), status: \(String(describing: status)), triggers: \(String(describing: triggers)), versioningConfiguration: \(String(describing: versioningConfiguration)))"}
}

/// <p>Information about a data set.</p>
public struct Dataset: Equatable {
    /// <p>The <code>DatasetAction</code> objects that automatically create the data set
    ///       contents.</p>
    public let actions: [DatasetAction]?
    /// <p>The ARN of the data set.</p>
    public let arn: String?
    /// <p>When dataset contents are created they are delivered to destinations specified
    ///       here.</p>
    public let contentDeliveryRules: [DatasetContentDeliveryRule]?
    /// <p>When the data set was created.</p>
    public let creationTime: Date?
    /// <p>The last time the data set was updated.</p>
    public let lastUpdateTime: Date?
    /// <p>A list of data rules that send notifications to Amazon CloudWatch, when data arrives late. To
    ///   specify <code>lateDataRules</code>, the dataset must use a <a href="https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_DeltaTime.html">DeltaTimer</a>
    ///   filter.</p>
    public let lateDataRules: [LateDataRule]?
    /// <p>The name of the data set.</p>
    public let name: String?
    /// <p>Optional. How long, in days, message data is kept for the data set.</p>
    public let retentionPeriod: RetentionPeriod?
    /// <p>The status of the data set.</p>
    public let status: DatasetStatus?
    /// <p>The <code>DatasetTrigger</code> objects that specify when the data set is automatically
    ///       updated.</p>
    public let triggers: [DatasetTrigger]?
    /// <p>Optional. How many versions of dataset contents are kept. If not specified or set to null,
    ///       only the latest version plus the latest succeeded version (if they are different) are kept for
    ///       the time period specified by the <code>retentionPeriod</code> parameter. For more information,
    ///       see <a href="https://docs.aws.amazon.com/iotanalytics/latest/userguide/getting-started.html#aws-iot-analytics-dataset-versions">Keeping Multiple Versions of AWS IoT Analytics Data Sets</a> in the <i>AWS IoT
    ///         Analytics User Guide</i>.</p>
    public let versioningConfiguration: VersioningConfiguration?

    public init (
        actions: [DatasetAction]? = nil,
        arn: String? = nil,
        contentDeliveryRules: [DatasetContentDeliveryRule]? = nil,
        creationTime: Date? = nil,
        lastUpdateTime: Date? = nil,
        lateDataRules: [LateDataRule]? = nil,
        name: String? = nil,
        retentionPeriod: RetentionPeriod? = nil,
        status: DatasetStatus? = nil,
        triggers: [DatasetTrigger]? = nil,
        versioningConfiguration: VersioningConfiguration? = nil
    )
    {
        self.actions = actions
        self.arn = arn
        self.contentDeliveryRules = contentDeliveryRules
        self.creationTime = creationTime
        self.lastUpdateTime = lastUpdateTime
        self.lateDataRules = lateDataRules
        self.name = name
        self.retentionPeriod = retentionPeriod
        self.status = status
        self.triggers = triggers
        self.versioningConfiguration = versioningConfiguration
    }
}

extension DatasetAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionName
        case containerAction
        case queryAction
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionName = actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let containerAction = containerAction {
            try encodeContainer.encode(containerAction, forKey: .containerAction)
        }
        if let queryAction = queryAction {
            try encodeContainer.encode(queryAction, forKey: .queryAction)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let queryActionDecoded = try containerValues.decodeIfPresent(SqlQueryDatasetAction.self, forKey: .queryAction)
        queryAction = queryActionDecoded
        let containerActionDecoded = try containerValues.decodeIfPresent(ContainerDatasetAction.self, forKey: .containerAction)
        containerAction = containerActionDecoded
    }
}

extension DatasetAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetAction(actionName: \(String(describing: actionName)), containerAction: \(String(describing: containerAction)), queryAction: \(String(describing: queryAction)))"}
}

/// <p>A <code>DatasetAction</code> object that specifies how data set contents are automatically
///       created.</p>
public struct DatasetAction: Equatable {
    /// <p>The name of the data set action by which data set contents are automatically
    ///       created.</p>
    public let actionName: String?
    /// <p>Information that allows the system to run a containerized application to create the
    ///       dataset contents. The application must be in a Docker container along with any required
    ///       support libraries.</p>
    public let containerAction: ContainerDatasetAction?
    /// <p>An <code>SqlQueryDatasetAction</code> object that uses an SQL query to automatically
    ///       create data set contents.</p>
    public let queryAction: SqlQueryDatasetAction?

    public init (
        actionName: String? = nil,
        containerAction: ContainerDatasetAction? = nil,
        queryAction: SqlQueryDatasetAction? = nil
    )
    {
        self.actionName = actionName
        self.containerAction = containerAction
        self.queryAction = queryAction
    }
}

extension DatasetActionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionName
        case actionType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionName = actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let actionType = actionType {
            try encodeContainer.encode(actionType.rawValue, forKey: .actionType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let actionTypeDecoded = try containerValues.decodeIfPresent(DatasetActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
    }
}

extension DatasetActionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetActionSummary(actionName: \(String(describing: actionName)), actionType: \(String(describing: actionType)))"}
}

/// <p>Information about the action that automatically creates the dataset's contents.</p>
public struct DatasetActionSummary: Equatable {
    /// <p>The name of the action that automatically creates the dataset's contents.</p>
    public let actionName: String?
    /// <p>The type of action by which the dataset's contents are automatically created.</p>
    public let actionType: DatasetActionType?

    public init (
        actionName: String? = nil,
        actionType: DatasetActionType? = nil
    )
    {
        self.actionName = actionName
        self.actionType = actionType
    }
}

public enum DatasetActionType {
    case container
    case query
    case sdkUnknown(String)
}

extension DatasetActionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DatasetActionType] {
        return [
            .container,
            .query,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .container: return "CONTAINER"
        case .query: return "QUERY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DatasetActionType(rawValue: rawValue) ?? DatasetActionType.sdkUnknown(rawValue)
    }
}

extension DatasetContentDeliveryDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case iotEventsDestinationConfiguration
        case s3DestinationConfiguration
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iotEventsDestinationConfiguration = iotEventsDestinationConfiguration {
            try encodeContainer.encode(iotEventsDestinationConfiguration, forKey: .iotEventsDestinationConfiguration)
        }
        if let s3DestinationConfiguration = s3DestinationConfiguration {
            try encodeContainer.encode(s3DestinationConfiguration, forKey: .s3DestinationConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotEventsDestinationConfigurationDecoded = try containerValues.decodeIfPresent(IotEventsDestinationConfiguration.self, forKey: .iotEventsDestinationConfiguration)
        iotEventsDestinationConfiguration = iotEventsDestinationConfigurationDecoded
        let s3DestinationConfigurationDecoded = try containerValues.decodeIfPresent(S3DestinationConfiguration.self, forKey: .s3DestinationConfiguration)
        s3DestinationConfiguration = s3DestinationConfigurationDecoded
    }
}

extension DatasetContentDeliveryDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetContentDeliveryDestination(iotEventsDestinationConfiguration: \(String(describing: iotEventsDestinationConfiguration)), s3DestinationConfiguration: \(String(describing: s3DestinationConfiguration)))"}
}

/// <p>The destination to which dataset contents are delivered.</p>
public struct DatasetContentDeliveryDestination: Equatable {
    /// <p>Configuration information for delivery of dataset contents to AWS IoT Events.</p>
    public let iotEventsDestinationConfiguration: IotEventsDestinationConfiguration?
    /// <p>Configuration information for delivery of dataset contents to Amazon S3.</p>
    public let s3DestinationConfiguration: S3DestinationConfiguration?

    public init (
        iotEventsDestinationConfiguration: IotEventsDestinationConfiguration? = nil,
        s3DestinationConfiguration: S3DestinationConfiguration? = nil
    )
    {
        self.iotEventsDestinationConfiguration = iotEventsDestinationConfiguration
        self.s3DestinationConfiguration = s3DestinationConfiguration
    }
}

extension DatasetContentDeliveryRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destination
        case entryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let entryName = entryName {
            try encodeContainer.encode(entryName, forKey: .entryName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entryName)
        entryName = entryNameDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(DatasetContentDeliveryDestination.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension DatasetContentDeliveryRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetContentDeliveryRule(destination: \(String(describing: destination)), entryName: \(String(describing: entryName)))"}
}

/// <p>When dataset contents are created, they are delivered to destination specified
///       here.</p>
public struct DatasetContentDeliveryRule: Equatable {
    /// <p>The destination to which dataset contents are delivered.</p>
    public let destination: DatasetContentDeliveryDestination?
    /// <p>The name of the dataset content delivery rules entry.</p>
    public let entryName: String?

    public init (
        destination: DatasetContentDeliveryDestination? = nil,
        entryName: String? = nil
    )
    {
        self.destination = destination
        self.entryName = entryName
    }
}

public enum DatasetContentState {
    case creating
    case failed
    case succeeded
    case sdkUnknown(String)
}

extension DatasetContentState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DatasetContentState] {
        return [
            .creating,
            .failed,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .creating: return "CREATING"
        case .failed: return "FAILED"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DatasetContentState(rawValue: rawValue) ?? DatasetContentState.sdkUnknown(rawValue)
    }
}

extension DatasetContentStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reason
        case state
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(DatasetContentState.self, forKey: .state)
        state = stateDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension DatasetContentStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetContentStatus(reason: \(String(describing: reason)), state: \(String(describing: state)))"}
}

/// <p>The state of the data set contents and the reason they are in this state.</p>
public struct DatasetContentStatus: Equatable {
    /// <p>The reason the data set contents are in this state.</p>
    public let reason: String?
    /// <p>The state of the data set contents. Can be one of READY, CREATING, SUCCEEDED, or
    ///       FAILED.</p>
    public let state: DatasetContentState?

    public init (
        reason: String? = nil,
        state: DatasetContentState? = nil
    )
    {
        self.reason = reason
        self.state = state
    }
}

extension DatasetContentSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case completionTime
        case creationTime
        case scheduleTime
        case status
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = completionTime {
            try encodeContainer.encode(completionTime.timeIntervalSince1970, forKey: .completionTime)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let scheduleTime = scheduleTime {
            try encodeContainer.encode(scheduleTime.timeIntervalSince1970, forKey: .scheduleTime)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DatasetContentStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let scheduleTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .scheduleTime)
        scheduleTime = scheduleTimeDecoded
        let completionTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completionTime)
        completionTime = completionTimeDecoded
    }
}

extension DatasetContentSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetContentSummary(completionTime: \(String(describing: completionTime)), creationTime: \(String(describing: creationTime)), scheduleTime: \(String(describing: scheduleTime)), status: \(String(describing: status)), version: \(String(describing: version)))"}
}

/// <p>Summary information about dataset contents.</p>
public struct DatasetContentSummary: Equatable {
    /// <p>The time the dataset content status was updated to SUCCEEDED or FAILED.</p>
    public let completionTime: Date?
    /// <p>The actual time the creation of the dataset contents was started.</p>
    public let creationTime: Date?
    /// <p>The time the creation of the dataset contents was scheduled to start.</p>
    public let scheduleTime: Date?
    /// <p>The status of the data set contents.</p>
    public let status: DatasetContentStatus?
    /// <p>The version of the dataset contents.</p>
    public let version: String?

    public init (
        completionTime: Date? = nil,
        creationTime: Date? = nil,
        scheduleTime: Date? = nil,
        status: DatasetContentStatus? = nil,
        version: String? = nil
    )
    {
        self.completionTime = completionTime
        self.creationTime = creationTime
        self.scheduleTime = scheduleTime
        self.status = status
        self.version = version
    }
}

extension DatasetContentVersionValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
    }
}

extension DatasetContentVersionValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetContentVersionValue(datasetName: \(String(describing: datasetName)))"}
}

/// <p>The dataset whose latest contents are used as input to the notebook or application.</p>
public struct DatasetContentVersionValue: Equatable {
    /// <p>The name of the dataset whose latest contents are used as input to the notebook or
    ///       application.</p>
    public let datasetName: String?

    public init (
        datasetName: String? = nil
    )
    {
        self.datasetName = datasetName
    }
}

extension DatasetEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataURI
        case entryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataURI = dataURI {
            try encodeContainer.encode(dataURI, forKey: .dataURI)
        }
        if let entryName = entryName {
            try encodeContainer.encode(entryName, forKey: .entryName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entryName)
        entryName = entryNameDecoded
        let dataURIDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataURI)
        dataURI = dataURIDecoded
    }
}

extension DatasetEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetEntry(dataURI: \(String(describing: dataURI)), entryName: \(String(describing: entryName)))"}
}

/// <p>The reference to a data set entry.</p>
public struct DatasetEntry: Equatable {
    /// <p>The presigned URI of the data set item.</p>
    public let dataURI: String?
    /// <p>The name of the data set item.</p>
    public let entryName: String?

    public init (
        dataURI: String? = nil,
        entryName: String? = nil
    )
    {
        self.dataURI = dataURI
        self.entryName = entryName
    }
}

public enum DatasetStatus {
    case active
    case creating
    case deleting
    case sdkUnknown(String)
}

extension DatasetStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DatasetStatus] {
        return [
            .active,
            .creating,
            .deleting,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DatasetStatus(rawValue: rawValue) ?? DatasetStatus.sdkUnknown(rawValue)
    }
}

extension DatasetSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions
        case creationTime
        case datasetName
        case lastUpdateTime
        case status
        case triggers
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for datasetactionsummaries0 in actions {
                try actionsContainer.encode(datasetactionsummaries0)
            }
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let triggers = triggers {
            var triggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .triggers)
            for datasettriggers0 in triggers {
                try triggersContainer.encode(datasettriggers0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DatasetStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let triggersContainer = try containerValues.decodeIfPresent([DatasetTrigger?].self, forKey: .triggers)
        var triggersDecoded0:[DatasetTrigger]? = nil
        if let triggersContainer = triggersContainer {
            triggersDecoded0 = [DatasetTrigger]()
            for structure0 in triggersContainer {
                if let structure0 = structure0 {
                    triggersDecoded0?.append(structure0)
                }
            }
        }
        triggers = triggersDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([DatasetActionSummary?].self, forKey: .actions)
        var actionsDecoded0:[DatasetActionSummary]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [DatasetActionSummary]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension DatasetSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetSummary(actions: \(String(describing: actions)), creationTime: \(String(describing: creationTime)), datasetName: \(String(describing: datasetName)), lastUpdateTime: \(String(describing: lastUpdateTime)), status: \(String(describing: status)), triggers: \(String(describing: triggers)))"}
}

/// <p>A summary of information about a data set.</p>
public struct DatasetSummary: Equatable {
    /// <p>A list of <code>DataActionSummary</code> objects.</p>
    public let actions: [DatasetActionSummary]?
    /// <p>The time the data set was created.</p>
    public let creationTime: Date?
    /// <p>The name of the data set.</p>
    public let datasetName: String?
    /// <p>The last time the data set was updated.</p>
    public let lastUpdateTime: Date?
    /// <p>The status of the data set.</p>
    public let status: DatasetStatus?
    /// <p>A list of triggers. A trigger causes data set content to be populated at a specified time
    ///       interval or when another data set is populated. The list of triggers can be empty or contain
    ///       up to five <code>DataSetTrigger</code> objects</p>
    public let triggers: [DatasetTrigger]?

    public init (
        actions: [DatasetActionSummary]? = nil,
        creationTime: Date? = nil,
        datasetName: String? = nil,
        lastUpdateTime: Date? = nil,
        status: DatasetStatus? = nil,
        triggers: [DatasetTrigger]? = nil
    )
    {
        self.actions = actions
        self.creationTime = creationTime
        self.datasetName = datasetName
        self.lastUpdateTime = lastUpdateTime
        self.status = status
        self.triggers = triggers
    }
}

extension DatasetTrigger: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataset
        case schedule
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataset = dataset {
            try encodeContainer.encode(dataset, forKey: .dataset)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleDecoded = try containerValues.decodeIfPresent(Schedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let datasetDecoded = try containerValues.decodeIfPresent(TriggeringDataset.self, forKey: .dataset)
        dataset = datasetDecoded
    }
}

extension DatasetTrigger: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetTrigger(dataset: \(String(describing: dataset)), schedule: \(String(describing: schedule)))"}
}

/// <p>The <code>DatasetTrigger</code> that specifies when the data set is automatically
///       updated.</p>
public struct DatasetTrigger: Equatable {
    /// <p>The data set whose content creation triggers the creation of this data set's
    ///       contents.</p>
    public let dataset: TriggeringDataset?
    /// <p>The Schedule when the trigger is initiated.</p>
    public let schedule: Schedule?

    public init (
        dataset: TriggeringDataset? = nil,
        schedule: Schedule? = nil
    )
    {
        self.dataset = dataset
        self.schedule = schedule
    }
}

extension Datastore: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case creationTime
        case fileFormatConfiguration
        case lastMessageArrivalTime
        case lastUpdateTime
        case name
        case retentionPeriod
        case status
        case storage
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let fileFormatConfiguration = fileFormatConfiguration {
            try encodeContainer.encode(fileFormatConfiguration, forKey: .fileFormatConfiguration)
        }
        if let lastMessageArrivalTime = lastMessageArrivalTime {
            try encodeContainer.encode(lastMessageArrivalTime.timeIntervalSince1970, forKey: .lastMessageArrivalTime)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let retentionPeriod = retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let storage = storage {
            try encodeContainer.encode(storage, forKey: .storage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let storageDecoded = try containerValues.decodeIfPresent(DatastoreStorage.self, forKey: .storage)
        storage = storageDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DatastoreStatus.self, forKey: .status)
        status = statusDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let lastMessageArrivalTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastMessageArrivalTime)
        lastMessageArrivalTime = lastMessageArrivalTimeDecoded
        let fileFormatConfigurationDecoded = try containerValues.decodeIfPresent(FileFormatConfiguration.self, forKey: .fileFormatConfiguration)
        fileFormatConfiguration = fileFormatConfigurationDecoded
    }
}

extension Datastore: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Datastore(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), fileFormatConfiguration: \(String(describing: fileFormatConfiguration)), lastMessageArrivalTime: \(String(describing: lastMessageArrivalTime)), lastUpdateTime: \(String(describing: lastUpdateTime)), name: \(String(describing: name)), retentionPeriod: \(String(describing: retentionPeriod)), status: \(String(describing: status)), storage: \(String(describing: storage)))"}
}

/// <p>Information about a data store.</p>
public struct Datastore: Equatable {
    /// <p>The ARN of the data store.</p>
    public let arn: String?
    /// <p>When the data store was created.</p>
    public let creationTime: Date?
    /// <p>Contains the configuration information of file formats. AWS IoT Analytics data stores support JSON
    ///       and <a href="https://parquet.apache.org/">Parquet</a>.</p>
    ///          <p>The default file format is JSON. You can specify only one format.</p>
    ///          <p>You can't change the file format after you create the data store.</p>
    public let fileFormatConfiguration: FileFormatConfiguration?
    /// <p>The last time when a new message arrived in the data store.</p>
    ///          <p>AWS IoT Analytics updates this value at most once per minute for one data store.
    ///   Hence, the <code>lastMessageArrivalTime</code> value is an approximation.</p>
    ///          <p>This feature only applies to messages that arrived in the data store after October 23, 2020. </p>
    public let lastMessageArrivalTime: Date?
    /// <p>The last time the data store was updated.</p>
    public let lastUpdateTime: Date?
    /// <p>The name of the data store.</p>
    public let name: String?
    /// <p>How long, in days, message data is kept for the data store. When
    ///         <code>customerManagedS3</code> storage is selected, this parameter is ignored.</p>
    public let retentionPeriod: RetentionPeriod?
    /// <p>The status of a data store:</p>
    ///          <dl>
    ///             <dt>CREATING</dt>
    ///             <dd>
    ///                <p>The data store is being created.</p>
    ///             </dd>
    ///             <dt>ACTIVE</dt>
    ///             <dd>
    ///                <p>The data store has been created and can be used.</p>
    ///             </dd>
    ///             <dt>DELETING</dt>
    ///             <dd>
    ///                <p>The data store is being deleted.</p>
    ///             </dd>
    ///          </dl>
    public let status: DatastoreStatus?
    /// <p>Where data store data is stored. You can choose one of <code>serviceManagedS3</code> or
    ///         <code>customerManagedS3</code> storage. If not specified, the default is
    ///         <code>serviceManagedS3</code>. You cannot change this storage option after the data store is
    ///       created.</p>
    public let storage: DatastoreStorage?

    public init (
        arn: String? = nil,
        creationTime: Date? = nil,
        fileFormatConfiguration: FileFormatConfiguration? = nil,
        lastMessageArrivalTime: Date? = nil,
        lastUpdateTime: Date? = nil,
        name: String? = nil,
        retentionPeriod: RetentionPeriod? = nil,
        status: DatastoreStatus? = nil,
        storage: DatastoreStorage? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.fileFormatConfiguration = fileFormatConfiguration
        self.lastMessageArrivalTime = lastMessageArrivalTime
        self.lastUpdateTime = lastUpdateTime
        self.name = name
        self.retentionPeriod = retentionPeriod
        self.status = status
        self.storage = storage
    }
}

extension DatastoreActivity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datastoreName
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreName = datastoreName {
            try encodeContainer.encode(datastoreName, forKey: .datastoreName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let datastoreNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
    }
}

extension DatastoreActivity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatastoreActivity(datastoreName: \(String(describing: datastoreName)), name: \(String(describing: name)))"}
}

/// <p>The datastore activity that specifies where to store the processed data.</p>
public struct DatastoreActivity: Equatable {
    /// <p>The name of the data store where processed messages are stored.</p>
    public let datastoreName: String?
    /// <p>The name of the datastore activity.</p>
    public let name: String?

    public init (
        datastoreName: String? = nil,
        name: String? = nil
    )
    {
        self.datastoreName = datastoreName
        self.name = name
    }
}

extension DatastoreStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case size
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let size = size {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeDecoded = try containerValues.decodeIfPresent(EstimatedResourceSize.self, forKey: .size)
        size = sizeDecoded
    }
}

extension DatastoreStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatastoreStatistics(size: \(String(describing: size)))"}
}

/// <p>Statistical information about the data store.</p>
public struct DatastoreStatistics: Equatable {
    /// <p>The estimated size of the data store.</p>
    public let size: EstimatedResourceSize?

    public init (
        size: EstimatedResourceSize? = nil
    )
    {
        self.size = size
    }
}

public enum DatastoreStatus {
    case active
    case creating
    case deleting
    case sdkUnknown(String)
}

extension DatastoreStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DatastoreStatus] {
        return [
            .active,
            .creating,
            .deleting,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DatastoreStatus(rawValue: rawValue) ?? DatastoreStatus.sdkUnknown(rawValue)
    }
}

extension DatastoreStorage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customerManagedS3
        case sdkUnknown
        case serviceManagedS3
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .customerManagedS3(customerManagedS3):
                if let customerManagedS3 = customerManagedS3 {
                    try container.encode(customerManagedS3, forKey: .customerManagedS3)
                }
            case let .serviceManagedS3(serviceManagedS3):
                if let serviceManagedS3 = serviceManagedS3 {
                    try container.encode(serviceManagedS3, forKey: .serviceManagedS3)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let serviceManagedS3Decoded = try values.decodeIfPresent(ServiceManagedDatastoreS3Storage.self, forKey: .serviceManagedS3)
        if let serviceManagedS3 = serviceManagedS3Decoded {
            self = .serviceManagedS3(serviceManagedS3)
            return
        }
        let customerManagedS3Decoded = try values.decodeIfPresent(CustomerManagedDatastoreS3Storage.self, forKey: .customerManagedS3)
        if let customerManagedS3 = customerManagedS3Decoded {
            self = .customerManagedS3(customerManagedS3)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>Where data store data is stored. You can choose one of <code>serviceManagedS3</code> or
///         <code>customerManagedS3</code> storage. If not specified, the default is
///         <code>serviceManagedS3</code>. You cannot change this storage option after the data store is
///       created.</p>
public enum DatastoreStorage: Equatable {
    /// <p>Use this to store data store data in an S3 bucket managed by AWS IoT Analytics. You cannot
    ///       change the choice of service-managed or customer-managed S3 storage after the data store is
    ///       created.</p>
    case serviceManagedS3(ServiceManagedDatastoreS3Storage?)
    /// <p>Use this to store data store data in an S3 bucket that you manage. When customer managed
    ///       storage is selected, the <code>retentionPeriod</code> parameter is ignored. The choice of
    ///       service-managed or customer-managed S3 storage cannot be changed after creation of the data
    ///       store.</p>
    case customerManagedS3(CustomerManagedDatastoreS3Storage?)
    case sdkUnknown(String?)
}

extension DatastoreStorageSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customerManagedS3
        case serviceManagedS3
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerManagedS3 = customerManagedS3 {
            try encodeContainer.encode(customerManagedS3, forKey: .customerManagedS3)
        }
        if let serviceManagedS3 = serviceManagedS3 {
            try encodeContainer.encode(serviceManagedS3, forKey: .serviceManagedS3)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceManagedS3Decoded = try containerValues.decodeIfPresent(ServiceManagedDatastoreS3StorageSummary.self, forKey: .serviceManagedS3)
        serviceManagedS3 = serviceManagedS3Decoded
        let customerManagedS3Decoded = try containerValues.decodeIfPresent(CustomerManagedDatastoreS3StorageSummary.self, forKey: .customerManagedS3)
        customerManagedS3 = customerManagedS3Decoded
    }
}

extension DatastoreStorageSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatastoreStorageSummary(customerManagedS3: \(String(describing: customerManagedS3)), serviceManagedS3: \(String(describing: serviceManagedS3)))"}
}

/// <p>Where data store data is stored.</p>
public struct DatastoreStorageSummary: Equatable {
    /// <p>Used to store data store data in an S3 bucket that you manage.</p>
    public let customerManagedS3: CustomerManagedDatastoreS3StorageSummary?
    /// <p>Used to store data store data in an S3 bucket managed by AWS IoT Analytics.</p>
    public let serviceManagedS3: ServiceManagedDatastoreS3StorageSummary?

    public init (
        customerManagedS3: CustomerManagedDatastoreS3StorageSummary? = nil,
        serviceManagedS3: ServiceManagedDatastoreS3StorageSummary? = nil
    )
    {
        self.customerManagedS3 = customerManagedS3
        self.serviceManagedS3 = serviceManagedS3
    }
}

extension DatastoreSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime
        case datastoreName
        case datastoreStorage
        case fileFormatType
        case lastMessageArrivalTime
        case lastUpdateTime
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let datastoreName = datastoreName {
            try encodeContainer.encode(datastoreName, forKey: .datastoreName)
        }
        if let datastoreStorage = datastoreStorage {
            try encodeContainer.encode(datastoreStorage, forKey: .datastoreStorage)
        }
        if let fileFormatType = fileFormatType {
            try encodeContainer.encode(fileFormatType.rawValue, forKey: .fileFormatType)
        }
        if let lastMessageArrivalTime = lastMessageArrivalTime {
            try encodeContainer.encode(lastMessageArrivalTime.timeIntervalSince1970, forKey: .lastMessageArrivalTime)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
        let datastoreStorageDecoded = try containerValues.decodeIfPresent(DatastoreStorageSummary.self, forKey: .datastoreStorage)
        datastoreStorage = datastoreStorageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DatastoreStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let lastMessageArrivalTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastMessageArrivalTime)
        lastMessageArrivalTime = lastMessageArrivalTimeDecoded
        let fileFormatTypeDecoded = try containerValues.decodeIfPresent(FileFormatType.self, forKey: .fileFormatType)
        fileFormatType = fileFormatTypeDecoded
    }
}

extension DatastoreSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatastoreSummary(creationTime: \(String(describing: creationTime)), datastoreName: \(String(describing: datastoreName)), datastoreStorage: \(String(describing: datastoreStorage)), fileFormatType: \(String(describing: fileFormatType)), lastMessageArrivalTime: \(String(describing: lastMessageArrivalTime)), lastUpdateTime: \(String(describing: lastUpdateTime)), status: \(String(describing: status)))"}
}

/// <p>A summary of information about a data store.</p>
public struct DatastoreSummary: Equatable {
    /// <p>When the data store was created.</p>
    public let creationTime: Date?
    /// <p>The name of the data store.</p>
    public let datastoreName: String?
    /// <p>Where data store data is stored.</p>
    public let datastoreStorage: DatastoreStorageSummary?
    /// <p>The file format of the data in the data store.</p>
    public let fileFormatType: FileFormatType?
    /// <p>The last time when a new message arrived in the data store.</p>
    ///          <p>AWS IoT Analytics updates this value at most once per minute for one data store.
    ///   Hence, the <code>lastMessageArrivalTime</code> value is an approximation.</p>
    ///          <p>This feature only applies to messages that arrived in the data store after October 23, 2020. </p>
    public let lastMessageArrivalTime: Date?
    /// <p>The last time the data store was updated.</p>
    public let lastUpdateTime: Date?
    /// <p>The status of the data store.</p>
    public let status: DatastoreStatus?

    public init (
        creationTime: Date? = nil,
        datastoreName: String? = nil,
        datastoreStorage: DatastoreStorageSummary? = nil,
        fileFormatType: FileFormatType? = nil,
        lastMessageArrivalTime: Date? = nil,
        lastUpdateTime: Date? = nil,
        status: DatastoreStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.datastoreName = datastoreName
        self.datastoreStorage = datastoreStorage
        self.fileFormatType = fileFormatType
        self.lastMessageArrivalTime = lastMessageArrivalTime
        self.lastUpdateTime = lastUpdateTime
        self.status = status
    }
}

extension DeleteChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteChannelInput(channelName: \(String(describing: channelName)))"}
}

extension DeleteChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteChannelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteChannelInput>
    public typealias MOutput = OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteChannelInput>
    public typealias MOutput = OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInput: Equatable {
    /// <p>The name of the channel to delete.</p>
    public let channelName: String?

    public init (
        channelName: String? = nil
    )
    {
        self.channelName = channelName
    }
}

struct DeleteChannelInputBody: Equatable {
}

extension DeleteChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteChannelOutputResponse()"}
}

extension DeleteChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelOutputResponse: Equatable {

    public init() {}
}

struct DeleteChannelOutputResponseBody: Equatable {
}

extension DeleteChannelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDatasetContentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatasetContentInput(datasetName: \(String(describing: datasetName)), versionId: \(String(describing: versionId)))"}
}

extension DeleteDatasetContentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDatasetContentInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDatasetContentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetContentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetContentInput>
    public typealias MOutput = OperationOutput<DeleteDatasetContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetContentOutputError>
}

public struct DeleteDatasetContentInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDatasetContentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetContentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let versionId = input.operationInput.versionId {
            let versionIdQueryItem = URLQueryItem(name: "versionId".urlPercentEncoding(), value: String(versionId).urlPercentEncoding())
            input.builder.withQueryItem(versionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetContentInput>
    public typealias MOutput = OperationOutput<DeleteDatasetContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetContentOutputError>
}

public struct DeleteDatasetContentInput: Equatable {
    /// <p>The name of the dataset whose content is deleted.</p>
    public let datasetName: String?
    /// <p>The version of the dataset whose content is deleted. You can also use the strings
    ///       "$LATEST" or "$LATEST_SUCCEEDED" to delete the latest or latest successfully completed data
    ///       set. If not specified, "$LATEST_SUCCEEDED" is the default.</p>
    public let versionId: String?

    public init (
        datasetName: String? = nil,
        versionId: String? = nil
    )
    {
        self.datasetName = datasetName
        self.versionId = versionId
    }
}

struct DeleteDatasetContentInputBody: Equatable {
}

extension DeleteDatasetContentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDatasetContentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetContentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatasetContentOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetContentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatasetContentOutputResponse()"}
}

extension DeleteDatasetContentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetContentOutputResponse: Equatable {

    public init() {}
}

struct DeleteDatasetContentOutputResponseBody: Equatable {
}

extension DeleteDatasetContentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDatasetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatasetInput(datasetName: \(String(describing: datasetName)))"}
}

extension DeleteDatasetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDatasetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInput: Equatable {
    /// <p>The name of the data set to delete.</p>
    public let datasetName: String?

    public init (
        datasetName: String? = nil
    )
    {
        self.datasetName = datasetName
    }
}

struct DeleteDatasetInputBody: Equatable {
}

extension DeleteDatasetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDatasetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatasetOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatasetOutputResponse()"}
}

extension DeleteDatasetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetOutputResponse: Equatable {

    public init() {}
}

struct DeleteDatasetOutputResponseBody: Equatable {
}

extension DeleteDatasetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDatastoreInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatastoreInput(datastoreName: \(String(describing: datastoreName)))"}
}

extension DeleteDatastoreInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDatastoreInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDatastoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatastoreInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatastoreInput>
    public typealias MOutput = OperationOutput<DeleteDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatastoreOutputError>
}

public struct DeleteDatastoreInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDatastoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatastoreInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatastoreInput>
    public typealias MOutput = OperationOutput<DeleteDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatastoreOutputError>
}

public struct DeleteDatastoreInput: Equatable {
    /// <p>The name of the data store to delete.</p>
    public let datastoreName: String?

    public init (
        datastoreName: String? = nil
    )
    {
        self.datastoreName = datastoreName
    }
}

struct DeleteDatastoreInputBody: Equatable {
}

extension DeleteDatastoreInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDatastoreOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatastoreOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatastoreOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatastoreOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatastoreOutputResponse()"}
}

extension DeleteDatastoreOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatastoreOutputResponse: Equatable {

    public init() {}
}

struct DeleteDatastoreOutputResponseBody: Equatable {
}

extension DeleteDatastoreOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePipelineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePipelineInput(pipelineName: \(String(describing: pipelineName)))"}
}

extension DeletePipelineInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeletePipelineInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePipelineInput>
    public typealias MOutput = OperationOutput<DeletePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePipelineOutputError>
}

public struct DeletePipelineInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePipelineInput>
    public typealias MOutput = OperationOutput<DeletePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePipelineOutputError>
}

public struct DeletePipelineInput: Equatable {
    /// <p>The name of the pipeline to delete.</p>
    public let pipelineName: String?

    public init (
        pipelineName: String? = nil
    )
    {
        self.pipelineName = pipelineName
    }
}

struct DeletePipelineInputBody: Equatable {
}

extension DeletePipelineInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePipelineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePipelineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePipelineOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePipelineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePipelineOutputResponse()"}
}

extension DeletePipelineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePipelineOutputResponse: Equatable {

    public init() {}
}

struct DeletePipelineOutputResponseBody: Equatable {
}

extension DeletePipelineOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeltaTime: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case offsetSeconds
        case timeExpression
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let offsetSeconds = offsetSeconds {
            try encodeContainer.encode(offsetSeconds, forKey: .offsetSeconds)
        }
        if let timeExpression = timeExpression {
            try encodeContainer.encode(timeExpression, forKey: .timeExpression)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offsetSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .offsetSeconds)
        offsetSeconds = offsetSecondsDecoded
        let timeExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeExpression)
        timeExpression = timeExpressionDecoded
    }
}

extension DeltaTime: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeltaTime(offsetSeconds: \(String(describing: offsetSeconds)), timeExpression: \(String(describing: timeExpression)))"}
}

/// <p>Used to limit data to that which has arrived since the last execution of the
///       action.</p>
public struct DeltaTime: Equatable {
    /// <p>The number of seconds of estimated in-flight lag time of message data. When you create
    ///       dataset contents using message data from a specified timeframe, some message data might still
    ///       be in flight when processing begins, and so do not arrive in time to be processed. Use this
    ///       field to make allowances for the in flight time of your message data, so that data not
    ///       processed from a previous timeframe is included with the next timeframe. Otherwise, missed
    ///       message data would be excluded from processing during the next timeframe too, because its
    ///       timestamp places it within the previous timeframe.</p>
    public let offsetSeconds: Int?
    /// <p>An expression by which the time of the message data might be determined. This can be the
    ///       name of a timestamp field or a SQL expression that is used to derive the time the message data
    ///       was generated.</p>
    public let timeExpression: String?

    public init (
        offsetSeconds: Int? = nil,
        timeExpression: String? = nil
    )
    {
        self.offsetSeconds = offsetSeconds
        self.timeExpression = timeExpression
    }
}

extension DeltaTimeSessionWindowConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case timeoutInMinutes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timeoutInMinutes = timeoutInMinutes {
            try encodeContainer.encode(timeoutInMinutes, forKey: .timeoutInMinutes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeoutInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeoutInMinutes)
        timeoutInMinutes = timeoutInMinutesDecoded
    }
}

extension DeltaTimeSessionWindowConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeltaTimeSessionWindowConfiguration(timeoutInMinutes: \(String(describing: timeoutInMinutes)))"}
}

/// <p>A structure that contains the configuration information of a delta time session
///       window.</p>
///          <p>
///             <a href="https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_DeltaTime.html">
///                <code>DeltaTime</code>
///             </a> specifies a time interval. You can use
///         <code>DeltaTime</code> to create dataset contents with data that has arrived in the data
///       store since the last execution. For an example of <code>DeltaTime</code>, see <a href="https://docs.aws.amazon.com/iotanalytics/latest/userguide/automate-create-dataset.html#automate-example6"> Creating
///         a SQL dataset with a delta window (CLI)</a> in the
///         <i>AWS IoT Analytics User Guide</i>.</p>
public struct DeltaTimeSessionWindowConfiguration: Equatable {
    /// <p>A time interval. You can use <code>timeoutInMinutes</code> so that AWS IoT Analytics can batch up late
    ///       data notifications that have been generated since the last execution. AWS IoT Analytics sends one batch of
    ///       notifications to Amazon CloudWatch Events at one time.</p>
    ///          <p>For more information about how to write a timestamp expression, see <a href="https://prestodb.io/docs/0.172/functions/datetime.html">Date and Time Functions and
    ///         Operators</a>, in the <i>Presto 0.172 Documentation</i>.</p>
    public let timeoutInMinutes: Int?

    public init (
        timeoutInMinutes: Int? = nil
    )
    {
        self.timeoutInMinutes = timeoutInMinutes
    }
}

extension DescribeChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeChannelInput(channelName: \(String(describing: channelName)), includeStatistics: \(String(describing: includeStatistics)))"}
}

extension DescribeChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeChannelInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeChannelInput>
    public typealias MOutput = OperationOutput<DescribeChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeChannelOutputError>
}

public struct DescribeChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let includeStatisticsQueryItem = URLQueryItem(name: "includeStatistics".urlPercentEncoding(), value: String(input.operationInput.includeStatistics).urlPercentEncoding())
        input.builder.withQueryItem(includeStatisticsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeChannelInput>
    public typealias MOutput = OperationOutput<DescribeChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeChannelOutputError>
}

public struct DescribeChannelInput: Equatable {
    /// <p>The name of the channel whose information is retrieved.</p>
    public let channelName: String?
    /// <p>If true, additional statistical information about the channel is included in the response.
    ///       This feature cannot be used with a channel whose S3 storage is customer-managed.</p>
    public let includeStatistics: Bool

    public init (
        channelName: String? = nil,
        includeStatistics: Bool = false
    )
    {
        self.channelName = channelName
        self.includeStatistics = includeStatistics
    }
}

struct DescribeChannelInputBody: Equatable {
}

extension DescribeChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeChannelOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeChannelOutputResponse(channel: \(String(describing: channel)), statistics: \(String(describing: statistics)))"}
}

extension DescribeChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeChannelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.channel = output.channel
            self.statistics = output.statistics
        } else {
            self.channel = nil
            self.statistics = nil
        }
    }
}

public struct DescribeChannelOutputResponse: Equatable {
    /// <p>An object that contains information about the channel.</p>
    public let channel: Channel?
    /// <p>Statistics about the channel. Included if the <code>includeStatistics</code> parameter is
    ///       set to <code>true</code> in the request.</p>
    public let statistics: ChannelStatistics?

    public init (
        channel: Channel? = nil,
        statistics: ChannelStatistics? = nil
    )
    {
        self.channel = channel
        self.statistics = statistics
    }
}

struct DescribeChannelOutputResponseBody: Equatable {
    public let channel: Channel?
    public let statistics: ChannelStatistics?
}

extension DescribeChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channel
        case statistics
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(Channel.self, forKey: .channel)
        channel = channelDecoded
        let statisticsDecoded = try containerValues.decodeIfPresent(ChannelStatistics.self, forKey: .statistics)
        statistics = statisticsDecoded
    }
}

extension DescribeDatasetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatasetInput(datasetName: \(String(describing: datasetName)))"}
}

extension DescribeDatasetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeDatasetInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInput: Equatable {
    /// <p>The name of the data set whose information is retrieved.</p>
    public let datasetName: String?

    public init (
        datasetName: String? = nil
    )
    {
        self.datasetName = datasetName
    }
}

struct DescribeDatasetInputBody: Equatable {
}

extension DescribeDatasetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeDatasetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatasetOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatasetOutputResponse(dataset: \(String(describing: dataset)))"}
}

extension DescribeDatasetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDatasetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataset = output.dataset
        } else {
            self.dataset = nil
        }
    }
}

public struct DescribeDatasetOutputResponse: Equatable {
    /// <p>An object that contains information about the data set.</p>
    public let dataset: Dataset?

    public init (
        dataset: Dataset? = nil
    )
    {
        self.dataset = dataset
    }
}

struct DescribeDatasetOutputResponseBody: Equatable {
    public let dataset: Dataset?
}

extension DescribeDatasetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataset
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetDecoded = try containerValues.decodeIfPresent(Dataset.self, forKey: .dataset)
        dataset = datasetDecoded
    }
}

extension DescribeDatastoreInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatastoreInput(datastoreName: \(String(describing: datastoreName)), includeStatistics: \(String(describing: includeStatistics)))"}
}

extension DescribeDatastoreInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeDatastoreInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDatastoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatastoreInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatastoreInput>
    public typealias MOutput = OperationOutput<DescribeDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatastoreOutputError>
}

public struct DescribeDatastoreInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDatastoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatastoreInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let includeStatisticsQueryItem = URLQueryItem(name: "includeStatistics".urlPercentEncoding(), value: String(input.operationInput.includeStatistics).urlPercentEncoding())
        input.builder.withQueryItem(includeStatisticsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatastoreInput>
    public typealias MOutput = OperationOutput<DescribeDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatastoreOutputError>
}

public struct DescribeDatastoreInput: Equatable {
    /// <p>The name of the data store</p>
    public let datastoreName: String?
    /// <p>If true, additional statistical information about the data store is included in the
    ///       response. This feature cannot be used with a data store whose S3 storage is
    ///       customer-managed.</p>
    public let includeStatistics: Bool

    public init (
        datastoreName: String? = nil,
        includeStatistics: Bool = false
    )
    {
        self.datastoreName = datastoreName
        self.includeStatistics = includeStatistics
    }
}

struct DescribeDatastoreInputBody: Equatable {
}

extension DescribeDatastoreInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeDatastoreOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatastoreOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatastoreOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatastoreOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatastoreOutputResponse(datastore: \(String(describing: datastore)), statistics: \(String(describing: statistics)))"}
}

extension DescribeDatastoreOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDatastoreOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datastore = output.datastore
            self.statistics = output.statistics
        } else {
            self.datastore = nil
            self.statistics = nil
        }
    }
}

public struct DescribeDatastoreOutputResponse: Equatable {
    /// <p>Information about the data store.</p>
    public let datastore: Datastore?
    /// <p>Additional statistical information about the data store. Included if the
    ///         <code>includeStatistics</code> parameter is set to <code>true</code> in the request.</p>
    public let statistics: DatastoreStatistics?

    public init (
        datastore: Datastore? = nil,
        statistics: DatastoreStatistics? = nil
    )
    {
        self.datastore = datastore
        self.statistics = statistics
    }
}

struct DescribeDatastoreOutputResponseBody: Equatable {
    public let datastore: Datastore?
    public let statistics: DatastoreStatistics?
}

extension DescribeDatastoreOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datastore
        case statistics
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreDecoded = try containerValues.decodeIfPresent(Datastore.self, forKey: .datastore)
        datastore = datastoreDecoded
        let statisticsDecoded = try containerValues.decodeIfPresent(DatastoreStatistics.self, forKey: .statistics)
        statistics = statisticsDecoded
    }
}

extension DescribeLoggingOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoggingOptionsInput()"}
}

extension DescribeLoggingOptionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeLoggingOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLoggingOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoggingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoggingOptionsInput>
    public typealias MOutput = OperationOutput<DescribeLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoggingOptionsOutputError>
}

public struct DescribeLoggingOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLoggingOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoggingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoggingOptionsInput>
    public typealias MOutput = OperationOutput<DescribeLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoggingOptionsOutputError>
}

public struct DescribeLoggingOptionsInput: Equatable {

    public init() {}
}

struct DescribeLoggingOptionsInputBody: Equatable {
}

extension DescribeLoggingOptionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeLoggingOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLoggingOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLoggingOptionsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoggingOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoggingOptionsOutputResponse(loggingOptions: \(String(describing: loggingOptions)))"}
}

extension DescribeLoggingOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeLoggingOptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.loggingOptions = output.loggingOptions
        } else {
            self.loggingOptions = nil
        }
    }
}

public struct DescribeLoggingOptionsOutputResponse: Equatable {
    /// <p>The current settings of the AWS IoT Analytics logging options.</p>
    public let loggingOptions: LoggingOptions?

    public init (
        loggingOptions: LoggingOptions? = nil
    )
    {
        self.loggingOptions = loggingOptions
    }
}

struct DescribeLoggingOptionsOutputResponseBody: Equatable {
    public let loggingOptions: LoggingOptions?
}

extension DescribeLoggingOptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loggingOptions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingOptionsDecoded = try containerValues.decodeIfPresent(LoggingOptions.self, forKey: .loggingOptions)
        loggingOptions = loggingOptionsDecoded
    }
}

extension DescribePipelineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePipelineInput(pipelineName: \(String(describing: pipelineName)))"}
}

extension DescribePipelineInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribePipelineInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePipelineInput>
    public typealias MOutput = OperationOutput<DescribePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePipelineOutputError>
}

public struct DescribePipelineInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePipelineInput>
    public typealias MOutput = OperationOutput<DescribePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePipelineOutputError>
}

public struct DescribePipelineInput: Equatable {
    /// <p>The name of the pipeline whose information is retrieved.</p>
    public let pipelineName: String?

    public init (
        pipelineName: String? = nil
    )
    {
        self.pipelineName = pipelineName
    }
}

struct DescribePipelineInputBody: Equatable {
}

extension DescribePipelineInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribePipelineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePipelineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePipelineOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePipelineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePipelineOutputResponse(pipeline: \(String(describing: pipeline)))"}
}

extension DescribePipelineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePipelineOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.pipeline = output.pipeline
        } else {
            self.pipeline = nil
        }
    }
}

public struct DescribePipelineOutputResponse: Equatable {
    /// <p>A <code>Pipeline</code> object that contains information about the pipeline.</p>
    public let pipeline: Pipeline?

    public init (
        pipeline: Pipeline? = nil
    )
    {
        self.pipeline = pipeline
    }
}

struct DescribePipelineOutputResponseBody: Equatable {
    public let pipeline: Pipeline?
}

extension DescribePipelineOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipeline
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(Pipeline.self, forKey: .pipeline)
        pipeline = pipelineDecoded
    }
}

extension DeviceRegistryEnrichActivity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attribute
        case name
        case next
        case roleArn
        case thingName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute, forKey: .attribute)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            try encodeContainer.encode(next, forKey: .next)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let thingName = thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let attributeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attribute)
        attribute = attributeDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let nextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .next)
        next = nextDecoded
    }
}

extension DeviceRegistryEnrichActivity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceRegistryEnrichActivity(attribute: \(String(describing: attribute)), name: \(String(describing: name)), next: \(String(describing: next)), roleArn: \(String(describing: roleArn)), thingName: \(String(describing: thingName)))"}
}

/// <p>An activity that adds data from the AWS IoT device registry to your message.</p>
public struct DeviceRegistryEnrichActivity: Equatable {
    /// <p>The name of the attribute that is added to the message.</p>
    public let attribute: String?
    /// <p>The name of the <code>deviceRegistryEnrich</code> activity.</p>
    public let name: String?
    /// <p>The next activity in the pipeline.</p>
    public let next: String?
    /// <p>The ARN of the role that allows access to the device's registry information.</p>
    public let roleArn: String?
    /// <p>The name of the IoT device whose registry information is added to the message.</p>
    public let thingName: String?

    public init (
        attribute: String? = nil,
        name: String? = nil,
        next: String? = nil,
        roleArn: String? = nil,
        thingName: String? = nil
    )
    {
        self.attribute = attribute
        self.name = name
        self.next = next
        self.roleArn = roleArn
        self.thingName = thingName
    }
}

extension DeviceShadowEnrichActivity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attribute
        case name
        case next
        case roleArn
        case thingName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute, forKey: .attribute)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            try encodeContainer.encode(next, forKey: .next)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let thingName = thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let attributeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attribute)
        attribute = attributeDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let nextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .next)
        next = nextDecoded
    }
}

extension DeviceShadowEnrichActivity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceShadowEnrichActivity(attribute: \(String(describing: attribute)), name: \(String(describing: name)), next: \(String(describing: next)), roleArn: \(String(describing: roleArn)), thingName: \(String(describing: thingName)))"}
}

/// <p>An activity that adds information from the AWS IoT Device Shadow service to a
///       message.</p>
public struct DeviceShadowEnrichActivity: Equatable {
    /// <p>The name of the attribute that is added to the message.</p>
    public let attribute: String?
    /// <p>The name of the <code>deviceShadowEnrich</code> activity.</p>
    public let name: String?
    /// <p>The next activity in the pipeline.</p>
    public let next: String?
    /// <p>The ARN of the role that allows access to the device's shadow.</p>
    public let roleArn: String?
    /// <p>The name of the IoT device whose shadow information is added to the message.</p>
    public let thingName: String?

    public init (
        attribute: String? = nil,
        name: String? = nil,
        next: String? = nil,
        roleArn: String? = nil,
        thingName: String? = nil
    )
    {
        self.attribute = attribute
        self.name = name
        self.next = next
        self.roleArn = roleArn
        self.thingName = thingName
    }
}

extension EstimatedResourceSize: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case estimatedOn
        case estimatedSizeInBytes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let estimatedOn = estimatedOn {
            try encodeContainer.encode(estimatedOn.timeIntervalSince1970, forKey: .estimatedOn)
        }
        if let estimatedSizeInBytes = estimatedSizeInBytes {
            try encodeContainer.encode(estimatedSizeInBytes, forKey: .estimatedSizeInBytes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let estimatedSizeInBytesDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .estimatedSizeInBytes)
        estimatedSizeInBytes = estimatedSizeInBytesDecoded
        let estimatedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .estimatedOn)
        estimatedOn = estimatedOnDecoded
    }
}

extension EstimatedResourceSize: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EstimatedResourceSize(estimatedOn: \(String(describing: estimatedOn)), estimatedSizeInBytes: \(String(describing: estimatedSizeInBytes)))"}
}

/// <p>The estimated size of the resource.</p>
public struct EstimatedResourceSize: Equatable {
    /// <p>The time when the estimate of the size of the resource was made.</p>
    public let estimatedOn: Date?
    /// <p>The estimated size of the resource, in bytes.</p>
    public let estimatedSizeInBytes: Double?

    public init (
        estimatedOn: Date? = nil,
        estimatedSizeInBytes: Double? = nil
    )
    {
        self.estimatedOn = estimatedOn
        self.estimatedSizeInBytes = estimatedSizeInBytes
    }
}

extension FileFormatConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jsonConfiguration
        case parquetConfiguration
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jsonConfiguration = jsonConfiguration {
            try encodeContainer.encode(jsonConfiguration, forKey: .jsonConfiguration)
        }
        if let parquetConfiguration = parquetConfiguration {
            try encodeContainer.encode(parquetConfiguration, forKey: .parquetConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jsonConfigurationDecoded = try containerValues.decodeIfPresent(JsonConfiguration.self, forKey: .jsonConfiguration)
        jsonConfiguration = jsonConfigurationDecoded
        let parquetConfigurationDecoded = try containerValues.decodeIfPresent(ParquetConfiguration.self, forKey: .parquetConfiguration)
        parquetConfiguration = parquetConfigurationDecoded
    }
}

extension FileFormatConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileFormatConfiguration(jsonConfiguration: \(String(describing: jsonConfiguration)), parquetConfiguration: \(String(describing: parquetConfiguration)))"}
}

/// <p>Contains the configuration information of file formats. AWS IoT Analytics data stores support JSON
///       and <a href="https://parquet.apache.org/">Parquet</a>.</p>
///          <p>The default file format is JSON. You can specify only one format.</p>
///          <p>You can't change the file format after you create the data store.</p>
public struct FileFormatConfiguration: Equatable {
    /// <p>Contains the configuration information of the JSON format.</p>
    public let jsonConfiguration: JsonConfiguration?
    /// <p>Contains the configuration information of the Parquet format.</p>
    public let parquetConfiguration: ParquetConfiguration?

    public init (
        jsonConfiguration: JsonConfiguration? = nil,
        parquetConfiguration: ParquetConfiguration? = nil
    )
    {
        self.jsonConfiguration = jsonConfiguration
        self.parquetConfiguration = parquetConfiguration
    }
}

public enum FileFormatType {
    case json
    case parquet
    case sdkUnknown(String)
}

extension FileFormatType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FileFormatType] {
        return [
            .json,
            .parquet,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .json: return "JSON"
        case .parquet: return "PARQUET"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FileFormatType(rawValue: rawValue) ?? FileFormatType.sdkUnknown(rawValue)
    }
}

extension FilterActivity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter
        case name
        case next
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            try encodeContainer.encode(next, forKey: .next)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let filterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filter)
        filter = filterDecoded
        let nextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .next)
        next = nextDecoded
    }
}

extension FilterActivity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FilterActivity(filter: \(String(describing: filter)), name: \(String(describing: name)), next: \(String(describing: next)))"}
}

/// <p>An activity that filters a message based on its attributes.</p>
public struct FilterActivity: Equatable {
    /// <p>An expression that looks like a SQL WHERE clause that must return a Boolean value.
    ///       Messages that satisfy the condition are passed to the next activity. </p>
    public let filter: String?
    /// <p>The name of the filter activity.</p>
    public let name: String?
    /// <p>The next activity in the pipeline.</p>
    public let next: String?

    public init (
        filter: String? = nil,
        name: String? = nil,
        next: String? = nil
    )
    {
        self.filter = filter
        self.name = name
        self.next = next
    }
}

extension GetDatasetContentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDatasetContentInput(datasetName: \(String(describing: datasetName)), versionId: \(String(describing: versionId)))"}
}

extension GetDatasetContentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDatasetContentInputHeadersMiddleware: Middleware {
    public let id: String = "GetDatasetContentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDatasetContentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDatasetContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDatasetContentInput>
    public typealias MOutput = OperationOutput<GetDatasetContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDatasetContentOutputError>
}

public struct GetDatasetContentInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDatasetContentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDatasetContentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDatasetContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let versionId = input.operationInput.versionId {
            let versionIdQueryItem = URLQueryItem(name: "versionId".urlPercentEncoding(), value: String(versionId).urlPercentEncoding())
            input.builder.withQueryItem(versionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDatasetContentInput>
    public typealias MOutput = OperationOutput<GetDatasetContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDatasetContentOutputError>
}

public struct GetDatasetContentInput: Equatable {
    /// <p>The name of the data set whose contents are retrieved.</p>
    public let datasetName: String?
    /// <p>The version of the data set whose contents are retrieved. You can also use the strings
    ///       "$LATEST" or "$LATEST_SUCCEEDED" to retrieve the contents of the latest or latest successfully
    ///       completed data set. If not specified, "$LATEST_SUCCEEDED" is the default.</p>
    public let versionId: String?

    public init (
        datasetName: String? = nil,
        versionId: String? = nil
    )
    {
        self.datasetName = datasetName
        self.versionId = versionId
    }
}

struct GetDatasetContentInputBody: Equatable {
}

extension GetDatasetContentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDatasetContentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDatasetContentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDatasetContentOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDatasetContentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDatasetContentOutputResponse(entries: \(String(describing: entries)), status: \(String(describing: status)), timestamp: \(String(describing: timestamp)))"}
}

extension GetDatasetContentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDatasetContentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entries = output.entries
            self.status = output.status
            self.timestamp = output.timestamp
        } else {
            self.entries = nil
            self.status = nil
            self.timestamp = nil
        }
    }
}

public struct GetDatasetContentOutputResponse: Equatable {
    /// <p>A list of <code>DatasetEntry</code> objects.</p>
    public let entries: [DatasetEntry]?
    /// <p>The status of the data set content.</p>
    public let status: DatasetContentStatus?
    /// <p>The time when the request was made.</p>
    public let timestamp: Date?

    public init (
        entries: [DatasetEntry]? = nil,
        status: DatasetContentStatus? = nil,
        timestamp: Date? = nil
    )
    {
        self.entries = entries
        self.status = status
        self.timestamp = timestamp
    }
}

struct GetDatasetContentOutputResponseBody: Equatable {
    public let entries: [DatasetEntry]?
    public let timestamp: Date?
    public let status: DatasetContentStatus?
}

extension GetDatasetContentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entries
        case status
        case timestamp
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([DatasetEntry?].self, forKey: .entries)
        var entriesDecoded0:[DatasetEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [DatasetEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let timestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DatasetContentStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GlueConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case databaseName
        case tableName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
    }
}

extension GlueConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GlueConfiguration(databaseName: \(String(describing: databaseName)), tableName: \(String(describing: tableName)))"}
}

/// <p>Configuration information for coordination with AWS Glue, a fully managed extract,
///       transform and load (ETL) service.</p>
public struct GlueConfiguration: Equatable {
    /// <p>The name of the database in your AWS Glue Data Catalog in which the table is located. An
    ///       AWS Glue Data Catalog database contains metadata tables.</p>
    public let databaseName: String?
    /// <p>The name of the table in your AWS Glue Data Catalog that is used to perform the ETL
    ///       operations. An AWS Glue Data Catalog table contains partitioned data and descriptions of data
    ///       sources and targets.</p>
    public let tableName: String?

    public init (
        databaseName: String? = nil,
        tableName: String? = nil
    )
    {
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

extension InternalFailureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalFailureException(message: \(String(describing: message)))"}
}

extension InternalFailureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There was an internal failure.</p>
public struct InternalFailureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Equatable {
    public let message: String?
}

extension InternalFailureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was not valid.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IotEventsDestinationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputName
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputName = inputName {
            try encodeContainer.encode(inputName, forKey: .inputName)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputName)
        inputName = inputNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IotEventsDestinationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IotEventsDestinationConfiguration(inputName: \(String(describing: inputName)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Configuration information for delivery of dataset contents to AWS IoT Events.</p>
public struct IotEventsDestinationConfiguration: Equatable {
    /// <p>The name of the AWS IoT Events input to which dataset contents are delivered.</p>
    public let inputName: String?
    /// <p>The ARN of the role that grants AWS IoT Analytics permission to deliver dataset contents
    ///       to an AWS IoT Events input.</p>
    public let roleArn: String?

    public init (
        inputName: String? = nil,
        roleArn: String? = nil
    )
    {
        self.inputName = inputName
        self.roleArn = roleArn
    }
}

extension JsonConfiguration: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension JsonConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JsonConfiguration()"}
}

/// <p>Contains the configuration information of the JSON format.</p>
public struct JsonConfiguration: Equatable {

    public init() {}
}

extension LambdaActivity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case batchSize
        case lambdaName
        case name
        case next
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchSize = batchSize {
            try encodeContainer.encode(batchSize, forKey: .batchSize)
        }
        if let lambdaName = lambdaName {
            try encodeContainer.encode(lambdaName, forKey: .lambdaName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            try encodeContainer.encode(next, forKey: .next)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let lambdaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lambdaName)
        lambdaName = lambdaNameDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let nextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .next)
        next = nextDecoded
    }
}

extension LambdaActivity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaActivity(batchSize: \(String(describing: batchSize)), lambdaName: \(String(describing: lambdaName)), name: \(String(describing: name)), next: \(String(describing: next)))"}
}

/// <p>An activity that runs a Lambda function to modify the message.</p>
public struct LambdaActivity: Equatable {
    /// <p>The number of messages passed to the Lambda function for processing.</p>
    ///          <p>The Lambda function must be able to process all of these messages within five minutes,
    ///       which is the maximum timeout duration for Lambda functions.</p>
    public let batchSize: Int?
    /// <p>The name of the Lambda function that is run on the message.</p>
    public let lambdaName: String?
    /// <p>The name of the lambda activity.</p>
    public let name: String?
    /// <p>The next activity in the pipeline.</p>
    public let next: String?

    public init (
        batchSize: Int? = nil,
        lambdaName: String? = nil,
        name: String? = nil,
        next: String? = nil
    )
    {
        self.batchSize = batchSize
        self.lambdaName = lambdaName
        self.name = name
        self.next = next
    }
}

extension LateDataRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ruleConfiguration
        case ruleName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ruleConfiguration = ruleConfiguration {
            try encodeContainer.encode(ruleConfiguration, forKey: .ruleConfiguration)
        }
        if let ruleName = ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let ruleConfigurationDecoded = try containerValues.decodeIfPresent(LateDataRuleConfiguration.self, forKey: .ruleConfiguration)
        ruleConfiguration = ruleConfigurationDecoded
    }
}

extension LateDataRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LateDataRule(ruleConfiguration: \(String(describing: ruleConfiguration)), ruleName: \(String(describing: ruleName)))"}
}

/// <p>A structure that contains the name and configuration information of a late data
///       rule.</p>
public struct LateDataRule: Equatable {
    /// <p>The information needed to configure the late data rule.</p>
    public let ruleConfiguration: LateDataRuleConfiguration?
    /// <p>The name of the late data rule.</p>
    public let ruleName: String?

    public init (
        ruleConfiguration: LateDataRuleConfiguration? = nil,
        ruleName: String? = nil
    )
    {
        self.ruleConfiguration = ruleConfiguration
        self.ruleName = ruleName
    }
}

extension LateDataRuleConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deltaTimeSessionWindowConfiguration
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deltaTimeSessionWindowConfiguration = deltaTimeSessionWindowConfiguration {
            try encodeContainer.encode(deltaTimeSessionWindowConfiguration, forKey: .deltaTimeSessionWindowConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deltaTimeSessionWindowConfigurationDecoded = try containerValues.decodeIfPresent(DeltaTimeSessionWindowConfiguration.self, forKey: .deltaTimeSessionWindowConfiguration)
        deltaTimeSessionWindowConfiguration = deltaTimeSessionWindowConfigurationDecoded
    }
}

extension LateDataRuleConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LateDataRuleConfiguration(deltaTimeSessionWindowConfiguration: \(String(describing: deltaTimeSessionWindowConfiguration)))"}
}

/// <p>The information needed to configure a delta time session window.</p>
public struct LateDataRuleConfiguration: Equatable {
    /// <p>The information needed to configure a delta time session window.</p>
    public let deltaTimeSessionWindowConfiguration: DeltaTimeSessionWindowConfiguration?

    public init (
        deltaTimeSessionWindowConfiguration: DeltaTimeSessionWindowConfiguration? = nil
    )
    {
        self.deltaTimeSessionWindowConfiguration = deltaTimeSessionWindowConfiguration
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The command caused an internal limit to be exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListChannelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListChannelsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListChannelsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListChannelsInputHeadersMiddleware: Middleware {
    public let id: String = "ListChannelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListChannelsInput>
    public typealias MOutput = OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListChannelsOutputError>
}

public struct ListChannelsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListChannelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListChannelsInput>
    public typealias MOutput = OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListChannelsOutputError>
}

public struct ListChannelsInput: Equatable {
    /// <p>The maximum number of results to return in this request.</p>
    ///          <p>The default value is 100.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelsInputBody: Equatable {
}

extension ListChannelsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListChannelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListChannelsOutputResponse(channelSummaries: \(String(describing: channelSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListChannelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListChannelsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.channelSummaries = output.channelSummaries
            self.nextToken = output.nextToken
        } else {
            self.channelSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsOutputResponse: Equatable {
    /// <p>A list of <code>ChannelSummary</code> objects.</p>
    public let channelSummaries: [ChannelSummary]?
    /// <p>The token to retrieve the next set of results, or <code>null</code> if there are no more
    ///       results.</p>
    public let nextToken: String?

    public init (
        channelSummaries: [ChannelSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.channelSummaries = channelSummaries
        self.nextToken = nextToken
    }
}

struct ListChannelsOutputResponseBody: Equatable {
    public let channelSummaries: [ChannelSummary]?
    public let nextToken: String?
}

extension ListChannelsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channelSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelSummariesContainer = try containerValues.decodeIfPresent([ChannelSummary?].self, forKey: .channelSummaries)
        var channelSummariesDecoded0:[ChannelSummary]? = nil
        if let channelSummariesContainer = channelSummariesContainer {
            channelSummariesDecoded0 = [ChannelSummary]()
            for structure0 in channelSummariesContainer {
                if let structure0 = structure0 {
                    channelSummariesDecoded0?.append(structure0)
                }
            }
        }
        channelSummaries = channelSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDatasetContentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetContentsInput(datasetName: \(String(describing: datasetName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), scheduledBefore: \(String(describing: scheduledBefore)), scheduledOnOrAfter: \(String(describing: scheduledOnOrAfter)))"}
}

extension ListDatasetContentsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDatasetContentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDatasetContentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetContentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetContentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetContentsInput>
    public typealias MOutput = OperationOutput<ListDatasetContentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetContentsOutputError>
}

public struct ListDatasetContentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDatasetContentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetContentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetContentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let scheduledOnOrAfter = input.operationInput.scheduledOnOrAfter {
            let scheduledOnOrAfterQueryItem = URLQueryItem(name: "scheduledOnOrAfter".urlPercentEncoding(), value: String(scheduledOnOrAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(scheduledOnOrAfterQueryItem)
        }
        if let scheduledBefore = input.operationInput.scheduledBefore {
            let scheduledBeforeQueryItem = URLQueryItem(name: "scheduledBefore".urlPercentEncoding(), value: String(scheduledBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(scheduledBeforeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetContentsInput>
    public typealias MOutput = OperationOutput<ListDatasetContentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetContentsOutputError>
}

public struct ListDatasetContentsInput: Equatable {
    /// <p>The name of the data set whose contents information you want to list.</p>
    public let datasetName: String?
    /// <p>The maximum number of results to return in this request.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?
    /// <p>A filter to limit results to those data set contents whose creation is scheduled before
    ///       the given time. See the field <code>triggers.schedule</code> in the <code>CreateDataset</code>
    ///       request. (timestamp)</p>
    public let scheduledBefore: Date?
    /// <p>A filter to limit results to those data set contents whose creation is scheduled on or
    ///       after the given time. See the field <code>triggers.schedule</code> in the
    ///         <code>CreateDataset</code> request. (timestamp)</p>
    public let scheduledOnOrAfter: Date?

    public init (
        datasetName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        scheduledBefore: Date? = nil,
        scheduledOnOrAfter: Date? = nil
    )
    {
        self.datasetName = datasetName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.scheduledBefore = scheduledBefore
        self.scheduledOnOrAfter = scheduledOnOrAfter
    }
}

struct ListDatasetContentsInputBody: Equatable {
}

extension ListDatasetContentsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDatasetContentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetContentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetContentsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetContentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetContentsOutputResponse(datasetContentSummaries: \(String(describing: datasetContentSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatasetContentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDatasetContentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasetContentSummaries = output.datasetContentSummaries
            self.nextToken = output.nextToken
        } else {
            self.datasetContentSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetContentsOutputResponse: Equatable {
    /// <p>Summary information about data set contents that have been created.</p>
    public let datasetContentSummaries: [DatasetContentSummary]?
    /// <p>The token to retrieve the next set of results, or <code>null</code> if there are no more
    ///       results.</p>
    public let nextToken: String?

    public init (
        datasetContentSummaries: [DatasetContentSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.datasetContentSummaries = datasetContentSummaries
        self.nextToken = nextToken
    }
}

struct ListDatasetContentsOutputResponseBody: Equatable {
    public let datasetContentSummaries: [DatasetContentSummary]?
    public let nextToken: String?
}

extension ListDatasetContentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetContentSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetContentSummariesContainer = try containerValues.decodeIfPresent([DatasetContentSummary?].self, forKey: .datasetContentSummaries)
        var datasetContentSummariesDecoded0:[DatasetContentSummary]? = nil
        if let datasetContentSummariesContainer = datasetContentSummariesContainer {
            datasetContentSummariesDecoded0 = [DatasetContentSummary]()
            for structure0 in datasetContentSummariesContainer {
                if let structure0 = structure0 {
                    datasetContentSummariesDecoded0?.append(structure0)
                }
            }
        }
        datasetContentSummaries = datasetContentSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDatasetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatasetsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDatasetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDatasetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetsOutputError>
}

public struct ListDatasetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDatasetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetsOutputError>
}

public struct ListDatasetsInput: Equatable {
    /// <p>The maximum number of results to return in this request.</p>
    ///          <p>The default value is 100.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetsInputBody: Equatable {
}

extension ListDatasetsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDatasetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetsOutputResponse(datasetSummaries: \(String(describing: datasetSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatasetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDatasetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasetSummaries = output.datasetSummaries
            self.nextToken = output.nextToken
        } else {
            self.datasetSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetsOutputResponse: Equatable {
    /// <p>A list of <code>DatasetSummary</code> objects.</p>
    public let datasetSummaries: [DatasetSummary]?
    /// <p>The token to retrieve the next set of results, or <code>null</code> if there are no more
    ///       results.</p>
    public let nextToken: String?

    public init (
        datasetSummaries: [DatasetSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.datasetSummaries = datasetSummaries
        self.nextToken = nextToken
    }
}

struct ListDatasetsOutputResponseBody: Equatable {
    public let datasetSummaries: [DatasetSummary]?
    public let nextToken: String?
}

extension ListDatasetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetSummariesContainer = try containerValues.decodeIfPresent([DatasetSummary?].self, forKey: .datasetSummaries)
        var datasetSummariesDecoded0:[DatasetSummary]? = nil
        if let datasetSummariesContainer = datasetSummariesContainer {
            datasetSummariesDecoded0 = [DatasetSummary]()
            for structure0 in datasetSummariesContainer {
                if let structure0 = structure0 {
                    datasetSummariesDecoded0?.append(structure0)
                }
            }
        }
        datasetSummaries = datasetSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDatastoresInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatastoresInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatastoresInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDatastoresInputHeadersMiddleware: Middleware {
    public let id: String = "ListDatastoresInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatastoresInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatastoresOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatastoresInput>
    public typealias MOutput = OperationOutput<ListDatastoresOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatastoresOutputError>
}

public struct ListDatastoresInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDatastoresInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatastoresInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatastoresOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatastoresInput>
    public typealias MOutput = OperationOutput<ListDatastoresOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatastoresOutputError>
}

public struct ListDatastoresInput: Equatable {
    /// <p>The maximum number of results to return in this request.</p>
    ///          <p>The default value is 100.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatastoresInputBody: Equatable {
}

extension ListDatastoresInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDatastoresOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatastoresOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatastoresOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatastoresOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatastoresOutputResponse(datastoreSummaries: \(String(describing: datastoreSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatastoresOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDatastoresOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datastoreSummaries = output.datastoreSummaries
            self.nextToken = output.nextToken
        } else {
            self.datastoreSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatastoresOutputResponse: Equatable {
    /// <p>A list of <code>DatastoreSummary</code> objects.</p>
    public let datastoreSummaries: [DatastoreSummary]?
    /// <p>The token to retrieve the next set of results, or <code>null</code> if there are no more
    ///       results.</p>
    public let nextToken: String?

    public init (
        datastoreSummaries: [DatastoreSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.datastoreSummaries = datastoreSummaries
        self.nextToken = nextToken
    }
}

struct ListDatastoresOutputResponseBody: Equatable {
    public let datastoreSummaries: [DatastoreSummary]?
    public let nextToken: String?
}

extension ListDatastoresOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datastoreSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreSummariesContainer = try containerValues.decodeIfPresent([DatastoreSummary?].self, forKey: .datastoreSummaries)
        var datastoreSummariesDecoded0:[DatastoreSummary]? = nil
        if let datastoreSummariesContainer = datastoreSummariesContainer {
            datastoreSummariesDecoded0 = [DatastoreSummary]()
            for structure0 in datastoreSummariesContainer {
                if let structure0 = structure0 {
                    datastoreSummariesDecoded0?.append(structure0)
                }
            }
        }
        datastoreSummaries = datastoreSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPipelinesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPipelinesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPipelinesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListPipelinesInputHeadersMiddleware: Middleware {
    public let id: String = "ListPipelinesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPipelinesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPipelinesInput>
    public typealias MOutput = OperationOutput<ListPipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPipelinesOutputError>
}

public struct ListPipelinesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPipelinesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPipelinesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPipelinesInput>
    public typealias MOutput = OperationOutput<ListPipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPipelinesOutputError>
}

public struct ListPipelinesInput: Equatable {
    /// <p>The maximum number of results to return in this request.</p>
    ///          <p>The default value is 100.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPipelinesInputBody: Equatable {
}

extension ListPipelinesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListPipelinesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPipelinesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPipelinesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPipelinesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPipelinesOutputResponse(nextToken: \(String(describing: nextToken)), pipelineSummaries: \(String(describing: pipelineSummaries)))"}
}

extension ListPipelinesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPipelinesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.pipelineSummaries = output.pipelineSummaries
        } else {
            self.nextToken = nil
            self.pipelineSummaries = nil
        }
    }
}

public struct ListPipelinesOutputResponse: Equatable {
    /// <p>The token to retrieve the next set of results, or <code>null</code> if there are no more
    ///       results.</p>
    public let nextToken: String?
    /// <p>A list of <code>PipelineSummary</code> objects.</p>
    public let pipelineSummaries: [PipelineSummary]?

    public init (
        nextToken: String? = nil,
        pipelineSummaries: [PipelineSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.pipelineSummaries = pipelineSummaries
    }
}

struct ListPipelinesOutputResponseBody: Equatable {
    public let pipelineSummaries: [PipelineSummary]?
    public let nextToken: String?
}

extension ListPipelinesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case pipelineSummaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineSummariesContainer = try containerValues.decodeIfPresent([PipelineSummary?].self, forKey: .pipelineSummaries)
        var pipelineSummariesDecoded0:[PipelineSummary]? = nil
        if let pipelineSummariesContainer = pipelineSummariesContainer {
            pipelineSummariesDecoded0 = [PipelineSummary]()
            for structure0 in pipelineSummariesContainer {
                if let structure0 = structure0 {
                    pipelineSummariesDecoded0?.append(structure0)
                }
            }
        }
        pipelineSummaries = pipelineSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The ARN of the resource whose tags you want to list.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags (metadata) that you have assigned to the resource.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum LoggingLevel {
    case error
    case sdkUnknown(String)
}

extension LoggingLevel : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LoggingLevel] {
        return [
            .error,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .error: return "ERROR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LoggingLevel(rawValue: rawValue) ?? LoggingLevel.sdkUnknown(rawValue)
    }
}

extension LoggingOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled
        case level
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let level = level {
            try encodeContainer.encode(level.rawValue, forKey: .level)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let levelDecoded = try containerValues.decodeIfPresent(LoggingLevel.self, forKey: .level)
        level = levelDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension LoggingOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoggingOptions(enabled: \(String(describing: enabled)), level: \(String(describing: level)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Information about logging options.</p>
public struct LoggingOptions: Equatable {
    /// <p>If true, logging is enabled for AWS IoT Analytics.</p>
    public let enabled: Bool
    /// <p>The logging level. Currently, only ERROR is supported.</p>
    public let level: LoggingLevel?
    /// <p>The ARN of the role that grants permission to AWS IoT Analytics to perform logging.</p>
    public let roleArn: String?

    public init (
        enabled: Bool = false,
        level: LoggingLevel? = nil,
        roleArn: String? = nil
    )
    {
        self.enabled = enabled
        self.level = level
        self.roleArn = roleArn
    }
}

extension MathActivity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attribute
        case math
        case name
        case next
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute, forKey: .attribute)
        }
        if let math = math {
            try encodeContainer.encode(math, forKey: .math)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            try encodeContainer.encode(next, forKey: .next)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let attributeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attribute)
        attribute = attributeDecoded
        let mathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .math)
        math = mathDecoded
        let nextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .next)
        next = nextDecoded
    }
}

extension MathActivity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MathActivity(attribute: \(String(describing: attribute)), math: \(String(describing: math)), name: \(String(describing: name)), next: \(String(describing: next)))"}
}

/// <p>An activity that computes an arithmetic expression using the message's attributes.</p>
public struct MathActivity: Equatable {
    /// <p>The name of the attribute that contains the result of the math operation.</p>
    public let attribute: String?
    /// <p>An expression that uses one or more existing attributes and must return an integer
    ///       value.</p>
    public let math: String?
    /// <p>The name of the math activity.</p>
    public let name: String?
    /// <p>The next activity in the pipeline.</p>
    public let next: String?

    public init (
        attribute: String? = nil,
        math: String? = nil,
        name: String? = nil,
        next: String? = nil
    )
    {
        self.attribute = attribute
        self.math = math
        self.name = name
        self.next = next
    }
}

extension Message: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case messageId
        case payload
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageId = messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let payload = payload {
            try encodeContainer.encode(payload.base64EncodedString(), forKey: .payload)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension Message: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Message(messageId: \(String(describing: messageId)), payload: \(String(describing: payload)))"}
}

/// <p>Information about a message.</p>
public struct Message: Equatable {
    /// <p>The ID you want to assign to the message. Each <code>messageId</code> must be unique
    ///          within each batch sent.</p>
    public let messageId: String?
    /// <p>The payload of the message. This can be a JSON string or a base64-encoded string
    ///          representing binary data, in which case you must decode it by means of a pipeline
    ///          activity.</p>
    public let payload: Data?

    public init (
        messageId: String? = nil,
        payload: Data? = nil
    )
    {
        self.messageId = messageId
        self.payload = payload
    }
}

extension OutputFileUriValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fileName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileName = fileName {
            try encodeContainer.encode(fileName, forKey: .fileName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileName)
        fileName = fileNameDecoded
    }
}

extension OutputFileUriValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutputFileUriValue(fileName: \(String(describing: fileName)))"}
}

/// <p>The value of the variable as a structure that specifies an output file URI.</p>
public struct OutputFileUriValue: Equatable {
    /// <p>The URI of the location where dataset contents are stored, usually the URI of a file in an
    ///       S3 bucket.</p>
    public let fileName: String?

    public init (
        fileName: String? = nil
    )
    {
        self.fileName = fileName
    }
}

extension ParquetConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case schemaDefinition
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaDefinition = schemaDefinition {
            try encodeContainer.encode(schemaDefinition, forKey: .schemaDefinition)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaDefinitionDecoded = try containerValues.decodeIfPresent(SchemaDefinition.self, forKey: .schemaDefinition)
        schemaDefinition = schemaDefinitionDecoded
    }
}

extension ParquetConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParquetConfiguration(schemaDefinition: \(String(describing: schemaDefinition)))"}
}

/// <p>Contains the configuration information of the Parquet format.</p>
public struct ParquetConfiguration: Equatable {
    /// <p>Information needed to define a schema.</p>
    public let schemaDefinition: SchemaDefinition?

    public init (
        schemaDefinition: SchemaDefinition? = nil
    )
    {
        self.schemaDefinition = schemaDefinition
    }
}

extension Pipeline: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activities
        case arn
        case creationTime
        case lastUpdateTime
        case name
        case reprocessingSummaries
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activities = activities {
            var activitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .activities)
            for pipelineactivities0 in activities {
                try activitiesContainer.encode(pipelineactivities0)
            }
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reprocessingSummaries = reprocessingSummaries {
            var reprocessingSummariesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reprocessingSummaries)
            for reprocessingsummaries0 in reprocessingSummaries {
                try reprocessingSummariesContainer.encode(reprocessingsummaries0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let activitiesContainer = try containerValues.decodeIfPresent([PipelineActivity?].self, forKey: .activities)
        var activitiesDecoded0:[PipelineActivity]? = nil
        if let activitiesContainer = activitiesContainer {
            activitiesDecoded0 = [PipelineActivity]()
            for structure0 in activitiesContainer {
                if let structure0 = structure0 {
                    activitiesDecoded0?.append(structure0)
                }
            }
        }
        activities = activitiesDecoded0
        let reprocessingSummariesContainer = try containerValues.decodeIfPresent([ReprocessingSummary?].self, forKey: .reprocessingSummaries)
        var reprocessingSummariesDecoded0:[ReprocessingSummary]? = nil
        if let reprocessingSummariesContainer = reprocessingSummariesContainer {
            reprocessingSummariesDecoded0 = [ReprocessingSummary]()
            for structure0 in reprocessingSummariesContainer {
                if let structure0 = structure0 {
                    reprocessingSummariesDecoded0?.append(structure0)
                }
            }
        }
        reprocessingSummaries = reprocessingSummariesDecoded0
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension Pipeline: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Pipeline(activities: \(String(describing: activities)), arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), lastUpdateTime: \(String(describing: lastUpdateTime)), name: \(String(describing: name)), reprocessingSummaries: \(String(describing: reprocessingSummaries)))"}
}

/// <p>Contains information about a pipeline.</p>
public struct Pipeline: Equatable {
    /// <p>The activities that perform transformations on the messages.</p>
    public let activities: [PipelineActivity]?
    /// <p>The ARN of the pipeline.</p>
    public let arn: String?
    /// <p>When the pipeline was created.</p>
    public let creationTime: Date?
    /// <p>The last time the pipeline was updated.</p>
    public let lastUpdateTime: Date?
    /// <p>The name of the pipeline.</p>
    public let name: String?
    /// <p>A summary of information about the pipeline reprocessing.</p>
    public let reprocessingSummaries: [ReprocessingSummary]?

    public init (
        activities: [PipelineActivity]? = nil,
        arn: String? = nil,
        creationTime: Date? = nil,
        lastUpdateTime: Date? = nil,
        name: String? = nil,
        reprocessingSummaries: [ReprocessingSummary]? = nil
    )
    {
        self.activities = activities
        self.arn = arn
        self.creationTime = creationTime
        self.lastUpdateTime = lastUpdateTime
        self.name = name
        self.reprocessingSummaries = reprocessingSummaries
    }
}

extension PipelineActivity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addAttributes
        case channel
        case datastore
        case deviceRegistryEnrich
        case deviceShadowEnrich
        case filter
        case lambda
        case math
        case removeAttributes
        case selectAttributes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addAttributes = addAttributes {
            try encodeContainer.encode(addAttributes, forKey: .addAttributes)
        }
        if let channel = channel {
            try encodeContainer.encode(channel, forKey: .channel)
        }
        if let datastore = datastore {
            try encodeContainer.encode(datastore, forKey: .datastore)
        }
        if let deviceRegistryEnrich = deviceRegistryEnrich {
            try encodeContainer.encode(deviceRegistryEnrich, forKey: .deviceRegistryEnrich)
        }
        if let deviceShadowEnrich = deviceShadowEnrich {
            try encodeContainer.encode(deviceShadowEnrich, forKey: .deviceShadowEnrich)
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let lambda = lambda {
            try encodeContainer.encode(lambda, forKey: .lambda)
        }
        if let math = math {
            try encodeContainer.encode(math, forKey: .math)
        }
        if let removeAttributes = removeAttributes {
            try encodeContainer.encode(removeAttributes, forKey: .removeAttributes)
        }
        if let selectAttributes = selectAttributes {
            try encodeContainer.encode(selectAttributes, forKey: .selectAttributes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(ChannelActivity.self, forKey: .channel)
        channel = channelDecoded
        let lambdaDecoded = try containerValues.decodeIfPresent(LambdaActivity.self, forKey: .lambda)
        lambda = lambdaDecoded
        let datastoreDecoded = try containerValues.decodeIfPresent(DatastoreActivity.self, forKey: .datastore)
        datastore = datastoreDecoded
        let addAttributesDecoded = try containerValues.decodeIfPresent(AddAttributesActivity.self, forKey: .addAttributes)
        addAttributes = addAttributesDecoded
        let removeAttributesDecoded = try containerValues.decodeIfPresent(RemoveAttributesActivity.self, forKey: .removeAttributes)
        removeAttributes = removeAttributesDecoded
        let selectAttributesDecoded = try containerValues.decodeIfPresent(SelectAttributesActivity.self, forKey: .selectAttributes)
        selectAttributes = selectAttributesDecoded
        let filterDecoded = try containerValues.decodeIfPresent(FilterActivity.self, forKey: .filter)
        filter = filterDecoded
        let mathDecoded = try containerValues.decodeIfPresent(MathActivity.self, forKey: .math)
        math = mathDecoded
        let deviceRegistryEnrichDecoded = try containerValues.decodeIfPresent(DeviceRegistryEnrichActivity.self, forKey: .deviceRegistryEnrich)
        deviceRegistryEnrich = deviceRegistryEnrichDecoded
        let deviceShadowEnrichDecoded = try containerValues.decodeIfPresent(DeviceShadowEnrichActivity.self, forKey: .deviceShadowEnrich)
        deviceShadowEnrich = deviceShadowEnrichDecoded
    }
}

extension PipelineActivity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PipelineActivity(addAttributes: \(String(describing: addAttributes)), channel: \(String(describing: channel)), datastore: \(String(describing: datastore)), deviceRegistryEnrich: \(String(describing: deviceRegistryEnrich)), deviceShadowEnrich: \(String(describing: deviceShadowEnrich)), filter: \(String(describing: filter)), lambda: \(String(describing: lambda)), math: \(String(describing: math)), removeAttributes: \(String(describing: removeAttributes)), selectAttributes: \(String(describing: selectAttributes)))"}
}

/// <p>An activity that performs a transformation on a message.</p>
public struct PipelineActivity: Equatable {
    /// <p>Adds other attributes based on existing attributes in the message.</p>
    public let addAttributes: AddAttributesActivity?
    /// <p>Determines the source of the messages to be processed.</p>
    public let channel: ChannelActivity?
    /// <p>Specifies where to store the processed message data.</p>
    public let datastore: DatastoreActivity?
    /// <p>Adds data from the AWS IoT device registry to your message.</p>
    public let deviceRegistryEnrich: DeviceRegistryEnrichActivity?
    /// <p>Adds information from the AWS IoT Device Shadow service to a message.</p>
    public let deviceShadowEnrich: DeviceShadowEnrichActivity?
    /// <p>Filters a message based on its attributes.</p>
    public let filter: FilterActivity?
    /// <p>Runs a Lambda function to modify the message.</p>
    public let lambda: LambdaActivity?
    /// <p>Computes an arithmetic expression using the message's attributes and adds it to the
    ///       message.</p>
    public let math: MathActivity?
    /// <p>Removes attributes from a message.</p>
    public let removeAttributes: RemoveAttributesActivity?
    /// <p>Creates a new message using only the specified attributes from the original message.
    ///     </p>
    public let selectAttributes: SelectAttributesActivity?

    public init (
        addAttributes: AddAttributesActivity? = nil,
        channel: ChannelActivity? = nil,
        datastore: DatastoreActivity? = nil,
        deviceRegistryEnrich: DeviceRegistryEnrichActivity? = nil,
        deviceShadowEnrich: DeviceShadowEnrichActivity? = nil,
        filter: FilterActivity? = nil,
        lambda: LambdaActivity? = nil,
        math: MathActivity? = nil,
        removeAttributes: RemoveAttributesActivity? = nil,
        selectAttributes: SelectAttributesActivity? = nil
    )
    {
        self.addAttributes = addAttributes
        self.channel = channel
        self.datastore = datastore
        self.deviceRegistryEnrich = deviceRegistryEnrich
        self.deviceShadowEnrich = deviceShadowEnrich
        self.filter = filter
        self.lambda = lambda
        self.math = math
        self.removeAttributes = removeAttributes
        self.selectAttributes = selectAttributes
    }
}

extension PipelineSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime
        case lastUpdateTime
        case pipelineName
        case reprocessingSummaries
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
        if let reprocessingSummaries = reprocessingSummaries {
            var reprocessingSummariesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reprocessingSummaries)
            for reprocessingsummaries0 in reprocessingSummaries {
                try reprocessingSummariesContainer.encode(reprocessingsummaries0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let reprocessingSummariesContainer = try containerValues.decodeIfPresent([ReprocessingSummary?].self, forKey: .reprocessingSummaries)
        var reprocessingSummariesDecoded0:[ReprocessingSummary]? = nil
        if let reprocessingSummariesContainer = reprocessingSummariesContainer {
            reprocessingSummariesDecoded0 = [ReprocessingSummary]()
            for structure0 in reprocessingSummariesContainer {
                if let structure0 = structure0 {
                    reprocessingSummariesDecoded0?.append(structure0)
                }
            }
        }
        reprocessingSummaries = reprocessingSummariesDecoded0
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension PipelineSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PipelineSummary(creationTime: \(String(describing: creationTime)), lastUpdateTime: \(String(describing: lastUpdateTime)), pipelineName: \(String(describing: pipelineName)), reprocessingSummaries: \(String(describing: reprocessingSummaries)))"}
}

/// <p>A summary of information about a pipeline.</p>
public struct PipelineSummary: Equatable {
    /// <p>When the pipeline was created.</p>
    public let creationTime: Date?
    /// <p>When the pipeline was last updated.</p>
    public let lastUpdateTime: Date?
    /// <p>The name of the pipeline.</p>
    public let pipelineName: String?
    /// <p>A summary of information about the pipeline reprocessing.</p>
    public let reprocessingSummaries: [ReprocessingSummary]?

    public init (
        creationTime: Date? = nil,
        lastUpdateTime: Date? = nil,
        pipelineName: String? = nil,
        reprocessingSummaries: [ReprocessingSummary]? = nil
    )
    {
        self.creationTime = creationTime
        self.lastUpdateTime = lastUpdateTime
        self.pipelineName = pipelineName
        self.reprocessingSummaries = reprocessingSummaries
    }
}

public struct PutLoggingOptionsInputBodyMiddleware: Middleware {
    public let id: String = "PutLoggingOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLoggingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLoggingOptionsInput>
    public typealias MOutput = OperationOutput<PutLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLoggingOptionsOutputError>
}

extension PutLoggingOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutLoggingOptionsInput(loggingOptions: \(String(describing: loggingOptions)))"}
}

extension PutLoggingOptionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case loggingOptions
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggingOptions = loggingOptions {
            try encodeContainer.encode(loggingOptions, forKey: .loggingOptions)
        }
    }
}

public struct PutLoggingOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "PutLoggingOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLoggingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLoggingOptionsInput>
    public typealias MOutput = OperationOutput<PutLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLoggingOptionsOutputError>
}

public struct PutLoggingOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutLoggingOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLoggingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLoggingOptionsInput>
    public typealias MOutput = OperationOutput<PutLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLoggingOptionsOutputError>
}

public struct PutLoggingOptionsInput: Equatable {
    /// <p>The new values of the AWS IoT Analytics logging options.</p>
    public let loggingOptions: LoggingOptions?

    public init (
        loggingOptions: LoggingOptions? = nil
    )
    {
        self.loggingOptions = loggingOptions
    }
}

struct PutLoggingOptionsInputBody: Equatable {
    public let loggingOptions: LoggingOptions?
}

extension PutLoggingOptionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loggingOptions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingOptionsDecoded = try containerValues.decodeIfPresent(LoggingOptions.self, forKey: .loggingOptions)
        loggingOptions = loggingOptionsDecoded
    }
}

extension PutLoggingOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutLoggingOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutLoggingOptionsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutLoggingOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutLoggingOptionsOutputResponse()"}
}

extension PutLoggingOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutLoggingOptionsOutputResponse: Equatable {

    public init() {}
}

struct PutLoggingOptionsOutputResponseBody: Equatable {
}

extension PutLoggingOptionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension QueryFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deltaTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deltaTime = deltaTime {
            try encodeContainer.encode(deltaTime, forKey: .deltaTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deltaTimeDecoded = try containerValues.decodeIfPresent(DeltaTime.self, forKey: .deltaTime)
        deltaTime = deltaTimeDecoded
    }
}

extension QueryFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryFilter(deltaTime: \(String(describing: deltaTime)))"}
}

/// <p>Information that is used to filter message data, to segregate it according to the
///       timeframe in which it arrives.</p>
public struct QueryFilter: Equatable {
    /// <p>Used to limit data to that which has arrived since the last execution of the
    ///       action.</p>
    public let deltaTime: DeltaTime?

    public init (
        deltaTime: DeltaTime? = nil
    )
    {
        self.deltaTime = deltaTime
    }
}

extension RemoveAttributesActivity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes
        case name
        case next
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributenames0 in attributes {
                try attributesContainer.encode(attributenames0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            try encodeContainer.encode(next, forKey: .next)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .attributes)
        var attributesDecoded0:[String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String]()
            for string0 in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?.append(string0)
                }
            }
        }
        attributes = attributesDecoded0
        let nextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .next)
        next = nextDecoded
    }
}

extension RemoveAttributesActivity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveAttributesActivity(attributes: \(String(describing: attributes)), name: \(String(describing: name)), next: \(String(describing: next)))"}
}

/// <p>An activity that removes attributes from a message.</p>
public struct RemoveAttributesActivity: Equatable {
    /// <p>A list of 1-50 attributes to remove from the message.</p>
    public let attributes: [String]?
    /// <p>The name of the <code>removeAttributes</code> activity.</p>
    public let name: String?
    /// <p>The next activity in the pipeline.</p>
    public let next: String?

    public init (
        attributes: [String]? = nil,
        name: String? = nil,
        next: String? = nil
    )
    {
        self.attributes = attributes
        self.name = name
        self.next = next
    }
}

public enum ReprocessingStatus {
    case cancelled
    case failed
    case running
    case succeeded
    case sdkUnknown(String)
}

extension ReprocessingStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReprocessingStatus] {
        return [
            .cancelled,
            .failed,
            .running,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "CANCELLED"
        case .failed: return "FAILED"
        case .running: return "RUNNING"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReprocessingStatus(rawValue: rawValue) ?? ReprocessingStatus.sdkUnknown(rawValue)
    }
}

extension ReprocessingSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime
        case id
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ReprocessingStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension ReprocessingSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReprocessingSummary(creationTime: \(String(describing: creationTime)), id: \(String(describing: id)), status: \(String(describing: status)))"}
}

/// <p>Information about pipeline reprocessing.</p>
public struct ReprocessingSummary: Equatable {
    /// <p>The time the pipeline reprocessing was created.</p>
    public let creationTime: Date?
    /// <p>The <code>reprocessingId</code> returned by <code>StartPipelineReprocessing</code>.</p>
    public let id: String?
    /// <p>The status of the pipeline reprocessing.</p>
    public let status: ReprocessingStatus?

    public init (
        creationTime: Date? = nil,
        id: String? = nil,
        status: ReprocessingStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.id = id
        self.status = status
    }
}

extension ResourceAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAlreadyExistsException(message: \(String(describing: message)), resourceArn: \(String(describing: resourceArn)), resourceId: \(String(describing: resourceId)))"}
}

extension ResourceAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceArn = output.resourceArn
            self.resourceId = output.resourceId
        } else {
            self.message = nil
            self.resourceArn = nil
            self.resourceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource with the same name already exists.</p>
public struct ResourceAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The ARN of the resource.</p>
    public var resourceArn: String?
    /// <p>The ID of the resource.</p>
    public var resourceId: String?

    public init (
        message: String? = nil,
        resourceArn: String? = nil,
        resourceId: String? = nil
    )
    {
        self.message = message
        self.resourceArn = resourceArn
        self.resourceId = resourceId
    }
}

struct ResourceAlreadyExistsExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceArn: String?
}

extension ResourceAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceArn
        case resourceId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ResourceConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case computeType
        case volumeSizeInGB
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computeType = computeType {
            try encodeContainer.encode(computeType.rawValue, forKey: .computeType)
        }
        if volumeSizeInGB != 0 {
            try encodeContainer.encode(volumeSizeInGB, forKey: .volumeSizeInGB)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computeTypeDecoded = try containerValues.decodeIfPresent(ComputeType.self, forKey: .computeType)
        computeType = computeTypeDecoded
        let volumeSizeInGBDecoded = try containerValues.decode(Int.self, forKey: .volumeSizeInGB)
        volumeSizeInGB = volumeSizeInGBDecoded
    }
}

extension ResourceConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceConfiguration(computeType: \(String(describing: computeType)), volumeSizeInGB: \(String(describing: volumeSizeInGB)))"}
}

/// <p>The configuration of the resource used to execute the <code>containerAction</code>.</p>
public struct ResourceConfiguration: Equatable {
    /// <p>The type of the compute resource used to execute the <code>containerAction</code>.
    ///       Possible values are: <code>ACU_1</code> (vCPU=4, memory=16 GiB) or <code>ACU_2</code> (vCPU=8,
    ///       memory=32 GiB).</p>
    public let computeType: ComputeType?
    /// <p>The size, in GB, of the persistent storage available to the resource instance used to
    ///       execute the <code>containerAction</code> (min: 1, max: 50).</p>
    public let volumeSizeInGB: Int

    public init (
        computeType: ComputeType? = nil,
        volumeSizeInGB: Int = 0
    )
    {
        self.computeType = computeType
        self.volumeSizeInGB = volumeSizeInGB
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource with the specified name could not be found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RetentionPeriod: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case numberOfDays
        case unlimited
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let numberOfDays = numberOfDays {
            try encodeContainer.encode(numberOfDays, forKey: .numberOfDays)
        }
        if unlimited != false {
            try encodeContainer.encode(unlimited, forKey: .unlimited)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unlimitedDecoded = try containerValues.decode(Bool.self, forKey: .unlimited)
        unlimited = unlimitedDecoded
        let numberOfDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfDays)
        numberOfDays = numberOfDaysDecoded
    }
}

extension RetentionPeriod: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RetentionPeriod(numberOfDays: \(String(describing: numberOfDays)), unlimited: \(String(describing: unlimited)))"}
}

/// <p>How long, in days, message data is kept.</p>
public struct RetentionPeriod: Equatable {
    /// <p>The number of days that message data is kept. The <code>unlimited</code> parameter must be
    ///       false.</p>
    public let numberOfDays: Int?
    /// <p>If true, message data is kept indefinitely.</p>
    public let unlimited: Bool

    public init (
        numberOfDays: Int? = nil,
        unlimited: Bool = false
    )
    {
        self.numberOfDays = numberOfDays
        self.unlimited = unlimited
    }
}

public struct RunPipelineActivityInputBodyMiddleware: Middleware {
    public let id: String = "RunPipelineActivityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RunPipelineActivityInput>,
                  next: H) -> Swift.Result<OperationOutput<RunPipelineActivityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RunPipelineActivityInput>
    public typealias MOutput = OperationOutput<RunPipelineActivityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RunPipelineActivityOutputError>
}

extension RunPipelineActivityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RunPipelineActivityInput(payloads: \(String(describing: payloads)), pipelineActivity: \(String(describing: pipelineActivity)))"}
}

extension RunPipelineActivityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case payloads
        case pipelineActivity
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payloads = payloads {
            var payloadsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .payloads)
            for messagepayloads0 in payloads {
                try payloadsContainer.encode(messagepayloads0.base64EncodedString())
            }
        }
        if let pipelineActivity = pipelineActivity {
            try encodeContainer.encode(pipelineActivity, forKey: .pipelineActivity)
        }
    }
}

public struct RunPipelineActivityInputHeadersMiddleware: Middleware {
    public let id: String = "RunPipelineActivityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RunPipelineActivityInput>,
                  next: H) -> Swift.Result<OperationOutput<RunPipelineActivityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RunPipelineActivityInput>
    public typealias MOutput = OperationOutput<RunPipelineActivityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RunPipelineActivityOutputError>
}

public struct RunPipelineActivityInputQueryItemMiddleware: Middleware {
    public let id: String = "RunPipelineActivityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RunPipelineActivityInput>,
                  next: H) -> Swift.Result<OperationOutput<RunPipelineActivityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RunPipelineActivityInput>
    public typealias MOutput = OperationOutput<RunPipelineActivityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RunPipelineActivityOutputError>
}

public struct RunPipelineActivityInput: Equatable {
    /// <p>The sample message payloads on which the pipeline activity is run.</p>
    public let payloads: [Data]?
    /// <p>The pipeline activity that is run. This must not be a channel activity or a datastore
    ///       activity because these activities are used in a pipeline only to load the original message and
    ///       to store the (possibly) transformed message. If a lambda activity is specified, only
    ///       short-running Lambda functions (those with a timeout of less than 30 seconds or less) can be
    ///       used.</p>
    public let pipelineActivity: PipelineActivity?

    public init (
        payloads: [Data]? = nil,
        pipelineActivity: PipelineActivity? = nil
    )
    {
        self.payloads = payloads
        self.pipelineActivity = pipelineActivity
    }
}

struct RunPipelineActivityInputBody: Equatable {
    public let pipelineActivity: PipelineActivity?
    public let payloads: [Data]?
}

extension RunPipelineActivityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case payloads
        case pipelineActivity
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineActivityDecoded = try containerValues.decodeIfPresent(PipelineActivity.self, forKey: .pipelineActivity)
        pipelineActivity = pipelineActivityDecoded
        let payloadsContainer = try containerValues.decodeIfPresent([ClientRuntime.Data?].self, forKey: .payloads)
        var payloadsDecoded0:[Data]? = nil
        if let payloadsContainer = payloadsContainer {
            payloadsDecoded0 = [Data]()
            for blob0 in payloadsContainer {
                if let blob0 = blob0 {
                    payloadsDecoded0?.append(blob0)
                }
            }
        }
        payloads = payloadsDecoded0
    }
}

extension RunPipelineActivityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RunPipelineActivityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RunPipelineActivityOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RunPipelineActivityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RunPipelineActivityOutputResponse(logResult: \(String(describing: logResult)), payloads: \(String(describing: payloads)))"}
}

extension RunPipelineActivityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RunPipelineActivityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.logResult = output.logResult
            self.payloads = output.payloads
        } else {
            self.logResult = nil
            self.payloads = nil
        }
    }
}

public struct RunPipelineActivityOutputResponse: Equatable {
    /// <p>In case the pipeline activity fails, the log message that is generated.</p>
    public let logResult: String?
    /// <p>The enriched or transformed sample message payloads as base64-encoded strings. (The
    ///       results of running the pipeline activity on each input sample message payload, encoded in
    ///       base64.)</p>
    public let payloads: [Data]?

    public init (
        logResult: String? = nil,
        payloads: [Data]? = nil
    )
    {
        self.logResult = logResult
        self.payloads = payloads
    }
}

struct RunPipelineActivityOutputResponseBody: Equatable {
    public let payloads: [Data]?
    public let logResult: String?
}

extension RunPipelineActivityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case logResult
        case payloads
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadsContainer = try containerValues.decodeIfPresent([ClientRuntime.Data?].self, forKey: .payloads)
        var payloadsDecoded0:[Data]? = nil
        if let payloadsContainer = payloadsContainer {
            payloadsDecoded0 = [Data]()
            for blob0 in payloadsContainer {
                if let blob0 = blob0 {
                    payloadsDecoded0?.append(blob0)
                }
            }
        }
        payloads = payloadsDecoded0
        let logResultDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logResult)
        logResult = logResultDecoded
    }
}

extension S3DestinationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket
        case glueConfiguration
        case key
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let glueConfiguration = glueConfiguration {
            try encodeContainer.encode(glueConfiguration, forKey: .glueConfiguration)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let glueConfigurationDecoded = try containerValues.decodeIfPresent(GlueConfiguration.self, forKey: .glueConfiguration)
        glueConfiguration = glueConfigurationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension S3DestinationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3DestinationConfiguration(bucket: \(String(describing: bucket)), glueConfiguration: \(String(describing: glueConfiguration)), key: \(String(describing: key)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Configuration information for delivery of dataset contents to Amazon Simple Storage
///       Service (Amazon S3).</p>
public struct S3DestinationConfiguration: Equatable {
    /// <p>The name of the S3 bucket to which dataset contents are delivered.</p>
    public let bucket: String?
    /// <p>Configuration information for coordination with AWS Glue, a fully managed extract,
    ///       transform and load (ETL) service.</p>
    public let glueConfiguration: GlueConfiguration?
    /// <p>The key of the dataset contents object in an S3 bucket. Each object has a key that is a
    ///       unique identifier. Each object has exactly one key.</p>
    ///          <p>You can create a unique key with the following options:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Use <code>!{iotanalytics:scheduleTime}</code> to insert the time of a scheduled SQL
    ///           query run.</p>
    ///             </li>
    ///             <li>
    ///                <p>Use <code>!{iotanalytics:versionId}</code> to insert a unique hash that identifies a
    ///           dataset content.</p>
    ///             </li>
    ///             <li>
    ///                <p>Use <code>!{iotanalytics:creationTime}</code> to insert the creation time of a dataset
    ///           content.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The following example creates a unique key for a CSV file:
    ///         <code>dataset/mydataset/!{iotanalytics:scheduleTime}/!{iotanalytics:versionId}.csv</code>
    ///          </p>
    ///          <note>
    ///             <p>If you don't use <code>!{iotanalytics:versionId}</code> to specify the key, you might
    ///         get duplicate keys. For example, you might have two dataset contents with the same
    ///           <code>scheduleTime</code> but different <code>versionId</code>s. This means that one
    ///         dataset content overwrites the other. </p>
    ///          </note>
    public let key: String?
    /// <p>The ARN of the role that grants AWS IoT Analytics permission to interact with your Amazon
    ///       S3 and AWS Glue resources.</p>
    public let roleArn: String?

    public init (
        bucket: String? = nil,
        glueConfiguration: GlueConfiguration? = nil,
        key: String? = nil,
        roleArn: String? = nil
    )
    {
        self.bucket = bucket
        self.glueConfiguration = glueConfiguration
        self.key = key
        self.roleArn = roleArn
    }
}

extension SampleChannelDataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SampleChannelDataInput(channelName: \(String(describing: channelName)), endTime: \(String(describing: endTime)), maxMessages: \(String(describing: maxMessages)), startTime: \(String(describing: startTime)))"}
}

extension SampleChannelDataInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct SampleChannelDataInputHeadersMiddleware: Middleware {
    public let id: String = "SampleChannelDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SampleChannelDataInput>,
                  next: H) -> Swift.Result<OperationOutput<SampleChannelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SampleChannelDataInput>
    public typealias MOutput = OperationOutput<SampleChannelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SampleChannelDataOutputError>
}

public struct SampleChannelDataInputQueryItemMiddleware: Middleware {
    public let id: String = "SampleChannelDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SampleChannelDataInput>,
                  next: H) -> Swift.Result<OperationOutput<SampleChannelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxMessages = input.operationInput.maxMessages {
            let maxMessagesQueryItem = URLQueryItem(name: "maxMessages".urlPercentEncoding(), value: String(maxMessages).urlPercentEncoding())
            input.builder.withQueryItem(maxMessagesQueryItem)
        }
        if let startTime = input.operationInput.startTime {
            let startTimeQueryItem = URLQueryItem(name: "startTime".urlPercentEncoding(), value: String(startTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startTimeQueryItem)
        }
        if let endTime = input.operationInput.endTime {
            let endTimeQueryItem = URLQueryItem(name: "endTime".urlPercentEncoding(), value: String(endTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endTimeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SampleChannelDataInput>
    public typealias MOutput = OperationOutput<SampleChannelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SampleChannelDataOutputError>
}

public struct SampleChannelDataInput: Equatable {
    /// <p>The name of the channel whose message samples are retrieved.</p>
    public let channelName: String?
    /// <p>The end of the time window from which sample messages are retrieved.</p>
    public let endTime: Date?
    /// <p>The number of sample messages to be retrieved. The limit is 10. The default is also
    ///       10.</p>
    public let maxMessages: Int?
    /// <p>The start of the time window from which sample messages are retrieved.</p>
    public let startTime: Date?

    public init (
        channelName: String? = nil,
        endTime: Date? = nil,
        maxMessages: Int? = nil,
        startTime: Date? = nil
    )
    {
        self.channelName = channelName
        self.endTime = endTime
        self.maxMessages = maxMessages
        self.startTime = startTime
    }
}

struct SampleChannelDataInputBody: Equatable {
}

extension SampleChannelDataInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension SampleChannelDataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SampleChannelDataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SampleChannelDataOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SampleChannelDataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SampleChannelDataOutputResponse(payloads: \(String(describing: payloads)))"}
}

extension SampleChannelDataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SampleChannelDataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.payloads = output.payloads
        } else {
            self.payloads = nil
        }
    }
}

public struct SampleChannelDataOutputResponse: Equatable {
    /// <p>The list of message samples. Each sample message is returned as a base64-encoded
    ///       string.</p>
    public let payloads: [Data]?

    public init (
        payloads: [Data]? = nil
    )
    {
        self.payloads = payloads
    }
}

struct SampleChannelDataOutputResponseBody: Equatable {
    public let payloads: [Data]?
}

extension SampleChannelDataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case payloads
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadsContainer = try containerValues.decodeIfPresent([ClientRuntime.Data?].self, forKey: .payloads)
        var payloadsDecoded0:[Data]? = nil
        if let payloadsContainer = payloadsContainer {
            payloadsDecoded0 = [Data]()
            for blob0 in payloadsContainer {
                if let blob0 = blob0 {
                    payloadsDecoded0?.append(blob0)
                }
            }
        }
        payloads = payloadsDecoded0
    }
}

extension Schedule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case expression
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expression)
        expression = expressionDecoded
    }
}

extension Schedule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Schedule(expression: \(String(describing: expression)))"}
}

/// <p>The schedule for when to trigger an update.</p>
public struct Schedule: Equatable {
    /// <p>The expression that defines when to trigger an update. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html">Schedule
    ///         Expressions for Rules</a> in the <i>Amazon CloudWatch Events User
    ///         Guide</i>.</p>
    public let expression: String?

    public init (
        expression: String? = nil
    )
    {
        self.expression = expression
    }
}

extension SchemaDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for columns0 in columns {
                try columnsContainer.encode(columns0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnsContainer = try containerValues.decodeIfPresent([Column?].self, forKey: .columns)
        var columnsDecoded0:[Column]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [Column]()
            for structure0 in columnsContainer {
                if let structure0 = structure0 {
                    columnsDecoded0?.append(structure0)
                }
            }
        }
        columns = columnsDecoded0
    }
}

extension SchemaDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SchemaDefinition(columns: \(String(describing: columns)))"}
}

/// <p>Information needed to define a schema.</p>
public struct SchemaDefinition: Equatable {
    /// <p>Specifies one or more columns that store your data.</p>
    ///          <p>Each schema can have up to 100 columns. Each column can have up to 100 nested types</p>
    public let columns: [Column]?

    public init (
        columns: [Column]? = nil
    )
    {
        self.columns = columns
    }
}

extension SelectAttributesActivity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes
        case name
        case next
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributenames0 in attributes {
                try attributesContainer.encode(attributenames0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let next = next {
            try encodeContainer.encode(next, forKey: .next)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .attributes)
        var attributesDecoded0:[String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String]()
            for string0 in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?.append(string0)
                }
            }
        }
        attributes = attributesDecoded0
        let nextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .next)
        next = nextDecoded
    }
}

extension SelectAttributesActivity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SelectAttributesActivity(attributes: \(String(describing: attributes)), name: \(String(describing: name)), next: \(String(describing: next)))"}
}

/// <p>Creates a new message using only the specified attributes from the original
///       message.</p>
public struct SelectAttributesActivity: Equatable {
    /// <p>A list of the attributes to select from the message.</p>
    public let attributes: [String]?
    /// <p>The name of the <code>selectAttributes</code> activity.</p>
    public let name: String?
    /// <p>The next activity in the pipeline.</p>
    public let next: String?

    public init (
        attributes: [String]? = nil,
        name: String? = nil,
        next: String? = nil
    )
    {
        self.attributes = attributes
        self.name = name
        self.next = next
    }
}

extension ServiceManagedChannelS3Storage: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension ServiceManagedChannelS3Storage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceManagedChannelS3Storage()"}
}

/// <p>Use this to store channel data in an S3 bucket managed by AWS IoT Analytics. You cannot
///       change the choice of service-managed or customer-managed S3 storage after the channel is
///       created.</p>
public struct ServiceManagedChannelS3Storage: Equatable {

    public init() {}
}

extension ServiceManagedChannelS3StorageSummary: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension ServiceManagedChannelS3StorageSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceManagedChannelS3StorageSummary()"}
}

/// <p>Used to store channel data in an S3 bucket managed by AWS IoT Analytics.</p>
public struct ServiceManagedChannelS3StorageSummary: Equatable {

    public init() {}
}

extension ServiceManagedDatastoreS3Storage: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension ServiceManagedDatastoreS3Storage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceManagedDatastoreS3Storage()"}
}

/// <p>Use this to store data store data in an S3 bucket managed by AWS IoT Analytics. You cannot
///       change the choice of service-managed or customer-managed S3 storage after the data store is
///       created.</p>
public struct ServiceManagedDatastoreS3Storage: Equatable {

    public init() {}
}

extension ServiceManagedDatastoreS3StorageSummary: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension ServiceManagedDatastoreS3StorageSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceManagedDatastoreS3StorageSummary()"}
}

/// <p>Used to store data store data in an S3 bucket managed by AWS IoT Analytics.</p>
public struct ServiceManagedDatastoreS3StorageSummary: Equatable {

    public init() {}
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service is temporarily unavailable.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SqlQueryDatasetAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case sqlQuery
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for queryfilters0 in filters {
                try filtersContainer.encode(queryfilters0)
            }
        }
        if let sqlQuery = sqlQuery {
            try encodeContainer.encode(sqlQuery, forKey: .sqlQuery)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sqlQueryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sqlQuery)
        sqlQuery = sqlQueryDecoded
        let filtersContainer = try containerValues.decodeIfPresent([QueryFilter?].self, forKey: .filters)
        var filtersDecoded0:[QueryFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [QueryFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension SqlQueryDatasetAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SqlQueryDatasetAction(filters: \(String(describing: filters)), sqlQuery: \(String(describing: sqlQuery)))"}
}

/// <p>The SQL query to modify the message.</p>
public struct SqlQueryDatasetAction: Equatable {
    /// <p>Prefilters applied to message data.</p>
    public let filters: [QueryFilter]?
    /// <p>A SQL query string.</p>
    public let sqlQuery: String?

    public init (
        filters: [QueryFilter]? = nil,
        sqlQuery: String? = nil
    )
    {
        self.filters = filters
        self.sqlQuery = sqlQuery
    }
}

public struct StartPipelineReprocessingInputBodyMiddleware: Middleware {
    public let id: String = "StartPipelineReprocessingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartPipelineReprocessingInput>,
                  next: H) -> Swift.Result<OperationOutput<StartPipelineReprocessingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartPipelineReprocessingInput>
    public typealias MOutput = OperationOutput<StartPipelineReprocessingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartPipelineReprocessingOutputError>
}

extension StartPipelineReprocessingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartPipelineReprocessingInput(channelMessages: \(String(describing: channelMessages)), endTime: \(String(describing: endTime)), pipelineName: \(String(describing: pipelineName)), startTime: \(String(describing: startTime)))"}
}

extension StartPipelineReprocessingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelMessages
        case endTime
        case startTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelMessages = channelMessages {
            try encodeContainer.encode(channelMessages, forKey: .channelMessages)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

public struct StartPipelineReprocessingInputHeadersMiddleware: Middleware {
    public let id: String = "StartPipelineReprocessingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartPipelineReprocessingInput>,
                  next: H) -> Swift.Result<OperationOutput<StartPipelineReprocessingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartPipelineReprocessingInput>
    public typealias MOutput = OperationOutput<StartPipelineReprocessingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartPipelineReprocessingOutputError>
}

public struct StartPipelineReprocessingInputQueryItemMiddleware: Middleware {
    public let id: String = "StartPipelineReprocessingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartPipelineReprocessingInput>,
                  next: H) -> Swift.Result<OperationOutput<StartPipelineReprocessingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartPipelineReprocessingInput>
    public typealias MOutput = OperationOutput<StartPipelineReprocessingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartPipelineReprocessingOutputError>
}

public struct StartPipelineReprocessingInput: Equatable {
    /// <p>Specifies one or more sets of channel messages that you want to reprocess.</p>
    ///          <p>If you use the <code>channelMessages</code> object, you must not specify a value for
    ///         <code>startTime</code> and <code>endTime</code>.</p>
    public let channelMessages: ChannelMessages?
    /// <p>The end time (exclusive) of raw message data that is reprocessed.</p>
    ///          <p>If you specify a value for the <code>endTime</code> parameter, you must not use the
    ///         <code>channelMessages</code> object.</p>
    public let endTime: Date?
    /// <p>The name of the pipeline on which to start reprocessing.</p>
    public let pipelineName: String?
    /// <p>The start time (inclusive) of raw message data that is reprocessed.</p>
    ///          <p>If you specify a value for the <code>startTime</code> parameter, you must not use the
    ///         <code>channelMessages</code> object.</p>
    public let startTime: Date?

    public init (
        channelMessages: ChannelMessages? = nil,
        endTime: Date? = nil,
        pipelineName: String? = nil,
        startTime: Date? = nil
    )
    {
        self.channelMessages = channelMessages
        self.endTime = endTime
        self.pipelineName = pipelineName
        self.startTime = startTime
    }
}

struct StartPipelineReprocessingInputBody: Equatable {
    public let startTime: Date?
    public let endTime: Date?
    public let channelMessages: ChannelMessages?
}

extension StartPipelineReprocessingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channelMessages
        case endTime
        case startTime
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let channelMessagesDecoded = try containerValues.decodeIfPresent(ChannelMessages.self, forKey: .channelMessages)
        channelMessages = channelMessagesDecoded
    }
}

extension StartPipelineReprocessingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartPipelineReprocessingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartPipelineReprocessingOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartPipelineReprocessingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartPipelineReprocessingOutputResponse(reprocessingId: \(String(describing: reprocessingId)))"}
}

extension StartPipelineReprocessingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartPipelineReprocessingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.reprocessingId = output.reprocessingId
        } else {
            self.reprocessingId = nil
        }
    }
}

public struct StartPipelineReprocessingOutputResponse: Equatable {
    /// <p>The ID of the pipeline reprocessing activity that was started.</p>
    public let reprocessingId: String?

    public init (
        reprocessingId: String? = nil
    )
    {
        self.reprocessingId = reprocessingId
    }
}

struct StartPipelineReprocessingOutputResponseBody: Equatable {
    public let reprocessingId: String?
}

extension StartPipelineReprocessingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reprocessingId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reprocessingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reprocessingId)
        reprocessingId = reprocessingIdDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A set of key-value pairs that are used to manage the resource.</p>
public struct Tag: Equatable {
    /// <p>The tag's key.</p>
    public let key: String?
    /// <p>The tag's value.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The ARN of the resource whose tags you want to modify.</p>
    public let resourceArn: String?
    /// <p>The new or modified tags for the resource.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied due to request throttling.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TriggeringDataset: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension TriggeringDataset: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TriggeringDataset(name: \(String(describing: name)))"}
}

/// <p>Information about the dataset whose content generation triggers the new dataset content
///       generation.</p>
public struct TriggeringDataset: Equatable {
    /// <p>The name of the dataset whose content generation triggers the new dataset content
    ///       generation.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The ARN of the resource whose tags you want to remove.</p>
    public let resourceArn: String?
    /// <p>The keys of those tags which you want to remove.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateChannelInputBodyMiddleware: Middleware {
    public let id: String = "UpdateChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateChannelOutputError>
}

extension UpdateChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateChannelInput(channelName: \(String(describing: channelName)), channelStorage: \(String(describing: channelStorage)), retentionPeriod: \(String(describing: retentionPeriod)))"}
}

extension UpdateChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelStorage
        case retentionPeriod
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelStorage = channelStorage {
            try encodeContainer.encode(channelStorage, forKey: .channelStorage)
        }
        if let retentionPeriod = retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
    }
}

public struct UpdateChannelInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInput: Equatable {
    /// <p>The name of the channel to be updated.</p>
    public let channelName: String?
    /// <p>Where channel data is stored. You can choose one of <code>serviceManagedS3</code> or
    ///         <code>customerManagedS3</code> storage. If not specified, the default is
    ///         <code>serviceManagedS3</code>. You cannot change this storage option after the channel is
    ///       created.</p>
    public let channelStorage: ChannelStorage?
    /// <p>How long, in days, message data is kept for the channel. The retention period cannot be
    ///       updated if the channel's S3 storage is customer-managed.</p>
    public let retentionPeriod: RetentionPeriod?

    public init (
        channelName: String? = nil,
        channelStorage: ChannelStorage? = nil,
        retentionPeriod: RetentionPeriod? = nil
    )
    {
        self.channelName = channelName
        self.channelStorage = channelStorage
        self.retentionPeriod = retentionPeriod
    }
}

struct UpdateChannelInputBody: Equatable {
    public let channelStorage: ChannelStorage?
    public let retentionPeriod: RetentionPeriod?
}

extension UpdateChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channelStorage
        case retentionPeriod
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelStorageDecoded = try containerValues.decodeIfPresent(ChannelStorage.self, forKey: .channelStorage)
        channelStorage = channelStorageDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
    }
}

extension UpdateChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateChannelOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateChannelOutputResponse()"}
}

extension UpdateChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateChannelOutputResponse: Equatable {

    public init() {}
}

struct UpdateChannelOutputResponseBody: Equatable {
}

extension UpdateChannelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDatasetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDatasetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDatasetInput>
    public typealias MOutput = OperationOutput<UpdateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDatasetOutputError>
}

extension UpdateDatasetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDatasetInput(actions: \(String(describing: actions)), contentDeliveryRules: \(String(describing: contentDeliveryRules)), datasetName: \(String(describing: datasetName)), lateDataRules: \(String(describing: lateDataRules)), retentionPeriod: \(String(describing: retentionPeriod)), triggers: \(String(describing: triggers)), versioningConfiguration: \(String(describing: versioningConfiguration)))"}
}

extension UpdateDatasetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions
        case contentDeliveryRules
        case lateDataRules
        case retentionPeriod
        case triggers
        case versioningConfiguration
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for datasetactions0 in actions {
                try actionsContainer.encode(datasetactions0)
            }
        }
        if let contentDeliveryRules = contentDeliveryRules {
            var contentDeliveryRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contentDeliveryRules)
            for datasetcontentdeliveryrules0 in contentDeliveryRules {
                try contentDeliveryRulesContainer.encode(datasetcontentdeliveryrules0)
            }
        }
        if let lateDataRules = lateDataRules {
            var lateDataRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lateDataRules)
            for latedatarules0 in lateDataRules {
                try lateDataRulesContainer.encode(latedatarules0)
            }
        }
        if let retentionPeriod = retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let triggers = triggers {
            var triggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .triggers)
            for datasettriggers0 in triggers {
                try triggersContainer.encode(datasettriggers0)
            }
        }
        if let versioningConfiguration = versioningConfiguration {
            try encodeContainer.encode(versioningConfiguration, forKey: .versioningConfiguration)
        }
    }
}

public struct UpdateDatasetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDatasetInput>
    public typealias MOutput = OperationOutput<UpdateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDatasetOutputError>
}

public struct UpdateDatasetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDatasetInput>
    public typealias MOutput = OperationOutput<UpdateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDatasetOutputError>
}

public struct UpdateDatasetInput: Equatable {
    /// <p>A list of <code>DatasetAction</code> objects.</p>
    public let actions: [DatasetAction]?
    /// <p>When dataset contents are created, they are delivered to destinations specified
    ///       here.</p>
    public let contentDeliveryRules: [DatasetContentDeliveryRule]?
    /// <p>The name of the data set to update.</p>
    public let datasetName: String?
    /// <p>A list of data rules that send notifications to Amazon CloudWatch, when data arrives late. To
    ///   specify <code>lateDataRules</code>, the dataset must use a <a href="https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_DeltaTime.html">DeltaTimer</a>
    ///   filter.</p>
    public let lateDataRules: [LateDataRule]?
    /// <p>How long, in days, dataset contents are kept for the dataset.</p>
    public let retentionPeriod: RetentionPeriod?
    /// <p>A list of <code>DatasetTrigger</code> objects. The list can be empty or can contain up to
    ///       five <code>DatasetTrigger</code> objects.</p>
    public let triggers: [DatasetTrigger]?
    /// <p>Optional. How many versions of dataset contents are kept. If not specified or set to null,
    ///       only the latest version plus the latest succeeded version (if they are different) are kept for
    ///       the time period specified by the <code>retentionPeriod</code> parameter. For more information,
    ///       see <a href="https://docs.aws.amazon.com/iotanalytics/latest/userguide/getting-started.html#aws-iot-analytics-dataset-versions">Keeping Multiple Versions of AWS IoT Analytics Data Sets</a> in the <i>AWS IoT
    ///         Analytics User Guide</i>.</p>
    public let versioningConfiguration: VersioningConfiguration?

    public init (
        actions: [DatasetAction]? = nil,
        contentDeliveryRules: [DatasetContentDeliveryRule]? = nil,
        datasetName: String? = nil,
        lateDataRules: [LateDataRule]? = nil,
        retentionPeriod: RetentionPeriod? = nil,
        triggers: [DatasetTrigger]? = nil,
        versioningConfiguration: VersioningConfiguration? = nil
    )
    {
        self.actions = actions
        self.contentDeliveryRules = contentDeliveryRules
        self.datasetName = datasetName
        self.lateDataRules = lateDataRules
        self.retentionPeriod = retentionPeriod
        self.triggers = triggers
        self.versioningConfiguration = versioningConfiguration
    }
}

struct UpdateDatasetInputBody: Equatable {
    public let actions: [DatasetAction]?
    public let triggers: [DatasetTrigger]?
    public let contentDeliveryRules: [DatasetContentDeliveryRule]?
    public let retentionPeriod: RetentionPeriod?
    public let versioningConfiguration: VersioningConfiguration?
    public let lateDataRules: [LateDataRule]?
}

extension UpdateDatasetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actions
        case contentDeliveryRules
        case lateDataRules
        case retentionPeriod
        case triggers
        case versioningConfiguration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsContainer = try containerValues.decodeIfPresent([DatasetAction?].self, forKey: .actions)
        var actionsDecoded0:[DatasetAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [DatasetAction]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let triggersContainer = try containerValues.decodeIfPresent([DatasetTrigger?].self, forKey: .triggers)
        var triggersDecoded0:[DatasetTrigger]? = nil
        if let triggersContainer = triggersContainer {
            triggersDecoded0 = [DatasetTrigger]()
            for structure0 in triggersContainer {
                if let structure0 = structure0 {
                    triggersDecoded0?.append(structure0)
                }
            }
        }
        triggers = triggersDecoded0
        let contentDeliveryRulesContainer = try containerValues.decodeIfPresent([DatasetContentDeliveryRule?].self, forKey: .contentDeliveryRules)
        var contentDeliveryRulesDecoded0:[DatasetContentDeliveryRule]? = nil
        if let contentDeliveryRulesContainer = contentDeliveryRulesContainer {
            contentDeliveryRulesDecoded0 = [DatasetContentDeliveryRule]()
            for structure0 in contentDeliveryRulesContainer {
                if let structure0 = structure0 {
                    contentDeliveryRulesDecoded0?.append(structure0)
                }
            }
        }
        contentDeliveryRules = contentDeliveryRulesDecoded0
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let versioningConfigurationDecoded = try containerValues.decodeIfPresent(VersioningConfiguration.self, forKey: .versioningConfiguration)
        versioningConfiguration = versioningConfigurationDecoded
        let lateDataRulesContainer = try containerValues.decodeIfPresent([LateDataRule?].self, forKey: .lateDataRules)
        var lateDataRulesDecoded0:[LateDataRule]? = nil
        if let lateDataRulesContainer = lateDataRulesContainer {
            lateDataRulesDecoded0 = [LateDataRule]()
            for structure0 in lateDataRulesContainer {
                if let structure0 = structure0 {
                    lateDataRulesDecoded0?.append(structure0)
                }
            }
        }
        lateDataRules = lateDataRulesDecoded0
    }
}

extension UpdateDatasetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDatasetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDatasetOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDatasetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDatasetOutputResponse()"}
}

extension UpdateDatasetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDatasetOutputResponse: Equatable {

    public init() {}
}

struct UpdateDatasetOutputResponseBody: Equatable {
}

extension UpdateDatasetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDatastoreInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDatastoreInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDatastoreInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDatastoreInput>
    public typealias MOutput = OperationOutput<UpdateDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDatastoreOutputError>
}

extension UpdateDatastoreInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDatastoreInput(datastoreName: \(String(describing: datastoreName)), datastoreStorage: \(String(describing: datastoreStorage)), fileFormatConfiguration: \(String(describing: fileFormatConfiguration)), retentionPeriod: \(String(describing: retentionPeriod)))"}
}

extension UpdateDatastoreInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datastoreStorage
        case fileFormatConfiguration
        case retentionPeriod
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreStorage = datastoreStorage {
            try encodeContainer.encode(datastoreStorage, forKey: .datastoreStorage)
        }
        if let fileFormatConfiguration = fileFormatConfiguration {
            try encodeContainer.encode(fileFormatConfiguration, forKey: .fileFormatConfiguration)
        }
        if let retentionPeriod = retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
    }
}

public struct UpdateDatastoreInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDatastoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDatastoreInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDatastoreInput>
    public typealias MOutput = OperationOutput<UpdateDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDatastoreOutputError>
}

public struct UpdateDatastoreInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDatastoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDatastoreInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDatastoreInput>
    public typealias MOutput = OperationOutput<UpdateDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDatastoreOutputError>
}

public struct UpdateDatastoreInput: Equatable {
    /// <p>The name of the data store to be updated.</p>
    public let datastoreName: String?
    /// <p>Where data store data is stored. You can choose one of <code>serviceManagedS3</code> or
    ///         <code>customerManagedS3</code> storage. If not specified, the default
    ///         is<code>serviceManagedS3</code>. You cannot change this storage option after the data store
    ///       is created.</p>
    public let datastoreStorage: DatastoreStorage?
    /// <p>Contains the configuration information of file formats. AWS IoT Analytics data stores support JSON
    ///       and <a href="https://parquet.apache.org/">Parquet</a>.</p>
    ///          <p>The default file format is JSON. You can specify only one format.</p>
    ///          <p>You can't change the file format after you create the data store.</p>
    public let fileFormatConfiguration: FileFormatConfiguration?
    /// <p>How long, in days, message data is kept for the data store. The retention period cannot be
    ///       updated if the data store's S3 storage is customer-managed.</p>
    public let retentionPeriod: RetentionPeriod?

    public init (
        datastoreName: String? = nil,
        datastoreStorage: DatastoreStorage? = nil,
        fileFormatConfiguration: FileFormatConfiguration? = nil,
        retentionPeriod: RetentionPeriod? = nil
    )
    {
        self.datastoreName = datastoreName
        self.datastoreStorage = datastoreStorage
        self.fileFormatConfiguration = fileFormatConfiguration
        self.retentionPeriod = retentionPeriod
    }
}

struct UpdateDatastoreInputBody: Equatable {
    public let retentionPeriod: RetentionPeriod?
    public let datastoreStorage: DatastoreStorage?
    public let fileFormatConfiguration: FileFormatConfiguration?
}

extension UpdateDatastoreInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datastoreStorage
        case fileFormatConfiguration
        case retentionPeriod
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let datastoreStorageDecoded = try containerValues.decodeIfPresent(DatastoreStorage.self, forKey: .datastoreStorage)
        datastoreStorage = datastoreStorageDecoded
        let fileFormatConfigurationDecoded = try containerValues.decodeIfPresent(FileFormatConfiguration.self, forKey: .fileFormatConfiguration)
        fileFormatConfiguration = fileFormatConfigurationDecoded
    }
}

extension UpdateDatastoreOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDatastoreOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDatastoreOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDatastoreOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDatastoreOutputResponse()"}
}

extension UpdateDatastoreOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDatastoreOutputResponse: Equatable {

    public init() {}
}

struct UpdateDatastoreOutputResponseBody: Equatable {
}

extension UpdateDatastoreOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdatePipelineInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePipelineInput>
    public typealias MOutput = OperationOutput<UpdatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePipelineOutputError>
}

extension UpdatePipelineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePipelineInput(pipelineActivities: \(String(describing: pipelineActivities)), pipelineName: \(String(describing: pipelineName)))"}
}

extension UpdatePipelineInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pipelineActivities
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineActivities = pipelineActivities {
            var pipelineActivitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pipelineActivities)
            for pipelineactivities0 in pipelineActivities {
                try pipelineActivitiesContainer.encode(pipelineactivities0)
            }
        }
    }
}

public struct UpdatePipelineInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePipelineInput>
    public typealias MOutput = OperationOutput<UpdatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePipelineOutputError>
}

public struct UpdatePipelineInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePipelineInput>
    public typealias MOutput = OperationOutput<UpdatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePipelineOutputError>
}

public struct UpdatePipelineInput: Equatable {
    /// <p>A list of <code>PipelineActivity</code> objects. Activities perform transformations on
    ///       your messages, such as removing, renaming or adding message attributes; filtering messages
    ///       based on attribute values; invoking your Lambda functions on messages for advanced processing;
    ///       or performing mathematical transformations to normalize device data.</p>
    ///          <p>The list can be 2-25 <code>PipelineActivity</code> objects and must contain both a
    ///         <code>channel</code> and a <code>datastore</code> activity. Each entry in the list must
    ///       contain only one activity. For example:</p>
    ///          <p>
    ///             <code>pipelineActivities = [ { "channel": { ... } }, { "lambda": { ... } }, ...
    ///       ]</code>
    ///          </p>
    public let pipelineActivities: [PipelineActivity]?
    /// <p>The name of the pipeline to update.</p>
    public let pipelineName: String?

    public init (
        pipelineActivities: [PipelineActivity]? = nil,
        pipelineName: String? = nil
    )
    {
        self.pipelineActivities = pipelineActivities
        self.pipelineName = pipelineName
    }
}

struct UpdatePipelineInputBody: Equatable {
    public let pipelineActivities: [PipelineActivity]?
}

extension UpdatePipelineInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipelineActivities
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineActivitiesContainer = try containerValues.decodeIfPresent([PipelineActivity?].self, forKey: .pipelineActivities)
        var pipelineActivitiesDecoded0:[PipelineActivity]? = nil
        if let pipelineActivitiesContainer = pipelineActivitiesContainer {
            pipelineActivitiesDecoded0 = [PipelineActivity]()
            for structure0 in pipelineActivitiesContainer {
                if let structure0 = structure0 {
                    pipelineActivitiesDecoded0?.append(structure0)
                }
            }
        }
        pipelineActivities = pipelineActivitiesDecoded0
    }
}

extension UpdatePipelineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePipelineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePipelineOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePipelineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePipelineOutputResponse()"}
}

extension UpdatePipelineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdatePipelineOutputResponse: Equatable {

    public init() {}
}

struct UpdatePipelineOutputResponseBody: Equatable {
}

extension UpdatePipelineOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Variable: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetContentVersionValue
        case doubleValue
        case name
        case outputFileUriValue
        case stringValue
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetContentVersionValue = datasetContentVersionValue {
            try encodeContainer.encode(datasetContentVersionValue, forKey: .datasetContentVersionValue)
        }
        if doubleValue != 0.0 {
            try encodeContainer.encode(doubleValue, forKey: .doubleValue)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputFileUriValue = outputFileUriValue {
            try encodeContainer.encode(outputFileUriValue, forKey: .outputFileUriValue)
        }
        if let stringValue = stringValue {
            try encodeContainer.encode(stringValue, forKey: .stringValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let stringValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stringValue)
        stringValue = stringValueDecoded
        let doubleValueDecoded = try containerValues.decode(Double.self, forKey: .doubleValue)
        doubleValue = doubleValueDecoded
        let datasetContentVersionValueDecoded = try containerValues.decodeIfPresent(DatasetContentVersionValue.self, forKey: .datasetContentVersionValue)
        datasetContentVersionValue = datasetContentVersionValueDecoded
        let outputFileUriValueDecoded = try containerValues.decodeIfPresent(OutputFileUriValue.self, forKey: .outputFileUriValue)
        outputFileUriValue = outputFileUriValueDecoded
    }
}

extension Variable: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Variable(datasetContentVersionValue: \(String(describing: datasetContentVersionValue)), doubleValue: \(String(describing: doubleValue)), name: \(String(describing: name)), outputFileUriValue: \(String(describing: outputFileUriValue)), stringValue: \(String(describing: stringValue)))"}
}

/// <p>An instance of a variable to be passed to the <code>containerAction</code> execution. Each
///       variable must have a name and a value given by one of <code>stringValue</code>,
///         <code>datasetContentVersionValue</code>, or <code>outputFileUriValue</code>.</p>
public struct Variable: Equatable {
    /// <p>The value of the variable as a structure that specifies a dataset content version.</p>
    public let datasetContentVersionValue: DatasetContentVersionValue?
    /// <p>The value of the variable as a double (numeric).</p>
    public let doubleValue: Double
    /// <p>The name of the variable.</p>
    public let name: String?
    /// <p>The value of the variable as a structure that specifies an output file URI.</p>
    public let outputFileUriValue: OutputFileUriValue?
    /// <p>The value of the variable as a string.</p>
    public let stringValue: String?

    public init (
        datasetContentVersionValue: DatasetContentVersionValue? = nil,
        doubleValue: Double = 0.0,
        name: String? = nil,
        outputFileUriValue: OutputFileUriValue? = nil,
        stringValue: String? = nil
    )
    {
        self.datasetContentVersionValue = datasetContentVersionValue
        self.doubleValue = doubleValue
        self.name = name
        self.outputFileUriValue = outputFileUriValue
        self.stringValue = stringValue
    }
}

extension VersioningConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxVersions
        case unlimited
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxVersions = maxVersions {
            try encodeContainer.encode(maxVersions, forKey: .maxVersions)
        }
        if unlimited != false {
            try encodeContainer.encode(unlimited, forKey: .unlimited)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unlimitedDecoded = try containerValues.decode(Bool.self, forKey: .unlimited)
        unlimited = unlimitedDecoded
        let maxVersionsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxVersions)
        maxVersions = maxVersionsDecoded
    }
}

extension VersioningConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VersioningConfiguration(maxVersions: \(String(describing: maxVersions)), unlimited: \(String(describing: unlimited)))"}
}

/// <p>Information about the versioning of dataset contents.</p>
public struct VersioningConfiguration: Equatable {
    /// <p>How many versions of dataset contents are kept. The <code>unlimited</code> parameter must
    ///       be <code>false</code>.</p>
    public let maxVersions: Int?
    /// <p>If true, unlimited versions of dataset contents are kept.</p>
    public let unlimited: Bool

    public init (
        maxVersions: Int? = nil,
        unlimited: Bool = false
    )
    {
        self.maxVersions = maxVersions
        self.unlimited = unlimited
    }
}
