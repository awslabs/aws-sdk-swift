// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AffectedEntity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsAccountId
        case entityArn
        case entityUrl
        case entityValue
        case eventArn
        case lastUpdatedTime
        case statusCode
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let entityArn = entityArn {
            try encodeContainer.encode(entityArn, forKey: .entityArn)
        }
        if let entityUrl = entityUrl {
            try encodeContainer.encode(entityUrl, forKey: .entityUrl)
        }
        if let entityValue = entityValue {
            try encodeContainer.encode(entityValue, forKey: .entityValue)
        }
        if let eventArn = eventArn {
            try encodeContainer.encode(eventArn, forKey: .eventArn)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagset0) in tags {
                try tagsContainer.encode(tagset0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityArn)
        entityArn = entityArnDecoded
        let eventArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventArn)
        eventArn = eventArnDecoded
        let entityValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityValue)
        entityValue = entityValueDecoded
        let entityUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityUrl)
        entityUrl = entityUrlDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(EntityStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AffectedEntity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AffectedEntity(awsAccountId: \(String(describing: awsAccountId)), entityArn: \(String(describing: entityArn)), entityUrl: \(String(describing: entityUrl)), entityValue: \(String(describing: entityValue)), eventArn: \(String(describing: eventArn)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), statusCode: \(String(describing: statusCode)), tags: \(String(describing: tags)))"}
}

/// <p>Information about an entity that is affected by a Health event.</p>
public struct AffectedEntity: Equatable {
    /// <p>The 12-digit AWS account number that contains the affected entity.</p>
    public let awsAccountId: String?
    /// <p>The unique identifier for the entity. Format: <code>arn:aws:health:<i>entity-region</i>:<i>aws-account</i>:entity/<i>entity-id</i>
    ///             </code>. Example: <code>arn:aws:health:us-east-1:111222333444:entity/AVh5GGT7ul1arKr1sE1K</code>
    ///          </p>
    public let entityArn: String?
    /// <p>The URL of the affected entity.</p>
    public let entityUrl: String?
    /// <p>The ID of the affected entity.</p>
    public let entityValue: String?
    /// <p>The unique identifier for the event. The event ARN has the
    /// <code>arn:aws:health:<i>event-region</i>::event/<i>SERVICE</i>/<i>EVENT_TYPE_CODE</i>/<i>EVENT_TYPE_PLUS_ID</i>
    ///             </code>
    /// format.</p>
    ///          <p>For example, an event ARN might look like the following:</p>
    ///          <p>
    ///             <code>arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456</code>
    ///          </p>
    public let eventArn: String?
    /// <p>The most recent time that the entity was updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>The most recent status of the entity affected by the event. The possible values are
    ///             <code>IMPAIRED</code>, <code>UNIMPAIRED</code>, and <code>UNKNOWN</code>.</p>
    public let statusCode: EntityStatusCode?
    /// <p>A map of entity tags attached to the affected entity.</p>
    ///          <note>
    ///             <p>Currently, the <code>tags</code> property isn't supported.</p>
    ///          </note>
    public let tags: [String:String]?

    public init (
        awsAccountId: String? = nil,
        entityArn: String? = nil,
        entityUrl: String? = nil,
        entityValue: String? = nil,
        eventArn: String? = nil,
        lastUpdatedTime: Date? = nil,
        statusCode: EntityStatusCode? = nil,
        tags: [String:String]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.entityArn = entityArn
        self.entityUrl = entityUrl
        self.entityValue = entityValue
        self.eventArn = eventArn
        self.lastUpdatedTime = lastUpdatedTime
        self.statusCode = statusCode
        self.tags = tags
    }
}

extension ConcurrentModificationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentModificationException(message: \(String(describing: message)))"}
}

extension ConcurrentModificationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_EnableHealthServiceAccessForOrganization.html">EnableHealthServiceAccessForOrganization</a> is already in progress. Wait for the
///          action to complete before trying again. To get the current status, use the <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeHealthServiceStatusForOrganization.html">DescribeHealthServiceStatusForOrganization</a> operation.</p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentModificationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DateTimeRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case from
        case to
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let from = from {
            try encodeContainer.encode(from.timeIntervalSince1970, forKey: .from)
        }
        if let to = to {
            try encodeContainer.encode(to.timeIntervalSince1970, forKey: .to)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .from)
        from = fromDecoded
        let toDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .to)
        to = toDecoded
    }
}

extension DateTimeRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DateTimeRange(from: \(String(describing: from)), to: \(String(describing: to)))"}
}

/// <p>A range of dates and times that is used by the <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_EventFilter.html">EventFilter</a> and <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_EntityFilter.html">EntityFilter</a> objects. If <code>from</code> is set and <code>to</code> is set:
///          match items where the timestamp (<code>startTime</code>, <code>endTime</code>, or
///             <code>lastUpdatedTime</code>) is between <code>from</code> and <code>to</code>
///          inclusive. If <code>from</code> is set and <code>to</code> is not set: match items where
///          the timestamp value is equal to or after <code>from</code>. If <code>from</code> is not set
///          and <code>to</code> is set: match items where the timestamp value is equal to or before
///             <code>to</code>.</p>
public struct DateTimeRange: Equatable {
    /// <p>The starting date and time of a time range.</p>
    public let from: Date?
    /// <p>The ending date and time of a time range.</p>
    public let to: Date?

    public init (
        from: Date? = nil,
        to: Date? = nil
    )
    {
        self.from = from
        self.to = to
    }
}

public struct DescribeAffectedAccountsForOrganizationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAffectedAccountsForOrganizationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAffectedAccountsForOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAffectedAccountsForOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAffectedAccountsForOrganizationInput>
    public typealias MOutput = OperationOutput<DescribeAffectedAccountsForOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAffectedAccountsForOrganizationOutputError>
}

extension DescribeAffectedAccountsForOrganizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAffectedAccountsForOrganizationInput(eventArn: \(String(describing: eventArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAffectedAccountsForOrganizationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventArn = eventArn {
            try encodeContainer.encode(eventArn, forKey: .eventArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeAffectedAccountsForOrganizationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAffectedAccountsForOrganizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAffectedAccountsForOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAffectedAccountsForOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAffectedAccountsForOrganizationInput>
    public typealias MOutput = OperationOutput<DescribeAffectedAccountsForOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAffectedAccountsForOrganizationOutputError>
}

public struct DescribeAffectedAccountsForOrganizationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAffectedAccountsForOrganizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAffectedAccountsForOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAffectedAccountsForOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAffectedAccountsForOrganizationInput>
    public typealias MOutput = OperationOutput<DescribeAffectedAccountsForOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAffectedAccountsForOrganizationOutputError>
}

public struct DescribeAffectedAccountsForOrganizationInput: Equatable {
    /// <p>The unique identifier for the event. The event ARN has the
    /// <code>arn:aws:health:<i>event-region</i>::event/<i>SERVICE</i>/<i>EVENT_TYPE_CODE</i>/<i>EVENT_TYPE_PLUS_ID</i>
    ///             </code>
    /// format.</p>
    ///          <p>For example, an event ARN might look like the following:</p>
    ///          <p>
    ///             <code>arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456</code>
    ///          </p>
    public let eventArn: String?
    /// <p>The maximum number of items to return in one batch, between 10 and 100, inclusive.</p>
    public let maxResults: Int?
    /// <p>If the results of a search are large, only a portion of the
    /// results are returned, and a <code>nextToken</code> pagination token is returned in the response. To
    /// retrieve the next batch of results, reissue the search request and include the returned token.
    /// When all results have been returned, the response does not contain a pagination token value.</p>
    public let nextToken: String?

    public init (
        eventArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.eventArn = eventArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAffectedAccountsForOrganizationInputBody: Equatable {
    public let eventArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeAffectedAccountsForOrganizationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventArn)
        eventArn = eventArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeAffectedAccountsForOrganizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAffectedAccountsForOrganizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidPaginationToken" : self = .invalidPaginationToken(try InvalidPaginationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAffectedAccountsForOrganizationOutputError: Equatable {
    case invalidPaginationToken(InvalidPaginationToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAffectedAccountsForOrganizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAffectedAccountsForOrganizationOutputResponse(affectedAccounts: \(String(describing: affectedAccounts)), eventScopeCode: \(String(describing: eventScopeCode)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAffectedAccountsForOrganizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAffectedAccountsForOrganizationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.affectedAccounts = output.affectedAccounts
            self.eventScopeCode = output.eventScopeCode
            self.nextToken = output.nextToken
        } else {
            self.affectedAccounts = nil
            self.eventScopeCode = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAffectedAccountsForOrganizationOutputResponse: Equatable {
    /// <p>A JSON set of elements of the affected accounts.</p>
    public let affectedAccounts: [String]?
    /// <p>This parameter specifies if the AWS Health event is a public AWS service event or an account-specific event.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If the <code>eventScopeCode</code> value is <code>PUBLIC</code>, then the
    ///                   <code>affectedAccounts</code> value is always empty.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the <code>eventScopeCode</code> value is <code>ACCOUNT_SPECIFIC</code>, then
    ///                the <code>affectedAccounts</code> value lists the affected AWS accounts in your
    ///                organization. For example, if an event affects a service such as Amazon Elastic Compute Cloud and you
    ///                have AWS accounts that use that service, those account IDs appear in the
    ///                response.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the <code>eventScopeCode</code> value is <code>NONE</code>, then the
    ///                   <code>eventArn</code> that you specified in the request is invalid or doesn't
    ///                exist.</p>
    ///             </li>
    ///          </ul>
    public let eventScopeCode: EventScopeCode?
    /// <p>If the results of a search are large, only a portion of the
    /// results are returned, and a <code>nextToken</code> pagination token is returned in the response. To
    /// retrieve the next batch of results, reissue the search request and include the returned token.
    /// When all results have been returned, the response does not contain a pagination token value.</p>
    public let nextToken: String?

    public init (
        affectedAccounts: [String]? = nil,
        eventScopeCode: EventScopeCode? = nil,
        nextToken: String? = nil
    )
    {
        self.affectedAccounts = affectedAccounts
        self.eventScopeCode = eventScopeCode
        self.nextToken = nextToken
    }
}

struct DescribeAffectedAccountsForOrganizationOutputResponseBody: Equatable {
    public let affectedAccounts: [String]?
    public let eventScopeCode: EventScopeCode?
    public let nextToken: String?
}

extension DescribeAffectedAccountsForOrganizationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case affectedAccounts
        case eventScopeCode
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let affectedAccountsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .affectedAccounts)
        var affectedAccountsDecoded0:[String]? = nil
        if let affectedAccountsContainer = affectedAccountsContainer {
            affectedAccountsDecoded0 = [String]()
            for string0 in affectedAccountsContainer {
                if let string0 = string0 {
                    affectedAccountsDecoded0?.append(string0)
                }
            }
        }
        affectedAccounts = affectedAccountsDecoded0
        let eventScopeCodeDecoded = try containerValues.decodeIfPresent(EventScopeCode.self, forKey: .eventScopeCode)
        eventScopeCode = eventScopeCodeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeAffectedEntitiesForOrganizationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAffectedEntitiesForOrganizationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAffectedEntitiesForOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAffectedEntitiesForOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAffectedEntitiesForOrganizationInput>
    public typealias MOutput = OperationOutput<DescribeAffectedEntitiesForOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAffectedEntitiesForOrganizationOutputError>
}

extension DescribeAffectedEntitiesForOrganizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAffectedEntitiesForOrganizationInput(locale: \(String(describing: locale)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), organizationEntityFilters: \(String(describing: organizationEntityFilters)))"}
}

extension DescribeAffectedEntitiesForOrganizationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case locale
        case maxResults
        case nextToken
        case organizationEntityFilters
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locale = locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationEntityFilters = organizationEntityFilters {
            var organizationEntityFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationEntityFilters)
            for organizationentityfilterslist0 in organizationEntityFilters {
                try organizationEntityFiltersContainer.encode(organizationentityfilterslist0)
            }
        }
    }
}

public struct DescribeAffectedEntitiesForOrganizationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAffectedEntitiesForOrganizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAffectedEntitiesForOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAffectedEntitiesForOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAffectedEntitiesForOrganizationInput>
    public typealias MOutput = OperationOutput<DescribeAffectedEntitiesForOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAffectedEntitiesForOrganizationOutputError>
}

public struct DescribeAffectedEntitiesForOrganizationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAffectedEntitiesForOrganizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAffectedEntitiesForOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAffectedEntitiesForOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAffectedEntitiesForOrganizationInput>
    public typealias MOutput = OperationOutput<DescribeAffectedEntitiesForOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAffectedEntitiesForOrganizationOutputError>
}

public struct DescribeAffectedEntitiesForOrganizationInput: Equatable {
    /// <p>The locale (language) to return information in. English (en) is the default and the only supported value at this time.</p>
    public let locale: String?
    /// <p>The maximum number of items to return in one batch, between 10 and 100, inclusive.</p>
    public let maxResults: Int?
    /// <p>If the results of a search are large, only a portion of the
    /// results are returned, and a <code>nextToken</code> pagination token is returned in the response. To
    /// retrieve the next batch of results, reissue the search request and include the returned token.
    /// When all results have been returned, the response does not contain a pagination token value.</p>
    public let nextToken: String?
    /// <p>A JSON set of elements including the <code>awsAccountId</code> and the
    ///             <code>eventArn</code>.</p>
    public let organizationEntityFilters: [EventAccountFilter]?

    public init (
        locale: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        organizationEntityFilters: [EventAccountFilter]? = nil
    )
    {
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationEntityFilters = organizationEntityFilters
    }
}

struct DescribeAffectedEntitiesForOrganizationInputBody: Equatable {
    public let organizationEntityFilters: [EventAccountFilter]?
    public let locale: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeAffectedEntitiesForOrganizationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case locale
        case maxResults
        case nextToken
        case organizationEntityFilters
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationEntityFiltersContainer = try containerValues.decodeIfPresent([EventAccountFilter?].self, forKey: .organizationEntityFilters)
        var organizationEntityFiltersDecoded0:[EventAccountFilter]? = nil
        if let organizationEntityFiltersContainer = organizationEntityFiltersContainer {
            organizationEntityFiltersDecoded0 = [EventAccountFilter]()
            for structure0 in organizationEntityFiltersContainer {
                if let structure0 = structure0 {
                    organizationEntityFiltersDecoded0?.append(structure0)
                }
            }
        }
        organizationEntityFilters = organizationEntityFiltersDecoded0
        let localeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locale)
        locale = localeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeAffectedEntitiesForOrganizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAffectedEntitiesForOrganizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidPaginationToken" : self = .invalidPaginationToken(try InvalidPaginationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLocale" : self = .unsupportedLocale(try UnsupportedLocale(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAffectedEntitiesForOrganizationOutputError: Equatable {
    case invalidPaginationToken(InvalidPaginationToken)
    case unsupportedLocale(UnsupportedLocale)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAffectedEntitiesForOrganizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAffectedEntitiesForOrganizationOutputResponse(entities: \(String(describing: entities)), failedSet: \(String(describing: failedSet)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAffectedEntitiesForOrganizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAffectedEntitiesForOrganizationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entities = output.entities
            self.failedSet = output.failedSet
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.failedSet = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAffectedEntitiesForOrganizationOutputResponse: Equatable {
    /// <p>A JSON set of elements including the <code>awsAccountId</code> and its
    ///             <code>entityArn</code>, <code>entityValue</code> and its <code>entityArn</code>,
    ///             <code>lastUpdatedTime</code>, and <code>statusCode</code>.</p>
    public let entities: [AffectedEntity]?
    /// <p>A JSON set of elements of the failed response, including the <code>awsAccountId</code>,
    ///             <code>errorMessage</code>, <code>errorName</code>, and <code>eventArn</code>.</p>
    public let failedSet: [OrganizationAffectedEntitiesErrorItem]?
    /// <p>If the results of a search are large, only a portion of the
    /// results are returned, and a <code>nextToken</code> pagination token is returned in the response. To
    /// retrieve the next batch of results, reissue the search request and include the returned token.
    /// When all results have been returned, the response does not contain a pagination token value.</p>
    public let nextToken: String?

    public init (
        entities: [AffectedEntity]? = nil,
        failedSet: [OrganizationAffectedEntitiesErrorItem]? = nil,
        nextToken: String? = nil
    )
    {
        self.entities = entities
        self.failedSet = failedSet
        self.nextToken = nextToken
    }
}

struct DescribeAffectedEntitiesForOrganizationOutputResponseBody: Equatable {
    public let entities: [AffectedEntity]?
    public let failedSet: [OrganizationAffectedEntitiesErrorItem]?
    public let nextToken: String?
}

extension DescribeAffectedEntitiesForOrganizationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entities
        case failedSet
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([AffectedEntity?].self, forKey: .entities)
        var entitiesDecoded0:[AffectedEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [AffectedEntity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let failedSetContainer = try containerValues.decodeIfPresent([OrganizationAffectedEntitiesErrorItem?].self, forKey: .failedSet)
        var failedSetDecoded0:[OrganizationAffectedEntitiesErrorItem]? = nil
        if let failedSetContainer = failedSetContainer {
            failedSetDecoded0 = [OrganizationAffectedEntitiesErrorItem]()
            for structure0 in failedSetContainer {
                if let structure0 = structure0 {
                    failedSetDecoded0?.append(structure0)
                }
            }
        }
        failedSet = failedSetDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeAffectedEntitiesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAffectedEntitiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAffectedEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAffectedEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAffectedEntitiesInput>
    public typealias MOutput = OperationOutput<DescribeAffectedEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAffectedEntitiesOutputError>
}

extension DescribeAffectedEntitiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAffectedEntitiesInput(filter: \(String(describing: filter)), locale: \(String(describing: locale)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAffectedEntitiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter
        case locale
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let locale = locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeAffectedEntitiesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAffectedEntitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAffectedEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAffectedEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAffectedEntitiesInput>
    public typealias MOutput = OperationOutput<DescribeAffectedEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAffectedEntitiesOutputError>
}

public struct DescribeAffectedEntitiesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAffectedEntitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAffectedEntitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAffectedEntitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAffectedEntitiesInput>
    public typealias MOutput = OperationOutput<DescribeAffectedEntitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAffectedEntitiesOutputError>
}

public struct DescribeAffectedEntitiesInput: Equatable {
    /// <p>Values to narrow the results returned. At least one event ARN is required.</p>
    public let filter: EntityFilter?
    /// <p>The locale (language) to return information in. English (en) is the default and the only supported value at this time.</p>
    public let locale: String?
    /// <p>The maximum number of items to return in one batch, between 10 and 100, inclusive.</p>
    public let maxResults: Int?
    /// <p>If the results of a search are large, only a portion of the
    /// results are returned, and a <code>nextToken</code> pagination token is returned in the response. To
    /// retrieve the next batch of results, reissue the search request and include the returned token.
    /// When all results have been returned, the response does not contain a pagination token value.</p>
    public let nextToken: String?

    public init (
        filter: EntityFilter? = nil,
        locale: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filter = filter
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAffectedEntitiesInputBody: Equatable {
    public let filter: EntityFilter?
    public let locale: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeAffectedEntitiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter
        case locale
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(EntityFilter.self, forKey: .filter)
        filter = filterDecoded
        let localeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locale)
        locale = localeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeAffectedEntitiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAffectedEntitiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidPaginationToken" : self = .invalidPaginationToken(try InvalidPaginationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLocale" : self = .unsupportedLocale(try UnsupportedLocale(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAffectedEntitiesOutputError: Equatable {
    case invalidPaginationToken(InvalidPaginationToken)
    case unsupportedLocale(UnsupportedLocale)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAffectedEntitiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAffectedEntitiesOutputResponse(entities: \(String(describing: entities)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAffectedEntitiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAffectedEntitiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entities = output.entities
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAffectedEntitiesOutputResponse: Equatable {
    /// <p>The entities that match the filter criteria.</p>
    public let entities: [AffectedEntity]?
    /// <p>If the results of a search are large, only a portion of the
    /// results are returned, and a <code>nextToken</code> pagination token is returned in the response. To
    /// retrieve the next batch of results, reissue the search request and include the returned token.
    /// When all results have been returned, the response does not contain a pagination token value.</p>
    public let nextToken: String?

    public init (
        entities: [AffectedEntity]? = nil,
        nextToken: String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

struct DescribeAffectedEntitiesOutputResponseBody: Equatable {
    public let entities: [AffectedEntity]?
    public let nextToken: String?
}

extension DescribeAffectedEntitiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entities
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([AffectedEntity?].self, forKey: .entities)
        var entitiesDecoded0:[AffectedEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [AffectedEntity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeEntityAggregatesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEntityAggregatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEntityAggregatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEntityAggregatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEntityAggregatesInput>
    public typealias MOutput = OperationOutput<DescribeEntityAggregatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEntityAggregatesOutputError>
}

extension DescribeEntityAggregatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEntityAggregatesInput(eventArns: \(String(describing: eventArns)))"}
}

extension DescribeEntityAggregatesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventArns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventArns = eventArns {
            var eventArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventArns)
            for eventarnslist0 in eventArns {
                try eventArnsContainer.encode(eventarnslist0)
            }
        }
    }
}

public struct DescribeEntityAggregatesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEntityAggregatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEntityAggregatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEntityAggregatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEntityAggregatesInput>
    public typealias MOutput = OperationOutput<DescribeEntityAggregatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEntityAggregatesOutputError>
}

public struct DescribeEntityAggregatesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEntityAggregatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEntityAggregatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEntityAggregatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEntityAggregatesInput>
    public typealias MOutput = OperationOutput<DescribeEntityAggregatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEntityAggregatesOutputError>
}

public struct DescribeEntityAggregatesInput: Equatable {
    /// <p>A list of event ARNs (unique identifiers). For example: <code>"arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"</code>
    ///          </p>
    public let eventArns: [String]?

    public init (
        eventArns: [String]? = nil
    )
    {
        self.eventArns = eventArns
    }
}

struct DescribeEntityAggregatesInputBody: Equatable {
    public let eventArns: [String]?
}

extension DescribeEntityAggregatesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventArns
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .eventArns)
        var eventArnsDecoded0:[String]? = nil
        if let eventArnsContainer = eventArnsContainer {
            eventArnsDecoded0 = [String]()
            for string0 in eventArnsContainer {
                if let string0 = string0 {
                    eventArnsDecoded0?.append(string0)
                }
            }
        }
        eventArns = eventArnsDecoded0
    }
}

extension DescribeEntityAggregatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEntityAggregatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEntityAggregatesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEntityAggregatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEntityAggregatesOutputResponse(entityAggregates: \(String(describing: entityAggregates)))"}
}

extension DescribeEntityAggregatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEntityAggregatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entityAggregates = output.entityAggregates
        } else {
            self.entityAggregates = nil
        }
    }
}

public struct DescribeEntityAggregatesOutputResponse: Equatable {
    /// <p>The number of entities that are affected by each of the specified events.</p>
    public let entityAggregates: [EntityAggregate]?

    public init (
        entityAggregates: [EntityAggregate]? = nil
    )
    {
        self.entityAggregates = entityAggregates
    }
}

struct DescribeEntityAggregatesOutputResponseBody: Equatable {
    public let entityAggregates: [EntityAggregate]?
}

extension DescribeEntityAggregatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entityAggregates
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityAggregatesContainer = try containerValues.decodeIfPresent([EntityAggregate?].self, forKey: .entityAggregates)
        var entityAggregatesDecoded0:[EntityAggregate]? = nil
        if let entityAggregatesContainer = entityAggregatesContainer {
            entityAggregatesDecoded0 = [EntityAggregate]()
            for structure0 in entityAggregatesContainer {
                if let structure0 = structure0 {
                    entityAggregatesDecoded0?.append(structure0)
                }
            }
        }
        entityAggregates = entityAggregatesDecoded0
    }
}

public struct DescribeEventAggregatesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventAggregatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventAggregatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventAggregatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventAggregatesInput>
    public typealias MOutput = OperationOutput<DescribeEventAggregatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventAggregatesOutputError>
}

extension DescribeEventAggregatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventAggregatesInput(aggregateField: \(String(describing: aggregateField)), filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeEventAggregatesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aggregateField
        case filter
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregateField = aggregateField {
            try encodeContainer.encode(aggregateField.rawValue, forKey: .aggregateField)
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeEventAggregatesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventAggregatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventAggregatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventAggregatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventAggregatesInput>
    public typealias MOutput = OperationOutput<DescribeEventAggregatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventAggregatesOutputError>
}

public struct DescribeEventAggregatesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventAggregatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventAggregatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventAggregatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventAggregatesInput>
    public typealias MOutput = OperationOutput<DescribeEventAggregatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventAggregatesOutputError>
}

public struct DescribeEventAggregatesInput: Equatable {
    /// <p>The only currently supported value is <code>eventTypeCategory</code>.</p>
    public let aggregateField: EventAggregateField?
    /// <p>Values to narrow the results returned.</p>
    public let filter: EventFilter?
    /// <p>The maximum number of items to return in one batch, between 10 and 100, inclusive.</p>
    public let maxResults: Int?
    /// <p>If the results of a search are large, only a portion of the
    /// results are returned, and a <code>nextToken</code> pagination token is returned in the response. To
    /// retrieve the next batch of results, reissue the search request and include the returned token.
    /// When all results have been returned, the response does not contain a pagination token value.</p>
    public let nextToken: String?

    public init (
        aggregateField: EventAggregateField? = nil,
        filter: EventFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.aggregateField = aggregateField
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeEventAggregatesInputBody: Equatable {
    public let filter: EventFilter?
    public let aggregateField: EventAggregateField?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeEventAggregatesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aggregateField
        case filter
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(EventFilter.self, forKey: .filter)
        filter = filterDecoded
        let aggregateFieldDecoded = try containerValues.decodeIfPresent(EventAggregateField.self, forKey: .aggregateField)
        aggregateField = aggregateFieldDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeEventAggregatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventAggregatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidPaginationToken" : self = .invalidPaginationToken(try InvalidPaginationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventAggregatesOutputError: Equatable {
    case invalidPaginationToken(InvalidPaginationToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventAggregatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventAggregatesOutputResponse(eventAggregates: \(String(describing: eventAggregates)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeEventAggregatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventAggregatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventAggregates = output.eventAggregates
            self.nextToken = output.nextToken
        } else {
            self.eventAggregates = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEventAggregatesOutputResponse: Equatable {
    /// <p>The number of events in each category that meet the optional filter criteria.</p>
    public let eventAggregates: [EventAggregate]?
    /// <p>If the results of a search are large, only a portion of the
    /// results are returned, and a <code>nextToken</code> pagination token is returned in the response. To
    /// retrieve the next batch of results, reissue the search request and include the returned token.
    /// When all results have been returned, the response does not contain a pagination token value.</p>
    public let nextToken: String?

    public init (
        eventAggregates: [EventAggregate]? = nil,
        nextToken: String? = nil
    )
    {
        self.eventAggregates = eventAggregates
        self.nextToken = nextToken
    }
}

struct DescribeEventAggregatesOutputResponseBody: Equatable {
    public let eventAggregates: [EventAggregate]?
    public let nextToken: String?
}

extension DescribeEventAggregatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventAggregates
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventAggregatesContainer = try containerValues.decodeIfPresent([EventAggregate?].self, forKey: .eventAggregates)
        var eventAggregatesDecoded0:[EventAggregate]? = nil
        if let eventAggregatesContainer = eventAggregatesContainer {
            eventAggregatesDecoded0 = [EventAggregate]()
            for structure0 in eventAggregatesContainer {
                if let structure0 = structure0 {
                    eventAggregatesDecoded0?.append(structure0)
                }
            }
        }
        eventAggregates = eventAggregatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeEventDetailsForOrganizationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventDetailsForOrganizationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventDetailsForOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventDetailsForOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventDetailsForOrganizationInput>
    public typealias MOutput = OperationOutput<DescribeEventDetailsForOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventDetailsForOrganizationOutputError>
}

extension DescribeEventDetailsForOrganizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventDetailsForOrganizationInput(locale: \(String(describing: locale)), organizationEventDetailFilters: \(String(describing: organizationEventDetailFilters)))"}
}

extension DescribeEventDetailsForOrganizationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case locale
        case organizationEventDetailFilters
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locale = locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let organizationEventDetailFilters = organizationEventDetailFilters {
            var organizationEventDetailFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationEventDetailFilters)
            for organizationeventdetailfilterslist0 in organizationEventDetailFilters {
                try organizationEventDetailFiltersContainer.encode(organizationeventdetailfilterslist0)
            }
        }
    }
}

public struct DescribeEventDetailsForOrganizationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventDetailsForOrganizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventDetailsForOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventDetailsForOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventDetailsForOrganizationInput>
    public typealias MOutput = OperationOutput<DescribeEventDetailsForOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventDetailsForOrganizationOutputError>
}

public struct DescribeEventDetailsForOrganizationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventDetailsForOrganizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventDetailsForOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventDetailsForOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventDetailsForOrganizationInput>
    public typealias MOutput = OperationOutput<DescribeEventDetailsForOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventDetailsForOrganizationOutputError>
}

public struct DescribeEventDetailsForOrganizationInput: Equatable {
    /// <p>The locale (language) to return information in. English (en) is the default and the only supported value at this time.</p>
    public let locale: String?
    /// <p>A set of JSON elements that includes the <code>awsAccountId</code> and the
    ///             <code>eventArn</code>.</p>
    public let organizationEventDetailFilters: [EventAccountFilter]?

    public init (
        locale: String? = nil,
        organizationEventDetailFilters: [EventAccountFilter]? = nil
    )
    {
        self.locale = locale
        self.organizationEventDetailFilters = organizationEventDetailFilters
    }
}

struct DescribeEventDetailsForOrganizationInputBody: Equatable {
    public let organizationEventDetailFilters: [EventAccountFilter]?
    public let locale: String?
}

extension DescribeEventDetailsForOrganizationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case locale
        case organizationEventDetailFilters
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationEventDetailFiltersContainer = try containerValues.decodeIfPresent([EventAccountFilter?].self, forKey: .organizationEventDetailFilters)
        var organizationEventDetailFiltersDecoded0:[EventAccountFilter]? = nil
        if let organizationEventDetailFiltersContainer = organizationEventDetailFiltersContainer {
            organizationEventDetailFiltersDecoded0 = [EventAccountFilter]()
            for structure0 in organizationEventDetailFiltersContainer {
                if let structure0 = structure0 {
                    organizationEventDetailFiltersDecoded0?.append(structure0)
                }
            }
        }
        organizationEventDetailFilters = organizationEventDetailFiltersDecoded0
        let localeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension DescribeEventDetailsForOrganizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventDetailsForOrganizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "UnsupportedLocale" : self = .unsupportedLocale(try UnsupportedLocale(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventDetailsForOrganizationOutputError: Equatable {
    case unsupportedLocale(UnsupportedLocale)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventDetailsForOrganizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventDetailsForOrganizationOutputResponse(failedSet: \(String(describing: failedSet)), successfulSet: \(String(describing: successfulSet)))"}
}

extension DescribeEventDetailsForOrganizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventDetailsForOrganizationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedSet = output.failedSet
            self.successfulSet = output.successfulSet
        } else {
            self.failedSet = nil
            self.successfulSet = nil
        }
    }
}

public struct DescribeEventDetailsForOrganizationOutputResponse: Equatable {
    /// <p>Error messages for any events that could not be retrieved.</p>
    public let failedSet: [OrganizationEventDetailsErrorItem]?
    /// <p>Information about the events that could be retrieved.</p>
    public let successfulSet: [OrganizationEventDetails]?

    public init (
        failedSet: [OrganizationEventDetailsErrorItem]? = nil,
        successfulSet: [OrganizationEventDetails]? = nil
    )
    {
        self.failedSet = failedSet
        self.successfulSet = successfulSet
    }
}

struct DescribeEventDetailsForOrganizationOutputResponseBody: Equatable {
    public let successfulSet: [OrganizationEventDetails]?
    public let failedSet: [OrganizationEventDetailsErrorItem]?
}

extension DescribeEventDetailsForOrganizationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedSet
        case successfulSet
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulSetContainer = try containerValues.decodeIfPresent([OrganizationEventDetails?].self, forKey: .successfulSet)
        var successfulSetDecoded0:[OrganizationEventDetails]? = nil
        if let successfulSetContainer = successfulSetContainer {
            successfulSetDecoded0 = [OrganizationEventDetails]()
            for structure0 in successfulSetContainer {
                if let structure0 = structure0 {
                    successfulSetDecoded0?.append(structure0)
                }
            }
        }
        successfulSet = successfulSetDecoded0
        let failedSetContainer = try containerValues.decodeIfPresent([OrganizationEventDetailsErrorItem?].self, forKey: .failedSet)
        var failedSetDecoded0:[OrganizationEventDetailsErrorItem]? = nil
        if let failedSetContainer = failedSetContainer {
            failedSetDecoded0 = [OrganizationEventDetailsErrorItem]()
            for structure0 in failedSetContainer {
                if let structure0 = structure0 {
                    failedSetDecoded0?.append(structure0)
                }
            }
        }
        failedSet = failedSetDecoded0
    }
}

public struct DescribeEventDetailsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventDetailsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventDetailsInput>
    public typealias MOutput = OperationOutput<DescribeEventDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventDetailsOutputError>
}

extension DescribeEventDetailsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventDetailsInput(eventArns: \(String(describing: eventArns)), locale: \(String(describing: locale)))"}
}

extension DescribeEventDetailsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventArns
        case locale
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventArns = eventArns {
            var eventArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventArns)
            for eventarnlist0 in eventArns {
                try eventArnsContainer.encode(eventarnlist0)
            }
        }
        if let locale = locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
    }
}

public struct DescribeEventDetailsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventDetailsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventDetailsInput>
    public typealias MOutput = OperationOutput<DescribeEventDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventDetailsOutputError>
}

public struct DescribeEventDetailsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventDetailsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventDetailsInput>
    public typealias MOutput = OperationOutput<DescribeEventDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventDetailsOutputError>
}

public struct DescribeEventDetailsInput: Equatable {
    /// <p>A list of event ARNs (unique identifiers). For example: <code>"arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"</code>
    ///          </p>
    public let eventArns: [String]?
    /// <p>The locale (language) to return information in. English (en) is the default and the only supported value at this time.</p>
    public let locale: String?

    public init (
        eventArns: [String]? = nil,
        locale: String? = nil
    )
    {
        self.eventArns = eventArns
        self.locale = locale
    }
}

struct DescribeEventDetailsInputBody: Equatable {
    public let eventArns: [String]?
    public let locale: String?
}

extension DescribeEventDetailsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventArns
        case locale
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .eventArns)
        var eventArnsDecoded0:[String]? = nil
        if let eventArnsContainer = eventArnsContainer {
            eventArnsDecoded0 = [String]()
            for string0 in eventArnsContainer {
                if let string0 = string0 {
                    eventArnsDecoded0?.append(string0)
                }
            }
        }
        eventArns = eventArnsDecoded0
        let localeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension DescribeEventDetailsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventDetailsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "UnsupportedLocale" : self = .unsupportedLocale(try UnsupportedLocale(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventDetailsOutputError: Equatable {
    case unsupportedLocale(UnsupportedLocale)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventDetailsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventDetailsOutputResponse(failedSet: \(String(describing: failedSet)), successfulSet: \(String(describing: successfulSet)))"}
}

extension DescribeEventDetailsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventDetailsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedSet = output.failedSet
            self.successfulSet = output.successfulSet
        } else {
            self.failedSet = nil
            self.successfulSet = nil
        }
    }
}

public struct DescribeEventDetailsOutputResponse: Equatable {
    /// <p>Error messages for any events that could not be retrieved.</p>
    public let failedSet: [EventDetailsErrorItem]?
    /// <p>Information about the events that could be retrieved.</p>
    public let successfulSet: [EventDetails]?

    public init (
        failedSet: [EventDetailsErrorItem]? = nil,
        successfulSet: [EventDetails]? = nil
    )
    {
        self.failedSet = failedSet
        self.successfulSet = successfulSet
    }
}

struct DescribeEventDetailsOutputResponseBody: Equatable {
    public let successfulSet: [EventDetails]?
    public let failedSet: [EventDetailsErrorItem]?
}

extension DescribeEventDetailsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedSet
        case successfulSet
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulSetContainer = try containerValues.decodeIfPresent([EventDetails?].self, forKey: .successfulSet)
        var successfulSetDecoded0:[EventDetails]? = nil
        if let successfulSetContainer = successfulSetContainer {
            successfulSetDecoded0 = [EventDetails]()
            for structure0 in successfulSetContainer {
                if let structure0 = structure0 {
                    successfulSetDecoded0?.append(structure0)
                }
            }
        }
        successfulSet = successfulSetDecoded0
        let failedSetContainer = try containerValues.decodeIfPresent([EventDetailsErrorItem?].self, forKey: .failedSet)
        var failedSetDecoded0:[EventDetailsErrorItem]? = nil
        if let failedSetContainer = failedSetContainer {
            failedSetDecoded0 = [EventDetailsErrorItem]()
            for structure0 in failedSetContainer {
                if let structure0 = structure0 {
                    failedSetDecoded0?.append(structure0)
                }
            }
        }
        failedSet = failedSetDecoded0
    }
}

public struct DescribeEventTypesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventTypesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventTypesInput>
    public typealias MOutput = OperationOutput<DescribeEventTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventTypesOutputError>
}

extension DescribeEventTypesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventTypesInput(filter: \(String(describing: filter)), locale: \(String(describing: locale)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeEventTypesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter
        case locale
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let locale = locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeEventTypesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventTypesInput>
    public typealias MOutput = OperationOutput<DescribeEventTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventTypesOutputError>
}

public struct DescribeEventTypesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventTypesInput>
    public typealias MOutput = OperationOutput<DescribeEventTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventTypesOutputError>
}

public struct DescribeEventTypesInput: Equatable {
    /// <p>Values to narrow the results returned.</p>
    public let filter: EventTypeFilter?
    /// <p>The locale (language) to return information in. English (en) is the default and the only supported value at this time.</p>
    public let locale: String?
    /// <p>The maximum number of items to return in one batch, between 10 and 100, inclusive.</p>
    public let maxResults: Int?
    /// <p>If the results of a search are large, only a portion of the
    /// results are returned, and a <code>nextToken</code> pagination token is returned in the response. To
    /// retrieve the next batch of results, reissue the search request and include the returned token.
    /// When all results have been returned, the response does not contain a pagination token value.</p>
    public let nextToken: String?

    public init (
        filter: EventTypeFilter? = nil,
        locale: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filter = filter
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeEventTypesInputBody: Equatable {
    public let filter: EventTypeFilter?
    public let locale: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeEventTypesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter
        case locale
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(EventTypeFilter.self, forKey: .filter)
        filter = filterDecoded
        let localeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locale)
        locale = localeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeEventTypesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventTypesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidPaginationToken" : self = .invalidPaginationToken(try InvalidPaginationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLocale" : self = .unsupportedLocale(try UnsupportedLocale(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventTypesOutputError: Equatable {
    case invalidPaginationToken(InvalidPaginationToken)
    case unsupportedLocale(UnsupportedLocale)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventTypesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventTypesOutputResponse(eventTypes: \(String(describing: eventTypes)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeEventTypesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventTypesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventTypes = output.eventTypes
            self.nextToken = output.nextToken
        } else {
            self.eventTypes = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEventTypesOutputResponse: Equatable {
    /// <p>A list of event types that match the filter criteria. Event types have a category
    ///             (<code>issue</code>, <code>accountNotification</code>, or <code>scheduledChange</code>),
    ///          a service (for example, <code>EC2</code>, <code>RDS</code>, <code>DATAPIPELINE</code>,
    ///             <code>BILLING</code>), and a code (in the format
    ///                <code>AWS_<i>SERVICE</i>_<i>DESCRIPTION</i>
    ///             </code>; for
    ///          example, <code>AWS_EC2_SYSTEM_MAINTENANCE_EVENT</code>).</p>
    public let eventTypes: [EventType]?
    /// <p>If the results of a search are large, only a portion of the
    /// results are returned, and a <code>nextToken</code> pagination token is returned in the response. To
    /// retrieve the next batch of results, reissue the search request and include the returned token.
    /// When all results have been returned, the response does not contain a pagination token value.</p>
    public let nextToken: String?

    public init (
        eventTypes: [EventType]? = nil,
        nextToken: String? = nil
    )
    {
        self.eventTypes = eventTypes
        self.nextToken = nextToken
    }
}

struct DescribeEventTypesOutputResponseBody: Equatable {
    public let eventTypes: [EventType]?
    public let nextToken: String?
}

extension DescribeEventTypesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventTypes
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypesContainer = try containerValues.decodeIfPresent([EventType?].self, forKey: .eventTypes)
        var eventTypesDecoded0:[EventType]? = nil
        if let eventTypesContainer = eventTypesContainer {
            eventTypesDecoded0 = [EventType]()
            for structure0 in eventTypesContainer {
                if let structure0 = structure0 {
                    eventTypesDecoded0?.append(structure0)
                }
            }
        }
        eventTypes = eventTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeEventsForOrganizationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventsForOrganizationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsForOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsForOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsForOrganizationInput>
    public typealias MOutput = OperationOutput<DescribeEventsForOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsForOrganizationOutputError>
}

extension DescribeEventsForOrganizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventsForOrganizationInput(filter: \(String(describing: filter)), locale: \(String(describing: locale)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeEventsForOrganizationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter
        case locale
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let locale = locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeEventsForOrganizationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventsForOrganizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsForOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsForOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsForOrganizationInput>
    public typealias MOutput = OperationOutput<DescribeEventsForOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsForOrganizationOutputError>
}

public struct DescribeEventsForOrganizationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventsForOrganizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsForOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsForOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsForOrganizationInput>
    public typealias MOutput = OperationOutput<DescribeEventsForOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsForOrganizationOutputError>
}

public struct DescribeEventsForOrganizationInput: Equatable {
    /// <p>Values to narrow the results returned.</p>
    public let filter: OrganizationEventFilter?
    /// <p>The locale (language) to return information in. English (en) is the default and the only supported value at this time.</p>
    public let locale: String?
    /// <p>The maximum number of items to return in one batch, between 10 and 100, inclusive.</p>
    public let maxResults: Int?
    /// <p>If the results of a search are large, only a portion of the
    /// results are returned, and a <code>nextToken</code> pagination token is returned in the response. To
    /// retrieve the next batch of results, reissue the search request and include the returned token.
    /// When all results have been returned, the response does not contain a pagination token value.</p>
    public let nextToken: String?

    public init (
        filter: OrganizationEventFilter? = nil,
        locale: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filter = filter
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeEventsForOrganizationInputBody: Equatable {
    public let filter: OrganizationEventFilter?
    public let nextToken: String?
    public let maxResults: Int?
    public let locale: String?
}

extension DescribeEventsForOrganizationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter
        case locale
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(OrganizationEventFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let localeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension DescribeEventsForOrganizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventsForOrganizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidPaginationToken" : self = .invalidPaginationToken(try InvalidPaginationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLocale" : self = .unsupportedLocale(try UnsupportedLocale(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventsForOrganizationOutputError: Equatable {
    case invalidPaginationToken(InvalidPaginationToken)
    case unsupportedLocale(UnsupportedLocale)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventsForOrganizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventsForOrganizationOutputResponse(events: \(String(describing: events)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeEventsForOrganizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventsForOrganizationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEventsForOrganizationOutputResponse: Equatable {
    /// <p>The events that match the specified filter criteria.</p>
    public let events: [OrganizationEvent]?
    /// <p>If the results of a search are large, only a portion of the
    /// results are returned, and a <code>nextToken</code> pagination token is returned in the response. To
    /// retrieve the next batch of results, reissue the search request and include the returned token.
    /// When all results have been returned, the response does not contain a pagination token value.</p>
    public let nextToken: String?

    public init (
        events: [OrganizationEvent]? = nil,
        nextToken: String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct DescribeEventsForOrganizationOutputResponseBody: Equatable {
    public let events: [OrganizationEvent]?
    public let nextToken: String?
}

extension DescribeEventsForOrganizationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case events
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([OrganizationEvent?].self, forKey: .events)
        var eventsDecoded0:[OrganizationEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [OrganizationEvent]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeEventsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsOutputError>
}

extension DescribeEventsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventsInput(filter: \(String(describing: filter)), locale: \(String(describing: locale)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeEventsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter
        case locale
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let locale = locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeEventsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInput: Equatable {
    /// <p>Values to narrow the results returned.</p>
    public let filter: EventFilter?
    /// <p>The locale (language) to return information in. English (en) is the default and the only supported value at this time.</p>
    public let locale: String?
    /// <p>The maximum number of items to return in one batch, between 10 and 100, inclusive.</p>
    public let maxResults: Int?
    /// <p>If the results of a search are large, only a portion of the
    /// results are returned, and a <code>nextToken</code> pagination token is returned in the response. To
    /// retrieve the next batch of results, reissue the search request and include the returned token.
    /// When all results have been returned, the response does not contain a pagination token value.</p>
    public let nextToken: String?

    public init (
        filter: EventFilter? = nil,
        locale: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filter = filter
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeEventsInputBody: Equatable {
    public let filter: EventFilter?
    public let nextToken: String?
    public let maxResults: Int?
    public let locale: String?
}

extension DescribeEventsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter
        case locale
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(EventFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let localeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension DescribeEventsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidPaginationToken" : self = .invalidPaginationToken(try InvalidPaginationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLocale" : self = .unsupportedLocale(try UnsupportedLocale(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventsOutputError: Equatable {
    case invalidPaginationToken(InvalidPaginationToken)
    case unsupportedLocale(UnsupportedLocale)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventsOutputResponse(events: \(String(describing: events)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeEventsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEventsOutputResponse: Equatable {
    /// <p>The events that match the specified filter criteria.</p>
    public let events: [Event]?
    /// <p>If the results of a search are large, only a portion of the
    /// results are returned, and a <code>nextToken</code> pagination token is returned in the response. To
    /// retrieve the next batch of results, reissue the search request and include the returned token.
    /// When all results have been returned, the response does not contain a pagination token value.</p>
    public let nextToken: String?

    public init (
        events: [Event]? = nil,
        nextToken: String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct DescribeEventsOutputResponseBody: Equatable {
    public let events: [Event]?
    public let nextToken: String?
}

extension DescribeEventsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case events
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([Event?].self, forKey: .events)
        var eventsDecoded0:[Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeHealthServiceStatusForOrganizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeHealthServiceStatusForOrganizationInput()"}
}

extension DescribeHealthServiceStatusForOrganizationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeHealthServiceStatusForOrganizationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeHealthServiceStatusForOrganizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHealthServiceStatusForOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHealthServiceStatusForOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHealthServiceStatusForOrganizationInput>
    public typealias MOutput = OperationOutput<DescribeHealthServiceStatusForOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHealthServiceStatusForOrganizationOutputError>
}

public struct DescribeHealthServiceStatusForOrganizationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeHealthServiceStatusForOrganizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeHealthServiceStatusForOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeHealthServiceStatusForOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeHealthServiceStatusForOrganizationInput>
    public typealias MOutput = OperationOutput<DescribeHealthServiceStatusForOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeHealthServiceStatusForOrganizationOutputError>
}

public struct DescribeHealthServiceStatusForOrganizationInput: Equatable {

    public init() {}
}

struct DescribeHealthServiceStatusForOrganizationInputBody: Equatable {
}

extension DescribeHealthServiceStatusForOrganizationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeHealthServiceStatusForOrganizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeHealthServiceStatusForOrganizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeHealthServiceStatusForOrganizationOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHealthServiceStatusForOrganizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeHealthServiceStatusForOrganizationOutputResponse(healthServiceAccessStatusForOrganization: \(String(describing: healthServiceAccessStatusForOrganization)))"}
}

extension DescribeHealthServiceStatusForOrganizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeHealthServiceStatusForOrganizationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.healthServiceAccessStatusForOrganization = output.healthServiceAccessStatusForOrganization
        } else {
            self.healthServiceAccessStatusForOrganization = nil
        }
    }
}

public struct DescribeHealthServiceStatusForOrganizationOutputResponse: Equatable {
    /// <p>Information about the status of enabling or disabling AWS Health Organizational View in
    ///          your organization.</p>
    ///          <p>Valid values are <code>ENABLED | DISABLED | PENDING</code>. </p>
    public let healthServiceAccessStatusForOrganization: String?

    public init (
        healthServiceAccessStatusForOrganization: String? = nil
    )
    {
        self.healthServiceAccessStatusForOrganization = healthServiceAccessStatusForOrganization
    }
}

struct DescribeHealthServiceStatusForOrganizationOutputResponseBody: Equatable {
    public let healthServiceAccessStatusForOrganization: String?
}

extension DescribeHealthServiceStatusForOrganizationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case healthServiceAccessStatusForOrganization
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let healthServiceAccessStatusForOrganizationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .healthServiceAccessStatusForOrganization)
        healthServiceAccessStatusForOrganization = healthServiceAccessStatusForOrganizationDecoded
    }
}

extension DisableHealthServiceAccessForOrganizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableHealthServiceAccessForOrganizationInput()"}
}

extension DisableHealthServiceAccessForOrganizationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisableHealthServiceAccessForOrganizationInputHeadersMiddleware: Middleware {
    public let id: String = "DisableHealthServiceAccessForOrganizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableHealthServiceAccessForOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableHealthServiceAccessForOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableHealthServiceAccessForOrganizationInput>
    public typealias MOutput = OperationOutput<DisableHealthServiceAccessForOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableHealthServiceAccessForOrganizationOutputError>
}

public struct DisableHealthServiceAccessForOrganizationInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableHealthServiceAccessForOrganizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableHealthServiceAccessForOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableHealthServiceAccessForOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableHealthServiceAccessForOrganizationInput>
    public typealias MOutput = OperationOutput<DisableHealthServiceAccessForOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableHealthServiceAccessForOrganizationOutputError>
}

public struct DisableHealthServiceAccessForOrganizationInput: Equatable {

    public init() {}
}

struct DisableHealthServiceAccessForOrganizationInputBody: Equatable {
}

extension DisableHealthServiceAccessForOrganizationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisableHealthServiceAccessForOrganizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableHealthServiceAccessForOrganizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableHealthServiceAccessForOrganizationOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableHealthServiceAccessForOrganizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableHealthServiceAccessForOrganizationOutputResponse()"}
}

extension DisableHealthServiceAccessForOrganizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisableHealthServiceAccessForOrganizationOutputResponse: Equatable {

    public init() {}
}

struct DisableHealthServiceAccessForOrganizationOutputResponseBody: Equatable {
}

extension DisableHealthServiceAccessForOrganizationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension EnableHealthServiceAccessForOrganizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableHealthServiceAccessForOrganizationInput()"}
}

extension EnableHealthServiceAccessForOrganizationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct EnableHealthServiceAccessForOrganizationInputHeadersMiddleware: Middleware {
    public let id: String = "EnableHealthServiceAccessForOrganizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableHealthServiceAccessForOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableHealthServiceAccessForOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableHealthServiceAccessForOrganizationInput>
    public typealias MOutput = OperationOutput<EnableHealthServiceAccessForOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableHealthServiceAccessForOrganizationOutputError>
}

public struct EnableHealthServiceAccessForOrganizationInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableHealthServiceAccessForOrganizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableHealthServiceAccessForOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableHealthServiceAccessForOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableHealthServiceAccessForOrganizationInput>
    public typealias MOutput = OperationOutput<EnableHealthServiceAccessForOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableHealthServiceAccessForOrganizationOutputError>
}

public struct EnableHealthServiceAccessForOrganizationInput: Equatable {

    public init() {}
}

struct EnableHealthServiceAccessForOrganizationInputBody: Equatable {
}

extension EnableHealthServiceAccessForOrganizationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension EnableHealthServiceAccessForOrganizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableHealthServiceAccessForOrganizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableHealthServiceAccessForOrganizationOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableHealthServiceAccessForOrganizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableHealthServiceAccessForOrganizationOutputResponse()"}
}

extension EnableHealthServiceAccessForOrganizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct EnableHealthServiceAccessForOrganizationOutputResponse: Equatable {

    public init() {}
}

struct EnableHealthServiceAccessForOrganizationOutputResponseBody: Equatable {
}

extension EnableHealthServiceAccessForOrganizationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension EntityAggregate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case count
        case eventArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let eventArn = eventArn {
            try encodeContainer.encode(eventArn, forKey: .eventArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventArn)
        eventArn = eventArnDecoded
        let countDecoded = try containerValues.decode(Int.self, forKey: .count)
        count = countDecoded
    }
}

extension EntityAggregate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityAggregate(count: \(String(describing: count)), eventArn: \(String(describing: eventArn)))"}
}

/// <p>The number of entities that are affected by one or more events. Returned by the <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEntityAggregates.html">DescribeEntityAggregates</a> operation.</p>
public struct EntityAggregate: Equatable {
    /// <p>The number of entities that match the criteria for the specified events.</p>
    public let count: Int
    /// <p>The unique identifier for the event. The event ARN has the
    /// <code>arn:aws:health:<i>event-region</i>::event/<i>SERVICE</i>/<i>EVENT_TYPE_CODE</i>/<i>EVENT_TYPE_PLUS_ID</i>
    ///             </code>
    /// format.</p>
    ///          <p>For example, an event ARN might look like the following:</p>
    ///          <p>
    ///             <code>arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456</code>
    ///          </p>
    public let eventArn: String?

    public init (
        count: Int = 0,
        eventArn: String? = nil
    )
    {
        self.count = count
        self.eventArn = eventArn
    }
}

extension EntityFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entityArns
        case entityValues
        case eventArns
        case lastUpdatedTimes
        case statusCodes
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityArns = entityArns {
            var entityArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityArns)
            for entityarnlist0 in entityArns {
                try entityArnsContainer.encode(entityarnlist0)
            }
        }
        if let entityValues = entityValues {
            var entityValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityValues)
            for entityvaluelist0 in entityValues {
                try entityValuesContainer.encode(entityvaluelist0)
            }
        }
        if let eventArns = eventArns {
            var eventArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventArns)
            for eventarnlist0 in eventArns {
                try eventArnsContainer.encode(eventarnlist0)
            }
        }
        if let lastUpdatedTimes = lastUpdatedTimes {
            var lastUpdatedTimesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lastUpdatedTimes)
            for datetimerangelist0 in lastUpdatedTimes {
                try lastUpdatedTimesContainer.encode(datetimerangelist0)
            }
        }
        if let statusCodes = statusCodes {
            var statusCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statusCodes)
            for entitystatuscodelist0 in statusCodes {
                try statusCodesContainer.encode(entitystatuscodelist0.rawValue)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagfilter0 in tags {
                var tagfilter0Container = tagsContainer.nestedContainer(keyedBy: Key.self)
                for (dictKey1, tagset1) in tagfilter0 {
                    try tagfilter0Container.encode(tagset1, forKey: Key(stringValue: dictKey1))
                }
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .eventArns)
        var eventArnsDecoded0:[String]? = nil
        if let eventArnsContainer = eventArnsContainer {
            eventArnsDecoded0 = [String]()
            for string0 in eventArnsContainer {
                if let string0 = string0 {
                    eventArnsDecoded0?.append(string0)
                }
            }
        }
        eventArns = eventArnsDecoded0
        let entityArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .entityArns)
        var entityArnsDecoded0:[String]? = nil
        if let entityArnsContainer = entityArnsContainer {
            entityArnsDecoded0 = [String]()
            for string0 in entityArnsContainer {
                if let string0 = string0 {
                    entityArnsDecoded0?.append(string0)
                }
            }
        }
        entityArns = entityArnsDecoded0
        let entityValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .entityValues)
        var entityValuesDecoded0:[String]? = nil
        if let entityValuesContainer = entityValuesContainer {
            entityValuesDecoded0 = [String]()
            for string0 in entityValuesContainer {
                if let string0 = string0 {
                    entityValuesDecoded0?.append(string0)
                }
            }
        }
        entityValues = entityValuesDecoded0
        let lastUpdatedTimesContainer = try containerValues.decodeIfPresent([DateTimeRange?].self, forKey: .lastUpdatedTimes)
        var lastUpdatedTimesDecoded0:[DateTimeRange]? = nil
        if let lastUpdatedTimesContainer = lastUpdatedTimesContainer {
            lastUpdatedTimesDecoded0 = [DateTimeRange]()
            for structure0 in lastUpdatedTimesContainer {
                if let structure0 = structure0 {
                    lastUpdatedTimesDecoded0?.append(structure0)
                }
            }
        }
        lastUpdatedTimes = lastUpdatedTimesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([[String: String?]?].self, forKey: .tags)
        var tagsDecoded0:[[String:String]]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [[String:String]]()
            for map0 in tagsContainer {
                var tagsContainerDecoded0: [String: String]? = nil
                if let map0 = map0 {
                    tagsContainerDecoded0 = [String: String]()
                    for (key1, tagvalue1) in map0 {
                        if let tagvalue1 = tagvalue1 {
                            tagsContainerDecoded0?[key1] = tagvalue1
                        }
                    }
                }
                if let tagsContainerDecoded0 = tagsContainerDecoded0 {
                    tagsDecoded0?.append(tagsContainerDecoded0)
                }
            }
        }
        tags = tagsDecoded0
        let statusCodesContainer = try containerValues.decodeIfPresent([EntityStatusCode?].self, forKey: .statusCodes)
        var statusCodesDecoded0:[EntityStatusCode]? = nil
        if let statusCodesContainer = statusCodesContainer {
            statusCodesDecoded0 = [EntityStatusCode]()
            for string0 in statusCodesContainer {
                if let string0 = string0 {
                    statusCodesDecoded0?.append(string0)
                }
            }
        }
        statusCodes = statusCodesDecoded0
    }
}

extension EntityFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityFilter(entityArns: \(String(describing: entityArns)), entityValues: \(String(describing: entityValues)), eventArns: \(String(describing: eventArns)), lastUpdatedTimes: \(String(describing: lastUpdatedTimes)), statusCodes: \(String(describing: statusCodes)), tags: \(String(describing: tags)))"}
}

/// <p>The values to use to filter results from the <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_EntityFilter.html">EntityFilter</a>
///          operation.</p>
public struct EntityFilter: Equatable {
    /// <p>A list of entity ARNs (unique identifiers).</p>
    public let entityArns: [String]?
    /// <p>A list of IDs for affected entities.</p>
    public let entityValues: [String]?
    /// <p>A list of event ARNs (unique identifiers). For example: <code>"arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"</code>
    ///          </p>
    public let eventArns: [String]?
    /// <p>A list of the most recent dates and times that the entity was updated.</p>
    public let lastUpdatedTimes: [DateTimeRange]?
    /// <p>A list of entity status codes (<code>IMPAIRED</code>, <code>UNIMPAIRED</code>, or
    ///             <code>UNKNOWN</code>).</p>
    public let statusCodes: [EntityStatusCode]?
    /// <p>A map of entity tags attached to the affected entity.</p>
    ///          <note>
    ///             <p>Currently, the <code>tags</code> property isn't supported.</p>
    ///          </note>
    public let tags: [[String:String]]?

    public init (
        entityArns: [String]? = nil,
        entityValues: [String]? = nil,
        eventArns: [String]? = nil,
        lastUpdatedTimes: [DateTimeRange]? = nil,
        statusCodes: [EntityStatusCode]? = nil,
        tags: [[String:String]]? = nil
    )
    {
        self.entityArns = entityArns
        self.entityValues = entityValues
        self.eventArns = eventArns
        self.lastUpdatedTimes = lastUpdatedTimes
        self.statusCodes = statusCodes
        self.tags = tags
    }
}

public enum EntityStatusCode {
    case impaired
    case unimpaired
    case unknown
    case sdkUnknown(String)
}

extension EntityStatusCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EntityStatusCode] {
        return [
            .impaired,
            .unimpaired,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .impaired: return "IMPAIRED"
        case .unimpaired: return "UNIMPAIRED"
        case .unknown: return "UNKNOWN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EntityStatusCode(rawValue: rawValue) ?? EntityStatusCode.sdkUnknown(rawValue)
    }
}

extension Event: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case availabilityZone
        case endTime
        case eventScopeCode
        case eventTypeCategory
        case eventTypeCode
        case lastUpdatedTime
        case region
        case service
        case startTime
        case statusCode
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let eventScopeCode = eventScopeCode {
            try encodeContainer.encode(eventScopeCode.rawValue, forKey: .eventScopeCode)
        }
        if let eventTypeCategory = eventTypeCategory {
            try encodeContainer.encode(eventTypeCategory.rawValue, forKey: .eventTypeCategory)
        }
        if let eventTypeCode = eventTypeCode {
            try encodeContainer.encode(eventTypeCode, forKey: .eventTypeCode)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let service = service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .service)
        service = serviceDecoded
        let eventTypeCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventTypeCode)
        eventTypeCode = eventTypeCodeDecoded
        let eventTypeCategoryDecoded = try containerValues.decodeIfPresent(EventTypeCategory.self, forKey: .eventTypeCategory)
        eventTypeCategory = eventTypeCategoryDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(EventStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let eventScopeCodeDecoded = try containerValues.decodeIfPresent(EventScopeCode.self, forKey: .eventScopeCode)
        eventScopeCode = eventScopeCodeDecoded
    }
}

extension Event: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Event(arn: \(String(describing: arn)), availabilityZone: \(String(describing: availabilityZone)), endTime: \(String(describing: endTime)), eventScopeCode: \(String(describing: eventScopeCode)), eventTypeCategory: \(String(describing: eventTypeCategory)), eventTypeCode: \(String(describing: eventTypeCode)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), region: \(String(describing: region)), service: \(String(describing: service)), startTime: \(String(describing: startTime)), statusCode: \(String(describing: statusCode)))"}
}

/// <p>Summary information about an AWS Health event.</p>
///          <p>AWS Health events can be public or account-specific:</p>
///          <ul>
///             <li>
///                <p>
///                   <i>Public events</i> might be service events that are not specific
///                to an AWS account. For example, if there is an issue with an AWS Region,
///                AWS Health provides information about the event, even if you don't use services or
///                resources in that Region.</p>
///             </li>
///             <li>
///                <p>
///                   <i>Account-specific</i> events are specific to either your AWS
///                account or an account in your organization. For example, if there's an issue with
///                Amazon Elastic Compute Cloud in a Region that you use, AWS Health provides information about the event
///                and the affected resources in the account.</p>
///             </li>
///          </ul>
///          <p>You can determine if an event is public or account-specific by using the
///             <code>eventScopeCode</code> parameter. For more information, see <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_Event.html#AWSHealth-Type-Event-eventScopeCode">eventScopeCode</a>.</p>
public struct Event: Equatable {
    /// <p>The unique identifier for the event. The event ARN has the
    /// <code>arn:aws:health:<i>event-region</i>::event/<i>SERVICE</i>/<i>EVENT_TYPE_CODE</i>/<i>EVENT_TYPE_PLUS_ID</i>
    ///             </code>
    /// format.</p>
    ///          <p>For example, an event ARN might look like the following:</p>
    ///          <p>
    ///             <code>arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456</code>
    ///          </p>
    public let arn: String?
    /// <p>The AWS Availability Zone of the event. For example, us-east-1a.</p>
    public let availabilityZone: String?
    /// <p>The date and time that the event ended.</p>
    public let endTime: Date?
    /// <p>This parameter specifies if the AWS Health event is a public AWS service event or an account-specific event.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If the <code>eventScopeCode</code> value is <code>PUBLIC</code>, then the
    ///                   <code>affectedAccounts</code> value is always empty.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the <code>eventScopeCode</code> value is <code>ACCOUNT_SPECIFIC</code>, then
    ///                the <code>affectedAccounts</code> value lists the affected AWS accounts in your
    ///                organization. For example, if an event affects a service such as Amazon Elastic Compute Cloud and you
    ///                have AWS accounts that use that service, those account IDs appear in the
    ///                response.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the <code>eventScopeCode</code> value is <code>NONE</code>, then the
    ///                   <code>eventArn</code> that you specified in the request is invalid or doesn't
    ///                exist.</p>
    ///             </li>
    ///          </ul>
    public let eventScopeCode: EventScopeCode?
    /// <p>The category of the event. Possible values are <code>issue</code>,
    ///             <code>scheduledChange</code>, and <code>accountNotification</code>.</p>
    public let eventTypeCategory: EventTypeCategory?
    /// <p>The unique identifier for the event type. The format is <code>AWS_<i>SERVICE</i>_<i>DESCRIPTION</i>
    ///             </code>; for example, <code>AWS_EC2_SYSTEM_MAINTENANCE_EVENT</code>.</p>
    public let eventTypeCode: String?
    /// <p>The most recent date and time that the event was updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>The AWS Region name of the event.</p>
    public let region: String?
    /// <p>The AWS service that is affected by the event. For example, <code>EC2</code>, <code>RDS</code>.</p>
    public let service: String?
    /// <p>The date and time that the event began.</p>
    public let startTime: Date?
    /// <p>The most recent status of the event. Possible values are <code>open</code>,
    ///             <code>closed</code>, and <code>upcoming</code>.</p>
    public let statusCode: EventStatusCode?

    public init (
        arn: String? = nil,
        availabilityZone: String? = nil,
        endTime: Date? = nil,
        eventScopeCode: EventScopeCode? = nil,
        eventTypeCategory: EventTypeCategory? = nil,
        eventTypeCode: String? = nil,
        lastUpdatedTime: Date? = nil,
        region: String? = nil,
        service: String? = nil,
        startTime: Date? = nil,
        statusCode: EventStatusCode? = nil
    )
    {
        self.arn = arn
        self.availabilityZone = availabilityZone
        self.endTime = endTime
        self.eventScopeCode = eventScopeCode
        self.eventTypeCategory = eventTypeCategory
        self.eventTypeCode = eventTypeCode
        self.lastUpdatedTime = lastUpdatedTime
        self.region = region
        self.service = service
        self.startTime = startTime
        self.statusCode = statusCode
    }
}

extension EventAccountFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsAccountId
        case eventArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let eventArn = eventArn {
            try encodeContainer.encode(eventArn, forKey: .eventArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventArn)
        eventArn = eventArnDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
    }
}

extension EventAccountFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventAccountFilter(awsAccountId: \(String(describing: awsAccountId)), eventArn: \(String(describing: eventArn)))"}
}

/// <p>The values used to filter results from the <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetailsForOrganization.html">DescribeEventDetailsForOrganization</a> and <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeAffectedEntitiesForOrganization.html">DescribeAffectedEntitiesForOrganization</a> operations.</p>
public struct EventAccountFilter: Equatable {
    /// <p>The 12-digit AWS account numbers that contains the affected entities.</p>
    public let awsAccountId: String?
    /// <p>The unique identifier for the event. The event ARN has the
    /// <code>arn:aws:health:<i>event-region</i>::event/<i>SERVICE</i>/<i>EVENT_TYPE_CODE</i>/<i>EVENT_TYPE_PLUS_ID</i>
    ///             </code>
    /// format.</p>
    ///          <p>For example, an event ARN might look like the following:</p>
    ///          <p>
    ///             <code>arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456</code>
    ///          </p>
    public let eventArn: String?

    public init (
        awsAccountId: String? = nil,
        eventArn: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.eventArn = eventArn
    }
}

extension EventAggregate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aggregateValue
        case count
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregateValue = aggregateValue {
            try encodeContainer.encode(aggregateValue, forKey: .aggregateValue)
        }
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregateValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aggregateValue)
        aggregateValue = aggregateValueDecoded
        let countDecoded = try containerValues.decode(Int.self, forKey: .count)
        count = countDecoded
    }
}

extension EventAggregate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventAggregate(aggregateValue: \(String(describing: aggregateValue)), count: \(String(describing: count)))"}
}

/// <p>The number of events of each issue type. Returned by the <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventAggregates.html">DescribeEventAggregates</a> operation.</p>
public struct EventAggregate: Equatable {
    /// <p>The issue type for the associated count.</p>
    public let aggregateValue: String?
    /// <p>The number of events of the associated issue type.</p>
    public let count: Int

    public init (
        aggregateValue: String? = nil,
        count: Int = 0
    )
    {
        self.aggregateValue = aggregateValue
        self.count = count
    }
}

public enum EventAggregateField {
    case eventtypecategory
    case sdkUnknown(String)
}

extension EventAggregateField : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventAggregateField] {
        return [
            .eventtypecategory,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .eventtypecategory: return "eventTypeCategory"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventAggregateField(rawValue: rawValue) ?? EventAggregateField.sdkUnknown(rawValue)
    }
}

extension EventDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case latestDescription
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let latestDescription = latestDescription {
            try encodeContainer.encode(latestDescription, forKey: .latestDescription)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latestDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestDescription)
        latestDescription = latestDescriptionDecoded
    }
}

extension EventDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventDescription(latestDescription: \(String(describing: latestDescription)))"}
}

/// <p>The detailed description of the event. Included in the information returned by the
///             <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetails.html">DescribeEventDetails</a> operation.</p>
public struct EventDescription: Equatable {
    /// <p>The most recent description of the event.</p>
    public let latestDescription: String?

    public init (
        latestDescription: String? = nil
    )
    {
        self.latestDescription = latestDescription
    }
}

extension EventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case event
        case eventDescription
        case eventMetadata
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = event {
            try encodeContainer.encode(event, forKey: .event)
        }
        if let eventDescription = eventDescription {
            try encodeContainer.encode(eventDescription, forKey: .eventDescription)
        }
        if let eventMetadata = eventMetadata {
            var eventMetadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .eventMetadata)
            for (dictKey0, eventmetadata0) in eventMetadata {
                try eventMetadataContainer.encode(eventmetadata0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDecoded = try containerValues.decodeIfPresent(Event.self, forKey: .event)
        event = eventDecoded
        let eventDescriptionDecoded = try containerValues.decodeIfPresent(EventDescription.self, forKey: .eventDescription)
        eventDescription = eventDescriptionDecoded
        let eventMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .eventMetadata)
        var eventMetadataDecoded0: [String:String]? = nil
        if let eventMetadataContainer = eventMetadataContainer {
            eventMetadataDecoded0 = [String:String]()
            for (key0, metadatavalue0) in eventMetadataContainer {
                if let metadatavalue0 = metadatavalue0 {
                    eventMetadataDecoded0?[key0] = metadatavalue0
                }
            }
        }
        eventMetadata = eventMetadataDecoded0
    }
}

extension EventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventDetails(event: \(String(describing: event)), eventDescription: \(String(describing: eventDescription)), eventMetadata: \(String(describing: eventMetadata)))"}
}

/// <p>Detailed information about an event. A combination of an <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_Event.html">Event</a> object, an <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_EventDescription.html">EventDescription</a> object, and additional metadata about the event. Returned by
///          the <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetails.html">DescribeEventDetails</a> operation.</p>
public struct EventDetails: Equatable {
    /// <p>Summary information about the event.</p>
    public let event: Event?
    /// <p>The most recent description of the event.</p>
    public let eventDescription: EventDescription?
    /// <p>Additional metadata about the event.</p>
    public let eventMetadata: [String:String]?

    public init (
        event: Event? = nil,
        eventDescription: EventDescription? = nil,
        eventMetadata: [String:String]? = nil
    )
    {
        self.event = event
        self.eventDescription = eventDescription
        self.eventMetadata = eventMetadata
    }
}

extension EventDetailsErrorItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorMessage
        case errorName
        case eventArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let errorName = errorName {
            try encodeContainer.encode(errorName, forKey: .errorName)
        }
        if let eventArn = eventArn {
            try encodeContainer.encode(eventArn, forKey: .eventArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventArn)
        eventArn = eventArnDecoded
        let errorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorName)
        errorName = errorNameDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension EventDetailsErrorItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventDetailsErrorItem(errorMessage: \(String(describing: errorMessage)), errorName: \(String(describing: errorName)), eventArn: \(String(describing: eventArn)))"}
}

/// <p>Error information returned when a <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetails.html">DescribeEventDetails</a> operation can't find a specified event.</p>
public struct EventDetailsErrorItem: Equatable {
    /// <p>A message that describes the error.</p>
    public let errorMessage: String?
    /// <p>The name of the error.</p>
    public let errorName: String?
    /// <p>The unique identifier for the event. The event ARN has the
    /// <code>arn:aws:health:<i>event-region</i>::event/<i>SERVICE</i>/<i>EVENT_TYPE_CODE</i>/<i>EVENT_TYPE_PLUS_ID</i>
    ///             </code>
    /// format.</p>
    ///          <p>For example, an event ARN might look like the following:</p>
    ///          <p>
    ///             <code>arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456</code>
    ///          </p>
    public let eventArn: String?

    public init (
        errorMessage: String? = nil,
        errorName: String? = nil,
        eventArn: String? = nil
    )
    {
        self.errorMessage = errorMessage
        self.errorName = errorName
        self.eventArn = eventArn
    }
}

extension EventFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZones
        case endTimes
        case entityArns
        case entityValues
        case eventArns
        case eventStatusCodes
        case eventTypeCategories
        case eventTypeCodes
        case lastUpdatedTimes
        case regions
        case services
        case startTimes
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzones0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzones0)
            }
        }
        if let endTimes = endTimes {
            var endTimesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endTimes)
            for datetimerangelist0 in endTimes {
                try endTimesContainer.encode(datetimerangelist0)
            }
        }
        if let entityArns = entityArns {
            var entityArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityArns)
            for entityarnlist0 in entityArns {
                try entityArnsContainer.encode(entityarnlist0)
            }
        }
        if let entityValues = entityValues {
            var entityValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityValues)
            for entityvaluelist0 in entityValues {
                try entityValuesContainer.encode(entityvaluelist0)
            }
        }
        if let eventArns = eventArns {
            var eventArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventArns)
            for eventarnlist0 in eventArns {
                try eventArnsContainer.encode(eventarnlist0)
            }
        }
        if let eventStatusCodes = eventStatusCodes {
            var eventStatusCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventStatusCodes)
            for eventstatuscodelist0 in eventStatusCodes {
                try eventStatusCodesContainer.encode(eventstatuscodelist0.rawValue)
            }
        }
        if let eventTypeCategories = eventTypeCategories {
            var eventTypeCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTypeCategories)
            for eventtypecategorylist20 in eventTypeCategories {
                try eventTypeCategoriesContainer.encode(eventtypecategorylist20.rawValue)
            }
        }
        if let eventTypeCodes = eventTypeCodes {
            var eventTypeCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTypeCodes)
            for eventtypelist20 in eventTypeCodes {
                try eventTypeCodesContainer.encode(eventtypelist20)
            }
        }
        if let lastUpdatedTimes = lastUpdatedTimes {
            var lastUpdatedTimesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lastUpdatedTimes)
            for datetimerangelist0 in lastUpdatedTimes {
                try lastUpdatedTimesContainer.encode(datetimerangelist0)
            }
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for regionlist0 in regions {
                try regionsContainer.encode(regionlist0)
            }
        }
        if let services = services {
            var servicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .services)
            for servicelist0 in services {
                try servicesContainer.encode(servicelist0)
            }
        }
        if let startTimes = startTimes {
            var startTimesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startTimes)
            for datetimerangelist0 in startTimes {
                try startTimesContainer.encode(datetimerangelist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagfilter0 in tags {
                var tagfilter0Container = tagsContainer.nestedContainer(keyedBy: Key.self)
                for (dictKey1, tagset1) in tagfilter0 {
                    try tagfilter0Container.encode(tagset1, forKey: Key(stringValue: dictKey1))
                }
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .eventArns)
        var eventArnsDecoded0:[String]? = nil
        if let eventArnsContainer = eventArnsContainer {
            eventArnsDecoded0 = [String]()
            for string0 in eventArnsContainer {
                if let string0 = string0 {
                    eventArnsDecoded0?.append(string0)
                }
            }
        }
        eventArns = eventArnsDecoded0
        let eventTypeCodesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .eventTypeCodes)
        var eventTypeCodesDecoded0:[String]? = nil
        if let eventTypeCodesContainer = eventTypeCodesContainer {
            eventTypeCodesDecoded0 = [String]()
            for string0 in eventTypeCodesContainer {
                if let string0 = string0 {
                    eventTypeCodesDecoded0?.append(string0)
                }
            }
        }
        eventTypeCodes = eventTypeCodesDecoded0
        let servicesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .services)
        var servicesDecoded0:[String]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [String]()
            for string0 in servicesContainer {
                if let string0 = string0 {
                    servicesDecoded0?.append(string0)
                }
            }
        }
        services = servicesDecoded0
        let regionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .regions)
        var regionsDecoded0:[String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
        let availabilityZonesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let startTimesContainer = try containerValues.decodeIfPresent([DateTimeRange?].self, forKey: .startTimes)
        var startTimesDecoded0:[DateTimeRange]? = nil
        if let startTimesContainer = startTimesContainer {
            startTimesDecoded0 = [DateTimeRange]()
            for structure0 in startTimesContainer {
                if let structure0 = structure0 {
                    startTimesDecoded0?.append(structure0)
                }
            }
        }
        startTimes = startTimesDecoded0
        let endTimesContainer = try containerValues.decodeIfPresent([DateTimeRange?].self, forKey: .endTimes)
        var endTimesDecoded0:[DateTimeRange]? = nil
        if let endTimesContainer = endTimesContainer {
            endTimesDecoded0 = [DateTimeRange]()
            for structure0 in endTimesContainer {
                if let structure0 = structure0 {
                    endTimesDecoded0?.append(structure0)
                }
            }
        }
        endTimes = endTimesDecoded0
        let lastUpdatedTimesContainer = try containerValues.decodeIfPresent([DateTimeRange?].self, forKey: .lastUpdatedTimes)
        var lastUpdatedTimesDecoded0:[DateTimeRange]? = nil
        if let lastUpdatedTimesContainer = lastUpdatedTimesContainer {
            lastUpdatedTimesDecoded0 = [DateTimeRange]()
            for structure0 in lastUpdatedTimesContainer {
                if let structure0 = structure0 {
                    lastUpdatedTimesDecoded0?.append(structure0)
                }
            }
        }
        lastUpdatedTimes = lastUpdatedTimesDecoded0
        let entityArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .entityArns)
        var entityArnsDecoded0:[String]? = nil
        if let entityArnsContainer = entityArnsContainer {
            entityArnsDecoded0 = [String]()
            for string0 in entityArnsContainer {
                if let string0 = string0 {
                    entityArnsDecoded0?.append(string0)
                }
            }
        }
        entityArns = entityArnsDecoded0
        let entityValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .entityValues)
        var entityValuesDecoded0:[String]? = nil
        if let entityValuesContainer = entityValuesContainer {
            entityValuesDecoded0 = [String]()
            for string0 in entityValuesContainer {
                if let string0 = string0 {
                    entityValuesDecoded0?.append(string0)
                }
            }
        }
        entityValues = entityValuesDecoded0
        let eventTypeCategoriesContainer = try containerValues.decodeIfPresent([EventTypeCategory?].self, forKey: .eventTypeCategories)
        var eventTypeCategoriesDecoded0:[EventTypeCategory]? = nil
        if let eventTypeCategoriesContainer = eventTypeCategoriesContainer {
            eventTypeCategoriesDecoded0 = [EventTypeCategory]()
            for string0 in eventTypeCategoriesContainer {
                if let string0 = string0 {
                    eventTypeCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventTypeCategories = eventTypeCategoriesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([[String: String?]?].self, forKey: .tags)
        var tagsDecoded0:[[String:String]]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [[String:String]]()
            for map0 in tagsContainer {
                var tagsContainerDecoded0: [String: String]? = nil
                if let map0 = map0 {
                    tagsContainerDecoded0 = [String: String]()
                    for (key1, tagvalue1) in map0 {
                        if let tagvalue1 = tagvalue1 {
                            tagsContainerDecoded0?[key1] = tagvalue1
                        }
                    }
                }
                if let tagsContainerDecoded0 = tagsContainerDecoded0 {
                    tagsDecoded0?.append(tagsContainerDecoded0)
                }
            }
        }
        tags = tagsDecoded0
        let eventStatusCodesContainer = try containerValues.decodeIfPresent([EventStatusCode?].self, forKey: .eventStatusCodes)
        var eventStatusCodesDecoded0:[EventStatusCode]? = nil
        if let eventStatusCodesContainer = eventStatusCodesContainer {
            eventStatusCodesDecoded0 = [EventStatusCode]()
            for string0 in eventStatusCodesContainer {
                if let string0 = string0 {
                    eventStatusCodesDecoded0?.append(string0)
                }
            }
        }
        eventStatusCodes = eventStatusCodesDecoded0
    }
}

extension EventFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventFilter(availabilityZones: \(String(describing: availabilityZones)), endTimes: \(String(describing: endTimes)), entityArns: \(String(describing: entityArns)), entityValues: \(String(describing: entityValues)), eventArns: \(String(describing: eventArns)), eventStatusCodes: \(String(describing: eventStatusCodes)), eventTypeCategories: \(String(describing: eventTypeCategories)), eventTypeCodes: \(String(describing: eventTypeCodes)), lastUpdatedTimes: \(String(describing: lastUpdatedTimes)), regions: \(String(describing: regions)), services: \(String(describing: services)), startTimes: \(String(describing: startTimes)), tags: \(String(describing: tags)))"}
}

/// <p>The values to use to filter results from the <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEvents.html">DescribeEvents</a> and
///             <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventAggregates.html">DescribeEventAggregates</a> operations.</p>
public struct EventFilter: Equatable {
    /// <p>A list of AWS Availability Zones.</p>
    public let availabilityZones: [String]?
    /// <p>A list of dates and times that the event ended.</p>
    public let endTimes: [DateTimeRange]?
    /// <p>A list of entity ARNs (unique identifiers).</p>
    public let entityArns: [String]?
    /// <p>A list of entity identifiers, such as EC2 instance IDs (<code>i-34ab692e</code>) or EBS
    ///          volumes (<code>vol-426ab23e</code>).</p>
    public let entityValues: [String]?
    /// <p>A list of event ARNs (unique identifiers). For example: <code>"arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"</code>
    ///          </p>
    public let eventArns: [String]?
    /// <p>A list of event status codes.</p>
    public let eventStatusCodes: [EventStatusCode]?
    /// <p>A list of event type category codes (<code>issue</code>, <code>scheduledChange</code>,
    ///          or <code>accountNotification</code>).</p>
    public let eventTypeCategories: [EventTypeCategory]?
    /// <p>A list of unique identifiers for event types. For example, <code>"AWS_EC2_SYSTEM_MAINTENANCE_EVENT","AWS_RDS_MAINTENANCE_SCHEDULED".</code>
    ///          </p>
    public let eventTypeCodes: [String]?
    /// <p>A list of dates and times that the event was last updated.</p>
    public let lastUpdatedTimes: [DateTimeRange]?
    /// <p>A list of AWS Regions.</p>
    public let regions: [String]?
    /// <p>The AWS services associated with the event. For example, <code>EC2</code>, <code>RDS</code>.</p>
    public let services: [String]?
    /// <p>A list of dates and times that the event began.</p>
    public let startTimes: [DateTimeRange]?
    /// <p>A map of entity tags attached to the affected entity.</p>
    ///          <note>
    ///             <p>Currently, the <code>tags</code> property isn't supported.</p>
    ///          </note>
    public let tags: [[String:String]]?

    public init (
        availabilityZones: [String]? = nil,
        endTimes: [DateTimeRange]? = nil,
        entityArns: [String]? = nil,
        entityValues: [String]? = nil,
        eventArns: [String]? = nil,
        eventStatusCodes: [EventStatusCode]? = nil,
        eventTypeCategories: [EventTypeCategory]? = nil,
        eventTypeCodes: [String]? = nil,
        lastUpdatedTimes: [DateTimeRange]? = nil,
        regions: [String]? = nil,
        services: [String]? = nil,
        startTimes: [DateTimeRange]? = nil,
        tags: [[String:String]]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.endTimes = endTimes
        self.entityArns = entityArns
        self.entityValues = entityValues
        self.eventArns = eventArns
        self.eventStatusCodes = eventStatusCodes
        self.eventTypeCategories = eventTypeCategories
        self.eventTypeCodes = eventTypeCodes
        self.lastUpdatedTimes = lastUpdatedTimes
        self.regions = regions
        self.services = services
        self.startTimes = startTimes
        self.tags = tags
    }
}

public enum EventScopeCode {
    case accountSpecific
    case `none`
    case `public`
    case sdkUnknown(String)
}

extension EventScopeCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventScopeCode] {
        return [
            .accountSpecific,
            .none,
            .public,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accountSpecific: return "ACCOUNT_SPECIFIC"
        case .none: return "NONE"
        case .public: return "PUBLIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventScopeCode(rawValue: rawValue) ?? EventScopeCode.sdkUnknown(rawValue)
    }
}

public enum EventStatusCode {
    case closed
    case `open`
    case upcoming
    case sdkUnknown(String)
}

extension EventStatusCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventStatusCode] {
        return [
            .closed,
            .open,
            .upcoming,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .closed: return "closed"
        case .open: return "open"
        case .upcoming: return "upcoming"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventStatusCode(rawValue: rawValue) ?? EventStatusCode.sdkUnknown(rawValue)
    }
}

extension EventType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case category
        case code
        case service
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let service = service {
            try encodeContainer.encode(service, forKey: .service)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .service)
        service = serviceDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(EventTypeCategory.self, forKey: .category)
        category = categoryDecoded
    }
}

extension EventType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventType(category: \(String(describing: category)), code: \(String(describing: code)), service: \(String(describing: service)))"}
}

/// <p>Contains the metadata about a type of event that is reported by AWS Health. The
///             <code>EventType</code> shows the category, service, and the event type code of the
///          event. For example, an <code>issue</code> might be the category, <code>EC2</code> the
///          service, and <code>AWS_EC2_SYSTEM_MAINTENANCE_EVENT</code> the event type code.</p>
///          <p>You can use the <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventTypes.html">DescribeEventTypes</a> API operation to return this information
///          about an event.</p>
///          <p>You can also use the Amazon CloudWatch Events console to create a rule so that you can get notified or
///          take action when AWS Health delivers a specific event to your AWS account. For more
///          information, see <a href="https://docs.aws.amazon.com/health/latest/ug/cloudwatch-events-health.html">Monitor for AWS Health events with Amazon CloudWatch Events</a> in the
///             <i>AWS Health User Guide</i>.</p>
public struct EventType: Equatable {
    /// <p>A list of event type category codes (<code>issue</code>, <code>scheduledChange</code>,
    ///          or <code>accountNotification</code>).</p>
    public let category: EventTypeCategory?
    /// <p>The unique identifier for the event type. The format is <code>AWS_<i>SERVICE</i>_<i>DESCRIPTION</i>
    ///             </code>; for example, <code>AWS_EC2_SYSTEM_MAINTENANCE_EVENT</code>.</p>
    public let code: String?
    /// <p>The AWS service that is affected by the event. For example, <code>EC2</code>, <code>RDS</code>.</p>
    public let service: String?

    public init (
        category: EventTypeCategory? = nil,
        code: String? = nil,
        service: String? = nil
    )
    {
        self.category = category
        self.code = code
        self.service = service
    }
}

public enum EventTypeCategory {
    case accountNotification
    case investigation
    case issue
    case scheduledChange
    case sdkUnknown(String)
}

extension EventTypeCategory : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventTypeCategory] {
        return [
            .accountNotification,
            .investigation,
            .issue,
            .scheduledChange,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accountNotification: return "accountNotification"
        case .investigation: return "investigation"
        case .issue: return "issue"
        case .scheduledChange: return "scheduledChange"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventTypeCategory(rawValue: rawValue) ?? EventTypeCategory.sdkUnknown(rawValue)
    }
}

extension EventTypeFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventTypeCategories
        case eventTypeCodes
        case services
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventTypeCategories = eventTypeCategories {
            var eventTypeCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTypeCategories)
            for eventtypecategorylist0 in eventTypeCategories {
                try eventTypeCategoriesContainer.encode(eventtypecategorylist0.rawValue)
            }
        }
        if let eventTypeCodes = eventTypeCodes {
            var eventTypeCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTypeCodes)
            for eventtypecodelist0 in eventTypeCodes {
                try eventTypeCodesContainer.encode(eventtypecodelist0)
            }
        }
        if let services = services {
            var servicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .services)
            for servicelist0 in services {
                try servicesContainer.encode(servicelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeCodesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .eventTypeCodes)
        var eventTypeCodesDecoded0:[String]? = nil
        if let eventTypeCodesContainer = eventTypeCodesContainer {
            eventTypeCodesDecoded0 = [String]()
            for string0 in eventTypeCodesContainer {
                if let string0 = string0 {
                    eventTypeCodesDecoded0?.append(string0)
                }
            }
        }
        eventTypeCodes = eventTypeCodesDecoded0
        let servicesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .services)
        var servicesDecoded0:[String]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [String]()
            for string0 in servicesContainer {
                if let string0 = string0 {
                    servicesDecoded0?.append(string0)
                }
            }
        }
        services = servicesDecoded0
        let eventTypeCategoriesContainer = try containerValues.decodeIfPresent([EventTypeCategory?].self, forKey: .eventTypeCategories)
        var eventTypeCategoriesDecoded0:[EventTypeCategory]? = nil
        if let eventTypeCategoriesContainer = eventTypeCategoriesContainer {
            eventTypeCategoriesDecoded0 = [EventTypeCategory]()
            for string0 in eventTypeCategoriesContainer {
                if let string0 = string0 {
                    eventTypeCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventTypeCategories = eventTypeCategoriesDecoded0
    }
}

extension EventTypeFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventTypeFilter(eventTypeCategories: \(String(describing: eventTypeCategories)), eventTypeCodes: \(String(describing: eventTypeCodes)), services: \(String(describing: services)))"}
}

/// <p>The values to use to filter results from the <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventTypes.html">DescribeEventTypes</a>
///          operation.</p>
public struct EventTypeFilter: Equatable {
    /// <p>A list of event type category codes (<code>issue</code>, <code>scheduledChange</code>,
    ///          or <code>accountNotification</code>).</p>
    public let eventTypeCategories: [EventTypeCategory]?
    /// <p>A list of event type codes.</p>
    public let eventTypeCodes: [String]?
    /// <p>The AWS services associated with the event. For example, <code>EC2</code>, <code>RDS</code>.</p>
    public let services: [String]?

    public init (
        eventTypeCategories: [EventTypeCategory]? = nil,
        eventTypeCodes: [String]? = nil,
        services: [String]? = nil
    )
    {
        self.eventTypeCategories = eventTypeCategories
        self.eventTypeCodes = eventTypeCodes
        self.services = services
    }
}

extension InvalidPaginationToken: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidPaginationToken(message: \(String(describing: message)))"}
}

extension InvalidPaginationToken: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidPaginationTokenBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified pagination token (<code>nextToken</code>) is not valid.</p>
public struct InvalidPaginationToken: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPaginationTokenBody: Equatable {
    public let message: String?
}

extension InvalidPaginationTokenBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationAffectedEntitiesErrorItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsAccountId
        case errorMessage
        case errorName
        case eventArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let errorName = errorName {
            try encodeContainer.encode(errorName, forKey: .errorName)
        }
        if let eventArn = eventArn {
            try encodeContainer.encode(eventArn, forKey: .eventArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let eventArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventArn)
        eventArn = eventArnDecoded
        let errorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorName)
        errorName = errorNameDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension OrganizationAffectedEntitiesErrorItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationAffectedEntitiesErrorItem(awsAccountId: \(String(describing: awsAccountId)), errorMessage: \(String(describing: errorMessage)), errorName: \(String(describing: errorName)), eventArn: \(String(describing: eventArn)))"}
}

/// <p>Error information returned when a <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeAffectedEntitiesForOrganization.html">DescribeAffectedEntitiesForOrganization</a> operation can't find or process a
///          specific entity.</p>
public struct OrganizationAffectedEntitiesErrorItem: Equatable {
    /// <p>The 12-digit AWS account numbers that contains the affected entities.</p>
    public let awsAccountId: String?
    /// <p>The unique identifier for the event type. The format is
    ///             <code>AWS_SERVICE_DESCRIPTION</code>. For example,
    ///             <code>AWS_EC2_SYSTEM_MAINTENANCE_EVENT</code>.</p>
    public let errorMessage: String?
    /// <p>The name of the error.</p>
    public let errorName: String?
    /// <p>The unique identifier for the event. The event ARN has the
    /// <code>arn:aws:health:<i>event-region</i>::event/<i>SERVICE</i>/<i>EVENT_TYPE_CODE</i>/<i>EVENT_TYPE_PLUS_ID</i>
    ///             </code>
    /// format.</p>
    ///          <p>For example, an event ARN might look like the following:</p>
    ///          <p>
    ///             <code>arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456</code>
    ///          </p>
    public let eventArn: String?

    public init (
        awsAccountId: String? = nil,
        errorMessage: String? = nil,
        errorName: String? = nil,
        eventArn: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.errorMessage = errorMessage
        self.errorName = errorName
        self.eventArn = eventArn
    }
}

extension OrganizationEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case endTime
        case eventScopeCode
        case eventTypeCategory
        case eventTypeCode
        case lastUpdatedTime
        case region
        case service
        case startTime
        case statusCode
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let eventScopeCode = eventScopeCode {
            try encodeContainer.encode(eventScopeCode.rawValue, forKey: .eventScopeCode)
        }
        if let eventTypeCategory = eventTypeCategory {
            try encodeContainer.encode(eventTypeCategory.rawValue, forKey: .eventTypeCategory)
        }
        if let eventTypeCode = eventTypeCode {
            try encodeContainer.encode(eventTypeCode, forKey: .eventTypeCode)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let service = service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .service)
        service = serviceDecoded
        let eventTypeCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventTypeCode)
        eventTypeCode = eventTypeCodeDecoded
        let eventTypeCategoryDecoded = try containerValues.decodeIfPresent(EventTypeCategory.self, forKey: .eventTypeCategory)
        eventTypeCategory = eventTypeCategoryDecoded
        let eventScopeCodeDecoded = try containerValues.decodeIfPresent(EventScopeCode.self, forKey: .eventScopeCode)
        eventScopeCode = eventScopeCodeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(EventStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
    }
}

extension OrganizationEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationEvent(arn: \(String(describing: arn)), endTime: \(String(describing: endTime)), eventScopeCode: \(String(describing: eventScopeCode)), eventTypeCategory: \(String(describing: eventTypeCategory)), eventTypeCode: \(String(describing: eventTypeCode)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), region: \(String(describing: region)), service: \(String(describing: service)), startTime: \(String(describing: startTime)), statusCode: \(String(describing: statusCode)))"}
}

/// <p>Summary information about an event, returned by the <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventsForOrganization.html">DescribeEventsForOrganization</a> operation.</p>
public struct OrganizationEvent: Equatable {
    /// <p>The unique identifier for the event. The event ARN has the
    /// <code>arn:aws:health:<i>event-region</i>::event/<i>SERVICE</i>/<i>EVENT_TYPE_CODE</i>/<i>EVENT_TYPE_PLUS_ID</i>
    ///             </code>
    /// format.</p>
    ///          <p>For example, an event ARN might look like the following:</p>
    ///          <p>
    ///             <code>arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456</code>
    ///          </p>
    public let arn: String?
    /// <p>The date and time that the event ended.</p>
    public let endTime: Date?
    /// <p>This parameter specifies if the AWS Health event is a public AWS service event or an account-specific event.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If the <code>eventScopeCode</code> value is <code>PUBLIC</code>, then the
    ///                   <code>affectedAccounts</code> value is always empty.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the <code>eventScopeCode</code> value is <code>ACCOUNT_SPECIFIC</code>, then
    ///                the <code>affectedAccounts</code> value lists the affected AWS accounts in your
    ///                organization. For example, if an event affects a service such as Amazon Elastic Compute Cloud and you
    ///                have AWS accounts that use that service, those account IDs appear in the
    ///                response.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the <code>eventScopeCode</code> value is <code>NONE</code>, then the
    ///                   <code>eventArn</code> that you specified in the request is invalid or doesn't
    ///                exist.</p>
    ///             </li>
    ///          </ul>
    public let eventScopeCode: EventScopeCode?
    /// <p>The category of the event type.</p>
    public let eventTypeCategory: EventTypeCategory?
    /// <p>The unique identifier for the event type. The format is
    ///             <code>AWS_SERVICE_DESCRIPTION</code>. For example,
    ///             <code>AWS_EC2_SYSTEM_MAINTENANCE_EVENT</code>.</p>
    public let eventTypeCode: String?
    /// <p>The most recent date and time that the event was updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>The AWS Region name of the event.</p>
    public let region: String?
    /// <p>The AWS service that is affected by the event, such as EC2 and RDS.</p>
    public let service: String?
    /// <p>The date and time that the event began.</p>
    public let startTime: Date?
    /// <p>The most recent status of the event. Possible values are <code>open</code>,
    ///             <code>closed</code>, and <code>upcoming</code>.</p>
    public let statusCode: EventStatusCode?

    public init (
        arn: String? = nil,
        endTime: Date? = nil,
        eventScopeCode: EventScopeCode? = nil,
        eventTypeCategory: EventTypeCategory? = nil,
        eventTypeCode: String? = nil,
        lastUpdatedTime: Date? = nil,
        region: String? = nil,
        service: String? = nil,
        startTime: Date? = nil,
        statusCode: EventStatusCode? = nil
    )
    {
        self.arn = arn
        self.endTime = endTime
        self.eventScopeCode = eventScopeCode
        self.eventTypeCategory = eventTypeCategory
        self.eventTypeCode = eventTypeCode
        self.lastUpdatedTime = lastUpdatedTime
        self.region = region
        self.service = service
        self.startTime = startTime
        self.statusCode = statusCode
    }
}

extension OrganizationEventDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsAccountId
        case event
        case eventDescription
        case eventMetadata
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let event = event {
            try encodeContainer.encode(event, forKey: .event)
        }
        if let eventDescription = eventDescription {
            try encodeContainer.encode(eventDescription, forKey: .eventDescription)
        }
        if let eventMetadata = eventMetadata {
            var eventMetadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .eventMetadata)
            for (dictKey0, eventmetadata0) in eventMetadata {
                try eventMetadataContainer.encode(eventmetadata0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let eventDecoded = try containerValues.decodeIfPresent(Event.self, forKey: .event)
        event = eventDecoded
        let eventDescriptionDecoded = try containerValues.decodeIfPresent(EventDescription.self, forKey: .eventDescription)
        eventDescription = eventDescriptionDecoded
        let eventMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .eventMetadata)
        var eventMetadataDecoded0: [String:String]? = nil
        if let eventMetadataContainer = eventMetadataContainer {
            eventMetadataDecoded0 = [String:String]()
            for (key0, metadatavalue0) in eventMetadataContainer {
                if let metadatavalue0 = metadatavalue0 {
                    eventMetadataDecoded0?[key0] = metadatavalue0
                }
            }
        }
        eventMetadata = eventMetadataDecoded0
    }
}

extension OrganizationEventDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationEventDetails(awsAccountId: \(String(describing: awsAccountId)), event: \(String(describing: event)), eventDescription: \(String(describing: eventDescription)), eventMetadata: \(String(describing: eventMetadata)))"}
}

/// <p>Detailed information about an event. A combination of an <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_Event.html">Event</a> object, an <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_EventDescription.html">EventDescription</a> object, and additional metadata about the event. Returned by
///          the <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetailsForOrganization.html">DescribeEventDetailsForOrganization</a> operation.</p>
public struct OrganizationEventDetails: Equatable {
    /// <p>The 12-digit AWS account numbers that contains the affected entities.</p>
    public let awsAccountId: String?
    /// <p>Summary information about an AWS Health event.</p>
    ///          <p>AWS Health events can be public or account-specific:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <i>Public events</i> might be service events that are not specific
    ///                to an AWS account. For example, if there is an issue with an AWS Region,
    ///                AWS Health provides information about the event, even if you don't use services or
    ///                resources in that Region.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>Account-specific</i> events are specific to either your AWS
    ///                account or an account in your organization. For example, if there's an issue with
    ///                Amazon Elastic Compute Cloud in a Region that you use, AWS Health provides information about the event
    ///                and the affected resources in the account.</p>
    ///             </li>
    ///          </ul>
    ///          <p>You can determine if an event is public or account-specific by using the
    ///             <code>eventScopeCode</code> parameter. For more information, see <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_Event.html#AWSHealth-Type-Event-eventScopeCode">eventScopeCode</a>.</p>
    public let event: Event?
    /// <p>The detailed description of the event. Included in the information returned by the
    ///             <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetails.html">DescribeEventDetails</a> operation.</p>
    public let eventDescription: EventDescription?
    /// <p>Additional metadata about the event.</p>
    public let eventMetadata: [String:String]?

    public init (
        awsAccountId: String? = nil,
        event: Event? = nil,
        eventDescription: EventDescription? = nil,
        eventMetadata: [String:String]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.event = event
        self.eventDescription = eventDescription
        self.eventMetadata = eventMetadata
    }
}

extension OrganizationEventDetailsErrorItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsAccountId
        case errorMessage
        case errorName
        case eventArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let errorName = errorName {
            try encodeContainer.encode(errorName, forKey: .errorName)
        }
        if let eventArn = eventArn {
            try encodeContainer.encode(eventArn, forKey: .eventArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let eventArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventArn)
        eventArn = eventArnDecoded
        let errorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorName)
        errorName = errorNameDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension OrganizationEventDetailsErrorItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationEventDetailsErrorItem(awsAccountId: \(String(describing: awsAccountId)), errorMessage: \(String(describing: errorMessage)), errorName: \(String(describing: errorName)), eventArn: \(String(describing: eventArn)))"}
}

/// <p>Error information returned when a <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetailsForOrganization.html">DescribeEventDetailsForOrganization</a> operation can't find a specified
///          event.</p>
public struct OrganizationEventDetailsErrorItem: Equatable {
    /// <p>Error information returned when a <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetailsForOrganization.html">DescribeEventDetailsForOrganization</a> operation can't find a specified
    ///          event.</p>
    public let awsAccountId: String?
    /// <p>A message that describes the error.</p>
    ///          <p>If you call the <code>DescribeEventDetailsForOrganization</code>
    /// operation and receive one of the following errors, follow the recommendations in the message:</p>
    ///          <ul>
    ///             <li>
    ///                <p>We couldn't find a public event that matches your request. To find an event that is account specific, you must enter an AWS account ID in the request.</p>
    ///             </li>
    ///             <li>
    ///                <p>We couldn't find an account specific event for the specified AWS account. To find an event that is public, you must enter a null value for the AWS account ID in the request.</p>
    ///             </li>
    ///             <li>
    ///                <p>Your AWS account doesn't include the AWS Support plan required to use the AWS Health API. You must have either a Business or Enterprise Support plan.</p>
    ///             </li>
    ///          </ul>
    public let errorMessage: String?
    /// <p>The name of the error.</p>
    public let errorName: String?
    /// <p>The unique identifier for the event. The event ARN has the
    /// <code>arn:aws:health:<i>event-region</i>::event/<i>SERVICE</i>/<i>EVENT_TYPE_CODE</i>/<i>EVENT_TYPE_PLUS_ID</i>
    ///             </code>
    /// format.</p>
    ///          <p>For example, an event ARN might look like the following:</p>
    ///          <p>
    ///             <code>arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456</code>
    ///          </p>
    public let eventArn: String?

    public init (
        awsAccountId: String? = nil,
        errorMessage: String? = nil,
        errorName: String? = nil,
        eventArn: String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.errorMessage = errorMessage
        self.errorName = errorName
        self.eventArn = eventArn
    }
}

extension OrganizationEventFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsAccountIds
        case endTime
        case entityArns
        case entityValues
        case eventStatusCodes
        case eventTypeCategories
        case eventTypeCodes
        case lastUpdatedTime
        case regions
        case services
        case startTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountIds = awsAccountIds {
            var awsAccountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsAccountIds)
            for awsaccountidslist0 in awsAccountIds {
                try awsAccountIdsContainer.encode(awsaccountidslist0)
            }
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let entityArns = entityArns {
            var entityArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityArns)
            for entityarnlist0 in entityArns {
                try entityArnsContainer.encode(entityarnlist0)
            }
        }
        if let entityValues = entityValues {
            var entityValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityValues)
            for entityvaluelist0 in entityValues {
                try entityValuesContainer.encode(entityvaluelist0)
            }
        }
        if let eventStatusCodes = eventStatusCodes {
            var eventStatusCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventStatusCodes)
            for eventstatuscodelist0 in eventStatusCodes {
                try eventStatusCodesContainer.encode(eventstatuscodelist0.rawValue)
            }
        }
        if let eventTypeCategories = eventTypeCategories {
            var eventTypeCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTypeCategories)
            for eventtypecategorylist20 in eventTypeCategories {
                try eventTypeCategoriesContainer.encode(eventtypecategorylist20.rawValue)
            }
        }
        if let eventTypeCodes = eventTypeCodes {
            var eventTypeCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTypeCodes)
            for eventtypelist20 in eventTypeCodes {
                try eventTypeCodesContainer.encode(eventtypelist20)
            }
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for regionlist0 in regions {
                try regionsContainer.encode(regionlist0)
            }
        }
        if let services = services {
            var servicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .services)
            for servicelist0 in services {
                try servicesContainer.encode(servicelist0)
            }
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeCodesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .eventTypeCodes)
        var eventTypeCodesDecoded0:[String]? = nil
        if let eventTypeCodesContainer = eventTypeCodesContainer {
            eventTypeCodesDecoded0 = [String]()
            for string0 in eventTypeCodesContainer {
                if let string0 = string0 {
                    eventTypeCodesDecoded0?.append(string0)
                }
            }
        }
        eventTypeCodes = eventTypeCodesDecoded0
        let awsAccountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .awsAccountIds)
        var awsAccountIdsDecoded0:[String]? = nil
        if let awsAccountIdsContainer = awsAccountIdsContainer {
            awsAccountIdsDecoded0 = [String]()
            for string0 in awsAccountIdsContainer {
                if let string0 = string0 {
                    awsAccountIdsDecoded0?.append(string0)
                }
            }
        }
        awsAccountIds = awsAccountIdsDecoded0
        let servicesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .services)
        var servicesDecoded0:[String]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [String]()
            for string0 in servicesContainer {
                if let string0 = string0 {
                    servicesDecoded0?.append(string0)
                }
            }
        }
        services = servicesDecoded0
        let regionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .regions)
        var regionsDecoded0:[String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
        let startTimeDecoded = try containerValues.decodeIfPresent(DateTimeRange.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(DateTimeRange.self, forKey: .endTime)
        endTime = endTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(DateTimeRange.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let entityArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .entityArns)
        var entityArnsDecoded0:[String]? = nil
        if let entityArnsContainer = entityArnsContainer {
            entityArnsDecoded0 = [String]()
            for string0 in entityArnsContainer {
                if let string0 = string0 {
                    entityArnsDecoded0?.append(string0)
                }
            }
        }
        entityArns = entityArnsDecoded0
        let entityValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .entityValues)
        var entityValuesDecoded0:[String]? = nil
        if let entityValuesContainer = entityValuesContainer {
            entityValuesDecoded0 = [String]()
            for string0 in entityValuesContainer {
                if let string0 = string0 {
                    entityValuesDecoded0?.append(string0)
                }
            }
        }
        entityValues = entityValuesDecoded0
        let eventTypeCategoriesContainer = try containerValues.decodeIfPresent([EventTypeCategory?].self, forKey: .eventTypeCategories)
        var eventTypeCategoriesDecoded0:[EventTypeCategory]? = nil
        if let eventTypeCategoriesContainer = eventTypeCategoriesContainer {
            eventTypeCategoriesDecoded0 = [EventTypeCategory]()
            for string0 in eventTypeCategoriesContainer {
                if let string0 = string0 {
                    eventTypeCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventTypeCategories = eventTypeCategoriesDecoded0
        let eventStatusCodesContainer = try containerValues.decodeIfPresent([EventStatusCode?].self, forKey: .eventStatusCodes)
        var eventStatusCodesDecoded0:[EventStatusCode]? = nil
        if let eventStatusCodesContainer = eventStatusCodesContainer {
            eventStatusCodesDecoded0 = [EventStatusCode]()
            for string0 in eventStatusCodesContainer {
                if let string0 = string0 {
                    eventStatusCodesDecoded0?.append(string0)
                }
            }
        }
        eventStatusCodes = eventStatusCodesDecoded0
    }
}

extension OrganizationEventFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationEventFilter(awsAccountIds: \(String(describing: awsAccountIds)), endTime: \(String(describing: endTime)), entityArns: \(String(describing: entityArns)), entityValues: \(String(describing: entityValues)), eventStatusCodes: \(String(describing: eventStatusCodes)), eventTypeCategories: \(String(describing: eventTypeCategories)), eventTypeCodes: \(String(describing: eventTypeCodes)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), regions: \(String(describing: regions)), services: \(String(describing: services)), startTime: \(String(describing: startTime)))"}
}

/// <p>The values to filter results from the <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventsForOrganization.html">DescribeEventsForOrganization</a> operation.</p>
public struct OrganizationEventFilter: Equatable {
    /// <p>A list of 12-digit AWS account numbers that contains the affected entities.</p>
    public let awsAccountIds: [String]?
    /// <p>A range of dates and times that is used by the <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_EventFilter.html">EventFilter</a> and <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_EntityFilter.html">EntityFilter</a> objects. If <code>from</code> is set and <code>to</code> is set:
    ///          match items where the timestamp (<code>startTime</code>, <code>endTime</code>, or
    ///             <code>lastUpdatedTime</code>) is between <code>from</code> and <code>to</code>
    ///          inclusive. If <code>from</code> is set and <code>to</code> is not set: match items where
    ///          the timestamp value is equal to or after <code>from</code>. If <code>from</code> is not set
    ///          and <code>to</code> is set: match items where the timestamp value is equal to or before
    ///             <code>to</code>.</p>
    public let endTime: DateTimeRange?
    /// <p>A list of entity ARNs (unique identifiers).</p>
    public let entityArns: [String]?
    /// <p>A list of entity identifiers, such as EC2 instance IDs (i-34ab692e) or EBS volumes (vol-426ab23e).</p>
    public let entityValues: [String]?
    /// <p>A list of event status codes.</p>
    public let eventStatusCodes: [EventStatusCode]?
    /// <p>A list of event type category codes (issue, scheduledChange, or accountNotification).</p>
    public let eventTypeCategories: [EventTypeCategory]?
    /// <p>A list of unique identifiers for event types. For example, <code>"AWS_EC2_SYSTEM_MAINTENANCE_EVENT","AWS_RDS_MAINTENANCE_SCHEDULED".</code>
    ///          </p>
    public let eventTypeCodes: [String]?
    /// <p>A range of dates and times that is used by the <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_EventFilter.html">EventFilter</a> and <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_EntityFilter.html">EntityFilter</a> objects. If <code>from</code> is set and <code>to</code> is set:
    ///          match items where the timestamp (<code>startTime</code>, <code>endTime</code>, or
    ///             <code>lastUpdatedTime</code>) is between <code>from</code> and <code>to</code>
    ///          inclusive. If <code>from</code> is set and <code>to</code> is not set: match items where
    ///          the timestamp value is equal to or after <code>from</code>. If <code>from</code> is not set
    ///          and <code>to</code> is set: match items where the timestamp value is equal to or before
    ///             <code>to</code>.</p>
    public let lastUpdatedTime: DateTimeRange?
    /// <p>A list of AWS Regions.</p>
    public let regions: [String]?
    /// <p>The AWS services associated with the event. For example, <code>EC2</code>, <code>RDS</code>.</p>
    public let services: [String]?
    /// <p>A range of dates and times that is used by the <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_EventFilter.html">EventFilter</a> and <a href="https://docs.aws.amazon.com/health/latest/APIReference/API_EntityFilter.html">EntityFilter</a> objects. If <code>from</code> is set and <code>to</code> is set:
    ///          match items where the timestamp (<code>startTime</code>, <code>endTime</code>, or
    ///             <code>lastUpdatedTime</code>) is between <code>from</code> and <code>to</code>
    ///          inclusive. If <code>from</code> is set and <code>to</code> is not set: match items where
    ///          the timestamp value is equal to or after <code>from</code>. If <code>from</code> is not set
    ///          and <code>to</code> is set: match items where the timestamp value is equal to or before
    ///             <code>to</code>.</p>
    public let startTime: DateTimeRange?

    public init (
        awsAccountIds: [String]? = nil,
        endTime: DateTimeRange? = nil,
        entityArns: [String]? = nil,
        entityValues: [String]? = nil,
        eventStatusCodes: [EventStatusCode]? = nil,
        eventTypeCategories: [EventTypeCategory]? = nil,
        eventTypeCodes: [String]? = nil,
        lastUpdatedTime: DateTimeRange? = nil,
        regions: [String]? = nil,
        services: [String]? = nil,
        startTime: DateTimeRange? = nil
    )
    {
        self.awsAccountIds = awsAccountIds
        self.endTime = endTime
        self.entityArns = entityArns
        self.entityValues = entityValues
        self.eventStatusCodes = eventStatusCodes
        self.eventTypeCategories = eventTypeCategories
        self.eventTypeCodes = eventTypeCodes
        self.lastUpdatedTime = lastUpdatedTime
        self.regions = regions
        self.services = services
        self.startTime = startTime
    }
}

extension UnsupportedLocale: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedLocale(message: \(String(describing: message)))"}
}

extension UnsupportedLocale: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedLocaleBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified locale is not supported.</p>
public struct UnsupportedLocale: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedLocaleBody: Equatable {
    public let message: String?
}

extension UnsupportedLocaleBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
