// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Access to the resource is denied.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Access to the resource is denied.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AssetDestinationEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assetId = "AssetId"
        case bucket = "Bucket"
        case key = "Key"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
    }
}

extension AssetDestinationEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetDestinationEntry(assetId: \(String(describing: assetId)), bucket: \(String(describing: bucket)), key: \(String(describing: key)))"}
}

/// <p>The destination for the asset.</p>
public struct AssetDestinationEntry: Equatable {
    /// <p>The unique identifier for the asset.</p>
    public let assetId: String?
    /// <p>The S3 bucket that is the destination for the asset.</p>
    public let bucket: String?
    /// <p>The name of the object in Amazon S3 for the asset.</p>
    public let key: String?

    public init (
        assetId: String? = nil,
        bucket: String? = nil,
        key: String? = nil
    )
    {
        self.assetId = assetId
        self.bucket = bucket
        self.key = key
    }
}

extension AssetDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3SnapshotAsset = "S3SnapshotAsset"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3SnapshotAsset = s3SnapshotAsset {
            try encodeContainer.encode(s3SnapshotAsset, forKey: .s3SnapshotAsset)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3SnapshotAssetDecoded = try containerValues.decodeIfPresent(S3SnapshotAsset.self, forKey: .s3SnapshotAsset)
        s3SnapshotAsset = s3SnapshotAssetDecoded
    }
}

extension AssetDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetDetails(s3SnapshotAsset: \(String(describing: s3SnapshotAsset)))"}
}

public struct AssetDetails: Equatable {
    /// <p>The S3 object that is the asset.</p>
    public let s3SnapshotAsset: S3SnapshotAsset?

    public init (
        s3SnapshotAsset: S3SnapshotAsset? = nil
    )
    {
        self.s3SnapshotAsset = s3SnapshotAsset
    }
}

extension AssetEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case assetDetails = "AssetDetails"
        case assetType = "AssetType"
        case createdAt = "CreatedAt"
        case dataSetId = "DataSetId"
        case id = "Id"
        case name = "Name"
        case revisionId = "RevisionId"
        case sourceId = "SourceId"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assetDetails = assetDetails {
            try encodeContainer.encode(assetDetails, forKey: .assetDetails)
        }
        if let assetType = assetType {
            try encodeContainer.encode(assetType.rawValue, forKey: .assetType)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let sourceId = sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let assetDetailsDecoded = try containerValues.decodeIfPresent(AssetDetails.self, forKey: .assetDetails)
        assetDetails = assetDetailsDecoded
        let assetTypeDecoded = try containerValues.decodeIfPresent(AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension AssetEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetEntry(arn: \(String(describing: arn)), assetDetails: \(String(describing: assetDetails)), assetType: \(String(describing: assetType)), createdAt: \(String(describing: createdAt)), dataSetId: \(String(describing: dataSetId)), id: \(String(describing: id)), name: \(String(describing: name)), revisionId: \(String(describing: revisionId)), sourceId: \(String(describing: sourceId)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>An asset in AWS Data Exchange is a piece of data that can be stored as an S3 object. The asset can be a structured data file, an image file, or some other data file. When you create an import job for your files, you create an asset in AWS Data Exchange for each of those files.</p>
public struct AssetEntry: Equatable {
    /// <p>The ARN for the asset.</p>
    public let arn: String?
    /// <p>Information about the asset, including its size.</p>
    public let assetDetails: AssetDetails?
    /// <p>The type of file your data is stored in. Currently, the supported asset type is S3_SNAPSHOT.</p>
    public let assetType: AssetType?
    /// <p>The date and time that the asset was created, in ISO 8601 format.</p>
    public let createdAt: Date?
    /// <p>The unique identifier for the data set associated with this asset.</p>
    public let dataSetId: String?
    /// <p>The unique identifier for the asset.</p>
    public let id: String?
    /// <p>The name of the asset. When importing from Amazon S3, the S3 object key is used as the asset name. When exporting to Amazon S3, the asset name is used as default target S3 object key.</p>
    public let name: String?
    /// <p>The unique identifier for the revision associated with this asset.</p>
    public let revisionId: String?
    /// <p>The asset ID of the owned asset corresponding to the entitled asset being viewed. This parameter is returned when an asset owner is viewing the entitled copy of its owned asset.</p>
    public let sourceId: String?
    /// <p>The date and time that the asset was last updated, in ISO 8601 format.</p>
    public let updatedAt: Date?

    public init (
        arn: String? = nil,
        assetDetails: AssetDetails? = nil,
        assetType: AssetType? = nil,
        createdAt: Date? = nil,
        dataSetId: String? = nil,
        id: String? = nil,
        name: String? = nil,
        revisionId: String? = nil,
        sourceId: String? = nil,
        updatedAt: Date? = nil
    )
    {
        self.arn = arn
        self.assetDetails = assetDetails
        self.assetType = assetType
        self.createdAt = createdAt
        self.dataSetId = dataSetId
        self.id = id
        self.name = name
        self.revisionId = revisionId
        self.sourceId = sourceId
        self.updatedAt = updatedAt
    }
}

extension AssetSourceEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case key = "Key"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
    }
}

extension AssetSourceEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetSourceEntry(bucket: \(String(describing: bucket)), key: \(String(describing: key)))"}
}

/// <p>The source of the assets.</p>
public struct AssetSourceEntry: Equatable {
    /// <p>The S3 bucket that's part of the source of the asset.</p>
    public let bucket: String?
    /// <p>The name of the object in Amazon S3 for the asset.</p>
    public let key: String?

    public init (
        bucket: String? = nil,
        key: String? = nil
    )
    {
        self.bucket = bucket
        self.key = key
    }
}

/// <p>The type of file your data is stored in. Currently, the supported asset type is S3_SNAPSHOT.</p>
public enum AssetType {
    case s3Snapshot
    case sdkUnknown(String)
}

extension AssetType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AssetType] {
        return [
            .s3Snapshot,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .s3Snapshot: return "S3_SNAPSHOT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AssetType(rawValue: rawValue) ?? AssetType.sdkUnknown(rawValue)
    }
}

extension CancelJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelJobInput(jobId: \(String(describing: jobId)))"}
}

extension CancelJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CancelJobInputHeadersMiddleware: Middleware {
    public let id: String = "CancelJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelJobInput>
    public typealias MOutput = OperationOutput<CancelJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelJobOutputError>
}

public struct CancelJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelJobInput>
    public typealias MOutput = OperationOutput<CancelJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelJobOutputError>
}

public struct CancelJobInput: Equatable {
    /// <p>The unique identifier for a job.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CancelJobInputBody: Equatable {
}

extension CancelJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CancelJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelJobOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelJobOutputResponse()"}
}

extension CancelJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CancelJobOutputResponse: Equatable {

    public init() {}
}

struct CancelJobOutputResponseBody: Equatable {
}

extension CancelJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum Code {
    case accessDeniedException
    case internalServerException
    case malwareDetected
    case malwareScanEncryptedFile
    case resourceNotFoundException
    case serviceQuotaExceededException
    case validationException
    case sdkUnknown(String)
}

extension Code : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Code] {
        return [
            .accessDeniedException,
            .internalServerException,
            .malwareDetected,
            .malwareScanEncryptedFile,
            .resourceNotFoundException,
            .serviceQuotaExceededException,
            .validationException,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accessDeniedException: return "ACCESS_DENIED_EXCEPTION"
        case .internalServerException: return "INTERNAL_SERVER_EXCEPTION"
        case .malwareDetected: return "MALWARE_DETECTED"
        case .malwareScanEncryptedFile: return "MALWARE_SCAN_ENCRYPTED_FILE"
        case .resourceNotFoundException: return "RESOURCE_NOT_FOUND_EXCEPTION"
        case .serviceQuotaExceededException: return "SERVICE_QUOTA_EXCEEDED_EXCEPTION"
        case .validationException: return "VALIDATION_EXCEPTION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Code(rawValue: rawValue) ?? Code.sdkUnknown(rawValue)
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request couldn't be completed because it conflicted with the current state of the resource.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The request couldn't be completed because it conflicted with the current state of the resource.</p>
    public var message: String?
    /// <p>The unique identifier for the resource with the conflict.</p>
    public var resourceId: String?
    /// <p>The type of the resource with the conflict.</p>
    public var resourceType: ResourceType?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: ResourceType?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct CreateDataSetInputBodyMiddleware: Middleware {
    public let id: String = "CreateDataSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDataSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDataSetInput>
    public typealias MOutput = OperationOutput<CreateDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDataSetOutputError>
}

extension CreateDataSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDataSetInput(assetType: \(String(describing: assetType)), description: \(String(describing: description)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateDataSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assetType = "AssetType"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetType = assetType {
            try encodeContainer.encode(assetType.rawValue, forKey: .assetType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapof__string0) in tags {
                try tagsContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateDataSetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDataSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDataSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDataSetInput>
    public typealias MOutput = OperationOutput<CreateDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDataSetOutputError>
}

public struct CreateDataSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDataSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDataSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDataSetInput>
    public typealias MOutput = OperationOutput<CreateDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDataSetOutputError>
}

/// <p>The request body for CreateDataSet.</p>
public struct CreateDataSetInput: Equatable {
    /// <p>The type of file your data is stored in. Currently, the supported asset type is S3_SNAPSHOT.</p>
    public let assetType: AssetType?
    /// <p>A description for the data set. This value can be up to 16,348 characters long.</p>
    public let description: String?
    /// <p>The name of the data set.</p>
    public let name: String?
    /// <p>A data set tag is an optional label that you can assign to a data set when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to these data sets and revisions.</p>
    public let tags: [String:String]?

    public init (
        assetType: AssetType? = nil,
        description: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.assetType = assetType
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateDataSetInputBody: Equatable {
    public let assetType: AssetType?
    public let description: String?
    public let name: String?
    public let tags: [String:String]?
}

extension CreateDataSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assetType = "AssetType"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetTypeDecoded = try containerValues.decodeIfPresent(AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDataSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDataSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceededException" : self = .serviceLimitExceededException(try ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDataSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case serviceLimitExceededException(ServiceLimitExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDataSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDataSetOutputResponse(arn: \(String(describing: arn)), assetType: \(String(describing: assetType)), createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), origin: \(String(describing: origin)), originDetails: \(String(describing: originDetails)), sourceId: \(String(describing: sourceId)), tags: \(String(describing: tags)), updatedAt: \(String(describing: updatedAt)))"}
}

extension CreateDataSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDataSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.assetType = output.assetType
            self.createdAt = output.createdAt
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.origin = output.origin
            self.originDetails = output.originDetails
            self.sourceId = output.sourceId
            self.tags = output.tags
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.assetType = nil
            self.createdAt = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.origin = nil
            self.originDetails = nil
            self.sourceId = nil
            self.tags = nil
            self.updatedAt = nil
        }
    }
}

public struct CreateDataSetOutputResponse: Equatable {
    /// <p>The ARN for the data set.</p>
    public let arn: String?
    /// <p>The type of file your data is stored in. Currently, the supported asset type is S3_SNAPSHOT.</p>
    public let assetType: AssetType?
    /// <p>The date and time that the data set was created, in ISO 8601 format.</p>
    public let createdAt: Date?
    /// <p>The description for the data set.</p>
    public let description: String?
    /// <p>The unique identifier for the data set.</p>
    public let id: String?
    /// <p>The name of the data set.</p>
    public let name: String?
    /// <p>A property that defines the data set as OWNED by the account (for providers) or ENTITLED to the account (for subscribers).</p>
    public let origin: Origin?
    /// <p>If the origin of this data set is ENTITLED, includes the details for the product on AWS Marketplace.</p>
    public let originDetails: OriginDetails?
    /// <p>The data set ID of the owned data set corresponding to the entitled data set being viewed. This parameter is returned when a data set owner is viewing the entitled copy of its owned data set.</p>
    public let sourceId: String?
    /// <p>The tags for the data set.</p>
    public let tags: [String:String]?
    /// <p>The date and time that the data set was last updated, in ISO 8601 format.</p>
    public let updatedAt: Date?

    public init (
        arn: String? = nil,
        assetType: AssetType? = nil,
        createdAt: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        origin: Origin? = nil,
        originDetails: OriginDetails? = nil,
        sourceId: String? = nil,
        tags: [String:String]? = nil,
        updatedAt: Date? = nil
    )
    {
        self.arn = arn
        self.assetType = assetType
        self.createdAt = createdAt
        self.description = description
        self.id = id
        self.name = name
        self.origin = origin
        self.originDetails = originDetails
        self.sourceId = sourceId
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

struct CreateDataSetOutputResponseBody: Equatable {
    public let arn: String?
    public let assetType: AssetType?
    public let createdAt: Date?
    public let description: String?
    public let id: String?
    public let name: String?
    public let origin: Origin?
    public let originDetails: OriginDetails?
    public let sourceId: String?
    public let tags: [String:String]?
    public let updatedAt: Date?
}

extension CreateDataSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case assetType = "AssetType"
        case createdAt = "CreatedAt"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case origin = "Origin"
        case originDetails = "OriginDetails"
        case sourceId = "SourceId"
        case tags = "Tags"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let assetTypeDecoded = try containerValues.decodeIfPresent(AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let originDecoded = try containerValues.decodeIfPresent(Origin.self, forKey: .origin)
        origin = originDecoded
        let originDetailsDecoded = try containerValues.decodeIfPresent(OriginDetails.self, forKey: .originDetails)
        originDetails = originDetailsDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

public struct CreateJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateJobInput>
    public typealias MOutput = OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateJobOutputError>
}

extension CreateJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateJobInput(details: \(String(describing: details)), type: \(String(describing: type)))"}
}

extension CreateJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case details = "Details"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let details = details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateJobInput>
    public typealias MOutput = OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateJobOutputError>
}

public struct CreateJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateJobInput>
    public typealias MOutput = OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateJobOutputError>
}

/// <p>The request body for CreateJob.</p>
public struct CreateJobInput: Equatable {
    /// <p>The details for the CreateJob request.</p>
    public let details: RequestDetails?
    /// <p>The type of job to be created.</p>
    public let type: `Type`?

    public init (
        details: RequestDetails? = nil,
        type: `Type`? = nil
    )
    {
        self.details = details
        self.type = type
    }
}

struct CreateJobInputBody: Equatable {
    public let details: RequestDetails?
    public let type: `Type`?
}

extension CreateJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case details = "Details"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsDecoded = try containerValues.decodeIfPresent(RequestDetails.self, forKey: .details)
        details = detailsDecoded
        let typeDecoded = try containerValues.decodeIfPresent(`Type`.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateJobOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateJobOutputResponse(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), details: \(String(describing: details)), errors: \(String(describing: errors)), id: \(String(describing: id)), state: \(String(describing: state)), type: \(String(describing: type)), updatedAt: \(String(describing: updatedAt)))"}
}

extension CreateJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.details = output.details
            self.errors = output.errors
            self.id = output.id
            self.state = output.state
            self.type = output.type
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.createdAt = nil
            self.details = nil
            self.errors = nil
            self.id = nil
            self.state = nil
            self.type = nil
            self.updatedAt = nil
        }
    }
}

public struct CreateJobOutputResponse: Equatable {
    /// <p>The ARN for the job.</p>
    public let arn: String?
    /// <p>The date and time that the job was created, in ISO 8601 format.</p>
    public let createdAt: Date?
    /// <p>Details about the job.</p>
    public let details: ResponseDetails?
    /// <p>The errors associated with jobs.</p>
    public let errors: [JobError]?
    /// <p>The unique identifier for the job.</p>
    public let id: String?
    /// <p>The state of the job.</p>
    public let state: State?
    /// <p>The job type.</p>
    public let type: `Type`?
    /// <p>The date and time that the job was last updated, in ISO 8601 format.</p>
    public let updatedAt: Date?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        details: ResponseDetails? = nil,
        errors: [JobError]? = nil,
        id: String? = nil,
        state: State? = nil,
        type: `Type`? = nil,
        updatedAt: Date? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.details = details
        self.errors = errors
        self.id = id
        self.state = state
        self.type = type
        self.updatedAt = updatedAt
    }
}

struct CreateJobOutputResponseBody: Equatable {
    public let arn: String?
    public let createdAt: Date?
    public let details: ResponseDetails?
    public let errors: [JobError]?
    public let id: String?
    public let state: State?
    public let type: `Type`?
    public let updatedAt: Date?
}

extension CreateJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case details = "Details"
        case errors = "Errors"
        case id = "Id"
        case state = "State"
        case type = "Type"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(ResponseDetails.self, forKey: .details)
        details = detailsDecoded
        let errorsContainer = try containerValues.decodeIfPresent([JobError?].self, forKey: .errors)
        var errorsDecoded0:[JobError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [JobError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let stateDecoded = try containerValues.decodeIfPresent(State.self, forKey: .state)
        state = stateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(`Type`.self, forKey: .type)
        type = typeDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

public struct CreateRevisionInputBodyMiddleware: Middleware {
    public let id: String = "CreateRevisionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRevisionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRevisionInput>
    public typealias MOutput = OperationOutput<CreateRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRevisionOutputError>
}

extension CreateRevisionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRevisionInput(comment: \(String(describing: comment)), dataSetId: \(String(describing: dataSetId)), tags: \(String(describing: tags)))"}
}

extension CreateRevisionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comment = "Comment"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapof__string0) in tags {
                try tagsContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateRevisionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRevisionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRevisionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRevisionInput>
    public typealias MOutput = OperationOutput<CreateRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRevisionOutputError>
}

public struct CreateRevisionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRevisionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRevisionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRevisionInput>
    public typealias MOutput = OperationOutput<CreateRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRevisionOutputError>
}

/// <p>The request body for CreateRevision.</p>
public struct CreateRevisionInput: Equatable {
    /// <p>An optional comment about the revision.</p>
    public let comment: String?
    /// <p>The unique identifier for a data set.</p>
    public let dataSetId: String?
    /// <p>A revision tag is an optional label that you can assign to a revision when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to these data sets and revisions.</p>
    public let tags: [String:String]?

    public init (
        comment: String? = nil,
        dataSetId: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.comment = comment
        self.dataSetId = dataSetId
        self.tags = tags
    }
}

struct CreateRevisionInputBody: Equatable {
    public let comment: String?
    public let tags: [String:String]?
}

extension CreateRevisionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case comment = "Comment"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRevisionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRevisionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRevisionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRevisionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRevisionOutputResponse(arn: \(String(describing: arn)), comment: \(String(describing: comment)), createdAt: \(String(describing: createdAt)), dataSetId: \(String(describing: dataSetId)), finalized: \(String(describing: finalized)), id: \(String(describing: id)), sourceId: \(String(describing: sourceId)), tags: \(String(describing: tags)), updatedAt: \(String(describing: updatedAt)))"}
}

extension CreateRevisionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRevisionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.comment = output.comment
            self.createdAt = output.createdAt
            self.dataSetId = output.dataSetId
            self.finalized = output.finalized
            self.id = output.id
            self.sourceId = output.sourceId
            self.tags = output.tags
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.comment = nil
            self.createdAt = nil
            self.dataSetId = nil
            self.finalized = false
            self.id = nil
            self.sourceId = nil
            self.tags = nil
            self.updatedAt = nil
        }
    }
}

public struct CreateRevisionOutputResponse: Equatable {
    /// <p>The ARN for the revision</p>
    public let arn: String?
    /// <p>An optional comment about the revision.</p>
    public let comment: String?
    /// <p>The date and time that the revision was created, in ISO 8601 format.</p>
    public let createdAt: Date?
    /// <p>The unique identifier for the data set associated with this revision.</p>
    public let dataSetId: String?
    /// <p>To publish a revision to a data set in a product, the revision must first be finalized. Finalizing a revision tells AWS Data Exchange that your changes to the assets in the revision are complete. After it's in this read-only state, you can publish the revision to your products.</p> <p>Finalized revisions can be published through the AWS Data Exchange console or the AWS Marketplace Catalog API, using the StartChangeSet AWS Marketplace Catalog API action. When using the API, revisions are uniquely identified by their ARN.</p>
    public let finalized: Bool
    /// <p>The unique identifier for the revision.</p>
    public let id: String?
    /// <p>The revision ID of the owned revision corresponding to the entitled revision being viewed. This parameter is returned when a revision owner is viewing the entitled copy of its owned revision.</p>
    public let sourceId: String?
    /// <p>The tags for the revision.</p>
    public let tags: [String:String]?
    /// <p>The date and time that the revision was last updated, in ISO 8601 format.</p>
    public let updatedAt: Date?

    public init (
        arn: String? = nil,
        comment: String? = nil,
        createdAt: Date? = nil,
        dataSetId: String? = nil,
        finalized: Bool = false,
        id: String? = nil,
        sourceId: String? = nil,
        tags: [String:String]? = nil,
        updatedAt: Date? = nil
    )
    {
        self.arn = arn
        self.comment = comment
        self.createdAt = createdAt
        self.dataSetId = dataSetId
        self.finalized = finalized
        self.id = id
        self.sourceId = sourceId
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

struct CreateRevisionOutputResponseBody: Equatable {
    public let arn: String?
    public let comment: String?
    public let createdAt: Date?
    public let dataSetId: String?
    public let finalized: Bool
    public let id: String?
    public let sourceId: String?
    public let tags: [String:String]?
    public let updatedAt: Date?
}

extension CreateRevisionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case comment = "Comment"
        case createdAt = "CreatedAt"
        case dataSetId = "DataSetId"
        case finalized = "Finalized"
        case id = "Id"
        case sourceId = "SourceId"
        case tags = "Tags"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let finalizedDecoded = try containerValues.decode(Bool.self, forKey: .finalized)
        finalized = finalizedDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension DataSetEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case assetType = "AssetType"
        case createdAt = "CreatedAt"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case origin = "Origin"
        case originDetails = "OriginDetails"
        case sourceId = "SourceId"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assetType = assetType {
            try encodeContainer.encode(assetType.rawValue, forKey: .assetType)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let origin = origin {
            try encodeContainer.encode(origin.rawValue, forKey: .origin)
        }
        if let originDetails = originDetails {
            try encodeContainer.encode(originDetails, forKey: .originDetails)
        }
        if let sourceId = sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let assetTypeDecoded = try containerValues.decodeIfPresent(AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let originDecoded = try containerValues.decodeIfPresent(Origin.self, forKey: .origin)
        origin = originDecoded
        let originDetailsDecoded = try containerValues.decodeIfPresent(OriginDetails.self, forKey: .originDetails)
        originDetails = originDetailsDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension DataSetEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataSetEntry(arn: \(String(describing: arn)), assetType: \(String(describing: assetType)), createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), origin: \(String(describing: origin)), originDetails: \(String(describing: originDetails)), sourceId: \(String(describing: sourceId)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>A data set is an AWS resource with one or more revisions.</p>
public struct DataSetEntry: Equatable {
    /// <p>The ARN for the data set.</p>
    public let arn: String?
    /// <p>The type of file your data is stored in. Currently, the supported asset type is S3_SNAPSHOT.</p>
    public let assetType: AssetType?
    /// <p>The date and time that the data set was created, in ISO 8601 format.</p>
    public let createdAt: Date?
    /// <p>The description for the data set.</p>
    public let description: String?
    /// <p>The unique identifier for the data set.</p>
    public let id: String?
    /// <p>The name of the data set.</p>
    public let name: String?
    /// <p>A property that defines the data set as OWNED by the account (for providers) or ENTITLED to the account (for subscribers).</p>
    public let origin: Origin?
    /// <p>If the origin of this data set is ENTITLED, includes the details for the product on AWS Marketplace.</p>
    public let originDetails: OriginDetails?
    /// <p>The data set ID of the owned data set corresponding to the entitled data set being viewed. This parameter is returned when a data set owner is viewing the entitled copy of its owned data set.</p>
    public let sourceId: String?
    /// <p>The date and time that the data set was last updated, in ISO 8601 format.</p>
    public let updatedAt: Date?

    public init (
        arn: String? = nil,
        assetType: AssetType? = nil,
        createdAt: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        origin: Origin? = nil,
        originDetails: OriginDetails? = nil,
        sourceId: String? = nil,
        updatedAt: Date? = nil
    )
    {
        self.arn = arn
        self.assetType = assetType
        self.createdAt = createdAt
        self.description = description
        self.id = id
        self.name = name
        self.origin = origin
        self.originDetails = originDetails
        self.sourceId = sourceId
        self.updatedAt = updatedAt
    }
}

extension DeleteAssetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAssetInput(assetId: \(String(describing: assetId)), dataSetId: \(String(describing: dataSetId)), revisionId: \(String(describing: revisionId)))"}
}

extension DeleteAssetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAssetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAssetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssetInput>
    public typealias MOutput = OperationOutput<DeleteAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssetOutputError>
}

public struct DeleteAssetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAssetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssetInput>
    public typealias MOutput = OperationOutput<DeleteAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssetOutputError>
}

public struct DeleteAssetInput: Equatable {
    /// <p>The unique identifier for an asset.</p>
    public let assetId: String?
    /// <p>The unique identifier for a data set.</p>
    public let dataSetId: String?
    /// <p>The unique identifier for a revision.</p>
    public let revisionId: String?

    public init (
        assetId: String? = nil,
        dataSetId: String? = nil,
        revisionId: String? = nil
    )
    {
        self.assetId = assetId
        self.dataSetId = dataSetId
        self.revisionId = revisionId
    }
}

struct DeleteAssetInputBody: Equatable {
}

extension DeleteAssetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAssetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAssetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAssetOutputResponse()"}
}

extension DeleteAssetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAssetOutputResponse: Equatable {

    public init() {}
}

struct DeleteAssetOutputResponseBody: Equatable {
}

extension DeleteAssetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDataSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDataSetInput(dataSetId: \(String(describing: dataSetId)))"}
}

extension DeleteDataSetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDataSetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDataSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDataSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDataSetInput>
    public typealias MOutput = OperationOutput<DeleteDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDataSetOutputError>
}

public struct DeleteDataSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDataSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDataSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDataSetInput>
    public typealias MOutput = OperationOutput<DeleteDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDataSetOutputError>
}

public struct DeleteDataSetInput: Equatable {
    /// <p>The unique identifier for a data set.</p>
    public let dataSetId: String?

    public init (
        dataSetId: String? = nil
    )
    {
        self.dataSetId = dataSetId
    }
}

struct DeleteDataSetInputBody: Equatable {
}

extension DeleteDataSetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDataSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDataSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDataSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDataSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDataSetOutputResponse()"}
}

extension DeleteDataSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDataSetOutputResponse: Equatable {

    public init() {}
}

struct DeleteDataSetOutputResponseBody: Equatable {
}

extension DeleteDataSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRevisionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRevisionInput(dataSetId: \(String(describing: dataSetId)), revisionId: \(String(describing: revisionId)))"}
}

extension DeleteRevisionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteRevisionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRevisionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRevisionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRevisionInput>
    public typealias MOutput = OperationOutput<DeleteRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRevisionOutputError>
}

public struct DeleteRevisionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRevisionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRevisionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRevisionInput>
    public typealias MOutput = OperationOutput<DeleteRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRevisionOutputError>
}

public struct DeleteRevisionInput: Equatable {
    /// <p>The unique identifier for a data set.</p>
    public let dataSetId: String?
    /// <p>The unique identifier for a revision.</p>
    public let revisionId: String?

    public init (
        dataSetId: String? = nil,
        revisionId: String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.revisionId = revisionId
    }
}

struct DeleteRevisionInputBody: Equatable {
}

extension DeleteRevisionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRevisionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRevisionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRevisionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRevisionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRevisionOutputResponse()"}
}

extension DeleteRevisionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRevisionOutputResponse: Equatable {

    public init() {}
}

struct DeleteRevisionOutputResponseBody: Equatable {
}

extension DeleteRevisionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Details: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case importAssetFromSignedUrlJobErrorDetails = "ImportAssetFromSignedUrlJobErrorDetails"
        case importAssetsFromS3JobErrorDetails = "ImportAssetsFromS3JobErrorDetails"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let importAssetFromSignedUrlJobErrorDetails = importAssetFromSignedUrlJobErrorDetails {
            try encodeContainer.encode(importAssetFromSignedUrlJobErrorDetails, forKey: .importAssetFromSignedUrlJobErrorDetails)
        }
        if let importAssetsFromS3JobErrorDetails = importAssetsFromS3JobErrorDetails {
            var importAssetsFromS3JobErrorDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .importAssetsFromS3JobErrorDetails)
            for listofassetsourceentry0 in importAssetsFromS3JobErrorDetails {
                try importAssetsFromS3JobErrorDetailsContainer.encode(listofassetsourceentry0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importAssetFromSignedUrlJobErrorDetailsDecoded = try containerValues.decodeIfPresent(ImportAssetFromSignedUrlJobErrorDetails.self, forKey: .importAssetFromSignedUrlJobErrorDetails)
        importAssetFromSignedUrlJobErrorDetails = importAssetFromSignedUrlJobErrorDetailsDecoded
        let importAssetsFromS3JobErrorDetailsContainer = try containerValues.decodeIfPresent([AssetSourceEntry?].self, forKey: .importAssetsFromS3JobErrorDetails)
        var importAssetsFromS3JobErrorDetailsDecoded0:[AssetSourceEntry]? = nil
        if let importAssetsFromS3JobErrorDetailsContainer = importAssetsFromS3JobErrorDetailsContainer {
            importAssetsFromS3JobErrorDetailsDecoded0 = [AssetSourceEntry]()
            for structure0 in importAssetsFromS3JobErrorDetailsContainer {
                if let structure0 = structure0 {
                    importAssetsFromS3JobErrorDetailsDecoded0?.append(structure0)
                }
            }
        }
        importAssetsFromS3JobErrorDetails = importAssetsFromS3JobErrorDetailsDecoded0
    }
}

extension Details: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Details(importAssetFromSignedUrlJobErrorDetails: \(String(describing: importAssetFromSignedUrlJobErrorDetails)), importAssetsFromS3JobErrorDetails: \(String(describing: importAssetsFromS3JobErrorDetails)))"}
}

public struct Details: Equatable {
    public let importAssetFromSignedUrlJobErrorDetails: ImportAssetFromSignedUrlJobErrorDetails?
    /// <p>The list of sources for the assets.</p>
    public let importAssetsFromS3JobErrorDetails: [AssetSourceEntry]?

    public init (
        importAssetFromSignedUrlJobErrorDetails: ImportAssetFromSignedUrlJobErrorDetails? = nil,
        importAssetsFromS3JobErrorDetails: [AssetSourceEntry]? = nil
    )
    {
        self.importAssetFromSignedUrlJobErrorDetails = importAssetFromSignedUrlJobErrorDetails
        self.importAssetsFromS3JobErrorDetails = importAssetsFromS3JobErrorDetails
    }
}

extension ExportAssetToSignedUrlRequestDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assetId = "AssetId"
        case dataSetId = "DataSetId"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension ExportAssetToSignedUrlRequestDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportAssetToSignedUrlRequestDetails(assetId: \(String(describing: assetId)), dataSetId: \(String(describing: dataSetId)), revisionId: \(String(describing: revisionId)))"}
}

/// <p>Details of the operation to be performed by the job.</p>
public struct ExportAssetToSignedUrlRequestDetails: Equatable {
    /// <p>The unique identifier for the asset that is exported to a signed URL.</p>
    public let assetId: String?
    /// <p>The unique identifier for the data set associated with this export job.</p>
    public let dataSetId: String?
    /// <p>The unique identifier for the revision associated with this export request.</p>
    public let revisionId: String?

    public init (
        assetId: String? = nil,
        dataSetId: String? = nil,
        revisionId: String? = nil
    )
    {
        self.assetId = assetId
        self.dataSetId = dataSetId
        self.revisionId = revisionId
    }
}

extension ExportAssetToSignedUrlResponseDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assetId = "AssetId"
        case dataSetId = "DataSetId"
        case revisionId = "RevisionId"
        case signedUrl = "SignedUrl"
        case signedUrlExpiresAt = "SignedUrlExpiresAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let signedUrl = signedUrl {
            try encodeContainer.encode(signedUrl, forKey: .signedUrl)
        }
        if let signedUrlExpiresAt = signedUrlExpiresAt {
            try encodeContainer.encode(signedUrlExpiresAt.timeIntervalSince1970, forKey: .signedUrlExpiresAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let signedUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signedUrl)
        signedUrl = signedUrlDecoded
        let signedUrlExpiresAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .signedUrlExpiresAt)
        signedUrlExpiresAt = signedUrlExpiresAtDecoded
    }
}

extension ExportAssetToSignedUrlResponseDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportAssetToSignedUrlResponseDetails(assetId: \(String(describing: assetId)), dataSetId: \(String(describing: dataSetId)), revisionId: \(String(describing: revisionId)), signedUrl: \(String(describing: signedUrl)), signedUrlExpiresAt: \(String(describing: signedUrlExpiresAt)))"}
}

/// <p>The details of the export to signed URL response.</p>
public struct ExportAssetToSignedUrlResponseDetails: Equatable {
    /// <p>The unique identifier for the asset associated with this export job.</p>
    public let assetId: String?
    /// <p>The unique identifier for the data set associated with this export job.</p>
    public let dataSetId: String?
    /// <p>The unique identifier for the revision associated with this export response.</p>
    public let revisionId: String?
    /// <p>The signed URL for the export request.</p>
    public let signedUrl: String?
    /// <p>The date and time that the signed URL expires, in ISO 8601 format.</p>
    public let signedUrlExpiresAt: Date?

    public init (
        assetId: String? = nil,
        dataSetId: String? = nil,
        revisionId: String? = nil,
        signedUrl: String? = nil,
        signedUrlExpiresAt: Date? = nil
    )
    {
        self.assetId = assetId
        self.dataSetId = dataSetId
        self.revisionId = revisionId
        self.signedUrl = signedUrl
        self.signedUrlExpiresAt = signedUrlExpiresAt
    }
}

extension ExportAssetsToS3RequestDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assetDestinations = "AssetDestinations"
        case dataSetId = "DataSetId"
        case encryption = "Encryption"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetDestinations = assetDestinations {
            var assetDestinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetDestinations)
            for listofassetdestinationentry0 in assetDestinations {
                try assetDestinationsContainer.encode(listofassetdestinationentry0)
            }
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetDestinationsContainer = try containerValues.decodeIfPresent([AssetDestinationEntry?].self, forKey: .assetDestinations)
        var assetDestinationsDecoded0:[AssetDestinationEntry]? = nil
        if let assetDestinationsContainer = assetDestinationsContainer {
            assetDestinationsDecoded0 = [AssetDestinationEntry]()
            for structure0 in assetDestinationsContainer {
                if let structure0 = structure0 {
                    assetDestinationsDecoded0?.append(structure0)
                }
            }
        }
        assetDestinations = assetDestinationsDecoded0
        let dataSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(ExportServerSideEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension ExportAssetsToS3RequestDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportAssetsToS3RequestDetails(assetDestinations: \(String(describing: assetDestinations)), dataSetId: \(String(describing: dataSetId)), encryption: \(String(describing: encryption)), revisionId: \(String(describing: revisionId)))"}
}

/// <p>Details of the operation to be performed by the job.</p>
public struct ExportAssetsToS3RequestDetails: Equatable {
    /// <p>The destination for the asset.</p>
    public let assetDestinations: [AssetDestinationEntry]?
    /// <p>The unique identifier for the data set associated with this export job.</p>
    public let dataSetId: String?
    /// <p>Encryption configuration for the export job.</p>
    public let encryption: ExportServerSideEncryption?
    /// <p>The unique identifier for the revision associated with this export request.</p>
    public let revisionId: String?

    public init (
        assetDestinations: [AssetDestinationEntry]? = nil,
        dataSetId: String? = nil,
        encryption: ExportServerSideEncryption? = nil,
        revisionId: String? = nil
    )
    {
        self.assetDestinations = assetDestinations
        self.dataSetId = dataSetId
        self.encryption = encryption
        self.revisionId = revisionId
    }
}

extension ExportAssetsToS3ResponseDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assetDestinations = "AssetDestinations"
        case dataSetId = "DataSetId"
        case encryption = "Encryption"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetDestinations = assetDestinations {
            var assetDestinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetDestinations)
            for listofassetdestinationentry0 in assetDestinations {
                try assetDestinationsContainer.encode(listofassetdestinationentry0)
            }
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetDestinationsContainer = try containerValues.decodeIfPresent([AssetDestinationEntry?].self, forKey: .assetDestinations)
        var assetDestinationsDecoded0:[AssetDestinationEntry]? = nil
        if let assetDestinationsContainer = assetDestinationsContainer {
            assetDestinationsDecoded0 = [AssetDestinationEntry]()
            for structure0 in assetDestinationsContainer {
                if let structure0 = structure0 {
                    assetDestinationsDecoded0?.append(structure0)
                }
            }
        }
        assetDestinations = assetDestinationsDecoded0
        let dataSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(ExportServerSideEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension ExportAssetsToS3ResponseDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportAssetsToS3ResponseDetails(assetDestinations: \(String(describing: assetDestinations)), dataSetId: \(String(describing: dataSetId)), encryption: \(String(describing: encryption)), revisionId: \(String(describing: revisionId)))"}
}

/// <p>Details about the export to Amazon S3 response.</p>
public struct ExportAssetsToS3ResponseDetails: Equatable {
    /// <p>The destination in Amazon S3 where the asset is exported.</p>
    public let assetDestinations: [AssetDestinationEntry]?
    /// <p>The unique identifier for the data set associated with this export job.</p>
    public let dataSetId: String?
    /// <p>Encryption configuration of the export job.</p>
    public let encryption: ExportServerSideEncryption?
    /// <p>The unique identifier for the revision associated with this export response.</p>
    public let revisionId: String?

    public init (
        assetDestinations: [AssetDestinationEntry]? = nil,
        dataSetId: String? = nil,
        encryption: ExportServerSideEncryption? = nil,
        revisionId: String? = nil
    )
    {
        self.assetDestinations = assetDestinations
        self.dataSetId = dataSetId
        self.encryption = encryption
        self.revisionId = revisionId
    }
}

extension ExportRevisionsToS3RequestDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSetId = "DataSetId"
        case encryption = "Encryption"
        case revisionDestinations = "RevisionDestinations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let revisionDestinations = revisionDestinations {
            var revisionDestinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revisionDestinations)
            for listofrevisiondestinationentry0 in revisionDestinations {
                try revisionDestinationsContainer.encode(listofrevisiondestinationentry0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(ExportServerSideEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let revisionDestinationsContainer = try containerValues.decodeIfPresent([RevisionDestinationEntry?].self, forKey: .revisionDestinations)
        var revisionDestinationsDecoded0:[RevisionDestinationEntry]? = nil
        if let revisionDestinationsContainer = revisionDestinationsContainer {
            revisionDestinationsDecoded0 = [RevisionDestinationEntry]()
            for structure0 in revisionDestinationsContainer {
                if let structure0 = structure0 {
                    revisionDestinationsDecoded0?.append(structure0)
                }
            }
        }
        revisionDestinations = revisionDestinationsDecoded0
    }
}

extension ExportRevisionsToS3RequestDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportRevisionsToS3RequestDetails(dataSetId: \(String(describing: dataSetId)), encryption: \(String(describing: encryption)), revisionDestinations: \(String(describing: revisionDestinations)))"}
}

/// <p>Details of the operation to be performed by the job.</p>
public struct ExportRevisionsToS3RequestDetails: Equatable {
    /// <p>The unique identifier for the data set associated with this export job.</p>
    public let dataSetId: String?
    /// <p>Encryption configuration for the export job.</p>
    public let encryption: ExportServerSideEncryption?
    /// <p>The destination for the revision.</p>
    public let revisionDestinations: [RevisionDestinationEntry]?

    public init (
        dataSetId: String? = nil,
        encryption: ExportServerSideEncryption? = nil,
        revisionDestinations: [RevisionDestinationEntry]? = nil
    )
    {
        self.dataSetId = dataSetId
        self.encryption = encryption
        self.revisionDestinations = revisionDestinations
    }
}

extension ExportRevisionsToS3ResponseDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSetId = "DataSetId"
        case encryption = "Encryption"
        case revisionDestinations = "RevisionDestinations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let revisionDestinations = revisionDestinations {
            var revisionDestinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revisionDestinations)
            for listofrevisiondestinationentry0 in revisionDestinations {
                try revisionDestinationsContainer.encode(listofrevisiondestinationentry0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(ExportServerSideEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let revisionDestinationsContainer = try containerValues.decodeIfPresent([RevisionDestinationEntry?].self, forKey: .revisionDestinations)
        var revisionDestinationsDecoded0:[RevisionDestinationEntry]? = nil
        if let revisionDestinationsContainer = revisionDestinationsContainer {
            revisionDestinationsDecoded0 = [RevisionDestinationEntry]()
            for structure0 in revisionDestinationsContainer {
                if let structure0 = structure0 {
                    revisionDestinationsDecoded0?.append(structure0)
                }
            }
        }
        revisionDestinations = revisionDestinationsDecoded0
    }
}

extension ExportRevisionsToS3ResponseDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportRevisionsToS3ResponseDetails(dataSetId: \(String(describing: dataSetId)), encryption: \(String(describing: encryption)), revisionDestinations: \(String(describing: revisionDestinations)))"}
}

/// <p>Details about the export revisions to Amazon S3 response.</p>
public struct ExportRevisionsToS3ResponseDetails: Equatable {
    /// <p>The unique identifier for the data set associated with this export job.</p>
    public let dataSetId: String?
    /// <p>Encryption configuration of the export job.</p>
    public let encryption: ExportServerSideEncryption?
    /// <p>The destination in Amazon S3 where the revision is exported.</p>
    public let revisionDestinations: [RevisionDestinationEntry]?

    public init (
        dataSetId: String? = nil,
        encryption: ExportServerSideEncryption? = nil,
        revisionDestinations: [RevisionDestinationEntry]? = nil
    )
    {
        self.dataSetId = dataSetId
        self.encryption = encryption
        self.revisionDestinations = revisionDestinations
    }
}

extension ExportServerSideEncryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kmsKeyArn = "KmsKeyArn"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServerSideEncryptionTypes.self, forKey: .type)
        type = typeDecoded
    }
}

extension ExportServerSideEncryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportServerSideEncryption(kmsKeyArn: \(String(describing: kmsKeyArn)), type: \(String(describing: type)))"}
}

/// <p>Encryption configuration of the export job. Includes the encryption type as well as the AWS KMS key. The KMS key is only necessary if you chose the KMS encryption type.</p>
public struct ExportServerSideEncryption: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the the AWS KMS key you want to use to encrypt the Amazon S3 objects. This parameter is required if you choose aws:kms as an encryption type.</p>
    public let kmsKeyArn: String?
    /// <p>The type of server side encryption used for encrypting the objects in Amazon S3.</p>
    public let type: ServerSideEncryptionTypes?

    public init (
        kmsKeyArn: String? = nil,
        type: ServerSideEncryptionTypes? = nil
    )
    {
        self.kmsKeyArn = kmsKeyArn
        self.type = type
    }
}

extension GetAssetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAssetInput(assetId: \(String(describing: assetId)), dataSetId: \(String(describing: dataSetId)), revisionId: \(String(describing: revisionId)))"}
}

extension GetAssetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAssetInputHeadersMiddleware: Middleware {
    public let id: String = "GetAssetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAssetInput>
    public typealias MOutput = OperationOutput<GetAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAssetOutputError>
}

public struct GetAssetInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAssetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAssetInput>
    public typealias MOutput = OperationOutput<GetAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAssetOutputError>
}

public struct GetAssetInput: Equatable {
    /// <p>The unique identifier for an asset.</p>
    public let assetId: String?
    /// <p>The unique identifier for a data set.</p>
    public let dataSetId: String?
    /// <p>The unique identifier for a revision.</p>
    public let revisionId: String?

    public init (
        assetId: String? = nil,
        dataSetId: String? = nil,
        revisionId: String? = nil
    )
    {
        self.assetId = assetId
        self.dataSetId = dataSetId
        self.revisionId = revisionId
    }
}

struct GetAssetInputBody: Equatable {
}

extension GetAssetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAssetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAssetOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAssetOutputResponse(arn: \(String(describing: arn)), assetDetails: \(String(describing: assetDetails)), assetType: \(String(describing: assetType)), createdAt: \(String(describing: createdAt)), dataSetId: \(String(describing: dataSetId)), id: \(String(describing: id)), name: \(String(describing: name)), revisionId: \(String(describing: revisionId)), sourceId: \(String(describing: sourceId)), updatedAt: \(String(describing: updatedAt)))"}
}

extension GetAssetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAssetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.assetDetails = output.assetDetails
            self.assetType = output.assetType
            self.createdAt = output.createdAt
            self.dataSetId = output.dataSetId
            self.id = output.id
            self.name = output.name
            self.revisionId = output.revisionId
            self.sourceId = output.sourceId
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.assetDetails = nil
            self.assetType = nil
            self.createdAt = nil
            self.dataSetId = nil
            self.id = nil
            self.name = nil
            self.revisionId = nil
            self.sourceId = nil
            self.updatedAt = nil
        }
    }
}

public struct GetAssetOutputResponse: Equatable {
    /// <p>The ARN for the asset.</p>
    public let arn: String?
    /// <p>Information about the asset, including its size.</p>
    public let assetDetails: AssetDetails?
    /// <p>The type of file your data is stored in. Currently, the supported asset type is S3_SNAPSHOT.</p>
    public let assetType: AssetType?
    /// <p>The date and time that the asset was created, in ISO 8601 format.</p>
    public let createdAt: Date?
    /// <p>The unique identifier for the data set associated with this asset.</p>
    public let dataSetId: String?
    /// <p>The unique identifier for the asset.</p>
    public let id: String?
    /// <p>The name of the asset When importing from Amazon S3, the S3 object key is used as the asset name. When exporting to Amazon S3, the asset name is used as default target S3 object key.</p>
    public let name: String?
    /// <p>The unique identifier for the revision associated with this asset.</p>
    public let revisionId: String?
    /// <p>The asset ID of the owned asset corresponding to the entitled asset being viewed. This parameter is returned when an asset owner is viewing the entitled copy of its owned asset.</p>
    public let sourceId: String?
    /// <p>The date and time that the asset was last updated, in ISO 8601 format.</p>
    public let updatedAt: Date?

    public init (
        arn: String? = nil,
        assetDetails: AssetDetails? = nil,
        assetType: AssetType? = nil,
        createdAt: Date? = nil,
        dataSetId: String? = nil,
        id: String? = nil,
        name: String? = nil,
        revisionId: String? = nil,
        sourceId: String? = nil,
        updatedAt: Date? = nil
    )
    {
        self.arn = arn
        self.assetDetails = assetDetails
        self.assetType = assetType
        self.createdAt = createdAt
        self.dataSetId = dataSetId
        self.id = id
        self.name = name
        self.revisionId = revisionId
        self.sourceId = sourceId
        self.updatedAt = updatedAt
    }
}

struct GetAssetOutputResponseBody: Equatable {
    public let arn: String?
    public let assetDetails: AssetDetails?
    public let assetType: AssetType?
    public let createdAt: Date?
    public let dataSetId: String?
    public let id: String?
    public let name: String?
    public let revisionId: String?
    public let sourceId: String?
    public let updatedAt: Date?
}

extension GetAssetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case assetDetails = "AssetDetails"
        case assetType = "AssetType"
        case createdAt = "CreatedAt"
        case dataSetId = "DataSetId"
        case id = "Id"
        case name = "Name"
        case revisionId = "RevisionId"
        case sourceId = "SourceId"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let assetDetailsDecoded = try containerValues.decodeIfPresent(AssetDetails.self, forKey: .assetDetails)
        assetDetails = assetDetailsDecoded
        let assetTypeDecoded = try containerValues.decodeIfPresent(AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension GetDataSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDataSetInput(dataSetId: \(String(describing: dataSetId)))"}
}

extension GetDataSetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDataSetInputHeadersMiddleware: Middleware {
    public let id: String = "GetDataSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDataSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDataSetInput>
    public typealias MOutput = OperationOutput<GetDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDataSetOutputError>
}

public struct GetDataSetInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDataSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDataSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDataSetInput>
    public typealias MOutput = OperationOutput<GetDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDataSetOutputError>
}

public struct GetDataSetInput: Equatable {
    /// <p>The unique identifier for a data set.</p>
    public let dataSetId: String?

    public init (
        dataSetId: String? = nil
    )
    {
        self.dataSetId = dataSetId
    }
}

struct GetDataSetInputBody: Equatable {
}

extension GetDataSetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDataSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDataSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDataSetOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDataSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDataSetOutputResponse(arn: \(String(describing: arn)), assetType: \(String(describing: assetType)), createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), origin: \(String(describing: origin)), originDetails: \(String(describing: originDetails)), sourceId: \(String(describing: sourceId)), tags: \(String(describing: tags)), updatedAt: \(String(describing: updatedAt)))"}
}

extension GetDataSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDataSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.assetType = output.assetType
            self.createdAt = output.createdAt
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.origin = output.origin
            self.originDetails = output.originDetails
            self.sourceId = output.sourceId
            self.tags = output.tags
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.assetType = nil
            self.createdAt = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.origin = nil
            self.originDetails = nil
            self.sourceId = nil
            self.tags = nil
            self.updatedAt = nil
        }
    }
}

public struct GetDataSetOutputResponse: Equatable {
    /// <p>The ARN for the data set.</p>
    public let arn: String?
    /// <p>The type of file your data is stored in. Currently, the supported asset type is S3_SNAPSHOT.</p>
    public let assetType: AssetType?
    /// <p>The date and time that the data set was created, in ISO 8601 format.</p>
    public let createdAt: Date?
    /// <p>The description for the data set.</p>
    public let description: String?
    /// <p>The unique identifier for the data set.</p>
    public let id: String?
    /// <p>The name of the data set.</p>
    public let name: String?
    /// <p>A property that defines the data set as OWNED by the account (for providers) or ENTITLED to the account (for subscribers).</p>
    public let origin: Origin?
    /// <p>If the origin of this data set is ENTITLED, includes the details for the product on AWS Marketplace.</p>
    public let originDetails: OriginDetails?
    /// <p>The data set ID of the owned data set corresponding to the entitled data set being viewed. This parameter is returned when a data set owner is viewing the entitled copy of its owned data set.</p>
    public let sourceId: String?
    /// <p>The tags for the data set.</p>
    public let tags: [String:String]?
    /// <p>The date and time that the data set was last updated, in ISO 8601 format.</p>
    public let updatedAt: Date?

    public init (
        arn: String? = nil,
        assetType: AssetType? = nil,
        createdAt: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        origin: Origin? = nil,
        originDetails: OriginDetails? = nil,
        sourceId: String? = nil,
        tags: [String:String]? = nil,
        updatedAt: Date? = nil
    )
    {
        self.arn = arn
        self.assetType = assetType
        self.createdAt = createdAt
        self.description = description
        self.id = id
        self.name = name
        self.origin = origin
        self.originDetails = originDetails
        self.sourceId = sourceId
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

struct GetDataSetOutputResponseBody: Equatable {
    public let arn: String?
    public let assetType: AssetType?
    public let createdAt: Date?
    public let description: String?
    public let id: String?
    public let name: String?
    public let origin: Origin?
    public let originDetails: OriginDetails?
    public let sourceId: String?
    public let tags: [String:String]?
    public let updatedAt: Date?
}

extension GetDataSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case assetType = "AssetType"
        case createdAt = "CreatedAt"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case origin = "Origin"
        case originDetails = "OriginDetails"
        case sourceId = "SourceId"
        case tags = "Tags"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let assetTypeDecoded = try containerValues.decodeIfPresent(AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let originDecoded = try containerValues.decodeIfPresent(Origin.self, forKey: .origin)
        origin = originDecoded
        let originDetailsDecoded = try containerValues.decodeIfPresent(OriginDetails.self, forKey: .originDetails)
        originDetails = originDetailsDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension GetJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobInput(jobId: \(String(describing: jobId)))"}
}

extension GetJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetJobInputHeadersMiddleware: Middleware {
    public let id: String = "GetJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobInput>
    public typealias MOutput = OperationOutput<GetJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobOutputError>
}

public struct GetJobInputQueryItemMiddleware: Middleware {
    public let id: String = "GetJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobInput>
    public typealias MOutput = OperationOutput<GetJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobOutputError>
}

public struct GetJobInput: Equatable {
    /// <p>The unique identifier for a job.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GetJobInputBody: Equatable {
}

extension GetJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJobOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobOutputResponse(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), details: \(String(describing: details)), errors: \(String(describing: errors)), id: \(String(describing: id)), state: \(String(describing: state)), type: \(String(describing: type)), updatedAt: \(String(describing: updatedAt)))"}
}

extension GetJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.details = output.details
            self.errors = output.errors
            self.id = output.id
            self.state = output.state
            self.type = output.type
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.createdAt = nil
            self.details = nil
            self.errors = nil
            self.id = nil
            self.state = nil
            self.type = nil
            self.updatedAt = nil
        }
    }
}

public struct GetJobOutputResponse: Equatable {
    /// <p>The ARN for the job.</p>
    public let arn: String?
    /// <p>The date and time that the job was created, in ISO 8601 format.</p>
    public let createdAt: Date?
    /// <p>Details about the job.</p>
    public let details: ResponseDetails?
    /// <p>The errors associated with jobs.</p>
    public let errors: [JobError]?
    /// <p>The unique identifier for the job.</p>
    public let id: String?
    /// <p>The state of the job.</p>
    public let state: State?
    /// <p>The job type.</p>
    public let type: `Type`?
    /// <p>The date and time that the job was last updated, in ISO 8601 format.</p>
    public let updatedAt: Date?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        details: ResponseDetails? = nil,
        errors: [JobError]? = nil,
        id: String? = nil,
        state: State? = nil,
        type: `Type`? = nil,
        updatedAt: Date? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.details = details
        self.errors = errors
        self.id = id
        self.state = state
        self.type = type
        self.updatedAt = updatedAt
    }
}

struct GetJobOutputResponseBody: Equatable {
    public let arn: String?
    public let createdAt: Date?
    public let details: ResponseDetails?
    public let errors: [JobError]?
    public let id: String?
    public let state: State?
    public let type: `Type`?
    public let updatedAt: Date?
}

extension GetJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case details = "Details"
        case errors = "Errors"
        case id = "Id"
        case state = "State"
        case type = "Type"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(ResponseDetails.self, forKey: .details)
        details = detailsDecoded
        let errorsContainer = try containerValues.decodeIfPresent([JobError?].self, forKey: .errors)
        var errorsDecoded0:[JobError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [JobError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let stateDecoded = try containerValues.decodeIfPresent(State.self, forKey: .state)
        state = stateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(`Type`.self, forKey: .type)
        type = typeDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension GetRevisionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRevisionInput(dataSetId: \(String(describing: dataSetId)), revisionId: \(String(describing: revisionId)))"}
}

extension GetRevisionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetRevisionInputHeadersMiddleware: Middleware {
    public let id: String = "GetRevisionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRevisionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRevisionInput>
    public typealias MOutput = OperationOutput<GetRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRevisionOutputError>
}

public struct GetRevisionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRevisionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRevisionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRevisionInput>
    public typealias MOutput = OperationOutput<GetRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRevisionOutputError>
}

public struct GetRevisionInput: Equatable {
    /// <p>The unique identifier for a data set.</p>
    public let dataSetId: String?
    /// <p>The unique identifier for a revision.</p>
    public let revisionId: String?

    public init (
        dataSetId: String? = nil,
        revisionId: String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.revisionId = revisionId
    }
}

struct GetRevisionInputBody: Equatable {
}

extension GetRevisionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetRevisionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRevisionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRevisionOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRevisionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRevisionOutputResponse(arn: \(String(describing: arn)), comment: \(String(describing: comment)), createdAt: \(String(describing: createdAt)), dataSetId: \(String(describing: dataSetId)), finalized: \(String(describing: finalized)), id: \(String(describing: id)), sourceId: \(String(describing: sourceId)), tags: \(String(describing: tags)), updatedAt: \(String(describing: updatedAt)))"}
}

extension GetRevisionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRevisionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.comment = output.comment
            self.createdAt = output.createdAt
            self.dataSetId = output.dataSetId
            self.finalized = output.finalized
            self.id = output.id
            self.sourceId = output.sourceId
            self.tags = output.tags
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.comment = nil
            self.createdAt = nil
            self.dataSetId = nil
            self.finalized = false
            self.id = nil
            self.sourceId = nil
            self.tags = nil
            self.updatedAt = nil
        }
    }
}

public struct GetRevisionOutputResponse: Equatable {
    /// <p>The ARN for the revision</p>
    public let arn: String?
    /// <p>An optional comment about the revision.</p>
    public let comment: String?
    /// <p>The date and time that the revision was created, in ISO 8601 format.</p>
    public let createdAt: Date?
    /// <p>The unique identifier for the data set associated with this revision.</p>
    public let dataSetId: String?
    /// <p>To publish a revision to a data set in a product, the revision must first be finalized. Finalizing a revision tells AWS Data Exchange that your changes to the assets in the revision are complete. After it's in this read-only state, you can publish the revision to your products.</p> <p>Finalized revisions can be published through the AWS Data Exchange console or the AWS Marketplace Catalog API, using the StartChangeSet AWS Marketplace Catalog API action. When using the API, revisions are uniquely identified by their ARN.</p>
    public let finalized: Bool
    /// <p>The unique identifier for the revision.</p>
    public let id: String?
    /// <p>The revision ID of the owned revision corresponding to the entitled revision being viewed. This parameter is returned when a revision owner is viewing the entitled copy of its owned revision.</p>
    public let sourceId: String?
    /// <p>The tags for the revision.</p>
    public let tags: [String:String]?
    /// <p>The date and time that the revision was last updated, in ISO 8601 format.</p>
    public let updatedAt: Date?

    public init (
        arn: String? = nil,
        comment: String? = nil,
        createdAt: Date? = nil,
        dataSetId: String? = nil,
        finalized: Bool = false,
        id: String? = nil,
        sourceId: String? = nil,
        tags: [String:String]? = nil,
        updatedAt: Date? = nil
    )
    {
        self.arn = arn
        self.comment = comment
        self.createdAt = createdAt
        self.dataSetId = dataSetId
        self.finalized = finalized
        self.id = id
        self.sourceId = sourceId
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

struct GetRevisionOutputResponseBody: Equatable {
    public let arn: String?
    public let comment: String?
    public let createdAt: Date?
    public let dataSetId: String?
    public let finalized: Bool
    public let id: String?
    public let sourceId: String?
    public let tags: [String:String]?
    public let updatedAt: Date?
}

extension GetRevisionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case comment = "Comment"
        case createdAt = "CreatedAt"
        case dataSetId = "DataSetId"
        case finalized = "Finalized"
        case id = "Id"
        case sourceId = "SourceId"
        case tags = "Tags"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let finalizedDecoded = try containerValues.decode(Bool.self, forKey: .finalized)
        finalized = finalizedDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension ImportAssetFromSignedUrlJobErrorDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assetName = "AssetName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetName = assetName {
            try encodeContainer.encode(assetName, forKey: .assetName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetName)
        assetName = assetNameDecoded
    }
}

extension ImportAssetFromSignedUrlJobErrorDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportAssetFromSignedUrlJobErrorDetails(assetName: \(String(describing: assetName)))"}
}

public struct ImportAssetFromSignedUrlJobErrorDetails: Equatable {
    /// <p>The name of the asset. When importing from Amazon S3, the S3 object key is used as the asset name. When exporting to Amazon S3, the asset name is used as default target S3 object key.</p>
    public let assetName: String?

    public init (
        assetName: String? = nil
    )
    {
        self.assetName = assetName
    }
}

extension ImportAssetFromSignedUrlRequestDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assetName = "AssetName"
        case dataSetId = "DataSetId"
        case md5Hash = "Md5Hash"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetName = assetName {
            try encodeContainer.encode(assetName, forKey: .assetName)
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let md5Hash = md5Hash {
            try encodeContainer.encode(md5Hash, forKey: .md5Hash)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetName)
        assetName = assetNameDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let md5HashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .md5Hash)
        md5Hash = md5HashDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension ImportAssetFromSignedUrlRequestDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportAssetFromSignedUrlRequestDetails(assetName: \(String(describing: assetName)), dataSetId: \(String(describing: dataSetId)), md5Hash: \(String(describing: md5Hash)), revisionId: \(String(describing: revisionId)))"}
}

/// <p>Details of the operation to be performed by the job.</p>
public struct ImportAssetFromSignedUrlRequestDetails: Equatable {
    /// <p>The name of the asset. When importing from Amazon S3, the S3 object key is used as the asset name.</p>
    public let assetName: String?
    /// <p>The unique identifier for the data set associated with this import job.</p>
    public let dataSetId: String?
    /// <p>The Base64-encoded Md5 hash for the asset, used to ensure the integrity of the file at that location.</p>
    public let md5Hash: String?
    /// <p>The unique identifier for the revision associated with this import request.</p>
    public let revisionId: String?

    public init (
        assetName: String? = nil,
        dataSetId: String? = nil,
        md5Hash: String? = nil,
        revisionId: String? = nil
    )
    {
        self.assetName = assetName
        self.dataSetId = dataSetId
        self.md5Hash = md5Hash
        self.revisionId = revisionId
    }
}

extension ImportAssetFromSignedUrlResponseDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assetName = "AssetName"
        case dataSetId = "DataSetId"
        case md5Hash = "Md5Hash"
        case revisionId = "RevisionId"
        case signedUrl = "SignedUrl"
        case signedUrlExpiresAt = "SignedUrlExpiresAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetName = assetName {
            try encodeContainer.encode(assetName, forKey: .assetName)
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let md5Hash = md5Hash {
            try encodeContainer.encode(md5Hash, forKey: .md5Hash)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let signedUrl = signedUrl {
            try encodeContainer.encode(signedUrl, forKey: .signedUrl)
        }
        if let signedUrlExpiresAt = signedUrlExpiresAt {
            try encodeContainer.encode(signedUrlExpiresAt.timeIntervalSince1970, forKey: .signedUrlExpiresAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetName)
        assetName = assetNameDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let md5HashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .md5Hash)
        md5Hash = md5HashDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let signedUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signedUrl)
        signedUrl = signedUrlDecoded
        let signedUrlExpiresAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .signedUrlExpiresAt)
        signedUrlExpiresAt = signedUrlExpiresAtDecoded
    }
}

extension ImportAssetFromSignedUrlResponseDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportAssetFromSignedUrlResponseDetails(assetName: \(String(describing: assetName)), dataSetId: \(String(describing: dataSetId)), md5Hash: \(String(describing: md5Hash)), revisionId: \(String(describing: revisionId)), signedUrl: \(String(describing: signedUrl)), signedUrlExpiresAt: \(String(describing: signedUrlExpiresAt)))"}
}

/// <p>The details in the response for an import request, including the signed URL and other information.</p>
public struct ImportAssetFromSignedUrlResponseDetails: Equatable {
    /// <p>The name for the asset associated with this import response.</p>
    public let assetName: String?
    /// <p>The unique identifier for the data set associated with this import job.</p>
    public let dataSetId: String?
    /// <p>The Base64-encoded Md5 hash for the asset, used to ensure the integrity of the file at that location.</p>
    public let md5Hash: String?
    /// <p>The unique identifier for the revision associated with this import response.</p>
    public let revisionId: String?
    /// <p>The signed URL.</p>
    public let signedUrl: String?
    /// <p>The time and date at which the signed URL expires, in ISO 8601 format.</p>
    public let signedUrlExpiresAt: Date?

    public init (
        assetName: String? = nil,
        dataSetId: String? = nil,
        md5Hash: String? = nil,
        revisionId: String? = nil,
        signedUrl: String? = nil,
        signedUrlExpiresAt: Date? = nil
    )
    {
        self.assetName = assetName
        self.dataSetId = dataSetId
        self.md5Hash = md5Hash
        self.revisionId = revisionId
        self.signedUrl = signedUrl
        self.signedUrlExpiresAt = signedUrlExpiresAt
    }
}

extension ImportAssetsFromS3RequestDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assetSources = "AssetSources"
        case dataSetId = "DataSetId"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetSources = assetSources {
            var assetSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetSources)
            for listofassetsourceentry0 in assetSources {
                try assetSourcesContainer.encode(listofassetsourceentry0)
            }
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetSourcesContainer = try containerValues.decodeIfPresent([AssetSourceEntry?].self, forKey: .assetSources)
        var assetSourcesDecoded0:[AssetSourceEntry]? = nil
        if let assetSourcesContainer = assetSourcesContainer {
            assetSourcesDecoded0 = [AssetSourceEntry]()
            for structure0 in assetSourcesContainer {
                if let structure0 = structure0 {
                    assetSourcesDecoded0?.append(structure0)
                }
            }
        }
        assetSources = assetSourcesDecoded0
        let dataSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension ImportAssetsFromS3RequestDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportAssetsFromS3RequestDetails(assetSources: \(String(describing: assetSources)), dataSetId: \(String(describing: dataSetId)), revisionId: \(String(describing: revisionId)))"}
}

/// <p>Details of the operation to be performed by the job.</p>
public struct ImportAssetsFromS3RequestDetails: Equatable {
    /// <p>Is a list of S3 bucket and object key pairs.</p>
    public let assetSources: [AssetSourceEntry]?
    /// <p>The unique identifier for the data set associated with this import job.</p>
    public let dataSetId: String?
    /// <p>The unique identifier for the revision associated with this import request.</p>
    public let revisionId: String?

    public init (
        assetSources: [AssetSourceEntry]? = nil,
        dataSetId: String? = nil,
        revisionId: String? = nil
    )
    {
        self.assetSources = assetSources
        self.dataSetId = dataSetId
        self.revisionId = revisionId
    }
}

extension ImportAssetsFromS3ResponseDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assetSources = "AssetSources"
        case dataSetId = "DataSetId"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetSources = assetSources {
            var assetSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetSources)
            for listofassetsourceentry0 in assetSources {
                try assetSourcesContainer.encode(listofassetsourceentry0)
            }
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetSourcesContainer = try containerValues.decodeIfPresent([AssetSourceEntry?].self, forKey: .assetSources)
        var assetSourcesDecoded0:[AssetSourceEntry]? = nil
        if let assetSourcesContainer = assetSourcesContainer {
            assetSourcesDecoded0 = [AssetSourceEntry]()
            for structure0 in assetSourcesContainer {
                if let structure0 = structure0 {
                    assetSourcesDecoded0?.append(structure0)
                }
            }
        }
        assetSources = assetSourcesDecoded0
        let dataSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension ImportAssetsFromS3ResponseDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportAssetsFromS3ResponseDetails(assetSources: \(String(describing: assetSources)), dataSetId: \(String(describing: dataSetId)), revisionId: \(String(describing: revisionId)))"}
}

/// <p>Details from an import from Amazon S3 response.</p>
public struct ImportAssetsFromS3ResponseDetails: Equatable {
    /// <p>Is a list of Amazon S3 bucket and object key pairs.</p>
    public let assetSources: [AssetSourceEntry]?
    /// <p>The unique identifier for the data set associated with this import job.</p>
    public let dataSetId: String?
    /// <p>The unique identifier for the revision associated with this import response.</p>
    public let revisionId: String?

    public init (
        assetSources: [AssetSourceEntry]? = nil,
        dataSetId: String? = nil,
        revisionId: String? = nil
    )
    {
        self.assetSources = assetSources
        self.dataSetId = dataSetId
        self.revisionId = revisionId
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An exception occurred with the service.
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// The message identifying the service exception that occurred.
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension JobEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case details = "Details"
        case errors = "Errors"
        case id = "Id"
        case state = "State"
        case type = "Type"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let details = details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for listofjoberror0 in errors {
                try errorsContainer.encode(listofjoberror0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(ResponseDetails.self, forKey: .details)
        details = detailsDecoded
        let errorsContainer = try containerValues.decodeIfPresent([JobError?].self, forKey: .errors)
        var errorsDecoded0:[JobError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [JobError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let stateDecoded = try containerValues.decodeIfPresent(State.self, forKey: .state)
        state = stateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(`Type`.self, forKey: .type)
        type = typeDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension JobEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobEntry(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), details: \(String(describing: details)), errors: \(String(describing: errors)), id: \(String(describing: id)), state: \(String(describing: state)), type: \(String(describing: type)), updatedAt: \(String(describing: updatedAt)))"}
}

/// AWS Data Exchange Jobs are asynchronous import or export operations used to create or copy assets. A data set owner can both import and export as they see fit. Someone with an entitlement to a data set can only export. Jobs are deleted 90 days after they are created.
public struct JobEntry: Equatable {
    /// <p>The ARN for the job.</p>
    public let arn: String?
    /// <p>The date and time that the job was created, in ISO 8601 format.</p>
    public let createdAt: Date?
    /// <p>Details of the operation to be performed by the job, such as export destination details or import source details.</p>
    public let details: ResponseDetails?
    /// <p>Errors for jobs.</p>
    public let errors: [JobError]?
    /// <p>The unique identifier for the job.</p>
    public let id: String?
    /// <p>The state of the job.</p>
    public let state: State?
    /// <p>The job type.</p>
    public let type: `Type`?
    /// <p>The date and time that the job was last updated, in ISO 8601 format.</p>
    public let updatedAt: Date?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        details: ResponseDetails? = nil,
        errors: [JobError]? = nil,
        id: String? = nil,
        state: State? = nil,
        type: `Type`? = nil,
        updatedAt: Date? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.details = details
        self.errors = errors
        self.id = id
        self.state = state
        self.type = type
        self.updatedAt = updatedAt
    }
}

extension JobError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case details = "Details"
        case limitName = "LimitName"
        case limitValue = "LimitValue"
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let details = details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let limitName = limitName {
            try encodeContainer.encode(limitName.rawValue, forKey: .limitName)
        }
        if limitValue != 0.0 {
            try encodeContainer.encode(limitValue, forKey: .limitValue)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Code.self, forKey: .code)
        code = codeDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(Details.self, forKey: .details)
        details = detailsDecoded
        let limitNameDecoded = try containerValues.decodeIfPresent(JobErrorLimitName.self, forKey: .limitName)
        limitName = limitNameDecoded
        let limitValueDecoded = try containerValues.decode(Double.self, forKey: .limitValue)
        limitValue = limitValueDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(JobErrorResourceTypes.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension JobError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobError(code: \(String(describing: code)), details: \(String(describing: details)), limitName: \(String(describing: limitName)), limitValue: \(String(describing: limitValue)), message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

/// An error that occurred with the job request.
public struct JobError: Equatable {
    /// The code for the job error.
    public let code: Code?
    public let details: Details?
    /// <p>The name of the limit that was reached.</p>
    public let limitName: JobErrorLimitName?
    /// The value of the exceeded limit.
    public let limitValue: Double
    /// The message related to the job error.
    public let message: String?
    /// The unique identifier for the resource related to the error.
    public let resourceId: String?
    /// The type of resource related to the error.
    public let resourceType: JobErrorResourceTypes?

    public init (
        code: Code? = nil,
        details: Details? = nil,
        limitName: JobErrorLimitName? = nil,
        limitValue: Double = 0.0,
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: JobErrorResourceTypes? = nil
    )
    {
        self.code = code
        self.details = details
        self.limitName = limitName
        self.limitValue = limitValue
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

/// The name of the limit that was reached.
public enum JobErrorLimitName {
    case assetSizeInGb
    case assetsPerRevision
    case sdkUnknown(String)
}

extension JobErrorLimitName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobErrorLimitName] {
        return [
            .assetSizeInGb,
            .assetsPerRevision,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .assetSizeInGb: return "Asset size in GB"
        case .assetsPerRevision: return "Assets per revision"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobErrorLimitName(rawValue: rawValue) ?? JobErrorLimitName.sdkUnknown(rawValue)
    }
}

/// The types of resource which the job error can apply to.
public enum JobErrorResourceTypes {
    case asset
    case revision
    case sdkUnknown(String)
}

extension JobErrorResourceTypes : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobErrorResourceTypes] {
        return [
            .asset,
            .revision,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .asset: return "ASSET"
        case .revision: return "REVISION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobErrorResourceTypes(rawValue: rawValue) ?? JobErrorResourceTypes.sdkUnknown(rawValue)
    }
}

public enum LimitName {
    case assetPerExportJobFromAmazonS3
    case assetSizeInGb
    case assetsPerImportJobFromAmazonS3
    case assetsPerRevision
    case concurrentInProgressJobsToExportAssetsToAmazonS3
    case concurrentInProgressJobsToExportAssetsToASignedUrl
    case concurrentInProgressJobsToImportAssetsFromAmazonS3
    case concurrentInProgressJobsToImportAssetsFromASignedUrl
    case dataSetsPerAccount
    case dataSetsPerProduct
    case productsPerAccount
    case revisionsPerDataSet
    case sdkUnknown(String)
}

extension LimitName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LimitName] {
        return [
            .assetPerExportJobFromAmazonS3,
            .assetSizeInGb,
            .assetsPerImportJobFromAmazonS3,
            .assetsPerRevision,
            .concurrentInProgressJobsToExportAssetsToAmazonS3,
            .concurrentInProgressJobsToExportAssetsToASignedUrl,
            .concurrentInProgressJobsToImportAssetsFromAmazonS3,
            .concurrentInProgressJobsToImportAssetsFromASignedUrl,
            .dataSetsPerAccount,
            .dataSetsPerProduct,
            .productsPerAccount,
            .revisionsPerDataSet,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .assetPerExportJobFromAmazonS3: return "Asset per export job from Amazon S3"
        case .assetSizeInGb: return "Asset size in GB"
        case .assetsPerImportJobFromAmazonS3: return "Assets per import job from Amazon S3"
        case .assetsPerRevision: return "Assets per revision"
        case .concurrentInProgressJobsToExportAssetsToAmazonS3: return "Concurrent in progress jobs to export assets to Amazon S3"
        case .concurrentInProgressJobsToExportAssetsToASignedUrl: return "Concurrent in progress jobs to export assets to a signed URL"
        case .concurrentInProgressJobsToImportAssetsFromAmazonS3: return "Concurrent in progress jobs to import assets from Amazon S3"
        case .concurrentInProgressJobsToImportAssetsFromASignedUrl: return "Concurrent in progress jobs to import assets from a signed URL"
        case .dataSetsPerAccount: return "Data sets per account"
        case .dataSetsPerProduct: return "Data sets per product"
        case .productsPerAccount: return "Products per account"
        case .revisionsPerDataSet: return "Revisions per data set"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LimitName(rawValue: rawValue) ?? LimitName.sdkUnknown(rawValue)
    }
}

extension ListDataSetRevisionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDataSetRevisionsInput(dataSetId: \(String(describing: dataSetId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDataSetRevisionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDataSetRevisionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDataSetRevisionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDataSetRevisionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDataSetRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDataSetRevisionsInput>
    public typealias MOutput = OperationOutput<ListDataSetRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDataSetRevisionsOutputError>
}

public struct ListDataSetRevisionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDataSetRevisionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDataSetRevisionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDataSetRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDataSetRevisionsInput>
    public typealias MOutput = OperationOutput<ListDataSetRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDataSetRevisionsOutputError>
}

public struct ListDataSetRevisionsInput: Equatable {
    /// <p>The unique identifier for a data set.</p>
    public let dataSetId: String?
    /// <p>The maximum number of results returned by a single call.</p>
    public let maxResults: Int
    /// <p>The token value retrieved from a previous call to access the next page of results.</p>
    public let nextToken: String?

    public init (
        dataSetId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataSetRevisionsInputBody: Equatable {
}

extension ListDataSetRevisionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDataSetRevisionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataSetRevisionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDataSetRevisionsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataSetRevisionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDataSetRevisionsOutputResponse(nextToken: \(String(describing: nextToken)), revisions: \(String(describing: revisions)))"}
}

extension ListDataSetRevisionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDataSetRevisionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.revisions = output.revisions
        } else {
            self.nextToken = nil
            self.revisions = nil
        }
    }
}

public struct ListDataSetRevisionsOutputResponse: Equatable {
    /// <p>The token value retrieved from a previous call to access the next page of results.</p>
    public let nextToken: String?
    /// <p>The asset objects listed by the request.</p>
    public let revisions: [RevisionEntry]?

    public init (
        nextToken: String? = nil,
        revisions: [RevisionEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.revisions = revisions
    }
}

struct ListDataSetRevisionsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let revisions: [RevisionEntry]?
}

extension ListDataSetRevisionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case revisions = "Revisions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let revisionsContainer = try containerValues.decodeIfPresent([RevisionEntry?].self, forKey: .revisions)
        var revisionsDecoded0:[RevisionEntry]? = nil
        if let revisionsContainer = revisionsContainer {
            revisionsDecoded0 = [RevisionEntry]()
            for structure0 in revisionsContainer {
                if let structure0 = structure0 {
                    revisionsDecoded0?.append(structure0)
                }
            }
        }
        revisions = revisionsDecoded0
    }
}

extension ListDataSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDataSetsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), origin: \(String(describing: origin)))"}
}

extension ListDataSetsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDataSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDataSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDataSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDataSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDataSetsInput>
    public typealias MOutput = OperationOutput<ListDataSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDataSetsOutputError>
}

public struct ListDataSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDataSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDataSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDataSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let origin = input.operationInput.origin {
            let originQueryItem = URLQueryItem(name: "origin".urlPercentEncoding(), value: String(origin).urlPercentEncoding())
            input.builder.withQueryItem(originQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDataSetsInput>
    public typealias MOutput = OperationOutput<ListDataSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDataSetsOutputError>
}

public struct ListDataSetsInput: Equatable {
    /// <p>The maximum number of results returned by a single call.</p>
    public let maxResults: Int
    /// <p>The token value retrieved from a previous call to access the next page of results.</p>
    public let nextToken: String?
    /// <p>A property that defines the data set as OWNED by the account (for providers) or ENTITLED to the account (for subscribers).</p>
    public let origin: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        origin: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.origin = origin
    }
}

struct ListDataSetsInputBody: Equatable {
}

extension ListDataSetsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDataSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDataSetsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDataSetsOutputResponse(dataSets: \(String(describing: dataSets)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDataSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDataSetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataSets = output.dataSets
            self.nextToken = output.nextToken
        } else {
            self.dataSets = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataSetsOutputResponse: Equatable {
    /// <p>The data set objects listed by the request.</p>
    public let dataSets: [DataSetEntry]?
    /// <p>The token value retrieved from a previous call to access the next page of results.</p>
    public let nextToken: String?

    public init (
        dataSets: [DataSetEntry]? = nil,
        nextToken: String? = nil
    )
    {
        self.dataSets = dataSets
        self.nextToken = nextToken
    }
}

struct ListDataSetsOutputResponseBody: Equatable {
    public let dataSets: [DataSetEntry]?
    public let nextToken: String?
}

extension ListDataSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataSets = "DataSets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetsContainer = try containerValues.decodeIfPresent([DataSetEntry?].self, forKey: .dataSets)
        var dataSetsDecoded0:[DataSetEntry]? = nil
        if let dataSetsContainer = dataSetsContainer {
            dataSetsDecoded0 = [DataSetEntry]()
            for structure0 in dataSetsContainer {
                if let structure0 = structure0 {
                    dataSetsDecoded0?.append(structure0)
                }
            }
        }
        dataSets = dataSetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobsInput(dataSetId: \(String(describing: dataSetId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), revisionId: \(String(describing: revisionId)))"}
}

extension ListJobsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobsInput>
    public typealias MOutput = OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobsOutputError>
}

public struct ListJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        if let dataSetId = input.operationInput.dataSetId {
            let dataSetIdQueryItem = URLQueryItem(name: "dataSetId".urlPercentEncoding(), value: String(dataSetId).urlPercentEncoding())
            input.builder.withQueryItem(dataSetIdQueryItem)
        }
        if let revisionId = input.operationInput.revisionId {
            let revisionIdQueryItem = URLQueryItem(name: "revisionId".urlPercentEncoding(), value: String(revisionId).urlPercentEncoding())
            input.builder.withQueryItem(revisionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobsInput>
    public typealias MOutput = OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobsOutputError>
}

public struct ListJobsInput: Equatable {
    /// <p>The unique identifier for a data set.</p>
    public let dataSetId: String?
    /// <p>The maximum number of results returned by a single call.</p>
    public let maxResults: Int
    /// <p>The token value retrieved from a previous call to access the next page of results.</p>
    public let nextToken: String?
    /// <p>The unique identifier for a revision.</p>
    public let revisionId: String?

    public init (
        dataSetId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        revisionId: String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.revisionId = revisionId
    }
}

struct ListJobsInputBody: Equatable {
}

extension ListJobsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJobsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobsOutputResponse(jobs: \(String(describing: jobs)), nextToken: \(String(describing: nextToken)))"}
}

extension ListJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobsOutputResponse: Equatable {
    /// <p>The jobs listed by the request.</p>
    public let jobs: [JobEntry]?
    /// <p>The token value retrieved from a previous call to access the next page of results.</p>
    public let nextToken: String?

    public init (
        jobs: [JobEntry]? = nil,
        nextToken: String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListJobsOutputResponseBody: Equatable {
    public let jobs: [JobEntry]?
    public let nextToken: String?
}

extension ListJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobs = "Jobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([JobEntry?].self, forKey: .jobs)
        var jobsDecoded0:[JobEntry]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [JobEntry]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRevisionAssetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRevisionAssetsInput(dataSetId: \(String(describing: dataSetId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), revisionId: \(String(describing: revisionId)))"}
}

extension ListRevisionAssetsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListRevisionAssetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListRevisionAssetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRevisionAssetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRevisionAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRevisionAssetsInput>
    public typealias MOutput = OperationOutput<ListRevisionAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRevisionAssetsOutputError>
}

public struct ListRevisionAssetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRevisionAssetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRevisionAssetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRevisionAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRevisionAssetsInput>
    public typealias MOutput = OperationOutput<ListRevisionAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRevisionAssetsOutputError>
}

public struct ListRevisionAssetsInput: Equatable {
    /// <p>The unique identifier for a data set.</p>
    public let dataSetId: String?
    /// <p>The maximum number of results returned by a single call.</p>
    public let maxResults: Int
    /// <p>The token value retrieved from a previous call to access the next page of results.</p>
    public let nextToken: String?
    /// <p>The unique identifier for a revision.</p>
    public let revisionId: String?

    public init (
        dataSetId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        revisionId: String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.revisionId = revisionId
    }
}

struct ListRevisionAssetsInputBody: Equatable {
}

extension ListRevisionAssetsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListRevisionAssetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRevisionAssetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRevisionAssetsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRevisionAssetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRevisionAssetsOutputResponse(assets: \(String(describing: assets)), nextToken: \(String(describing: nextToken)))"}
}

extension ListRevisionAssetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRevisionAssetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assets = output.assets
            self.nextToken = output.nextToken
        } else {
            self.assets = nil
            self.nextToken = nil
        }
    }
}

public struct ListRevisionAssetsOutputResponse: Equatable {
    /// <p>The asset objects listed by the request.</p>
    public let assets: [AssetEntry]?
    /// <p>The token value retrieved from a previous call to access the next page of results.</p>
    public let nextToken: String?

    public init (
        assets: [AssetEntry]? = nil,
        nextToken: String? = nil
    )
    {
        self.assets = assets
        self.nextToken = nextToken
    }
}

struct ListRevisionAssetsOutputResponseBody: Equatable {
    public let assets: [AssetEntry]?
    public let nextToken: String?
}

extension ListRevisionAssetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assets = "Assets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetsContainer = try containerValues.decodeIfPresent([AssetEntry?].self, forKey: .assets)
        var assetsDecoded0:[AssetEntry]? = nil
        if let assetsContainer = assetsContainer {
            assetsDecoded0 = [AssetEntry]()
            for structure0 in assetsContainer {
                if let structure0 = structure0 {
                    assetsDecoded0?.append(structure0)
                }
            }
        }
        assets = assetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies an AWS resource.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// A label that consists of a customer-defined key and an optional value.
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

/// <p>A property that defines the data set as OWNED by the account (for providers) or ENTITLED to the account (for subscribers). When an owned data set is published in a product, AWS Data Exchange creates a copy of the data set. Subscribers can access that copy of the data set as an entitled data set.</p>
public enum Origin {
    case entitled
    case owned
    case sdkUnknown(String)
}

extension Origin : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Origin] {
        return [
            .entitled,
            .owned,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .entitled: return "ENTITLED"
        case .owned: return "OWNED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Origin(rawValue: rawValue) ?? Origin.sdkUnknown(rawValue)
    }
}

extension OriginDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case productId = "ProductId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
    }
}

extension OriginDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OriginDetails(productId: \(String(describing: productId)))"}
}

public struct OriginDetails: Equatable {
    public let productId: String?

    public init (
        productId: String? = nil
    )
    {
        self.productId = productId
    }
}

extension RequestDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exportAssetToSignedUrl = "ExportAssetToSignedUrl"
        case exportAssetsToS3 = "ExportAssetsToS3"
        case exportRevisionsToS3 = "ExportRevisionsToS3"
        case importAssetFromSignedUrl = "ImportAssetFromSignedUrl"
        case importAssetsFromS3 = "ImportAssetsFromS3"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportAssetToSignedUrl = exportAssetToSignedUrl {
            try encodeContainer.encode(exportAssetToSignedUrl, forKey: .exportAssetToSignedUrl)
        }
        if let exportAssetsToS3 = exportAssetsToS3 {
            try encodeContainer.encode(exportAssetsToS3, forKey: .exportAssetsToS3)
        }
        if let exportRevisionsToS3 = exportRevisionsToS3 {
            try encodeContainer.encode(exportRevisionsToS3, forKey: .exportRevisionsToS3)
        }
        if let importAssetFromSignedUrl = importAssetFromSignedUrl {
            try encodeContainer.encode(importAssetFromSignedUrl, forKey: .importAssetFromSignedUrl)
        }
        if let importAssetsFromS3 = importAssetsFromS3 {
            try encodeContainer.encode(importAssetsFromS3, forKey: .importAssetsFromS3)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportAssetToSignedUrlDecoded = try containerValues.decodeIfPresent(ExportAssetToSignedUrlRequestDetails.self, forKey: .exportAssetToSignedUrl)
        exportAssetToSignedUrl = exportAssetToSignedUrlDecoded
        let exportAssetsToS3Decoded = try containerValues.decodeIfPresent(ExportAssetsToS3RequestDetails.self, forKey: .exportAssetsToS3)
        exportAssetsToS3 = exportAssetsToS3Decoded
        let exportRevisionsToS3Decoded = try containerValues.decodeIfPresent(ExportRevisionsToS3RequestDetails.self, forKey: .exportRevisionsToS3)
        exportRevisionsToS3 = exportRevisionsToS3Decoded
        let importAssetFromSignedUrlDecoded = try containerValues.decodeIfPresent(ImportAssetFromSignedUrlRequestDetails.self, forKey: .importAssetFromSignedUrl)
        importAssetFromSignedUrl = importAssetFromSignedUrlDecoded
        let importAssetsFromS3Decoded = try containerValues.decodeIfPresent(ImportAssetsFromS3RequestDetails.self, forKey: .importAssetsFromS3)
        importAssetsFromS3 = importAssetsFromS3Decoded
    }
}

extension RequestDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestDetails(exportAssetToSignedUrl: \(String(describing: exportAssetToSignedUrl)), exportAssetsToS3: \(String(describing: exportAssetsToS3)), exportRevisionsToS3: \(String(describing: exportRevisionsToS3)), importAssetFromSignedUrl: \(String(describing: importAssetFromSignedUrl)), importAssetsFromS3: \(String(describing: importAssetsFromS3)))"}
}

/// <p>The details for the request.</p>
public struct RequestDetails: Equatable {
    /// <p>Details about the export to signed URL request.</p>
    public let exportAssetToSignedUrl: ExportAssetToSignedUrlRequestDetails?
    /// <p>Details about the export to Amazon S3 request.</p>
    public let exportAssetsToS3: ExportAssetsToS3RequestDetails?
    /// <p>Details about the export to Amazon S3 request.</p>
    public let exportRevisionsToS3: ExportRevisionsToS3RequestDetails?
    /// <p>Details about the import from signed URL request.</p>
    public let importAssetFromSignedUrl: ImportAssetFromSignedUrlRequestDetails?
    /// <p>Details about the import from Amazon S3 request.</p>
    public let importAssetsFromS3: ImportAssetsFromS3RequestDetails?

    public init (
        exportAssetToSignedUrl: ExportAssetToSignedUrlRequestDetails? = nil,
        exportAssetsToS3: ExportAssetsToS3RequestDetails? = nil,
        exportRevisionsToS3: ExportRevisionsToS3RequestDetails? = nil,
        importAssetFromSignedUrl: ImportAssetFromSignedUrlRequestDetails? = nil,
        importAssetsFromS3: ImportAssetsFromS3RequestDetails? = nil
    )
    {
        self.exportAssetToSignedUrl = exportAssetToSignedUrl
        self.exportAssetsToS3 = exportAssetsToS3
        self.exportRevisionsToS3 = exportRevisionsToS3
        self.importAssetFromSignedUrl = importAssetFromSignedUrl
        self.importAssetsFromS3 = importAssetsFromS3
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource couldn't be found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The resource couldn't be found.</p>
    public var message: String?
    /// <p>The unique identifier for the resource that couldn't be found.</p>
    public var resourceId: String?
    /// <p>The type of resource that couldn't be found.</p>
    public var resourceType: ResourceType?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: ResourceType?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public enum ResourceType {
    case asset
    case dataSet
    case job
    case revision
    case sdkUnknown(String)
}

extension ResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceType] {
        return [
            .asset,
            .dataSet,
            .job,
            .revision,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .asset: return "ASSET"
        case .dataSet: return "DATA_SET"
        case .job: return "JOB"
        case .revision: return "REVISION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
    }
}

extension ResponseDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exportAssetToSignedUrl = "ExportAssetToSignedUrl"
        case exportAssetsToS3 = "ExportAssetsToS3"
        case exportRevisionsToS3 = "ExportRevisionsToS3"
        case importAssetFromSignedUrl = "ImportAssetFromSignedUrl"
        case importAssetsFromS3 = "ImportAssetsFromS3"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportAssetToSignedUrl = exportAssetToSignedUrl {
            try encodeContainer.encode(exportAssetToSignedUrl, forKey: .exportAssetToSignedUrl)
        }
        if let exportAssetsToS3 = exportAssetsToS3 {
            try encodeContainer.encode(exportAssetsToS3, forKey: .exportAssetsToS3)
        }
        if let exportRevisionsToS3 = exportRevisionsToS3 {
            try encodeContainer.encode(exportRevisionsToS3, forKey: .exportRevisionsToS3)
        }
        if let importAssetFromSignedUrl = importAssetFromSignedUrl {
            try encodeContainer.encode(importAssetFromSignedUrl, forKey: .importAssetFromSignedUrl)
        }
        if let importAssetsFromS3 = importAssetsFromS3 {
            try encodeContainer.encode(importAssetsFromS3, forKey: .importAssetsFromS3)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportAssetToSignedUrlDecoded = try containerValues.decodeIfPresent(ExportAssetToSignedUrlResponseDetails.self, forKey: .exportAssetToSignedUrl)
        exportAssetToSignedUrl = exportAssetToSignedUrlDecoded
        let exportAssetsToS3Decoded = try containerValues.decodeIfPresent(ExportAssetsToS3ResponseDetails.self, forKey: .exportAssetsToS3)
        exportAssetsToS3 = exportAssetsToS3Decoded
        let exportRevisionsToS3Decoded = try containerValues.decodeIfPresent(ExportRevisionsToS3ResponseDetails.self, forKey: .exportRevisionsToS3)
        exportRevisionsToS3 = exportRevisionsToS3Decoded
        let importAssetFromSignedUrlDecoded = try containerValues.decodeIfPresent(ImportAssetFromSignedUrlResponseDetails.self, forKey: .importAssetFromSignedUrl)
        importAssetFromSignedUrl = importAssetFromSignedUrlDecoded
        let importAssetsFromS3Decoded = try containerValues.decodeIfPresent(ImportAssetsFromS3ResponseDetails.self, forKey: .importAssetsFromS3)
        importAssetsFromS3 = importAssetsFromS3Decoded
    }
}

extension ResponseDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResponseDetails(exportAssetToSignedUrl: \(String(describing: exportAssetToSignedUrl)), exportAssetsToS3: \(String(describing: exportAssetsToS3)), exportRevisionsToS3: \(String(describing: exportRevisionsToS3)), importAssetFromSignedUrl: \(String(describing: importAssetFromSignedUrl)), importAssetsFromS3: \(String(describing: importAssetsFromS3)))"}
}

/// <p>Details for the response.</p>
public struct ResponseDetails: Equatable {
    /// <p>Details for the export to signed URL response.</p>
    public let exportAssetToSignedUrl: ExportAssetToSignedUrlResponseDetails?
    /// <p>Details for the export to Amazon S3 response.</p>
    public let exportAssetsToS3: ExportAssetsToS3ResponseDetails?
    /// <p>Details for the export revisions to Amazon S3 response.</p>
    public let exportRevisionsToS3: ExportRevisionsToS3ResponseDetails?
    /// <p>Details for the import from signed URL response.</p>
    public let importAssetFromSignedUrl: ImportAssetFromSignedUrlResponseDetails?
    /// <p>Details for the import from Amazon S3 response.</p>
    public let importAssetsFromS3: ImportAssetsFromS3ResponseDetails?

    public init (
        exportAssetToSignedUrl: ExportAssetToSignedUrlResponseDetails? = nil,
        exportAssetsToS3: ExportAssetsToS3ResponseDetails? = nil,
        exportRevisionsToS3: ExportRevisionsToS3ResponseDetails? = nil,
        importAssetFromSignedUrl: ImportAssetFromSignedUrlResponseDetails? = nil,
        importAssetsFromS3: ImportAssetsFromS3ResponseDetails? = nil
    )
    {
        self.exportAssetToSignedUrl = exportAssetToSignedUrl
        self.exportAssetsToS3 = exportAssetsToS3
        self.exportRevisionsToS3 = exportRevisionsToS3
        self.importAssetFromSignedUrl = importAssetFromSignedUrl
        self.importAssetsFromS3 = importAssetsFromS3
    }
}

extension RevisionDestinationEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case keyPattern = "KeyPattern"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let keyPattern = keyPattern {
            try encodeContainer.encode(keyPattern, forKey: .keyPattern)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyPattern)
        keyPattern = keyPatternDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension RevisionDestinationEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevisionDestinationEntry(bucket: \(String(describing: bucket)), keyPattern: \(String(describing: keyPattern)), revisionId: \(String(describing: revisionId)))"}
}

/// <p>The destination where the assets in the revision will be exported.</p>
public struct RevisionDestinationEntry: Equatable {
    /// <p>The S3 bucket that is the destination for the assets in the revision.</p>
    public let bucket: String?
    /// <p>A string representing the pattern for generated names of the individual assets in the revision. For more information about key patterns, see <a href="https://docs.aws.amazon.com/data-exchange/latest/userguide/jobs.html#revision-export-keypatterns">Key patterns when exporting revisions</a>.</p>
    public let keyPattern: String?
    /// <p>The unique identifier for the revision.</p>
    public let revisionId: String?

    public init (
        bucket: String? = nil,
        keyPattern: String? = nil,
        revisionId: String? = nil
    )
    {
        self.bucket = bucket
        self.keyPattern = keyPattern
        self.revisionId = revisionId
    }
}

extension RevisionEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case comment = "Comment"
        case createdAt = "CreatedAt"
        case dataSetId = "DataSetId"
        case finalized = "Finalized"
        case id = "Id"
        case sourceId = "SourceId"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let dataSetId = dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if finalized != false {
            try encodeContainer.encode(finalized, forKey: .finalized)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let sourceId = sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let finalizedDecoded = try containerValues.decode(Bool.self, forKey: .finalized)
        finalized = finalizedDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension RevisionEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevisionEntry(arn: \(String(describing: arn)), comment: \(String(describing: comment)), createdAt: \(String(describing: createdAt)), dataSetId: \(String(describing: dataSetId)), finalized: \(String(describing: finalized)), id: \(String(describing: id)), sourceId: \(String(describing: sourceId)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>A revision is a container for one or more assets.</p>
public struct RevisionEntry: Equatable {
    /// <p>The ARN for the revision.</p>
    public let arn: String?
    /// <p>An optional comment about the revision.</p>
    public let comment: String?
    /// <p>The date and time that the revision was created, in ISO 8601 format.</p>
    public let createdAt: Date?
    /// <p>The unique identifier for the data set associated with this revision.</p>
    public let dataSetId: String?
    /// <p>To publish a revision to a data set in a product, the revision must first be finalized. Finalizing a revision tells AWS Data Exchange that your changes to the assets in the revision are complete. After it's in this read-only state, you can publish the revision to your products.</p> <p>Finalized revisions can be published through the AWS Data Exchange console or the AWS Marketplace Catalog API, using the StartChangeSet AWS Marketplace Catalog API action. When using the API, revisions are uniquely identified by their ARN.</p>
    public let finalized: Bool
    /// <p>The unique identifier for the revision.</p>
    public let id: String?
    /// <p>The revision ID of the owned revision corresponding to the entitled revision being viewed. This parameter is returned when a revision owner is viewing the entitled copy of its owned revision.</p>
    public let sourceId: String?
    /// <p>The date and time that the revision was last updated, in ISO 8601 format.</p>
    public let updatedAt: Date?

    public init (
        arn: String? = nil,
        comment: String? = nil,
        createdAt: Date? = nil,
        dataSetId: String? = nil,
        finalized: Bool = false,
        id: String? = nil,
        sourceId: String? = nil,
        updatedAt: Date? = nil
    )
    {
        self.arn = arn
        self.comment = comment
        self.createdAt = createdAt
        self.dataSetId = dataSetId
        self.finalized = finalized
        self.id = id
        self.sourceId = sourceId
        self.updatedAt = updatedAt
    }
}

extension S3SnapshotAsset: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case size = "Size"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if size != 0.0 {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeDecoded = try containerValues.decode(Double.self, forKey: .size)
        size = sizeDecoded
    }
}

extension S3SnapshotAsset: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3SnapshotAsset(size: \(String(describing: size)))"}
}

/// <p>The S3 object that is the asset.</p>
public struct S3SnapshotAsset: Equatable {
    /// <p>The size of the S3 object that is the object.</p>
    public let size: Double

    public init (
        size: Double = 0.0
    )
    {
        self.size = size
    }
}

/// <p>The types of encryption supported in export jobs to Amazon S3.</p>
public enum ServerSideEncryptionTypes {
    case aes256
    case awsKms
    case sdkUnknown(String)
}

extension ServerSideEncryptionTypes : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServerSideEncryptionTypes] {
        return [
            .aes256,
            .awsKms,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aes256: return "AES256"
        case .awsKms: return "aws:kms"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServerSideEncryptionTypes(rawValue: rawValue) ?? ServerSideEncryptionTypes.sdkUnknown(rawValue)
    }
}

extension ServiceLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceLimitExceededException(limitName: \(String(describing: limitName)), limitValue: \(String(describing: limitValue)), message: \(String(describing: message)))"}
}

extension ServiceLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.limitName = output.limitName
            self.limitValue = output.limitValue
            self.message = output.message
        } else {
            self.limitName = nil
            self.limitValue = 0.0
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request has exceeded the quotas imposed by the service.</p>
public struct ServiceLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The name of the quota that was exceeded.</p>
    public var limitName: LimitName?
    /// <p>The maximum value for the service-specific limit.</p>
    public var limitValue: Double
    /// <p>The request has exceeded the quotas imposed by the service.</p>
    public var message: String?

    public init (
        limitName: LimitName? = nil,
        limitValue: Double = 0.0,
        message: String? = nil
    )
    {
        self.limitName = limitName
        self.limitValue = limitValue
        self.message = message
    }
}

struct ServiceLimitExceededExceptionBody: Equatable {
    public let limitName: LimitName?
    public let limitValue: Double
    public let message: String?
}

extension ServiceLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limitName = "LimitName"
        case limitValue = "LimitValue"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitNameDecoded = try containerValues.decodeIfPresent(LimitName.self, forKey: .limitName)
        limitName = limitNameDecoded
        let limitValueDecoded = try containerValues.decode(Double.self, forKey: .limitValue)
        limitValue = limitValueDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartJobInput(jobId: \(String(describing: jobId)))"}
}

extension StartJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct StartJobInputHeadersMiddleware: Middleware {
    public let id: String = "StartJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartJobInput>
    public typealias MOutput = OperationOutput<StartJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartJobOutputError>
}

public struct StartJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartJobInput>
    public typealias MOutput = OperationOutput<StartJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartJobOutputError>
}

public struct StartJobInput: Equatable {
    /// <p>The unique identifier for a job.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartJobInputBody: Equatable {
}

extension StartJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StartJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartJobOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartJobOutputResponse()"}
}

extension StartJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StartJobOutputResponse: Equatable {

    public init() {}
}

struct StartJobOutputResponseBody: Equatable {
}

extension StartJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum State {
    case cancelled
    case completed
    case error
    case inProgress
    case timedOut
    case waiting
    case sdkUnknown(String)
}

extension State : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [State] {
        return [
            .cancelled,
            .completed,
            .error,
            .inProgress,
            .timedOut,
            .waiting,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "CANCELLED"
        case .completed: return "COMPLETED"
        case .error: return "ERROR"
        case .inProgress: return "IN_PROGRESS"
        case .timedOut: return "TIMED_OUT"
        case .waiting: return "WAITING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = State(rawValue: rawValue) ?? State.sdkUnknown(rawValue)
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapof__string0) in tags {
                try tagsContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

/// <p>The request body for TagResource.</p>
public struct TagResourceInput: Equatable {
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies an AWS resource.</p>
    public let resourceArn: String?
    /// A label that consists of a customer-defined key and an optional value.
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The limit on the number of requests per second was exceeded.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The limit on the number of requests per second was exceeded.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum `Type` {
    case exportAssetsToS3
    case exportAssetToSignedUrl
    case exportRevisionsToS3
    case importAssetsFromS3
    case importAssetFromSignedUrl
    case sdkUnknown(String)
}

extension `Type` : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [`Type`] {
        return [
            .exportAssetsToS3,
            .exportAssetToSignedUrl,
            .exportRevisionsToS3,
            .importAssetsFromS3,
            .importAssetFromSignedUrl,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .exportAssetsToS3: return "EXPORT_ASSETS_TO_S3"
        case .exportAssetToSignedUrl: return "EXPORT_ASSET_TO_SIGNED_URL"
        case .exportRevisionsToS3: return "EXPORT_REVISIONS_TO_S3"
        case .importAssetsFromS3: return "IMPORT_ASSETS_FROM_S3"
        case .importAssetFromSignedUrl: return "IMPORT_ASSET_FROM_SIGNED_URL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = `Type`(rawValue: rawValue) ?? `Type`.sdkUnknown(rawValue)
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>An Amazon Resource Name (ARN) that uniquely identifies an AWS resource.</p>
    public let resourceArn: String?
    /// The key tags.
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateAssetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAssetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssetInput>
    public typealias MOutput = OperationOutput<UpdateAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssetOutputError>
}

extension UpdateAssetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssetInput(assetId: \(String(describing: assetId)), dataSetId: \(String(describing: dataSetId)), name: \(String(describing: name)), revisionId: \(String(describing: revisionId)))"}
}

extension UpdateAssetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateAssetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAssetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssetInput>
    public typealias MOutput = OperationOutput<UpdateAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssetOutputError>
}

public struct UpdateAssetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAssetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssetInput>
    public typealias MOutput = OperationOutput<UpdateAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssetOutputError>
}

/// <p>The request body for UpdateAsset.</p>
public struct UpdateAssetInput: Equatable {
    /// <p>The unique identifier for an asset.</p>
    public let assetId: String?
    /// <p>The unique identifier for a data set.</p>
    public let dataSetId: String?
    /// <p>The name of the asset. When importing from Amazon S3, the S3 object key is used as the asset name. When exporting to Amazon S3, the asset name is used as default target S3 object key.</p>
    public let name: String?
    /// <p>The unique identifier for a revision.</p>
    public let revisionId: String?

    public init (
        assetId: String? = nil,
        dataSetId: String? = nil,
        name: String? = nil,
        revisionId: String? = nil
    )
    {
        self.assetId = assetId
        self.dataSetId = dataSetId
        self.name = name
        self.revisionId = revisionId
    }
}

struct UpdateAssetInputBody: Equatable {
    public let name: String?
}

extension UpdateAssetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateAssetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAssetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssetOutputResponse(arn: \(String(describing: arn)), assetDetails: \(String(describing: assetDetails)), assetType: \(String(describing: assetType)), createdAt: \(String(describing: createdAt)), dataSetId: \(String(describing: dataSetId)), id: \(String(describing: id)), name: \(String(describing: name)), revisionId: \(String(describing: revisionId)), sourceId: \(String(describing: sourceId)), updatedAt: \(String(describing: updatedAt)))"}
}

extension UpdateAssetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAssetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.assetDetails = output.assetDetails
            self.assetType = output.assetType
            self.createdAt = output.createdAt
            self.dataSetId = output.dataSetId
            self.id = output.id
            self.name = output.name
            self.revisionId = output.revisionId
            self.sourceId = output.sourceId
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.assetDetails = nil
            self.assetType = nil
            self.createdAt = nil
            self.dataSetId = nil
            self.id = nil
            self.name = nil
            self.revisionId = nil
            self.sourceId = nil
            self.updatedAt = nil
        }
    }
}

public struct UpdateAssetOutputResponse: Equatable {
    /// <p>The ARN for the asset.</p>
    public let arn: String?
    /// <p>Information about the asset, including its size.</p>
    public let assetDetails: AssetDetails?
    /// <p>The type of file your data is stored in. Currently, the supported asset type is S3_SNAPSHOT.</p>
    public let assetType: AssetType?
    /// <p>The date and time that the asset was created, in ISO 8601 format.</p>
    public let createdAt: Date?
    /// <p>The unique identifier for the data set associated with this asset.</p>
    public let dataSetId: String?
    /// <p>The unique identifier for the asset.</p>
    public let id: String?
    /// <p>The name of the asset When importing from Amazon S3, the S3 object key is used as the asset name. When exporting to Amazon S3, the asset name is used as default target S3 object key.</p>
    public let name: String?
    /// <p>The unique identifier for the revision associated with this asset.</p>
    public let revisionId: String?
    /// <p>The asset ID of the owned asset corresponding to the entitled asset being viewed. This parameter is returned when an asset owner is viewing the entitled copy of its owned asset.</p>
    public let sourceId: String?
    /// <p>The date and time that the asset was last updated, in ISO 8601 format.</p>
    public let updatedAt: Date?

    public init (
        arn: String? = nil,
        assetDetails: AssetDetails? = nil,
        assetType: AssetType? = nil,
        createdAt: Date? = nil,
        dataSetId: String? = nil,
        id: String? = nil,
        name: String? = nil,
        revisionId: String? = nil,
        sourceId: String? = nil,
        updatedAt: Date? = nil
    )
    {
        self.arn = arn
        self.assetDetails = assetDetails
        self.assetType = assetType
        self.createdAt = createdAt
        self.dataSetId = dataSetId
        self.id = id
        self.name = name
        self.revisionId = revisionId
        self.sourceId = sourceId
        self.updatedAt = updatedAt
    }
}

struct UpdateAssetOutputResponseBody: Equatable {
    public let arn: String?
    public let assetDetails: AssetDetails?
    public let assetType: AssetType?
    public let createdAt: Date?
    public let dataSetId: String?
    public let id: String?
    public let name: String?
    public let revisionId: String?
    public let sourceId: String?
    public let updatedAt: Date?
}

extension UpdateAssetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case assetDetails = "AssetDetails"
        case assetType = "AssetType"
        case createdAt = "CreatedAt"
        case dataSetId = "DataSetId"
        case id = "Id"
        case name = "Name"
        case revisionId = "RevisionId"
        case sourceId = "SourceId"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let assetDetailsDecoded = try containerValues.decodeIfPresent(AssetDetails.self, forKey: .assetDetails)
        assetDetails = assetDetailsDecoded
        let assetTypeDecoded = try containerValues.decodeIfPresent(AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

public struct UpdateDataSetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDataSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataSetInput>
    public typealias MOutput = OperationOutput<UpdateDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataSetOutputError>
}

extension UpdateDataSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDataSetInput(dataSetId: \(String(describing: dataSetId)), description: \(String(describing: description)), name: \(String(describing: name)))"}
}

extension UpdateDataSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateDataSetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDataSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataSetInput>
    public typealias MOutput = OperationOutput<UpdateDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataSetOutputError>
}

public struct UpdateDataSetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDataSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataSetInput>
    public typealias MOutput = OperationOutput<UpdateDataSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataSetOutputError>
}

/// <p>The request body for UpdateDataSet.</p>
public struct UpdateDataSetInput: Equatable {
    /// <p>The unique identifier for a data set.</p>
    public let dataSetId: String?
    /// <p>The description for the data set.</p>
    public let description: String?
    /// <p>The name of the data set.</p>
    public let name: String?

    public init (
        dataSetId: String? = nil,
        description: String? = nil,
        name: String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.description = description
        self.name = name
    }
}

struct UpdateDataSetInputBody: Equatable {
    public let description: String?
    public let name: String?
}

extension UpdateDataSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateDataSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDataSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDataSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDataSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDataSetOutputResponse(arn: \(String(describing: arn)), assetType: \(String(describing: assetType)), createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), origin: \(String(describing: origin)), originDetails: \(String(describing: originDetails)), sourceId: \(String(describing: sourceId)), updatedAt: \(String(describing: updatedAt)))"}
}

extension UpdateDataSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDataSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.assetType = output.assetType
            self.createdAt = output.createdAt
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.origin = output.origin
            self.originDetails = output.originDetails
            self.sourceId = output.sourceId
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.assetType = nil
            self.createdAt = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.origin = nil
            self.originDetails = nil
            self.sourceId = nil
            self.updatedAt = nil
        }
    }
}

public struct UpdateDataSetOutputResponse: Equatable {
    /// <p>The ARN for the data set.</p>
    public let arn: String?
    /// <p>The type of file your data is stored in. Currently, the supported asset type is S3_SNAPSHOT.</p>
    public let assetType: AssetType?
    /// <p>The date and time that the data set was created, in ISO 8601 format.</p>
    public let createdAt: Date?
    /// <p>The description for the data set.</p>
    public let description: String?
    /// <p>The unique identifier for the data set.</p>
    public let id: String?
    /// <p>The name of the data set.</p>
    public let name: String?
    /// <p>A property that defines the data set as OWNED by the account (for providers) or ENTITLED to the account (for subscribers).</p>
    public let origin: Origin?
    /// <p>If the origin of this data set is ENTITLED, includes the details for the product on AWS Marketplace.</p>
    public let originDetails: OriginDetails?
    /// <p>The data set ID of the owned data set corresponding to the entitled data set being viewed. This parameter is returned when a data set owner is viewing the entitled copy of its owned data set.</p>
    public let sourceId: String?
    /// <p>The date and time that the data set was last updated, in ISO 8601 format.</p>
    public let updatedAt: Date?

    public init (
        arn: String? = nil,
        assetType: AssetType? = nil,
        createdAt: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        origin: Origin? = nil,
        originDetails: OriginDetails? = nil,
        sourceId: String? = nil,
        updatedAt: Date? = nil
    )
    {
        self.arn = arn
        self.assetType = assetType
        self.createdAt = createdAt
        self.description = description
        self.id = id
        self.name = name
        self.origin = origin
        self.originDetails = originDetails
        self.sourceId = sourceId
        self.updatedAt = updatedAt
    }
}

struct UpdateDataSetOutputResponseBody: Equatable {
    public let arn: String?
    public let assetType: AssetType?
    public let createdAt: Date?
    public let description: String?
    public let id: String?
    public let name: String?
    public let origin: Origin?
    public let originDetails: OriginDetails?
    public let sourceId: String?
    public let updatedAt: Date?
}

extension UpdateDataSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case assetType = "AssetType"
        case createdAt = "CreatedAt"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case origin = "Origin"
        case originDetails = "OriginDetails"
        case sourceId = "SourceId"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let assetTypeDecoded = try containerValues.decodeIfPresent(AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let originDecoded = try containerValues.decodeIfPresent(Origin.self, forKey: .origin)
        origin = originDecoded
        let originDetailsDecoded = try containerValues.decodeIfPresent(OriginDetails.self, forKey: .originDetails)
        originDetails = originDetailsDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

public struct UpdateRevisionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRevisionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRevisionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRevisionInput>
    public typealias MOutput = OperationOutput<UpdateRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRevisionOutputError>
}

extension UpdateRevisionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRevisionInput(comment: \(String(describing: comment)), dataSetId: \(String(describing: dataSetId)), finalized: \(String(describing: finalized)), revisionId: \(String(describing: revisionId)))"}
}

extension UpdateRevisionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comment = "Comment"
        case finalized = "Finalized"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if finalized != false {
            try encodeContainer.encode(finalized, forKey: .finalized)
        }
    }
}

public struct UpdateRevisionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRevisionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRevisionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRevisionInput>
    public typealias MOutput = OperationOutput<UpdateRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRevisionOutputError>
}

public struct UpdateRevisionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRevisionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRevisionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRevisionInput>
    public typealias MOutput = OperationOutput<UpdateRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRevisionOutputError>
}

/// <p>The request body for UpdateRevision.</p>
public struct UpdateRevisionInput: Equatable {
    /// <p>An optional comment about the revision.</p>
    public let comment: String?
    /// <p>The unique identifier for a data set.</p>
    public let dataSetId: String?
    /// <p>Finalizing a revision tells AWS Data Exchange that your changes to the assets in the revision are complete. After it's in this read-only state, you can publish the revision to your products.</p>
    public let finalized: Bool
    /// <p>The unique identifier for a revision.</p>
    public let revisionId: String?

    public init (
        comment: String? = nil,
        dataSetId: String? = nil,
        finalized: Bool = false,
        revisionId: String? = nil
    )
    {
        self.comment = comment
        self.dataSetId = dataSetId
        self.finalized = finalized
        self.revisionId = revisionId
    }
}

struct UpdateRevisionInputBody: Equatable {
    public let comment: String?
    public let finalized: Bool
}

extension UpdateRevisionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case comment = "Comment"
        case finalized = "Finalized"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let finalizedDecoded = try containerValues.decode(Bool.self, forKey: .finalized)
        finalized = finalizedDecoded
    }
}

extension UpdateRevisionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRevisionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRevisionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRevisionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRevisionOutputResponse(arn: \(String(describing: arn)), comment: \(String(describing: comment)), createdAt: \(String(describing: createdAt)), dataSetId: \(String(describing: dataSetId)), finalized: \(String(describing: finalized)), id: \(String(describing: id)), sourceId: \(String(describing: sourceId)), updatedAt: \(String(describing: updatedAt)))"}
}

extension UpdateRevisionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateRevisionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.comment = output.comment
            self.createdAt = output.createdAt
            self.dataSetId = output.dataSetId
            self.finalized = output.finalized
            self.id = output.id
            self.sourceId = output.sourceId
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.comment = nil
            self.createdAt = nil
            self.dataSetId = nil
            self.finalized = false
            self.id = nil
            self.sourceId = nil
            self.updatedAt = nil
        }
    }
}

public struct UpdateRevisionOutputResponse: Equatable {
    /// <p>The ARN for the revision.</p>
    public let arn: String?
    /// <p>An optional comment about the revision.</p>
    public let comment: String?
    /// <p>The date and time that the revision was created, in ISO 8601 format.</p>
    public let createdAt: Date?
    /// <p>The unique identifier for the data set associated with this revision.</p>
    public let dataSetId: String?
    /// <p>To publish a revision to a data set in a product, the revision must first be finalized. Finalizing a revision tells AWS Data Exchange that changes to the assets in the revision are complete. After it's in this read-only state, you can publish the revision to your products.</p> <p>Finalized revisions can be published through the AWS Data Exchange console or the AWS Marketplace Catalog API, using the StartChangeSet AWS Marketplace Catalog API action. When using the API, revisions are uniquely identified by their ARN.</p>
    public let finalized: Bool
    /// <p>The unique identifier for the revision.</p>
    public let id: String?
    /// <p>The revision ID of the owned revision corresponding to the entitled revision being viewed. This parameter is returned when a revision owner is viewing the entitled copy of its owned revision.</p>
    public let sourceId: String?
    /// <p>The date and time that the revision was last updated, in ISO 8601 format.</p>
    public let updatedAt: Date?

    public init (
        arn: String? = nil,
        comment: String? = nil,
        createdAt: Date? = nil,
        dataSetId: String? = nil,
        finalized: Bool = false,
        id: String? = nil,
        sourceId: String? = nil,
        updatedAt: Date? = nil
    )
    {
        self.arn = arn
        self.comment = comment
        self.createdAt = createdAt
        self.dataSetId = dataSetId
        self.finalized = finalized
        self.id = id
        self.sourceId = sourceId
        self.updatedAt = updatedAt
    }
}

struct UpdateRevisionOutputResponseBody: Equatable {
    public let arn: String?
    public let comment: String?
    public let createdAt: Date?
    public let dataSetId: String?
    public let finalized: Bool
    public let id: String?
    public let sourceId: String?
    public let updatedAt: Date?
}

extension UpdateRevisionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case comment = "Comment"
        case createdAt = "CreatedAt"
        case dataSetId = "DataSetId"
        case finalized = "Finalized"
        case id = "Id"
        case sourceId = "SourceId"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let finalizedDecoded = try containerValues.decode(Bool.self, forKey: .finalized)
        finalized = finalizedDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was invalid.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message that informs you about what was invalid about the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
