// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

/// <p>The region of the S3 bucket that AWS delivers the report into.</p>
public enum AWSRegion {
    case bahrain
    case beijing
    case canadaCentral
    case capeTown
    case frankfurt
    case hongKong
    case ireland
    case london
    case milano
    case mumbai
    case ningxia
    case northernCalifornia
    case ohio
    case oregon
    case osaka
    case paris
    case saoPaulo
    case seoul
    case singapore
    case stockholm
    case sydney
    case tokyo
    case usStandard
    case sdkUnknown(String)
}

extension AWSRegion : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AWSRegion] {
        return [
            .bahrain,
            .beijing,
            .canadaCentral,
            .capeTown,
            .frankfurt,
            .hongKong,
            .ireland,
            .london,
            .milano,
            .mumbai,
            .ningxia,
            .northernCalifornia,
            .ohio,
            .oregon,
            .osaka,
            .paris,
            .saoPaulo,
            .seoul,
            .singapore,
            .stockholm,
            .sydney,
            .tokyo,
            .usStandard,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bahrain: return "me-south-1"
        case .beijing: return "cn-north-1"
        case .canadaCentral: return "ca-central-1"
        case .capeTown: return "af-south-1"
        case .frankfurt: return "eu-central-1"
        case .hongKong: return "ap-east-1"
        case .ireland: return "eu-west-1"
        case .london: return "eu-west-2"
        case .milano: return "eu-south-1"
        case .mumbai: return "ap-south-1"
        case .ningxia: return "cn-northwest-1"
        case .northernCalifornia: return "us-west-1"
        case .ohio: return "us-east-2"
        case .oregon: return "us-west-2"
        case .osaka: return "ap-northeast-3"
        case .paris: return "eu-west-3"
        case .saoPaulo: return "sa-east-1"
        case .seoul: return "ap-northeast-2"
        case .singapore: return "ap-southeast-1"
        case .stockholm: return "eu-north-1"
        case .sydney: return "ap-southeast-2"
        case .tokyo: return "ap-northeast-1"
        case .usStandard: return "us-east-1"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AWSRegion(rawValue: rawValue) ?? AWSRegion.sdkUnknown(rawValue)
    }
}

/// <p>The types of manifest that you want AWS to create for this report.</p>
public enum AdditionalArtifact {
    case athena
    case quicksight
    case redshift
    case sdkUnknown(String)
}

extension AdditionalArtifact : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AdditionalArtifact] {
        return [
            .athena,
            .quicksight,
            .redshift,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .athena: return "ATHENA"
        case .quicksight: return "QUICKSIGHT"
        case .redshift: return "REDSHIFT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AdditionalArtifact(rawValue: rawValue) ?? AdditionalArtifact.sdkUnknown(rawValue)
    }
}

/// <p>The compression format that AWS uses for the report.</p>
public enum CompressionFormat {
    case gzip
    case parquet
    case zip
    case sdkUnknown(String)
}

extension CompressionFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CompressionFormat] {
        return [
            .gzip,
            .parquet,
            .zip,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .gzip: return "GZIP"
        case .parquet: return "Parquet"
        case .zip: return "ZIP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CompressionFormat(rawValue: rawValue) ?? CompressionFormat.sdkUnknown(rawValue)
    }
}

public struct DeleteReportDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteReportDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReportDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReportDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReportDefinitionOutputError>
}

extension DeleteReportDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReportDefinitionInput(reportName: \(String(describing: reportName)))"}
}

extension DeleteReportDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reportName = "ReportName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reportName = reportName {
            try encodeContainer.encode(reportName, forKey: .reportName)
        }
    }
}

public struct DeleteReportDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteReportDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReportDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReportDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReportDefinitionOutputError>
}

public struct DeleteReportDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteReportDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReportDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReportDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReportDefinitionOutputError>
}

/// <p>Deletes the specified report.</p>
public struct DeleteReportDefinitionInput: Equatable {
    /// <p>The name of the report that you want to delete. The name must be unique, is case sensitive, and can't include spaces.</p>
    public let reportName: String?

    public init (
        reportName: String? = nil
    )
    {
        self.reportName = reportName
    }
}

struct DeleteReportDefinitionInputBody: Equatable {
    public let reportName: String?
}

extension DeleteReportDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reportName = "ReportName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportName)
        reportName = reportNameDecoded
    }
}

extension DeleteReportDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReportDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteReportDefinitionOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReportDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReportDefinitionOutputResponse(responseMessage: \(String(describing: responseMessage)))"}
}

extension DeleteReportDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteReportDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.responseMessage = output.responseMessage
        } else {
            self.responseMessage = nil
        }
    }
}

/// <p>If the action is successful, the service sends back an HTTP 200 response.</p>
public struct DeleteReportDefinitionOutputResponse: Equatable {
    /// <p>Whether the deletion was successful or not.</p>
    public let responseMessage: String?

    public init (
        responseMessage: String? = nil
    )
    {
        self.responseMessage = responseMessage
    }
}

struct DeleteReportDefinitionOutputResponseBody: Equatable {
    public let responseMessage: String?
}

extension DeleteReportDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case responseMessage = "ResponseMessage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .responseMessage)
        responseMessage = responseMessageDecoded
    }
}

public struct DescribeReportDefinitionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeReportDefinitionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReportDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReportDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReportDefinitionsInput>
    public typealias MOutput = OperationOutput<DescribeReportDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReportDefinitionsOutputError>
}

extension DescribeReportDefinitionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReportDefinitionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeReportDefinitionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeReportDefinitionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeReportDefinitionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReportDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReportDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReportDefinitionsInput>
    public typealias MOutput = OperationOutput<DescribeReportDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReportDefinitionsOutputError>
}

public struct DescribeReportDefinitionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeReportDefinitionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReportDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReportDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReportDefinitionsInput>
    public typealias MOutput = OperationOutput<DescribeReportDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReportDefinitionsOutputError>
}

/// <p>Requests a list of AWS Cost and Usage reports owned by the account.</p>
public struct DescribeReportDefinitionsInput: Equatable {
    /// <p>The maximum number of results that AWS returns for the operation.</p>
    public let maxResults: Int?
    /// <p>A generic string.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeReportDefinitionsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeReportDefinitionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeReportDefinitionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReportDefinitionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReportDefinitionsOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReportDefinitionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReportDefinitionsOutputResponse(nextToken: \(String(describing: nextToken)), reportDefinitions: \(String(describing: reportDefinitions)))"}
}

extension DescribeReportDefinitionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeReportDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.reportDefinitions = output.reportDefinitions
        } else {
            self.nextToken = nil
            self.reportDefinitions = nil
        }
    }
}

/// <p>If the action is successful, the service sends back an HTTP 200 response.</p>
public struct DescribeReportDefinitionsOutputResponse: Equatable {
    /// <p>A generic string.</p>
    public let nextToken: String?
    /// <p>A list of AWS Cost and Usage reports owned by the account.</p>
    public let reportDefinitions: [ReportDefinition]?

    public init (
        nextToken: String? = nil,
        reportDefinitions: [ReportDefinition]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportDefinitions = reportDefinitions
    }
}

struct DescribeReportDefinitionsOutputResponseBody: Equatable {
    public let reportDefinitions: [ReportDefinition]?
    public let nextToken: String?
}

extension DescribeReportDefinitionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case reportDefinitions = "ReportDefinitions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportDefinitionsContainer = try containerValues.decodeIfPresent([ReportDefinition?].self, forKey: .reportDefinitions)
        var reportDefinitionsDecoded0:[ReportDefinition]? = nil
        if let reportDefinitionsContainer = reportDefinitionsContainer {
            reportDefinitionsDecoded0 = [ReportDefinition]()
            for structure0 in reportDefinitionsContainer {
                if let structure0 = structure0 {
                    reportDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        reportDefinitions = reportDefinitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DuplicateReportNameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DuplicateReportNameException(message: \(String(describing: message)))"}
}

extension DuplicateReportNameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DuplicateReportNameExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A report with the specified name already exists in the account. Specify a different report name.</p>
public struct DuplicateReportNameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message to show the detail of the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateReportNameExceptionBody: Equatable {
    public let message: String?
}

extension DuplicateReportNameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalErrorException(message: \(String(describing: message)))"}
}

extension InternalErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An error on the server occurred during the processing of your request. Try again later.</p>
public struct InternalErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>A message to show the detail of the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalErrorExceptionBody: Equatable {
    public let message: String?
}

extension InternalErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ModifyReportDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "ModifyReportDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyReportDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyReportDefinitionInput>
    public typealias MOutput = OperationOutput<ModifyReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyReportDefinitionOutputError>
}

extension ModifyReportDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyReportDefinitionInput(reportDefinition: \(String(describing: reportDefinition)), reportName: \(String(describing: reportName)))"}
}

extension ModifyReportDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reportDefinition = "ReportDefinition"
        case reportName = "ReportName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reportDefinition = reportDefinition {
            try encodeContainer.encode(reportDefinition, forKey: .reportDefinition)
        }
        if let reportName = reportName {
            try encodeContainer.encode(reportName, forKey: .reportName)
        }
    }
}

public struct ModifyReportDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyReportDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyReportDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyReportDefinitionInput>
    public typealias MOutput = OperationOutput<ModifyReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyReportDefinitionOutputError>
}

public struct ModifyReportDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyReportDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyReportDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyReportDefinitionInput>
    public typealias MOutput = OperationOutput<ModifyReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyReportDefinitionOutputError>
}

public struct ModifyReportDefinitionInput: Equatable {
    /// <p>The definition of AWS Cost and Usage Report. You can specify the report name,
    ///          time unit, report format, compression format, S3 bucket, additional artifacts, and schema
    ///          elements in the definition.
    ///     </p>
    public let reportDefinition: ReportDefinition?
    /// <p>The name of the report that you want to create. The name must be unique,
    ///         is case sensitive, and can't include spaces. </p>
    public let reportName: String?

    public init (
        reportDefinition: ReportDefinition? = nil,
        reportName: String? = nil
    )
    {
        self.reportDefinition = reportDefinition
        self.reportName = reportName
    }
}

struct ModifyReportDefinitionInputBody: Equatable {
    public let reportName: String?
    public let reportDefinition: ReportDefinition?
}

extension ModifyReportDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reportDefinition = "ReportDefinition"
        case reportName = "ReportName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportName)
        reportName = reportNameDecoded
        let reportDefinitionDecoded = try containerValues.decodeIfPresent(ReportDefinition.self, forKey: .reportDefinition)
        reportDefinition = reportDefinitionDecoded
    }
}

extension ModifyReportDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyReportDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyReportDefinitionOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyReportDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyReportDefinitionOutputResponse()"}
}

extension ModifyReportDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ModifyReportDefinitionOutputResponse: Equatable {

    public init() {}
}

struct ModifyReportDefinitionOutputResponseBody: Equatable {
}

extension ModifyReportDefinitionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutReportDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "PutReportDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutReportDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutReportDefinitionInput>
    public typealias MOutput = OperationOutput<PutReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutReportDefinitionOutputError>
}

extension PutReportDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutReportDefinitionInput(reportDefinition: \(String(describing: reportDefinition)))"}
}

extension PutReportDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reportDefinition = "ReportDefinition"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reportDefinition = reportDefinition {
            try encodeContainer.encode(reportDefinition, forKey: .reportDefinition)
        }
    }
}

public struct PutReportDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "PutReportDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutReportDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutReportDefinitionInput>
    public typealias MOutput = OperationOutput<PutReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutReportDefinitionOutputError>
}

public struct PutReportDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "PutReportDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutReportDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutReportDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutReportDefinitionInput>
    public typealias MOutput = OperationOutput<PutReportDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutReportDefinitionOutputError>
}

/// <p>Creates a Cost and Usage Report.</p>
public struct PutReportDefinitionInput: Equatable {
    /// <p>Represents the output of the PutReportDefinition operation. The content consists of the detailed
    ///       metadata and data file information. </p>
    public let reportDefinition: ReportDefinition?

    public init (
        reportDefinition: ReportDefinition? = nil
    )
    {
        self.reportDefinition = reportDefinition
    }
}

struct PutReportDefinitionInputBody: Equatable {
    public let reportDefinition: ReportDefinition?
}

extension PutReportDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reportDefinition = "ReportDefinition"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportDefinitionDecoded = try containerValues.decodeIfPresent(ReportDefinition.self, forKey: .reportDefinition)
        reportDefinition = reportDefinitionDecoded
    }
}

extension PutReportDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutReportDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateReportNameException" : self = .duplicateReportNameException(try DuplicateReportNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReportLimitReachedException" : self = .reportLimitReachedException(try ReportLimitReachedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutReportDefinitionOutputError: Equatable {
    case duplicateReportNameException(DuplicateReportNameException)
    case internalErrorException(InternalErrorException)
    case reportLimitReachedException(ReportLimitReachedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutReportDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutReportDefinitionOutputResponse()"}
}

extension PutReportDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>If the action is successful, the service sends back an HTTP 200 response with an empty HTTP body.</p>
public struct PutReportDefinitionOutputResponse: Equatable {

    public init() {}
}

struct PutReportDefinitionOutputResponseBody: Equatable {
}

extension PutReportDefinitionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ReportDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalArtifacts = "AdditionalArtifacts"
        case additionalSchemaElements = "AdditionalSchemaElements"
        case billingViewArn = "BillingViewArn"
        case compression = "Compression"
        case format = "Format"
        case refreshClosedReports = "RefreshClosedReports"
        case reportName = "ReportName"
        case reportVersioning = "ReportVersioning"
        case s3Bucket = "S3Bucket"
        case s3Prefix = "S3Prefix"
        case s3Region = "S3Region"
        case timeUnit = "TimeUnit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalArtifacts = additionalArtifacts {
            var additionalArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalArtifacts)
            for additionalartifactlist0 in additionalArtifacts {
                try additionalArtifactsContainer.encode(additionalartifactlist0.rawValue)
            }
        }
        if let additionalSchemaElements = additionalSchemaElements {
            var additionalSchemaElementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalSchemaElements)
            for schemaelementlist0 in additionalSchemaElements {
                try additionalSchemaElementsContainer.encode(schemaelementlist0.rawValue)
            }
        }
        if let billingViewArn = billingViewArn {
            try encodeContainer.encode(billingViewArn, forKey: .billingViewArn)
        }
        if let compression = compression {
            try encodeContainer.encode(compression.rawValue, forKey: .compression)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let refreshClosedReports = refreshClosedReports {
            try encodeContainer.encode(refreshClosedReports, forKey: .refreshClosedReports)
        }
        if let reportName = reportName {
            try encodeContainer.encode(reportName, forKey: .reportName)
        }
        if let reportVersioning = reportVersioning {
            try encodeContainer.encode(reportVersioning.rawValue, forKey: .reportVersioning)
        }
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Prefix = s3Prefix {
            try encodeContainer.encode(s3Prefix, forKey: .s3Prefix)
        }
        if let s3Region = s3Region {
            try encodeContainer.encode(s3Region.rawValue, forKey: .s3Region)
        }
        if let timeUnit = timeUnit {
            try encodeContainer.encode(timeUnit.rawValue, forKey: .timeUnit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportName)
        reportName = reportNameDecoded
        let timeUnitDecoded = try containerValues.decodeIfPresent(TimeUnit.self, forKey: .timeUnit)
        timeUnit = timeUnitDecoded
        let formatDecoded = try containerValues.decodeIfPresent(ReportFormat.self, forKey: .format)
        format = formatDecoded
        let compressionDecoded = try containerValues.decodeIfPresent(CompressionFormat.self, forKey: .compression)
        compression = compressionDecoded
        let additionalSchemaElementsContainer = try containerValues.decodeIfPresent([SchemaElement?].self, forKey: .additionalSchemaElements)
        var additionalSchemaElementsDecoded0:[SchemaElement]? = nil
        if let additionalSchemaElementsContainer = additionalSchemaElementsContainer {
            additionalSchemaElementsDecoded0 = [SchemaElement]()
            for string0 in additionalSchemaElementsContainer {
                if let string0 = string0 {
                    additionalSchemaElementsDecoded0?.append(string0)
                }
            }
        }
        additionalSchemaElements = additionalSchemaElementsDecoded0
        let s3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
        let s3RegionDecoded = try containerValues.decodeIfPresent(AWSRegion.self, forKey: .s3Region)
        s3Region = s3RegionDecoded
        let additionalArtifactsContainer = try containerValues.decodeIfPresent([AdditionalArtifact?].self, forKey: .additionalArtifacts)
        var additionalArtifactsDecoded0:[AdditionalArtifact]? = nil
        if let additionalArtifactsContainer = additionalArtifactsContainer {
            additionalArtifactsDecoded0 = [AdditionalArtifact]()
            for string0 in additionalArtifactsContainer {
                if let string0 = string0 {
                    additionalArtifactsDecoded0?.append(string0)
                }
            }
        }
        additionalArtifacts = additionalArtifactsDecoded0
        let refreshClosedReportsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .refreshClosedReports)
        refreshClosedReports = refreshClosedReportsDecoded
        let reportVersioningDecoded = try containerValues.decodeIfPresent(ReportVersioning.self, forKey: .reportVersioning)
        reportVersioning = reportVersioningDecoded
        let billingViewArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .billingViewArn)
        billingViewArn = billingViewArnDecoded
    }
}

extension ReportDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReportDefinition(additionalArtifacts: \(String(describing: additionalArtifacts)), additionalSchemaElements: \(String(describing: additionalSchemaElements)), billingViewArn: \(String(describing: billingViewArn)), compression: \(String(describing: compression)), format: \(String(describing: format)), refreshClosedReports: \(String(describing: refreshClosedReports)), reportName: \(String(describing: reportName)), reportVersioning: \(String(describing: reportVersioning)), s3Bucket: \(String(describing: s3Bucket)), s3Prefix: \(String(describing: s3Prefix)), s3Region: \(String(describing: s3Region)), timeUnit: \(String(describing: timeUnit)))"}
}

/// <p>The definition of AWS Cost and Usage Report. You can specify the report name,
///          time unit, report format, compression format, S3 bucket, additional artifacts, and schema
///          elements in the definition.
///     </p>
public struct ReportDefinition: Equatable {
    /// <p>A list of manifests that you want Amazon Web Services to create for this report.</p>
    public let additionalArtifacts: [AdditionalArtifact]?
    /// <p>A list of strings that indicate additional content that Amazon Web Services includes in the report, such as individual resource IDs. </p>
    public let additionalSchemaElements: [SchemaElement]?
    /// <p>
    ///       The Amazon resource name of the billing view. You can get this value by using the billing view service public APIs.
    ///     </p>
    public let billingViewArn: String?
    /// <p>The compression format that AWS uses for the report.</p>
    public let compression: CompressionFormat?
    /// <p>The format that AWS saves the report in.</p>
    public let format: ReportFormat?
    /// <p>Whether you want Amazon Web Services to update your reports after they have been finalized if Amazon Web Services detects charges related to
    ///       previous months. These charges can include refunds, credits, or support fees.</p>
    public let refreshClosedReports: Bool?
    /// <p>The name of the report that you want to create. The name must be unique,
    ///         is case sensitive, and can't include spaces. </p>
    public let reportName: String?
    /// <p>Whether you want Amazon Web Services to overwrite the previous version of each report or
    ///          to deliver the report in addition to the previous versions.</p>
    public let reportVersioning: ReportVersioning?
    /// <p>The S3 bucket where AWS delivers the report.</p>
    public let s3Bucket: String?
    /// <p>The prefix that AWS adds to the report name when AWS delivers the report. Your prefix
    ///         can't include spaces.</p>
    public let s3Prefix: String?
    /// <p>The region of the S3 bucket that AWS delivers the report into.</p>
    public let s3Region: AWSRegion?
    /// <p>The length of time covered by the report. </p>
    public let timeUnit: TimeUnit?

    public init (
        additionalArtifacts: [AdditionalArtifact]? = nil,
        additionalSchemaElements: [SchemaElement]? = nil,
        billingViewArn: String? = nil,
        compression: CompressionFormat? = nil,
        format: ReportFormat? = nil,
        refreshClosedReports: Bool? = nil,
        reportName: String? = nil,
        reportVersioning: ReportVersioning? = nil,
        s3Bucket: String? = nil,
        s3Prefix: String? = nil,
        s3Region: AWSRegion? = nil,
        timeUnit: TimeUnit? = nil
    )
    {
        self.additionalArtifacts = additionalArtifacts
        self.additionalSchemaElements = additionalSchemaElements
        self.billingViewArn = billingViewArn
        self.compression = compression
        self.format = format
        self.refreshClosedReports = refreshClosedReports
        self.reportName = reportName
        self.reportVersioning = reportVersioning
        self.s3Bucket = s3Bucket
        self.s3Prefix = s3Prefix
        self.s3Region = s3Region
        self.timeUnit = timeUnit
    }
}

/// <p>The format that AWS saves the report in.</p>
public enum ReportFormat {
    case csv
    case parquet
    case sdkUnknown(String)
}

extension ReportFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReportFormat] {
        return [
            .csv,
            .parquet,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .csv: return "textORcsv"
        case .parquet: return "Parquet"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReportFormat(rawValue: rawValue) ?? ReportFormat.sdkUnknown(rawValue)
    }
}

extension ReportLimitReachedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReportLimitReachedException(message: \(String(describing: message)))"}
}

extension ReportLimitReachedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ReportLimitReachedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This account already has five reports defined. To define a new report, you must delete an existing report.</p>
public struct ReportLimitReachedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message to show the detail of the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReportLimitReachedExceptionBody: Equatable {
    public let message: String?
}

extension ReportLimitReachedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ReportVersioning {
    case createNewReport
    case overwriteReport
    case sdkUnknown(String)
}

extension ReportVersioning : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReportVersioning] {
        return [
            .createNewReport,
            .overwriteReport,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createNewReport: return "CREATE_NEW_REPORT"
        case .overwriteReport: return "OVERWRITE_REPORT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReportVersioning(rawValue: rawValue) ?? ReportVersioning.sdkUnknown(rawValue)
    }
}

/// <p>Whether or not AWS includes resource IDs in the report. </p>
public enum SchemaElement {
    case resources
    case sdkUnknown(String)
}

extension SchemaElement : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SchemaElement] {
        return [
            .resources,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .resources: return "RESOURCES"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SchemaElement(rawValue: rawValue) ?? SchemaElement.sdkUnknown(rawValue)
    }
}

/// <p>The length of time covered by the report. </p>
public enum TimeUnit {
    case daily
    case hourly
    case monthly
    case sdkUnknown(String)
}

extension TimeUnit : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TimeUnit] {
        return [
            .daily,
            .hourly,
            .monthly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .daily: return "DAILY"
        case .hourly: return "HOURLY"
        case .monthly: return "MONTHLY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TimeUnit(rawValue: rawValue) ?? TimeUnit.sdkUnknown(rawValue)
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The input fails to satisfy the constraints specified by an AWS service.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A message to show the detail of the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
